{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/GroupSummary.js", "../../../../Grid/lib/Grid/util/TableExporter.js", "../../../../Grid/lib/Grid/util/BooleanUnicodeSymbol.js", "../../../../Grid/lib/Grid/feature/experimental/ExcelExporter.js"],
  "sourcesContent": ["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport SummaryFormatter from './mixin/SummaryFormatter.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/GroupSummary\n */\n\n/**\n * Displays a summary row as a group footer in a grouped grid. Uses same configuration options on columns as\n * {@link Grid.feature.Summary}.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```javascript\n * features : {\n *     group        : 'city',\n *     groupSummary : true\n * }\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/groupsummary\n * @classtype groupSummary\n * @feature\n *\n * @inlineexample Grid/feature/GroupSummary.js\n */\nexport default class GroupSummary extends SummaryFormatter(InstancePlugin) {\n    //region Init\n\n    static get $name() {\n        return 'GroupSummary';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Set to `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @member {Boolean} collapseToHeader\n             */\n            /**\n             * Configure as `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            collapseToHeader : true\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @config {Boolean}\n             */\n            collapseToHeader : null,\n\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * @member {'header'|'footer'} target\n             */\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            target : 'header'\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * @config {'header'|'footer'}\n             * @default\n             */\n            target : 'footer'\n        };\n    }\n\n    construct(grid, config) {\n        this.grid = grid;\n\n        super.construct(grid, config);\n\n        if (!grid.features.group) {\n            throw new Error('Requires Group feature to work, please enable');\n        }\n\n        this.bindStore(grid.store);\n\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            renderCell      : 'renderCell',\n\n            // The feature gets to see cells being rendered after the Group feature\n            // because the Group feature injects header content into group header rows\n            // and adds rendering info to the cells renderData which we must comply with.\n            // In particular, it calculates the isFirstColumn flag which it adds to\n            // the cell renderData which we interrogate.\n            prio    : 1000,\n            thisObj : this\n        });\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            update  : 'onStoreUpdate',\n            // need to run before grids listener, to flag for full refresh\n            prio    : 1,\n            thisObj : this\n        });\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    doDisable(disable) {\n        // Toggle footers if needed\n        this.updateTarget(this.target);\n\n        super.doDisable(disable);\n    }\n\n    changeTarget(target) {\n        ObjectHelper.assertString(target, 'target');\n\n        return target;\n    }\n\n    updateTarget(target) {\n        // Flag that will make the Store insert rows for group footers\n        this.store.useGroupFooters = !this.disabled && target === 'footer';\n\n        // Refresh groups to show/hide footers\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n\n    changeCollapseToHeader(collapseToHeader) {\n        ObjectHelper.assertBoolean(collapseToHeader, 'collapseToHeader');\n\n        return collapseToHeader;\n    }\n\n    updateCollapseToHeader() {\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called before rendering row contents, used to reset rows no longer used as group summary rows\n     * @private\n     */\n    onBeforeRenderRow({ row, record }) {\n        if (row.isGroupFooter && !('groupFooterFor' in record.meta)) {\n            // not a group row.\n            row.isGroupFooter = false;\n            // force full \"redraw\" when rendering cells\n            row.forceInnerHTML = true;\n        }\n        else if (row.isGroupHeader && !record.meta.collapsed) {\n            // remove any summary elements\n            row.eachElement(this.removeSummaryElements);\n        }\n    }\n\n    removeSummaryElements(rowEl) {}\n\n    /**\n     * Called when a cell is rendered, styles the group rows first cell.\n     * @private\n     */\n    renderCell({ column, cellElement, row, record, size, isFirstColumn }) {\n        const\n            me            = this,\n            { meta }      = record,\n            { rowHeight } = me.grid,\n            isGroupHeader = 'groupRowFor' in meta,\n            isGroupFooter = 'groupFooterFor' in meta,\n            targetsHeader = me.target === 'header',\n            rowClasses    = {\n                'b-group-footer'   : 0,\n                'b-header-summary' : 0\n            },\n            isSummaryTarget =\n                // Header cell should have summary content if we are targeting the header or if the group is collapsed\n                // and we are configured with collapseToHeader, excluding the first column which holds the group title\n                (isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn) ||\n                // Footer cell should have summary content if we are targeting the footer (won't render if collapsed)\n                (isGroupFooter && !targetsHeader);\n\n        // Needed to restore height when summary is no longer displayed\n        if (isGroupHeader || isGroupFooter) {\n            size.height = isGroupHeader ? (size.height || rowHeight) : rowHeight;\n        }\n\n        if (me.store.isGrouped && isSummaryTarget && !me.disabled) {\n            // clear cell before add any HTML in it. if the cell contained widgets, they will be properly destroyed.\n            column.clearCell(cellElement);\n\n            const groupRecord = isGroupHeader ? record : meta.groupRecord;\n\n            row.isGroupFooter = isGroupFooter;\n            row.isGroupHeader = isGroupHeader;\n\n            // This is a group footer row, add css\n            if (isGroupFooter) {\n                rowClasses['b-group-footer'] = 1;\n            }\n            // This is a group header row, add css\n            else {\n                rowClasses['b-header-summary'] = 1;\n            }\n\n            // returns height config or count. config format is { height, count }. where `height is in px and should be\n            // added to value calculated from `count\n            const\n                heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord),\n                count         = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;\n\n            // number of summaries returned, use to calculate cell height\n            if (count > 1) {\n                size.height += (meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1);\n            }\n\n            // height config with height specified, added to cell height\n            if (heightSetting.height) {\n                size.height += heightSetting.height;\n            }\n        }\n\n        // Sync row's classes with its status as a group header or footer.\n        row.assignCls(rowClasses);\n    }\n\n    updateSummaryHtml(cellElement, column, groupRecord) {\n        const records = groupRecord.groupChildren.slice();\n\n        // Group footers should not be included in summary calculations\n        if (records[records.length - 1].isGroupFooter) {\n            records.pop();\n        }\n\n        const html = this.generateHtml(column, records, 'b-grid-group-summary', groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);\n\n        // First time, set table\n        if (!cellElement.children.length) {\n            cellElement.innerHTML = html;\n        }\n        // Following times, sync changes\n        else {\n            DomHelper.sync(html, cellElement.firstElementChild);\n        }\n\n        // return summary \"count\", used to set row height\n        return column.summaries ? column.summaries.length : column.sum ? 1 : 0;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Updates summaries on store changes (except record update, handled below)\n     * @private\n     */\n    onStoreUpdate({ source : store, changes }) {\n        if (!this.disabled && store.isGrouped) {\n            // If a grouping field is among the changes, StoreGroup#onDataChanged will\n            // take care of the update by re-sorting.\n            if (changes && store.groupers.find(grouper => grouper.field in changes)) {\n                return;\n            }\n            // only update summary when a field that affects summary is changed\n            // <remove-on-release>\n            // TODO: this should maybe be removed, another column might depend on the value for its summary?\n            // </remove-on-release>\n            const shouldUpdate = Object.keys(changes).some(field => {\n                const colField = this.grid.columns.get(field);\n                // check existence, since a field not used in a column might have changed\n                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));\n            });\n\n            if (shouldUpdate) {\n                this.grid.forceFullRefresh = true;\n            }\n        }\n    }\n\n    //endregion\n\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        this.grid.columns.visibleColumns.forEach(column => {\n            if (this.hasSummary(column)) {\n                this.grid.refreshColumn(column);\n            }\n        });\n    }\n\n    hasSummary(column) {\n        return column.sum || column.summaries;\n    }\n}\n\nGroupSummary.featureClass = 'b-group-summary';\n\nGridFeatureManager.registerFeature(GroupSummary);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport Base from '../../Core/Base.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/util/TableExporter\n */\n\n/**\n * This class transforms grid component into two arrays: rows and columns. Columns array contains objects with\n * meta information about column: field name, column name, width and type of the rendered value, rows array contains\n * arrays of cell values.\n *\n * ```javascript\n * const exporter = new TableExporter({ target : grid });\n * exporter.export()\n *\n * // Output\n * {\n *     columns : [\n *         { field : 'name',     value : 'First name', type : 'string',  width : 100 },\n *         { field : 'surname',  value : 'Last name',  type : 'string',  width : 100 },\n *         { field : 'age',      value : 'Age',        type : 'number',  width : 50  },\n *         { field : 'married',  value : 'Married',    type : 'boolean', width : 50  },\n *         { field : 'children', value : 'Children',   type : 'object',  width : 100 }\n *     ],\n *     rows : [\n *         ['Michael', 'Scott',   40, false, []],\n *         ['Jim',     'Halpert', 30, true,  [...]]\n *     ]\n * }\n * ```\n *\n * ## How data is exported\n *\n * Exporter iterates over store records and processes each record for each column being exported. Exporter uses same\n * approach to retrieve data as column: reading record field, configured on the column, or calling renderer function\n * if one is provided. This means data can be of any type: primitives or objects. So children array in the above code\n * snippet may contain instances of child record class.\n *\n * ## Column renderers\n *\n * Column renderers are commonly used to style the cell, or even render more HTML into it, like {@link Grid.column.WidgetColumn}\n * does. This is not applicable in case of export. Also, given grid uses virtual rendering (only renders visible rows) and\n * exporter iterates over all records, not just visible ones, we cannot provide all data necessary to the renderer. Some\n * arguments, like cellElement and row, wouldn't exist. Thus renderer is called with as much data we have: value,\n * record, column, grid, other {@link Grid.column.Column#config-renderer documented arguments} would be undefined.\n *\n * Exporter adds one more flag for renderer function: isExport. When renderer receives this flag it knows\n * data is being exported and can skip DOM work to return simpler value. Below snippet shows simplified code of the\n * widget column handling export:\n *\n * ```javascript\n * renderer({ isExport }) {\n *     if (isExport) {\n *         return null;\n *     }\n *     else {\n *         // widget rendering routine\n *         ...\n *     }\n * }\n * ```\n *\n * ## Column types\n *\n * Column types are not actually a complete list of JavaScript types (you can get actual type of the cell using typeof) it\n * is a simple and helpful meta information.\n *\n * Available column types are:\n *  * string\n *  * number\n *  * boolean\n *  * date\n *  * object\n *\n * Everything which is not primitive like string/number/bool (or a date) is considered an object. This includes null, undefined,\n * arrays, classes, functions etc.\n *\n * ## Getting column type\n *\n * If existing grid column is used, column type first would be checked with {@link Grid.column.Column#config-exportedType exportedType}\n * config. If exportedType is undefined or column does not exist in grid, type is read from a record field definition.\n * If the field is not defined, object type is used.\n *\n * Configuring exported type:\n *\n * ```javascript\n * new Grid({\n *     columns : [\n *         {\n *             name         : 'Name',\n *             field        : 'name',\n *             exportedType : 'object',\n *             renderer     : ({ value, isExport }) => {\n *                 if (isExport) {\n *                     return { value }; // return value wrapped into object\n *                 }\n *             }\n *     ]\n * })\n * ```\n *\n * @extends Core/Base\n */\nexport default class TableExporter extends Base {\n    static get defaultConfig() {\n        return {\n            /**\n             * Target grid instance to export data from\n             * @config {Grid.view.Grid} target\n             */\n            target : null,\n\n            /**\n             * Specifies a default column width if no width specified\n             * @config {Number} defaultColumnWidth\n             * @default\n             */\n            defaultColumnWidth : 100,\n\n            /**\n             * Set to false to export date as it is displayed by Date column formatter\n             * @config {Boolean}\n             * @default\n             */\n            exportDateAsInstance : true,\n\n            /**\n             * If true and the grid is grouped, shows the grouped value in the first column. True by default.\n             * @config {Boolean} showGroupHeader\n             * @default\n             */\n            showGroupHeader : true,\n\n            /**\n             * An array of column configuration objects used to specify column widths, header text, and data fields to get the data from.\n             * 'field' config is required. If 'text' is missing, it will read it from the grid column or the 'field' config.\n             * If 'width' is missing, it will try to get it retrieved from the grid column or {@link #config-defaultColumnWidth} config.\n             * If no columns provided the config will be generated from the grid columns.\n             *\n             * For example:\n             * ```javascript\n             * columns : [\n             *     'firstName', // field\n             *     'age', // field\n             *     { text : 'Starts', field : 'start', width : 140 },\n             *     { text : 'Ends', field : 'finish', width : 140 }\n             * ]\n             * ```\n             *\n             * @config {String[]|Object[]} columns\n             * @default\n             */\n            columns : null,\n\n            /**\n             * When true and tree is being exported, node names are indented with {@link #config-indentationSymbol}\n             * @config {Boolean}\n             * @default\n             */\n            indent : true,\n\n            /**\n             * This symbol (four spaces by default) is used to indent node names when {@link #config-indent} is true\n             * @config {String}\n             * @default\n             */\n            indentationSymbol : '\\u00A0\\u00A0\\u00A0\\u00A0'\n        };\n    }\n\n    /**\n     * Exports grid data according to provided config\n     * @param {Object} config\n     * @returns {{ rows : Object[][], columns : Object[] }}\n     */\n    export(config = {}) {\n        const me = this;\n\n        config = ObjectHelper.assign({}, me.config, config);\n\n        me.normalizeColumns(config);\n\n        return me.generateExportData(config);\n    }\n\n    generateExportData(config) {\n        const\n            me      = this,\n            columns = me.generateColumns(config),\n            rows    = me.generateRows(config);\n\n        return { rows, columns };\n    }\n\n    normalizeColumns(config) {\n        // In case columns are provided we need to use normalized config. If those are not provided, we are going\n        // to use real columns, possible invoking renderers (we need to pass column instance to the renderer to\n        // avoid breaking API too much)\n        const columns = config.columns || this.target.columns.visibleColumns.filter(rec => rec.exportable !== false);\n\n        config.columns = columns.map(col => {\n            if (typeof col === 'string') {\n                return this.target.columns.find(column => column.field === col) || { field : col };\n            }\n            else {\n                return col;\n            }\n        });\n    }\n\n    generateColumns(config) {\n        return config.columns.map(col => this.processColumn(col, config));\n    }\n\n    generateRows(config) {\n        const { columns, rows } = config;\n\n        if (columns.length === 0 || rows?.length === 0) {\n            return [];\n        }\n\n        const\n            me         = this,\n            { target } = me;\n\n        return (rows || target.store)\n            // although columns are taken from config, it is convenient to provide them as a separate argument\n            // because that allows to override set of columns to process\n            .map(record => me.processRecord(record, columns, config))\n            // filter out empty rows\n            .filter(cells => cells?.length);\n    }\n\n    getColumnType(column, store = this.target.store) {\n        let result = column.exportedType || 'object';\n\n        if (column.exportedType === undefined) {\n            if (column.field) {\n                const fieldDefinition = store.modelClass.getFieldDefinition(column.field);\n\n                if (fieldDefinition && fieldDefinition.type !== 'auto') {\n                    result = fieldDefinition.type;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Extracts export data from the column instance\n     * @param {Grid.column.Column} column\n     * @param {Object} config\n     * @private\n     * @returns {Object}\n     */\n    processColumn(column, config) {\n        const\n            me                     = this,\n            { target }             = me,\n            { defaultColumnWidth } = config;\n\n        let { field, text : value, width, minWidth } = column;\n\n        // If column is not configured with field, field is generated (see Column.js around line 514).\n        // In export we want empty string there\n        if (!(field in target.store.modelClass.fieldMap)) {\n            field = '';\n        }\n\n        // If name or width is missing try to retrieve them from the grid column and the field, or use default values.\n        if (!value || !width) {\n            const gridColumn = target.columns.find(col => col.field === field);\n\n            if (!value) {\n                value = gridColumn && gridColumn.text || field;\n            }\n\n            // null or undefined\n            if (width == null) {\n                width = gridColumn && gridColumn.width || defaultColumnWidth;\n            }\n        }\n\n        width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);\n\n        return { field, value, width, type : me.getColumnType(column) };\n    }\n\n    /**\n     * Extracts export data from the record instance reading supplied column configs\n     * @param {Core.data.Model|null} record If null is passed, all columns will be filled with empty strings\n     * @param {Grid.column.Column[]} columns\n     * @param {Object} config\n     * @private\n     * @returns {Object[]}\n     */\n    processRecord(record, columns, config) {\n        const\n            { target } = this,\n            {\n                showGroupHeader,\n                indent,\n                indentationSymbol\n            }  = config;\n\n        let cells;\n\n        if (!record) {\n            cells = columns.map(() => '');\n        }\n        else if (record.isSpecialRow) {\n            if (showGroupHeader && record.meta.groupRowFor) {\n                cells = columns.map(column => {\n                    return target.features.group.buildGroupHeader({\n                        // Create dummy element to get html from\n                        cellElement : DomHelper.createElement(),\n                        grid        : target,\n                        record,\n                        column\n                    });\n                });\n            }\n        }\n        else {\n            cells = columns.map(column => {\n                let value = column.field?.includes('.') ? record.get(column.field) : record[column.field];\n                const useRenderer = column.renderer || column.defaultRenderer;\n\n                if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {\n                    value = useRenderer.call(column, {\n                        value,\n                        record,\n                        column,\n                        grid     : target,\n                        isExport : true\n                    });\n                }\n\n                if (indent && column.tree) {\n                    value = `${indentationSymbol.repeat(record.childLevel)}${value}`;\n                }\n\n                return value;\n            });\n        }\n\n        return cells;\n    }\n}\n", "export default class BooleanUnicodeSymbol {\n    constructor(value) {\n        this._value = value;\n    }\n\n    get value() {\n        return this._value;\n    }\n\n    toString() {\n        return Boolean(this.value) ? '✓' : '';\n    }\n}\n", "import GridFeatureManager from '../GridFeatureManager.js';\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport TableExporter from '../../util/TableExporter.js';\nimport BooleanUnicodeSymbol from '../../util/BooleanUnicodeSymbol.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/experimental/ExcelExporter\n */\n\n/**\n * **NOTE**: This class requires a 3rd party library to operate.\n *\n * A feature that allows exporting Grid data to Excel without involving the server. It uses {@link Grid.util.TableExporter}\n * class as data provider, [zipcelx library](https://www.npmjs.com/package/zipcelx)\n * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)\n * and [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).\n * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.\n *\n * ```html\n * // Global scope\n * <script src=\"zipcelx.js\"></script>\n * ```\n *\n * ```javascript\n * // importing from package\n * import zipcelx from 'zipcelx';\n *\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             zipcelx\n *         }\n *     }\n * })\n * ```\n *\n * Here is an example of how to add the feature:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             // Choose the date format for date fields\n *             dateFormat : 'YYYY-MM-DD HH:mm',\n *\n *             exporterConfig : {\n *                 // Choose the columns to include in the exported file\n *                 columns : ['name', 'role'],\n *                 // Optional, export only selected rows\n *                 rows    : grid.selectedRecords\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * And how to call it:\n *\n * ```javascript\n * grid.features.excelExporter.export({\n *     filename : 'Export',\n *     exporterConfig : {\n *         columns : [\n *             { text : 'First Name', field : 'firstName', width : 90 },\n *             { text : 'Age', field : 'age', width : 40 },\n *             { text : 'Starts', field : 'start', width : 140 },\n *             { text : 'Ends', field : 'finish', width : 140 }\n *         ]\n *     }\n * })\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/exporttoexcel\n * @classtype excelExporter\n * @feature\n */\nexport default class ExcelExporter extends InstancePlugin {\n    static get $name() {\n        return 'ExcelExporter';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Name of the exported file\n             * @config {String} filename\n             * @default\n             */\n            filename : null,\n\n            /**\n             * Defines how dates in a cell will be formatted\n             * @config {String} dateFormat\n             * @default\n             */\n            dateFormat : 'YYYY-MM-DD',\n\n            /**\n             * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.\n             * @config {Grid.util.TableExporter}\n             * @typings {typeof TableExporter}\n             * @default\n             */\n            exporterClass : TableExporter,\n\n            /**\n             * Configuration object for {@link #config-exporterClass exporter class}.\n             * @config {Object}\n             */\n            exporterConfig : null,\n\n            /**\n             * Reference to zipcelx library. If not provided, exporter will look in the global scope.\n             * @config {Object}\n             */\n            zipcelx : null,\n\n            /**\n             * If this config is true, exporter will convert all empty values to ''. Empty values are:\n             * * undefined, null, NaN\n             * * Objects/class instances that do not have toString method defined and are stringified to [object Object]\n             * * functions\n             * @config {Boolean}\n             */\n            convertEmptyValueToEmptyString : true\n        };\n    }\n\n    processValue(value) {\n        if (\n            value === undefined ||\n            value === null ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            (typeof value === 'object' && String(value) === '[object Object]')\n        ) {\n            return '';\n        }\n        else {\n            return value;\n        }\n    }\n\n    generateExportData(config) {\n        const\n            me                = this,\n            { rows, columns } = me.exporter.export(config.exporterConfig);\n\n        return {\n            rows : rows.map(row => {\n                return row.map((value, index) => {\n                    if (value instanceof Date) {\n                        value = DateHelper.format(value, config.dateFormat);\n                    }\n                    else if (typeof value === 'boolean') {\n                        value = new BooleanUnicodeSymbol(value);\n                    }\n\n                    if (me.convertEmptyValueToEmptyString) {\n                        value = me.processValue(value);\n                    }\n\n                    const type = columns[index]?.type === 'number' ? 'number' : 'string';\n\n                    return { value, type };\n                });\n            }),\n            columns : columns.map(col => {\n                let { field, value, width, type } = col;\n\n                // when number column is exported with zipcelx, excel warns that sheet is broken and asks for repair\n                // repair works, but having error on open doesn't look acceptable\n                // type = type === 'number' ? 'number' : 'string';\n                type = 'string';\n\n                return { field, value, width, type };\n            })\n        };\n    }\n\n    /**\n     * Generate and download an Excel file (.xslx).\n     * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.\n     * @param {String} [config.filename] Name of the exported file\n     * @param {String} [config.dateFormat] Defines how dates in a cell will be formatted\n     * @param {String[]|Object[]} [config.columns] An array of column configuration objects\n     * @param {Core.data.Model[]} [config.rows] An array of records to export\n     * @returns {Promise} Promise that resolves when the export is completed\n     */\n    export(config = {}) {\n        const\n            me      = this,\n            zipcelx = me.zipcelx || globalThis.zipcelx;\n\n        if (!zipcelx) {\n            throw new Error('ExcelExporter: \"zipcelx\" library is required');\n        }\n\n        if (me.disabled) {\n            return;\n        }\n\n        config = ObjectHelper.assign({}, me.config, config);\n\n        if (!config.filename) {\n            config.filename = me.client.$$name;\n        }\n\n        const\n            { filename }      = config,\n            { rows, columns } = me.generateExportData(config);\n\n        return zipcelx({\n            filename,\n            sheet : {\n                data : [columns].concat(rows),\n                cols : columns\n            }\n        });\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        if (!this.zipcelx) {\n            if (typeof zipcelx !== 'undefined') {\n                this.zipcelx = globalThis.zipcelx;\n            }\n        }\n    }\n\n    get exporter() {\n        const me = this;\n\n        return me._exporter || (me._exporter = me.exporterClass.new({ target : me.client }, me.exporterConfig));\n    }\n}\n\nGridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');\n"],
  "mappings": "6MA6Be,MAAMA,UAAqBC,EAAiBC,CAAc,CAAE,CAEvE,WAAWC,OAAQ,CACf,MAAO,cACX,CACA,WAAWC,cAAe,CACtB,MAAO,CAyBHC,iBAAmB,KAwBnBC,OAAS,SAEjB,CACAC,UAAUC,EAAMC,EAAQ,CAGpB,GAFA,KAAKD,KAAOA,EACZ,MAAMD,UAAUC,EAAMC,CAAM,EACxB,CAACD,EAAKE,SAASC,MACf,MAAM,IAAIC,MAAM,+CAA+C,EAEnE,KAAKC,UAAUL,EAAKM,KAAK,EACzBN,EAAKO,WAAWC,IAAI,CAChBC,gBAAkB,oBAClBC,WAAkB,aAMlBC,KAAU,IACVC,QAAU,IACd,CAAC,CACL,CACAP,UAAUC,EAAO,CACb,KAAKO,gBAAgB,OAAO,EAC5BP,EAAME,IAAI,CACNM,KAAU,QACVC,OAAU,gBAEVJ,KAAU,EACVC,QAAU,IACd,CAAC,CACL,CACA,IAAIN,OAAQ,CACR,OAAO,KAAKN,KAAKM,KACrB,CACAU,UAAUC,EAAS,CAEf,KAAKC,aAAa,KAAKpB,MAAM,EAC7B,MAAMkB,UAAUC,CAAO,CAC3B,CACAE,aAAarB,EAAQ,CACjBsB,OAAAA,EAAaC,aAAavB,EAAQ,QAAQ,EACnCA,CACX,CACAoB,aAAapB,EAAQ,CAEjB,KAAKQ,MAAMgB,gBAAkB,CAAC,KAAKC,UAAYzB,IAAW,SAErD,KAAK0B,eACN,KAAKlB,MAAMH,MAAK,CAExB,CACAsB,uBAAuB5B,EAAkB,CACrCuB,OAAAA,EAAaM,cAAc7B,EAAkB,kBAAkB,EACxDA,CACX,CACA8B,wBAAyB,CAChB,KAAKH,eACN,KAAKlB,MAAMH,MAAK,CAExB,CAIA,WAAWyB,cAAe,CACtB,MAAO,CACHC,MAAQ,CAAC,WAAW,EAE5B,CAOAC,kBAAkB,CAAEC,IAAAA,EAAKC,OAAAA,CAAO,EAAG,CAC3BD,EAAIE,eAAiB,EAAE,mBAAoBD,EAAOE,OAElDH,EAAIE,cAAgB,GAEpBF,EAAII,eAAiB,IAEhBJ,EAAIK,eAAiB,CAACJ,EAAOE,KAAKG,WAEvCN,EAAIO,YAAY,KAAKC,qBAAqB,CAElD,CACAA,sBAAsBC,EAAO,CAAA,CAK7B9B,WAAW,CAAE+B,OAAAA,EAAQC,YAAAA,EAAaX,IAAAA,EAAKC,OAAAA,EAAQW,KAAAA,EAAMC,cAAAA,CAAc,EAAG,CAClE,MACIC,EAAgB,KAChB,CAAEX,KAAAA,CAAK,EAASF,EAChB,CAAEc,UAAAA,GAAcD,EAAG7C,KACnBoC,EAAgB,gBAAiBF,EACjCD,EAAgB,mBAAoBC,EACpCa,EAAgBF,EAAG/C,SAAW,SAC9BkD,EAAgB,CACZ,iBAAqB,EACrB,mBAAqB,GAEzBC,EAGKb,IAAkBW,GAAiBF,EAAGhD,kBAAoBqC,EAAKG,YAAc,CAACO,GAE9EX,GAAiB,CAACc,EAK3B,IAHIX,GAAiBH,KACjBU,EAAKO,OAASd,GAAiBO,EAAKO,QAAUJ,GAE9CD,EAAGvC,MAAM6C,WAAaF,GAAmB,CAACJ,EAAGtB,SAAU,CAEvDkB,EAAOW,UAAUV,CAAW,EAC5B,MAAMW,EAAcjB,EAAgBJ,EAASE,EAAKmB,YAClDtB,EAAIE,cAAgBA,EACpBF,EAAIK,cAAgBA,EAEhBH,EACAe,EAAW,gBAAgB,EAAI,EAI/BA,EAAW,kBAAkB,EAAI,EAIrC,MACIM,EAAgBT,EAAGU,kBAAkBb,EAAaD,EAAQY,CAAW,EACrEG,EAAgB,OAAOF,GAAkB,SAAWA,EAAgBA,EAAcE,MAElFA,EAAQ,IACRb,EAAKO,QAAWhB,EAAKG,WAAa,CAACU,EAAgB,EAAIS,EAAQV,EAAY,IAG3EQ,EAAcJ,SACdP,EAAKO,QAAUI,EAAcJ,QAIrCnB,EAAI0B,UAAUT,CAAU,CAC5B,CACAO,kBAAkBb,EAAaD,EAAQY,EAAa,CAChD,MAAMK,EAAUL,EAAYM,cAAcC,MAAK,EAE3CF,EAAQA,EAAQG,OAAS,CAAC,EAAE5B,eAC5ByB,EAAQI,IAAG,EAEf,MAAMC,EAAO,KAAKC,aAAavB,EAAQiB,EAAS,uBAAwBL,EAAaA,EAAYnB,KAAK+B,WAAYZ,EAAYnB,KAAKgC,WAAW,EAE9I,OAAKxB,EAAYyB,SAASN,OAKtBO,EAAUC,KAAKN,EAAMrB,EAAY4B,iBAAiB,EAJlD5B,EAAY6B,UAAYR,EAOrBtB,EAAO+B,UAAY/B,EAAO+B,UAAUX,OAASpB,EAAOgC,IAAM,EAAI,CACzE,CAOAC,cAAc,CAAEC,OAASrE,EAAOsE,QAAAA,CAAQ,EAAG,CACvC,GAAI,CAAC,KAAKrD,UAAYjB,EAAM6C,UAAW,CAGnC,GAAIyB,GAAWtE,EAAMuE,SAASC,KAAKC,GAAWA,EAAQC,SAASJ,CAAO,EAClE,OAGiBK,OAAOC,KAAKN,CAAO,EAAEO,KAAKH,GAAS,CACpD,MAAMI,EAAW,KAAKpF,KAAKqF,QAAQC,IAAIN,CAAK,EAE5C,MAAOO,EAAQH,IAAcG,EAAQH,EAASX,KAAQc,EAAQH,EAASZ,UAC3E,CAAC,IAEG,KAAKxE,KAAKwF,iBAAmB,IAGzC,CAKAC,SAAU,CACN,KAAKzF,KAAKqF,QAAQK,eAAeC,QAAQlD,GAAU,CAC3C,KAAKmD,WAAWnD,CAAM,GACtB,KAAKzC,KAAK6F,cAAcpD,CAAM,CAEtC,CAAC,CACL,CACAmD,WAAWnD,EAAQ,CACf,OAAOA,EAAOgC,KAAOhC,EAAO+B,SAChC,CACJ,CACAhF,EAAasG,aAAe,kBAC5BtG,EAAauG,OAAS,eAAgBC,EAAmBC,gBAAgBzG,CAAY,ECxLtE,MAAM0G,UAAsBC,CAAK,CAC5C,WAAWC,eAAgB,CACvB,MAAO,CAKHtG,OAAS,KAMTuG,mBAAqB,IAMrBC,qBAAuB,GAMvBC,gBAAkB,GAoBlBlB,QAAU,KAMVmB,OAAS,GAMTC,kBAAoB,mBAE5B,CAMAC,OAAOzG,EAAS,CAAA,EAAI,CAChB,MAAM4C,EAAK,KACX5C,OAAAA,EAASmB,EAAauF,OAAO,CAAA,EAAI9D,EAAG5C,OAAQA,CAAM,EAClD4C,EAAG+D,iBAAiB3G,CAAM,EACnB4C,EAAGgE,mBAAmB5G,CAAM,CACvC,CACA4G,mBAAmB5G,EAAQ,CACvB,MACI4C,EAAU,KACVwC,EAAUxC,EAAGiE,gBAAgB7G,CAAM,EAEvC,MAAO,CAAE8G,KADKlE,EAAGmE,aAAa/G,CAAM,EACrBoF,QAAAA,EACnB,CACAuB,iBAAiB3G,EAAQ,CAIrB,MAAMoF,EAAUpF,EAAOoF,SAAW,KAAKvF,OAAOuF,QAAQK,eAAeuB,OAAOC,GAAOA,EAAIC,aAAe,EAAK,EAC3GlH,EAAOoF,QAAUA,EAAQ+B,IAAIC,GACrB,OAAOA,GAAQ,SACR,KAAKvH,OAAOuF,QAAQP,KAAKrC,GAAUA,EAAOuC,QAAUqC,CAAG,GAAK,CAAErC,MAAQqC,GAGtEA,CAEd,CACL,CACAP,gBAAgB7G,EAAQ,CACpB,OAAOA,EAAOoF,QAAQ+B,IAAIC,GAAO,KAAKC,cAAcD,EAAKpH,CAAM,CAAC,CACpE,CACA+G,aAAa/G,EAAQ,CACjB,KAAM,CAAEoF,QAAAA,EAAS0B,KAAAA,CAAK,EAAI9G,EAC1B,GAAIoF,EAAQxB,SAAW,IAAKkD,GAAAA,KAAI,OAAJA,EAAMlD,UAAW,EACzC,MAAO,CAAA,EAEX,MACIhB,EAAa,KACb,CAAE/C,OAAAA,CAAO,EAAI+C,EACjB,OAAQkE,GAAQjH,EAAOQ,OAGlB8G,IAAIpF,GAAUa,EAAG0E,cAAcvF,EAAQqD,EAASpF,CAAM,CAAC,EAEvDgH,OAAOO,GAASA,GAAAA,KAAAA,OAAAA,EAAO3D,MAAM,CACtC,CACA4D,cAAchF,EAAQnC,EAAQ,KAAKR,OAAOQ,MAAO,CAC7C,IAAIoH,EAASjF,EAAOkF,cAAgB,SACpC,GAAIlF,EAAOkF,eAAiBC,QACpBnF,EAAOuC,MAAO,CACd,MAAM6C,EAAkBvH,EAAMwH,WAAWC,mBAAmBtF,EAAOuC,KAAK,EACpE6C,GAAmBA,EAAgBG,OAAS,SAC5CN,EAASG,EAAgBG,MAIrC,OAAON,CACX,CAQAJ,cAAc7E,EAAQxC,EAAQ,CAC1B,MACI4C,EAAyB,KACzB,CAAE/C,OAAAA,CAAO,EAAgB+C,EACzB,CAAEwD,mBAAAA,CAAmB,EAAIpG,EAC7B,GAAI,CAAE+E,MAAAA,EAAOiD,KAAOC,EAAOC,MAAAA,EAAOC,SAAAA,CAAS,EAAI3F,EAO/C,GAJMuC,KAASlF,EAAOQ,MAAMwH,WAAWO,WACnCrD,EAAQ,IAGR,CAACkD,GAAS,CAACC,EAAO,CAClB,MAAMG,EAAaxI,EAAOuF,QAAQP,KAAKuC,GAAOA,EAAIrC,QAAUA,CAAK,EAC5DkD,IACDA,EAAQI,GAAcA,EAAWL,MAAQjD,GAGzCmD,GAAS,OACTA,EAAQG,GAAcA,EAAWH,OAAS9B,GAGlD8B,OAAAA,EAAQI,KAAKC,IAAIL,GAAS9B,EAAoB+B,GAAY/B,CAAkB,EACrE,CAAErB,MAAAA,EAAOkD,MAAAA,EAAOC,MAAAA,EAAOH,KAAOnF,EAAG4E,cAAchF,CAAM,EAChE,CASA8E,cAAcvF,EAAQqD,EAASpF,EAAQ,CACnC,KACI,CAAEH,OAAAA,CAAO,EAAI,KACb,CACIyG,gBAAAA,EACAC,OAAAA,EACAC,kBAAAA,CACJ,EAAKxG,EACT,IAAIuH,EACJ,OAAKxF,EAGIA,EAAOyG,aACRlC,GAAmBvE,EAAOE,KAAKgC,cAC/BsD,EAAQnC,EAAQ+B,IAAI3E,GACT3C,EAAOI,SAASC,MAAMuI,iBAAiB,CAE1ChG,YAAc0B,EAAUuE,cAAa,EACrC3I,KAAcF,EACdkC,OAAAA,EACAS,OAAAA,CACJ,CAAC,CACJ,GAIL+E,EAAQnC,EAAQ+B,IAAI3E,GAAU,CAAA,IAAAmG,EAC1B,IAAIV,GAAQU,EAAAnG,EAAOuC,SAAK,MAAA4D,IAAA,QAAZA,EAAcC,SAAS,GAAG,EAAI7G,EAAOsD,IAAI7C,EAAOuC,KAAK,EAAIhD,EAAOS,EAAOuC,KAAK,EACxF,MAAM8D,EAAcrG,EAAOsG,UAAYtG,EAAOuG,gBAC9C,OAAIF,GAAe,EAAEZ,GAASzF,EAAOwG,cAAgBhJ,EAAOqG,wBACxD4B,EAAQY,EAAYI,KAAKzG,EAAQ,CAC7ByF,MAAAA,EACAlG,OAAAA,EACAS,OAAAA,EACAzC,KAAWF,EACXqJ,SAAW,EACf,CAAC,GAED3C,GAAU/D,EAAO2G,OACjBlB,EAAS,GAAEzB,EAAkB4C,OAAOrH,EAAOsH,UAAU,IAAIpB,KAEtDA,CACX,CAAC,EAhCDV,EAAQnC,EAAQ+B,IAAI,IAAM,EAAE,EAkCzBI,CACX,CACJ,CACAtB,EAAcH,OAAS,gBCxTR,MAAMwD,CAAqB,CACtCC,YAAYtB,EAAO,CACf,KAAKuB,OAASvB,CAClB,CACA,IAAIA,OAAQ,CACR,OAAO,KAAKuB,MAChB,CACAC,UAAW,CACP,OAAe,KAAKxB,MAAS,SAAM,EACvC,CACJ,CACAqB,EAAqBxD,OAAS,uBCkEf,MAAM4D,UAAsBjK,CAAe,CACtD,WAAWC,OAAQ,CACf,MAAO,eACX,CACA,WAAWyG,eAAgB,CACvB,MAAO,CAMHwD,SAAW,KAMXC,WAAa,aAObC,cAAgB5D,EAKhB6D,eAAiB,KAKjBC,QAAU,KAQVC,+BAAiC,GAEzC,CACAC,aAAahC,EAAO,CAChB,OAEIA,GAAU,MACViC,OAAOC,MAAMlC,CAAK,GAClB,OAAOA,GAAU,YAChB,OAAOA,GAAU,UAAYmC,OAAOnC,CAAK,IAAM,kBAEzC,GAGAA,CAEf,CACArB,mBAAmB5G,EAAQ,CACvB,MACI4C,EAAoB,KACpB,CAAEkE,KAAAA,EAAM1B,QAAAA,GAAYxC,EAAGyH,SAAS5D,OAAOzG,EAAO8J,cAAc,EAChE,MAAO,CACHhD,KAAOA,EAAKK,IAAIrF,GACLA,EAAIqF,IAAI,CAACc,EAAOqC,IAAU,CAAA,IAAAC,EACzBtC,aAAiBuC,KACjBvC,EAAQwC,EAAWC,OAAOzC,EAAOjI,EAAO4J,UAAU,EAE7C,OAAO3B,GAAU,YACtBA,EAAQ,IAAIqB,EAAqBrB,CAAK,GAEtCrF,EAAGoH,iCACH/B,EAAQrF,EAAGqH,aAAahC,CAAK,GAEjC,MAAMF,IAAOwC,EAAAnF,EAAQkF,CAAK,KAAC,MAAAC,IAAdA,OAAAA,OAAAA,EAAgBxC,QAAS,SAAW,SAAW,SAC5D,MAAO,CAAEE,MAAAA,EAAOF,KAAAA,EACpB,CAAC,CACJ,EACD3C,QAAUA,EAAQ+B,IAAIC,GAAO,CACzB,GAAI,CAAErC,MAAAA,EAAOkD,MAAAA,EAAOC,MAAAA,EAAOH,KAAAA,CAAK,EAAIX,EAIpCW,OAAAA,EAAO,SACA,CAAEhD,MAAAA,EAAOkD,MAAAA,EAAOC,MAAAA,EAAOH,KAAAA,GACjC,EAET,CAUAtB,OAAOzG,EAAS,CAAA,EAAI,CAChB,MACI4C,EAAU,KACVmH,EAAUnH,EAAGmH,SAAWY,WAAWZ,QACvC,GAAI,CAACA,EACD,MAAM,IAAI5J,MAAM,8CAA8C,EAElE,GAAIyC,EAAGtB,SACH,OAEJtB,EAASmB,EAAauF,OAAO,CAAA,EAAI9D,EAAG5C,OAAQA,CAAM,EAC7CA,EAAO2J,WACR3J,EAAO2J,SAAW/G,EAAGgI,OAAOC,QAEhC,KACI,CAAElB,SAAAA,CAAS,EAAS3J,EACpB,CAAE8G,KAAAA,EAAM1B,QAAAA,CAAQ,EAAIxC,EAAGgE,mBAAmB5G,CAAM,EACpD,OAAO+J,EAAQ,CACXJ,SAAAA,EACAmB,MAAQ,CACJC,KAAO,CAAC3F,CAAO,EAAE4F,OAAOlE,CAAI,EAC5BmE,KAAO7F,CACX,CACJ,CAAC,CACL,CACAtF,UAAUC,EAAMC,EAAQ,CACpB,MAAMF,UAAUC,EAAMC,CAAM,EACvB,KAAK+J,SACF,OAAOA,SAAY,cACnB,KAAKA,QAAUY,WAAWZ,QAGtC,CACA,IAAIM,UAAW,CACX,MAAMzH,EAAK,KACX,OAAOA,EAAGsI,YAActI,EAAGsI,UAAYtI,EAAGiH,cAAcsB,IAAI,CAAEtL,OAAS+C,EAAGgI,MAAO,EAAGhI,EAAGkH,cAAc,EACzG,CACJ,CACAJ,EAAc5D,OAAS,gBAAiBC,EAAmBC,gBAAgB0D,EAAe,GAAO,MAAM",
  "names": ["GroupSummary", "SummaryFormatter", "InstancePlugin", "$name", "configurable", "collapseToHeader", "target", "construct", "grid", "config", "features", "group", "Error", "bindStore", "store", "rowManager", "ion", "beforeRenderRow", "renderCell", "prio", "thisObj", "detachListeners", "name", "update", "doDisable", "disable", "updateTarget", "changeTarget", "ObjectHelper", "assertString", "useGroupFooters", "disabled", "isConfiguring", "changeCollapseToHeader", "assertBoolean", "updateCollapseToHeader", "pluginConfig", "chain", "onBeforeRenderRow", "row", "record", "isGroupFooter", "meta", "forceInnerHTML", "isGroupHeader", "collapsed", "eachElement", "removeSummaryElements", "rowEl", "column", "cellElement", "size", "isFirstColumn", "me", "rowHeight", "targetsHeader", "rowClasses", "isSummaryTarget", "height", "isGrouped", "clearCell", "groupRecord", "heightSetting", "updateSummaryHtml", "count", "assignCls", "records", "groupChildren", "slice", "length", "pop", "html", "generateHtml", "groupField", "groupRowFor", "children", "DomHelper", "sync", "firstElementChild", "innerHTML", "summaries", "sum", "onStoreUpdate", "source", "changes", "groupers", "find", "grouper", "field", "Object", "keys", "some", "colField", "columns", "get", "Boolean", "forceFullRefresh", "refresh", "visibleColumns", "forEach", "hasSummary", "refreshColumn", "featureClass", "_$name", "GridFeatureManager", "registerFeature", "TableExporter", "Base", "defaultConfig", "defaultColumnWidth", "exportDateAsInstance", "showGroupHeader", "indent", "indentationSymbol", "export", "assign", "normalizeColumns", "generateExportData", "generateColumns", "rows", "generateRows", "filter", "rec", "exportable", "map", "col", "processColumn", "processRecord", "cells", "getColumnType", "result", "exportedType", "undefined", "fieldDefinition", "modelClass", "getFieldDefinition", "type", "text", "value", "width", "minWidth", "fieldMap", "gridColumn", "Math", "max", "isSpecialRow", "buildGroupHeader", "createElement", "_column$field", "includes", "useRenderer", "renderer", "defaultRenderer", "isDateColumn", "call", "isExport", "tree", "repeat", "childLevel", "BooleanUnicodeSymbol", "constructor", "_value", "toString", "ExcelExporter", "filename", "dateFormat", "exporterClass", "exporterConfig", "zipcelx", "convertEmptyValueToEmptyString", "processValue", "Number", "isNaN", "String", "exporter", "index", "_columns$index", "Date", "DateHelper", "format", "globalThis", "client", "$$name", "sheet", "data", "concat", "cols", "_exporter", "new"]
}
