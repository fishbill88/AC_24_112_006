{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/graph/Histogram.js", "../../../../Core/lib/Core/widget/graph/Scale.js"],
  "sourcesContent": ["import Widget from '../Widget.js';\nimport StringHelper from '../../helper/StringHelper.js';\nimport DomSync from '../../helper/DomSync.js';\nimport Tooltip from '../Tooltip.js';\n\n/**\n * @module Core/widget/graph/Histogram\n */\nconst\n    ns = 'http://www.w3.org/2000/svg',\n    // Outline series must overlay bars\n    typePrio = {\n        bar     : 1,\n        outline : 2,\n        text    : 3\n    },\n    byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10),\n    getField = s => s.field,\n    returnFalse = () => false;\n\n/**\n * Displays a simple bar histogram based upon an array of data objects passed in the {@link #config-data} config.\n * @extends Core/widget/Widget\n * @classtype histogram\n */\nexport default class Histogram extends Widget {\n    //region Config\n\n    static get type() {\n        return 'histogram';\n    }\n\n    static get $name() {\n        return 'Histogram';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * An array of data objects used to drive the histogram. The property/properties used\n             * are defined in the {@link #config-series} option.\n             * @config {Object[]}\n             * @default\n             */\n            data : null,\n\n            /**\n             * The values to represent in bar form.\n             * @config {Number[]}\n             */\n            values : null,\n\n            /**\n             * Each item in the array must contain two properties:\n             *  - `type` A String, either `'bar'` or `'outline'`\n             *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n             * @config {Object[]}\n             */\n            series : null,\n\n            /**\n             * By default, the bars are scaled based upon the detected max value across all the series.\n             * A specific top value to represent the 100% height may be configured.\n             * @config {Number}\n             */\n            topValue : null,\n\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup'\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n\n            /**\n             * By default, all bars are rendered, even those with zero height. Configure this as `true`\n             * to omit zero height bars.\n             * @config {Number}\n             */\n            omitZeroHeightBars : null,\n\n            monitorResize : true,\n\n            /**\n             * A Function which returns a CSS class name to add to a rectangle element.\n             * The following parameters are passed:\n             * @param {Object} series - The series being rendered\n             * @param {Object} rectConfig - The rectangle configuration object\n             * @param {Object} datum - The datum being rendered\n             * @param {Number} index - The index of the datum being rendered\n             * @config {Function}\n             */\n            getRectClass : null,\n\n            /**\n             * A Function which returns the tooltip text to display when hovering a bar.\n             * The following parameters are passed:\n             * @param {Object} series - The series being rendered\n             * @param {Object} rectConfig - The rectangle configuration object\n             * @param {Object} datum - The datum being rendered\n             * @param {Number} index - The index of the datum being rendered\n             * @config {Function}\n             */\n            getBarTip : null,\n\n            /**\n             * A Function which returns the text to render inside a bar.\n             * The following parameters are passed:\n             * @param {Object} datum - The datum being rendered\n             * @param {Number} index - The index of the datum being rendered\n             * @config {Function}\n             */\n            getBarText : null,\n\n            getBarTextRenderData : null,\n\n            getBarTextTip : null\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        super.construct(config);\n        this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);\n        this.refresh();\n    }\n\n    set tip(tip) {\n        const me = this;\n\n        me.tip?.destroy();\n\n        if (tip) {\n            me._tip = Tooltip.new({\n                owner             : me,\n                forElement        : me.svgElement,\n                forSelector       : 'rect',\n                internalListeners : {\n                    beforeShow : 'up.onBeforeTipShow'\n                }\n            }, tip);\n        }\n        else {\n            me._tip = null;\n        }\n    }\n\n    onElementResize() {\n        super.onElementResize(...arguments);\n\n        const svgRect = this.svgElement.getBoundingClientRect();\n\n        this.scaledSvgGroup.setAttribute('transform', `scale(${svgRect.width} ${svgRect.height})`);\n    }\n\n    onBeforeTipShow({ source : tip }) {\n        const index = parseInt(tip.activeTarget.dataset.index);\n\n        tip.html = tip.contentTemplate({\n            histogram : this,\n            index\n        });\n    }\n\n    set series(value) {\n        const\n            me     = this,\n            series = me._series = {};\n\n        for (const id in value) {\n            // Providing\n            //\n            // \"series\" : {\n            //     \"foo\" : false\n            //     ...\n            //\n            // disables the \"foo\" serie (that could be defined on a prototype level for example)\n\n            if (value[id] !== false) {\n                const data = series[id] = Object.assign({}, value[id]);\n\n                // support type & field provided on config prototype level\n\n                if (!data.type && value[id].type) {\n                    data.type = value[id].type;\n                }\n\n                if (!data.field && value[id].field) {\n                    data.field = value[id].field;\n                }\n\n                if (!('order' in series)) {\n                    data.order = typePrio[data.type];\n                }\n\n                data.id = id;\n            }\n        }\n\n        me.scheduleRefresh();\n    }\n\n    get series() {\n        return this._series;\n    }\n\n    set data(data) {\n        const me = this;\n\n        // <remove-on-release>\n        // TODO: me.topValue = undefined;\n        // </remove-on-release>\n\n        me._data = data;\n\n        // Calculate the top value from all the series\n        if (!me.topValue) {\n            const fields   = Object.values(me.series).map(getField);\n\n            for (let i = 0, { length } = data; i < length; i++) {\n                for (let j = 0, { length } = fields; j < length; j++) {\n                    me.topValue = Math.max(me.topValue || 0, data[i][fields[j]]);\n                }\n            }\n        }\n\n        me.scheduleRefresh();\n    }\n\n    get data() {\n        return this._data;\n    }\n\n    set topValue(value) {\n        this._topValue = value;\n\n        this.scheduleRefresh();\n    }\n\n    get topValue() {\n        return this._topValue;\n    }\n\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n\n    }\n\n    refresh() {\n        const\n            me             = this,\n            {\n                series,\n                _tip\n            }              = me,\n            histogramElements = [];\n\n        for (const id in series) {\n            const\n                data     = series[id],\n                elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data);\n\n            if (Array.isArray(elConfig)) {\n                histogramElements.push.apply(histogramElements, elConfig);\n            }\n            else {\n                histogramElements.push(elConfig);\n            }\n        }\n\n        histogramElements.sort(byDatasetOrder);\n\n        DomSync.syncChildren({\n            domConfig      : { children : histogramElements },\n            configEquality : returnFalse\n        }, me.scaledSvgGroup);\n\n        DomSync.syncChildren({\n            domConfig : { children : me.drawText() }\n        }, me.unscaledSvgGroup);\n\n        if (_tip && _tip.isVisible) {\n            me.onBeforeTipShow({ source : _tip });\n        }\n    }\n\n    drawBar(series) {\n        const\n            me           = this,\n            {\n                topValue,\n                data,\n                omitZeroHeightBars,\n                barStyle\n            }            = me,\n            {\n                field,\n                order\n            }            = series,\n            defaultWidth = 1 / data.length,\n            children     = [];\n\n        let\n            width;\n\n        for (let index = 0, x = 0, { length } = data; index < length; index++, x += width) {\n            const\n                datum = data[index],\n                value = datum[field],\n                // limit height with topValue otherwise the histogram looks fine\n                // yet the bar tooltip picks wrong Y-coordinate and there is an empty space between it and the bar\n                height = datum.height || (value > topValue ? topValue : value) / topValue,\n                y = 1 - height,\n                rectConfig = (datum.rectConfig = {\n                    ns,\n                    tag     : 'rect',\n                    dataset : {}\n                }),\n                barTip = me.callback('getBarTip', me, [series, rectConfig, datum, index]);\n\n            // use either provided width or the calculated value\n            width = datum.width || defaultWidth;\n\n            if (barStyle) {\n                rectConfig.style = barStyle;\n            }\n            else {\n                delete rectConfig.style;\n            }\n            Object.assign(rectConfig.dataset, {\n                index,\n                order\n            });\n            Object.assign(rectConfig, {\n                x,\n                y,\n                width,\n                height,\n                class : me.callback('getRectClass', me, [series, rectConfig, datum, index])\n            });\n\n            if (barTip) {\n                rectConfig.dataset.btip = barTip;\n            }\n            else {\n                delete rectConfig.dataset.btip;\n            }\n\n            if (height || !omitZeroHeightBars) {\n                children.push(rectConfig);\n            }\n        }\n        return children;\n    }\n\n    drawOutline(series) {\n        const\n            me           = this,\n            {\n                topValue,\n                data\n            }            = me,\n            {\n                field,\n                order\n            }            = series,\n            defaultWidth = 1 / data.length,\n            coords       = ['M 0,1'],\n            result       = series.outlineElement || (series.outlineElement = {\n                ns,\n                tag     : 'path',\n                dataset : {\n                    order\n                }\n            });\n\n        let\n            barWidth,\n            command1 = 'M',\n            command2 = 'L';\n\n        for (let i = 0, x = 0, { length } = data; i < length; i++) {\n            const barHeight = 1 - data[i][field] / topValue;\n\n            // use either provided with or the calculated value\n            barWidth = data[i].width || defaultWidth;\n\n            coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);\n            command1 = command2 = '';\n        }\n        // coords.push('1,1');\n\n        result.d = coords.join(' ');\n\n        return result;\n    }\n\n    drawText() {\n        const\n            me                = this,\n            { data }          = me,\n            defaultWidth      = 1 / data.length,\n            defaultY          = '100%',\n            unscaledSvgGroups = [];\n\n        for (let index = 0, width, x = 0, { length } = data; index < length; index++, x += width) {\n            width = data[index].width || defaultWidth;\n\n            const barText = me.callback('getBarText', me, [data[index], index]);\n\n            if (barText) {\n\n                const renderData = me.callback('getBarTextRenderData', me, [{\n                    ns,\n                    tag       : 'text',\n                    className : 'b-bar-legend',\n                    html      : barText,\n                    x         : `${(x + width / 2) * 100}%`,\n                    y         : data[index].y !== undefined ? data[index].y : defaultY,\n                    dataset   : {\n                        index\n                    }\n                }, data[index], index]);\n\n                const barTip = me.callback('getBarTextTip', me, [renderData, data[index], index]);\n                if (barTip) {\n                    renderData.dataset.btip = barTip;\n                }\n                else {\n                    delete renderData.dataset.btip;\n                }\n\n                unscaledSvgGroups.push(renderData);\n            }\n        }\n\n        return unscaledSvgGroups;\n    }\n\n    //endregion\n\n    // Injectable method\n    getBarText(datum, index) {\n        return '';\n    }\n\n    // Injectable method\n    getBarTextRenderData(renderData, datum, index) {\n        return renderData;\n    }\n\n    // Injectable method\n    getBarTip(series, rectConfig, datum, index) {\n\n    }\n\n    // Injectable method\n    getBarTextTip(renderData, datum, index) {\n\n    }\n\n    // Injectable method\n    getRectClass(series, rectConfig, datum, index) {\n        return '';\n    }\n}\n\nHistogram.initClass();\n", "import Widget from '../Widget.js';\nimport DomSync from '../../helper/DomSync.js';\n\n/**\n * @module Core/widget/graph/Scale\n */\nconst\n    ns = 'http://www.w3.org/2000/svg';\n\n/**\n * Displays a scale with ticks and labels.\n * @extends Core/widget/Widget\n * @classtype scale\n */\nexport default class Scale extends Widget {\n    //region Config\n\n    static get type() {\n        return 'scale';\n    }\n\n    static get $name() {\n        return 'Scale';\n    }\n\n    static get configurable() {\n        return {\n            scalePoints : null,\n\n            // Padding after the max scale point.\n            // Expressed as the share of the height.\n            scaleMaxPadding : 0.1,\n\n            /**\n             * Configure as `true` to create a horizontal scale. Scales are vertical by default.\n             * @config {Boolean}\n             */\n            horizontal : false,\n\n            /**\n             * Side to align the scale to. Defaults to `bottom` for {@link #config-horizontal} Scales\n             * and `right` for vertical Scales.\n             * @config {String}\n             */\n            align : {\n                value   : false,\n                $config : {\n                    merge : 'replace'\n                }\n            },\n\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : [{\n                            ns,\n                            tag       : 'path',\n                            reference : 'pathElement'\n                        }]\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n\n            monitorResize : true\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        super.construct(config);\n        this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);\n        this.refresh();\n    }\n\n    changeAlign(align) {\n        if (!align) {\n            align = this.horizontal ? 'bottom' : 'right';\n        }\n        return align;\n    }\n\n    updateAlign(align, oldAlign) {\n        this.element.classList.remove(`b-align-${oldAlign}`);\n        this.element.classList.add(`b-align-${align}`);\n    }\n\n    updateHorizontal(horizontal, oldHorizontal) {\n        this.element.classList.remove(`b-scale-${oldHorizontal ? 'horizontal' : 'vertical'}`);\n        this.element.classList.add(`b-scale-${horizontal ? 'horizontal' : 'vertical'}`);\n    }\n\n    onElementResize() {\n        super.onElementResize(...arguments);\n        this.scheduleRefresh();\n    }\n\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n\n    }\n\n    refresh() {\n        const\n            me             = this,\n            {\n                horizontal,\n                width,\n                height,\n                align,\n                scalePoints,\n                scaleMaxPadding\n            }                  = me,\n            scaleMax           = scalePoints[scalePoints.length - 1].value,\n            path               = [],\n            labels             = [];\n\n        const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);\n\n        me.scaledSvgGroup.setAttribute('transform', `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);\n\n        for (const point of scalePoints) {\n            const isLabelStep = Boolean(point.text),\n                pos = posFactor * point.value;\n\n            if (isLabelStep) {\n                const label = {\n                    ns,\n                    tag       : 'text',\n                    className : 'b-scale-tick-label',\n                    html      : point.text,\n                    dataset   : {\n                        tick : point.value\n                    }\n                };\n\n                if (horizontal) {\n                    label.x = `${pos * 100}%`;\n                    label.y = align === 'top' ? '1.6em' : height - 12;\n                }\n                else {\n                    label.x = align === 'left' ? '12' : `${width - 12}`;\n                    label.y = `${(1 - pos) * 100}%`;\n                }\n                labels.push(label);\n            }\n\n            if (horizontal) {\n                if (align === 'top') {\n                    path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);\n                }\n                else {\n                    path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);\n                }\n            }\n            else {\n                if (align === 'left') {\n                    path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);\n                }\n                else {\n                    path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);\n                }\n            }\n        }\n        me.pathElement.setAttribute('d', path.join(''));\n        DomSync.syncChildren({\n            domConfig : { children : labels }\n        }, me.unscaledSvgGroup);\n    }\n\n    //endregion\n}\nScale.initClass();\n"],
  "mappings": "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",
  "names": ["ns", "typePrio", "bar", "outline", "text", "byDatasetOrder", "l", "r", "parseInt", "dataset", "order", "getField", "s", "field", "returnFalse", "Histogram", "Widget", "type", "$name", "defaultConfig", "data", "values", "series", "topValue", "element", "children", "tag", "reference", "width", "height", "preserveAspectRatio", "omitZeroHeightBars", "monitorResize", "getRectClass", "getBarTip", "getBarText", "getBarTextRenderData", "getBarTextTip", "construct", "config", "scheduleRefresh", "createOnFrame", "refresh", "tip", "_me$tip", "me", "destroy", "_tip", "Tooltip", "new", "owner", "forElement", "svgElement", "forSelector", "internalListeners", "beforeShow", "onElementResize", "arguments", "svgRect", "getBoundingClientRect", "scaledSvgGroup", "setAttribute", "onBeforeTipShow", "source", "index", "activeTarget", "html", "contentTemplate", "histogram", "value", "_series", "id", "Object", "assign", "_data", "fields", "map", "i", "length", "j", "Math", "max", "_topValue", "histogramElements", "elConfig", "StringHelper", "capitalize", "Array", "isArray", "push", "apply", "sort", "DomSync", "syncChildren", "domConfig", "configEquality", "drawText", "unscaledSvgGroup", "isVisible", "drawBar", "barStyle", "defaultWidth", "x", "datum", "y", "rectConfig", "barTip", "callback", "style", "class", "btip", "drawOutline", "coords", "result", "outlineElement", "barWidth", "command1", "command2", "barHeight", "d", "join", "defaultY", "unscaledSvgGroups", "barText", "renderData", "className", "undefined", "initClass", "_$name", "Scale", "configurable", "scalePoints", "scaleMaxPadding", "horizontal", "align", "$config", "merge", "changeAlign", "updateAlign", "oldAlign", "classList", "remove", "add", "updateHorizontal", "oldHorizontal", "scaleMax", "path", "labels", "posFactor", "point", "isLabelStep", "Boolean", "pos", "label", "tick", "pathElement"]
}
