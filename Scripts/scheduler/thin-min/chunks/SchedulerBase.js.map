{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/view/VerticalTimeAxis.js", "../../../../Scheduler/lib/Scheduler/column/VerticalTimeAxisColumn.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayout.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutPack.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutStack.js", "../../../../Scheduler/lib/Scheduler/feature/base/ResourceTimeRangesBase.js", "../../../../Scheduler/lib/Scheduler/view/DependencyEditor.js", "../../../../Scheduler/lib/Scheduler/feature/DependencyEdit.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleContext.js", "../../../../Scheduler/lib/Scheduler/feature/EventCopyPaste.js", "../../../../Scheduler/lib/Scheduler/feature/EventDrag.js", "../../../../Scheduler/lib/Scheduler/feature/EventDragCreate.js", "../../../../Scheduler/lib/Scheduler/feature/EventTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/StickyEvents.js", "../../../../Scheduler/lib/Scheduler/feature/TimeRanges.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDom.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDomEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerEventRendering.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerStores.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerScroll.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerRegions.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerState.js", "../../../../Scheduler/lib/Scheduler/view/orientation/HorizontalRendering.js", "../../../../Scheduler/lib/Scheduler/eventlayout/VerticalLayout.js", "../../../../Scheduler/lib/Scheduler/view/orientation/VerticalRendering.js", "../../../../Scheduler/lib/Scheduler/view/SchedulerBase.js"],
  "sourcesContent": ["import TimeAxisBase from './TimeAxisBase.js';\n\n/**\n * @module Scheduler/view/VerticalTimeAxis\n */\n\n/**\n * Widget that renders a vertical time axis. Only renders ticks in view. Used in vertical mode.\n * @extends Core/widget/Widget\n * @private\n */\nexport default class VerticalTimeAxis extends TimeAxisBase {\n\n    static get $name() {\n        return 'VerticalTimeAxis';\n    }\n\n    static get configurable() {\n        return {\n            cls : 'b-verticaltimeaxis',\n\n            sizeProperty : 'height',\n\n            positionProperty : 'top',\n\n            wrapText : true\n        };\n    }\n\n    // All cells overlayed in the same space.\n    // For future use.\n    buildHorizontalCells() {\n        const\n            me                   = this,\n            { client }           = me,\n            stickyHeaders        = client?.stickyHeaders,\n            featureHeaderConfigs = [],\n            cellConfigs          = me.levels.reduce((result, level, i) => {\n                if (level.cells) {\n                    result.push(...level.cells?.filter(cell => cell.start < me.endDate && cell.end > me.startDate).map((cell, j, cells) => ({\n                        role      : 'presentation',\n                        className : {\n                            'b-sch-header-timeaxis-cell' : 1,\n                            [cell.headerCellCls]         : cell.headerCellCls,\n                            [`b-align-${cell.align}`]    : cell.align,\n                            'b-last'                     : j === cells.length - 1,\n                            'b-lowest'                   : i === me.levels.length - 1\n                        },\n                        dataset : {\n                            tickIndex      : cell.index,\n                            cellId         : `${i}-${cell.index}`,\n                            headerPosition : i,\n                            // Used in export tests to resolve dates from tick elements\n                            ...globalThis.DEBUG && { date : cell.start.getTime() }\n                        },\n                        style : {\n                            // DomHelper appends px to numeric dimensions\n                            top       : cell.coord,\n                            height    : cell.width,\n                            minHeight : cell.width\n                        },\n                        children : [\n                            {\n                                role      : 'presentation',\n                                className : {\n                                    'b-sch-header-text' : 1,\n                                    'b-sticky-header'   : stickyHeaders\n                                },\n                                html : cell.value\n                            }\n                        ]\n                    })));\n                }\n                return result;\n            }, []);\n\n        // When tested in isolation there is no client\n        client?.getHeaderDomConfigs(featureHeaderConfigs);\n\n        cellConfigs.push(...featureHeaderConfigs);\n\n        // noinspection JSSuspiciousNameCombination\n        return {\n            className : me.widgetClassList,\n            dataset   : {\n                headerFeature  : `headerRow0`,\n                headerPosition : 0\n            },\n            syncOptions : {\n                // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                // wide tickSizes\n                releaseThreshold : 5,\n                syncIdField      : 'cellId'\n            },\n            children : cellConfigs\n        };\n    }\n\n    get height() {\n        return this.size;\n    }\n}\n", "import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport VerticalTimeAxis from '../view/VerticalTimeAxis.js';\n\n/**\n * @module Scheduler/column/VerticalTimeAxisColumn\n */\n\n/**\n * A special column containing the time axis labels when the Scheduler is used in vertical mode. You can configure,\n * it using the {@link Scheduler.view.Scheduler#config-verticalTimeAxisColumn} config object.\n *\n * **Note**: this column is sized by flexing to consume full width of its containing {@link Grid.view.SubGrid}. To\n * change width of this column, instead size the subgrid like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     mode           : 'vertical',\n *     subGridConfigs : {\n *         locked : {\n *             width : 300\n *         }\n *     }\n * });\n * ```\n *\n * @extends Grid/column/Column\n */\nexport default class VerticalTimeAxisColumn extends Column {\n\n    static $name = 'VerticalTimeAxisColumn';\n\n    static get type() {\n        return 'verticalTimeAxis';\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * @hideconfigs autoWidth, autoHeight\n             */\n\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            draggable : false,\n\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            groupable : false,\n\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            hideable : false,\n\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            showColumnPicker : false,\n\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            filterable : false,\n\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            sortable : false,\n\n            // /**\n            //  * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n            //  * @config {Boolean} resizable\n            //  * @default false\n            //  * @category Interaction\n            //  * @hide\n            //  */\n            // resizable : false,\n\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            searchable : false,\n\n            /**\n             * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)\n             * @config {String} editor\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            editor : false,\n\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            enableCellContextMenu : false,\n\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n\n            /**\n             * Column minimal width. If value is Number then minimal width is in pixels\n             * @config {Number|String} minWidth\n             * @default 0\n             * @category Layout\n             */\n            minWidth : 0,\n\n            resizable : false,\n\n            cellCls : 'b-verticaltimeaxiscolumn',\n            locked  : true,\n\n            flex : 1,\n\n            alwaysClearCell : false\n        };\n    }\n\n    get isFocusable() {\n        return false;\n    }\n\n    construct(data) {\n        super.construct(...arguments);\n\n        this.view = new VerticalTimeAxis({\n            model  : this.grid.timeAxisViewModel,\n            client : this.grid\n        });\n    }\n\n    renderer({ cellElement, size }) {\n        this.view.render(cellElement);\n\n        size.height = this.view.height;\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Remove irrelevant configs\n        delete result.id;\n        delete result.region;\n        delete result.type;\n        delete result.field;\n        delete result.ariaLabel;\n        delete result.cellAriaLabel;\n\n        return result;\n    }\n}\n\nColumnStore.registerColumnType(VerticalTimeAxisColumn);\n", "import Base from '../../Core/Base.js';\n\n/**\n * @module Scheduler/eventlayout/HorizontalLayout\n */\n\n/**\n * Base class for horizontal layouts (HorizontalLayoutPack and HorizontalLayoutStack). Should not be used directly,\n * instead specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} in Scheduler config (stack,\n * pack or none):\n *\n * @example\n * let scheduler = new Scheduler({\n *   eventLayout: 'stack'\n * });\n *\n * @abstract\n * @private\n */\nexport default class HorizontalLayout extends Base {\n    static get defaultConfig() {\n        return {\n            nbrOfBandsByResource        : {},\n            bandIndexToPxConvertFn      : null,\n            bandIndexToPxConvertThisObj : null\n        };\n    }\n\n    clearCache(resource) {\n        if (resource) {\n            delete this.nbrOfBandsByResource[resource.id];\n        }\n        else {\n            this.nbrOfBandsByResource = {};\n        }\n    }\n\n    /**\n     * This method performs layout on an array of event render data and returns amount of _bands_. Band is a multiplier of a\n     * configured {@link Scheduler.view.Scheduler#config-rowHeight} to calculate total row height required to fit all\n     * events.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events Unordered array of event render data, sorting may be required\n     * @param {Scheduler.model.ResourceModel} resource The resource for which the events are being laid out.\n     * @returns {Number}\n     */\n    applyLayout(events, resource) {\n        // Return number of bands required\n        return this.nbrOfBandsByResource[resource.id] = this.layoutEventsInBands(events, resource);\n    }\n\n    /**\n     * This method iterates over events and calculates top position for each of them. Default layouts calculate\n     * positions to avoid events overlapping horizontally (except for the 'none' layout). Pack layout will squeeze events to a single\n     * row by reducing their height, Stack layout will increase the row height and keep event height intact.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events Unordered array of event render data, sorting may be required\n     * @param {Scheduler.model.ResourceModel} resource The resource for which the events are being laid out.\n     */\n    layoutEventsInBands(events, resource) {\n        throw new Error('Implement in subclass');\n    }\n}\n", "import HorizontalLayout from './HorizontalLayout.js';\nimport PackMixin from './PackMixin.js';\n\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutPack\n */\n\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Packs events (adjusts their height) to fit\n * available row height\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @mixes Scheduler/eventlayout/PackMixin\n * @private\n */\nexport default class HorizontalLayoutPack extends HorizontalLayout.mixin(PackMixin) {\n    static get $name() {\n        return 'HorizontalLayoutPack';\n    }\n\n    static get configurable() {\n        return {\n            type : 'pack'\n        };\n    }\n\n    // Packs the events to consume as little space as possible\n    layoutEventsInBands(events) {\n        const result = this.packEventsInBands(events, (event, j, slot, slotSize) => {\n            event.height = slotSize;\n            event.top    = slot.start + (j * slotSize);\n        });\n\n        events.forEach(event => {\n            Object.assign(\n                event,\n                this.bandIndexToPxConvertFn.call(\n                    this.bandIndexToPxConvertThisObj || this,\n                    event.top,\n                    event.height,\n                    event.eventRecord,\n                    event.resourceRecord\n                )\n            );\n        });\n\n        return result;\n    }\n}\n", "import HorizontalLayout from './HorizontalLayout.js';\n\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutStack\n */\n\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Stacks events, increasing row height when to fit\n * all overlapping events.\n *\n * This layout is used by default in horizontal mode.\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @private\n */\nexport default class HorizontalLayoutStack extends HorizontalLayout {\n    static get $name() {\n        return 'HorizontalLayoutStack';\n    }\n\n    static get configurable() {\n        return {\n            type : 'stack'\n        };\n    }\n\n    // Input: Array of event layout data\n    // heightRun is used when pre-calculating row heights, taking a cheaper path\n    layoutEventsInBands(events, resource, heightRun = false) {\n        let verticalPosition = 0;\n\n        do {\n            let eventIndex = 0,\n                event      = events[0];\n\n            while (event) {\n                if (!heightRun) {\n                    // Apply band height to the event cfg\n                    event.top = this.bandIndexToPxConvertFn.call(\n                        this.bandIndexToPxConvertThisObj || this,\n                        verticalPosition,\n                        event.eventRecord,\n                        event.resourceRecord\n                    );\n                }\n\n                // Remove it from the array and continue searching\n                events.splice(eventIndex, 1);\n\n                eventIndex = this.findClosestSuccessor(event, events);\n                event = events[eventIndex];\n            }\n\n            verticalPosition++;\n        } while (events.length > 0);\n\n        // Done!\n        return verticalPosition;\n    }\n\n    // <remove-on-release>\n    // TODO: optimize this for better performance with many events per resource\n    // </remove-on-release>\n    findClosestSuccessor(eventRenderData, events) {\n        const\n            { endMS, group } = eventRenderData,\n            isMilestone      = eventRenderData.eventRecord && eventRenderData.eventRecord.duration === 0;\n\n        let minGap      = Infinity,\n            closest,\n            gap,\n            event;\n\n        for (let i = 0, l = events.length; i < l; i++) {\n            event = events[i];\n            gap = event.startMS - endMS;\n\n            if (\n                gap >= 0 && gap < minGap &&\n                // Two milestones should not overlap\n                (gap > 0 || event.endMS - event.startMS > 0 || !isMilestone)\n            ) {\n                // Events are sorted by group, so when we find first event with a different group, we can stop iteration\n                if (this.grouped && group !== event.group) {\n                    break;\n                }\n                closest = i;\n                minGap  = gap;\n            }\n        }\n\n        return closest;\n    }\n}\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/base/ResourceTimeRangesBase\n */\n\n/**\n * Abstract base class for ResourceTimeRanges and ResourceNonWorkingTime features.\n * You should not use this class directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class ResourceTimeRangesBase extends InstancePlugin.mixin(AttachToProjectMixin) {\n    //region Config\n\n    static configurable = {\n        /**\n         * Specify value to use for the tabIndex attribute of range elements\n         * @config {Number}\n         * @category Misc\n         */\n        tabIndex : null,\n\n        entityName : 'resourceTimeRange'\n    };\n\n    static get pluginConfig()  {\n        return {\n            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],\n            override : ['matchScheduleCell', 'resolveResourceRecord']\n        };\n    }\n\n    // Let Scheduler know if we have ResourceTimeRanges in view or not\n    noFeatureElementsInAxis() {\n        const { timeAxis } = this.client;\n        return !this.needsRefresh && this.store && !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));\n    }\n\n    //endregion\n\n    //region Init\n\n    doDisable(disable) {\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n\n        super.doDisable(disable);\n    }\n\n    updateTabIndex() {\n        if (!this.isConfiguring) {\n            this.client.refresh();\n        }\n    }\n\n    //endregion\n\n    getEventsToRender(resource, events) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges\n    // (chained function from Scheduler)\n    onEventDataGenerated(renderData) {\n        const\n            me                       = this,\n            { eventRecord, iconCls } = renderData;\n\n        if (me.shouldInclude(eventRecord)) {\n            if (me.client.isVertical) {\n                renderData.width = renderData.resourceRecord.columnWidth || me.client.resourceColumnWidth;\n            }\n            else {\n                renderData.top = 0;\n            }\n\n            // Flag that we should fill entire row/col\n            renderData.fillSize = true;\n            // Add our own cls\n            renderData.wrapperCls['b-sch-resourcetimerange'] = 1;\n            if (me.rangeCls) {\n                renderData.wrapperCls[me.rangeCls] = 1;\n            }\n            renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;\n            // Add label\n            renderData.eventContent.text = eventRecord.name;\n            renderData.children.push(renderData.eventContent);\n\n            // Allow configuring tabIndex\n            renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;\n\n            // Add icon\n            if (iconCls?.length > 0) {\n                renderData.children.unshift({\n                    tag       : 'i',\n                    className : iconCls.toString()\n                });\n            }\n\n            // Event data for DOMSync comparison\n            renderData.eventId = me.generateElementId(eventRecord);\n        }\n    }\n\n    /**\n     * Generates ID from the passed time range record\n     * @param {Scheduler.model.TimeSpan} record\n     * @returns {String} Generated ID for the DOM element\n     * @internal\n     */\n    generateElementId(record) {\n        return record.domId;\n    }\n\n    resolveResourceTimeRangeRecord(rangeElement) {\n        return rangeElement?.closest(`.${this.rangeCls}`)?.elementData.eventRecord;\n    }\n\n    getElementFromResourceTimeRangeRecord(record) {\n        // return this.client.foregroundCanvas.querySelector(`[data-event-id=\"${record.domId}\"]`);\n        return this.client.foregroundCanvas.syncIdMap[record.domId];\n    }\n\n    resolveResourceRecord(event) {\n        const record = this.overridden.resolveResourceRecord(...arguments);\n\n        return record || this.resolveResourceTimeRangeRecord(event.target || event)?.resource;\n    }\n\n    shouldInclude(eventRecord) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI\n    onStoreChange(event) {\n        // Edge case for scheduler not using any events, it has to refresh anyway to get rid of ResourceTimeRanges\n        if (event.action === 'removeall' || event.action === 'dataset') {\n            this.needsRefresh = true;\n        }\n\n        this.client.onInternalEventStoreChange(event);\n\n        this.needsRefresh = false;\n    }\n\n    // Override to let scheduler find the time cell from a resource time range element\n    matchScheduleCell(target) {\n        let cell = this.overridden.matchScheduleCell(target);\n\n        if (!cell && this.enableMouseEvents) {\n            const\n                { client }   = this,\n                rangeElement = target.closest(`.${this.rangeCls}`);\n\n            cell = rangeElement && client.getCell({\n                record : client.isHorizontal ? rangeElement.elementData.resource : client.store.first,\n                column : client.timeAxisColumn\n            });\n        }\n\n        return cell;\n    }\n\n    handleRangeMouseEvent(domEvent) {\n        const\n            me           = this,\n            rangeElement = domEvent.target.closest(`.${me.rangeCls}`);\n\n        if (rangeElement) {\n            const\n                eventName               = EventHelper.eventNameMap[domEvent.type] ?? StringHelper.capitalize(domEvent.type),\n                resourceTimeRangeRecord = me.resolveResourceTimeRangeRecord(rangeElement);\n\n            me.client.trigger(me.entityName + eventName, {\n                feature                    : me,\n                [`${me.entityName}Record`] : resourceTimeRangeRecord,\n                resourceRecord             : me.client.resourceStore.getById(resourceTimeRangeRecord.resourceId),\n                domEvent\n            });\n        }\n    }\n\n    updateEnableMouseEvents(enable) {\n        const\n            me         = this,\n            { client } = me;\n\n        me.mouseEventsDetacher?.();\n        me.mouseEventsDetacher = null;\n\n        if (enable) {\n            function attachMouseEvents() {\n                me.mouseEventsDetacher = EventHelper.on({\n                    element     : client.foregroundCanvas,\n                    delegate    : `.${me.rangeCls}`,\n                    mousedown   : 'handleRangeMouseEvent',\n                    mouseup     : 'handleRangeMouseEvent',\n                    click       : 'handleRangeMouseEvent',\n                    dblclick    : 'handleRangeMouseEvent',\n                    contextmenu : 'handleRangeMouseEvent',\n                    mouseover   : 'handleRangeMouseEvent',\n                    mouseout    : 'handleRangeMouseEvent',\n                    thisObj     : me\n                });\n            }\n\n            client.whenVisible(attachMouseEvents);\n        }\n\n        client.element.classList.toggle('b-interactive-resourcetimeranges', Boolean(enable));\n    }\n}\n\n// No feature based styling needed, do not add a cls to Scheduler\nResourceTimeRangesBase.featureClass = '';\n", "import Popup from '../../Core/widget/Popup.js';\n\n/**\n * @module Scheduler/view/DependencyEditor\n */\n\n/**\n * A dependency editor popup.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class DependencyEditor extends Popup {\n\n    static get $name() {\n        return 'DependencyEditor';\n    }\n\n    static get defaultConfig() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners\n            },\n            axisLock : 'flexible'\n        };\n    }\n\n    processWidgetConfig(widget) {\n        const { dependencyEditFeature } = this;\n\n        if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {\n            return false;\n        }\n        if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {\n            return false;\n        }\n\n        return super.processWidgetConfig(widget);\n    }\n\n    afterShow(...args) {\n        const { deleteButton } = this.widgetMap;\n\n        // Only show delete button if the dependency record belongs to a store\n        if (deleteButton) {\n            deleteButton.hidden = !this.record.isPartOfStore();\n        }\n\n        super.afterShow(...args);\n    }\n\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n}\n", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../../Core/widget/DisplayField.js';\nimport '../../Core/widget/DurationField.js';\nimport DependencyEditor from '../view/DependencyEditor.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport Duration from '../../Core/data/Duration.js';\n\n/**\n * @module Scheduler/feature/DependencyEdit\n */\n\n/**\n * Feature that displays a popup containing fields for editing a dependency. Requires the\n * {@link Scheduler.feature.Dependencies} feature to be enabled. Double click a line in the demo below to show the\n * editor.\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * ## Customizing the built-in widgets\n *\n * ```javascript\n *  const scheduler = new Scheduler({\n *      columns : [\n *          { field : 'name', text : 'Name', width : 100 }\n *      ],\n *      features : {\n *          dependencies   : true,\n *          dependencyEdit : {\n *              editorConfig : {\n *                  items : {\n *                      // Custom label for the type field\n *                      typeField : {\n *                          label : 'Kind'\n *                      }\n *                  },\n *\n *                  bbar : {\n *                      items : {\n *                          // Hiding save button\n *                          saveButton : {\n *                              hidden : true\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n *  });\n * ```\n *\n * ## Built in widgets\n *\n * | Widget ref             | Type                              | Weight | Description               |\n * |------------------------|-----------------------------------|--------|---------------------------|\n * | `fromNameField`        | {@link Core.widget.DisplayField}  | 100    | From task name (readonly) |\n * | `toNameField`          | {@link Core.widget.DisplayField}  | 200    | To task name (readonly)   |\n * | `typeField`            | {@link Core.widget.Combo}         | 300    | Edit type                 |\n * | `lagField`             | {@link Core.widget.DurationField} | 400    | Edit lag                  |\n *\n * The built in buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                       |\n * |------------------------|----------------------------|--------|-----------------------------------|\n * | `saveButton`           | {@link Core.widget.Button} | 100    | Save button on the bbar           |\n * | `deleteButton`         | {@link Core.widget.Button} | 200    | Delete button on the bbar         |\n * | `cancelButton`         | {@link Core.widget.Button} | 300    | Cancel editing button on the bbar |\n *\n * This feature is **off** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencyEdit\n * @feature\n */\nexport default class DependencyEdit extends InstancePlugin {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{StartToStart}',\n        'L{StartToEnd}',\n        'L{EndToStart}',\n        'L{EndToEnd}'\n    ];\n    // endregion\n    // </debug>\n\n    //region Config\n\n    static get $name() {\n        return 'DependencyEdit';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * True to hide this editor if a click is detected outside it (defaults to true)\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            autoClose : true,\n\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n\n            /**\n             * True to show a delete button in the form.\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showDeleteButton : true,\n\n            /**\n             * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or\n             * `null` to disable editing of dependencies.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'dependencydblclick',\n\n            /**\n             * True to show the lag field for the dependency\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showLagField : false,\n\n            dependencyRecord : null,\n\n            /**\n             * Default editor configuration, used to configure the Popup.\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : {\n                title       : 'L{Edit dependency}',\n                localeClass : this,\n                closable    : true,\n\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the from name\n                     * @member {Core.widget.DisplayField} fromNameField\n                     * @readonly\n                     */\n                    fromNameField : {\n                        type   : 'display',\n                        weight : 100,\n                        label  : 'L{From}'\n                    },\n                    /**\n                     * Reference to the to name field\n                     * @member {Core.widget.DisplayField} toNameField\n                     * @readonly\n                     */\n                    toNameField : {\n                        type   : 'display',\n                        weight : 200,\n                        label  : 'L{To}'\n                    },\n                    /**\n                     * Reference to the type field\n                     * @member {Core.widget.Combo} typeField\n                     * @readonly\n                     */\n                    typeField : {\n                        type                  : 'combo',\n                        weight                : 300,\n                        label                 : 'L{Type}',\n                        name                  : 'type',\n                        editable              : false,\n                        valueField            : 'id',\n                        displayField          : 'name',\n                        localizeDisplayFields : true,\n                        buildItems            : function() {\n                            const dialog = this.parent;\n\n                            return Object.keys(DependencyModel.Type).map(type => ({\n                                id        : DependencyModel.Type[type],\n                                name      : dialog.L(type),\n                                localeKey : type\n                            }));\n                        }\n                    },\n\n                    /**\n                     * Reference to the lag field\n                     * @member {Core.widget.DurationField} lagField\n                     * @readonly\n                     */\n                    lagField : {\n                        type          : 'duration',\n                        weight        : 400,\n                        label         : 'L{Lag}',\n                        name          : 'lag',\n                        allowNegative : true\n                    }\n                },\n\n                bbar : {\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        foo : {\n                            type : 'widget',\n                            cls  : 'b-label-filler'\n                        },\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color : 'b-green',\n                            text  : 'L{Save}'\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            color : 'b-gray',\n                            text  : 'L{Delete}'\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            color : 'b-gray',\n                            text  : 'L{Object.Cancel}'\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        client.dependencyEdit = me;\n\n        super.construct(client, config);\n\n        if (!client.features.dependencies) {\n            throw new Error('Dependencies feature required when using DependencyEdit');\n        }\n\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : me.onActivateEditor,\n            thisObj           : me\n        });\n    }\n\n    doDestroy() {\n        this.clientListenersDetacher();\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Editing\n\n    changeEditorConfig(config) {\n        const\n            me                         = this,\n            { autoClose, cls, client } = me;\n\n        return ObjectHelper.assign({\n            owner        : client,\n            align        : 'b-t',\n            id           : `${client.id}-dependency-editor`, // no-sanity\n            autoShow     : false,\n            anchor       : true,\n            scrollAction : 'realign',\n            clippedBy    : [client.timeAxisSubGridElement, client.bodyContainer],\n            constrainTo  : globalThis,\n            autoClose,\n            cls\n        }, config);\n    }\n\n    //endregion\n\n    //region Save\n\n    get isValid() {\n        return Object.values(this.editor.widgetMap).every(field => {\n            if (!field.name || field.hidden) {\n                return true;\n            }\n\n            return field.isValid !== false;\n        });\n    }\n\n    get values() {\n        const values = {};\n\n        this.editor.eachWidget(widget => {\n            if (!widget.name || widget.hidden) return;\n\n            values[widget.name] = widget.value;\n        }, true);\n\n        return values;\n    }\n\n    /**\n     * Template method, intended to be overridden. Called before the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onBeforeSave(dependencyRecord) {}\n\n    /**\n     * Template method, intended to be overridden. Called after the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onAfterSave(dependencyRecord) {}\n\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(dependencyRecord) {\n        const { values } = this;\n\n        // Engine does not understand { magnitude, unit } syntax\n        if (values.lag) {\n            values.lagUnit = values.lag.unit;\n            values.lag = values.lag.magnitude;\n        }\n\n        // Type replaces fromSide/toSide, if they are used\n        if ('type' in values) {\n            dependencyRecord.fromSide != null && (values.fromSide = null);\n            dependencyRecord.toSide != null && (values.toSide = null);\n        }\n\n        // Chronograph doesn't filter out undefined fields, it nullifies them instead\n        // https://github.com/bryntum/chronograph/issues/11\n        ObjectHelper.cleanupProperties(values, true);\n\n        dependencyRecord.set(values);\n    }\n\n    //endregion\n\n    //region Events\n\n    onPopupKeyDown({ event }) {\n        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n\n            this.onSaveClick();\n        }\n    }\n\n    onSaveClick() {\n        if (this.save()) {\n            this.editor.hide();\n        }\n    }\n\n    onDeleteClick() {\n        this.deleteDependency();\n        this.editor.hide();\n    }\n\n    onCancelClick() {\n        this.editor.hide();\n    }\n\n    //region Editing\n\n    // Called from editDependency() to actually show the editor\n    internalShowEditor(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me;\n\n        let showPoint = me.lastPointerDownCoordinate;\n\n        /**\n         * Fires on the owning Scheduler before an dependency is displayed in the editor.\n         * This may be listened for to allow an application to take over dependency editing duties. Returning `false`\n         * stops the default editing UI from being shown.\n         * @event beforeDependencyEdit\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyEdit', {\n            dependencyEdit : me,\n            dependencyRecord\n        }) === false) {\n            return;\n        }\n\n        const editor = me.getEditor(dependencyRecord);\n\n        me.loadRecord(dependencyRecord);\n\n        /**\n         * Fires on the owning Scheduler when the editor for a dependency is available but before it is shown. Allows\n         * manipulating fields before the widget is shown.\n         * @event beforeDependencyEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @param {Core.widget.Popup} editor The editor popup\n         */\n        client.trigger('beforeDependencyEditShow', {\n            dependencyEdit : me,\n            dependencyRecord,\n            editor\n        });\n\n        if (!showPoint) {\n            const center = Rectangle.from(me.client.element).center;\n\n            showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];\n        }\n\n        editor.showBy(showPoint);\n    }\n\n    /**\n     * Opens a popup to edit the passed dependency.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit\n     */\n    editDependency(dependencyRecord) {\n        if (this.client.readOnly || dependencyRecord.readOnly) {\n            return;\n        }\n\n        this.internalShowEditor(dependencyRecord);\n    }\n\n    //endregion\n\n    //region Save\n\n    /**\n     * Gets an editor instance. Creates on first call, reuses on consecutive\n     * @internal\n     * @returns {Scheduler.view.DependencyEditor} Editor popup\n     */\n    getEditor() {\n        const me = this;\n\n        let { editor } = me;\n\n        if (editor) {\n            return editor;\n        }\n\n        editor = me.editor = DependencyEditor.new({\n            dependencyEditFeature : me,\n            autoShow              : false,\n            anchor                : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            autoClose             : me.autoClose,\n            cls                   : me.cls,\n            rootElement           : me.client.rootElement,\n            internalListeners     : {\n                keydown : me.onPopupKeyDown,\n                thisObj : me\n            }\n        }, me.editorConfig);\n\n        if (editor.items.length === 0) {\n            console.warn('Editor configured without any `items`');\n        }\n\n        // assign widget refs\n        editor.eachWidget(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n            }\n        });\n\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n\n        return me.editor;\n    }\n\n    //endregion\n\n    //region Delete\n\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(dependency) {\n        const me = this;\n\n        me.fromNameField.value = dependency.fromEvent.name;\n        me.toNameField.value = dependency.toEvent.name;\n\n        if (me.lagField) {\n            me.lagField.value = new Duration(dependency.lag, dependency.lagUnit);\n        }\n\n        me.editor.record = me.dependencyRecord = dependency;\n    }\n\n    //endregion\n\n    //region Stores\n\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeDependencySave\n     * @fires beforeDependencyAdd\n     * @fires afterDependencySave\n     * @returns {*}\n     */\n    async save() {\n        const\n            me                           = this,\n            { client, dependencyRecord } = me;\n\n        if (!dependencyRecord || !me.isValid) {\n            return;\n        }\n\n        const { dependencyStore, values } = me;\n\n        /**\n         * Fires on the owning Scheduler before a dependency is saved\n         * @event beforeDependencySave\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n         * @param {Object} values The new values\n         * @preventable\n         */\n        if (client.trigger('beforeDependencySave', {\n            dependencyRecord,\n            values\n        }) !== false) {\n            me.onBeforeSave(dependencyRecord);\n\n            me.updateRecord(dependencyRecord);\n\n            // Check if this is a new record\n            if (dependencyStore && !dependencyRecord.stores.length) {\n                /**\n                 * Fires on the owning Scheduler before a dependency is added\n                 * @event beforeDependencyAdd\n                 * @on-owner\n                 * @param {Scheduler.view.Scheduler} source The scheduler\n                 * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature\n                 * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added\n                 * @preventable\n                 */\n                if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit : me }) === false) {\n                    return;\n                }\n\n                dependencyStore.add(dependencyRecord);\n            }\n\n            await client.project?.commitAsync();\n\n            /**\n             * Fires on the owning Scheduler after a dependency is successfully saved\n             * @event afterDependencySave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n             */\n            client.trigger('afterDependencySave', { dependencyRecord });\n\n            me.onAfterSave(dependencyRecord);\n        }\n\n        return dependencyRecord;\n    }\n\n    /**\n     * Delete dependency being edited\n     * @private\n     * @fires beforeDependencyDelete\n     */\n    async deleteDependency() {\n        const { client, editor, dependencyRecord } = this;\n\n        /**\n         * Fires on the owning Scheduler before a dependency is deleted\n         * @event beforeDependencyDelete\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyDelete', { dependencyRecord }) !== false) {\n            if (editor.containsFocus) {\n                editor.revertFocus();\n            }\n\n            client.dependencyStore.remove(dependencyRecord);\n            await client.project?.commitAsync();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    get dependencyStore() {\n        return this.client.dependencyStore;\n    }\n    //endregion\n\n    //region Events\n\n    onActivateEditor({ dependency, event }) {\n        if (!this.disabled) {\n            this.lastPointerDownCoordinate = [event.clientX, event.clientY];\n            this.editDependency(dependency);\n        }\n    }\n\n    //endregion\n\n}\n\nGridFeatureManager.registerFeature(DependencyEdit, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n\n/**\n * @module Scheduler/feature/ScheduleContext\n */\n\n/**\n * Allow visually selecting a schedule \"cell\" by clicking, or {@link #config-triggerEvent any other pointer gesture}.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         // Configure as a truthy value to enable the feature\n *         scheduleContext : {\n *             triggerEvent : 'hover',\n *             renderer     : (context, element) => {\n *                 element.innerText = '';\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * The contextual details are available in the {@link #property-context} property.\n *\n * **Note that the context is cleared upon change of {@link Scheduler.view.Scheduler#property-viewPreset}\n * such as when zooming in or out.**\n *\n * @extends Core/mixin/InstancePlugin\n * @inlineexample Scheduler/feature/ScheduleContext.js\n * @classtype scheduleContext\n * @feature\n */\nexport default class ScheduleContext extends InstancePlugin.mixin(Delayable) {\n    static get $name() {\n        return 'ScheduleContext';\n    }\n\n    static delayable = {\n        syncContextElement : 'raf'\n    };\n\n    static configurable = {\n        /**\n         * The pointer event type to use to update the context. May be `'hover'` to highlight the\n         * tick context when moving the mouse across the timeline.\n         * @config {'click'|'hover'|'contextmenu'|'mousedown'}\n         * @default\n         */\n        triggerEvent : 'click',\n\n        /**\n         * A function (or the name of a function) which may mutate the contents of the context overlay\n         * element which tracks the active resource/tick context.\n         * @config {String|Function}\n         * @param {TimelineContext} context The context being highlighted.\n         * @param {HTMLElement} element The context highlight element. This will be empty each time.\n         */\n        renderer : null,\n\n        /**\n         * The active context.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         */\n        context : {\n            $config : {\n                // Reject non-changes so that when using mousemove, we only update the context\n                // when it changes.\n                equal(c1, c2) {\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        }\n    };\n\n    /**\n     * The contextual information about which cell was clicked on and highlighted.\n     *\n     * When the {@link Scheduler.view.Scheduler#property-viewPreset} is changed (such as when zooming)\n     * the context is cleared and the highlight is removed.\n     *\n     * @member {Object} context\n     * @property {Scheduler.view.TimelineBase} context.source The owning Scheduler\n     * @property {Date} context.date Date at mouse position\n     * @property {Scheduler.model.TimeSpan} context.tick A record which encapsulates the time axis tick clicked on.\n     * @property {Number} context.tickIndex The index of the time axis tick clicked on.\n     * @property {Date} context.tickStartDate The start date of the current time axis tick\n     * @property {Date} context.tickEndDate The end date of the current time axis tick\n     * @property {Grid.row.Row} context.row Clicked row (in horizontal mode only)\n     * @property {Number} context.index Index of clicked resource\n     * @property {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n     * @property {MouseEvent} context.event Browser event\n     */\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        const\n            { triggerEvent } = this,\n            listeners        = {\n                datachange              : 'syncContextElement',\n                timeaxisviewmodelupdate : 'onTimeAxisViewModelUpdate',\n                presetchange            : 'clearContext',\n                thisObj                 : this\n            };\n\n        // If mousemove is our trigger, we cab use the client's timelineContextChange event\n        if (triggerEvent === 'mouseover') {\n            listeners.timelineContextChange = 'onTimelineContextChange';\n        }\n        // Otherwise, we have to listen for the required events on Schedule and events\n        else {\n            // Context menu will be expected to update the context if click or mousedown\n            // is the triggerEvent. Context menu is a mousedown gesture.\n            if (triggerEvent === 'click' || triggerEvent === 'mousedown') {\n                listeners.schedulecontextmenu = 'onScheduleContextGesture';\n            }\n\n            Object.assign(listeners, {\n                [`schedule${triggerEvent}`] : 'onScheduleContextGesture',\n                [`event${triggerEvent}`]    : 'onScheduleContextGesture',\n                ...listeners\n            });\n        }\n\n        // required to work\n        client.useBackgroundCanvas = true;\n\n        client.ion(listeners);\n        client.rowManager.ion({\n            rowheight : 'syncContextElement',\n            thisObj   : this\n        });\n    }\n\n    changeTriggerEvent(triggerEvent) {\n        // Both these things should route through to using the client's timelineContextChange event\n        if (triggerEvent === 'hover' || triggerEvent === 'mousemove') {\n            triggerEvent = 'mouseover';\n        }\n        return triggerEvent;\n    }\n\n    get element() {\n        return this._element || (this._element = DomHelper.createElement({\n            parent    : this.client.backgroundCanvas,\n            className : 'b-schedule-selected-tick'\n        }));\n    }\n\n    // Handle the Client's own timelineContextChange event which it maintains on mousemove\n    onTimelineContextChange({ context }) {\n        this.context = context;\n    }\n\n    // Handle the scheduleclick or eventclick Scheduler events if we re not using mouseover\n    onScheduleContextGesture(context) {\n        this.context = context;\n    }\n\n    onTimeAxisViewModelUpdate({ source : timeAxisViewModel }) {\n        // Just a mutation of existing tick details, sync the element\n        if (timeAxisViewModel.timeAxis.includes(this.context?.tick)) {\n            this.syncContextElement();\n        }\n        // The tick has gone, we have moved to a new ViewPreset, so clear the context.\n        else {\n            this.clearContext();\n        }\n    }\n\n    clearContext() {\n        this.context = null;\n    }\n\n    updateContext(context, oldContext) {\n        this.syncContextElement();\n    }\n\n    syncContextElement() {\n        if (this.context && this.enabled) {\n            const\n                me  = this,\n                {\n                    client,\n                    element,\n                    context,\n                    renderer\n                }   = me,\n                {\n                    isVertical\n                }   = client,\n                {\n                    style\n                }   = element,\n                row = isVertical ? client.rowManager.rows[0] : client.getRowFor(context.resourceRecord);\n\n            if (row) {\n                const\n                    {\n                        tickStartDate,\n                        tickEndDate,\n                        resourceRecord\n                    } = context,\n                    // get the position clicked based on dates\n                    renderData = client.currentOrientation.getTimeSpanRenderData({\n                        startDate   : tickStartDate,\n                        endDate     : tickEndDate,\n                        startDateMS : tickStartDate.getTime(),\n                        endDateMS   : tickEndDate.getTime()\n                    }, resourceRecord);\n\n                let top, width, height;\n\n                if (isVertical) {\n                    top = renderData.top;\n                    width = renderData.resourceWidth;\n                    height = renderData.height;\n                }\n                else {\n                    top = row.top;\n                    width = renderData.width;\n                    height = row.height;\n                }\n\n                // Move to current cell\n                style.display = '';\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                DomHelper.setTranslateXY(element, renderData.left, top);\n\n                // In case we updated on a datachange action : 'remove' or 'add' event.\n                context.index = row.index;\n\n                // Undo any contents added by the renderer last time round.\n                element.innerHTML = '';\n\n                // Show the context and the element to the renderer\n                renderer && me.callback(renderer, me, [context, element]);\n            }\n            // No row for resource might mean it's scrolled out of view or filtered out\n            // so just hide so that the next valid sync can restore it to visibility\n            else {\n                style.display = 'none';\n            }\n        }\n        else {\n            this.element.style.display = 'none';\n        }\n    }\n}\n\nScheduleContext.featureClass = 'b-scheduler-context';\n\nGridFeatureManager.registerFeature(ScheduleContext, false, ['Scheduler']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport './ScheduleContext.js';\n\n/**\n * @module Scheduler/feature/EventCopyPaste\n */\n\n/**\n * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste events.\n *\n * This feature also adds entries to the {@link Scheduler/feature/EventMenu} for copying & cutting (see example below\n * for how to configure) and to the {@link Scheduler/feature/ScheduleMenu} for pasting.\n *\n * You can configure how a newly pasted record is named using {@link #function-generateNewName}.\n *\n * {@inlineexample Scheduler/feature/EventCopyPaste.js}\n *\n * If you want to highlight the paste location when clicking in the schedule, consider enabling the\n * {@link Scheduler/feature/ScheduleContext} feature.\n *\n * <div class=\"note\">When used with Scheduler Pro, pasting will bypass any constraint set on the event to allow the\n * copy to be assigned the targeted date.</div>\n *\n * This feature is **enabled** by default.\n *\n * ## Customize menu items\n *\n * See {@link Scheduler/feature/EventMenu} and {@link Scheduler/feature/ScheduleMenu} for more info on customizing the\n * menu items supplied by the feature. This snippet illustrates the concept:\n *\n * ```javascript\n * // Custom copy text + remove cut option from event menu:\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 copyEvent : {\n *                     text : 'Copy booking'\n *                 },\n *                 cutEvent  : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Keyboard shortcuts\n *\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action   | Action description                                |\n * |------------|----------|---------------------------------------------------|\n * | `Ctrl`+`C` | *copy*   | Copies selected event(s) into the clipboard.      |\n * | `Ctrl`+`X` | *cut*    | Cuts out selected event(s) into the clipboard.    |\n * | `Ctrl`+`V` | *paste*  | Insert copied or cut event(s) from the clipboard. |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Scheduler/guides/customization/keymap.md).\n *\n * ## Multi assigned events\n *\n * In a Scheduler that uses single assignment, copying and then pasting creates a clone of the event and assigns it\n * to the target resource. Cutting and pasting moves the original event to the target resource.\n *\n * In a Scheduler using multi assignment, the behaviour is slightly more complex. Cutting and pasting reassigns the\n * event to the target, keeping other assignments of the same event intact. The behaviour for copying and pasting is\n * configurable using the {@link #config-copyPasteAction} config. It accepts two values:\n *\n * * `'clone'` - The default, the event is cloned and the clone is assigned to the target resource. Very similar to the\n *   behaviour with single assignment (event count goes up by 1).\n * * `'assign'` - The original event is assigned to the target resource (event count is unaffected).\n *\n * This snippet shows how to reconfigure it:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventCopyPaste : {\n *             copyPasteAction : 'assign'\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">Copying multiple assignments of the same event will always result in all but the first assignment\n * being removed on paste, since paste targets a single resource and an event can only be assigned to a resource once.\n * </div>\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventCopyPaste\n * @feature\n */\n\nexport default class EventCopyPaste extends InstancePlugin {\n    static $name = 'EventCopyPaste';\n\n    static pluginConfig = {\n        assign : [\n            'copyEvents',\n            'pasteEvents'\n        ],\n        chain : [\n            'populateEventMenu',\n            'populateScheduleMenu',\n            'onEventDataGenerated'\n        ]\n    };\n\n    static configurable = {\n        /**\n         * The field to use as the name field when updating the name of copied records\n         * @config {String}\n         * @default\n         */\n        nameField : 'name',\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            'Ctrl+C' : 'copy',\n            'Ctrl+X' : 'cut',\n            'Ctrl+V' : 'paste'\n        },\n\n        /**\n         * How to handle a copy paste operation when the host uses multi assignment. Either:\n         *\n         * - `'clone'`  - The default, clone the copied event, assigning the clone to the target resource.\n         * - `'assign'` - Add an assignment for the existing event to the target resource.\n         *\n         * For single assignment mode, it always uses the `'clone'` behaviour.\n         *\n         * @config {'clone'|'assign'}\n         * @default\n         */\n        copyPasteAction : 'clone'\n    };\n\n    clipboardRecords = [];\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        scheduler.ion({\n            eventclick    : this.onEventClick,\n            scheduleclick : this.onScheduleClick,\n            projectChange : () => {\n                this.clearClipboard();\n                this._cellClickedContext = null;\n            },\n            thisObj : this\n        });\n\n        this.scheduler = scheduler;\n    }\n\n    // Used in events to separate events from different features from each other\n    entityName = 'event';\n\n    onEventDataGenerated(eventData) {\n        const { assignmentRecord } = eventData;\n\n        // No assignmentRecord for resource time ranges, which we want to ignore anyway\n        if (assignmentRecord) {\n            eventData.cls['b-cut-item'] = assignmentRecord.meta.isCut;\n        }\n    }\n\n    onEventClick(context) {\n        this._cellClickedContext = null;\n    }\n\n    onScheduleClick(context) {\n        this._cellClickedContext = context;\n    }\n\n    isActionAvailable({ event }) {\n        const cellEdit = this.client.features.cellEdit;\n\n        // No action if\n        // 1. there is selected text on the page\n        // 2. cell editing is active\n        // 3. cursor is not in the grid (filter bar etc)\n        // 4. focus is on specialrow\n        return !this.disabled &&\n            globalThis.getSelection().toString().length === 0 &&\n            !cellEdit?.isEditing &&\n            Boolean(event.target.closest('.b-timeaxissubgrid')) &&\n            !this.client.focusedCell?.isSpecialRow;\n    }\n\n    copy() {\n        this.copyEvents();\n    }\n\n    cut() {\n        this.copyEvents(undefined, true);\n    }\n\n    paste() {\n        this.pasteEvents();\n    }\n\n    /**\n     * Copy events (when using single assignment mode) or assignments (when using multi assignment mode) to clipboard to\n     * paste later\n     * @fires beforeCopy\n     * @fires copy\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} [records] Pass records to copy them,\n     * leave out to copying current selection\n     * @param {Boolean} [isCut] Copies by default, pass `true` to cut instead\n     * @category Edit\n     */\n    copyEvents(records = this.scheduler.selectedAssignments, isCut = false) {\n        const\n            me                        = this,\n            { scheduler, entityName } = me;\n\n        if (!records?.length) {\n            return;\n        }\n\n        let assignmentRecords = records.slice(); // Slice to not lose records if selection changes\n\n        if (records[0].isEventModel) {\n            assignmentRecords = records.map(r => r.assignments).flat();\n        }\n\n        // Prevent cutting readOnly events\n        if (isCut) {\n            assignmentRecords = assignmentRecords.filter(a => !a.event.readOnly);\n        }\n\n        const eventRecords = assignmentRecords.map(a => a.event);\n\n        /**\n         * Fires on the owning Scheduler before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} records Deprecated, will be removed in 6.0. Use eventRecords instead.\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records about to be copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records about to be copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforeCopy events\n         */\n        if (!assignmentRecords.length || scheduler.readOnly || scheduler.trigger('beforeCopy', {\n            assignmentRecords, records : eventRecords, eventRecords, isCut, entityName\n        }) === false) {\n            return;\n        }\n\n        /**\n         * Fires on the owning Scheduler after a copy action is performed.\n         * @event copy\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records that were copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records that were copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other copy events\n         */\n        if (assignmentRecords.length > 0) {\n            scheduler.trigger('copy', { assignmentRecords, eventRecords, isCut, entityName });\n        }\n\n        me._isCut    = isCut;\n        // records is used when call comes from context menu where the current event is the context\n        me.clipboard = { assignmentRecords, eventRecords };\n\n        scheduler.assignmentStore.forEach(assignment => {\n            assignment.meta.isCut = isCut && assignmentRecords.includes(assignment);\n        });\n\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        scheduler.refreshWithTransition();\n    }\n\n    /**\n     * Paste events or assignments to specified date and resource\n     * @fires beforePaste\n     * @fires paste\n     * @param {Date} [date] Date where the events or assignments will be pasted\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] Resource to assign the pasted events or assignments to\n     * @category Edit\n     */\n    pasteEvents(date, resourceRecord) {\n        const\n            me                                   = this,\n            { clipboard, scheduler, entityName } = me;\n\n        if (!clipboard) {\n            return;\n        }\n\n        const\n            { assignmentRecords, eventRecords }  = clipboard,\n            isCut                                = me._isCut;\n        let reason;\n\n        if (arguments.length === 0) {\n            const context  = me._cellClickedContext || {};\n            date           = context.date;\n            resourceRecord = context.resourceRecord;\n        }\n\n        if (resourceRecord) {\n            // No pasting to readOnly resources\n            if (resourceRecord.readOnly) {\n                reason = 'resourceReadOnly';\n            }\n\n            resourceRecord = resourceRecord.$original;\n        }\n\n        if (!scheduler.allowOverlap) {\n            const pasteWouldResultInOverlap = assignmentRecords.some(assignmentRecord => !scheduler.isDateRangeAvailable(\n                assignmentRecord.event.startDate,\n                assignmentRecord.event.endDate,\n                isCut ? assignmentRecord.event : null,\n                assignmentRecord.resource)\n            );\n\n            if (pasteWouldResultInOverlap) {\n                reason = 'overlappingEvents';\n            }\n        }\n\n        /**\n         * Fires on the owning Scheduler if a paste action is not allowed\n         * @event pasteNotAllowed\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n         * @param {Date} date The paste date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other `pasteNotAllowed` events\n         * @param {'overlappingEvents'|'resourceReadOnly'} reason A string id to use for displaying an error message to the user.\n         */\n        if (reason) {\n            scheduler.trigger('pasteNotAllowed', {\n                assignmentRecords,\n                records        : eventRecords,\n                eventRecords,\n                resourceRecord : resourceRecord || assignmentRecords[0].resource,\n                date,\n                isCut,\n                entityName,\n                reason\n            });\n            return;\n        }\n\n        /**\n         * Fires on the owning Scheduler before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} records Deprecated, will be removed in 6.0. Use eventRecords instead.\n         * @param {Scheduler.model.EventModel[]} eventRecords The events about to be pasted\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignments about to be pasted\n         * @param {Date} date The date when the pasted events will be scheduled\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record, the clipboard\n         * event records will be assigned to this resource.\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforePaste events\n         */\n        if (\n            !clipboard ||\n            scheduler.trigger('beforePaste',\n                {\n                    assignmentRecords,\n                    records        : eventRecords,\n                    eventRecords,\n                    resourceRecord : resourceRecord || assignmentRecords[0].resource,\n                    date,\n                    isCut,\n                    entityName\n                }) === false\n        ) {\n            return;\n        }\n\n        let toFocus = null;\n\n        const\n            pastedEvents = new Set(),\n            pastedEventRecords = [];\n\n        for (const assignmentRecord of assignmentRecords) {\n            let { event }            = assignmentRecord;\n            const\n                targetResourceRecord = resourceRecord || assignmentRecord.resource,\n                targetDate           = date || assignmentRecord.event.startDate;\n\n            // Pasting targets a specific resource, we cannot have multiple assignments to the same so remove all but\n            // the first (happens when pasting multiple assignments of the same event)\n            if (pastedEvents.has(event)) {\n                if (isCut) {\n                    assignmentRecord.remove();\n                }\n                continue;\n            }\n\n            pastedEvents.add(event);\n\n            // Cut always means reassign\n            if (isCut) {\n                assignmentRecord.meta.isCut = false;\n                assignmentRecord.resource   = targetResourceRecord;\n                toFocus                     = assignmentRecord;\n            }\n            // Copy creates a new event in single assignment, or when configured to copy\n            else if (scheduler.eventStore.usesSingleAssignment || me.copyPasteAction === 'clone') {\n                event      = event.copy();\n                event.name = me.generateNewName(event);\n                scheduler.eventStore.add(event);\n                event.assign(targetResourceRecord);\n                toFocus = scheduler.assignmentStore.last;\n            }\n            // Safeguard against pasting on a resource where the event is already assigned,\n            // a new assignment in multiassign mode will only change the date in such case\n            else if (!event.resources.includes(targetResourceRecord)) {\n                const newAssignmentRecord    = assignmentRecord.copy();\n                newAssignmentRecord.resource = targetResourceRecord;\n                [toFocus]                    = scheduler.assignmentStore.add(newAssignmentRecord);\n            }\n\n            event.startDate = targetDate;\n\n            // Pro specific, to allow event to appear where pasted\n            if (event.constraintDate) {\n                event.constraintDate = null;\n            }\n\n            pastedEventRecords.push(event);\n        }\n\n        /**\n         * Fires on the owning Scheduler after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords Original events\n         * @param {Scheduler.model.EventModel[]} pastedEventRecords Pasted events\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Pasted assignments\n         * @param {Date} date date Pasted to this date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other paste events\n         */\n        if (clipboard) {\n            scheduler.trigger('paste', { assignmentRecords, pastedEventRecords, eventRecords, resourceRecord, date, isCut, entityName });\n        }\n\n        // Focus the last pasted assignment\n        const detacher = scheduler.ion({\n            renderEvent({ assignmentRecord }) {\n                if (assignmentRecord === toFocus) {\n                    scheduler.navigateTo(assignmentRecord, { scrollIntoView : false });\n                    detacher();\n                }\n            }\n        });\n\n        if (isCut) {\n            me.clearClipboard();\n        }\n    }\n\n    /**\n     * Clears the clipboard and refreshes the UI\n     */\n    clearClipboard() {\n        const me = this;\n        if (me._isCut) {\n            me.clipboard.assignmentRecords.forEach(assignment => {\n                assignment.meta.isCut = false;\n            });\n            me.scheduler.refreshWithTransition();\n            me._isCut = false;\n        }\n        // reset clipboard\n        me.clipboard = null;\n    }\n\n    populateEventMenu({ assignmentRecord, items }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        if (!scheduler.readOnly) {\n            items.copyEvent = {\n                text        : 'L{copyEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n\n                    me.copyEvents(assignments);\n                }\n            };\n\n            items.cutEvent = {\n                text        : 'L{cutEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 120,\n                disabled    : assignmentRecord.event.readOnly,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n                    me.copyEvents(assignments, true);\n                }\n            };\n        }\n    }\n\n    populateScheduleMenu({ items, resourceRecord }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        if (!scheduler.readOnly && me.clipboard) {\n            items.pasteEvent = {\n                text        : 'L{pasteEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                disabled    : scheduler.resourceStore.count === 0 || resourceRecord.readOnly,\n                weight      : 110,\n                onItem      : ({\n                    date, resourceRecord\n                }) => me.pasteEvents(date, resourceRecord, scheduler.getRowFor(resourceRecord))\n            };\n        }\n    }\n\n    /**\n     * A method used to generate the name for a copy pasted record. By defaults appends \"- 2\", \"- 3\" as a suffix.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord The new eventRecord being pasted\n     * @returns {String}\n     */\n    generateNewName(eventRecord) {\n        const originalName = eventRecord[this.nameField];\n\n        let counter = 2;\n\n        while (this.client.eventStore.findRecord(this.nameField, `${originalName} - ${counter}`)) {\n            counter++;\n        }\n\n        return `${originalName} - ${counter}`;\n    }\n}\n\nEventCopyPaste.featureClass = 'b-event-copypaste';\n\nGridFeatureManager.registerFeature(EventCopyPaste, true, 'Scheduler');\n", "import DragBase from './base/DragBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/EventDrag\n */\n\n/**\n * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.\n *\n * This feature is **enabled** by default\n *\n * ## Customizing the drag drop tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * features: {\n *     eventDrag : {\n *         // A minimal start date tooltip\n *         tooltipTemplate : ({ eventRecord, startDate }) => {\n *             return DateHelper.format(startDate, 'HH:mm');\n *         }\n *     }\n * }\n * ```\n *\n * ## Constraining the drag drop area\n *\n * You can constrain how the dragged event is allowed to move by using the following configs\n * * {@link #config-constrainDragToResource} Resource fixed, only allowed to change start date\n * * {@link #config-constrainDragToTimeSlot} Start date is fixed, only move between resources\n * * {@link Scheduler.view.Scheduler#config-getDateConstraints} A method on the Scheduler instance\n *    which lets you define the date range for the dragged event programmatically\n *\n * ```js\n * // Enable dragging + constrain drag to current resource\n * const scheduler = new Scheduler({\n *     features : {\n *         eventDrag : {\n *             constrainDragToResource : true\n *         }\n *     }\n * });\n * ```\n *\n * ## Drag drop events from outside\n *\n * Dragging unplanned events from an external grid is a very popular use case. There are\n * several demos showing you how to do this. Please see the [Drag from grid demo](../examples/dragfromgrid)\n * and study the **Drag from grid guide** to learn more.\n *\n * ## Drag drop events to outside target\n *\n * You can also drag events outside the schedule area by setting {@link #config-constrainDragToTimeline} to `false`. You\n * should also either:\n * * provide a {@link #config-validatorFn} to programmatically define if a drop location is valid or not\n * * configure a {@link #config-externalDropTargetSelector} CSS selector to define where drops are allowed\n *\n * See [this demo](../examples/drag-outside) to see this in action.\n *\n * ## Validating drag drop\n *\n * It is easy to programmatically decide what is a valid drag drop operation. Use the {@link #config-validatorFn}\n * and return either `true` / `false` (optionally a message to show to the user).\n *\n * ```javascript\n * features : {\n *     eventDrag : {\n *        validatorFn({ eventRecords, newResource }) {\n *            const task  = eventRecords[0],\n *                  valid = newResource.role === task.resource.role;\n *\n *            return {\n *                valid   : newResource.role === task.resource.role,\n *                message : valid ? '' : 'Resource role does not match required role for this task'\n *            };\n *        }\n *     }\n * }\n * ```\n *\n * See [this demo](../examples/validation) to see validation in action.\n *\n * If you instead want to do a single validation upon drop, you can listen to {@link #event-beforeEventDropFinalize}\n * and set the `valid` flag on the context object provided.\n *\n * ```javascript\n *   const scheduler = new Scheduler({\n *      listeners : {\n *          beforeEventDropFinalize({ context }) {\n *              const { eventRecords } = context;\n *              // Don't allow dropping events in the past\n *              context.valid = Date.now() <= eventRecords[0].startDate;\n *          }\n *      }\n *  });\n * ```\n *\n * ## Preventing drag of certain events\n *\n * To prevent certain events from being dragged, you have two options. You can set {@link Scheduler.model.EventModel#field-draggable}\n * to `false` in your data, or you can listen for the {@link Scheduler.view.Scheduler#event-beforeEventDrag} event and\n * return `false` to block the drag.\n *\n * ```javascript\n * new Scheduler({\n *    listeners : {\n *        beforeEventDrag({ eventRecord }) {\n *            // Don't allow dragging events that have already started\n *            return Date.now() <= eventRecord.startDate;\n *        }\n *    }\n * })\n * ```\n *\n * @extends Scheduler/feature/base/DragBase\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventDrag.js\n * @classtype eventDrag\n * @feature\n */\nexport default class EventDrag extends DragBase {\n    //region Config\n\n    static get $name() {\n        return 'EventDrag';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Template used to generate drag tooltip contents.\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             dragTipTemplate({eventRecord, startText}) {\n             *                 return `${eventRecord.name}: ${startText}`\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Boolean} data.valid Currently over a valid drop target or not\n             * @param {Date} data.startDate New start date\n             * @param {Date} data.endDate New end date\n             * @returns {String}\n             */\n\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @member {Boolean} constrainDragToResource\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToResource : false,\n\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @member {Boolean} constrainDragToTimeSlot\n             */\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeSlot : false,\n\n            /**\n             * A CSS selector specifying elements outside the scheduler element which are valid drop targets.\n             * @config {String}\n             */\n            externalDropTargetSelector : null,\n\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on the item being\n             * dragged. This function is called during the drag and drop process and also after the drop is made.\n             * Return `true` if the new position is valid, `false` to prevent the drag.\n             *\n             * ```javascript\n             * features : {\n             *     eventDrag : {\n             *         validatorFn({ eventRecords, newResource }) {\n             *             const\n             *                 task  = eventRecords[0],\n             *                 valid = newResource.role === task.resource.role;\n             *\n             *             return {\n             *                 valid   : newResource.role === task.resource.role,\n             *                 message : valid ? '' : 'Resource role does not match required role for this task'\n             *             };\n             *         }\n             *     }\n             * }\n             * ```\n             * @param {Object} context A drag drop context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records which were dragged\n             * @param {Scheduler.model.EventModel[]} context.eventRecords Event records which were dragged\n             * @param {Scheduler.model.ResourceModel} context.newResource New resource record\n             * @param {Scheduler.model.EventModel} context.targetEventRecord Currently hovering this event record\n             * @param {Event} event The event object\n             * @returns {Boolean|Object} `true` if this validation passes, `false` if it does not.\n             *\n             * Or an object with 2 properties: `valid` -  Boolean `true`/`false` depending on validity,\n             * and `message` - String with a custom error message to display when invalid.\n             * @config {Function}\n             */\n            validatorFn : (context, event) => {},\n\n            /**\n             * The `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @member {Boolean} unifiedDrag\n             */\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @config {Boolean}\n             * @default false\n             */\n            unifiedDrag : null,\n\n            /**\n             * A hook that allows manipulating the position the drag proxy snaps to. Manipulate the `snapTo` property\n             * to alter snap position.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             snapToPosition({ eventRecord, snapTo }) {\n             *                 if (eventRecord.late) {\n             *                     snapTo.x = 400;\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord Dragged assignment\n             * @param {Scheduler.model.EventModel} context.eventRecord Dragged event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord Currently over this resource\n             * @param {Date} context.startDate Start date for current position\n             * @param {Date} context.endDate End date for current position\n             * @param {Object} context.snapTo\n             * @param {Number} context.snapTo.x X to snap to\n             * @param {Number} context.snapTo.y Y to snap to\n             */\n            snapToPosition : null,\n\n            /**\n             * A modifier key (CTRL, SHIFT, ALT, META) that when pressed will copy an event instead of moving it. Set to\n             * empty string to disable copying\n             * @prp {'CTRL'|'ALT'|'SHIFT'|'META'|''}\n             * @default\n             */\n            copyKey : 'SHIFT',\n\n            /**\n             * Event can be copied two ways: either by adding new assignment to an existing event ('assignment'), or\n             * by copying the event itself ('event'). 'auto' mode will pick 'event' for a single-assignment mode (when\n             * event has `resourceId` field) and 'assignment' mode otherwise.\n             * @prp {'auto'|'assignment'|'event'}\n             * @default\n             */\n            copyMode : 'auto',\n\n            /**\n             * Mode of the current drag drop operation.\n             * @member {'move'|'copy'}\n             * @readonly\n             */\n            mode : 'move',\n\n            capitalizedEventName : null\n        };\n    }\n\n    afterConstruct() {\n        this.capitalizedEventName = this.capitalizedEventName || this.client.capitalizedEventName;\n        super.afterConstruct(...arguments);\n    }\n\n    //endregion\n\n    changeMode(value) {\n        const { dragData, copyMode } = this;\n\n        // Do not create assignments in case scheduler doesn't use multiple assignments\n        // Do not allow to copy recurring events\n        if (\n            (copyMode === 'event' || copyMode === 'auto' ||\n                copyMode === 'assignment' && !this.scheduler.eventStore.usesSingleAssignment) &&\n            (!dragData || dragData.eventRecords.every(r => !r.isRecurring))\n        ) {\n            return value;\n        }\n    }\n\n    updateMode(mode) {\n        if (this.dragData) {\n            if (mode === 'copy') {\n                this.setCopying();\n            }\n            else {\n                this.setMoving();\n            }\n\n            /**\n             * Triggered when drag mode is changed, for example when copy key is\n             * pressed or released while dragging.\n             * @event eventDragModeChange\n             * @param {String} mode Drag mode, could be either 'move', 'copy', or 'auto'\n             * @on-owner\n             */\n            this.client.trigger('eventDragModeChange', { mode });\n        }\n    }\n\n    setCopying() {\n        const { dragData } = this;\n\n        if (!dragData) {\n            return;\n        }\n\n        // Check if proxies are added to the DOM by checking if any of them is\n        if (!dragData.eventBarCopies.some(el => el.isConnected)) {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.add('b-drag-proxy-copy');\n                // hidden class can be added by the drag feature if we're dragging event outside\n                el.classList.remove('b-hidden');\n\n                dragData.context.grabbedParent.appendChild(el);\n                // Mark this node as ignored for the DomSync\n                el.retainElement = true;\n            });\n        }\n        else {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.remove('b-hidden');\n            });\n        }\n    }\n\n    setMoving() {\n        const { dragData } = this;\n\n        if (!dragData) {\n            return;\n        }\n\n        dragData.eventBarCopies.forEach(el => {\n            el.classList.add('b-hidden');\n        });\n    }\n\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler to allow implementer to use asynchronous finalization by setting `context.async = true`\n     * in the listener, to show a confirmation popup etc.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * For synchronous one-time validation, simply set `context.valid` to true or false.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.valid = false;\n     *  })\n     * ```\n     * @event beforeEventDropFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to not finalize the drag-drop operation immediately (e.g. to wait for user confirmation)\n     * @param {Scheduler.model.EventModel[]} context.eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records being dragged\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {Boolean} context.valid Set this to `false` to abort the drop immediately.\n     * @param {Function} context.finalize Call this method after an **async** finalization flow, to finalize the drag-drop operation. This method accepts one\n     * argument: pass `true` to update records, or `false` to ignore changes\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler after event drop\n     * @event afterEventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Boolean} valid\n     * @param {Object} context\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when an event is dropped\n     * @event eventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {HTMLElement} externalDropTarget The HTML element dropped upon, if drop happened on a valid external drop target\n     * @param {Boolean} isCopy\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler before event dragging starts. Return `false` to prevent the action.\n     * @event beforeEventDrag\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record the drag starts from\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when event dragging starts\n     * @event eventDragStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when event is dragged\n     * @event eventDrag\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {Date} startDate Start date for the current location\n     * @param {Date} endDate End date for the current location\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag started from\n     * @param {Scheduler.model.ResourceModel} newResource Resource at the current location\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to `false` to signal that the current drop position is invalid.\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler after an event drag operation has been aborted\n     * @event eventDragAbort\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation regardless of the operation being cancelled or not\n     * @event eventDragReset\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     */\n    //endregion\n\n    //region Data layer\n\n    // Deprecated. Use this.client instead\n    get scheduler() {\n        return this.client;\n    }\n\n    //endregion\n\n    //#region Drag lifecycle\n\n    onAfterDragStart(event) {\n        const\n            me                        = this,\n            { context : { element } } = event;\n\n        super.onAfterDragStart(event);\n\n        me.handleKeyDownOrMove(event.event);\n\n        me.keyEventDetacher = EventHelper.on({\n            // In case we drag event between scheduler focused event gets moved and focus\n            // moves to the body. We only need to read the key from this event\n            element : DomHelper.getRootElement(element),\n            keydown : me.handleKeyDownOrMove,\n            keyup   : me.handleKeyUp,\n            thisObj : me\n        });\n    }\n\n    onDragReset(event) {\n        super.onDragReset(event);\n\n        this.keyEventDetacher?.();\n\n        this.mode = 'move';\n    }\n\n    onDrop(event) {\n        // Always remove proxy on drop\n        this.dragData.eventBarCopies?.forEach(el => el.remove());\n\n        return super.onDrop(event);\n    }\n\n    //#endregion\n\n    //region Drag events\n\n    getDraggableElement(el) {\n        return el?.closest(this.drag.targetSelector);\n    }\n\n    resolveEventRecord(eventElement, client = this.client) {\n        return client.resolveEventRecord(eventElement);\n    }\n\n    isElementDraggable(el, event) {\n        const\n            me           = this,\n            { client }   = me,\n            eventElement = me.getDraggableElement(el);\n\n        if (!eventElement || me.disabled || client.readOnly) {\n            return false;\n        }\n\n        // displaying something resizable within the event?\n        if (el.matches('[class$=\"-handle\"]')) {\n            return false;\n        }\n\n        const eventRecord = me.resolveEventRecord(eventElement, client);\n\n        if (!eventRecord || !eventRecord.isDraggable || eventRecord.readOnly) {\n            return false;\n        }\n\n        // Hook for features that need to prevent drag\n        const prevented = client[`is${me.capitalizedEventName}ElementDraggable`]?.(\n            eventElement, eventRecord, el, event\n        ) === false;\n\n        return !prevented;\n    }\n\n    getTriggerParams(dragData) {\n        const { assignmentRecords, eventRecords, resourceRecord, browserEvent : domEvent } = dragData;\n\n        return {\n            // `context` is now private, but used in WebSocketHelper\n            context : dragData,\n            eventRecords,\n            resourceRecord,\n            assignmentRecords,\n            event   : domEvent, // Deprecated, remove on  6.0?\n            domEvent\n        };\n    }\n\n    triggerBeforeEventDrag(eventType, event) {\n        return this.client.trigger(eventType, event);\n    }\n\n    triggerEventDrag(dragData, start) {\n        this.client.trigger('eventDrag', Object.assign(this.getTriggerParams(dragData), {\n            startDate   : dragData.startDate,\n            endDate     : dragData.endDate,\n            newResource : dragData.newResource\n        }));\n    }\n\n    triggerDragStart(dragData) {\n        this.client.navigator.skipNextClick = true;\n\n        this.client.trigger('eventDragStart', this.getTriggerParams(dragData));\n    }\n\n    triggerDragAbort(dragData) {\n        this.client.trigger('eventDragAbort', this.getTriggerParams(dragData));\n    }\n\n    triggerDragAbortFinalized(dragData) {\n        this.client.trigger('eventDragAbortFinalized', this.getTriggerParams(dragData));\n    }\n\n    triggerAfterDrop(dragData, valid) {\n        const me = this;\n\n        me.currentOverClient.trigger('afterEventDrop', Object.assign(me.getTriggerParams(dragData), {\n            valid\n        }));\n\n        if (!valid) {\n            // Edge cases:\n            // 1. If this drag was a no-op, and underlying data was changed while drag was ongoing (e.g. web socket\n            // push), we need to manually force a view refresh to ensure a correct render state\n            //\n            // or\n            // 2. Events were removed before we dropped at an invalid point\n            const\n                { assignmentStore, eventStore } = me.client,\n                needRefresh                     = me.dragData.initialAssignmentsState.find(({\n                    resource, assignment\n                }, i) => {\n                    return !assignmentStore.includes(assignment) ||\n                        !eventStore.includes(assignment.event) ||\n                        resource.id !== me.dragData.assignmentRecords[i]?.resourceId;\n                });\n\n            if (needRefresh) {\n                me.client.refresh();\n            }\n        }\n        // Reset the skipNextClick after a potential click event fires. https://github.com/bryntum/support/issues/5135\n        me.client.setTimeout(() => me.client.navigator.skipNextClick = false, 10);\n    }\n\n    handleKeyDownOrMove(event) {\n        if (this.mode !== 'copy') {\n            if (event.key && EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase() || event[`${this.copyKey.toLowerCase()}Key`]) {\n                this.mode = 'copy';\n            }\n        }\n    }\n\n    handleKeyUp(event) {\n        if (EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase()) {\n            this.mode = 'move';\n        }\n    }\n\n    //endregion\n\n    //region Finalization & validation\n\n    /**\n     * Checks if an event can be dropped on the specified position.\n     * @private\n     * @returns {Boolean} Valid (true) or invalid (false)\n     */\n    isValidDrop(dragData) {\n        const\n            { newResource, resourceRecord } = dragData,\n            sourceRecord                    = dragData.draggedEntities[0];\n\n        // Only allowed to drop outside scheduler element if we hit an element matching the externalDropTargetSelector\n        if (!newResource) {\n            return (!this.constrainDragToTimeline && this.externalDropTargetSelector) ? Boolean(dragData.browserEvent.target.closest(this.externalDropTargetSelector)) : false;\n        }\n\n        // Not allowed to drop an event on a group header or a readOnly resource\n        if (newResource.isSpecialRow || newResource.readOnly) {\n            return false;\n        }\n\n        // Not allowed to assign an event twice to the same resource\n        if (resourceRecord !== newResource) {\n            return !sourceRecord.event.resources.includes(newResource);\n        }\n\n        return true;\n    }\n\n    checkDragValidity(dragData, event) {\n        const\n            me        = this,\n            scheduler = me.currentOverClient;\n\n        let result;\n\n        // Cannot assign anything to readOnly resources\n        if (dragData.newResource?.readOnly) {\n            return false;\n        }\n\n        // First make sure there's no overlap, if not run the external validatorFn\n        if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(\n            dragData.startDate,\n            dragData.endDate,\n            dragData.draggedEntities[0],\n            dragData.newResource\n        )) {\n            result = {\n                valid   : false,\n                message : me.L('L{eventOverlapsExisting}')\n            };\n        }\n        else {\n            result = me.validatorFn.call(\n                me.validatorFnThisObj || me,\n                dragData,\n                event\n            );\n        }\n\n        if (!result || result.valid) {\n            // Hook for features to have a say on validity\n            result = scheduler['checkEventDragValidity']?.(dragData, event) ?? result;\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    //region Update records\n\n    /**\n     * Update events being dragged.\n     * @private\n     * @param context Drag data.\n     */\n    async updateRecords(context) {\n        const\n            me                            = this,\n            fromScheduler                                          = me.client,\n            toScheduler                                            = me.currentOverClient,\n            copyKeyPressed                                         = me.mode === 'copy',\n            { draggedEntities, timeDiff, initialAssignmentsState } = context,\n            originalStartDate                                      = initialAssignmentsState[0].startDate,\n            droppedStartDate                                       = me.adjustStartDate(originalStartDate, timeDiff);\n\n        let result;\n\n        if (!context.externalDropTarget) {\n            // Dropping dragged event completely outside the time axis is not allowed\n            if (!toScheduler.timeAxis.timeSpanInAxis(droppedStartDate, DateHelper.add(droppedStartDate, draggedEntities[0].event.durationMS, 'ms'))) {\n                context.valid = false;\n            }\n\n            if (context.valid) {\n                fromScheduler.eventStore.suspendAutoCommit();\n                toScheduler.eventStore.suspendAutoCommit();\n\n                result = await me.updateAssignments(fromScheduler, toScheduler, context, copyKeyPressed);\n\n                fromScheduler.eventStore.resumeAutoCommit();\n                toScheduler.eventStore.resumeAutoCommit();\n            }\n        }\n\n        // Might be flagged invalid in updateAssignments() above, if drop did not lead to any change\n        // (for example if dropped on non-working-time in Pro)\n        if (context.valid) {\n            // Tell the world there was a successful drop\n            toScheduler.trigger('eventDrop', Object.assign(me.getTriggerParams(context), {\n                isCopy               : copyKeyPressed,\n                copyMode             : me.copyMode,\n                domEvent             : context.browserEvent,\n                targetEventRecord    : context.targetEventRecord,\n                targetResourceRecord : context.newResource,\n                externalDropTarget   : context.externalDropTarget\n            }));\n        }\n\n        return result;\n    }\n\n    /**\n     * Update assignments being dragged\n     * @private\n     */\n    async updateAssignments(fromScheduler, toScheduler, context, copy) {\n        // The code is written to emit as few store events as possible\n        const\n            me                  = this,\n            { copyMode }        = me,\n            isCrossScheduler    = (fromScheduler !== toScheduler),\n            { isVertical }      = toScheduler,\n            {\n                assignmentStore : fromAssignmentStore,\n                eventStore      : fromEventStore\n            }                   = fromScheduler,\n            {\n                assignmentStore : toAssignmentStore,\n                eventStore      : toEventStore\n            }                   = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore   = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore     = isVertical ? toScheduler.resourceStore : toScheduler.store,\n            {\n                eventRecords,\n                assignmentRecords,\n                timeDiff,\n                initialAssignmentsState,\n                resourceRecord : fromResource,\n                newResource    : toResource\n            }                   = context,\n            { unifiedDrag }     = me,\n            // For an empty target event store, check if it has usesSingleAssignment explicitly set, otherwise use\n            // the value from the source event store\n            useSingleAssignment = (toEventStore.usesSingleAssignment ||\n                (toEventStore.usesSingleAssignment !== false && fromEventStore.usesSingleAssignment)),\n            // this value has clear semantic only for same scheduler case\n            effectiveCopyMode   = copyMode === 'event'\n                ? 'event'\n                : copyMode === 'assignment'\n                    ? 'assignment'\n                    : useSingleAssignment ? 'event' : 'assignment',\n            event1Date          = me.adjustStartDate(assignmentRecords[0].event.startDate, timeDiff),\n            eventsToAdd         = [],\n            eventsToRemove      = [],\n            assignmentsToAdd    = [],\n            assignmentsToRemove = [],\n            eventsToCheck       = [],\n            eventsToBatch       = new Set(),\n            resourcesInStore    = fromResourceStore.getAllDataRecords();\n\n        fromScheduler.suspendRefresh();\n        toScheduler.suspendRefresh();\n\n        let updated      = false,\n            updatedEvent = false,\n            indexDiff; // By how many resource rows has the drag moved.\n\n        if (isCrossScheduler) {\n            // The difference in indices via first dragged event will help us find resources for all the rest of the\n            // events accordingly\n            indexDiff = toResourceStore.indexOf(toResource) - fromResourceStore.indexOf(fromResource);\n        }\n        else if (me.constainDragToResource) {\n            indexDiff = 0;\n        }\n        else if (isVertical && toResourceStore.isGrouped) {\n            indexDiff = resourcesInStore.indexOf(fromResource) - resourcesInStore.indexOf(toResource);\n        }\n        else {\n            indexDiff = fromResourceStore.indexOf(fromResource) - fromResourceStore.indexOf(toResource);\n        }\n\n        if (isVertical) {\n            // <remove-on-release>\n            // TODO: Broken after merge, figure it out\n            // </remove-on-release>\n            eventRecords.forEach((draggedEvent, i) => {\n                const eventBar = context.eventBarEls[i];\n\n                delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;\n\n                // If it was created by a call to scheduler.currentOrientation.addTemporaryDragElement\n                // then release it back to be available to DomSync next time the rendered event block\n                // is synced.\n                if (eventBar.dataset.transient) {\n                    eventBar.remove();\n                }\n            });\n        }\n\n        const\n            eventBarEls          = context.eventBarEls.slice(),\n            addedEvents          = [],\n            // this map holds references between original assignment and its copy\n            copiedAssignmentsMap = {};\n\n        // Using for to support await inside\n        for (let i = 0; i < assignmentRecords.length; i++) {\n            const originalAssignment = assignmentRecords[i];\n\n            // Reassigned when dropped on other scheduler, thus not const\n            let draggedEvent = originalAssignment.event,\n                draggedAssignment;\n\n            if (copy) {\n                draggedAssignment                           = originalAssignment.copy();\n                copiedAssignmentsMap[originalAssignment.id] = draggedAssignment;\n            }\n            else {\n                draggedAssignment = originalAssignment;\n            }\n\n            if (!draggedAssignment.isOccurrenceAssignment && (!fromAssignmentStore.includes(originalAssignment) || !fromEventStore.includes(draggedEvent))) {\n                // Event was removed externally during the drag, just remove element from DOM (DomSync already has\n                // tried to clean it up at this point, but could not due to retainElement being set)\n                eventBarEls[i].remove();\n                eventBarEls.splice(i, 1);\n                assignmentRecords.splice(i, 1);\n                i--;\n                continue;\n            }\n\n            const\n                initialState           = initialAssignmentsState[i],\n                originalEventRecord    = draggedEvent,\n                originalStartDate      = initialState.startDate,\n                // grabbing resource early, since after \".copy()\" the record won't belong to any store\n                // and \".getResources()\" won't work. If it's a move to another scheduler, ensure the\n                // array still has a length. The process function will do an assign as opposed\n                // to a reassignment\n                originalResourceRecord = initialState.resource,\n                // Calculate new startDate (and round it) based on timeDiff up here, might be added to another\n                // event store below in which case it is invalidated. But this is anyway the target date\n                newStartDate           = this.constrainDragToTimeSlot\n                    ? originalStartDate\n                    : (unifiedDrag\n                        ? event1Date\n                        : me.adjustStartDate(originalStartDate, timeDiff));\n\n            if (fromAssignmentStore !== toAssignmentStore) {\n                // Single assignment from a multi assigned event dragged over, event needs to be copied over\n                // Same if we hold the copy key\n                const keepEvent = originalEventRecord.assignments.length > 1 || copy;\n\n                let newAssignment;\n\n                if (copy) {\n                    // In a copy mode dragged assignment is already a copy\n                    newAssignment = draggedAssignment;\n                }\n                else {\n                    newAssignment                              = draggedAssignment.copy();\n                    copiedAssignmentsMap[draggedAssignment.id] = newAssignment;\n                }\n\n                // Pro Engine does not seem to handle having the event already in place on the copied assignment,\n                // replacing it with id to have events bucket properly set up on commit\n                if (newAssignment.event && !useSingleAssignment) {\n                    newAssignment.event    = newAssignment.event.id;\n                    newAssignment.resource = newAssignment.resource.id;\n                }\n\n                if (!copy) {\n                    // If we're not copying, remove assignment from source scheduler\n                    assignmentsToRemove.push(draggedAssignment);\n                }\n\n                // If it was the last assignment, the event should also be removed\n                if (!keepEvent) {\n                    eventsToRemove.push(originalEventRecord);\n                }\n\n                // If event does not already exist in target scheduler a copy is added\n                // if we're copying the event, we always need to create new record\n                if (\n                    copy && (copyMode === 'event' || (copyMode === 'auto' && toEventStore.usesSingleAssignment)) ||\n                    !toEventStore.getById(originalEventRecord.id)\n                ) {\n                    draggedEvent = toEventStore.createRecord({\n                        ...originalEventRecord.data,\n                        // If we're copying the event (not making new assignment to existing), we need to generate\n                        // phantom id to link event to the assignment record\n                        id       : copy && (copyMode === 'event' || copyMode === 'auto') ? undefined : originalEventRecord.id,\n                        // Engine gets mad if not nulled\n                        calendar : null\n                    });\n\n                    newAssignment.set({\n                        eventId : draggedEvent.id,\n                        event   : draggedEvent\n                    });\n\n                    eventsToAdd.push(draggedEvent);\n                }\n\n                // And add it to the target scheduler\n                // <remove-on-release>\n                // TODO: Should be handled on the data layer ideally\n                // </remove-on-release>\n                if (!useSingleAssignment) {\n                    assignmentsToAdd.push(newAssignment);\n                }\n                draggedAssignment = newAssignment;\n            }\n\n            let newResource    = toResource,\n                reassignedFrom = null;\n\n            if (!unifiedDrag) {\n                if (!isCrossScheduler) {\n                    // If not dragging events as a unified block, distribute each to a new resource\n                    // using the same offset as the dragged event.\n                    if (indexDiff !== 0) {\n                        let newIndex;\n                        if (isVertical && toResourceStore.isGrouped) {\n                            newIndex    = Math.max(\n                                Math.min(\n                                    resourcesInStore.indexOf(originalResourceRecord) - indexDiff,\n                                    resourcesInStore.length - 1\n                                ),\n                                0\n                            );\n                            newResource = resourcesInStore[newIndex];\n                        }\n                        else {\n                            newIndex = Math.max(\n                                Math.min(\n                                    fromResourceStore.indexOf(originalResourceRecord) - indexDiff,\n                                    fromResourceStore.count - 1\n                                ),\n                                0\n                            );\n\n                            newResource = fromResourceStore.getAt(newIndex);\n\n                            // Exclude group headers, footers, summary row etc\n                            if (newResource.isSpecialRow) {\n                                newResource = fromResourceStore.getNext(newResource, false, true) || fromResourceStore.getPrevious(newResource, false, true);\n                            }\n                        }\n\n                        newResource = newResource?.$original;\n                    }\n                    else {\n                        newResource = originalResourceRecord;\n                    }\n                }\n                // we have a resource for first dragged event in toResource\n                else if (i > 0) {\n                    const draggedEventResourceIndex = fromResourceStore.indexOf(originalResourceRecord);\n                    newResource                     = toResourceStore.getAt(draggedEventResourceIndex + indexDiff) || newResource;\n                }\n            }\n\n            const isCrossResource = draggedAssignment.resourceId !== newResource.id;\n\n            // Cannot rely on assignment generation to detect update, since it might be a new assignment\n            // <remove-on-release>\n            // TODO: what about a case when we drag between schedulers which have different resource with same ids?\n            // </remove-on-release>\n            if (isCrossResource) {\n                reassignedFrom = fromResourceStore.getById(draggedAssignment.resourceId);\n\n                if (copy && fromAssignmentStore === toAssignmentStore) {\n                    // Scheduler Core patch\n                    // need to completely clear the resource/resourceId on the copied assignment, before setting the new\n                    // otherwise, what happens is that in the `$beforeChange.resource/Id` are still\n                    // stored the resource/Id of the original assignment\n                    // then, when finalizing commit, Core engine performs this:\n                    //     // First silently revert any data change (used by buckets), otherwise it won't be detected by `set()`\n                    //     me.setData(me.$beforeChange)\n                    // and then updates the data to new, which is recorded as UpdateAction in the STM with old/new data\n                    // then, when that update action in STM is undo-ed, the old data is written back to the record\n                    // and newly added assignment is pointing to the old resource\n                    // then, when STM action is redo-ed, a \"duplicate assignment\" exception is thrown\n                    // this is covered with the test:\n                    // Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (\"multi-assignment\")\n                    draggedAssignment.setData({\n                        resource   : null,\n                        resourceId : null\n                    });\n                    // eof Scheduler Core patch\n\n                    draggedAssignment.resource = newResource;\n                    draggedAssignment.event    = toEventStore.getById(draggedAssignment.eventId);\n\n                    const shouldCopyEvent = copyMode === 'event' || (fromEventStore.usesSingleAssignment && copyMode === 'auto');\n\n                    if (shouldCopyEvent) {\n                        draggedEvent = draggedEvent.copy();\n                        // need to clear the `endDate` of the copy\n                        // this is because when we drag the copy to a different position on the timeline\n                        // it will set the new start date and re-calculate end date\n                        // as a result, in STM transaction for this drag-copy there will be \"add\" action\n                        // and \"update\" action and NO COMMIT in the middle\n                        // so when re-doing this transaction the duration change is lost\n                        // this is covered with the test:\n                        // \"Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (usesSingleAssignment)\",\n                        // Before doing it, save a copy of endDate in meta object, considering timeDiff: that's because below it will check if event is in timeAxis.\n                        draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                        draggedEvent.endDate = null;\n\n                        draggedAssignment.event = draggedEvent;\n\n                        if (toEventStore.usesSingleAssignment) {\n                            draggedEvent.resource   = newResource;\n                            draggedEvent.resourceId = newResource.id;\n                        }\n                    }\n\n                    if (\n                        !toAssignmentStore.find(a => a.eventId === draggedAssignment.eventId && a.resourceId === draggedAssignment.resourceId) &&\n                        !assignmentsToAdd.find(r => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId)\n                    ) {\n                        shouldCopyEvent && eventsToAdd.push(draggedEvent);\n                        assignmentsToAdd.push(draggedAssignment);\n                    }\n                }\n                else {\n                    draggedAssignment.resource = newResource;\n                }\n\n                // Actual events should be batched, not data for new events when dragging between\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updated = true;\n\n                // When dragging an occurrence, the assignment is only temporary. We have to tag the newResource along\n                // to be picked up by the occurrence -> event conversion\n                // <remove-on-release>\n                // TODO: A hack, figure a better way out\n                // </remove-on-release>\n                if (draggedEvent.isOccurrence) {\n                    draggedEvent.set('newResource', newResource);\n                }\n\n                // <remove-on-release>\n                // TODO: Should be handled on the datalayer somehow, but it is kind of edge casey\n                // </remove-on-release>\n                if (isCrossScheduler && useSingleAssignment) {\n                    // In single assignment mode, when dragged to another scheduler it will not copy the assignment\n                    // over but instead set the resourceId of the event. To better match expected behaviour\n                    draggedEvent.resourceId = newResource.id;\n                }\n            }\n            else {\n                if (\n                    copy &&\n                    (copyMode === 'event' || (copyMode === 'auto' && fromEventStore.usesSingleAssignment)) &&\n                    !eventsToAdd.includes(draggedEvent)\n                ) {\n                    draggedEvent = draggedEvent.copy();\n                    // see the comment above\n                    draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                    draggedEvent.endDate = null;\n\n                    eventsToAdd.push(draggedEvent);\n\n                    draggedAssignment.event = draggedEvent;\n\n                    if (toEventStore.usesSingleAssignment) {\n                        draggedEvent.set({\n                            resource   : newResource,\n                            resourceId : newResource.id\n                        });\n                    }\n\n                    // Always add assignment to the store to allow proper element reuse\n                    assignmentsToAdd.push(draggedAssignment);\n                }\n            }\n\n            // Same for event\n            if (!eventsToCheck.find(ev => ev.draggedEvent === draggedEvent) && !DateHelper.isEqual(draggedEvent.startDate, newStartDate)) {\n\n                // only do for non occurence records\n                while (!draggedEvent.isOccurrence && draggedEvent.isBatchUpdating) {\n                    draggedEvent.endBatch(true);\n                }\n\n                // for same scheduler with multi-assignments, and copyMode === assignment, need to keep the start date\n                // because user intention is to create a new assignment, not re-schedule the event\n                // but only for cross-resource dragging, same resource dragging has semantic of regular drag\n                // <remove-on-release>\n                // TODO should also keep the proxy element on the same X coordinate\n                // </remove-on-release>\n                const shouldKeepStartDate = copy && !isCrossScheduler && !useSingleAssignment && effectiveCopyMode === 'assignment' && isCrossResource;\n\n                if (!shouldKeepStartDate) {\n                    draggedEvent.startDate = newStartDate;\n\n                    eventsToCheck.push({ draggedEvent, originalStartDate });\n                }\n\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updatedEvent = true;\n            }\n\n            // Hook for features that need to do additional processing on drop (used by NestedEvents)\n            toScheduler.processEventDrop({\n                eventRecord    : draggedEvent,\n                resourceRecord : newResource,\n                element        : i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                context,\n                toScheduler,\n                reassignedFrom,\n                eventsToAdd,\n                addedEvents,\n                draggedAssignment\n            });\n\n            // There are two cases to consider when triggering this event - `copy` and `move` mode. In case we are\n            // copying the assignment (we can also copy the event) draggedAssignment will point to the copy of the\n            // original assignment record. Same for draggedEvent. These records are new records which are not yet added\n            // to the store and they contain correct state of the drop - which event is going to be assigned to which\n            // resource on what time.\n            // These records possess no knowledge about original records which they were cloned from. And that might be\n            // useful. Let's say you want to copy assignment (or event) to every row in the way. You need to know start\n            // row and the end row. That information is kept in the `originalAssignment` record. Which might be identical\n            // to the `draggedAssignment` record in `move` mode.\n            toScheduler.trigger('processEventDrop', {\n                originalAssignment,\n                draggedAssignment,\n                context,\n                copyMode,\n                isCopy : copy\n            });\n        }\n\n        fromAssignmentStore.remove(assignmentsToRemove);\n        fromEventStore.remove(eventsToRemove);\n        toAssignmentStore.add(assignmentsToAdd);\n\n        // Modify syncIdMap on the FGCanvas to make sure elements get animated nicely to new position\n        if (copy && fromAssignmentStore === toAssignmentStore) {\n            const { syncIdMap } = fromScheduler.foregroundCanvas;\n\n            Object.entries(copiedAssignmentsMap).forEach(([originalId, cloneRecord]) => {\n                const element = syncIdMap[originalId];\n                delete syncIdMap[originalId];\n                syncIdMap[cloneRecord.id] = element;\n            });\n        }\n\n        eventsToAdd.length && addedEvents.push(...toEventStore.add(eventsToAdd));\n\n        // When not constrained to timeline we are dragging a clone and need to manually do some cleanup if\n        // dropped in view\n        if (!me.constrainDragToTimeline) {\n            // go through assignmentRecords again after events has been added to toEventStore (if any)\n            // now we have updated assignment ids and can properly reuse event HTML elements\n            for (let i = 0; i < assignmentRecords.length; i++) {\n                const\n                    assignmentRecord     = copiedAssignmentsMap[assignmentRecords[i].id] || assignmentRecords[i],\n                    originalDraggedEvent = assignmentRecord.event,\n                    // try to get dragged event from addedEvents array, it will be there with updated ids\n                    // if toScheduler is different\n                    draggedEvent         = addedEvents?.find(r => r.id === originalDraggedEvent.id) || originalDraggedEvent,\n                    eventBar             = context.eventBarEls[i],\n                    element              = i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                    // Determine if in time axis here also, since the records date might be invalidated further below\n                    inTimeAxis           = toScheduler.isInTimeAxis(draggedEvent);\n\n                // after checking if is in time axis, imeta.endDateCached can be deleted\n                delete draggedEvent.meta.endDateCached;\n\n                if (!copy) {\n                    // Remove original element properly\n                    DomSync.removeChild(eventBar.parentElement, eventBar);\n                }\n\n                if (draggedEvent.resource && (isVertical || toScheduler.rowManager.getRowFor(draggedEvent.resource)) && inTimeAxis) {\n                    // Nested events are added to correct parent by the feature\n                    if (!draggedEvent.parent || draggedEvent.parent.isRoot) {\n                        const elRect = Rectangle.from(element, toScheduler.foregroundCanvas, true);\n\n                        // Ensure that after inserting the dragged element clone into the toScheduler's foregroundCanvas\n                        // it's at the same visual position that it was dragged to.\n                        DomHelper.setTopLeft(element, elRect.y, elRect.x);\n\n                        // Add element properly, so that DomSync will reuse it on next update\n                        DomSync.addChild(toScheduler.foregroundCanvas, element, draggedEvent.assignments[0].id);\n\n                        isCrossScheduler && toScheduler.processCrossSchedulerEventDrop({\n                            eventRecord : draggedEvent,\n                            toScheduler\n                        });\n                    }\n\n                    element.classList.remove('b-sch-event-hover', 'b-active', 'b-drag-proxy', 'b-dragging');\n                    element.retainElement = false;\n                }\n            }\n        }\n\n        addedEvents?.forEach(added => eventsToBatch.add(added));\n\n        // addedEvents order is the same with [context.element, ..context.relatedElements]\n        // Any added or removed events or assignments => something changed\n        if (assignmentsToRemove.length || eventsToRemove.length || assignmentsToAdd.length || eventsToAdd.length) {\n            updated = true;\n        }\n\n        // Commit changes to affected projects\n        if (updated || updatedEvent) {\n            // By batching event changes when using single assignment we avoid two updates, without it there will be one\n            // for date change and one when changed assignment updates resourceId on the event\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.beginBatch());\n\n            await Promise.all([\n                toScheduler.project !== fromScheduler.project ? toScheduler.project.commitAsync() : null,\n                fromScheduler.project.commitAsync()\n            ]);\n\n            // End batch in engine friendly way, avoiding to have `set()` trigger another round of calculations\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.endBatch(false, true));\n        }\n\n        if (!updated) {\n            // Engine might have reverted the date change, in which case this should be considered an invalid op\n            updated = eventsToCheck.some(({ draggedEvent, originalStartDate }) =>\n                !DateHelper.isEqual(draggedEvent.startDate, originalStartDate)\n            );\n        }\n\n        // Resumes self twice if not cross scheduler, but was suspended twice above also so all good\n        toScheduler.resumeRefresh();\n        fromScheduler.resumeRefresh();\n\n        if (assignmentRecords.length > 0) {\n            if (!updated) {\n                context.valid = false;\n            }\n            else {\n                // Always force re-render of the bars, to return them to their original position when:\n                // * Fill ticks leading to small date adjustment not actually changing the DOM\n                //   (https://github.com/bryntum/support/issues/630)\n                // * Dragging straight down with multiselection, events in the last resource will still be assigned to\n                //   that resource = no change in the DOM (https://github.com/bryntum/support/issues/6293)\n                eventBarEls.forEach(el => delete el.lastDomConfig);\n\n                // Not doing full refresh above, to allow for animations\n                toScheduler.refreshWithTransition();\n\n                if (isCrossScheduler) {\n                    fromScheduler.refreshWithTransition();\n\n                    toScheduler.selectedEvents = addedEvents;\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Drag data\n\n    getProductDragContext(dragData) {\n        const\n            me                                = this,\n            { currentOverClient : scheduler } = me,\n            target                            = dragData.browserEvent.target,\n            previousResolvedResource          = dragData.newResource || dragData.resourceRecord,\n            previousTargetEventRecord         = dragData.targetEventRecord;\n\n        let\n            targetEventRecord = scheduler ? me.resolveEventRecord(target, scheduler) : null,\n            newResource, externalDropTarget;\n\n        // Ignore if over dragged event\n        if (dragData.eventRecords.includes(targetEventRecord)) {\n            targetEventRecord = null;\n        }\n\n        if (me.constrainDragToResource) {\n            newResource = dragData.resourceRecord;\n        }\n        else if (!me.constrainDragToTimeline) {\n            newResource = me.resolveResource();\n        }\n        else if (scheduler) {\n            newResource = me.resolveResource() || dragData.newResource || dragData.resourceRecord;\n        }\n\n        const\n            { assignmentRecords, eventRecords } = dragData,\n            isOverNewResource                   = previousResolvedResource !== newResource;\n\n        let valid = Boolean(newResource && !newResource.isSpecialRow);\n\n        if (!newResource && me.externalDropTargetSelector) {\n            externalDropTarget = target.closest(me.externalDropTargetSelector);\n            valid              = Boolean(externalDropTarget);\n        }\n\n        return {\n            valid,\n            externalDropTarget,\n            eventRecords,\n            assignmentRecords,\n            newResource,\n            targetEventRecord,\n            dirty         : isOverNewResource || targetEventRecord !== previousTargetEventRecord,\n            proxyElements : [dragData.context.element, ...dragData.context.relatedElements || []]\n        };\n    }\n\n    getMinimalDragData(info) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            element           = me.getElementFromContext(info),\n            eventRecord       = me.resolveEventRecord(element, scheduler),\n            resourceRecord    = scheduler.resolveResourceRecord(element),\n            assignmentRecord  = scheduler.resolveAssignmentRecord(element),\n            assignmentRecords = assignmentRecord ? [assignmentRecord] : [];\n\n        // We multi drag other selected events if the dragged event is already selected, or the ctrl key is pressed\n        if (assignmentRecord && (scheduler.isAssignmentSelected(assignmentRecords[0]) || (me.drag.startEvent.ctrlKey && scheduler.multiEventSelect))) {\n            assignmentRecords.push.apply(assignmentRecords, me.getRelatedRecords(assignmentRecord));\n        }\n\n        const eventRecords = [...new Set(assignmentRecords.map(assignment => assignment.event))];\n\n        return {\n            eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            eventRecords,\n            assignmentRecords\n        };\n    }\n\n    setupProductDragData(info) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = me.getElementFromContext(info),\n            {\n                eventRecord,\n                resourceRecord,\n                assignmentRecord,\n                assignmentRecords\n            }             = me.getMinimalDragData(info),\n            eventBarEls   = [];\n\n        if (me.constrainDragToResource && !resourceRecord) {\n            throw new Error('Resource could not be resolved for event: ' + eventRecord.id);\n        }\n\n        let dateConstraints;\n\n        if (me.constrainDragToTimeline) {\n            dateConstraints = me.getDateConstraints?.(resourceRecord, eventRecord);\n\n            const\n                constrainRectangle = me.constrainRectangle = me.getConstrainingRectangle(dateConstraints, resourceRecord, eventRecord),\n                eventRegion        = Rectangle.from(element, scheduler.timeAxisSubGridElement);\n\n            super.setupConstraints(\n                constrainRectangle,\n                eventRegion,\n                scheduler.timeAxisViewModel.snapPixelAmount,\n                Boolean(dateConstraints.start)\n            );\n        }\n\n        // Collecting all elements to drag\n        assignmentRecords.forEach(assignment => {\n            let eventBarEl = scheduler.getElementFromAssignmentRecord(assignment, true);\n\n            if (!eventBarEl) {\n                eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(assignment.event, assignment.resource);\n            }\n\n            eventBarEls.push(eventBarEl);\n        });\n\n        return {\n            record          : assignmentRecord,\n            draggedEntities : assignmentRecords,\n            dateConstraints : dateConstraints?.start ? dateConstraints : null,\n            // Create copies of the elements\n            eventBarCopies  : eventBarEls.map(el => me.createProxy(el)),\n            eventBarEls\n        };\n    }\n\n    getDateConstraints(resourceRecord, eventRecord) {\n        const\n            { scheduler }           = this,\n            externalDateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n\n        let minDate, maxDate;\n\n        if (this.constrainDragToTimeSlot) {\n            minDate = eventRecord.startDate;\n            maxDate = eventRecord.endDate;\n        }\n        else if (externalDateConstraints) {\n            minDate = externalDateConstraints.start;\n            maxDate = externalDateConstraints.end;\n        }\n\n        return {\n            start : minDate,\n            end   : maxDate\n        };\n    }\n\n    getConstrainingRectangle(dateRange, resourceRecord, eventRecord) {\n        return this.scheduler.getScheduleRegion(this.constrainDragToResource && resourceRecord, eventRecord, true, dateRange && {\n            start : dateRange.start, end : dateRange.end\n        });\n    }\n\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const dragData = this.getMinimalDragData(info) || {};\n\n        return {\n            ...super.getDragData(info),\n            ...dragData,\n            initialAssignmentsState : dragData.assignmentRecords.map(assignment => ({\n                startDate : assignment.event.startDate,\n                resource  : assignment.resource,\n                assignment\n            }))\n        };\n    }\n\n    /**\n     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dragged\n     * @returns {Scheduler.model.AssignmentModel[]} An array of assignment records to drag together with the original\n     */\n    getRelatedRecords(assignmentRecord) {\n        return this.scheduler.selectedAssignments.filter(selectedRecord => selectedRecord !== assignmentRecord && !selectedRecord.resource.readOnly && selectedRecord.event.isDraggable);\n    }\n\n    /**\n     * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone\n     * layout into account.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Record being dragged\n     * @param {HTMLElement} element Element being dragged\n     * @param {Number[]} coord XY coordinates\n     * @returns {Number|Number[]} X,Y or XY\n     */\n    getCoordinate(eventRecord, element, coord) {\n        const scheduler = this.currentOverClient;\n\n        if (scheduler.isHorizontal) {\n            let x = coord[0];\n\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        x += element.offsetWidth / 2;\n                        break;\n                    case 'end':\n                        x += element.offsetWidth;\n                        break;\n                }\n            }\n\n            return x;\n        }\n        else {\n            let y = coord[1];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        y += element.offsetHeight / 2;\n                        break;\n                    case 'end':\n                        y += element.offsetHeight;\n                        break;\n                }\n            }\n\n            return y;\n        }\n    }\n\n    /**\n     * Get resource record occluded by the drag proxy.\n     * @private\n     * @returns {Scheduler.model.ResourceModel}\n     */\n    resolveResource() {\n        const\n            me                 = this,\n            client             = me.currentOverClient,\n            { isHorizontal }   = client,\n            {\n                context,\n                browserEvent,\n                dragProxy\n            }                  = me.dragData,\n            element            = dragProxy || context.element,\n            // Page coords for elementFromPoint\n            pageRect           = Rectangle.from(element, null, true),\n            y                  = (client.isVertical || me.unifiedDrag) ? context.clientY : pageRect.center.y,\n            // Local coords to resolve resource in vertical\n            localRect          = Rectangle.from(element, client.timeAxisSubGridElement, true),\n            { x : lx, y : ly } = localRect.center,\n            eventTarget        = me.getMouseMoveEventTarget(browserEvent);\n\n        let resource = null;\n\n        if (client.element.contains(eventTarget)) {\n            // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate\n            // so use it in preference to elementFromPoint (which causes a forced synchronous layout) in horizontal mode.\n            if (isHorizontal) {\n                const row = client.rowManager.getRowAt(y);\n\n                resource = row && client.store.getAt(row.dataIndex);\n            }\n            else {\n                // In vertical mode, just use the X coordinate to find out which resource we are under.\n                // The method requires that a .b-sch-timeaxis-cell element be passed.\n                // There is only one in vertical mode, so use that.\n                resource = client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);\n            }\n        }\n\n        return resource;\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    adjustStartDate(startDate, timeDiff) {\n        const\n            scheduler = this.currentOverClient;\n\n        startDate = scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);\n\n        return this.constrainStartDate(startDate);\n    }\n\n    getRecordElement(assignmentRecord) {\n        return this.client.getElementFromAssignmentRecord(assignmentRecord, true);\n    }\n\n    // Used by the Dependencies feature to draw lines to the drag proxy instead of the original event element\n    getProxyElement(assignmentRecord) {\n        if (this.isDragging) {\n            const index = this.dragData.assignmentRecords.indexOf(assignmentRecord);\n\n            if (index >= 0) {\n                return this.dragData.proxyElements[index];\n            }\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //#region Salesforce hooks\n\n    getMouseMoveEventTarget(event) {\n        return event.target;\n    }\n\n    //#endregion\n}\n\nGridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDrag, false, 'ResourceHistogram');\n", "import DragCreateBase from './base/DragCreateBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/feature/EventDragCreate\n */\n\n/**\n * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.\n *\n * {@inlineexample Scheduler/feature/EventDragCreate.js}\n *\n * This feature is **enabled** by default.\n *\n * <div class=\"note\">Incompatible with the {@link Scheduler.feature.EventDragSelect EventDragSelect} and\n * {@link Scheduler.feature.Pan Pan} features. If either of those features are enabled, this feature has no effect.\n * </div>\n *\n * ## Conditionally preventing drag creation\n *\n * To conditionally prevent drag creation for a certain resource or a certain timespan, you listen for the\n * {@link #event-beforeDragCreate} event, add your custom logic to it and return `false` to prevent the operation\n * from starting. For example to not allow drag creation on the topmost resource:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     listeners : {\n *         beforeDragCreate({ resource }) {\n *             // Prevent drag creating on the topmost resource\n *             if (resource === scheduler.resourceStore.first) {\n *                 return false;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/base/DragCreateBase\n * @demo Scheduler/basic\n * @classtype eventDragCreate\n * @feature\n */\nexport default class EventDragCreate extends DragCreateBase {\n    //region Config\n\n    static $name = 'EventDragCreate';\n\n    static configurable = {\n        /**\n         * An empty function by default, but provided so that you can perform custom validation on the event being\n         * created. Return `true` if the new event is valid, `false` to prevent an event being created.\n         * @param {Object} context A drag create context\n         * @param {Date} context.startDate Event start date\n         * @param {Date} context.endDate Event end date\n         * @param {Scheduler.model.EventModel} context.record Event record\n         * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n         * @param {Event} event The event object\n         * @returns {Boolean} `true` if this validation passes\n         * @config {Function}\n         */\n        validatorFn : () => true,\n\n        /**\n         * Locks the layout during drag create, overriding the default behaviour that uses the same rendering\n         * pathway for drag creation as for already existing events.\n         *\n         * This more closely resembles the behaviour of versions prior to 4.2.0.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        lockLayout : false\n    };\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fires on the owning Scheduler after the new event has been created.\n     * @event dragCreateEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource for the row in which the event is being\n     * created.\n     * @param {MouseEvent} event The ending mouseup event.\n     * @param {HTMLElement} eventElement The DOM element representing the newly created event un the UI.\n     */\n\n    /**\n     * Fires on the owning Scheduler at the beginning of the drag gesture. Returning `false` from a listener prevents\n     * the drag create operation from starting.\n     *\n     * ```javascript\n     * const scheduler = new Scheduler({\n     *     listeners : {\n     *         beforeDragCreate({ date }) {\n     *             // Prevent drag creating events in the past\n     *             return date >= Date.now();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeDragCreate\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date The datetime associated with the drag start point.\n     */\n\n    /**\n     * Fires on the owning Scheduler after the drag start has created a new Event record.\n     * @event dragCreateStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new event.\n     */\n\n    /**\n     * Fires on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     * ```javascript\n     *  scheduler.on('beforedragcreatefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     * @event beforeDragCreateFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new Event record\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user\n     * confirmation)\n     * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one\n     * argument: pass true to update records, or false, to ignore changes\n     */\n\n    /**\n     * Fires on the owning Scheduler at the end of the drag create gesture whether or not\n     * a new event was created by the gesture.\n     * @event afterDragCreate\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the created event record\n     */\n\n    //endregion\n\n    //region Init\n\n    get scheduler() {\n        return this.client;\n    }\n\n    get store() {\n        return this.client.eventStore;\n    }\n\n    get project() {\n        return this.client.project;\n    }\n\n    updateLockLayout(lock) {\n        this.dragActiveCls = `b-dragcreating${lock ? ' b-dragcreate-lock' : ''}`;\n    }\n\n    //endregion\n\n    //region Scheduler specific implementation\n\n    handleBeforeDragCreate(drag, eventRecord, event) {\n        const { resourceRecord } = drag;\n\n        if (resourceRecord.readOnly || !this.scheduler.resourceStore.isAvailable(resourceRecord)) {\n            return false;\n        }\n\n        const\n            { scheduler }      = this,\n            // For resources with a calendar, ensure the date is inside a working time range\n            isWorkingTime      = !scheduler.isSchedulerPro || eventRecord.ignoreResourceCalendar || resourceRecord.isWorkingTime(drag.mousedownDate),\n            result             = isWorkingTime && scheduler.trigger('beforeDragCreate', {\n                resourceRecord,\n                date : drag.mousedownDate,\n                event\n            });\n\n        // Save date constraints\n        this.dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n\n        return result;\n    }\n\n    dragStart(drag) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                eventStore,\n                assignmentStore,\n                enableEventAnimations\n            }                  = client,\n            { resourceRecord } = drag,\n            eventRecord        = me.createEventRecord(drag),\n            resourceRecords    = [resourceRecord];\n\n        eventRecord.set('duration', DateHelper.diff(eventRecord.startDate, eventRecord.endDate, eventRecord.durationUnit, true));\n\n        // It's only a provisional event until gesture is completed (possibly longer if an editor dialog is shown after)\n        eventRecord.isCreating = true;\n\n        // Flag used by rendering to not draw a zero length event being drag created as a milestone\n        eventRecord.meta.isDragCreating = true;\n\n        // force the transaction canceling in the taskeditor early\n        // this is because we are going to add a new event record to the store, and it has to be out of the\n        // task editor's stm transaction\n        // now there's a re-entrant protection in that method, so hopefully when it will be called by the\n        // editor itself that's ok\n        // `taskEdit === false` in some cases, so can't just use `?.` here\n        client.features.taskEdit && client.features.taskEdit.doCancel();\n\n        // This presents the event to be scheduled for validation at the proposed mouse/date point\n        // If rejected, we cancel operation\n        if (me.handleBeforeDragCreate(drag, eventRecord, drag.event) === false) {\n            return false;\n        }\n\n        me.captureStm(true);\n\n        let assignmentRecords = [];\n\n        if (resourceRecord) {\n            assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n        }\n\n        // Vetoable beforeEventAdd allows cancel of this operation\n        if (client.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            assignmentStore.remove(assignmentRecords);\n            return false;\n        }\n\n        // When configured to lock layout during drag create, set a flag that HorizontalRendering will pick up to\n        // exclude the new event from the layout calculations. It will then be at the topmost position in the \"cell\"\n        if (me.lockLayout) {\n            eventRecord.meta.excludeFromLayout = true;\n        }\n\n        client.onEventCreated?.(eventRecord);\n\n        client.enableEventAnimations = false;\n        eventStore.addAsync(eventRecord).then(() => client.enableEventAnimations = enableEventAnimations);\n\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        client.isCreating = true;\n        client.refreshRows();\n        client.isCreating = false;\n\n        // Set the element we are dragging\n        drag.itemElement = drag.element = client.getElementFromEventRecord(eventRecord);\n\n        // If the resource row is very tall, the event may have been rendered outside of the\n        // visible viewport. If so, scroll it into view.\n        if (!DomHelper.isInView(drag.itemElement)) {\n            client.scrollable.scrollIntoView(drag.itemElement, {\n                animate    : true,\n                edgeOffset : client.barMargin\n            });\n        }\n\n        return super.dragStart(drag);\n    }\n\n    checkValidity(context, event) {\n        const\n            me         = this,\n            { client } = me;\n\n        // Nicer for users of validatorFn\n        context.resourceRecord = me.dragging.resourceRecord;\n        return (\n            client.allowOverlap ||\n            client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)\n        ) && me.createValidatorFn.call(me.validatorFnThisObj || me, context, event);\n    }\n\n    // Determine if resource already has events or not\n    isRowEmpty(resourceRecord) {\n        const events = this.store.getEventsForResource(resourceRecord);\n        return !events || !events.length;\n    }\n\n    //endregion\n\n    triggerBeforeFinalize(event) {\n        this.client.trigger(`beforeDragCreateFinalize`, event);\n    }\n\n    /**\n     * Creates an event by the event object coordinates\n     * @param {Object} drag The Bryntum event object\n     * @private\n     */\n    createEventRecord(drag) {\n        const\n            me          = this,\n            { client }  = me,\n            dimension   = client.isHorizontal ? 'X' : 'Y',\n            {\n                timeAxis,\n                eventStore,\n                weekStartDay\n            }           = client,\n            {\n                event,\n                mousedownDate\n            }           = drag,\n            draggingEnd = me.draggingEnd = event[`page${dimension}`] > drag.startEvent[`page${dimension}`],\n            eventConfig = {\n                name      : eventStore.modelClass.fieldMap.name.defaultValue || me.L('L{Object.newEvent}'),\n                startDate : draggingEnd ? DateHelper.floor(mousedownDate, timeAxis.resolution, null, weekStartDay) : mousedownDate,\n                endDate   : draggingEnd ? mousedownDate : DateHelper.ceil(mousedownDate, timeAxis.resolution, null, weekStartDay)\n            };\n\n        // if project model has been imported from Gantt, we have to define constraint data directly to correct\n        // auto-scheduling while dragCreate\n        if (client.project.isGanttProjectMixin) {\n            ObjectHelper.assign(eventConfig, {\n                constraintDate : eventConfig.startDate,\n                constraintType : 'startnoearlierthan'\n            });\n        }\n\n        return eventStore.createRecord(eventConfig);\n    }\n\n    async internalUpdateRecord(context, eventRecord) {\n        await super.internalUpdateRecord(context, eventRecord);\n\n        // Toggle isCreating after ending batch, to make sure assignments can become persistable\n        if (!this.client.hasEventEditor) {\n            context.eventRecord.isCreating = false;\n        }\n    }\n\n    async finalizeDragCreate(context) {\n        const { meta } = context.eventRecord;\n\n        // Remove the layout lock flag, event will jump into place as part of the finalization\n        meta.excludeFromLayout = false;\n        // Also allow new event to become a milestone now\n        meta.isDragCreating    = false;\n\n        const transferred = await super.finalizeDragCreate(context);\n\n        // if STM capture has NOT been transferred to the\n        // event editor, we need to finalize the STM transaction / release the capture\n        if (!transferred) {\n            this.freeStm(true);\n        }\n        else {\n            // otherwise just freeing our capture\n            this.hasStmCapture = false;\n        }\n\n        return transferred;\n    }\n\n    async cancelDragCreate(context) {\n        await super.cancelDragCreate(context);\n\n        this.freeStm(false);\n    }\n\n    getTipHtml(...args) {\n        const\n            html        = super.getTipHtml(...args),\n            { element } = this.tip;\n\n        element.classList.add('b-sch-dragcreate-tooltip');\n        element.classList.toggle('b-too-narrow', this.dragging.context.tooNarrow);\n\n        return html;\n    }\n\n    onAborted(context) {\n        const { eventRecord, resourceRecord } = context;\n\n        // The product this is being used in may not have resources.\n        this.store.unassignEventFromResource?.(eventRecord, resourceRecord);\n        this.store.remove(eventRecord);\n    }\n}\n\nGridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDragCreate, false, 'ResourceHistogram');\n", "import TooltipBase from './base/TooltipBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport { parseAlign } from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Scheduler/feature/EventTooltip\n */\n\n// Alignment offsets to clear any dependency terminals depending on whether\n// the tooltip is aligned top/bottom (1) or left/right (2) as parsed from the\n// align string by Rectangle's parseAlign\nconst\n    zeroOffset = [0, 0],\n    depOffset  = [\n        null, [0, 10], [10, 0]\n    ];\n\n/**\n * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.\n * Config options are also applied to the tooltip shown, see {@link Core.widget.Tooltip} for available options.\n *\n * ## Showing local data\n * To show a basic \"local\" tooltip (with data available in the Event record) upon hover:\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *         // Tooltip configs can be used here\n *         align : 'l-r' // Align left to right,\n *         // A custom HTML template\n *         template : data => `<dl>\n *           <dt>Assigned to:</dt>\n *              <dt>Time:</dt>\n *              <dd>\n *                  ${DateHelper.format(data.eventRecord.startDate, 'LT')} - ${DateHelper.format(data.eventRecord.endDate, 'LT')}\n *              </dd>\n *              ${data.eventRecord.get('note') ? `<dt>Note:</dt><dd>${data.eventRecord.note}</dd>` : ''}\n *\n *              ${data.eventRecord.get('image') ? `<dt>Image:</dt><dd><img class=\"image\" src=\"${data.eventRecord.get('image')}\"/></dd>` : ''}\n *          </dl>`\n *     }\n *   }\n * });\n * ```\n *\n * ## Showing remotely loaded data\n * Loading remote data into the event tooltip is easy. Simply use the {@link #config-template} and return a Promise which yields the content to show.\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *        template : ({ eventRecord }) => AjaxHelper.get(`./fakeServer?name=${eventRecord.name}`).then(response => response.text())\n *     }\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * By default, the tooltip {@link Core.widget.Widget#config-scrollAction realigns on scroll}\n * meaning that it will stay aligned with its target should a scroll interaction make the target move.\n *\n * If this is causing performance issues in a Scheduler, such as if there are many dozens of events\n * visible, you can configure this feature with `scrollAction: 'hide'`. This feature's configuration is\n * applied to the tooltip, so that will mean that the tooltip will hide if its target is moved by a\n * scroll interaction.\n *\n * @extends Scheduler/feature/base/TooltipBase\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventTooltip.js\n * @classtype eventTooltip\n * @feature\n */\nexport default class EventTooltip extends TooltipBase {\n    //region Config\n\n    static get $name() {\n        return 'EventTooltip';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function which receives data about the event and returns a string,\n             * or a Promise yielding a string (for async tooltips), to be displayed in the tooltip.\n             * This method will be called with an object containing the fields below\n             * @param {Object} data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Date} data.startDate\n             * @param {Date} data.endDate\n             * @param {String} data.startText\n             * @param {String} data.endText\n             * @config {Function} template\n             */\n            template : data => `\n                ${data.eventRecord.name ? StringHelper.xss`<div class=\"b-sch-event-title\">${data.eventRecord.name}</div>` : ''}\n                ${data.startClockHtml}\n                ${data.endClockHtml}`,\n\n            cls : 'b-sch-event-tooltip',\n\n            monitorRecordUpdate : true,\n\n            /**\n             * Defines what to do if document is scrolled while the tooltip is visible.\n             *\n             * Valid values: null: do nothing, hide: hide the tooltip or realign: realign to the target if possible.\n             *\n             * @config {'hide'|'realign'|null}\n             * @default\n             */\n            scrollAction : 'hide'\n        };\n    }\n\n    /**\n     * The event which the tooltip feature has been activated for.\n     * @member {Scheduler.model.EventModel} eventRecord\n     * @readonly\n     */\n\n    //endregion\n\n    construct(client, config) {\n        const me = this;\n\n        super.construct(client, config);\n\n        if (typeof me.align === 'string') {\n            me.align = { align : me.align };\n        }\n    }\n\n    onPaint({ firstPaint }) {\n        super.onPaint(...arguments);\n\n        if (firstPaint) {\n            const\n                me           = this,\n                dependencies = me.client.features.dependencies;\n\n            if (dependencies) {\n                me.tooltip.ion({\n                    beforeAlign({ source : tooltip, offset = zeroOffset }) {\n                        const\n                            { edgeAligned }   = parseAlign(tooltip.align.align),\n                            depTerminalOffset = dependencies.disabled ? zeroOffset : depOffset[edgeAligned];\n\n                        // Add the spec's offset to the offset necessitated by dependency terminals\n                        arguments[0].offset = [\n                            offset[0] + depTerminalOffset[0],\n                            offset[1] + depTerminalOffset[1]\n                        ];\n                    }\n                });\n            }\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventTooltip, false, 'ResourceHistogram');\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n\n/**\n * @module Scheduler/feature/StickyEvents\n */\n\nconst zeroMargins = { width : 0, height : 0 };\n\n/**\n * This feature applies native `position: sticky` to event contents in horizontal mode, keeping the contents in view as\n * long as possible on scroll. For vertical mode it uses a programmatic solution to achieve the same result.\n *\n * Assign `eventRecord.stickyContents = false` to disable stickiness on a per event level (docs for\n * {@link Scheduler/model/EventModel#field-stickyContents}).\n *\n * This feature is **enabled** by default.\n *\n * ### Note\n * If a complex {@link Scheduler.view.Scheduler#config-eventRenderer} is used to create a DOM structure within the\n * `.b-sch-event-content` element, then application CSS will need to be written to cancel the stickiness on the\n * `.b-sch-event-content` element, and make some inner content element(s) sticky.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyEvents\n * @feature\n */\nexport default class StickyEvents extends InstancePlugin {\n    static $name = 'StickyEvents';\n\n    static type = 'stickyEvents';\n\n    static pluginConfig = {\n        chain : ['onEventDataGenerated']\n    };\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        if (scheduler.isVertical) {\n            this.toUpdate = new Set();\n\n            scheduler.ion({\n                scroll           : 'onSchedulerScroll',\n                horizontalScroll : 'onHorizontalScroll',\n                thisObj          : this,\n                prio             : 10000\n            });\n        }\n    }\n\n    onEventDataGenerated(renderData) {\n        if (this.client.isHorizontal) {\n            renderData.wrapperCls['b-disable-sticky'] = renderData.eventRecord.stickyContents === false;\n        }\n        else {\n            this.syncEventContentPosition(renderData, undefined, true);\n            this.updateStyles();\n        }\n    }\n\n    //region Vertical mode\n\n    onSchedulerScroll() {\n        if (!this.disabled) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n\n    // Have to sync also on horizontal scroll, since we reuse elements and dom configs\n    onHorizontalScroll({ subGrid }) {\n        if (subGrid === this.client.timeAxisSubGrid) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n\n    updateStyles() {\n        for (const { contentEl, style } of this.toUpdate) {\n            DomHelper.applyStyle(contentEl, style);\n        }\n\n        this.toUpdate.clear();\n    }\n\n    verticalSyncAllEventsContentPosition(scheduler) {\n        const { resourceMap } = scheduler.currentOrientation;\n\n        for (const eventsData of resourceMap.values()) {\n            for (const { renderData, elementConfig } of Object.values(eventsData)) {\n                const args = [renderData];\n\n                if (elementConfig && renderData.eventRecord.isResourceTimeRange) {\n                    args.push(elementConfig.children[0]);\n                }\n\n                this.syncEventContentPosition.apply(this, args);\n            }\n        }\n        this.toUpdate.size && this.updateStyles();\n    }\n\n    syncEventContentPosition(renderData, eventContent = renderData.eventContent, duringGeneration = false) {\n        if (\n            this.disabled ||\n            // Allow client disable stickiness for certain events\n            renderData.eventRecord.stickyContents === false\n        ) {\n            return;\n        }\n\n        const\n            { client }        = this,\n            {\n                eventRecord,\n                resourceRecord,\n                useEventBuffer,\n                bufferAfterWidth,\n                bufferBeforeWidth,\n                top,\n                height\n            }                 = renderData,\n            scrollPosition    = client.scrollable.y,\n            wrapperEl         = duringGeneration ? null : client.getElementFromEventRecord(eventRecord, resourceRecord, true),\n            contentEl         = wrapperEl && DomSync.getChild(wrapperEl, 'event.content'),\n            meta              = eventRecord.instanceMeta(client),\n            style             = typeof eventContent.style === 'string'\n                ? (eventContent.style = DomHelper.parseStyle(eventContent.style))\n                : eventContent.style || (eventContent.style = {});\n\n        // Do not process events being dragged\n        if (wrapperEl?.classList.contains('b-dragging')) {\n            return;\n        }\n\n        let start       = top,\n            contentSize = height,\n            end         = start + contentSize;\n\n        if (useEventBuffer) {\n            start += bufferBeforeWidth;\n            contentSize = contentSize - bufferBeforeWidth - bufferAfterWidth;\n            end = start + contentSize;\n        }\n\n        // Only process non-milestones that are partially out of view\n        if (start < scrollPosition && end >= scrollPosition && !eventRecord.isMilestone) {\n            const\n                contentWidth = contentEl?.offsetWidth,\n                justify      = contentEl?.parentNode && DomHelper.getStyleValue(contentEl.parentNode, 'justifyContent'),\n                c            = justify === 'center' ? (renderData.width - contentWidth) / 2 : 0,\n                eventStart   = start,\n                eventEnd     = eventStart + contentSize - 1;\n\n            // Only process non-milestone events. Milestones have no width.\n            // If there's no offsetWidth, it's still b-released, so we cannot measure it.\n            // If the event starts off the left edge, but its right edge is still visible,\n            // translate the contentEl to compensate. If not, undo any translation.\n            if ((!contentEl || contentWidth) && eventStart < scrollPosition && eventEnd >= scrollPosition) {\n                const\n                    edgeSizes = this.getEventContentMargins(contentEl),\n                    maxOffset = contentEl\n                        ? (contentSize - contentEl.offsetHeight - edgeSizes.height) - c\n                        : Number.MAX_SAFE_INTEGER,\n                    offset = Math.min(scrollPosition - eventStart, maxOffset - 2);\n\n                style.transform = offset > 0 ? `translateY(${offset}px)` : '';\n                meta.stuck = true;\n            }\n            else {\n                style.transform = '';\n                meta.stuck = false;\n            }\n\n            if (contentEl) {\n                this.toUpdate.add({\n                    contentEl,\n                    style\n                });\n            }\n        }\n        else if (contentEl && meta.stuck) {\n            style.transform = '';\n            meta.stuck = false;\n\n            this.toUpdate.add({\n                contentEl,\n                style\n            });\n        }\n    }\n\n    // Only measure the margins of an event's contentEl once\n    getEventContentMargins(contentEl) {\n        if (contentEl?.classList.contains('b-sch-event-content')) {\n            return DomHelper.getEdgeSize(contentEl, 'margin');\n        }\n        return zeroMargins;\n    }\n\n    //endregion\n\n    doDisable() {\n        super.doDisable(...arguments);\n\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(StickyEvents, true, 'Scheduler');\nGridFeatureManager.registerFeature(StickyEvents, false, 'ResourceHistogram');\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport TimeSpan from '../model/TimeSpan.js';\n\n/**\n * @module Scheduler/feature/TimeRanges\n */\n\n/**\n * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch\n * or some important point in time (a `line`, i.e. a range with 0 duration). This feature can also show a current time\n * indicator if you set {@link #config-showCurrentTimeLine} to true. To style the rendered elements, use the\n * {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.\n *\n * {@inlineexample Scheduler/feature/TimeRanges.js}\n *\n * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple\n * {@link Core.data.Store}. The feature uses {@link Scheduler/model/ProjectModel#property-timeRangeStore} defined on the\n * project by default. The store's persisting/loading is handled by Crud Manager (if it's used by the component).\n *\n * Note that the feature uses virtualized rendering, only the currently visible ranges are available in the DOM.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * ## Showing an icon in the time range header\n *\n * You can use Font Awesome icons easily (or set any other icon using CSS) by using the {@link Scheduler.model.TimeSpan#field-iconCls}\n * field. The JSON data below will show a flag icon:\n *\n * ```json\n * {\n *     \"id\"        : 5,\n *     \"iconCls\"   : \"b-fa b-fa-flag\",\n *     \"name\"      : \"v5.0\",\n *     \"startDate\" : \"2019-02-07 15:45\"\n * },\n * ```\n *\n * ## Recurring time ranges\n *\n * The feature supports recurring ranges in case the provided store and models\n * have {@link Scheduler/data/mixin/RecurringTimeSpansMixin} and {@link Scheduler/model/mixin/RecurringTimeSpan}\n * mixins applied:\n *\n * ```javascript\n * // We want to use recurring time ranges so we make a special model extending standard TimeSpan model with\n * // RecurringTimeSpan which adds recurrence support\n * class MyTimeRange extends RecurringTimeSpan(TimeSpan) {}\n *\n * // Define a new store extending standard Store with RecurringTimeSpansMixin mixin to add recurrence support to the\n * // store. This store will contain time ranges.\n * class MyTimeRangeStore extends RecurringTimeSpansMixin(Store) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyTimeRange\n *         };\n *     }\n * };\n *\n * // Instantiate store for timeRanges using our new classes\n * const timeRangeStore = new MyTimeRangeStore({\n *     data : [{\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Lunch',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n *\n * const scheduler = new Scheduler({\n *     ...\n *     features : {\n *         timeRanges : true\n *     },\n *\n *     crudManager : {\n *         // store for \"timeRanges\" feature\n *         timeRangeStore\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @classtype timeRanges\n * @feature\n * @demo Scheduler/timeranges\n */\nexport default class TimeRanges extends AbstractTimeRanges.mixin(AttachToProjectMixin) {\n    //region Config\n\n    static get $name() {\n        return 'TimeRanges';\n    }\n\n    static get defaultConfig() {\n        return {\n            store : true\n        };\n    }\n\n    static configurable = {\n        /**\n         * Store that holds the time ranges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).\n         * A store will be automatically created if none is specified.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Misc\n         */\n        store : {\n            modelClass : TimeSpan\n        },\n\n        /**\n         * The interval (as amount of ms) defining how frequently the current timeline will be updated\n         * @config {Number}\n         * @default\n         * @category Misc\n         */\n        currentTimeLineUpdateInterval : 10000,\n\n        /**\n         * The date format to show in the header for the current time line (when {@link #config-showCurrentTimeLine} is configured).\n         * See {@link Core.helper.DateHelper} for the possible formats to use.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        currentDateFormat : 'HH:mm',\n\n        /**\n         * Show a line indicating current time. Either `true` or `false` or a {@link Scheduler.model.TimeSpan}\n         * configuration object to apply to this special time range (allowing you to provide a custom text):\n         *\n         * ```javascript\n         * showCurrentTimeLine : {\n         *     name : 'Now'\n         * }\n         * ```\n         *\n         * The line carries the CSS class name `b-sch-current-time`, and this may be used to add custom styling to it.\n         *\n         * @prp {Boolean|TimeSpanConfig}\n         * @default\n         * @category Common\n         */\n        showCurrentTimeLine : false\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.storeDetacher?.();\n\n        super.doDestroy();\n    }\n\n    /**\n     * Returns the TimeRanges which occur within the client Scheduler's time axis.\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get timeRanges() {\n        const me        = this;\n\n        if (!me._timeRanges) {\n            const { store } = me;\n\n            let { records } = store;\n\n            if (store.recurringEvents) {\n                const {\n                    startDate,\n                    endDate\n                } = me.client.timeAxis;\n\n                records = records.flatMap(timeSpan => {\n                    // Collect occurrences for the recurring events in the record set\n                    if (timeSpan.isRecurring) {\n                        return timeSpan.getOccurrencesForDateRange(startDate, endDate);\n                    }\n\n                    return timeSpan;\n                });\n            }\n\n            if (me.currentTimeLine) {\n                // Avoid polluting store records\n                if (!store.recurringEvents) {\n                    records = records.slice();\n                }\n\n                records.push(me.currentTimeLine);\n            }\n\n            me._timeRanges = records;\n        }\n\n        return me._timeRanges;\n    }\n    //endregion\n\n    //region Current time line\n\n    attachToProject(project) {\n        super.attachToProject(project);\n        const me = this;\n\n        me.projectTimeZoneChangeDetacher?.();\n\n        if (me.showCurrentTimeLine) {\n\n            // Update currentTimeLine immediately after a time zone change\n            me.projectTimeZoneChangeDetacher = me.client.project?.ion({ timeZoneChange : () => me.updateCurrentTimeLine() });\n\n            // Update currentTimeLine if its already created\n            if (me.currentTimeLine) {\n                me.updateCurrentTimeLine();\n            }\n        }\n    }\n\n    initCurrentTimeLine() {\n        const me = this;\n\n        if (me.currentTimeLine || !me.showCurrentTimeLine) {\n            return;\n        }\n\n        const data = typeof me.showCurrentTimeLine === 'object' ? me.showCurrentTimeLine : {};\n\n        me.currentTimeLine = me.store.modelClass.new({\n            id  : 'currentTime', // no-sanity\n            cls : 'b-sch-current-time'\n        }, data);\n\n        me.currentTimeInterval = me.setInterval(() => me.updateCurrentTimeLine(), me.currentTimeLineUpdateInterval);\n\n        me._timeRanges = null;\n\n        me.updateCurrentTimeLine();\n    }\n\n    updateCurrentTimeLine() {\n        const\n            me                  = this,\n            { currentTimeLine } = me;\n\n        currentTimeLine.timeZone = me.project?.timeZone;\n        currentTimeLine.setLocalDate('startDate', new Date());\n        currentTimeLine.endDate = currentTimeLine.startDate;\n\n        if (!currentTimeLine.originalData.name) {\n            currentTimeLine.name = DateHelper.format(currentTimeLine.startDate, me.currentDateFormat);\n        }\n\n        me.renderRanges();\n    }\n\n    hideCurrentTimeLine() {\n        const me = this;\n\n        if (!me.currentTimeLine) {\n            return;\n        }\n\n        me.clearInterval(me.currentTimeInterval);\n        me.currentTimeLine = null;\n\n        me.refresh();\n    }\n\n    updateShowCurrentTimeLine(show) {\n        if (show) {\n            this.initCurrentTimeLine();\n        }\n        else {\n            this.hideCurrentTimeLine();\n        }\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds a menu item to show/hide current time line.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ column, items }) {\n        items.currentTimeLine = {\n            weight   : 400,\n            text     : this.L('L{showCurrentTimeLine}'),\n            checked  : this.showCurrentTimeLine,\n            onToggle : ({ checked }) => {\n                this.showCurrentTimeLine = checked;\n            }\n        };\n    }\n\n    //endregion\n\n    //region Store\n\n    attachToStore(store) {\n        const me = this;\n\n        let renderRanges = false;\n\n        // if we had some store assigned before we need to detach it\n        if (me.storeDetacher) {\n            me.storeDetacher();\n            // then we'll need to render ranges provided by the new store\n            renderRanges = true;\n        }\n\n        me.storeDetacher = store.ion({\n            change  : 'onStoreChange',\n            refresh : 'onStoreChange',\n            thisObj : me\n        });\n\n        me._timeRanges = null;\n\n        // render ranges if needed\n        renderRanges && me.renderRanges();\n    }\n\n    /**\n     * Returns the {@link Core.data.Store store} used by this feature\n     * @property {Core.data.Store}\n     * @category Misc\n     */\n    get store() {\n        return this.client.project.timeRangeStore;\n    }\n\n    updateStore(store) {\n        const\n            me          = this,\n            { client }  = me,\n            { project } = client;\n\n        store = project.timeRangeStore;\n\n        me.attachToStore(store);\n\n        // timeRanges can be set on scheduler/gantt, for convenience. Should only be processed by the TimeRanges and not\n        // any subclasses\n        if (client.timeRanges && !client._timeRangesExposed) {\n            store.add(client.timeRanges);\n            delete client.timeRanges;\n        }\n    }\n\n    // Called by ProjectConsumer after a new store is assigned at runtime\n    attachToTimeRangeStore(store) {\n        this.store = store;\n    }\n\n    resolveTimeRangeRecord(el) {\n        return this.store.getById(el.closest(this.baseSelector).dataset.id);\n    }\n\n    onStoreChange({ type, action }) {\n        const me = this;\n\n        // Force re-evaluating of which ranges to consider for render\n        me._timeRanges = null;\n\n        // https://github.com/bryntum/support/issues/1398 - checking also if scheduler is visible to change elements\n        if (me.disabled || !me.client.isVisible || me.isConfiguring || (type === 'refresh' && action !== 'batch')) {\n            return;\n        }\n\n        me.client.runWithTransition(() => me.renderRanges(), !me.client.refreshSuspended);\n    }\n\n    //endregion\n\n    //region Drag\n\n    onDragStart(event) {\n        const\n            me                = this,\n            { context }       = event,\n            record            = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl       = me.getBodyElementByRecord(record);\n\n        context.relatedElements = [rangeBodyEl];\n\n        Object.assign(context, {\n            record,\n            rangeBodyEl,\n            originRangeX : DomHelper.getTranslateX(rangeBodyEl),\n            originRangeY : DomHelper.getTranslateY(rangeBodyEl)\n        });\n\n        super.onDragStart(event);\n\n        me.showTip(context);\n    }\n\n    onDrop(event) {\n        const { context } = event;\n\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me          = this,\n            { client }  = me,\n            { record }  = context,\n            box         = Rectangle.from(context.rangeBodyEl),\n            newStart    = client.getDateFromCoordinate(box.getStart(client.rtl, client.isHorizontal), 'round', false),\n            wasModified = (record.startDate - newStart !== 0);\n\n        if (wasModified) {\n            record.setStartDate(newStart);\n        }\n        else {\n            me.onInvalidDrop();\n        }\n\n        me.destroyTip();\n\n        super.onDrop(event);\n    }\n\n    //endregion\n\n    //region Resize\n\n    onResizeStart({ context }) {\n        const\n            me          = this,\n            record      = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl = me.getBodyElementByRecord(record);\n\n        Object.assign(context, {\n            record,\n            rangeBodyEl\n        });\n\n        me.showTip(context);\n    }\n\n    onResizeDrag({ context }) {\n        const\n            me              = this,\n            { rangeBodyEl } = context;\n\n        if (me.client.isVertical) {\n            if (context.edge === 'top') {\n                DomHelper.setTranslateY(rangeBodyEl, context.newY);\n            }\n\n            rangeBodyEl.style.height = context.newHeight + 'px';\n        }\n        else {\n            if (context.edge === 'left') {\n                DomHelper.setTranslateX(rangeBodyEl, context.newX);\n            }\n\n            rangeBodyEl.style.width = context.newWidth + 'px';\n        }\n    }\n\n    onResize({ context }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me          = this,\n            { client }  = me,\n            { rtl }     = client,\n            record      = context.record,\n            box         = Rectangle.from(context.element),\n            startPos    = box.getStart(rtl, client.isHorizontal),\n            endPos      = box.getEnd(rtl, client.isHorizontal),\n            newStart    = client.getDateFromCoordinate(startPos, 'round', false),\n            isStart     = (rtl && context.edge === 'right') || (!rtl && context.edge === 'left') || context.edge === 'top',\n            newEnd      = client.getDateFromCoordinate(endPos, 'round', false),\n            wasModified = (isStart && record.startDate - newStart !== 0) ||\n                (newEnd && record.endDate - newEnd !== 0);\n\n        if (wasModified && newEnd > newStart) {\n            if (isStart) {\n                // could be that the drag operation placed the range with start/end outside the axis\n                record.setStartDate(newStart, false);\n            }\n            else {\n                record.setEndDate(newEnd, false);\n            }\n        }\n        else {\n            me.onInvalidResize({ context });\n        }\n\n        me.destroyTip();\n    }\n\n    onInvalidResize({ context }) {\n        const me = this;\n\n        me.resize.reset();\n        // Allow DomSync to reapply original state\n        context.rangeBodyEl.parentElement.lastDomConfig = context.rangeBodyEl.lastDomConfig = null;\n        me.renderRanges();\n\n        me.destroyTip();\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(TimeRanges, false, ['Scheduler', 'Gantt']);\n", "import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerDom\n */\n\n/**\n * Mixin with EventModel and ResourceModel <-> HTMLElement mapping functions\n *\n * @mixin\n */\nexport default Target => class SchedulerDom extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDom';\n    }\n\n    //region Get\n\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord An assignment record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromAssignmentRecord(assignmentRecord, returnWrapper = false) {\n        if (this.isPainted && assignmentRecord) {\n            let wrapper = this.foregroundCanvas.syncIdMap?.[assignmentRecord.id];\n\n            // When using links, the original might not be rendered but a link might\n            if (!wrapper && assignmentRecord.resource.hasLinks) {\n                for (const link of assignmentRecord.resource.$links) {\n                    wrapper = this.foregroundCanvas.syncIdMap?.[`${assignmentRecord.id}_${link.id}`];\n\n                    if (wrapper) {\n                        break;\n                    }\n                }\n            }\n\n            // Wrapper won't have syncIdMap when saving dragcreated event from editor\n            return returnWrapper ? wrapper : wrapper?.syncIdMap?.event;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromEventRecord(eventRecord, resourceRecord = eventRecord.resources?.[0], returnWrapper = false) {\n        if (eventRecord.isResourceTimeRange) {\n            const wrapper = this.foregroundCanvas.syncIdMap?.[eventRecord.domId];\n\n            return returnWrapper ? wrapper : wrapper?.syncIdMap.event;\n        }\n\n        const assignmentRecord = this.assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);\n        return this.getElementFromAssignmentRecord(assignmentRecord, returnWrapper);\n    }\n\n    /**\n     * Returns all the HTMLElements representing an event record.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] A resource record\n     *\n     * @returns {HTMLElement[]} The element(s) representing the event record\n     * @category DOM\n     */\n    getElementsFromEventRecord(eventRecord, resourceRecord, returnWrapper = false) {\n        // Single event instance, as array\n        if (resourceRecord) {\n            return [this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper)];\n        }\n        // All instances\n        else {\n            return eventRecord.resources.reduce((result, resourceRecord) => {\n                const el = this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper);\n\n                el && result.push(el);\n\n                return result;\n            }, []);\n        }\n    }\n\n    //endregion\n\n    //region Resolve\n\n    /**\n     * Resolves the resource based on a dom element or event. In vertical mode, if resolving from an element higher up in\n     * the hierarchy than event elements, then it is required to supply an coordinates since resources are virtual\n     * columns.\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a resource from\n     * @param {Number[]} [xy] X and Y coordinates, required in some cases in vertical mode, disregarded in horizontal\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveResourceRecord(elementOrEvent, xy) {\n        return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);\n    }\n\n    /**\n     * Product agnostic method which yields the {@link Scheduler.model.ResourceModel} record which underpins the row which\n     * encapsulates the passed element. The element can be a grid cell, or an event element, and the result\n     * will be a {@link Scheduler.model.ResourceModel}\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a record from\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveRowRecord(elementOrEvent) {\n        return this.resolveResourceRecord(elementOrEvent);\n    }\n\n    /**\n     * Returns the event record for a DOM element\n     * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup\n     * @returns {Scheduler.model.EventModel} The event record\n     * @category DOM\n     */\n    resolveEventRecord(elementOrEvent) {\n        if (elementOrEvent instanceof Event) {\n            elementOrEvent = elementOrEvent.target;\n        }\n\n        const element = elementOrEvent?.closest(this.eventSelector);\n\n        if (element) {\n            if (element.dataset.eventId) {\n                return this.eventStore.getById(element.dataset.eventId);\n            }\n\n            if (element.dataset.assignmentId) {\n                return this.assignmentStore.getById(element.dataset.assignmentId).event;\n            }\n        }\n\n        return null;\n    }\n\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {\n        return this.resolveEventRecord(element);\n    }\n\n    /**\n     * Returns an assignment record for a DOM element\n     * @param {HTMLElement} element The DOM node to lookup\n     * @returns {Scheduler.model.AssignmentModel} The assignment record\n     * @category DOM\n     */\n    resolveAssignmentRecord(element) {\n        const\n            eventElement     = element.closest(this.eventSelector),\n            assignmentRecord = eventElement && this.assignmentStore.getById(eventElement.dataset.assignmentId),\n            eventRecord      = eventElement && this.eventStore.getById(eventElement.dataset.eventId);\n\n        // When resolving a recurring event, we might be resolving an occurrence\n        return this.assignmentStore.getOccurrence(assignmentRecord, eventRecord);\n    }\n\n    //endregion\n\n    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)\n    isRowVisible(resourceRecord) {\n        // records in collapsed groups/branches etc. are removed from processedRecords\n        return this.store.indexOf(resourceRecord) >= 0;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerDomEvents\n */\n\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class SchedulerDomEvents extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDomEvents';\n    }\n\n    //region Events\n\n    /**\n     * Triggered when user mousedowns over an empty area in the schedule.\n     * @event scheduleMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when mouse enters an empty area in the schedule.\n     * @event scheduleMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when mouse leaves an empty area in the schedule.\n     * @event scheduleMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user mouseups over an empty area in the schedule.\n     * @event scheduleMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user moves mouse over an empty area in the schedule.\n     * @event scheduleMouseMove\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user clicks an empty area in the schedule.\n     * @event scheduleClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user double-clicks an empty area in the schedule.\n     * @event scheduleDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Index of double-clicked resource\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user right-clicks an empty area in the schedule.\n     * @event scheduleContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse down on an event.\n     * @event eventMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse up on an event.\n     * @event eventMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for click on an event.\n     * @event eventClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for double-click on an event.\n     * @event eventDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for right-click on an event.\n     * @event eventContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when the mouse enters an event bar.\n     * @event eventMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when the mouse leaves an event bar.\n     * @event eventMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse over events when moving into and within an event bar.\n     *\n     * Note that `mouseover` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving into the event bar is required, use the {@link #event-eventMouseEnter} event._\n     * @event eventMouseOver\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse out events within and when moving out of an event bar.\n     *\n     * Note that `mouseout` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving out of the event bar is required, use the {@link #event-eventMouseLeave} event._\n     * @event eventMouseOut\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    //endregion\n\n    //region Event handling\n\n    getTimeSpanMouseEventParams(eventElement, event) {\n        // May have hovered a record being removed / faded out\n        const eventRecord = this.resolveEventRecord(eventElement);\n\n        return eventRecord && {\n            eventRecord,\n            resourceRecord   : this.resolveResourceRecord(eventElement),\n            assignmentRecord : this.resolveAssignmentRecord(eventElement),\n            eventElement,\n            event\n        };\n    }\n\n    getScheduleMouseEventParams(cellData, event) {\n        const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);\n\n        return { resourceRecord };\n    }\n\n    /**\n     * Relays keydown events as eventkeydown if we have a selected task.\n     * @private\n     */\n    onElementKeyDown(event) {\n        const\n            result = super.onElementKeyDown(event),\n            me     = this;\n\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyDown', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n                // <remove-on-release>\n                // TODO: Remove for 6.0\n                // </remove-on-release>\n                eventRecord       : me.selectedEvents,\n                assignmentRecord  : me.selectedAssignments\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Relays keyup events as eventkeyup if we have a selected task.\n     * @private\n     */\n    onElementKeyUp(event) {\n        super.onElementKeyUp(event);\n\n        const me = this;\n\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyUp', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n\n                // <remove-on-release>\n                // TODO: Remove for 6.0\n                // </remove-on-release>\n                eventRecord      : me.selectedEvents,\n                assignmentRecord : me.selectedAssignments\n            });\n        }\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport DomClassList from '../../../Core/helper/util/DomClassList.js';\nimport HorizontalLayoutStack from '../../eventlayout/HorizontalLayoutStack.js';\nimport HorizontalLayoutPack from '../../eventlayout/HorizontalLayoutPack.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerEventRendering\n */\n\n/**\n * Layout data object used to lay out an event record.\n * @typedef {Object} EventRenderData\n * @property {Scheduler.model.EventModel} eventRecord Event instance\n * @property {Scheduler.model.ResourceModel} resourceRecord Assigned resource\n * @property {Scheduler.model.AssignmentModel} assignmentRecord Assignment instance\n * @property {Number} startMS Event start date time in milliseconds\n * @property {Number} endMS Event end date in milliseconds\n * @property {Number} height Calculated event element height\n * @property {Number} width Calculated event element width\n * @property {Number} top Calculated event element top position in the row (or column)\n * @property {Number} left Calculated event element left position in the row (or column)\n */\n\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixin\n */\nexport default Target => class SchedulerEventRendering extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerEventRendering';\n    }\n\n    //region Default config\n\n    static get configurable() {\n        return {\n            /**\n             * Position of the milestone text:\n             * * 'inside' - for short 1-char text displayed inside the diamond, not applicable when using\n             *   {@link #config-milestoneLayoutMode})\n             * * 'outside' - for longer text displayed outside the diamond, but inside it when using\n             *   {@link #config-milestoneLayoutMode}\n             * * 'always-outside' - outside even when combined with {@link #config-milestoneLayoutMode}\n             *\n             * @prp {'inside'|'outside'|'always-outside'}\n             * @default\n             * @category Milestones\n             */\n            milestoneTextPosition : 'outside',\n\n            /**\n             * How to align milestones in relation to their startDate. Only applies when using a `milestoneLayoutMode`\n             * other than `default`. Valid values are:\n             * * start\n             * * center (default)\n             * * end\n             * @prp {'start'|'center'|'end'}\n             * @default\n             * @category Milestones\n             */\n            milestoneAlign : 'center',\n\n            /**\n             * Factor representing the average char width in pixels used to determine milestone width when configured\n             * with `milestoneLayoutMode: 'estimate'`.\n             * @prp {Number}\n             * @default\n             * @category Milestones\n             */\n            milestoneCharWidth : 10,\n\n            /**\n             * How to handle milestones during event layout. How the milestones are displayed when part of the layout\n             * are controlled using {@link #config-milestoneTextPosition}.\n             *\n             * Options are:\n             * * default - Milestones do not affect event layout\n             * * estimate - Milestone width is estimated by multiplying text length with Scheduler#milestoneCharWidth\n             * * data - Milestone width is determined by checking EventModel#milestoneWidth\n             * * measure - Milestone width is determined by measuring label width\n             * Please note that currently text width is always determined using EventModel#name.\n             * Also note that only 'default' is supported by eventStyles line, dashed and minimal.\n             * @prp {'default'|'estimate'|'data'|'measure'}\n             * @default\n             * @category Milestones\n             */\n            milestoneLayoutMode : 'default',\n\n            /**\n             * Defines how to handle overlapping events. Valid values are:\n             * - `stack`, adjusts row height (only horizontal)\n             * - `pack`, adjusts event height\n             * - `mixed`, allows two events to overlap, more packs (only vertical)\n             * - `none`, allows events to overlap\n             *\n             * This config can also accept an object:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     eventLayout : { type : 'stack' }\n             * })\n             * ```\n             *\n             * @prp {'stack'|'pack'|'mixed'|'none'|Object}\n             * @default\n             * @category Scheduled events\n             */\n            eventLayout : 'stack',\n\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. See {@link\n             * #config-overlappingEventSorter} for more details.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @member {Function} overlappingEventSorter\n             * @category Misc\n             */\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. This only applies\n             * to the horizontal mode, where the order the events are sorted in determines their vertical placement\n             * within a resource.\n             *\n             * By default, overlapping events are laid out based on the start date. If the start date is equal, events\n             * with earlier end date go first. And lastly the name of events is taken into account.\n             *\n             * Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event\n             * `a` is placed above event `b`:\n             *\n             * ```javascript\n             * overlappingEventSorter(a, b) {\n             *\n             *   const startA = a.startDate, endA = a.endDate;\n             *   const startB = b.startDate, endB = b.endDate;\n             *\n             *   const sameStart = (startA - startB === 0);\n             *\n             *   if (sameStart) {\n             *     return endA > endB ? -1 : 1;\n             *   } else {\n             *     return (startA < startB) ? -1 : 1;\n             *   }\n             * }\n             * ```\n             *\n             * NOTE: The algorithms (stack, pack) that lay the events out expects them to be served in chronological\n             * order, be sure to first sort by `startDate` to get predictable results.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @config {Function}\n             * @category Misc\n             */\n            overlappingEventSorter : null,\n\n            /**\n             * Deprecated, to be removed in version 6.0. Replaced by {@link #config-overlappingEventSorter}.\n             * @deprecated Since 5.0. Use {@link #config-overlappingEventSorter} instead.\n             * @config {Function}\n             * @category Misc\n             */\n            horizontalEventSorterFn : null,\n\n            /**\n             * Control how much space to leave between the first event/last event and the resources edge (top/bottom\n             * margin within the resource row in horizontal mode, left/right margin within the resource column in\n             * vertical mode), in px. Defaults to the value of {@link Scheduler.view.Scheduler#config-barMargin}.\n             *\n             * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-resourceMargin\n             * resource.resourceMargin}.\n             *\n             * @prp {Number}\n             * @category Scheduled events\n             */\n            resourceMargin : null,\n\n            /**\n             * By default, scheduler fade events in on load. Specify `false` to prevent this animation or specify one\n             * of the available animation types to use it (`true` equals `'fade-in'`):\n             * * fade-in (default)\n             * * slide-from-left\n             * * slide-from-top\n             * ```\n             * // Slide events in from the left on load\n             * scheduler = new Scheduler({\n             *     useInitialAnimation : 'slide-from-left'\n             * });\n             * ```\n             * @prp {Boolean|String}\n             * @default\n             * @category Misc\n             */\n            useInitialAnimation : true,\n\n            /**\n             * An empty function by default, but provided so that you can override it. This function is called each time\n             * an event is rendered into the schedule to render the contents of the event. It's called with the event,\n             * its resource and a `renderData` object which allows you to populate data placeholders inside the event\n             * template. **IMPORTANT** You should never modify any data on the EventModel inside this method.\n             *\n             * By default, the DOM markup of an event bar includes placeholders for 'cls' and 'style'. The cls property\n             * is a {@link Core.helper.util.DomClassList} which will be added to the event element. The style property\n             * is an inline style declaration for the event element.\n             *\n             * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS\n             * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as\n             * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as\n             * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.\n             *\n             * ```javascript\n             *  eventRenderer({ eventRecord, resourceRecord, renderData }) {\n             *      renderData.style = 'color:white';                 // You can use inline styles too.\n             *\n             *      // Property names with truthy values are added to the resulting elements CSS class.\n             *      renderData.cls.isImportant = this.isImportant(eventRecord);\n             *      renderData.cls.isModified = eventRecord.isModified;\n             *\n             *      // Remove a class name by setting the property to false\n             *      renderData.cls[scheduler.generatedIdCls] = false;\n             *\n             *      // Or, you can treat it as a string, but this is less efficient, especially\n             *      // if your renderer wants to *remove* classes that may be there.\n             *      renderData.cls += ' extra-class';\n             *\n             *      return StringHelper.xss`${DateHelper.format(eventRecord.startDate, 'YYYY-MM-DD')}: ${eventRecord.name}`;\n             *  }\n             * ```\n             *\n             * @param {Object} detail An object containing the information needed to render an Event.\n             * @param {Scheduler.model.EventModel} detail.eventRecord The event record.\n             * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record.\n             * @param {Scheduler.model.AssignmentModel} detail.assignmentRecord The assignment record.\n             * @param {Object} detail.renderData An object containing details about the event rendering.\n             * @param {Scheduler.model.EventModel} detail.renderData.event The event record.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.cls An object whose property names\n             * represent the CSS class names to be added to the event bar element. Set a property's value to truthy or\n             * falsy to add or remove the class name based on the property name. Using this technique, you do not have\n             * to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.wrapperCls An object whose property names\n             * represent the CSS class names to be added to the event wrapper element. Set a property's value to truthy\n             * or falsy to add or remove the class name based on the property name. Using this technique, you do not\n             * have to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.iconCls An object whose property names\n             * represent the CSS class names to be added to an event icon element.\n             *\n             * Note that an element carrying this icon class is injected into the event element *after*\n             * the renderer completes, *before* the renderer's created content.\n             *\n             * To disable this if the renderer takes full control and creates content using the iconCls,\n             * you can set `renderData.iconCls = null`.\n             * @param {Number} detail.renderData.left Vertical offset position (in pixels) on the time axis.\n             * @param {Number} detail.renderData.width Width in pixels of the event element.\n             * @param {Number} detail.renderData.height Height in pixels of the event element.\n             * @param {String|Object<String,String>} detail.renderData.style Inline styles for the event bar DOM element.\n             * Use either 'border: 1px solid black' or `{ border: '1px solid black' }`\n             * @param {String|Object<String,String>} detail.renderData.wrapperStyle Inline styles for wrapper of the\n             * event bar DOM element. Use either 'border: 1px solid green' or `{ border: '1px solid green' }`\n             * @param {String} detail.renderData.eventStyle The `eventStyle` of the event. Use this to apply custom\n             * styles to the event DOM element\n             * @param {String} detail.renderData.eventColor The `eventColor` of the event. Use this to set a custom\n             * color for the rendered event\n             * @param {DomConfig[]} detail.renderData.children An array of DOM configs used as children to the\n             * `b-sch-event` element. Can be populated with additional DOM configs to have more control over contents.\n             * @returns {String|Object} A simple string, or a custom object which will be applied to the\n             * {@link #config-eventBodyTemplate}, creating the actual HTML\n             * @config {Function}\n             * @category Scheduled events\n             */\n            eventRenderer : null,\n\n            /**\n             * `this` reference for the {@link #config-eventRenderer} function\n             * @config {Object}\n             * @category Scheduled events\n             */\n            eventRendererThisObj : null,\n\n            /**\n             * Field from EventModel displayed as text in the bar when rendering\n             * @config {String}\n             * @default\n             * @category Scheduled events\n             */\n            eventBarTextField : 'name',\n\n            /**\n             * The template used to generate the markup of your events in the scheduler. To 'populate' the\n             * eventBodyTemplate with data, use the {@link #config-eventRenderer} method.\n             * @config {Function}\n             * @category Scheduled events\n             */\n            eventBodyTemplate : null,\n\n            /**\n             * The class responsible for the packing horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutPackClass : HorizontalLayoutPack,\n\n            /**\n             * The class name responsible for the stacking horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutStackClass : HorizontalLayoutStack,\n\n            /**\n             * A config object used to configure the resource columns in vertical mode.\n             * See {@link Scheduler.view.ResourceHeader} for more details on available properties.\n             *\n             * ```\n             * new Scheduler({\n             *   resourceColumns : {\n             *     columnWidth    : 100,\n             *     headerRenderer : ({ resourceRecord }) => `${resourceRecord.id} - ${resourceRecord.name}`\n             *   }\n             * })\n             * ```\n             * @config {ResourceHeaderConfig}\n             * @category Resources\n             */\n            resourceColumns : null,\n\n            /**\n             * Path to load resource images from. Used by the resource header in vertical mode and the\n             * {@link Scheduler.column.ResourceInfoColumn} in horizontal mode. Set this to display miniature\n             * images for each resource using their `image` or `imageUrl` fields.\n             *\n             * * `image` represents image name inside the specified `resourceImagePath`,\n             * * `imageUrl` represents fully qualified image URL.\n             *\n             *  If set and a resource has no `imageUrl` or `image` specified it will try show miniature using\n             *  the resource's name with {@link #config-resourceImageExtension} appended.\n             *\n             * **NOTE**: The path should end with a `/`:\n             *\n             * ```\n             * new Scheduler({\n             *   resourceImagePath : 'images/resources/'\n             * });\n             * ```\n             * @config {String}\n             * @category Resources\n             */\n            resourceImagePath : null,\n\n            /**\n             * Generic resource image, used when provided `imageUrl` or `image` fields or path calculated from resource\n             * name are all invalid. If left blank, resource name initials will be shown when no image can be loaded.\n             * @default\n             * @config {String}\n             * @category Resources\n             */\n            defaultResourceImageName : null,\n\n            /**\n             * Resource image extension, used when creating image path from resource name.\n             * @default\n             * @config {String}\n             * @category Resources\n             */\n            resourceImageExtension : '.jpg',\n\n            /**\n             * Controls how much space to leave between stacked event bars in px.\n             *\n             * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-barMargin\n             * resource.barMargin}.\n             *\n             * @config {Number} barMargin\n             * @default\n             * @category Scheduled events\n             */\n\n            // Used to animate events on first render\n            isFirstRender : true,\n\n            initialAnimationDuration : 2000,\n\n            /**\n             * When an event bar has a width less than this value, it gets the CSS class `b-sch-event-narrow`\n             * added. You may apply custom CSS rules using this class.\n             *\n             * In vertical mode, this class causes the text to be rotated so that it runs vertically.\n             * @default\n             * @config {Number}\n             * @category Scheduled events\n             */\n            narrowEventWidth : 10,\n\n            internalEventLayout : null,\n            eventPositionMode   : 'translate',\n            eventScrollMode     : 'move'\n        };\n    }\n\n    //endregion\n\n    //region Settings\n\n    changeEventLayout(eventLayout) {\n        // Pass layout config to internal config to normalize its form\n        this.internalEventLayout = eventLayout;\n\n        // Return normalized string type\n        return this.internalEventLayout.type;\n    }\n\n    changeInternalEventLayout(eventLayout) {\n        return this.getEventLayout(eventLayout);\n    }\n\n    updateInternalEventLayout(eventLayout, oldEventLayout) {\n        const me = this;\n\n        if (oldEventLayout) {\n            me.element.classList.remove(`b-eventlayout-${oldEventLayout.type}`);\n        }\n\n        me.element.classList.add(`b-eventlayout-${eventLayout.type}`);\n\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n\n            me.trigger('stateChange');\n        }\n    }\n\n    changeHorizontalEventSorterFn(fn) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Replaced by overlappingEventSorter()');\n        this.overlappingEventSorter = fn;\n    }\n\n    updateOverlappingEventSorter(fn) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n\n    //endregion\n\n    //region Layout helpers\n\n    // Wraps string config to object with type\n    getEventLayout(value) {\n        if (value?.isModel) {\n            value = value.eventLayout || this.internalEventLayout;\n        }\n\n        if (typeof value === 'string') {\n            value = { type : value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Get event layout handler. The handler decides the vertical placement of events within a resource.\n     * Returns null if no eventLayout is used (if {@link #config-eventLayout} is set to \"none\")\n     * @internal\n     * @returns {Scheduler.eventlayout.HorizontalLayout}\n     * @readonly\n     * @category Scheduled events\n     */\n    getEventLayoutHandler(eventLayout) {\n        const me = this;\n\n        if (!me.isHorizontal) {\n            return null;\n        }\n\n        const\n            { timeAxisViewModel, horizontal } = me,\n            { type }                          = eventLayout;\n\n        if (!me.layouts) {\n            me.layouts = {};\n        }\n\n        switch (type) {\n            // stack, adjust row height to fit all events\n            case 'stack': {\n                if (!me.layouts.horizontalStack) {\n                    me.layouts.horizontalStack = new me.horizontalLayoutStackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyStack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n\n                return me.layouts.horizontalStack;\n            }\n            // pack, fit all events in available height by adjusting their height\n            case 'pack': {\n                if (!me.layouts.horizontalPack) {\n                    me.layouts.horizontalPack = new me.horizontalLayoutPackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyPack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n\n                return me.layouts.horizontalPack;\n            }\n            default:\n                return null;\n        }\n    }\n\n    //endregion\n\n    //region Resource header/columns\n\n    // NOTE: The configs below are initially applied to the resource header in `TimeAxisColumn#set mode`\n\n    /**\n     * Use it to manipulate resource column properties at runtime.\n     * @property {Scheduler.view.ResourceHeader}\n     * @readonly\n     * @category Resources\n     */\n    get resourceColumns() {\n        return this.timeAxisColumn?.resourceColumns || this._resourceColumns;\n    }\n\n    /**\n     * Get resource column width. Only applies to vertical mode. To set it, assign to\n     * `scheduler.resourceColumns.columnWidth`.\n     * @property {Number}\n     * @readonly\n     * @category Resources\n     */\n    get resourceColumnWidth() {\n        return this.resourceColumns?.columnWidth || null;\n    }\n\n    //endregion\n\n    //region Event rendering\n\n    // Chainable function called with the events to render for a specific resource. Allows features to add/remove.\n    // Chained by ResourceTimeRanges\n    getEventsToRender(resource, events) {\n        return events;\n    }\n\n    /**\n     * Rerenders events for specified resource (by rerendering the entire row).\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @category Rendering\n     */\n    repaintEventsForResource(resourceRecord) {\n        this.currentOrientation.repaintEventsForResource(resourceRecord);\n    }\n\n    /**\n     * Rerenders the events for all resources connected to the specified event\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @private\n     */\n    repaintEvent(eventRecord) {\n        const resources = this.eventStore.getResourcesForEvent(eventRecord);\n        resources.forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));\n    }\n\n    // Returns a resource specific resourceMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceMargin(resourceRecord) {\n        return resourceRecord?.resourceMargin ?? this.resourceMargin;\n    }\n\n    // Returns a resource specific barMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getBarMargin(resourceRecord) {\n        return resourceRecord?.barMargin ?? this.barMargin;\n    }\n\n    // Returns a resource specific rowHeight, falling back to Schedulers setting\n    // Prio order: Height from record, configured height\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceHeight(resourceRecord) {\n        return resourceRecord.rowHeight ?? (this.isHorizontal ? this.rowHeight : this.getResourceWidth(resourceRecord));\n    }\n\n    getResourceWidth(resourceRecord) {\n        return resourceRecord.columnWidth ?? this.resourceColumnWidth;\n    }\n\n    // Similar to getResourceHeight(), but for usage later in the process to take height set by renderers into account.\n    // Cant be used earlier in the process because then the row will grow\n    // Prio order: Height requested by renderer, height from record, configured height\n    getAppliedResourceHeight(resourceRecord) {\n        const row = this.getRowById(resourceRecord);\n\n        return row?.maxRequestedHeight ?? this.getResourceHeight(resourceRecord);\n    }\n\n    // Combined convenience getter for destructuring on calling side\n    // Second arg only passed for nested events, handled by NestedEvent feature\n    getResourceLayoutSettings(resourceRecord, parentEventRecord = null) {\n        const\n            resourceMargin = this.getResourceMargin(resourceRecord, parentEventRecord),\n            rowHeight      = this.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n\n        return {\n            barMargin     : this.getBarMargin(resourceRecord, parentEventRecord),\n            contentHeight : Math.max(rowHeight - resourceMargin * 2, 1),\n            rowHeight,\n            resourceMargin\n        };\n    }\n\n    getEventStyle(eventRecord, resourceRecord) {\n        return eventRecord.eventStyle || resourceRecord.eventStyle || this.eventStyle;\n    }\n\n    getEventColor(eventRecord, resourceRecord) {\n        return eventRecord.eventColor || eventRecord.event?.eventColor || eventRecord.parent?.eventColor || resourceRecord.eventColor || this.eventColor;\n    }\n\n    //endregion\n\n    //region Template\n\n    /**\n     * Generates data used in the template when rendering an event. For example which css classes to use. Also applies\n     * #eventBodyTemplate and calls the {@link #config-eventRenderer}.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Event to generate data for\n     * @param {Scheduler.model.ResourceModel} resourceRecord Events resource\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside the vertical timespan viewport's bounds.\n     * @returns {Object} Data to use in event template, or `undefined` if the event is outside the rendered zone.\n     */\n    generateRenderData(eventRecord, resourceRecord, includeOutside = { viewport : true }) {\n        // <remove-on-release>\n        // TODO: Change this fn to accept an assignment instead of event + resource\n        // </remove-on-release>\n        const\n            me               = this,\n            // generateRenderData calculates layout for events which are outside the vertical viewport\n            // because the RowManager needs to know a row height.\n            renderData       = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside),\n            { isEvent }      = eventRecord,\n            { eventResize }  = me.features,\n            // Don't want events drag created to zero duration to render as milestones\n            isMilestone      = !eventRecord.meta.isDragCreating && eventRecord.isMilestone,\n            // $originalId allows lookup to yield same result for original resources and linked resources\n            assignmentRecord = isEvent && eventRecord.assignments.find(a => a.resourceId === resourceRecord.$originalId),\n            // Events inner element, will be populated by renderer and/or eventBodyTemplate\n            eventContent     = {\n                className : 'b-sch-event-content',\n                role      : 'presentation',\n                dataset   : {\n                    taskBarFeature : 'content'\n                }\n            };\n\n        if (renderData) {\n            renderData.tabIndex = '0';\n\n            let resizable = eventRecord.isResizable;\n\n            if (eventResize && resizable) {\n                if (renderData.startsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'end';\n                    }\n                    else if (resizable === 'start') {\n                        resizable = false;\n                    }\n                }\n                if (renderData.endsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'start';\n                    }\n                    else if (resizable === 'end') {\n                        resizable = false;\n                    }\n                }\n\n                // Let the feature veto start/end handles\n                if (resizable) {\n                    if (me.isHorizontal) {\n                        if ((!me.rtl && !eventResize.leftHandle) || (me.rtl && !eventResize.rightHandle)) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if ((!me.rtl && !eventResize.rightHandle) || (me.rtl && !eventResize.leftHandle)) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                    else {\n                        if (!eventResize.topHandle) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if (!eventResize.bottomHandle) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                }\n            }\n\n            // Event record cls properties are now DomClassList instances, so clone them\n            // so that they can be manipulated here and by renderers.\n            // Truthy value means the key will be added as a class name.\n            // ResourceTimeRanges applies custom cls to wrapper.\n            const\n                // Boolean needed here, otherwise DomSync will dig into comparing the modifications\n                isDirty           = Boolean(\n                    eventRecord.hasPersistableChanges || assignmentRecord?.hasPersistableChanges\n                ),\n                clsListObj        = {\n                    [resourceRecord.cls]      : resourceRecord.cls,\n                    [me.generatedIdCls]       : !eventRecord.isOccurrence && eventRecord.hasGeneratedId,\n                    [me.dirtyCls]             : isDirty,\n                    [me.committingCls]        : eventRecord.isCommitting,\n                    [me.endsOutsideViewCls]   : renderData.endsOutsideView,\n                    [me.startsOutsideViewCls] : renderData.startsOutsideView,\n                    'b-clipped-start'         : renderData.clippedStart,\n                    'b-clipped-end'           : renderData.clippedEnd,\n                    'b-iscreating'            : eventRecord.isCreating,\n                    'b-rtl'                   : me.rtl\n                },\n                wrapperClsListObj = {\n                    [`${me.eventCls}-parent`] : resourceRecord.isParent,\n                    'b-readonly'              : eventRecord.readOnly || assignmentRecord?.readOnly,\n                    'b-linked-resource'       : resourceRecord.isLinked,\n                    'b-original-resource'     : resourceRecord.hasLinks\n                },\n                clsList           = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.internalCls.clone(),\n                wrapperClsList    = eventRecord.isResourceTimeRange ? eventRecord.internalCls.clone() : new DomClassList();\n\n            renderData.wrapperStyle = '';\n\n            // mark as wrapper to make sure fire render events for this level only\n            renderData.isWrap = true;\n\n            // Event specifics, things that do not apply to ResourceTimeRanges\n            if (isEvent) {\n                const selected = assignmentRecord && me.isAssignmentSelected(assignmentRecord);\n\n                ObjectHelper.assign(clsListObj, {\n                    [me.eventCls]                          : 1,\n                    'b-milestone'                          : isMilestone,\n                    'b-sch-event-narrow'                   : !isMilestone && renderData.width < me.narrowEventWidth,\n                    [me.fixedEventCls]                     : eventRecord.isDraggable === false,\n                    [`b-sch-event-resizable-${resizable}`] : Boolean(eventResize && !eventRecord.readOnly),\n                    [me.eventSelectedCls]                  : selected,\n                    [me.eventAssignHighlightCls]           : me.eventAssignHighlightCls && !selected && me.isEventSelected(eventRecord),\n                    'b-recurring'                          : eventRecord.isRecurring,\n                    'b-occurrence'                         : eventRecord.isOccurrence,\n                    'b-inactive'                           : eventRecord.inactive\n                });\n\n                renderData.eventId  = eventRecord.id;\n\n                const\n                    eventStyle   = me.getEventStyle(eventRecord, resourceRecord),\n                    eventColor   = me.getEventColor(eventRecord, resourceRecord),\n                    hasAnimation = me.isFirstRender && me.useInitialAnimation && globalThis.bryntum.noAnimations !== true;\n\n                ObjectHelper.assign(wrapperClsListObj, {\n                    [`${me.eventCls}-wrap`] : 1,\n                    'b-milestone-wrap'      : isMilestone\n                });\n\n                if (hasAnimation) {\n                    const\n                        index   = renderData.row ? renderData.row.index : (renderData.top - me.scrollTop) / me.tickSize,\n                        delayMS = index / 20 * 1000;\n\n                    renderData.wrapperStyle = `animation-delay: ${delayMS}ms;`;\n                    me.maxDelay = Math.max(me.maxDelay || 0, delayMS);\n\n                    // Add an extra delay to wait for the most delayed animation to finish\n                    // before we call stopInitialAnimation. In this way, we allow them all to finish\n                    // before we remove the b-initial-${me._useInitialAnimation} class.\n                    if (!me.initialAnimationDetacher) {\n                        me.initialAnimationDetacher = EventHelper.on({\n                            element  : me.foregroundCanvas,\n                            delegate : me.eventSelector,\n\n                            // Just listen for the first animation end fired by our event els\n                            once         : true,\n                            animationend : () => me.setTimeout({\n                                fn                : 'stopInitialAnimation',\n                                delay             : me.maxDelay,\n                                cancelOutstanding : true\n                            }),\n                            // Fallback in case animation is interrupted\n                            expires : {\n                                alt   : 'stopInitialAnimation',\n                                delay : me.initialAnimationDuration + me.maxDelay\n                            },\n                            thisObj : me\n                        });\n                    }\n                }\n\n                renderData.eventColor = eventColor;\n                renderData.eventStyle = eventStyle;\n\n                // <remove-on-release>\n                // TODO: Deprecate assignment, use assignmentRecord\n                // </remove-on-release>\n                renderData.assignmentRecord = renderData.assignment = assignmentRecord;\n            }\n\n            // If not using a wrapping div, this cls will be added to event div for correct rendering\n            renderData.wrapperCls = ObjectHelper.assign(wrapperClsList, wrapperClsListObj);\n\n            renderData.cls = ObjectHelper.assign(clsList, clsListObj);\n            renderData.iconCls = new DomClassList(eventRecord.get(me.eventBarIconClsField) || eventRecord.iconCls);\n\n            // ResourceTimeRanges applies custom style to the wrapper\n            if (eventRecord.isResourceTimeRange) {\n                renderData.style = '';\n                renderData.wrapperStyle += eventRecord.style || '';\n            }\n            // Others to inner\n            else {\n                renderData.style = eventRecord.style || '';\n            }\n\n            // <remove-on-release>\n            // TODO: Deprecate resource in favor of resourceRecord\n            // </remove-on-release>\n            renderData.resource = renderData.resourceRecord = resourceRecord;\n            renderData.resourceId = renderData.rowId;\n\n            if (isEvent) {\n                let childContent = null,\n                    milestoneLabelConfig = null,\n                    value;\n\n                if (me.eventRenderer) {\n                    // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate\n                    const\n                        rendererValue = me.eventRenderer.call(me.eventRendererThisObj || me, {\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord : renderData.assignmentRecord,\n                            renderData\n                        });\n\n                    // If the user's renderer coerced it into a string, recreate a DomClassList.\n                    if (typeof renderData.cls === 'string') {\n                        renderData.cls = new DomClassList(renderData.cls);\n                    }\n\n                    if (typeof renderData.wrapperCls === 'string') {\n                        renderData.wrapperCls = new DomClassList(renderData.wrapperCls);\n                    }\n\n                    // Same goes for iconCls\n                    if (typeof renderData.iconCls === 'string') {\n                        renderData.iconCls = new DomClassList(renderData.iconCls);\n                    }\n\n                    if (me.eventBodyTemplate) {\n                        value = me.eventBodyTemplate(rendererValue);\n                    }\n                    else {\n                        value = rendererValue;\n                    }\n                }\n                else if (me.eventBodyTemplate) {\n                    // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.\n                    value = me.eventBodyTemplate(eventRecord);\n                }\n                else if (me.eventBarTextField) {\n                    // User has specified a field in the data model to read from\n                    value = StringHelper.encodeHtml(eventRecord[me.eventBarTextField] || '');\n                }\n\n                if (!me.eventBodyTemplate || Array.isArray(value)) {\n                    eventContent.children = [];\n\n                    // Give milestone a dedicated label element so we can use padding\n                    if (isMilestone && (me.milestoneLayoutMode === 'default' || me.milestoneTextPosition === 'always-outside') && value != null && value !== '') {\n                        eventContent.children.unshift(milestoneLabelConfig = {\n                            tag      : 'label',\n                            children : []\n                        });\n                    }\n\n                    if (renderData.iconCls?.length) {\n                        eventContent.children.unshift({\n                            tag       : 'i',\n                            className : renderData.iconCls\n                        });\n                    }\n\n                    // Array, assumed to contain DOM configs for eventContent children (or milestone label)\n                    if (Array.isArray(value)) {\n                        (milestoneLabelConfig || eventContent).children.push(...value);\n                    }\n                    // Likely HTML content\n                    else if (StringHelper.isHtml(value)) {\n                        if (eventContent.children.length) {\n                            childContent = {\n                                tag   : 'span',\n                                class : 'b-event-text-wrap',\n                                html  : value\n                            };\n                        }\n                        else {\n                            eventContent.children = null;\n                            eventContent.html = value;\n                        }\n                    }\n                    // DOM config or plain string can be used as is\n                    else if (typeof value === 'string' || typeof value === 'object') {\n                        childContent = value;\n                    }\n                    // Other, use string\n                    else if (value != null) {\n                        childContent = String(value);\n                    }\n\n                    // Must allow empty string as valid content\n                    if (childContent != null) {\n                        // Milestones have content in their label, other events in their \"body\"\n                        (milestoneLabelConfig || eventContent).children.push(childContent);\n                        renderData.cls.add('b-has-content');\n                    }\n\n                    if (eventContent.html != null || eventContent.children.length) {\n                        renderData.children.push(eventContent);\n                    }\n                }\n                else {\n                    eventContent.html = value;\n                    renderData.children.push(eventContent);\n                }\n            }\n\n            const { eventStyle, eventColor } = renderData;\n\n            // Renderers have last say on style & color\n            renderData.wrapperCls[`b-sch-style-${eventStyle || 'none'}`] = 1;\n\n            // Named colors are applied as a class to the wrapper\n            if (DomHelper.isNamedColor(eventColor)) {\n                renderData.wrapperCls[`b-sch-color-${eventColor}`] = eventColor;\n            }\n            else if (eventColor) {\n                const colorProp = eventStyle ? 'color' : 'background-color';\n\n                renderData.style = `${colorProp}:${eventColor};` + renderData.style;\n                renderData.wrapperCls['b-sch-custom-color'] = 1;\n            }\n            else {\n                renderData.wrapperCls[`b-sch-color-none`] = 1;\n            }\n\n            // Milestones has to apply styling to b-sch-event-content\n            if (renderData.style && isMilestone && eventContent) {\n                eventContent.style = renderData.style;\n                delete renderData.style;\n            }\n\n            // If there are any iconCls entries...\n            renderData.cls['b-sch-event-withicon'] = renderData.iconCls?.length;\n\n            // For comparison in sync, cheaper than comparing DocumentFragments\n            renderData.eventContent = eventContent;\n\n            renderData.wrapperChildren = [];\n\n            // Method which features may chain in to\n            me.onEventDataGenerated(renderData);\n        }\n\n        return renderData;\n    }\n\n    /**\n     * A method which may be chained by features. It is called when an event's render\n     * data is calculated so that features may update the style, class list or body.\n     * @param {Object} eventData\n     * @internal\n     */\n    onEventDataGenerated(eventData) {}\n\n    //endregion\n\n    //region Initial animation\n\n    changeUseInitialAnimation(name) {\n        return name === true ? 'fade-in' : name;\n    }\n\n    updateUseInitialAnimation(name, old) {\n        const { classList } = this.element;\n\n        if (old) {\n            classList.remove(`b-initial-${old}`);\n        }\n\n        if (name) {\n            classList.add(`b-initial-${name}`);\n\n            // Transition block for FF, to not interfere with animations\n            if (BrowserHelper.isFirefox) {\n                classList.add('b-prevent-event-transitions');\n            }\n        }\n    }\n\n    /**\n     * Restarts initial events animation with new value {@link #config-useInitialAnimation}.\n     * @param {Boolean|String} initialAnimation new initial animation value\n     * @category Misc\n     */\n    restartInitialAnimation(initialAnimation) {\n        const me = this;\n\n        me.initialAnimationDetacher?.();\n        me.initialAnimationDetacher = null;\n\n        me.useInitialAnimation = initialAnimation;\n        me.isFirstRender = true;\n        me.refresh();\n    }\n\n    stopInitialAnimation() {\n        const me = this;\n\n        me.initialAnimationDetacher();\n        me.isFirstRender = false;\n\n        // Prevent any further initial animations\n        me.useInitialAnimation = false;\n\n        // Remove transition block for FF a bit later, to not interfere with animations\n        if (BrowserHelper.isFirefox) {\n            me.setTimeout(() => me.element.classList.remove('b-prevent-event-transitions'), 100);\n        }\n    }\n\n    //endregion\n\n    //region Milestones\n\n    /**\n     * Determines width of a milestones label. How width is determined is decided by configuring\n     * {@link #config-milestoneLayoutMode}. Please note that text width is always determined using the events\n     * {@link Scheduler/model/EventModel#field-name}.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Number}\n     * @category Milestones\n     */\n    getMilestoneLabelWidth(eventRecord, resourceRecord) {\n        const\n            me   = this,\n            mode = me.milestoneLayoutMode,\n            size = me.getResourceLayoutSettings(resourceRecord).contentHeight;\n\n        if (mode === 'measure') {\n            const\n                html    = StringHelper.encodeHtml(eventRecord.name),\n                color   = me.getEventColor(eventRecord, resourceRecord),\n                style   = me.getEventStyle(eventRecord, resourceRecord),\n                element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({\n                    className : {\n                        'b-sch-event-wrap'       : 1,\n                        'b-milestone-wrap'       : 1,\n                        'b-measure'              : 1,\n                        [`b-sch-color-${color}`] : color,\n                        [`b-sch-style-${style}`] : style\n                    },\n                    children : [\n                        {\n                            className : 'b-sch-event b-milestone',\n                            children  : [\n                                {\n                                    className : 'b-sch-event-content',\n                                    children  : [\n                                        { tag : 'label' }\n                                    ]\n                                }\n                            ]\n                        }\n                    ],\n                    parent : me.foregroundCanvas\n                }));\n\n            // DomSync should not touch\n            element.retainElement = true;\n\n            element.style.fontSize = `${size}px`;\n\n            if (me.milestoneTextPosition === 'always-outside') {\n                const label = element.firstElementChild.firstElementChild.firstElementChild;\n\n                label.innerHTML = html;\n\n                const bounds = Rectangle.from(label, label.parentElement);\n\n                // +2 for a little margin\n                return bounds.left + bounds.width + 2;\n            }\n            else {\n                // b-sch-event-content\n                element.firstElementChild.firstElementChild.innerHTML = `<label></label>${html}`;\n\n                return element.firstElementChild.offsetWidth;\n            }\n        }\n\n        if (mode === 'estimate') {\n            return eventRecord.name.length * me.milestoneCharWidth + (me.milestoneTextPosition === 'always-outside' ? size : 0);\n        }\n\n        if (mode === 'data') {\n            return eventRecord.milestoneWidth;\n        }\n\n        return 0;\n    }\n\n    updateMilestoneLayoutMode(mode) {\n        const\n            me            = this,\n            alwaysOutside = me.milestoneTextPosition === 'always-outside';\n\n        me.element.classList.toggle('b-sch-layout-milestones', mode !== 'default' && !alwaysOutside);\n        me.element.classList.toggle('b-sch-layout-milestone-labels', mode !== 'default' && alwaysOutside);\n\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n        }\n    }\n\n    updateMilestoneTextPosition(position) {\n        this.element.classList.toggle('b-sch-layout-milestone-text-position-inside', position === 'inside');\n\n        this.updateMilestoneLayoutMode(this.milestoneLayoutMode);\n    }\n\n    updateMilestoneAlign() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n\n    updateMilestoneCharWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n\n    // endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport ProjectConsumer from '../../data/mixin/ProjectConsumer.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerStores\n */\n\n/**\n * Functions for store assignment and store event listeners.\n *\n * @mixin\n * @extends Scheduler/data/mixin/ProjectConsumer\n */\nexport default Target => class SchedulerStores extends ProjectConsumer(Target || Base) {\n    static get $name() {\n        return 'SchedulerStores';\n    }\n\n    //region Default config\n\n    // This is the static definition of the Stores we consume from the project, and\n    // which we must provide *TO* the project if we or our CrudManager is configured\n    // with them.\n    // The property name is the store name, and within that there is the dataName which\n    // is the property which provides static data definition. And there is a listeners\n    // definition which specifies the listeners *on this object* for each store.\n    //\n    // To process incoming stores, implement an updateXxxxxStore method such\n    // as `updateEventStore(eventStore)`.\n    //\n    // To process an incoming Project implement `updateProject`. __Note that\n    // `super.updateProject(...arguments)` must be called first.__\n    static get projectStores() {\n        return {\n            resourceStore : {\n                dataName : 'resources'\n            },\n\n            eventStore : {\n                dataName  : 'events',\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : {\n                    batchedUpdate   : 'onEventStoreBatchedUpdate',\n                    changePreCommit : 'onInternalEventStoreChange',\n                    commitStart     : 'onEventCommitStart',\n                    commit          : 'onEventCommit',\n                    exception       : 'onEventException',\n                    idchange        : 'onEventIdChange',\n                    beforeLoad      : 'onBeforeLoad'\n                }\n            },\n\n            assignmentStore : {\n                dataName  : 'assignments',\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : {\n                    changePreCommit : 'onAssignmentChange', // In EventSelection.js\n                    commitStart     : 'onAssignmentCommitStart',\n                    commit          : 'onAssignmentCommit',\n                    exception       : 'onAssignmentException',\n                    beforeRemove    : {\n                        fn   : 'onAssignmentBeforeRemove',\n                        // We must go last in case an app vetoes a remove\n                        // by returning false from a handler.\n                        prio : -1000\n                    }\n                }\n            },\n\n            dependencyStore : {\n                dataName : 'dependencies'\n            },\n\n            calendarManagerStore   : {},\n            timeRangeStore         : {},\n            resourceTimeRangeStore : {}\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Overridden to *not* auto create a store at the Scheduler level.\n             * The store is the {@link Scheduler.data.ResourceStore} of the backing project\n             * @config {Core.data.Store}\n             * @private\n             */\n            store : null,\n\n            /**\n             * The name of the start date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            startParamName : 'startDate',\n\n            /**\n             * The name of the end date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            endParamName : 'endDate',\n\n            /**\n             * Set to true to include `startDate` and `endDate` params indicating the currently viewed date range.\n             * Dates are formatted using the same format as the `startDate` field on the EventModel\n             * (e.g. 2023-03-08T00:00:00+01:00).\n             *\n             * Enabled by default in version 6.0 and above.\n             *\n             * @config {Boolean}\n             */\n            passStartEndParameters : VersionHelper.checkVersion('core', '6.0', '>='),\n\n            /**\n             * Class that should be used to instantiate a CrudManager in case it's provided as a simple object to\n             * {@link #config-crudManager} config.\n             * @config {Scheduler.data.CrudManager}\n             * @typings {typeof CrudManager}\n             * @category Data\n             */\n            crudManagerClass : null,\n\n            /**\n             * Get/set the CrudManager instance\n             * @member {Scheduler.data.CrudManager} crudManager\n             * @category Data\n             */\n            /**\n             * Supply a {@link Scheduler.data.CrudManager} instance or a config object if you want to use\n             * CrudManager for handling data.\n             * @config {CrudManagerConfig|Scheduler.data.CrudManager}\n             * @category Data\n             */\n            crudManager : null\n        };\n    }\n\n    //endregion\n\n    //region Project\n\n    updateProject(project, oldProject) {\n        super.updateProject(project, oldProject);\n\n        this.detachListeners('schedulerStores');\n\n        project.ion({\n            name    : 'schedulerStores',\n            refresh : 'onProjectRefresh',\n            thisObj : this\n        });\n    }\n\n    // Called when project changes are committed, before data is written back to records (but still ready to render\n    // since data is fetched from engine)\n    onProjectRefresh({ isInitialCommit }) {\n        const me = this;\n\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            if (isInitialCommit) {\n                if (me.isVertical) {\n                    me.refreshAfterProjectRefresh = false;\n                    me.refreshWithTransition();\n                }\n            }\n\n            if (me.navigateToAfterRefresh) {\n                me.navigateTo(me.navigateToAfterRefresh);\n                me.navigateToAfterRefresh = null;\n            }\n\n            if (me.refreshAfterProjectRefresh) {\n                me.refreshWithTransition(false, !isInitialCommit);\n                me.refreshAfterProjectRefresh = false;\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n\n    //endregion\n\n    //region CrudManager\n\n    changeCrudManager(crudManager) {\n        const me = this;\n\n        if (crudManager && !crudManager.isCrudManager) {\n            //<debug>\n            if (!me.crudManagerClass) {\n                throw new Error('No CrudManager class configured on CrudManager\\'s View');\n            }\n            //</debug>\n\n            // CrudManager injects itself into is Scheduler's _crudManager property\n            // because code it triggers needs to access it through its getter.\n            crudManager = me.crudManagerClass.new({\n                scheduler : me\n            }, crudManager);\n        }\n        // config setter will veto because of above described behaviour\n        // of setting the property early on creation\n        me._crudManager = crudManager;\n\n        me.bindCrudManager(crudManager);\n    }\n\n    //endregion\n\n    //region Row store\n\n    get store() {\n        // Vertical uses a dummy store\n        if (!this._store && this.isVertical) {\n            // <remove-on-release>\n            // TODO: Make this store readonly, since we are using single cell approach\n            // </remove-on-release>\n            this._store = new Store({\n                data : [\n                    {\n                        id  : 'verticalTimeAxisRow', // no-sanity\n                        cls : 'b-verticaltimeaxis-row'\n                    }\n                ]\n            });\n        }\n\n        return super.store;\n    }\n\n    set store(store) {\n        super.store = store;\n    }\n\n    // Wrap w/ transition refreshFromRowOnStoreAdd() inherited from Grid\n    refreshFromRowOnStoreAdd(row, { isExpand, records }) {\n        const args = arguments;\n\n        this.runWithTransition(() => {\n            // Postpone drawing of events for a new resource until the following project refresh. Previously the draw\n            // would not happen because engine was not ready, but now when we allow commits and can read values during\n            // commit that block is no longer there\n            this.currentOrientation.suspended = !isExpand && !records.some(r => r.isLinked);\n\n            super.refreshFromRowOnStoreAdd(row, ...args);\n\n            this.currentOrientation.suspended = false;\n        }, !isExpand);\n    }\n\n    onStoreAdd(event) {\n        super.onStoreAdd(event);\n\n        if (this.isPainted) {\n            this.calculateRowHeights(event.records);\n        }\n    }\n\n    onStoreUpdateRecord({ source : store, record, changes }) {\n        // Ignore engine changes that do not affect row rendering\n        let ignoreCount = 0;\n\n        if ('assigned' in changes) {\n            ignoreCount++;\n        }\n\n        if ('calendar' in changes) {\n            ignoreCount++;\n        }\n\n        if (ignoreCount !== Object.keys(changes).length) {\n            super.onStoreUpdateRecord(...arguments);\n        }\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    updateResourceStore(resourceStore) {\n        // Reconfigure grid if resourceStore is backing the rows\n        if (resourceStore && this.isHorizontal) {\n            resourceStore.metaMapId = this.id;\n            this.store = resourceStore;\n        }\n    }\n\n    get usesDisplayStore() {\n        return this.store !== this.resourceStore;\n    }\n\n    //endregion\n\n    //region Events\n\n    onEventIdChange(params) {\n        this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);\n    }\n\n    /**\n     * Listener to the batchedUpdate event which fires when a field is changed on a record which\n     * is batch updating. Occasionally UIs must keep in sync with batched changes.\n     * For example, the EventResize feature performs batched updating of the startDate/endDate\n     * and it tells its client to listen to batchedUpdate.\n     * @private\n     */\n    onEventStoreBatchedUpdate(event) {\n        if (this.listenToBatchedUpdates) {\n            return this.onInternalEventStoreChange(event);\n        }\n    }\n\n    /**\n     * Calls appropriate functions for current event layout when the event store is modified.\n     * @private\n     */\n    // Named as Internal to avoid naming collision with wrappers that relay events\n    onInternalEventStoreChange(params) {\n        // Too early, bail out\n        // Also bail out if this is a reassign using resourceId, any updates will be handled by AssignmentStore instead\n        if (!this.isPainted || !this._mode || params.isAssign || this.assignmentStore.isRemovingAssignment) {\n            return;\n        }\n\n        // Only respond if we are visible. If not, defer until we are shown\n        if (this.isVisible) {\n            this.currentOrientation.onEventStoreChange(params);\n        }\n        else {\n            this.whenVisible(this.onInternalEventStoreChange, this, [params]);\n        }\n    }\n\n    /**\n     * Refreshes committed events, to remove dirty/committing flag.\n     * CSS is added\n     * @private\n     */\n    onEventCommit({ changes }) {\n        let resourcesToRepaint = [...changes.added, ...changes.modified].map(\n            eventRecord => this.eventStore.getResourcesForEvent(eventRecord)\n        );\n\n        // getResourcesForEvent returns an array, so need to flatten resourcesToRepaint\n        resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);\n\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n\n    /**\n     * Adds the committing flag to changed events before commit.\n     * @private\n     */\n    onEventCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n        // Committing sets a flag in meta that during event rendering applies a CSS class. But to not mess up drag and\n        // drop between resources no redraw is performed before committing, so class is never applied to the element(s).\n        // Applying here instead\n        [...changes.added, ...changes.modified].forEach(eventRecord =>\n            eventRecord.assignments.forEach(\n                assignmentRecord => currentOrientation.toggleCls(assignmentRecord, committingCls, true)\n            )\n        );\n    }\n\n    // Clear committing flag\n    onEventException({ action }) {\n        if (action === 'commit') {\n            const { changes } = this.eventStore;\n\n            [...changes.added, ...changes.modified, ...changes.removed].forEach(eventRecord =>\n                this.repaintEvent(eventRecord)\n            );\n        }\n    }\n\n    onAssignmentCommit({ changes }) {\n        this.repaintEventsForAssignmentChanges(changes);\n    }\n\n    onAssignmentCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n\n        [...changes.added, ...changes.modified].forEach(assignmentRecord => {\n            currentOrientation.toggleCls(assignmentRecord, committingCls, true);\n        });\n    }\n\n    // Clear committing flag\n    onAssignmentException({ action }) {\n        if (action === 'commit') {\n            this.repaintEventsForAssignmentChanges(this.assignmentStore.changes);\n        }\n    }\n\n    repaintEventsForAssignmentChanges(changes) {\n        const resourcesToRepaint = [...changes.added, ...changes.modified, ...changes.removed].map(\n            assignmentRecord => assignmentRecord.getResource()\n        );\n\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n\n    onAssignmentBeforeRemove({ records, removingAll }) {\n        if (removingAll) {\n            return;\n        }\n\n        const me = this;\n\n        let moveTo;\n\n        // Deassigning the active assignment\n        if (!me.isConfiguring &&\n            // If we have current active assignment or we scheduled navigating to an assignment, we should check\n            // if we're removing that assignment in order to avoid navigating to it\n            (me.navigateToAfterRefresh || me.activeAssignment && records.includes(me.activeAssignment))\n        ) {\n            // If next navigation target is removed, clean up the flag\n            if (records.includes(me.navigateToAfterRefresh)) {\n                me.navigateToAfterRefresh = null;\n            }\n            // If being done by a keyboard gesture then look for a close target until we find an existing record, not\n            // scheduled for removal. Otherwise, push focus outside of the Scheduler.\n            // This condition will react not only on meaningful keyboard action - like pressing DELETE key on selected\n            // event - but also in case user started dragging and pressed CTRL (or any other key) in process.\n            // https://github.com/bryntum/support/issues/3479\n            if (GlobalEvents.lastInteractionType === 'key') {\n                // Look for a close target until we find an existing record, not scheduled for removal. Provided\n                // assignment position in store is arbitrary as well as order of removed records, it does not make much\n                // sense trying to apply any specific order to them. Existing assignment next to any removed one is as\n                // good as any.\n                for (let i = 0, l = records.length; i < l && !moveTo; i++) {\n                    const assignment = records[i];\n\n                    if (assignment.resource && assignment.resource.isModel) {\n                        // Find next record\n                        let next = me.getNext(assignment);\n\n                        // If next record is not found or also removed, look for previous. This should not become a\n                        // performance bottleneck because we only can get to this code if project is committing, if\n                        // records are removed on a dragdrop listener and user pressed any key after mousedown, or if\n                        // user is operating with a keyboard and pressed [DELETE] to remove multiple records.\n                        if (!next || records.includes(next)) {\n                            next = me.getPrevious(assignment);\n                        }\n\n                        if (next && !records.includes(next)) {\n                            moveTo = next;\n                        }\n                    }\n                }\n            }\n\n            // Move focus away from the element which will soon have no backing data.\n            if (moveTo) {\n                // Although removing records from assignment store will trigger project commit and consequently\n                // `refresh` event on the project which will use this record to navigate to, some tests expect\n                // immediate navigation\n                me.navigateTo(moveTo);\n                me.navigateToAfterRefresh = moveTo;\n            }\n            // Focus must exit the Scheduler's subgrid, otherwise, if a navigation\n            // key gesture is delivered before the outgoing event's element has faded\n            // out and been removed, navigation will be attempted from a deleted\n            // event. Animated hiding is problematic.\n            //\n            // We cannot just revertFocus() because that might move focus back to an\n            // element in a floating EventEditor which is not yet faded out and\n            // been removed. Animated hiding is problematic.\n            //\n            // We cannot focus scheduler.timeAxisColumn.element because the browser\n            // would scroll it in some way if we have horizontal overflow.\n            //\n            // The only thing we can know about to focus here is the Scheduler itself.\n            else {\n                DomHelper.focusWithoutScrolling(me.focusElement);\n            }\n        }\n    }\n\n    //endregion\n\n    //region TimeRangeStore & TimeRanges\n\n    /**\n     * Inline time ranges, will be loaded into an internally created store if {@link Scheduler.feature.TimeRanges}\n     * is enabled.\n     * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n     * @category Data\n     */\n\n    /**\n     * Get/set time ranges, applies to the backing project's TimeRangeStore.\n     * @member {Scheduler.model.TimeSpan[]} timeRanges\n     * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the time ranges store instance or config object for {@link Scheduler.feature.TimeRanges} feature.\n     * @member {Core.data.Store} timeRangeStore\n     * @accepts {Core.data.Store|StoreConfig}\n     * @category Data\n     */\n\n    /**\n     * The time ranges store instance for {@link Scheduler.feature.TimeRanges} feature.\n     * @config {Core.data.Store|StoreConfig} timeRangeStore\n     * @category Data\n     */\n\n    set timeRanges(timeRanges) {\n        this.project.timeRanges = timeRanges;\n    }\n\n    get timeRanges() {\n        return this.project.timeRanges;\n    }\n\n    //endregion\n\n    //region ResourceTimeRangeStore\n\n    /**\n     * Inline resource time ranges, will be loaded into an internally created store if\n     * {@link Scheduler.feature.ResourceTimeRanges} is enabled.\n     * @prp {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n     * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the resource time ranges store instance for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore\n     * @accepts {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}\n     * @category Data\n     */\n\n    /**\n     * Resource time ranges store instance or config object for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig} resourceTimeRangeStore\n     * @category Data\n     */\n\n    set resourceTimeRanges(resourceTimeRanges) {\n        this.project.resourceTimeRanges = resourceTimeRanges;\n    }\n\n    get resourceTimeRanges() {\n        return this.project.resourceTimeRanges;\n    }\n\n    //endregion\n\n    //region Other functions\n\n    onBeforeLoad({ params }) {\n        this.applyStartEndParameters(params);\n    }\n\n    /**\n     * Get events grouped by timeAxis ticks from resources array\n     * @category Data\n     * @param {Scheduler.model.ResourceModel[]} resources An array of resources to process. If not passed, all resources\n     * will be used.\n     * @param {Function} filterFn filter function to filter events if required. Optional.\n     * @private\n     */\n    getResourcesEventsPerTick(resources, filterFn) {\n        const\n            { timeAxis, resourceStore } = this,\n            eventsByTick                = [];\n\n        resources = resources || resourceStore.records;\n        resources.forEach(resource => {\n            resource.events.forEach(event => {\n                if (!timeAxis.isTimeSpanInAxis(event) || (filterFn && !filterFn.call(this, { resource, event }))) {\n                    return;\n                }\n                // getTickFromDate may return float if event starts/ends in a middle of a tick\n                let startTick = Math.floor(timeAxis.getTickFromDate(event.startDate)),\n                    endTick = Math.ceil(timeAxis.getTickFromDate(event.endDate));\n\n                // if startDate/endDate of the event is out of timeAxis' bounds, use first/last tick id instead\n                if (startTick == -1) {\n                    startTick = 0;\n                }\n\n                if (endTick === -1) {\n                    endTick = timeAxis.ticks.length;\n                }\n\n                do {\n                    if (!eventsByTick[startTick]) {\n                        eventsByTick[startTick] = [event];\n                    }\n                    else {\n                        eventsByTick[startTick].push(event);\n                    }\n                } while (++startTick < endTick);\n            });\n        });\n\n        return eventsByTick;\n    }\n\n    //endregion\n\n    //region WidgetClass\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerScroll\n */\n\nconst\n    defaultScrollOptions = {\n        block      : 'nearest',\n        edgeOffset : 20\n    },\n    unrenderedScrollOptions = {\n        highlight : false,\n        focus     : false\n    };\n\n/**\n * Functions for scrolling to events, dates etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerScroll extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerScroll';\n    }\n\n    //region Scroll to event\n\n    /**\n     * Scrolls an event record into the viewport.\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.\n     *\n     * This function is not applicable for events with multiple assignments, please use #scrollResourceEventIntoView instead.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord the event record to scroll into view\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @async\n     * @category Scrolling\n     */\n    async scrollEventIntoView(eventRecord, options = defaultScrollOptions) {\n        const\n            me        = this,\n            resources = eventRecord.resources || [eventRecord];\n\n        if (resources.length > 1) {\n            throw new Error('scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.');\n        }\n\n        if (!resources.length) {\n            console.warn('You have asked to scroll to an event which is not assigned to a resource');\n        }\n\n        await me.scrollResourceEventIntoView(resources[0], eventRecord, options);\n    }\n\n    /**\n     * Scrolls an assignment record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord A resource record an event record is assigned to\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollAssignmentIntoView(assignmentRecord, ...args) {\n        return this.scrollResourceEventIntoView(assignmentRecord.resource, assignmentRecord.event, ...args);\n    }\n\n    /**\n     * Scrolls a resource event record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {Scheduler.model.EventModel} eventRecord An event record to scroll into view\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     * @async\n     */\n    async scrollResourceEventIntoView(resourceRecord, eventRecord, options = defaultScrollOptions) {\n        const\n            me             = this,\n            eventStart     = eventRecord.startDate,\n            eventEnd       = eventRecord.endDate,\n            eventIsOutside = eventRecord.isScheduled && eventStart < me.timeAxis.startDate | ((eventEnd > me.timeAxis.endDate) << 1);\n\n        // <remove-on-release>\n        // TODO: Remove in 6.0\n        // </remove-on-release>\n        if (arguments.length > 3) {\n            options = arguments[3];\n        }\n\n        let el;\n\n        if (options.edgeOffset == null) {\n            options.edgeOffset = 20;\n        }\n\n        // Make sure event is within TimeAxis time span unless extendTimeAxis passed as false.\n        // The EventEdit feature passes false because it must not mutate the TimeAxis.\n        // Bitwise flag:\n        //  1 === start is before TimeAxis start.\n        //  2 === end is after TimeAxis end.\n        if (eventIsOutside && options.extendTimeAxis !== false) {\n            const currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate;\n\n            // Event is too wide, expand the range to encompass it.\n            if (eventIsOutside === 3) {\n                me.setTimeSpan(\n                    new Date(eventStart.valueOf() - currentTimeSpanRange / 2),\n                    new Date(eventEnd.valueOf()  + currentTimeSpanRange / 2)\n                );\n            }\n            else if (me.infiniteScroll) {\n                const\n                    { visibleDateRange } = me,\n                    visibleMS = visibleDateRange.endMS - visibleDateRange.startMS,\n                    // If event starts before time axis, scroll to a date one full viewport after target date\n                    // (reverse for an event starting after time axis), to allow a scroll animation\n                    sign = eventIsOutside & 1 ? 1 : -1;\n\n                await me.setTimeSpan(\n                    new Date(eventStart.valueOf()  - currentTimeSpanRange / 2),\n                    new Date(eventStart.valueOf() + currentTimeSpanRange / 2),\n                    {\n                        visibleDate : new Date(eventEnd.valueOf() + (sign * visibleMS))\n                    }\n                );\n            }\n            // Event is partially or wholly outside but will fit.\n            // Move the TimeAxis to include it. That will maintain visual position.\n            else {\n                // Event starts before\n                if (eventIsOutside & 1) {\n                    me.setTimeSpan(\n                        new Date(eventStart),\n                        new Date(eventStart.valueOf() + currentTimeSpanRange)\n                    );\n                }\n                // Event ends after\n                else {\n                    me.setTimeSpan(\n                        new Date(eventEnd.valueOf() - currentTimeSpanRange),\n                        new Date(eventEnd)\n                    );\n                }\n            }\n        }\n\n        if (me.store.tree) {\n            // If we're a tree, ensure parents are expanded first\n            await me.expandTo?.(resourceRecord);\n        }\n\n        // Handle nested events too\n        if (eventRecord.parent && !eventRecord.parent.isRoot) {\n            await this.scrollEventIntoView(eventRecord.parent);\n        }\n\n        // Establishing element to scroll to\n        el = me.getElementFromEventRecord(eventRecord, resourceRecord);\n\n        if (el) {\n            // It's usually the event wrapper that holds focus\n            if (!DomHelper.isFocusable(el)) {\n                el = el.parentNode;\n            }\n\n            const scroller = me.timeAxisSubGrid.scrollable;\n\n            // Force horizontalscroll to be triggered directly on scroll instead of on next frame, to have events\n            // already drawn when promise resolves\n            me.timeAxisSubGrid.forceScrollUpdate = true;\n            // Scroll into view with animation and highlighting if needed.\n            await scroller.scrollIntoView(el, options);\n        }\n        // If event is wholly outside of the range and we are not allowed to extend\n        // the range, then we cannot perform the operation.\n        else if (eventIsOutside === 3 && options.extendTimeAxis === false) {\n            console.warn('You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled');\n        }\n        else if (!eventRecord.isOccurrence && !me.eventStore.isAvailable(eventRecord)) {\n            console.warn('You have asked to scroll to an event which is not available');\n        }\n        else if (eventRecord.isScheduled) {\n            // Event scheduled but not rendered, scroll to calculated location\n            await me.scrollUnrenderedEventIntoView(resourceRecord, eventRecord, options);\n        }\n        else {\n            // Event not scheduled, just scroll resource row into view\n            await me.scrollResourceIntoView(resourceRecord, options);\n        }\n    }\n\n    /**\n     * Scrolls an unrendered event into view. Internal function used from #scrollResourceEventIntoView.\n     * @private\n     * @category Scrolling\n     */\n    scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions) {\n        // We must only resolve when the event's element has been painted\n        // *and* the scroll has fully completed.\n        return new Promise(resolve => {\n            const\n                me               = this,\n                // Knock out highlight and focus options. They must be applied after the scroll\n                // has fully completed and we have an element. Use a default edgeOffset of 20.\n                modifiedOptions  = Object.assign({ edgeOffset : 20 }, options, unrenderedScrollOptions),\n                scroller         = me.timeAxisSubGrid.scrollable,\n                box              = me.getResourceEventBox(eventRec, resourceRec),\n                scrollerViewport = scroller.viewport;\n\n            // Event may fall on a time not included by workingTime settings\n            if (!scrollerViewport || !box) {\n                resolve();\n                return;\n            }\n\n            // In case of subPixel position, scroll the whole pixel into view\n            box.x = Math.ceil(box.x);\n            box.y = Math.ceil(box.y);\n\n            if (me.rtl) {\n                // RTL scrolls in negative direction but coordinates are still LTR\n                box.translate(-me.timeAxisViewModel.totalSize + scrollerViewport.width, 0);\n            }\n\n            // Note use of scroller.scrollLeft here. We need the natural DOM scrollLeft value\n            // not the +ve X position along the scrolling axis.\n            box.translate(scrollerViewport.x - scroller.scrollLeft, scrollerViewport.y - scroller.y);\n\n            const\n                // delta         = scroller.getDeltaTo(box, modifiedOptions)[me.isHorizontal ? 'xDelta' : 'yDelta'],\n                onEventRender = async({ eventRecord, element, targetElement }) => {\n                    if (eventRecord === eventRec) {\n                        // Vertical's renderEvent is different to horizontal's\n                        const el = element || targetElement;\n\n                        detacher();\n\n                        // Don't resolve until the scroll has fully completed.\n                        await initialScrollPromise;\n\n                        options.highlight && DomHelper.highlight(el);\n                        options.focus && el.focus();\n\n                        resolve();\n                    }\n                },\n                // On either paint or repaint of the event, resolve the scroll promise and detach the listeners.\n                detacher = me.ion({\n                    renderEvent : onEventRender\n                }),\n                initialScrollPromise = scroller.scrollIntoView(box, modifiedOptions);\n        });\n    }\n\n    /**\n     * Scrolls the specified resource into view, works for both horizontal and vertical modes.\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollResourceIntoView(resourceRecord, options = defaultScrollOptions) {\n        if (this.isVertical) {\n            return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);\n        }\n        else {\n            return this.scrollRowIntoView(resourceRecord, options);\n        }\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerRegions\n */\n\n/**\n * Functions to get regions (bounding boxes) for scheduler, events etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerRegions extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerRegions';\n    }\n\n    //region Orientation dependent regions\n\n    /**\n     * Gets the region represented by the schedule and optionally only for a single resource. The view will ask the\n     * scheduler for the resource availability by calling getResourceAvailability. By overriding that method you can\n     * constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} resourceRecord (optional) The resource record\n     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints) {\n        return this.currentOrientation.getScheduleRegion(...arguments);\n    }\n\n    /**\n     * Gets the region, relative to the timeline view element, representing the passed resource and optionally just for a certain date interval.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} A Rectangle which encapsulates the resource time span\n     */\n    getResourceRegion(resourceRecord, startDate, endDate) {\n        return this.currentOrientation.getRowRegion(...arguments);\n    }\n\n    //endregion\n\n    //region ResourceEventBox\n\n    getAssignmentEventBox(assignmentRecord, includesOutside) {\n        return this.getResourceEventBox(assignmentRecord.event, assignmentRecord.resource, includesOutside);\n    }\n\n    /**\n     * Get the region for a specified resources specified event.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Boolean} includeOutside Specify true to get boxes for events outside of the rendered zone in both\n     *   dimensions. This option is used when calculating dependency lines, and we need to include routes from events\n     *   which may be outside the rendered zone.\n     * @returns {Core.helper.util.Rectangle}\n     */\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside = false, roughly = false) {\n        return this.currentOrientation.getResourceEventBox(...arguments);\n    }\n\n    //endregion\n\n    //region Item box\n\n    /**\n     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item\n     * then the method returns all of them. Box coordinates are in view coordinate system.\n     *\n     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)\n     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible\n     * top row or below currently visible bottom row) will be calculated approximately.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Object|Object[]}\n     * @returns {Boolean} return.isPainted Whether the box was calculated for the rendered scheduled record or was\n     *    approximately calculated for the scheduled record outside of the current vertical view area.\n     * @returns {Number} return.top\n     * @returns {Number} return.bottom\n     * @returns {Number} return.start\n     * @returns {Number} return.end\n     * @returns {'before'|'after'} return.relPos if the item is not rendered then provides a view relative\n     * position one of 'before', 'after'\n     * @internal\n     */\n    getItemBox(event, includeOutside = false) {\n        return event.resources.map(resource => this.getResourceEventBox(event, resource, includeOutside));\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerState\n */\n\nconst copyProperties = [\n    'eventLayout',\n    'mode',\n    'eventColor',\n    'eventStyle',\n    'tickSize',\n    'fillTicks'\n];\n\n/**\n * A Mixin for Scheduler that handles state. It serializes the following scheduler properties, in addition to what\n * is already stored by its superclass {@link Grid/view/mixin/GridState}:\n *\n * * eventLayout\n * * barMargin\n * * mode\n * * tickSize\n * * zoomLevel\n * * eventColor\n * * eventStyle\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class SchedulerState extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerState';\n    }\n\n    /**\n     * Gets or sets scheduler's state. Check out {@link Scheduler.view.mixin.SchedulerState} mixin\n     * and {@link Grid.view.mixin.GridState} for more details.\n     * @member {Object} state\n     * @property {String} state.eventLayout\n     * @property {String} state.eventStyle\n     * @property {String} state.eventColor\n     * @property {Number} state.barMargin\n     * @property {Number} state.tickSize\n     * @property {Boolean} state.fillTicks\n     * @property {Number} state.zoomLevel\n     * @property {'horizontal'|'vertical'} state.mode\n     * @property {Object[]} state.columns\n     * @property {Boolean} state.readOnly\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.selectedCell\n     * @property {String} state.style\n     * @property {Object} state.subGrids\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @category State\n     */\n\n    /**\n     * Get scheduler's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        return ObjectHelper.copyProperties(super.getState(), this, copyProperties);\n    }\n\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        this.suspendRefresh();\n\n        let propsToCopy = copyProperties.slice();\n\n        if (state?.eventLayout === 'layoutFn') {\n            delete state.eventLayout;\n            propsToCopy.splice(propsToCopy.indexOf('eventLayout'), 1);\n        }\n\n        // Zoom level will set tick size, no need to update model additionally\n        if (state?.zoomLevelOptions?.width) {\n            propsToCopy = propsToCopy.filter(p => p !== 'tickSize');\n        }\n\n        ObjectHelper.copyProperties(this, state, propsToCopy);\n\n        super.applyState(state);\n\n        this.resumeRefresh(true);\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport Base from '../../../Core/Base.js';\nimport Model from '../../../Core/data/Model.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/view/orientation/HorizontalRendering\n */\n\n/**\n * @typedef HorizontalRenderData\n * @property {Scheduler.model.EventModel} eventRecord\n * @property {Date} start Span start\n * @property {Date} end Span end\n * @property {String} rowId Id of the resource row\n * @property {DomConfig[]} children Child elements\n * @property {Number} startMS Wrap element start in milliseconds\n * @property {Number} endMS Span Wrap element end in milliseconds\n * @property {Number} durationMS Wrap duration in milliseconds (not just a difference between start and end)\n * @property {Number} innerStartMS Actual event start in milliseconds\n * @property {Number} innerEndMS Actual event end in milliseconds\n * @property {Number} innerDurationMS Actual event duration in milliseconds\n * @property {Boolean} startsOutsideView True if span starts before time axis start\n * @property {Boolean} endsOutsideView True if span ends after time axis end\n * @property {Number} left Absolute left coordinate of the wrap element\n * @property {Number} width\n * @property {Number} top Absolute top coordinate of the wrap element (can be changed by layout)\n * @property {Number} height\n * @property {Boolean} clippedStart True if start is clipped\n * @property {Boolean} clippedEnd True if end is clipped\n * @private\n */\n\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    MAX_WIDTH           = 9999999,\n    heightEventSorter   = ({ startDateMS : lhs }, { startDateMS : rhs }) => lhs - rhs,\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    };\n\nfunction getStartEnd(scheduler, eventRecord, useEnd, fieldName, useEventBuffer) {\n    // Must use Model.get in order to get latest values in case we are inside a batch.\n    // EventResize changes the endDate using batching to enable a tentative change\n    // via the batchedUpdate event which is triggered when changing a field in a batch.\n    // Fall back to accessor if propagation has not populated date fields.\n    const\n        { timeAxis }     = scheduler,\n        date             = eventRecord.isBatchUpdating && !useEventBuffer ? eventRecord.get(fieldName) : eventRecord[fieldName],\n        hasBatchedChange = eventRecord.hasBatchedChange?.(fieldName),\n        // fillTicks shouldn't be used during resizing for changing date for smooth animation.\n        // correct date will be applied after resize, when `isResizing` will be falsy\n        useTickDates     = scheduler.fillTicks && (!eventRecord.meta?.isResizing || !hasBatchedChange);\n\n    if (useTickDates) {\n        let tick = timeAxis.getTickFromDate(date);\n\n        if (tick >= 0) {\n            // If date matches a tick start/end, use the earlier tick\n            if (useEnd && tick === Math.round(tick) && tick > 0) {\n                tick--;\n            }\n\n            const\n                tickIndex  = Math.floor(tick),\n                tickRecord = timeAxis.getAt(tickIndex);\n\n            return tickRecord[fieldName].getTime();\n        }\n    }\n\n    return date?.getTime();\n}\n\n/**\n * Handles event rendering in Schedulers horizontal mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class HorizontalRendering extends Base.mixin(AttachToProjectMixin) {\n    //region Config & Init\n\n    static $name = 'HorizontalRendering';\n\n    static get configurable() {\n        return {\n            // It's needed to adjust visible date range in Export. Set to 100 to render additional 100px\n            // worth of ticks which helps to scroll faster during export and fixes\n            // issue when scrollToDate cannot reach panel end date on exceptionally narrow view\n            scrollBuffer : 0,\n\n            /**\n             * Amount of pixels to extend the current visible range at both ends with when deciding which events to\n             * render. Only applies when using labels or for milestones\n             * @config {Number}\n             * @default\n             */\n            bufferSize : 150,\n\n            verticalBufferSize : 150\n        };\n    }\n\n    static get properties() {\n        return {\n            // Map with event DOM configs, keyed by resource id\n            resourceMap            : new Map(),\n            // Map with visible events DOM configs, keyed by row instance\n            rowMap                 : new Map(),\n            eventConfigs           : [],\n            // Flag to avoid transitioning on first refresh\n            isFirstRefresh         : true,\n            toDrawOnProjectRefresh : new Set(),\n            toDrawOnDataReady      : new Set()\n        };\n    }\n\n    construct(scheduler) {\n        const me = this;\n\n        me.client = me.scheduler = scheduler;\n\n        me.eventSorter = me.eventSorter.bind(scheduler);\n\n        // Catch scroll before renderers are called\n        scheduler.scrollable.ion({\n            scroll  : 'onEarlyScroll',\n            prio    : 1,\n            thisObj : me\n        });\n\n        scheduler.rowManager.ion({\n            name            : 'rowManager',\n            renderDone      : 'onRenderDone',\n            removeRows      : 'onRemoveRows',\n            translateRow    : 'onTranslateRow',\n            offsetRows      : 'onOffsetRows',\n            beforeRowHeight : 'onBeforeRowHeightChange',\n            thisObj         : me\n        });\n\n        super.construct({});\n    }\n\n    init() {}\n\n    updateVerticalBufferSize() {\n        const { rowManager } = this.scheduler;\n\n        if (this.scheduler.isPainted) {\n            // Refresh rows when vertical buffer size changes to trigger event repaint. Required for the export feature.\n            rowManager.renderRows(rowManager.rows);\n        }\n    }\n\n    //endregion\n\n    //region Region, dates & coordinates\n\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { scheduler } = this;\n\n        let coord = xy[0];\n\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n\n        coord = scheduler.getRtlX(coord);\n\n        return scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n\n    translateToScheduleCoordinate(x) {\n        const\n            { scheduler } = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n\n        let result = x - scheduler.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n        // The vertical counterpart uses the _bodyRectangle which was created with that adjustment.\n\n        if (scheduler.rtl) {\n            result += scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result += scheduler.scrollLeft;\n        }\n\n        return result;\n    }\n\n    translateToPageCoordinate(x) {\n        const\n            { scheduler } = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n\n        let result = x + scheduler.timeAxisSubGridElement.getBoundingClientRect().left;\n\n        if (scheduler.rtl) {\n            result -= scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result -= scheduler.scrollLeft;\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the region, relative to the page, represented by the schedule and optionally only for a single resource.\n     * This method will call getDateConstraints to allow for additional resource/event based constraints. By overriding\n     * that method you can constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] (optional) The row record\n     * @param {Scheduler.model.EventModel} [eventRecord] (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints, stretch = false) {\n        const\n            me                                   = this,\n            { scheduler }                        = me,\n            { timeAxisSubGridElement, timeAxis } = scheduler,\n            resourceMargin                       = (!stretch || resourceRecord) && scheduler.getResourceMargin(resourceRecord) || 0;\n\n        let region;\n\n        if (resourceRecord) {\n            const eventElement = eventRecord && scheduler.getElementsFromEventRecord(eventRecord, resourceRecord)[0];\n\n            region = Rectangle.from(scheduler.getRowById(resourceRecord.id).getElement('normal'), timeAxisSubGridElement);\n\n            if (eventElement) {\n                const eventRegion = Rectangle.from(eventElement, timeAxisSubGridElement);\n\n                region.y = eventRegion.y;\n                region.bottom = eventRegion.bottom;\n            }\n            else {\n                region.y = region.y + resourceMargin;\n                region.bottom = region.bottom - resourceMargin;\n            }\n        }\n        else {\n            // <remove-on-release>\n            // TODO: This is what the function that was removed here did.\n            // </remove-on-release>\n            // The coordinate space needs to be sorted out here!\n            region = Rectangle.from(timeAxisSubGridElement).moveTo(null, 0);\n            region.width = timeAxisSubGridElement.scrollWidth;\n\n            region.y = region.y + resourceMargin;\n            region.bottom = region.bottom - resourceMargin;\n        }\n\n        const\n            taStart         = timeAxis.startDate,\n            taEnd           = timeAxis.endDate;\n\n        dateConstraints = (dateConstraints?.start && dateConstraints) || scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n            start : taStart,\n            end   : taEnd\n        };\n\n        let startX          = scheduler.getCoordinateFromDate(dateConstraints.start ? DateHelper.max(taStart, dateConstraints.start) : taStart),\n            endX            = scheduler.getCoordinateFromDate(dateConstraints.end ? DateHelper.min(taEnd, dateConstraints.end) : taEnd);\n\n        if (!local) {\n            startX = me.translateToPageCoordinate(startX);\n            endX = me.translateToPageCoordinate(endX);\n        }\n\n        region.left = Math.min(startX, endX);\n        region.right = Math.max(startX, endX);\n\n        return region;\n    }\n\n    /**\n     * Gets the Region, relative to the timeline view element, representing the passed row and optionally just for a\n     * certain date interval.\n     * @param {Core.data.Model} rowRecord The row record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} The Rectangle which encapsulates the row\n     */\n    getRowRegion(rowRecord, startDate, endDate) {\n        const\n            { scheduler } = this,\n            { timeAxis }  = scheduler,\n            row           = scheduler.getRowById(rowRecord.id);\n\n        // might not be rendered\n        if (!row) {\n            return null;\n        }\n\n        const\n            taStart    = timeAxis.startDate,\n            taEnd      = timeAxis.endDate,\n            start      = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end        = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startX     = scheduler.getCoordinateFromDate(start),\n            endX       = scheduler.getCoordinateFromDate(end, true, true),\n            y          = row.top,\n            x          = Math.min(startX, endX),\n            bottom     = y + row.offsetHeight;\n\n        return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);\n    }\n\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside, roughly = false) {\n        const resourceData = this.resourceMap.get(resourceRecord.id);\n\n        let eventLayout  = null,\n            approx       = false;\n\n        if (resourceData) {\n            eventLayout = resourceData.eventsData.find(d => d.eventRecord === eventRecord);\n        }\n\n        // Outside of view, layout now if supposed to be included\n        if (!eventLayout) {\n            eventLayout = this.getTimeSpanRenderData(\n                eventRecord,\n                resourceRecord,\n                { viewport : true, timeAxis : includeOutside }\n            );\n\n            approx = true;\n        }\n\n        if (eventLayout) {\n            // Event layout is relative to row, need to make to absolute before returning\n            const\n                rowBox      = this.scheduler.rowManager.getRecordCoords(resourceRecord, true, roughly),\n                absoluteTop = eventLayout.top + rowBox.top,\n                box         = new Rectangle(eventLayout.left, absoluteTop, eventLayout.width, eventLayout.height);\n\n            // Flag informing other parts of the code that this box is approximated\n            box.layout = !approx;\n            box.rowTop = rowBox.top;\n            box.rowBottom = rowBox.bottom;\n\n            box.resourceId = resourceRecord.id;\n\n            return box;\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //region Element <-> Record mapping\n\n    resolveRowRecord(elementOrEvent) {\n        const\n            me             = this,\n            { scheduler }  = me,\n            element        = elementOrEvent.nodeType ? elementOrEvent : elementOrEvent.target,\n            // Fix for FF on Linux having text nodes as event.target\n            el             = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventNode      = el.closest(scheduler.eventSelector);\n\n        if (eventNode) {\n            return me.resourceStore.getById(eventNode.dataset.resourceId);\n        }\n\n        return scheduler.getRecordFromElement(el);\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        this.refreshAllWhenReady = true;\n\n        // Perform a full clear when replacing the project, to not leave any references to old project in DOM\n        if (!this.scheduler.isConfiguring) {\n            this.clearAll({ clearDom : true });\n        }\n\n        project?.ion({\n            name            : 'project',\n            refresh         : 'onProjectRefresh',\n            commitFinalized : 'onProjectCommitFinalized',\n            thisObj         : this\n        });\n    }\n\n    onProjectCommitFinalized() {\n        const { scheduler, toDrawOnDataReady, project } = this;\n\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.refreshSuspended) {\n                // If this is a timezone commit, we got here from a store dataset\n                // We need to do a full refresh\n                if (!toDrawOnDataReady.size && project.timeZone != null && project.ignoreRecordChanges) {\n                    project.resourceStore.forEach(r => toDrawOnDataReady.add(r.id));\n                }\n                if (toDrawOnDataReady.size) {\n                    this.clearResources(toDrawOnDataReady);\n                    this.refreshResources(toDrawOnDataReady);\n                }\n\n                toDrawOnDataReady.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refreshRows');\n        }\n    }\n\n    onProjectRefresh({ isCalculated, isInitialCommit }) {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.isConfiguring && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset or when delayed calculations are finished)\n                if (me.refreshAllWhenReady || (isInitialCommit && isCalculated)) {\n                    scheduler.calculateAllRowHeights(true);\n                    const { rowManager } = scheduler;\n\n                    // Rows rendered? Refresh\n                    if (rowManager.topRow) {\n                        me.clearAll();\n\n                        // Refresh only if it won't be refreshed elsewhere (SchedulerStore#onProjectRefresh())\n                        if (!scheduler.refreshAfterProjectRefresh) {\n                            // If refresh was suspended when replacing the dataset in a scrolled view we might end up with a\n                            // topRow outside of available range -> reset it. Call renderRows() to mimic what normally happens\n                            // when refresh is not suspended\n                            if (rowManager.topRow.dataIndex >= scheduler.store.count) {\n                                scheduler.renderRows(false);\n                            }\n                            else {\n                                // Don't transition first refresh / early render\n                                scheduler.refreshWithTransition(false, !me.isFirstRefresh && isCalculated && !isInitialCommit);\n                            }\n                        }\n\n                        me.isFirstRefresh = false;\n                    }\n                    // No rows yet, reinitialize (happens if initial project empty and then non empty project assigned)\n                    else {\n                        rowManager.reinitialize();\n                    }\n\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refreshResources(toDrawOnProjectRefresh);\n                }\n\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n\n    //endregion\n\n    //region AssignmentStore\n\n    attachToAssignmentStore(assignmentStore) {\n        this.refreshAllWhenReady = true;\n\n        super.attachToAssignmentStore(assignmentStore);\n\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onAssignmentStoreChange({ source, action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            resourceIds       = new Set(assignmentRecords.flatMap(assignmentRecord => ([\n                assignmentRecord.resourceId,\n                // Also include any linked resources (?. twice since resource might not be resolved and point to id)\n                ...assignmentRecord.resource?.$links?.map(link => link.id) ?? []\n            ])));\n\n        // Ignore assignment changes caused by removing resources, the remove will redraw things anyway\n        // Also ignore case when resource id is changed. In this case row will be refreshed by the grid\n        if (me.resourceStore.isRemoving || me.resourceStore.isChangingId) {\n            return;\n        }\n\n        switch (action) {\n            // These operations will invalidate the graph, need to draw later\n            case 'dataset': {\n                // Ignore dataset when using single assignment mode\n                if (!me.eventStore.usesSingleAssignment) {\n                    if (resourceIds.size) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearAll();\n                        scheduler.refreshWithTransition();\n                    }\n                }\n                return;\n            }\n\n            // <remove-on-release>\n            // TODO: Don't think updateMultiple below is covered by any test...\n            // </remove-on-release>\n\n            case 'add':\n            case 'remove':\n            case 'updateMultiple':\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n\n            case 'removeall':\n                me.refreshAllWhenReady = true;\n                return;\n\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([oldAssignment, newAssignment]) => {\n                    resourceIds.add(oldAssignment.resourceId);\n                    resourceIds.add(newAssignment.resourceId);\n                });\n                // And refresh them\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n\n            // These operations won't invalidate the graph, redraw now\n            case 'filter':\n                me.clearAll();\n                scheduler.calculateAllRowHeights(true);\n                scheduler.refreshWithTransition();\n                return;\n\n            case 'update': {\n                if ('eventId' in changes || 'resourceId' in changes || 'id' in changes) {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n\n                    // When chaining stores in single assignment mode, we might not be the project store\n                    if (source === scheduler.project.assignmentStore) {\n                        me.refreshResourcesOnDataReady(resourceIds);\n                    }\n                    // Refresh directly when we are not\n                    else {\n                        me.refreshResources(resourceIds);\n                    }\n                }\n                break;\n            }\n\n            case 'clearchanges': {\n                const { added, modified, removed } = changes;\n\n                // If modified records appear in the clearchanges action we need to refresh entire view\n                // because we have not enough information about previously assigned resource\n                if (modified.length) {\n                    scheduler.refreshWithTransition();\n                }\n                else {\n                    added.forEach(r => resourceIds.add(r.resourceId));\n                    removed.forEach(r => resourceIds.add(r.resourceId));\n\n                    me.refreshResourcesOnDataReady(resourceIds);\n                }\n            }\n        }\n    }\n\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.scheduler.refreshWithTransition();\n        }\n    }\n\n    //endregion\n\n    //region EventStore\n\n    attachToEventStore(eventStore) {\n        this.refreshAllWhenReady = true;\n\n        super.attachToEventStore(eventStore);\n\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            const { scheduler } = this;\n            if (scheduler.isEngineReady && scheduler.isPainted) {\n                this.clearAll();\n                scheduler.refreshWithTransition();\n            }\n        }\n    }\n\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, source }) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            isResourceTimeRange = source.isResourceTimeRangeStore,\n            resourceIds         = new Set();\n\n        if (!scheduler.isPainted) {\n            return;\n        }\n\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n\n            // When rendering a Gantt project, the project model also passes through here -> no `resources`\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n\n        if (isResourceTimeRange) {\n            switch (action) {\n                // - dataset cant pass through same path as events, which relies on project being invalidated. and\n                // resource time ranges does not pass through engine\n                // - removeall also needs special path, since no resources to redraw will be collected\n                case 'removeall':\n                case 'dataset':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n            }\n\n            me.refreshResources(resourceIds);\n        }\n        else {\n            switch (action) {\n                // No-ops\n                case 'batch': // Handled elsewhere, don't want it to clear again\n                case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n                case 'group':\n                case 'move':\n                    return;\n\n                case 'remove':\n                    // Remove is a no-op since assignment will also be removed\n                    return;\n\n                case 'clearchanges':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n\n                case 'dataset': {\n                    me.clearAll();\n                    // This is mainly for chained stores, where data is set from main store without project being\n                    // invalidated. Nothing to wait for, refresh now\n                    if (scheduler.isEngineReady) {\n                        scheduler.refreshWithTransition();\n                    }\n                    else {\n                        me.refreshAllWhenReady = true;\n                    }\n                    return;\n                }\n\n                case 'add':\n                case 'updateMultiple':\n                    // Just refresh below\n                    break;\n\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([, newEvent]) => {\n                        // Old cleared by changed assignment\n                        newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                    });\n                    break;\n\n                case 'removeall':\n                case 'filter':\n                    // Filter might be caused by add retriggering filters, in which case we need to refresh later\n                    if (!scheduler.isEngineReady) {\n                        me.refreshAllWhenReady = true;\n                        return;\n                    }\n\n                    // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                    // figure out which events was filtered out and only clear their resources.\n                    me.clearAll();\n                    scheduler.calculateAllRowHeights(true);\n                    scheduler.refreshWithTransition();\n                    return;\n\n                case 'update': {\n                    // Check if changes are graph related or not\n                    const allChrono = record.$entity\n                        ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                        : !Object.keys(changes).some(name => !chronoFields[name]);\n\n                    let dateChanges = 0;\n                    'startDate' in changes && dateChanges++;\n                    'endDate' in changes && dateChanges++;\n                    'duration' in changes && dateChanges++;\n\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n\n                    // If we have a set of resources to update, refresh them.\n                    // Always redraw non chrono changes (name etc) and chrono changes that can affect appearance\n                    if (\n                        resourceIds.size && (\n                            !allChrono ||\n                            // skip case when changed \"duration\" only (w/o start/end affected)\n                            dateChanges && !('duration' in changes && dateChanges === 1) ||\n                            'percentDone' in changes ||\n                            'inactive' in changes ||\n                            'constraintDate' in changes ||\n                            'constraintType' in changes ||\n                            'segments' in changes\n                        )\n                    ) {\n                        // if we are finalizing data loading let's delay the resources refresh till all the\n                        // propagation results get into stores\n                        if (me.project?.propagatingLoadChanges || me.project?.isWritingData) {\n                            me.refreshResourcesOnDataReady(resourceIds);\n                        }\n                        else {\n                            me.refreshResources(resourceIds);\n                        }\n                    }\n                    return;\n                }\n            }\n\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    attachToResourceStore(resourceStore) {\n\n        this.refreshAllWhenReady = true;\n\n        super.attachToResourceStore(resourceStore);\n\n        if (resourceStore) {\n            this.clearAll({ clearLayoutCache : true });\n\n            resourceStore.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreChange',\n                thisObj         : this\n            });\n        }\n    }\n\n    get resourceStore() {\n        return this.client.store;\n    }\n\n    onResourceStoreChange({ action, isExpand, records, changes }) {\n        const\n            me          = this,\n            // Update link + original when asked for link\n            resourceIds = records?.flatMap(r => r.isLinked ? [r.id, r.$originalId] : [r.id]);\n\n        if (!me.scheduler.isPainted) {\n            return;\n        }\n\n        switch (action) {\n            case 'add':\n                // #635 Events disappear when toggling other node\n                // If we are expanding project won't fire refresh event\n                if (!isExpand) {\n                    // Links won't cause calculations, refresh now\n                    if (records.every(r => r.isLinked)) {\n                        me.refreshResources(resourceIds);\n                    }\n                    // Otherwise refresh when project is ready\n                    else {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                }\n                return;\n            case 'update': {\n                // Ignore changes from project commit, if they affect events they will be redrawn anyway\n                // Also ignore explicit transformation of leaf <-> parent\n                if (!me.project.isBatchingChanges && !changes.isLeaf) {\n                    // Resource changes might affect events, refresh\n                    me.refreshResources(resourceIds);\n                }\n                return;\n            }\n            case 'filter':\n                // Bail out on filter action. Map was already updated on `refresh` event triggered before this `change`\n                // one. And extra records are removed from rowMap by `onRemoveRows`\n                return;\n            case 'removeall':\n                me.clearAll({ clearLayoutCache : true });\n                return;\n\n                // We must not clear all resources when whole dataset changes\n                // https://github.com/bryntum/support/issues/3292\n            case 'dataset':\n                return;\n        }\n\n        resourceIds && me.clearResources(resourceIds);\n    }\n\n    //endregion\n\n    //region RowManager\n\n    onTranslateRow({ row }) {\n        // Newly added rows are translated prior to having an id, rule those out since they will be rendered later\n        if (row.id != null) {\n            // Event layouts are stored relative to the resource, only need to rerender the row to have its absolute\n            // position updated to match new translation\n            this.refreshEventsForResource(row, false);\n        }\n    }\n\n    // RowManager error correction, cached layouts will no longer match.\n    // Redraw to have events correctly positioned for dependency feature to draw to their elements\n    onOffsetRows() {\n        this.clearAll();\n        this.doUpdateTimeView();\n    }\n\n    // Used to pre-calculate row heights\n    calculateRowHeight(resourceRecord) {\n        const\n            { scheduler } = this,\n            rowHeight     = scheduler.getResourceHeight(resourceRecord),\n            eventLayout   = scheduler.getEventLayout(resourceRecord),\n            layoutType    = eventLayout.type;\n\n        if (\n            layoutType === 'stack' &&\n            scheduler.isEngineReady &&\n            !resourceRecord.isSpecialRow &&\n            // Generated parents when TreeGrouping do not have assigned bucket\n            resourceRecord.assigned?.size > 1\n        ) {\n            const\n                {\n                    assignmentStore,\n                    eventStore,\n                    timeAxis\n                }               = scheduler,\n                {\n                    barMargin,\n                    resourceMargin,\n                    contentHeight\n                }               = scheduler.getResourceLayoutSettings(resourceRecord),\n                // When using an AssignmentStore we will get all events for the resource even if the EventStore is\n                // filtered\n                eventFilter     = (eventStore.isFiltered || assignmentStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a))),\n                events          = eventStore\n                    .getEvents({\n                        resourceRecord,\n                        includeOccurrences : scheduler.enableRecurringEvents,\n                        startDate          : timeAxis.startDate,\n                        endDate            : timeAxis.endDate,\n                        filter             : eventFilter\n                    })\n                    .sort(heightEventSorter)\n                    .map(eventRecord => {\n                        const\n                            // Must use Model.get in order to get latest values in case we are inside a batch.\n                            // EventResize changes the endDate using batching to enable a tentative change\n                            // via the batchedUpdate event which is triggered when changing a field in a batch.\n                            // Fall back to accessor if propagation has not populated date fields.\n                            startDate = eventRecord.isBatchUpdating ? eventRecord.get('startDate') : eventRecord.startDate,\n                            endDate   = eventRecord.isBatchUpdating ? eventRecord.get('endDate') : eventRecord.endDate || startDate;\n\n                        return {\n                            eventRecord,\n                            resourceRecord,\n                            startMS : startDate.getTime(),\n                            endMS   : endDate.getTime()\n                        };\n                    }),\n                layoutHandler = scheduler.getEventLayoutHandler(eventLayout),\n                nbrOfBandsRequired = layoutHandler.layoutEventsInBands(events, resourceRecord, true);\n\n            if (layoutHandler.type === 'layoutFn') {\n                return nbrOfBandsRequired;\n            }\n\n            return (nbrOfBandsRequired * contentHeight) + ((nbrOfBandsRequired - 1) * barMargin) + resourceMargin * 2;\n        }\n\n        return rowHeight;\n    }\n\n    //endregion\n\n    //region TimeAxis\n\n    doUpdateTimeView() {\n        const { scrollable } = this.scheduler.timeAxisSubGrid;\n\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX i always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x);\n    }\n\n    onTimeAxisViewModelUpdate() {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        me.clearAll();\n\n        // If refresh is suspended, update timeView as soon as refresh gets unsuspended\n        if (scheduler.refreshSuspended) {\n            me.detachListeners('renderingSuspend');\n\n            scheduler.ion({\n                name : 'renderingSuspend',\n                resumeRefresh({ trigger }) {\n                    // This code will try to refresh rows, but resumeRefresh event doesn't guarantee rowManager rows are\n                    // in actual state. e.g. if resources were removed during a suspended refresh rowManager won't get a\n                    // chance to update them until `refresh` event from the project. We can safely update the view only\n                    // if engine in ready (not committing), otherwise we leave refresh a liability of normal project refresh\n                    // logic. Covered by SchedulerRendering.t.js\n                    // https://github.com/bryntum/support/issues/1462\n                    if (scheduler.isEngineReady && trigger) {\n                        me.doUpdateTimeView();\n                    }\n                },\n                thisObj : me,\n                once    : true\n            });\n        }\n\n        // Call update anyway. If refresh is suspended this call will only update visible date range and will not redraw rows\n        me.doUpdateTimeView();\n    }\n\n    //endregion\n\n    //region Dependency connectors\n\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'start';\n    }\n\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'end';\n    }\n\n    //endregion\n\n    //region Scheduler hooks\n\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n        }\n    }\n\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n\n    // Called when viewport size changes\n    onViewportResize(width, height, oldWidth, oldHeight) {\n        // We don't draw events for all rendered rows, \"refresh\" when height changes to make sure events in previously\n        // invisible rows gets displayed\n        if (height > oldHeight) {\n            this.onRenderDone();\n        }\n    }\n\n    // Called from EventDrag\n    onDragAbort({ context, dragData }) {\n        // Aborted a drag in a scrolled scheduler, with origin now out of view. Element is no longer needed\n        if (this.resourceStore.indexOf(dragData.record.resource) < this.scheduler.topRow.dataIndex) {\n            context.element.remove();\n        }\n    }\n\n    // Called from EventSelection\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {\n        const\n            element      = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper),\n            // <remove-on-release>\n            // TODO: Should be assignmentRecord.resourceId, but breaks engine. Hoping https://github.com/bryntum/bryntum-suite/pull/1252 will fix it\n            // </remove-on-release>\n            resourceData = this.resourceMap.get(assignmentRecord.isModel ? assignmentRecord.get('resourceId') : assignmentRecord.resourceId),\n            eventData    = resourceData?.eventsData.find(d => d.eventId === assignmentRecord.eventId);\n\n        // Update cached config\n        if (eventData) {\n            eventData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n        }\n\n        // Live update element\n        if (element) {\n            // Update element\n            element.classList[add ? 'add' : 'remove'](cls);\n            // And its DOM config\n            element.lastDomConfig.className[cls] = add;\n        }\n    }\n\n    // React to rows being removed, refreshes view without any relayouting needed since layout is cached relative to row\n    onRemoveRows({ rows }) {\n        rows.forEach(row => this.rowMap.delete(row));\n        this.onRenderDone();\n    }\n\n    // Reset renderer flag before any renderers are called\n    onEarlyScroll() {\n        this.rendererCalled = false;\n    }\n\n    // If vertical scroll did not cause a renderer to be called we still want to update since we only draw events in\n    // view, \"independent\" from their rows\n    updateFromVerticalScroll() {\n        this.fromScroll = true;\n        if (!this.rendererCalled) {\n            this.onRenderDone();\n        }\n    }\n\n    // Update header range on horizontal scroll. No need to draw any tasks, Gantt only cares about vertical scroll\n    updateFromHorizontalScroll(scrollX) {\n        const\n            me            = this,\n            {\n                scheduler,\n                // scrollBuffer is an export only thing\n                scrollBuffer\n            } = me,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = scheduler,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = scheduler.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = scheduler.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd ? timeAxis.endDate : (scheduler.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n\n        if (startDate && !scheduler._viewPresetChanging) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords  = rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n\n            // Update timeaxis header making it display the new dates\n            const range = scheduler.timeView.range = { startDate, endDate };\n\n            scheduler.onVisibleDateRangeChange(range);\n\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!scheduler.refreshSuspended && scheduler.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (scheduler.rowManager.rows[0].id === null) {\n                    return;\n                }\n\n                me.fromScroll = true;\n                scheduler.rowManager.rows.forEach(row => me.refreshEventsForResource(row, false, false));\n\n                me.onRenderDone();\n            }\n        }\n    }\n\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.refreshResources([resourceRecord.id]);\n    }\n\n    onBeforeRowHeightChange() {\n        // Row height is cached per resource, all have to be re-laid out\n        this.clearAll();\n    }\n\n    //endregion\n\n    //region Refresh resources\n\n    refreshResourcesOnDataReady(resourceIds) {\n        resourceIds.forEach(id => this.toDrawOnDataReady.add(id));\n    }\n\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n\n    /**\n     * Clears and redraws resources directly. Respects schedulers refresh suspension\n     * @param {Number[]|String[]} ids Resource ids\n     * @param {Boolean} [transition] Use transition or not\n     * @private\n     */\n    refreshResources(ids, transition = true) {\n        const\n            me            = this,\n            { scheduler } = me,\n            rows          = [],\n            noRows        = [];\n\n        me.clearResources(ids);\n\n        if (!scheduler.refreshSuspended) {\n            ids.forEach(id => {\n                const row = scheduler.getRowById(id);\n                if (row) {\n                    rows.push(row);\n                }\n                else {\n                    noRows.push(row);\n                }\n            });\n\n            scheduler.runWithTransition(() => {\n                // Rendering rows populates row heights, but not all resources might have a row in view\n                scheduler.calculateRowHeights(noRows.map(id => this.resourceStore.getById(id)), true);\n\n                // Render those that do\n                scheduler.rowManager.renderRows(rows);\n            }, transition);\n        }\n    }\n\n    //endregion\n\n    //region Stack & pack\n\n    layoutEventVerticallyStack(bandIndex, eventRecord, resourceRecord) {\n        const { barMargin, resourceMargin, contentHeight } = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent);\n\n        return bandIndex === 0\n            ? resourceMargin\n            : resourceMargin + bandIndex * contentHeight + bandIndex * barMargin;\n    }\n\n    layoutEventVerticallyPack(topFraction, heightFraction, eventRecord, resourceRecord) {\n        const\n            {\n                barMargin,\n                resourceMargin,\n                contentHeight\n            }               = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent),\n            count           = 1 / heightFraction,\n            bandIndex       = topFraction * count, // \"y\" within row\n            height          = (contentHeight - ((count - 1) * barMargin)) * heightFraction,\n            top             = resourceMargin + bandIndex * height + bandIndex * barMargin;\n\n        return {\n            top, height\n        };\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord, resourceRecord = eventRecord.resource) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(eventRecord, resourceRecord, { timeAxis : true, viewport : true });\n\n        renderData.absoluteTop = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, resourceRecord, true).top;\n\n        const\n            domConfig = this.renderEvent(renderData),\n            { dataset } = domConfig;\n\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent = this.scheduler.foregroundCanvas;\n\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n\n        const result = DomHelper.createElement(domConfig);\n\n        result.innerElement = result.firstChild;\n\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n\n        return result;\n    }\n\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    // Fn can be called with layout date or event records (from EventNavigation)\n    eventSorter(a, b) {\n        if (this.overlappingEventSorter) {\n            return this.overlappingEventSorter(a.eventRecord || a, b.eventRecord || b);\n        }\n\n        const\n            // <remove-on-release>\n            // TODO: Rename startMS -> startDateMS to not have to have isModel check here (and to be consistent)\n            // </remove-on-release>\n            startA    = a.isModel ? a.startDateMS : a.dataStartMS || a.startMS, // dataXX are used if configured with fillTicks\n            endA      = a.isModel ? a.endDateMS : a.dataEndMS || a.endMS,\n            startB    = b.isModel ? b.startDateMS : b.dataStartMS || b.startMS,\n            endB      = b.isModel ? b.endDateMS :  b.dataEndMS || b.endMS,\n            nameA     = a.isModel ? a.name : a.eventRecord.name,\n            nameB     = b.isModel ? b.name : b.eventRecord.name;\n\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n\n    /**\n     * Converts a start/endDate into a MS value used when rendering the event. If scheduler is configured with\n     * `fillTicks: true` the value returned will be snapped to tick start/end.\n     * @private\n     * @param {Scheduler.model.TimeSpan} eventRecord\n     * @param {String} startDateField\n     * @param {String} endDateField\n     * @param {Boolean} useEventBuffer\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Object} Object of format { startMS, endMS, durationMS }\n     */\n    calculateMS(eventRecord, startDateField, endDateField, useEventBuffer, resourceRecord) {\n        const\n            me                    = this,\n            { scheduler }         = me,\n            { timeAxisViewModel } = scheduler;\n\n        let startMS    = getStartEnd(scheduler, eventRecord, false, startDateField, useEventBuffer),\n            endMS      = getStartEnd(scheduler, eventRecord, true, endDateField, useEventBuffer),\n            durationMS = endMS - startMS;\n\n        if (scheduler.milestoneLayoutMode !== 'default' && durationMS === 0) {\n            const\n                pxPerMinute = timeAxisViewModel.getSingleUnitInPixels('minute'),\n                lengthInPx  = scheduler.getMilestoneLabelWidth(eventRecord, resourceRecord),\n                duration    = lengthInPx * (1 / pxPerMinute);\n\n            durationMS = duration * 60 * 1000;\n\n            if (scheduler.milestoneTextPosition === 'always-outside') {\n                // Milestone is offset half a diamond to the left (compensated in CSS with padding) for the layout pass,\n                // to take diamond corner into account\n                const\n                    diamondSize = scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent).contentHeight,\n                    diamondMS   = diamondSize * (1 / pxPerMinute) * 60 * 1000;\n                startMS -= diamondMS / 2;\n                endMS = startMS + durationMS;\n            }\n            else {\n                switch (scheduler.milestoneAlign) {\n                    case 'start':\n                    case 'left':\n                        endMS = startMS + durationMS;\n                        break;\n                    case 'end':\n                    case 'right':\n                        endMS = startMS;\n                        startMS = endMS - durationMS;\n                        break;\n                    default: // using center as default\n                        endMS = startMS + durationMS / 2;\n                        startMS = endMS - durationMS;\n                        break;\n                }\n            }\n        }\n\n        return {\n            startMS,\n            endMS,\n            durationMS\n        };\n    }\n\n    /**\n     * Returns event render data except actual position information.\n     * @param timeSpan\n     * @param rowRecord\n     * @returns {HorizontalRenderData}\n     * @private\n     */\n    setupRenderData(timeSpan, rowRecord) {\n        const\n            me                             = this,\n            { scheduler }                  = me,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }                              = scheduler,\n            {\n                preamble,\n                postamble\n            }                              = timeSpan,\n            useEventBuffer                 = me.isProHorizontalRendering && scheduler.features.eventBuffer?.enabled &&\n                (preamble || postamble) && !timeSpan.isMilestone,\n            pxPerMinute                    = timeAxisViewModel.getSingleUnitInPixels('minute'),\n            { isBatchUpdating }            = timeSpan,\n            startDateField                 = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField                   = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            // Use endDate accessor if duration has not been propagated to create endDate\n            timespanStart                  = isBatchUpdating && !useEventBuffer ? timeSpan.get(startDateField) : timeSpan[startDateField],\n            // Allow timespans to be rendered even when they are missing an end date\n            timespanEnd                    = isBatchUpdating && !useEventBuffer ? timeSpan.get(endDateField) : timeSpan[endDateField] || timespanStart,\n            viewStartMS                    = timeAxis.startMS,\n            viewEndMS                      = timeAxis.endMS,\n            { startMS, endMS, durationMS } = me.calculateMS(timeSpan, startDateField, endDateField, useEventBuffer, rowRecord),\n            // These flags have two components because includeOutsideViewport\n            // means that we can be calculating data for events either side of\n            // the TimeAxis.\n            // The start is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the start is before the TimeAxis\n            // 2 set means the start is after the TimeAxis\n            // Either way, a truthy value means that the start is outside of the TimeAxis.\n            startsOutsideView              = startMS < viewStartMS | ((startMS > viewEndMS) << 1),\n            // The end is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the end is after the TimeAxis\n            // 2 set means the end is before the TimeAxis\n            // Either way, a truthy value means that the end is outside of the TimeAxis.\n            endsOutsideView                = endMS > viewEndMS | ((endMS <= viewStartMS) << 1),\n            durationMinutes                = durationMS / (1000 * 60),\n            width                          = endsOutsideView ? pxPerMinute * durationMinutes : null,\n            row                            = scheduler.getRowById(rowRecord);\n\n        return {\n            eventRecord : timeSpan,\n            taskRecord  : timeSpan, // Helps with using Gantt projects in Scheduler Pro\n            start       : timespanStart,\n            end         : timespanEnd,\n            rowId       : rowRecord.id,\n            children    : [],\n            startMS,\n            endMS,\n            durationMS,\n            startsOutsideView,\n            endsOutsideView,\n            width,\n            row,\n            useEventBuffer\n        };\n    }\n\n    /**\n     * Populates render data with information about width and horizontal position of the wrap.\n     * @param {HorizontalRenderData} renderData\n     * @returns {Boolean}\n     * @private\n     */\n    fillTimeSpanHorizontalPosition(renderData) {\n        const\n            { startMS, endMS, durationMS } = renderData,\n            // With delayed calculation there is no guarantee data is normalized, might be missing a crucial component\n            result = startMS != null && endMS != null && this.calculateHorizontalPosition(renderData, startMS, endMS, durationMS);\n\n        if (result) {\n            Object.assign(renderData, result);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Fills render data with `left` and `width` properties\n     * @param {HorizontalRenderData} renderData\n     * @param {Number} startMS\n     * @param {Number} endMS\n     * @param {Number} durationMS\n     * @returns {{left: number, width: number, clippedStart: boolean, clippedEnd: boolean}|null}\n     * @private\n     */\n    calculateHorizontalPosition(renderData, startMS, endMS, durationMS) {\n        const\n            { scheduler }   = this,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }               = scheduler,\n            {\n                startsOutsideView,\n                endsOutsideView,\n                eventRecord\n            }               = renderData,\n            viewStartMS     = timeAxis.startMS,\n            pxPerMinute     = timeAxisViewModel.getSingleUnitInPixels('minute'),\n            durationMinutes = durationMS / (1000 * 60),\n            width           = endsOutsideView ? pxPerMinute * durationMinutes : null;\n\n        let endX = scheduler.getCoordinateFromDate(endMS, {\n                local            : true,\n                respectExclusion : true,\n                isEnd            : true\n            }), startX, clippedStart = false, clippedEnd = false;\n\n        // If event starts outside of view, estimate where.\n        if (startsOutsideView) {\n            startX = (startMS - viewStartMS) / (1000 * 60) * pxPerMinute;\n\n            // Flip -ve startX to being to the right of the viewport end\n            if (scheduler.rtl) {\n                startX = scheduler.timeAxisSubGrid.scrollable.scrollWidth - startX;\n            }\n        }\n        // Starts in view, calculate exactly\n        else {\n            // If end date is included in time axis but start date is not (when using time axis exclusions), snap start date to next included data\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : endX !== -1\n            });\n\n            clippedStart = startX === -1;\n        }\n\n        if (endsOutsideView) {\n            // Have to clip the events in Safari when using stickyEvents, it does not support `overflow: clip`\n            if (BrowserHelper.isSafari && scheduler.features.stickyEvents && timeAxis.endMS  || (endX === -1 && !timeAxis.continuous)) {\n                endX = scheduler.getCoordinateFromDate(timeAxis.endMS);\n            }\n            else {\n                // Parentheses needed\n                endX = startX + width * (scheduler.rtl ? -1 : 1);\n            }\n        }\n        else {\n            clippedEnd = endX === -1;\n        }\n\n        if (clippedEnd && !clippedStart) {\n            // We know where to start but not where to end, snap it (the opposite is already handled by the\n            // snapToNextIncluded flag when calculating startX above)\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true\n            });\n        }\n\n        // If the element is very wide there's no point in displaying it all.\n        // Indeed the element may not be displayable at extremely large widths.\n        if (width > MAX_WIDTH) {\n            // The start is before the TimeAxis start\n            if (startsOutsideView === 1) {\n                // Both ends outside - spans TimeAxis\n                if (endsOutsideView === 1) {\n                    startX = -100;\n                    endX = scheduler.timeAxisColumn.width + 100;\n                }\n                // End is in view\n                else {\n                    startX = endX - MAX_WIDTH;\n                }\n            }\n            // The end is after, but the start is in view\n            else if (endsOutsideView === 1) {\n                endX = startX + MAX_WIDTH;\n            }\n        }\n\n        if (clippedStart && clippedEnd) {\n            // Both ends excluded, but there might be some part in between that should be displayed...\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : true,\n                max                : endMS\n            });\n\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true,\n                min                : startMS\n            });\n\n            if (startX === endX) {\n                // Raise flag on instance meta to avoid duplicating this logic\n                eventRecord.instanceMeta(scheduler).excluded = true;\n                // Excluded by time axis exclusion rules, render nothing\n                return null;\n            }\n        }\n\n        return {\n            left  : Math.min(startX, endX),\n            // Use min width 5 for normal events, 0 for milestones (won't have width specified at all in the\n            // end). During drag create a normal event can get 0 duration, in this case we still want it to\n            // get a min width of 5 (6px for wrapper, -1 px for event element\n            width : Math.abs(endX - startX) || (eventRecord.isMilestone && !eventRecord.meta.isDragCreating ? 0 : 6),\n            clippedStart,\n            clippedEnd\n        };\n    }\n\n    fillTimeSpanVerticalPosition(renderData, rowRecord) {\n        const\n            { scheduler }  = this,\n            { start, end } = renderData,\n            {\n                resourceMargin,\n                contentHeight\n            }              = scheduler.getResourceLayoutSettings(rowRecord);\n\n        // If filling ticks we need to also keep data's MS values, since they are used for sorting timespans\n        if (scheduler.fillTicks) {\n            renderData.dataStartMS = start.getTime();\n            renderData.dataEndMS = end.getTime();\n        }\n\n        renderData.top = Math.max(0, resourceMargin);\n\n        if (scheduler.managedEventSizing) {\n            // Timespan height should be at least 1px\n            renderData.height = contentHeight;\n        }\n    }\n\n    /**\n     * Gets timespan coordinates etc. Relative to containing row. If the timespan is outside of the zone in\n     * which timespans are rendered, that is outside of the TimeAxis, or outside of the vertical zone in which timespans\n     * are rendered, then `undefined` is returned.\n     * @private\n     * @param {Scheduler.model.TimeSpan} timeSpan TimeSpan record\n     * @param {Core.data.Model} rowRecord Row record\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.\n     * @returns {{event/task: *, left: number, width: number, start: (Date), end: (Date), startMS: number, endMS: number, startsOutsideView: boolean, endsOutsideView: boolean}}\n     */\n    getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {\n        const\n            me                     = this,\n            { scheduler }          = me,\n            { timeAxis }           = scheduler,\n            includeOutsideTimeAxis = includeOutside === true || includeOutside.timeAxis,\n            includeOutsideViewport = includeOutside === true || includeOutside.viewport;\n\n        // If timespan is outside the TimeAxis, give up trying to calculate a layout (Unless we're including timespans\n        // outside our zone)\n        if (includeOutsideTimeAxis || timeAxis.isTimeSpanInAxis(timeSpan)) {\n            const row = scheduler.getRowById(rowRecord);\n\n            if (row || includeOutsideViewport) {\n                const data = me.setupRenderData(timeSpan, rowRecord);\n\n                if (!me.fillTimeSpanHorizontalPosition(data)) {\n                    return null;\n                }\n\n                me.fillTimeSpanVerticalPosition(data, rowRecord);\n\n                return data;\n            }\n        }\n    }\n\n    // Layout a set of events, code shared by normal event render path and nested events\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me                   = this,\n            { scheduler }        = me,\n            { timeAxis }         = scheduler,\n            // Generate layout data\n            eventsData           = allEvents.reduce((result, eventRecord) => {\n                // Only those in time axis (by default)\n                if ((includeOutside || timeAxis.isTimeSpanInAxis(eventRecord))) {\n                    const eventBox = scheduler.generateRenderData(eventRecord, resourceRecord, false);\n\n                    // Collect layouts of visible events\n                    if (eventBox) {\n                        result.push(eventBox);\n                    }\n                }\n\n                return result;\n            }, []);\n\n        // Ensure the events are rendered in natural order so that navigation works.\n        eventsData.sort(eventSorter ?? me.eventSorter);\n\n        let rowHeight = scheduler.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n\n        const\n            // Only events and tasks should be considered during layout (not resource time ranges if any, or events\n            // being drag created when configured with lockLayout)\n            layoutEventData = eventsData.filter(({ eventRecord }) => eventRecord.isEvent && !eventRecord.meta.excludeFromLayout),\n            eventLayout     = scheduler.getEventLayout(resourceRecord, parentEventRecord),\n            layoutHandler   = scheduler.getEventLayoutHandler(eventLayout);\n\n        if (layoutHandler) {\n            const\n                {\n                    barMargin,\n                    resourceMargin,\n                    contentHeight\n                }              = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord),\n                bandsRequired  = layoutHandler.applyLayout(layoutEventData, resourceRecord) || 1;\n\n            if (layoutHandler.type === 'layoutFn') {\n                rowHeight = bandsRequired;\n            }\n            else {\n                rowHeight = (bandsRequired * contentHeight) + ((bandsRequired - 1) * barMargin) + resourceMargin * 2;\n            }\n        }\n        // Apply z-index when event elements might overlap, to keep \"overlap order\" consistent\n        else if (layoutEventData.length > 0) {\n            for (let i = 0; i < layoutEventData.length; i++) {\n                const data = layoutEventData[i];\n                // $event-zindex scss var is 5\n                data.wrapperStyle += `;z-index:${i + 5}`;\n            }\n        }\n\n        return { rowHeight, eventsData };\n    }\n\n    // Lay out events within a resource, relative to the resource\n    layoutResourceEvents(resourceRecord, includeOutside = false) {\n        const\n            me                   = this,\n            { scheduler }        = me,\n            {\n                eventStore,\n                assignmentStore,\n                timeAxis\n            }                    = scheduler,\n            // Events for this resource\n            resourceEvents = eventStore.getEvents({\n                includeOccurrences : scheduler.enableRecurringEvents,\n                resourceRecord,\n                startDate          : timeAxis.startDate,\n                endDate            : timeAxis.endDate,\n                filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a)))\n            }),\n            // Call a chainable template function on scheduler to allow features to add additional \"events\" to render\n            // Currently used by ResourceTimeRanges, CalendarHighlight & NestedEvents\n            allEvents            = scheduler.getEventsToRender(resourceRecord, resourceEvents) || [];\n\n        return me.layoutEvents(resourceRecord, allEvents, includeOutside);\n    }\n\n    // Generates a DOMConfig for an EventRecord\n    renderEvent(data, rowHeight) {\n        const\n            { scheduler }                                     = this,\n            { resourceRecord, assignmentRecord, eventRecord } = data,\n            {\n                milestoneLayoutMode    : layoutMode,\n                milestoneTextPosition  : textPosition\n            }    = scheduler,\n            // Sync using assignment id for events and event id for ResourceTimeRanges. Add eventId for occurrences to make them unique\n            syncId                                            = assignmentRecord\n                // Assignment, might be an occurrence\n                ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id\n                // Something else, probably a ResourceTimeRange\n                : data.eventId,\n            eventElementConfig = {\n                className : data.cls,\n                style     : data.style || '',\n                children  : data.children,\n                role      : 'presentation',\n                dataset   : {\n                    // Each feature putting contents in the event wrap should have this to simplify syncing and\n                    // element retrieval after sync\n                    taskFeature : 'event'\n                },\n                syncOptions : {\n                    syncIdField : 'taskBarFeature'\n                }\n            },\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig                        = {\n                className : data.wrapperCls,\n                tabIndex  : ('tabIndex' in data) ? data.tabIndex : -1,\n                children  : [\n                    eventElementConfig,\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top    : data.absoluteTop,\n                    left   : data.left,\n                    // ResourceTimeRanges fill row height, cannot be done earlier than this since row height is not\n                    // known initially\n                    height : data.fillSize ? rowHeight : data.height,\n                    // DomHelper appends px to dimensions when using numbers.\n                    // Do not ignore width for normal milestones, use height value. It is required to properly center\n                    // pseudo element with top/bottom labels.\n                    // Milestone part of layout that contain the label gets a width\n                    width  : (eventRecord.isMilestone && !eventRecord.meta.isDragCreating) &&\n                             ((layoutMode === 'default' && (textPosition === 'outside' || (textPosition === 'inside' && !data.width))) ||\n                                 textPosition === 'always-outside') ? data.height : data.width,\n                    style    : data.wrapperStyle,\n                    fontSize : data.height + 'px'\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    syncId     : resourceRecord.isLinked ? `${syncId}_${resourceRecord.id}` : syncId\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : data,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : assignmentRecord?.instanceMeta(scheduler).retainElement || eventRecord.instanceMeta(scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n\n        // Write back the correct height for elements filling the row, to not derender them later based on wrong height\n        if (data.fillSize) {\n            data.height = rowHeight;\n        }\n\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n\n        data.elementConfig = elementConfig;\n\n        return elementConfig;\n    }\n\n    /**\n     * Refresh events for resource record (or Row), clearing its cache and forcing DOM refresh.\n     * @param {Scheduler.model.ResourceModel} recordOrRow Record or row to refresh\n     * @param {Boolean} [force] Specify `false` to prevent clearing cache and forcing DOM refresh\n     * @internal\n     */\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        const\n            me     = this,\n            record = me.scheduler.store.getById(recordOrRow.isRow ? recordOrRow.id : recordOrRow),\n            row    = me.scheduler.rowManager.getRowFor(record);\n\n        if (force) {\n            me.clearResources([record]);\n        }\n\n        if (row && record) {\n            me.renderer({ row, record });\n\n            if (force && draw) {\n                me.onRenderDone();\n            }\n        }\n    }\n\n    // Returns layout for the current resource. Used by the renderer and exporter\n    getResourceLayout(resourceRecord) {\n        const me = this;\n\n        // Use cached layout if available\n        let resourceLayout = me.resourceMap.get(resourceRecord.id);\n\n        if (!resourceLayout || resourceLayout.invalid) {\n            // Previously we would bail out here if engine wasn't ready. Now we instead allow drawing in most cases,\n            // since data can be read and written during commit (previously it could not)\n            if (me.suspended) {\n                return;\n            }\n\n            resourceLayout = me.layoutResourceEvents(resourceRecord, false);\n            me.resourceMap.set(resourceRecord.id, resourceLayout);\n        }\n\n        return resourceLayout;\n    }\n\n    getEventDOMConfigForCurrentView(resourceLayout, row, left, right) {\n        const\n            me                        = this,\n            { bufferSize, scheduler } = me,\n            { labels, eventBuffer }   = scheduler.features,\n            // Left/right labels and event buffer elements require using a buffer to not derender too early\n            usesLabels                = eventBuffer?.enabled || (labels?.enabled && (labels.left || labels.right || labels.before || labels.after)),\n            { eventsData }            = resourceLayout,\n            // When scrolling, layout will be reused and any events that are still in view can reuse their DOM configs\n            reusableDOMConfigs        = me.fromScroll ? me.rowMap.get(row) : null,\n            eventDOMConfigs           = [];\n\n        let useLeft, useRight;\n\n        // Only collect configs for those actually in view\n        for (let i = 0; i < eventsData.length; i++) {\n            const layout = eventsData[i];\n\n            useLeft = left;\n            useRight = right;\n\n            // Labels/milestones requires keeping events rendered longer\n            if (usesLabels || layout.width === 0) {\n                useLeft -= bufferSize;\n                useRight += bufferSize;\n            }\n\n            if ((layout.left + layout.width) >= useLeft && layout.left <= useRight) {\n                layout.absoluteTop = layout.top + row.top;\n                // <remove-on-release>\n                // TODO: Consider using a map of maps instead of having to find() here. But it is anyhow much faster\n                //  than not reusing dom configs\n                // </remove-on-release>\n                const prevDomConfig = reusableDOMConfigs?.find(config => config.elementData.eventId === layout.eventId &&\n                    config.elementData.resourceId === layout.resourceId);\n                eventDOMConfigs.push(prevDomConfig ?? me.renderEvent(layout, resourceLayout.rowHeight));\n            }\n        }\n\n        return eventDOMConfigs;\n    }\n\n    // Called per row in \"view\", collect configs\n    renderer({ row, record : resourceRecord, size = {} }) {\n        const me = this;\n\n        // Bail out for group headers/footers\n        if (resourceRecord.isSpecialRow) {\n            // Clear any cached layout for row retooled to special row, and bail out\n            me.rowMap.delete(row);\n            return;\n        }\n\n        const\n            { left, right } = me.viewportCoords,\n            resourceLayout  = me.getResourceLayout(resourceRecord);\n\n        // Layout is suspended\n        if (!resourceLayout) {\n            return;\n        }\n\n        // Size row to fit events\n        size.height = resourceLayout.rowHeight;\n        // Avoid storing our calculated height as the rows max height, to not affect next round of calculations\n        size.transient = true;\n\n        const eventDOMConfigs = me.getEventDOMConfigForCurrentView(resourceLayout, row, left, right);\n\n        me.rowMap.set(row, eventDOMConfigs);\n\n        // Keep track if we need to draw on vertical scroll or not, to not get multiple onRenderDone() calls\n        me.rendererCalled = true;\n    }\n\n    // Called when the current row rendering \"pass\" is complete, sync collected configs to DOM\n    onRenderDone() {\n        const\n            { scheduler, rowMap, verticalBufferSize }  = this,\n            visibleEventDOMConfigs                     = [],\n            bodyTop                                    = scheduler._scrollTop ?? 0,\n            viewTop                                    = bodyTop - verticalBufferSize,\n            viewBottom                                 = bodyTop + scheduler._bodyRectangle.height + verticalBufferSize,\n            unbuffered                                 = verticalBufferSize < 0,\n            unmanagedSize                              = !scheduler.managedEventSizing;\n\n        // Event configs are collected when rows are rendered, but we do not want to waste resources on rendering\n        // events far out of view. Especially with many events per row giving large row heights, rows in the RowManagers\n        // buffer might far away -> collect events for rows within viewport + small vertical buffer\n        rowMap.forEach((eventDOMConfigs, row) => {\n            // Render events \"in view\". Export specifies a negative verticalBufferSize to disable it\n            if (unbuffered || (row.bottom > viewTop && row.top < viewBottom)) {\n                for (let i = 0; i < eventDOMConfigs.length; i++) {\n                    const\n                        config = eventDOMConfigs[i],\n                        data   = config.elementData,\n                        {\n                            absoluteTop,\n                            eventRecord\n                        } = data;\n\n                    // Conditions under which event bars are included in the DOM:\n                    //   If bufferSize is -ve, meaning render all events.\n                    //   scheduler.managedEventSizing is false.\n                    //   The event is beig drag-created or drag-resized\n                    //   The event is within the bounds of the rendered region.\n                    if (unbuffered || unmanagedSize || eventRecord.meta.isDragCreating || eventRecord.meta.isResizing || (absoluteTop + data.height > viewTop && absoluteTop < viewBottom)) {\n                        visibleEventDOMConfigs.push(config);\n                    }\n                }\n            }\n\n            // We are using cached DomConfigs. When DomSync releases an element, it also flags the config as released.\n            // Next time we pass it that very same config, it says it is released and nothing shows up.\n            //\n            // We are breaching the DomSync contract a bit with the cached approach. DomSync expects new configs on each\n            // call, so to facilitate that we clone the configs shallowly (nothing deep is affected by sync releasing).\n            // That way we can always pass it fresh unreleased configs.\n            for (let i = 0; i < eventDOMConfigs.length; i++) {\n                eventDOMConfigs[i] = { ...eventDOMConfigs[i] };\n            }\n        });\n\n        this.fromScroll = false;\n        this.visibleEventDOMConfigs = visibleEventDOMConfigs;\n\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : visibleEventDOMConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n\n            // Called by DomSync when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const\n                    { reactComponent } = scheduler,\n                    // Some actions are considered first a release and then a render (reusing another element).\n                    // This gives clients code a chance to clean up before reusing an element\n                    isRelease          = releaseEventActions[action],\n                    isRender           = renderEventActions[action];\n\n                !isRelease && scheduler.processEventContent?.({\n                    jsx,\n                    action,\n                    domConfig,\n                    targetElement,\n                    isRelease,\n                    reactComponent\n                });\n\n                if (action === 'none' || !domConfig?.elementData?.isWrap) {\n                    return;\n                }\n\n                // Trigger release for events (it might be a proxy element, skip those)\n                if (isRelease && lastDomConfig?.elementData) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = lastDomConfig.elementData,\n                        event = {\n                            renderData : lastDomConfig.elementData,\n                            element    : targetElement,\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n\n                    // Process event necessary in the case of release\n                    scheduler.processEventContent?.({\n                        isRelease,\n                        targetElement,\n                        reactComponent,\n                        assignmentRecord\n                    });\n\n                    // Some browsers do not blur on set to display:none, so releasing the active element\n                    // must *explicitly* move focus outwards to the view.\n                    if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                        scheduler.focusElement.focus();\n                    }\n\n                    // This event is documented on Scheduler\n                    scheduler.trigger('releaseEvent', event);\n                }\n\n                if (isRender) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = domConfig.elementData,\n                        event = {\n                            renderData       : domConfig.elementData,\n                            element          : targetElement,\n                            isReusingElement : action === 'reuseElement',\n                            isRepaint        : action === 'reuseOwnElement',\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n\n                    // This event is documented on Scheduler\n                    scheduler.trigger('renderEvent', event);\n                }\n            }\n        });\n    }\n\n    //endregion\n\n    //region Cache\n\n    // Clears cached resource layout\n    clearResources(recordsOrIds) {\n        recordsOrIds = ArrayHelper.asArray(recordsOrIds);\n\n        const resourceIds = recordsOrIds.map(Model.asId);\n\n        //<debug>\n        if (globalThis.DEBUG) {\n            console.log('%Clearing resources ' + Array.from(resourceIds).join(','), 'color: #770000');\n        }\n        //</debug>\n\n        resourceIds.forEach(resourceId => {\n            // Invalidate resourceLayout, keeping it around in case we need it before next refresh\n            const cached = this.resourceMap.get(resourceId);\n            if (cached) {\n                cached.invalid = true;\n            }\n\n            const row = this.scheduler.getRowById(resourceId);\n            row && this.rowMap.delete(row);\n        });\n    }\n\n    clearAll({ clearDom = false, clearLayoutCache = false } = {}) {\n        const\n            me                            = this,\n            { layouts, foregroundCanvas } = me.scheduler;\n\n        //<debug>\n        if (globalThis.DEBUG) {\n            console.log('%Clearing all', 'color: #770000');\n        }\n        //</debug>\n\n        if (clearLayoutCache && layouts) {\n            for (const layout in layouts) {\n                layouts[layout].clearCache();\n            }\n        }\n\n        // it seems `foregroundCanvas` can be missing at this point\n        // for example if scheduler instance is created w/o of `appendTo` config\n        if (foregroundCanvas && clearDom) {\n            // Start from scratch when replacing the project, to not retain anything in maps or released elements\n            foregroundCanvas.syncIdMap = foregroundCanvas.lastDomConfig = null;\n\n            for (const child of foregroundCanvas.children) {\n                child.lastDomConfig = child.elementData = null;\n            }\n        }\n\n        me.resourceMap.clear();\n        me.rowMap.clear();\n    }\n\n    //endregion\n}\n", "import PackMixin from './PackMixin.js';\n\n/**\n * @module Scheduler/eventlayout/VerticalLayout\n */\n\n/**\n * Assists with event layout in vertical mode, handles `eventLayout: none|pack|mixed`\n * @private\n * @mixes Scheduler/eventlayout/PackMixin\n */\nexport default class VerticalLayout extends PackMixin() {\n\n    static get defaultConfig() {\n        return {\n            coordProp : 'leftFactor',\n            sizeProp  : 'widthFactor'\n        };\n    }\n\n    // Try to pack the events to consume as little space as possible\n    applyLayout(events, columnWidth, resourceMargin, barMargin, columnIndex, eventLayout) {\n        const\n            me         = this,\n            layoutType = eventLayout.type;\n\n        return me.packEventsInBands(events, (tplData, clusterIndex, slot, slotSize) => {\n            // Stretch events to fill available width\n            if (layoutType === 'none') {\n                tplData.width = columnWidth - resourceMargin * 2;\n                tplData.left += resourceMargin;\n            }\n            else {\n                // Fractions of resource column\n                tplData.widthFactor = slotSize;\n\n                const\n                    leftFactor      = tplData.leftFactor = slot.start + (clusterIndex * slotSize),\n                    // Number of \"columns\" in the current slot\n                    packColumnCount = Math.round(1 / slotSize),\n                    // Index among those columns for current event\n                    packColumnIndex = leftFactor / slotSize,\n                    // Width with all bar margins subtracted\n                    availableWidth  = columnWidth - resourceMargin * 2 - barMargin * (packColumnCount - 1);\n\n                // Allowing two events to overlap? Slightly offset the second\n                if (layoutType === 'mixed' && packColumnCount === 2) {\n                    tplData.left += leftFactor * columnWidth / 5 + barMargin;\n                    tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;\n                    tplData.zIndex = 5 + packColumnIndex;\n                }\n                // Pack by default\n                else {\n                    // Fractional width\n                    tplData.width = slotSize * availableWidth;\n                    // Translate to absolute position\n                    tplData.left += leftFactor * availableWidth + resourceMargin + barMargin * packColumnIndex;\n                }\n            }\n            tplData.cls['b-sch-event-narrow'] = tplData.width < me.scheduler.narrowEventWidth;\n        });\n    }\n}\n", "import Base from '../../../Core/Base.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VerticalLayout from '../../eventlayout/VerticalLayout.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/view/orientation/VerticalRendering\n */\n\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    },\n    emptyObject        = Object.freeze({});\n\n/**\n * Handles event rendering in Schedulers vertical mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class VerticalRendering extends Base.mixin(Delayable, AttachToProjectMixin) {\n\n    //region Config & Init\n\n    static get properties() {\n        return {\n            eventMap               : new Map(),\n            resourceMap            : new Map(),\n            releasedElements       : {},\n            toDrawOnProjectRefresh : new Set(),\n            resourceBufferSize     : 1\n        };\n    }\n\n    construct(scheduler) {\n        this.client         = this.scheduler = scheduler;\n        this.verticalLayout = new VerticalLayout({ scheduler });\n\n        super.construct({});\n    }\n\n    init() {\n        const\n            me                             = this,\n            { scheduler, resourceColumns } = me;\n\n        // Resource header/columns\n        resourceColumns.resourceStore = me.resourceStore;\n\n        resourceColumns.ion({\n            name              : 'resourceColumns',\n            columnWidthChange : 'onResourceColumnWidthChange',\n            thisObj           : me\n        });\n\n        me.initialized = true;\n\n        if (scheduler.isPainted) {\n            me.renderer();\n        }\n\n        resourceColumns.availableWidth = scheduler.timeAxisSubGridElement.offsetWidth;\n    }\n\n    //endregion\n\n    //region Elements <-> Records\n\n    resolveRowRecord(elementOrEvent, xy) {\n        const\n            me            = this,\n            { scheduler } = me,\n            event         = elementOrEvent.nodeType ? null : elementOrEvent,\n            element       = event ? event.target : elementOrEvent,\n            coords        = event ? [event.borderOffsetX, event.borderOffsetY] : xy,\n            // Fix for FF on Linux having text nodes as event.target\n            el            = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventElement  = el.closest(scheduler.eventSelector);\n\n        if (eventElement) {\n            return scheduler.resourceStore.getById(eventElement.dataset.resourceId);\n        }\n\n        // Need to be inside schedule at least\n        if (!element.closest('.b-sch-timeaxis-cell')) {\n            return null;\n        }\n\n        if (!coords) {\n            throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser\n                event instead of element to extract element and coordinates from`);\n        }\n\n        if (scheduler.variableColumnWidths || scheduler.resourceStore.isGrouped) {\n            let totalWidth = 0;\n\n            for (const col of me.resourceStore) {\n                if (!col.isSpecialRow) {\n                    totalWidth += col.columnWidth || me.resourceColumns.columnWidth;\n                }\n                if (totalWidth >= coords[0]) {\n                    return col;\n                }\n            }\n\n            return null;\n        }\n\n        const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);\n\n        return me.allResourceRecords[index];\n    }\n\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {\n        const eventData = this.eventMap.get(assignmentRecord.eventId)?.[assignmentRecord.resourceId];\n\n        if (eventData) {\n            eventData.renderData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n            // Element from the map cannot be trusted, might be reused in which case map is not updated to reflect that.\n            // To be safe, retrieve using `getElementFromAssignmentRecord`\n            const element = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper);\n\n            if (element) {\n                element.classList[add ? 'add' : 'remove'](cls);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Coordinate <-> Date\n\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        let coord = xy[1];\n\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n\n        return this.scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n\n    translateToScheduleCoordinate(y) {\n        return y - this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top - globalThis.scrollY;\n    }\n\n    translateToPageCoordinate(y) {\n        return y + this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top + globalThis.scrollY;\n    }\n\n    //endregion\n\n    //region Regions\n\n    getResourceEventBox(event, resource) {\n        const\n            eventId    = event.id,\n            resourceId = resource.id;\n\n        let { renderData } = this.eventMap.get(eventId)?.[resourceId] || emptyObject;\n\n        if (!renderData) {\n            // Never been in view, lay it out\n            this.layoutResourceEvents(this.scheduler.resourceStore.getById(resourceId));\n\n            // Have another go at getting the layout data\n            renderData = this.eventMap.get(eventId)?.[resourceId]?.renderData;\n        }\n\n        return renderData\n            ? new Rectangle(renderData.left, renderData.top, renderData.width, renderData.bottom - renderData.top)\n            : null;\n    }\n\n    getScheduleRegion(resourceRecord, eventRecord, local) {\n        const\n            me            = this,\n            { scheduler } = me,\n            // Only interested in width / height (in \"local\" coordinates)\n            region        = Rectangle.from(scheduler.timeAxisSubGridElement, scheduler.timeAxisSubGridElement);\n\n        if (resourceRecord) {\n            // <remove-on-release>\n            // TODO: How to account for eventRecord here?\n            // </remove-on-release>\n            region.left  = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n            region.right = region.left + scheduler.resourceColumnWidth;\n        }\n\n        const\n            start           = scheduler.timeAxis.startDate,\n            end             = scheduler.timeAxis.endDate,\n            dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n                start,\n                end\n            },\n            startY          = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),\n            endY            = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));\n\n        if (!local) {\n            region.top    = me.translateToPageCoordinate(startY);\n            region.bottom = me.translateToPageCoordinate(endY);\n        }\n        else {\n            region.top    = startY;\n            region.bottom = endY;\n        }\n\n        return region;\n    }\n\n    getRowRegion(resourceRecord, startDate, endDate) {\n        const\n            me            = this,\n            { scheduler } = me,\n            x             = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            taStart       = scheduler.timeAxis.startDate,\n            taEnd         = scheduler.timeAxis.endDate,\n            start         = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end           = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startY        = scheduler.getCoordinateFromDate(start),\n            endY          = scheduler.getCoordinateFromDate(end, true, true),\n            y             = Math.min(startY, endY),\n            height        = Math.abs(startY - endY);\n\n        return new Rectangle(x, y, scheduler.resourceColumnWidth, height);\n    }\n\n    get visibleDateRange() {\n        const\n            scheduler = this.scheduler,\n            scrollPos = scheduler.scrollable.y,\n            height    = scheduler.scrollable.clientHeight,\n            startDate = scheduler.getDateFromCoordinate(scrollPos) || scheduler.timeAxis.startDate,\n            endDate   = scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate;\n\n        return {\n            startDate,\n            endDate,\n            startMS : startDate.getTime(),\n            endMS   : endDate.getTime()\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    // Column width changed, rerender fully\n    onResourceColumnWidthChange({ width, oldWidth }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        // Fix width of column & header\n        me.resourceColumns.width = scheduler.timeAxisColumn.width = me.allResourceRecords.length * width;\n        me.clearAll();\n\n        // Only transition large changes, otherwise it is janky when dragging slider in demo\n        me.refresh(Math.abs(width - oldWidth) > 30);\n\n        // Not detected by resizeobserver? Need to call this for virtual scrolling to react to update\n        //        scheduler.callEachSubGrid('refreshFakeScroll');\n        //        scheduler.refreshVirtualScrollbars();\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        if (project) {\n            project.ion({\n                name    : 'project',\n                refresh : 'onProjectRefresh',\n                thisObj : this\n            });\n        }\n    }\n\n    onProjectRefresh() {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.rendered && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset)\n                if (me.refreshAllWhenReady) {\n                    me.clearAll();\n                    //scheduler.refreshWithTransition();\n                    me.refresh();\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refresh();\n                }\n\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n\n    //endregion\n\n    //region EventStore\n\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n\n        this.refreshAllWhenReady = true;\n\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            this.refreshAllWhenReady = true;\n        }\n    }\n\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, isAssign }) {\n        const\n            me          = this,\n            resourceIds = new Set();\n\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n\n        switch (action) {\n            // No-ops\n            case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n            case 'group':\n            case 'move':\n            case 'remove': // Remove is a no-op since assignment will also be removed\n                return;\n\n            case 'dataset':\n                me.refreshAllResourcesWhenReady();\n                return;\n\n            case 'add':\n            case 'updateMultiple':\n                // Just refresh below\n                break;\n\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([, newEvent]) => {\n                    // Old cleared by changed assignment\n                    newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                });\n                // And clear them\n                me.clearResources(resourceIds);\n                break;\n\n            case 'removeall':\n            case 'filter':\n                // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                // figure out which events was filtered out and only clear their resources.\n                me.clearAll();\n                me.refresh();\n                return;\n\n            case 'update': {\n                // Check if changes are graph related or not\n                const allChrono = record.$entity\n                    ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                    : !Object.keys(changes).some(name => !chronoFields[name]);\n\n                // If any one of these in changes, it will affect visuals\n                let changeCount = 0;\n                if ('startDate' in changes) changeCount++;\n                if ('endDate' in changes) changeCount++;\n                if ('duration' in changes) changeCount++;\n\n                // Always redraw non chrono changes (name etc)\n                if (!allChrono || changeCount || 'percentDone' in changes || 'inactive' in changes || 'segments' in changes) {\n                    if (me.shouldWaitForInitializeAndEngineReady) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearResources(resourceIds);\n                        me.refresh();\n                    }\n                }\n                return;\n            }\n        }\n\n        me.refreshResourcesWhenReady(resourceIds);\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    attachToResourceStore(resourceStore) {\n        const me = this;\n\n        super.attachToResourceStore(resourceStore);\n\n        me.refreshAllWhenReady = true;\n\n        if (me.resourceColumns) {\n            me.resourceColumns.resourceStore = resourceStore;\n        }\n\n        resourceStore.ion({\n            name             : 'resourceStore',\n            changePreCommit  : 'onResourceStoreChange',\n            refreshPreCommit : 'onResourceStoreRefresh',\n            // In vertical, resource store is not the row store but should toggle the load mask\n            load             : () => me.scheduler.unmaskBody(),\n            thisObj          : me,\n            prio             : 1 // Call before others to clear cache before redraw\n        });\n\n        if (me.initialized && me.scheduler.isPainted) {\n            // Invalidate resource range and events\n            me.firstResource = me.lastResource = null;\n            me.clearAll();\n\n            me.renderer();\n        }\n    }\n\n    onResourceStoreChange({ source : resourceStore, action, records = [], record, replaced, changes }) {\n        const\n            me              = this,\n            // records for add, record for update, replaced [[old, new]] for replace\n            resourceRecords = replaced ? replaced.map(r => r[1]) : records,\n            resourceIds     = new Set(resourceRecords.map(resourceRecord => resourceRecord.id));\n\n        // Invalidate resource range\n        me.firstResource                  = me.lastResource = null;\n        resourceStore._allResourceRecords = null;\n\n        const { allResourceRecords } = resourceStore;\n\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'update':\n                    if (changes?.id) {\n                        me.clearResources([changes.id.oldValue, changes.id.value]);\n                    }\n                    else {\n                        me.clearResources([record.id]);\n                    }\n                    // Only the invalidation above needed\n                    break;\n\n                case 'filter':\n                    // All filtered out resources needs clearing and so does those not filtered out since they might have\n                    // moved horizontally when others hide\n                    me.clearAll();\n                    break;\n            }\n\n            // Changing a column width means columns after that will have to be recalculated\n            // so clear all cached layouts.\n            if (changes && ('columnWidth' in changes)) {\n                me.clearAll();\n            }\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            switch (action) {\n                case 'dataset':\n                case 'remove': // Cannot tell from which index it was removed\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n\n                case 'replace':\n                case 'add': {\n                    if (!resourceStore.isGrouped) {\n                        // Make sure all existing events following added resources are offset correctly\n                        const\n                            firstIndex = resourceRecords.reduce(\n                                (index, record) => Math.min(index, allResourceRecords.indexOf(record)),\n                                allResourceRecords.length\n                            );\n\n                        for (let i = firstIndex; i < allResourceRecords.length; i++) {\n                            resourceIds.add(allResourceRecords[i].id);\n                        }\n                    }\n                }\n            }\n\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n\n    onResourceStoreRefresh({ action }) {\n        const me = this;\n\n        if (action === 'sort' || action === 'group') {\n            // Invalidate resource range & cache\n            me.firstResource = me.lastResource = me.resourceStore._allResourceRecords = null;\n            me.clearAll();\n            me.refresh();\n        }\n    }\n\n    //endregion\n\n    //region AssignmentStore\n\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n\n        this.refreshAllWhenReady = true;\n\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onAssignmentStoreChange({ action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me          = this,\n            resourceIds = new Set(assignmentRecords.map(assignmentRecord => assignmentRecord.resourceId));\n\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'remove':\n                    me.clearResources(resourceIds);\n                    break;\n\n                case 'filter':\n                    me.clearAll();\n                    break;\n\n                case 'update': {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n\n                    // Ignore engine resolving resourceId -> resource, eventId -> event\n                    if (!Object.keys(changes).filter(field => field !== 'resource' && field !== 'event').length) {\n                        return;\n                    }\n\n                    me.clearResources(resourceIds);\n                }\n            }\n\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            if (changes && 'resourceId' in changes) {\n                resourceIds.add(changes.resourceId.oldValue);\n            }\n\n            switch (action) {\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([oldAssignment, newAssignment]) => {\n                        resourceIds.add(oldAssignment.resourceId);\n                        resourceIds.add(newAssignment.resourceId);\n                    });\n            }\n\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.refreshAllResourcesWhenReady();\n        }\n    }\n\n    //endregion\n\n    //region View hooks\n\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n            this.scheduler.refreshFromRerender = false;\n        }\n    }\n\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.renderResource(resourceRecord);\n    }\n\n    updateFromHorizontalScroll(scrollX) {\n        if (scrollX !== this.prevScrollX) {\n            this.renderer();\n            this.prevScrollX = scrollX;\n        }\n    }\n\n    updateFromVerticalScroll() {\n        this.renderer();\n    }\n\n    scrollResourceIntoView(resourceRecord, options) {\n        const\n            { scheduler } = this,\n            x             = this.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n\n        return scheduler.scrollHorizontallyTo(x, options);\n    }\n\n    get allResourceRecords() {\n        return this.scheduler.resourceStore.allResourceRecords;\n    }\n\n    // Called when viewport size changes\n    onViewportResize(width) {\n        this.resourceColumns.availableWidth = width;\n        this.renderer();\n    }\n\n    get resourceColumns() {\n        return this.scheduler.timeAxisColumn?.resourceColumns;\n    }\n\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n\n    // No need to do anything special\n    onDragAbort() {}\n\n    onBeforeRowHeightChange() {}\n\n    onTimeAxisViewModelUpdate() {}\n\n    updateElementId() {}\n\n    releaseTimeSpanDiv() {}\n\n    //endregion\n\n    //region Dependency connectors\n\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'top';\n    }\n\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'bottom';\n    }\n\n    //endregion\n\n    //region Refresh resources\n\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n\n    /**\n     * Clears all resources directly and redraws them on next project refresh\n     * @private\n     */\n    refreshAllResourcesWhenReady() {\n        this.clearAll();\n        this.refreshAllWhenReady = true;\n    }\n\n    //region Rendering\n\n    // Resources in view + buffer\n    get resourceRange() {\n        return this.getResourceRange(true);\n    }\n\n    // Resources strictly in view\n    get visibleResources() {\n        const { first, last } = this.getResourceRange();\n\n        return {\n            first : this.allResourceRecords[first],\n            last  : this.allResourceRecords[last]\n        };\n    }\n\n    getResourceRange(withBuffer) {\n        const\n            {\n                scheduler,\n                resourceStore\n            }                  = this,\n            {\n                resourceColumnWidth,\n                scrollX\n            }                  = scheduler,\n            {\n                scrollWidth\n            }                  = scheduler.timeAxisSubGrid.scrollable,\n            resourceBufferSize = withBuffer ? this.resourceBufferSize : 0,\n            viewportStart      = scrollX - resourceBufferSize,\n            viewportEnd        = scrollX + scrollWidth + resourceBufferSize;\n        if (!resourceStore?.count) {\n            return { first : -1, last : -1 };\n        }\n\n        // Some resources define their own width\n        if (scheduler.variableColumnWidths) {\n            let first, last = 0, start, end = 0;\n            this.allResourceRecords.forEach((resource, i) => {\n                resource.instanceMeta(scheduler).insetStart = start = end;\n                end                                         = start + resource.columnWidth;\n\n                if (start > viewportEnd) {\n                    return false;\n                }\n                if (end > viewportStart && first == null) {\n                    first = i;\n                }\n                else if (start < viewportEnd) {\n                    last = i;\n                }\n            });\n            return { first, last };\n        }\n        // We are using fixed column widths\n        else {\n            return {\n                first : Math.max(Math.floor(scrollX / resourceColumnWidth) - resourceBufferSize, 0),\n                last  : Math.min(\n                    Math.floor((scrollX + scheduler.timeAxisSubGrid.width) / resourceColumnWidth) + resourceBufferSize,\n                    this.allResourceRecords.length - 1\n                )\n            };\n        }\n    }\n\n    // Dates in view + buffer\n    get dateRange() {\n        const\n            { scheduler } = this;\n\n        let bottomDate = scheduler.getDateFromCoordinate(Math.min(\n            scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1,\n            (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1)\n        );\n\n        // Might end up below time axis (out of ticks)\n        // <remove-on-release>\n        // TODO: Change call order on refresh to make sure this is not needed?\n        // </remove-on-release>\n        if (!bottomDate) {\n            bottomDate = scheduler.timeAxis.last.endDate;\n        }\n\n        let topDate = scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0));\n\n        // Might end up above time axis when reconfiguring (since this happens as part of rendering)\n        if (!topDate) {\n            topDate    = scheduler.timeAxis.first.startDate;\n            bottomDate = scheduler.getDateFromCoordinate(scheduler.bodyHeight + scheduler.tickSize - 1);\n        }\n\n        return {\n            topDate,\n            bottomDate\n        };\n    }\n\n    getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {\n        const\n            me             = this,\n            {\n                scheduler\n            }              = me,\n            {\n                preamble,\n                postamble\n            }              = eventRecord,\n            {\n                variableColumnWidths\n            }              = scheduler,\n            useEventBuffer = scheduler.features.eventBuffer?.enabled && me.isProVerticalRendering &&\n                (preamble || postamble) && !eventRecord.isMilestone,\n            startDateField = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField   = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            startDate      = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(startDateField) && !useEventBuffer\n                ? eventRecord.get(startDateField) : eventRecord[startDateField],\n            endDate        = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(endDateField) && !useEventBuffer\n                ? eventRecord.get(endDateField) : eventRecord[endDateField],\n            resourceMargin = scheduler.getResourceMargin(resourceRecord),\n            top            = scheduler.getCoordinateFromDate(startDate),\n            instanceMeta   = resourceRecord.instanceMeta(scheduler),\n            // Preliminary values for left & width, used for proxy. Will be changed on layout.\n            // The property \"left\" is utilized based on Scheduler's rtl setting.\n            // If RTL, then it's used as the \"right\" style position.\n            left           = variableColumnWidths ? instanceMeta.insetStart : me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            resourceWidth  = scheduler.getResourceWidth(resourceRecord),\n            width          = resourceWidth - resourceMargin * 2,\n            startDateMS    = startDate.getTime(),\n            endDateMS      = endDate.getTime();\n\n        let bottom = scheduler.getCoordinateFromDate(endDate),\n            height = bottom - top;\n\n        // Below, estimate height\n        if (bottom === -1) {\n            height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('millisecond'));\n            bottom = top + height;\n        }\n\n        return {\n            eventRecord,\n            resourceRecord,\n            left,\n            top,\n            bottom,\n            resourceWidth,\n            width,\n            height,\n            startDate,\n            endDate,\n            startDateMS,\n            endDateMS,\n            useEventBuffer,\n\n            children : [],\n\n            // <remove-on-release>\n            // TODO: should change there to match horizontal\n            // </remove-on-release>\n            start   : startDate,\n            end     : endDate,\n            startMS : startDateMS,\n            endMS   : endDateMS\n        };\n    }\n\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    eventSorter(a, b) {\n        const\n            startA = a.dataStartMs || a.startDateMS, // dataXX are used if configured with fillTicks\n            endA   = a.dataEndMs || a.endDateMS,\n            startB = b.dataStartMs || b.startDateMS,\n            endB   = b.dataEndMs || b.endDateMS,\n            nameA  = a.isModel ? a.name : a.eventRecord.name,\n            nameB  = b.isModel ? b.name : b.eventRecord.name;\n\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            {\n                variableColumnWidths\n            }                   = scheduler,\n            { id : resourceId } = resourceRecord,\n            instanceMeta        = resourceRecord.instanceMeta(scheduler),\n            cacheKey            = parentEventRecord ? `${resourceId}-${parentEventRecord.id}` : resourceId,\n            // Cache per resource\n            cache               = me.resourceMap.set(cacheKey, {}).get(cacheKey),\n            // Resource \"column\"\n            resourceIndex       = me.allResourceRecords.indexOf(resourceRecord),\n            {\n                barMargin,\n                resourceMargin\n            }                   = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord);\n\n        const layoutData = allEvents.reduce((toLayout, eventRecord) => {\n            if (eventRecord.isScheduled) {\n                const\n                    renderData     = scheduler.generateRenderData(eventRecord, resourceRecord, false),\n                    // Elements will be appended to eventData during syncing\n                    eventData      = { renderData },\n                    eventResources = ObjectHelper.getMapPath(me.eventMap, renderData.eventId, {});\n\n                // Cache per event, { e1 : { r1 : { xxx }, r2 : ... }, e2 : ... }\n                // Uses renderData.eventId in favor of eventRecord.id to work with ResourceTimeRanges\n                eventResources[resourceId] = eventData;\n\n                // Cache per resource\n                cache[renderData.eventId] = eventData;\n\n                // Position ResourceTimeRanges directly, they do not affect the layout of others\n                if (renderData.fillSize) {\n                    // The property \"left\" is utilized based on Scheduler's rtl setting.\n                    // If RTL, then it's used as the \"right\" style position.\n                    renderData.left = variableColumnWidths ? instanceMeta.insetStart : resourceIndex * scheduler.resourceColumnWidth;\n\n                    renderData.width = scheduler.getResourceWidth(resourceRecord);\n                }\n                // Anything not flagged with `fillSize` should take part in layout\n                else {\n                    toLayout.push(renderData);\n                }\n            }\n\n            return toLayout;\n        }, []);\n\n        // Ensure the events are rendered in natural order so that navigation works.\n        layoutData.sort(eventSorter ?? me.eventSorter);\n\n        // Apply per resource event layout (pack, overlap or mixed)\n        me.verticalLayout.applyLayout(\n            layoutData,\n            scheduler.getResourceWidth(resourceRecord, parentEventRecord),\n            resourceMargin,\n            barMargin,\n            resourceIndex,\n            scheduler.getEventLayout(resourceRecord, parentEventRecord)\n        );\n\n        return cache;\n    }\n\n    // Calculate the layout for all events assigned to a resource. Since we are never stacking, the layout of one\n    // resource will never affect the others\n    layoutResourceEvents(resourceRecord) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            // Used in loop, reduce access time a wee bit\n            {\n                assignmentStore,\n                eventStore,\n                timeAxis\n            }                   = scheduler;\n\n        // Events for the resource, minus those that are filtered out by filtering assignments and events\n        let events = eventStore.getEvents({\n            includeOccurrences : scheduler.enableRecurringEvents,\n            resourceRecord,\n            startDate          : timeAxis.startDate,\n            endDate            : timeAxis.endDate,\n            filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                eventRecord.assignments.some(a => a.resource === resourceRecord && assignmentStore.includes(a)))\n        });\n\n        // Hook for features to inject additional timespans to render\n        events = scheduler.getEventsToRender(resourceRecord, events);\n\n        return me.layoutEvents(resourceRecord, events);\n    }\n\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(\n                eventRecord,\n                eventRecord.resource,\n                { timeAxis : true, viewport : true }\n            );\n\n        renderData.top = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;\n\n        const\n            domConfig   = this.renderEvent({ renderData }),\n            { dataset } = domConfig;\n\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent  = this.scheduler.foregroundCanvas;\n\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n\n        const result = DomHelper.createElement(domConfig);\n\n        result.innerElement = result.firstChild;\n\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n\n        return result;\n    }\n\n    // <remove-on-release>\n    // TODO: Pretty much identical to HorizontalRendering#renderEvent.\n    //  Make shared base class Render a single event, aborting if already in DOM.\n    // </remove-on-release>\n    // To update an event, first release its element and then render it again.\n    // The element will be reused and updated. Keeps code simpler\n    renderEvent(eventData) {\n        // No point in rendering event that already has an element\n        const\n            { scheduler } = this,\n            data          = eventData.renderData,\n            {\n                resourceRecord,\n                assignmentRecord,\n                eventRecord\n            }             = data,\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig = {\n                className : data.wrapperCls,\n                tabIndex  : -1,\n                children  : [\n                    {\n                        role      : 'presentation',\n                        className : data.cls,\n                        style     : (data.internalStyle || '') + (data.style || ''),\n                        children  : data.children,\n                        dataset   : {\n                            // Each feature putting contents in the event wrap should have this to simplify syncing and\n                            // element retrieval after sync\n                            taskFeature : 'event'\n                        },\n                        syncOptions : {\n                            syncIdField : 'taskBarFeature'\n                        }\n                    },\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top                                : data.top,\n                    [scheduler.rtl ? 'right' : 'left'] : data.left,\n                    // DomHelper appends px to dimensions when using numbers\n                    height                             : eventRecord.isMilestone ? '1em' : data.height,\n                    width                              : data.width,\n                    style                              : data.wrapperStyle || '',\n                    fontSize                           : eventRecord.isMilestone ? Math.min(data.width, 40) : null\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    // Sync using assignment id for events and event id for ResourceTimeRanges\n                    syncId     : assignmentRecord ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id : data.eventId\n\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : eventData,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : (assignmentRecord || eventRecord).instanceMeta(this.scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n\n        elementConfig.className['b-sch-vertical'] = 1;\n\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n\n        // Allows access to the used config later, for example to retrieve element\n        eventData.elementConfig = elementConfig;\n\n        return elementConfig;\n    }\n\n    renderResource(resourceRecord) {\n        const\n            me                          = this,\n            // Date at top and bottom for determining which events to include\n            { topDateMS, bottomDateMS } = me,\n            // Will hold element configs\n            eventDOMConfigs             = [];\n\n        let resourceEntry = me.resourceMap.get(resourceRecord.id);\n\n        // Layout all events for the resource unless already done\n        if (!resourceEntry) {\n            resourceEntry = me.layoutResourceEvents(resourceRecord);\n        }\n\n        // Iterate over all events for the resource\n        for (const eventId in resourceEntry) {\n            const\n                eventData                               = resourceEntry[eventId],\n                { endDateMS, startDateMS, eventRecord } = eventData.renderData;\n\n            if (\n                // Only collect configs for those actually in view\n                endDateMS >= topDateMS && startDateMS <= bottomDateMS &&\n                // And not being dragged, those have a temporary element already\n                !eventRecord.instanceMeta(me.scheduler).hasTemporaryDragElement\n            ) {\n                // Reuse DomConfig if available, otherwise render event to create one\n                const domConfig = eventData.elementConfig?.className !== 'b-released' && eventData.elementConfig || me.renderEvent(eventData);\n                eventDOMConfigs.push(domConfig);\n            }\n        }\n\n        return eventDOMConfigs;\n    }\n\n    isEventElement(domConfig) {\n        const className = domConfig && domConfig.className;\n\n        return className && className[this.scheduler.eventCls + '-wrap'];\n    }\n\n    get shouldWaitForInitializeAndEngineReady() {\n        return !this.initialized || (!this.scheduler.isEngineReady && !this.scheduler.isCreating);\n    }\n\n    // Single cell so only one call to this renderer, determine which events are in view and draw them.\n    // Drawing on scroll is triggered by `updateFromVerticalScroll()` and `updateFromHorizontalScroll()`\n    renderer() {\n        const\n            me                                           = this,\n            { scheduler }                                = me,\n            // Determine resource range to draw events for\n            { first : firstResource, last : lastResource } = me.resourceRange,\n            // Date at top and bottom for determining which events to include\n            { topDate, bottomDate }                        = me.dateRange,\n            syncConfigs                                    = [],\n            featureDomConfigs                              = [];\n\n        // If scheduler is creating a new event, the render needs to be synchronous, so\n        // we cannot wait for the engine to normalize - the new event will have correct data set.\n        if (me.shouldWaitForInitializeAndEngineReady) {\n            return;\n        }\n\n        //<debug>\n        if (globalThis.DEBUG) {\n            if (me.firstResource !== firstResource || me.lastResource !== lastResource) {\n                console.log(`Resources in view ${me.allResourceRecords[firstResource].id} -> ${me.allResourceRecords[lastResource].id}`);\n            }\n        }\n        //</debug>\n\n        // Update current time range, reflecting the change on the vertical time axis header\n        if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {\n            // Calculated values used by `renderResource()`\n            me.topDate      = topDate;\n            me.bottomDate   = bottomDate;\n            me.topDateMS    = topDate.getTime();\n            me.bottomDateMS = bottomDate.getTime();\n\n            const range = me.timeView.range = { startDate : topDate, endDate : bottomDate };\n\n            scheduler.onVisibleDateRangeChange(range);\n        }\n\n        if (firstResource !== -1 && lastResource !== -1) {\n            // Collect all events for resources in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                syncConfigs.push.apply(syncConfigs, me.renderResource(me.allResourceRecords[i]));\n            }\n        }\n\n        scheduler.getForegroundDomConfigs(featureDomConfigs);\n\n        syncConfigs.push.apply(syncConfigs, featureDomConfigs);\n\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : syncConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n\n            // Called by DomHelper when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const { reactComponent } = scheduler;\n                // If element is an event wrap, trigger appropriate events\n                if (me.isEventElement(domConfig) || jsx || domConfig?.elementData?.jsx) {\n                    const\n                        // Some actions are considered first a release and then a render (reusing another element).\n                        // This gives clients code a chance to clean up before reusing an element\n                        isRelease = releaseEventActions[action],\n                        isRender  = renderEventActions[action];\n\n                    if (scheduler.processEventContent?.({\n                        action,\n                        domConfig,\n                        isRelease : false,\n                        targetElement,\n                        reactComponent,\n                        jsx\n\n                    })) return;\n\n                    // If we are reusing an element that was previously released we should not trigger again\n                    if (isRelease && me.isEventElement(lastDomConfig) && !lastDomConfig.isReleased) {\n                        const\n                            data  = lastDomConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement\n                            };\n\n                        // Release any portal in React event content\n                        scheduler.processEventContent?.({\n                            isRelease,\n                            targetElement,\n                            reactComponent,\n                            assignmentRecord : data.assignmentRecord\n                        });\n\n                        // Some browsers do not blur on set to display:none, so releasing the active element\n                        // must *explicitly* move focus outwards to the view.\n                        if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                            scheduler.focusElement.focus();\n                        }\n\n                        // This event is documented on Scheduler\n                        scheduler.trigger('releaseEvent', event);\n                    }\n\n                    if (isRender) {\n                        const\n                            data  = domConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement,\n                                isReusingElement : action === 'reuseElement',\n                                isRepaint        : action === 'reuseOwnElement'\n                            };\n\n                        event.reusingElement = action === 'reuseElement';\n\n                        // This event is documented on Scheduler\n                        scheduler.trigger('renderEvent', event);\n                    }\n                }\n            }\n        });\n\n        // Change in displayed resources?\n        if (me.firstResource !== firstResource || me.lastResource !== lastResource) {\n            // Update header to match\n            const range = me.resourceColumns.visibleResources = { firstResource, lastResource };\n\n            // Store which resources are currently in view\n            me.firstResource = firstResource;\n            me.lastResource  = lastResource;\n\n            scheduler.onVisibleResourceRangeChange(range);\n            scheduler.trigger('resourceRangeChange', range);\n        }\n    }\n\n    refresh(transition) {\n        this.scheduler.runWithTransition(() => this.renderer(), transition);\n    }\n\n    // To match horizontals API, used from EventDrag\n    refreshResources(resourceIds) {\n        this.clearResources(resourceIds);\n        this.refresh();\n    }\n\n    // To match horizontals API, used from EventDrag\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        this.refreshResources([recordOrRow.id]);\n    }\n\n    onRenderDone() {\n\n    }\n\n    //endregion\n\n    //region Other\n\n    get timeView() {\n        return this.scheduler.timeView;\n    }\n\n    //endregion\n\n    //region Cache\n\n    // Clears cached resource layout\n    clearResources(resourceIds) {\n        const { resourceMap, eventMap } = this;\n\n        //<debug>\n        if (globalThis.DEBUG) console.log('%Clearing resources ' + Array.from(resourceIds).join(','), 'color: #770000');\n        //</debug>\n\n        resourceIds.forEach(resourceId => {\n            if (resourceMap.has(resourceId)) {\n                // The *keys* of an Object are strings, so we must iterate the values\n                // and use the original eventId to look up in the Map which preserves key type.\n                Object.values(resourceMap.get(resourceId)).forEach(({ renderData : { eventId } }) => {\n                    delete eventMap.get(eventId)[resourceId];\n                });\n\n                resourceMap.delete(resourceId);\n            }\n        });\n    }\n\n    clearAll() {\n        //<debug>\n        if (globalThis.DEBUG) console.log('%Clearing all', 'color: #770000');\n        //</debug>\n\n        this.resourceMap.clear();\n        this.eventMap.clear();\n    }\n\n    //endregion\n}\n", "import TimelineBase from './TimelineBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport CrudManager from '../data/CrudManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../localization/En.js';\n\nimport CurrentConfig from './mixin/CurrentConfig.js';\nimport Describable from './mixin/Describable.js';\nimport SchedulerDom from './mixin/SchedulerDom.js';\nimport SchedulerDomEvents from './mixin/SchedulerDomEvents.js';\nimport SchedulerEventRendering from './mixin/SchedulerEventRendering.js';\nimport SchedulerStores from './mixin/SchedulerStores.js';\nimport SchedulerScroll from './mixin/SchedulerScroll.js';\nimport SchedulerRegions from './mixin/SchedulerRegions.js';\nimport SchedulerState from './mixin/SchedulerState.js';\nimport EventSelection from './mixin/EventSelection.js';\nimport EventNavigation from './mixin/EventNavigation.js';\nimport CrudManagerView from '../crud/mixin/CrudManagerView.js';\nimport HorizontalRendering from './orientation/HorizontalRendering.js';\nimport VerticalRendering from './orientation/VerticalRendering.js';\nimport '../column/TimeAxisColumn.js';\nimport '../column/VerticalTimeAxisColumn.js';\n\n// Should always be present in Scheduler\nimport '../../Grid/feature/RegionResize.js';\n\n/**\n * @module Scheduler/view/SchedulerBase\n */\n\nconst\n    descriptionFormats = {\n        month : 'MMMM, YYYY',\n        week  : ['MMMM YYYY (Wp)', 'S{MMM} - E{MMM YYYY} (S{Wp})'],\n        day   : 'MMMM D, YYYY'\n    };\n\n/**\n * A thin base class for {@link Scheduler.view.Scheduler}. Does not include any features by default, allowing smaller\n * custom built bundles if used in place of {@link Scheduler.view.Scheduler}.\n *\n * **NOTE:** In most scenarios you do probably want to use Scheduler instead of SchedulerBase.\n *\n * @mixes Scheduler/view/mixin/Describable\n * @mixes Scheduler/view/mixin/EventNavigation\n * @mixes Scheduler/view/mixin/EventSelection\n * @mixes Scheduler/view/mixin/SchedulerDom\n * @mixes Scheduler/view/mixin/SchedulerDomEvents\n * @mixes Scheduler/view/mixin/SchedulerEventRendering\n * @mixes Scheduler/view/mixin/SchedulerRegions\n * @mixes Scheduler/view/mixin/SchedulerScroll\n * @mixes Scheduler/view/mixin/SchedulerState\n * @mixes Scheduler/view/mixin/SchedulerStores\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes Scheduler/data/mixin/ProjectConsumer\n *\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/Dependencies\n * @features Scheduler/feature/DependencyEdit\n * @features Scheduler/feature/EventCopyPaste\n * @features Scheduler/feature/EventDrag\n * @features Scheduler/feature/EventDragCreate\n * @features Scheduler/feature/EventDragSelect\n * @features Scheduler/feature/EventEdit\n * @features Scheduler/feature/EventFilter\n * @features Scheduler/feature/EventMenu\n * @features Scheduler/feature/EventNonWorkingTime\n * @features Scheduler/feature/EventResize\n * @features Scheduler/feature/EventTooltip\n * @features Scheduler/feature/GroupSummary\n * @features Scheduler/feature/HeaderZoom\n * @features Scheduler/feature/Labels\n * @features Scheduler/feature/NonWorkingTime\n * @features Scheduler/feature/Pan\n * @features Scheduler/feature/ResourceMenu\n * @features Scheduler/feature/ResourceTimeRanges\n * @features Scheduler/feature/ScheduleContext\n * @features Scheduler/feature/ScheduleMenu\n * @features Scheduler/feature/ScheduleTooltip\n * @features Scheduler/feature/SimpleEventEdit\n * @features Scheduler/feature/StickyEvents\n * @features Scheduler/feature/Summary\n * @features Scheduler/feature/TimeAxisHeaderMenu\n * @features Scheduler/feature/TimeRanges\n * @features Scheduler/feature/TimeSelection\n *\n * @features Scheduler/feature/experimental/ExcelExporter\n *\n * @features Scheduler/feature/export/PdfExport\n * @features Scheduler/feature/export/exporter/MultiPageExporter\n * @features Scheduler/feature/export/exporter/MultiPageVerticalExporter\n * @features Scheduler/feature/export/exporter/SinglePageExporter\n *\n * @extends Scheduler/view/TimelineBase\n * @widget\n */\nexport default class SchedulerBase extends TimelineBase.mixin(\n    CrudManagerView,\n    Describable,\n    SchedulerDom,\n    SchedulerDomEvents,\n    SchedulerStores,\n    SchedulerScroll,\n    SchedulerState,\n    SchedulerEventRendering,\n    SchedulerRegions,\n    EventSelection,\n    EventNavigation,\n    CurrentConfig\n) {\n    //region Config\n\n    static get $name() {\n        return 'SchedulerBase';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'schedulerbase';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Get/set the scheduler's read-only state. When set to `true`, any UIs for modifying data are disabled.\n             * @member {Boolean} readOnly\n             * @category Misc\n             */\n            /**\n             * Configure as `true` to make the scheduler read-only, by disabling any UIs for modifying data.\n             *\n             * __Note that checks MUST always also be applied at the server side.__\n             * @config {Boolean} readOnly\n             * @default false\n             * @category Misc\n             */\n\n            /**\n             * The date to display when used as a component of a Calendar.\n             *\n             * This is required by the Calendar Mode Interface.\n             *\n             * @config {Date}\n             * @category Calendar integration\n             */\n            date : {\n                value : null,\n\n                $config : {\n                    equal : 'date'\n                }\n            },\n\n            /**\n             * Unit used to control how large steps to take when clicking the previous and next buttons in the Calendar\n             * UI. Only applies when used as a component of a Calendar.\n             *\n             * Suitable units depend on configured {@link #config-range}, a smaller or equal unit is recommended.\n             *\n             * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n             * @default\n             * @category Calendar integration\n             */\n            stepUnit : 'week',\n\n            /**\n             * Unit used to set the length of the time axis when used as a component of a Calendar. Suitable units are\n             * `'month'`, `'week'` and `'day'`.\n             *\n             * @config {'day'|'week'|'month'}\n             * @category Calendar integration\n             * @default\n             */\n            range : 'week',\n\n            /**\n             * When the scheduler is used in a Calendar, this function provides the textual description for the\n             * Calendar's toolbar.\n             *\n             * ```javascript\n             *  descriptionRenderer : scheduler => {\n             *      const\n             *          count = scheduler.eventStore.records.filter(\n             *              eventRec => DateHelper.intersectSpans(\n             *                  scheduler.startDate, scheduler.endDate,\n             *                  eventRec.startDate, eventRec.endDate)).length,\n             *          startDate = DateHelper.format(scheduler.startDate, 'DD/MM/YYY'),\n             *          endData = DateHelper.format(scheduler.endDate, 'DD/MM/YYY');\n             *\n             *      return `${startDate} - ${endData}, ${count} event${count === 1 ? '' : 's'}`;\n             *  }\n             * ```\n             * @config {Function}\n             * @param {Scheduler.view.SchedulerBase} view The active view.\n             * @category Calendar integration\n             */\n\n            /**\n             * A method allowing you to define date boundaries that will constrain resize, create and drag drop\n             * operations. The method will be called with the Resource record, and the Event record.\n             *\n             * ```javascript\n             *  new Scheduler({\n             *      getDateConstraints(resourceRecord, eventRecord) {\n             *          // Assuming you have added these extra fields to your own EventModel subclass\n             *          const { minStartDate, maxEndDate } = eventRecord;\n             *\n             *          return {\n             *              start : minStartDate,\n             *              end   : maxEndDate\n             *          };\n             *      }\n             *  });\n             * ```\n             * @param {Scheduler.model.ResourceModel} [resourceRecord] The resource record\n             * @param {Scheduler.model.EventModel} [eventRecord] The event record\n             * @returns {Object} Constraining object containing `start` and `end` constraints. Omitting either\n             * will mean that end is not constrained. So you can prevent a resize or move from moving *before*\n             * a certain time while not constraining the end date.\n             * @returns {Date} [return.start] Start date\n             * @returns {Date} [return.end] End date\n             * @config {Function}\n             * @category Scheduled events\n             */\n            getDateConstraints : null,\n\n            /**\n             * The time axis column config for vertical {@link Scheduler.view.SchedulerBase#config-mode}.\n             *\n             * Object with {@link Scheduler.column.VerticalTimeAxisColumn} configuration.\n             *\n             * This object will be used to configure the vertical time axis column instance.\n             *\n             * The config allows configuring the `VerticalTimeAxisColumn` instance used in vertical mode with any Column options that apply to it.\n             *\n             * Example:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     mode     : 'vertical',\n             *     features : {\n             *         filterBar : true\n             *     },\n             *     verticalTimeAxisColumn : {\n             *         text  : 'Filter by event name',\n             *         width : 180,\n             *         filterable : {\n             *             // add a filter field to the vertical column access header\n             *             filterField : {\n             *                 type        : 'text',\n             *                 placeholder : 'Type to search',\n             *                 onChange    : ({ value }) => {\n             *                     // filter event by name converting to lowerCase to be equal comparison\n             *                     scheduler.eventStore.filter({\n             *                         filters : event => event.name.toLowerCase().includes(value.toLowerCase()),\n             *                         replace : true\n             *                     });\n             *                 }\n             *             }\n             *         }\n             *     },\n             *     ...\n             * });\n             * ```\n             *\n             * @config {VerticalTimeAxisColumnConfig}\n             * @category Time axis\n             */\n            verticalTimeAxisColumn : {},\n\n            /**\n             * See {@link Scheduler.view.Scheduler#keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             * @category Common\n             */\n\n            /**\n             * If true, a new event will be created when user double-clicks on a time axis cell (if scheduler is not in\n             * read only mode).\n             *\n             * The duration / durationUnit of the new event will be 1 time axis tick (default), or it can be read from\n             * the {@link Scheduler.model.EventModel#field-duration} and\n             * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n             *\n             * Set to `false` to not create events on double click.\n             * @config {Boolean|Object} createEventOnDblClick\n             * @param {Boolean} [createEventOnDblClick.useEventModelDefaults] set to `true` to set default duration\n             * based on the defaults specified by the {@link Scheduler.model.EventModel#field-duration} and\n             * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n             * @default\n             * @category Scheduled events\n             */\n            createEventOnDblClick : true,\n\n            // A CSS class identifying areas where events can be scheduled using drag-create, double click etc.\n            schedulableAreaSelector : '.b-sch-timeaxis-cell',\n            scheduledEventName      : 'event',\n            sortFeatureStore        : 'resourceStore'\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Scheduler mode. Supported values: horizontal, vertical\n             * @config {'horizontal'|'vertical'} mode\n             * @default\n             * @category Common\n             */\n            mode : 'horizontal',\n\n            /**\n             * CSS class to add to rendered events\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            eventCls : 'b-sch-event',\n\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            timeCellCls : 'b-sch-timeaxis-cell',\n\n            /**\n             * A CSS class to apply to each event in the view on mouseover (defaults to 'b-sch-event-hover').\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : 'b-sch-event-hover',\n\n            /**\n             * Set to false if you don't want to allow events overlapping times for any one resource (defaults to true).\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            allowOverlap : true,\n\n            /**\n             * The height in pixels of Scheduler rows.\n             * @config {Number}\n             * @default\n             * @category Common\n             */\n            rowHeight : 60,\n\n            /**\n             * Scheduler overrides Grids default implementation of {@link Grid.view.GridBase#config-getRowHeight} to\n             * pre-calculate row heights based on events in the rows.\n             *\n             * The amount of rows that are pre-calculated is limited for performance reasons. The limit is configurable\n             * by specifying the {@link Scheduler.view.SchedulerBase#config-preCalculateHeightLimit} config.\n             *\n             * The results of the calculation are cached internally.\n             *\n             * @config {Function} getRowHeight\n             * @param {Scheduler.model.ResourceModel} getRowHeight.record Resource record to determine row height for\n             * @returns {Number} Desired row height\n             * @category Layout\n             */\n\n            /**\n             * Maximum number of resources for which height is pre-calculated. If you have many events per\n             * resource you might want to lower this number to gain some initial rendering performance.\n             *\n             * Specify a falsy value to opt out of row height pre-calculation.\n             *\n             * @config {Number}\n             * @default\n             * @category Layout\n             */\n            preCalculateHeightLimit : 10000,\n\n            crudManagerClass : CrudManager,\n\n            testConfig : {\n                loadMaskError : {\n                    autoClose : 10,\n                    showDelay : 0\n                }\n            }\n        };\n    }\n\n    timeCellSelector          = '.b-sch-timeaxis-cell';\n    resourceTimeRangeSelector = '.b-sch-resourcetimerange';\n\n    // <remove-on-release>\n    // Keep this commented out to have easy access to the syntax next time we need to use it\n    // static get deprecatedEvents() {\n    //     return {\n    //         eventContextMenuBeforeShow : {\n    //             product            : 'Scheduler',\n    //             invalidAsOfVersion : '5.0.0',\n    //             message            : '`eventContextMenuBeforeShow` event is deprecated, in favor of `eventMenuBeforeShow` event. Please see https://bryntum.com/products/scheduler/docs/guide/Scheduler/upgrades/3.1.0 for more information.'\n    //         }\n    //     };\n    // }\n    // </remove-on-release>\n\n    //endregion\n\n    //region Store & model docs\n\n    // Documented here instead of in SchedulerStores since SchedulerPro uses different types\n\n    // Configs\n\n    /**\n     * Inline events, will be loaded into an internally created EventStore.\n     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events\n     * @category Data\n     */\n\n    /**\n     * The {@link Scheduler.data.EventStore} holding the events to be rendered into the scheduler (required).\n     * @config {Scheduler.data.EventStore|EventStoreConfig} eventStore\n     * @category Data\n     */\n\n    /**\n     * Inline resources, will be loaded into an internally created ResourceStore.\n     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources\n     * @category Data\n     */\n\n    /**\n     * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the scheduler (required).\n     * @config {Scheduler.data.ResourceStore|ResourceStoreConfig} resourceStore\n     * @category Data\n     */\n\n    /**\n     * Inline assignments, will be loaded into an internally created AssignmentStore.\n     * @config {Scheduler.model.AssignmentModel[]|Object[]} assignments\n     * @category Data\n     */\n\n    /**\n     * The optional {@link Scheduler.data.AssignmentStore}, holding assignments between resources and events.\n     * Required for multi assignments.\n     * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig} assignmentStore\n     * @category Data\n     */\n\n    /**\n     * Inline dependencies, will be loaded into an internally created DependencyStore.\n     * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} dependencies\n     * @category Data\n     */\n\n    /**\n     * The optional {@link Scheduler.data.DependencyStore}.\n     * @config {Scheduler.data.DependencyStore|DependencyStoreConfig} dependencyStore\n     * @category Data\n     */\n\n    // Properties\n\n    /**\n     * Get/set events, applies to the backing project's EventStore.\n     * @member {Scheduler.model.EventModel[]} events\n     * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.EventStore} eventStore\n     * @category Data\n     */\n\n    /**\n     * Get/set resources, applies to the backing project's ResourceStore.\n     * @member {Scheduler.model.ResourceModel[]} resources\n     * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the resource store instance of the backing project\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @category Data\n     */\n\n    /**\n     * Get/set assignments, applies to the backing project's AssignmentStore.\n     * @member {Scheduler.model.AssignmentModel[]} assignments\n     * @accepts {Scheduler.model.AssignmentModel[]|Object[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @category Data\n     */\n\n    /**\n     * Get/set dependencies, applies to the backing projects DependencyStore.\n     * @member {Scheduler.model.DependencyModel[]} dependencies\n     * @accepts {Scheduler.model.DependencyModel[]|DependencyModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the dependencies store instance of the backing project.\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @category Data\n     */\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fired after rendering an event, when its element is available in DOM.\n     * @event renderEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering, see\n     *   {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventRenderer} for details\n     * @param {Boolean} isRepaint `true` if this render is a repaint of the event, updating its existing element\n     * @param {Boolean} isReusingElement `true` if this render lead to the event reusing a released events element\n     * @param {HTMLElement} element The event bar element\n     */\n\n    /**\n     * Fired after releasing an event, useful to cleanup of custom content added on `renderEvent` or in `eventRenderer`.\n     * @event releaseEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering\n     * @param {HTMLElement} element The event bar element\n     */\n\n    /**\n     * Fired when clicking a resource header cell\n     * @event resourceHeaderClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n\n    /**\n     * Fired when double clicking a resource header cell\n     * @event resourceHeaderDblclick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n\n    /**\n     * Fired when activating context menu on a resource header cell\n     * @event resourceHeaderContextmenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n\n    /**\n     * Triggered when a keydown event is observed if there are selected events.\n     * @event eventKeyDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n\n    /**\n     * Triggered when a keyup event is observed if there are selected events.\n     * @event eventKeyUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n\n    //endregion\n\n    //region Functions injected by features\n\n    // For documentation & typings purposes\n\n    /**\n     * Opens an editor UI to edit the passed event.\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/EventEdit EventEdit} feature is enabled.*\n     *\n     * @function editEvent\n     * @param {Scheduler.model.EventModel} eventRecord Event to edit\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.\n     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using\n     * multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @category Feature shortcuts\n     */\n\n    /**\n     * Returns the dependency record for a DOM element\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/Dependencies Dependencies} feature is enabled.*\n     *\n     * @function resolveDependencyRecord\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     * @category Feature shortcuts\n     */\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        const me = this;\n\n        super.afterConstruct();\n\n        me.ion({ scroll : 'onVerticalScroll', thisObj : me });\n\n        if (me.createEventOnDblClick) {\n            me.ion({ scheduledblclick : me.onTimeAxisCellDblClick });\n        }\n    }\n\n    //endregion\n\n    //region Overrides\n\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onPaint() because it may be chained on instance and Override won't be applied\n    }\n\n    //endregion\n\n    //region Config getters/setters\n\n    // Placeholder getter/setter for mixins, please make any changes needed to SchedulerStores#store instead\n    get store() {\n        return super.store;\n    }\n\n    set store(store) {\n        super.store = store;\n    }\n\n    /**\n     * Returns an object defining the range of visible resources\n     * @property {Object}\n     * @property {Scheduler.model.ResourceModel} visibleResources.first First visible resource\n     * @property {Scheduler.model.ResourceModel} visibleResources.last Last visible resource\n     * @readonly\n     * @category Resources\n     */\n    get visibleResources() {\n        const me = this;\n\n        if (me.isVertical) {\n            return me.currentOrientation.visibleResources;\n        }\n\n        return {\n            first : me.store.getById(me.firstVisibleRow?.id),\n            last  : me.store.getById(me.lastVisibleRow?.id)\n        };\n    }\n\n    //endregion\n\n    //region Event handlers\n\n    onLocaleChange() {\n        this.currentOrientation.onLocaleChange();\n\n        super.onLocaleChange();\n    }\n\n    onTimeAxisCellDblClick({ date : startDate, resourceRecord, row }) {\n        this.createEvent(startDate, resourceRecord, row);\n    }\n\n    onVerticalScroll({ scrollTop }) {\n        this.currentOrientation.updateFromVerticalScroll(scrollTop);\n    }\n\n    /**\n     * Called when new event is created.\n     * an be overridden to supply default record values etc.\n     * @param {Scheduler.model.EventModel} eventRecord Newly created event\n     * @category Scheduled events\n     */\n    onEventCreated(eventRecord) {}\n\n    //endregion\n\n    //region Mode\n\n    /**\n     * Checks if scheduler is in horizontal mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isHorizontal() {\n        return this.mode === 'horizontal';\n    }\n\n    /**\n     * Checks if scheduler is in vertical mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n\n    /**\n     * Get mode (horizontal/vertical)\n     * @property {'horizontal'|'vertical'}\n     * @readonly\n     * @category Common\n     */\n    get mode() {\n        return this._mode;\n    }\n\n    set mode(mode) {\n        const me = this;\n\n        me._mode = mode;\n\n        if (!me[mode]) {\n            me.element.classList.add(`b-sch-${mode}`);\n\n            if (mode === 'horizontal') {\n                me.horizontal = new HorizontalRendering(me);\n                if (me.isPainted) {\n                    me.horizontal.init();\n                }\n            }\n            else if (mode === 'vertical') {\n                me.vertical = new VerticalRendering(me);\n\n                if (me.rendered) {\n                    me.vertical.init();\n                }\n            }\n        }\n    }\n\n    get currentOrientation() {\n        return this[this.mode];\n    }\n\n    //endregion\n\n    //region Dom event dummies\n\n    // this is ugly, but needed since super cannot be called from SchedulerDomEvents mixin...\n\n    onElementKeyDown(event) {\n        return super.onElementKeyDown(event);\n    }\n\n    onElementKeyUp(event) {\n        return super.onElementKeyUp(event);\n    }\n\n    onElementMouseOver(event) {\n        return super.onElementMouseOver(event);\n    }\n\n    onElementMouseOut(event) {\n        return super.onElementMouseOut(event);\n    }\n\n    //endregion\n\n    //region Feature hooks\n\n    // Called for each event during drop\n    processEventDrop() {}\n    processCrossSchedulerEventDrop() {}\n\n    // Called before event drag starts\n    beforeEventDragStart() {}\n\n    // Called after event drag starts\n    afterEventDragStart() {}\n\n    // Called after aborting a drag\n    afterEventDragAbortFinalized() {}\n\n    // Called during event drag validation\n    checkEventDragValidity() {}\n\n    // Called after event resizing starts\n    afterEventResizeStart() {}\n\n    //endregion\n\n    //region Scheduler specific date mapping functions\n\n    get hasEventEditor() {\n        return Boolean(this.eventEditingFeature);\n    }\n\n    get eventEditingFeature() {\n        const {\n            eventEdit,\n            taskEdit,\n            simpleEventEdit\n        } = this.features;\n\n        return eventEdit?.enabled\n            ? eventEdit\n            : taskEdit?.enabled\n                ? taskEdit\n                : simpleEventEdit?.enabled ? simpleEventEdit : null;\n    }\n\n    // Method is chained by event editing features. Ensure that the event is in the store.\n    editEvent(eventRecord, resourceRecord, element) {\n        const\n            me = this,\n            {\n                eventStore,\n                assignmentStore\n            } = me;\n\n        // Abort the chain if no event editing features available\n        if (!me.hasEventEditor) {\n            return false;\n        }\n\n        if (eventRecord.eventStore !== eventStore) {\n            const\n                { enableEventAnimations } = me,\n                resourceRecords           = [];\n\n            // It's only a provisional event because we are going to edit it which will\n            // allow an opportunity to cancel the add (by removing it).\n            eventRecord.isCreating = true;\n\n            let assignmentRecords = [];\n\n            if (resourceRecord) {\n                resourceRecords.push(resourceRecord);\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n\n            // Vetoable beforeEventAdd allows cancel of this operation\n            if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n                // Remove any assignment created above, to leave store as it was\n                assignmentStore?.remove(assignmentRecords);\n\n                return false;\n            }\n\n            me.enableEventAnimations = false;\n            eventStore.add(eventRecord);\n            me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n\n            // Element must be created synchronously, not after the project's normalizing delays.\n            me.refreshRows();\n        }\n    }\n\n    /**\n     * Creates an event on the specified date, for the specified resource which conforms to this\n     * scheduler's {@link #config-createEventOnDblClick} setting.\n     *\n     * NOTE: If the scheduler is readonly, or resource type is invalid (group header), or if `allowOverlap` is `false`\n     * and slot is already occupied - no event is created.\n     *\n     * This method may be called programmatically by application code if the `createEventOnDblClick` setting\n     * is `false`, in which case the default values for `createEventOnDblClick` will be used.\n     *\n     * If the {@link Scheduler.feature.EventEdit} feature is active, the new event\n     * will be displayed in the event editor.\n     * @param {Date} date The date to add the event at.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource to create the event for.\n     * @category Scheduled events\n     */\n    async createEvent(startDate, resourceRecord) {\n        const\n            me                    = this,\n            {\n                enableEventAnimations,\n                eventStore,\n                assignmentStore,\n                hasEventEditor\n            }                     = me,\n            resourceRecords       = [resourceRecord],\n            useEventModelDefaults = me.createEventOnDblClick.useEventModelDefaults,\n            defaultDuration       = useEventModelDefaults ? eventStore.modelClass.defaultValues.duration : 1,\n            defaultDurationUnit   = useEventModelDefaults ? eventStore.modelClass.defaultValues.durationUnit : me.timeAxis.unit,\n            eventRecord           = eventStore.createRecord({\n                startDate,\n                endDate      : DateHelper.add(startDate, defaultDuration, defaultDurationUnit),\n                duration     : defaultDuration,\n                durationUnit : defaultDurationUnit,\n                name         : me.L('L{Object.newEvent}')\n            });\n\n        if (me.readOnly || resourceRecord.isSpecialRow || resourceRecord.readOnly || (!me.allowOverlap && !me.isDateRangeAvailable(\n            eventRecord.startDate,\n            eventRecord.endDate,\n            null,\n            resourceRecord\n        ))) {\n            return;\n        }\n\n        me.eventEditingFeature?.captureStm(true);\n\n        // It's only a provisional event if there is an event edit feature available to\n        // cancel the add (by removing it). Otherwise it's a definite event creation.\n        eventRecord.isCreating = hasEventEditor;\n\n        me.onEventCreated(eventRecord);\n\n        const assignmentRecords = assignmentStore?.assignEventToResource(eventRecord, resourceRecord);\n\n        /**\n         * Fires before an event is added. Can be triggered by schedule double click or drag create action.\n         * @event beforeEventAdd\n         * @param {Scheduler.view.Scheduler} source The Scheduler instance\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be added\n         * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records\n         * @preventable\n         */\n        if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            // Remove any assignment created above, to leave store as it was\n            assignmentStore?.remove(assignmentRecords);\n\n            me.eventEditingFeature?.freeStm(false);\n\n            return;\n        }\n\n        me.enableEventAnimations = false;\n        eventStore.add(eventRecord);\n        me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        me.isCreating = true;\n        me.refreshRows();\n        me.isCreating = false;\n\n        /**\n         * Fired when a double click or drag gesture has created a new event and added it to the event store.\n         * @event eventAutoCreated\n         * @param {Scheduler.view.Scheduler} source This Scheduler.\n         * @param {Scheduler.model.EventModel} eventRecord The new event record.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The resource assigned to the new event.\n         */\n        me.trigger('eventAutoCreated', {\n            eventRecord,\n            resourceRecord\n        });\n\n        if (hasEventEditor) {\n            me.editEvent(eventRecord, resourceRecord, me.getEventElement(eventRecord));\n        }\n    }\n\n    /**\n     * Checks if a date range is allocated or not for a given resource.\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)\n     * @param {Scheduler.model.ResourceModel} resource The resource\n     * @returns {Boolean} True if the timespan is available for the resource\n     * @category Dates\n     */\n    isDateRangeAvailable(start, end, excludeEvent, resource) {\n        return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);\n    }\n    //endregion\n\n    /**\n     * Suspends UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * @function suspendRefresh\n     * @category Rendering\n     */\n\n    /**\n     * Resumes UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * Specify `true` as the first param to trigger a refresh if this call unblocked the refresh suspension.\n     * If the underlying project is calculating changes, the refresh will be postponed until it is done.\n     *\n     * @param {Boolean} trigger `true` to trigger a refresh, if this resume unblocks suspension\n     * @category Rendering\n     */\n    async resumeRefresh(trigger) {\n        super.resumeRefresh(false);\n\n        const me = this;\n\n        if (!me.refreshSuspended && trigger) {\n            // Do not refresh until project is in a valid state\n            if (!me.isEngineReady) {\n                // Refresh will happen because of the commit, bail out of this one after forcing rendering to consider\n                // next one a full refresh\n                me.currentOrientation.refreshAllWhenReady = true;\n                return me.project.commitAsync();\n            }\n\n            // View could've been destroyed while we waited for engine\n            if (!me.isDestroyed) {\n                // If it already is, refresh now\n                me.refreshWithTransition();\n            }\n        }\n    }\n\n    //region Appearance\n\n    // Overrides grid to take crudManager loading into account\n    toggleEmptyText() {\n        const\n            me = this;\n\n        if (me.bodyContainer) {\n            DomHelper.toggleClasses(me.bodyContainer, 'b-grid-empty', !(me.resourceStore.count > 0 || me.crudManager?.isLoading));\n        }\n    }\n\n    // Overrides Grids base implementation to return a correctly calculated height for the row. Also stores it in\n    // RowManagers height map, which is used to calculate total height etc.\n    getRowHeight(resourceRecord) {\n        if (this.isHorizontal) {\n            const height = this.currentOrientation.calculateRowHeight(resourceRecord);\n            this.rowManager.storeKnownHeight(resourceRecord.id, height);\n            return height;\n        }\n    }\n\n    // Calculates the height for specified rows. Call when changes potentially makes its height invalid\n    calculateRowHeights(resourceRecords, silent = false) {\n        // Array allowed to have nulls in it for easier code when calling this fn\n        resourceRecords.forEach(resourceRecord => resourceRecord && this.getRowHeight(resourceRecord));\n\n        if (!silent) {\n            this.rowManager.estimateTotalHeight(true);\n        }\n    }\n\n    // Calculate heights for all rows (up to the preCalculateHeightLimit)\n    calculateAllRowHeights(silent = false) {\n        const\n            { store, rowManager } = this,\n            count                 = Math.min(store.count, this.preCalculateHeightLimit);\n\n        // Allow opt out by specifying falsy value.\n        if (count) {\n            rowManager.clearKnownHeights();\n\n            for (let i = 0; i < count; i++) {\n                // This will both calculate and store the height\n                this.getRowHeight(store.getAt(i));\n            }\n\n            // Make sure height is reflected on scroller etc.\n            if (!silent) {\n                rowManager.estimateTotalHeight(true);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Calendar Mode Interface\n\n    // These are all internal and match up w/CalendarMixin\n\n    /**\n     * Returns the date or ranges of included dates as an array. If only the {@link #config-startDate} is significant,\n     * the array will have that date as its only element. Otherwise, a range of dates is returned as a two-element\n     * array with `[0]` is the {@link #config-startDate} and `[1]` is the {@link #property-lastDate}.\n     * @member {Date[]}\n     * @internal\n     */\n    get dateBounds() {\n        const\n            me  = this,\n            ret = [me.startDate];\n\n        if (me.range === 'week') {\n            ret.push(me.lastDate);\n        }\n\n        return ret;\n    }\n\n    get defaultDescriptionFormat() {\n        return descriptionFormats[this.range];\n    }\n\n    /**\n     * The last day that is included in the date range. This is different than {@link #config-endDate} since that date\n     * is not inclusive. For example, an `endDate` of 2022-07-21 00:00:00 indicates that the time range ends at that\n     * time, and so 2022-07-21 is _not_ in the range. In this example, `lastDate` would be 2022-07-20 since that is the\n     * last day included in the range.\n     * @member {Date}\n     * @internal\n     */\n    get lastDate() {\n        const lastDate = this.endDate;\n\n        // endDate is \"exclusive\" because it means 00:00:00 of that day, so subtract 1\n        // to keep description consistent with human expectations.\n        return lastDate && DateHelper.add(lastDate, -1, 'day');\n    }\n\n    getEventRecord(target) {\n        target = DomHelper.getEventElement(target);\n\n        return this.resolveEventRecord(target);\n    }\n\n    getEventElement(eventRecord) {\n        return this.getElementFromEventRecord(eventRecord);\n    }\n\n    changeRange(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n\n    updateRange(unit) {\n        if (!this.isConfiguring) {\n            const\n                currentDate = this.date,\n                newDate     = this.date = DateHelper.startOf(currentDate, unit);\n\n            // Force a span update if changing the range did not change the date\n            if (currentDate.getTime() === newDate.getTime()) {\n                this.updateDate(newDate);\n            }\n        }\n    }\n\n    changeStepUnit(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n\n    updateDate(newDate) {\n        const\n            me    = this,\n            start = DateHelper.startOf(newDate, me.range);\n\n        me.setTimeSpan(start, DateHelper.add(start, 1, me.range));\n\n        // Cant always use newDate here in case timeAxis is filtered\n        me.visibleDate = {\n            date    : DateHelper.max(newDate, me.timeAxis.startDate),\n            block   : 'start',\n            animate : true\n        };\n\n        me.trigger('descriptionChange');\n    }\n\n    previous() {\n        this.date = DateHelper.add(this.date, -1, this.stepUnit);\n    }\n\n    next() {\n        this.date = DateHelper.add(this.date, 1, this.stepUnit);\n    }\n\n    //endregion\n\n    /**\n     * Assigns and schedules an unassigned event record (+ adds it to this Scheduler's event store unless already in it).\n     * @param {Object} config The config containing data about the event record to schedule\n     * @param {Date} config.startDate The start date\n     * @param {Scheduler.model.EventModel|EventModelConfig} config.eventRecord Event (or data for it) to assign and schedule\n     * @param {Scheduler.model.EventModel} [config.parentEventRecord] Parent event to add the event to (to nest it),\n     * only applies when using the NestedEvents feature\n     * @param {Scheduler.model.ResourceModel} config.resourceRecord Resource to assign the event to\n     * @param {HTMLElement} [config.element] The element if you are dragging an element from outside the scheduler\n     * @category Scheduled events\n     */\n    async scheduleEvent({ startDate, eventRecord, resourceRecord, element }) {\n        const me = this;\n\n        // NestedEvents has an override for this function to handle parentEventRecord\n\n        if (!me.eventStore.includes(eventRecord)) {\n            [eventRecord] = me.eventStore.add(eventRecord);\n        }\n\n        eventRecord.startDate = startDate;\n        eventRecord.assign(resourceRecord);\n\n        if (element) {\n            const eventRect = Rectangle.from(element, me.foregroundCanvas);\n\n            // Clear translate styles used by DragHelper\n            DomHelper.setTranslateXY(element, 0, 0);\n            DomHelper.setTopLeft(element, eventRect.y, eventRect.x);\n\n            DomSync.addChild(me.foregroundCanvas, element, eventRecord.assignments[0].id);\n        }\n\n        await me.project.commitAsync();\n    }\n}\n\n// Register this widget type with its Factory\nSchedulerBase.initClass();\n\n// Scheduler version is specified in TimelineBase because Gantt extends it\n"],
  "mappings": "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",
  "names": ["VerticalTimeAxis", "TimeAxisBase", "$name", "configurable", "cls", "sizeProperty", "positionProperty", "wrapText", "buildHorizontalCells", "me", "client", "stickyHeaders", "featureHeaderConfigs", "cellConfigs", "levels", "reduce", "result", "level", "i", "cells", "_level$cells", "push", "filter", "cell", "start", "endDate", "end", "startDate", "map", "j", "role", "className", "headerCellCls", "align", "length", "dataset", "tickIndex", "index", "cellId", "headerPosition", "globalThis", "DEBUG", "date", "getTime", "style", "top", "coord", "height", "width", "minHeight", "children", "html", "value", "getHeaderDomConfigs", "widgetClassList", "headerFeature", "syncOptions", "releaseThreshold", "syncIdField", "size", "_$name", "VerticalTimeAxisColumn", "Column", "type", "defaults", "draggable", "groupable", "hideable", "showColumnPicker", "filterable", "sortable", "searchable", "editor", "enableCellContextMenu", "tooltipRenderer", "minWidth", "resizable", "cellCls", "locked", "flex", "alwaysClearCell", "isFocusable", "construct", "data", "arguments", "view", "model", "grid", "timeAxisViewModel", "renderer", "cellElement", "render", "getCurrentConfig", "options", "id", "region", "field", "ariaLabel", "cellAriaLabel", "__publicField", "ColumnStore", "registerColumnType", "HorizontalLayout", "Base", "defaultConfig", "nbrOfBandsByResource", "bandIndexToPxConvertFn", "bandIndexToPxConvertThisObj", "clearCache", "resource", "applyLayout", "events", "layoutEventsInBands", "Error", "HorizontalLayoutPack", "mixin", "PackMixin", "packEventsInBands", "event", "slot", "slotSize", "forEach", "Object", "assign", "call", "eventRecord", "resourceRecord", "HorizontalLayoutStack", "heightRun", "verticalPosition", "eventIndex", "splice", "findClosestSuccessor", "eventRenderData", "endMS", "group", "isMilestone", "duration", "minGap", "Infinity", "closest", "gap", "l", "startMS", "grouped", "ResourceTimeRangesBase", "InstancePlugin", "AttachToProjectMixin", "pluginConfig", "chain", "override", "noFeatureElementsInAxis", "timeAxis", "needsRefresh", "store", "storage", "values", "some", "t", "isTimeSpanInAxis", "doDisable", "disable", "isPainted", "refresh", "updateTabIndex", "isConfiguring", "getEventsToRender", "onEventDataGenerated", "renderData", "iconCls", "shouldInclude", "isVertical", "columnWidth", "resourceColumnWidth", "fillSize", "wrapperCls", "rangeCls", "timeRangeColor", "eventContent", "text", "name", "tabIndex", "String", "unshift", "tag", "toString", "eventId", "generateElementId", "record", "domId", "resolveResourceTimeRangeRecord", "rangeElement", "_rangeElement$closest", "elementData", "getElementFromResourceTimeRangeRecord", "foregroundCanvas", "syncIdMap", "resolveResourceRecord", "_this$resolveResource", "overridden", "target", "onStoreChange", "action", "onInternalEventStoreChange", "matchScheduleCell", "enableMouseEvents", "getCell", "isHorizontal", "first", "column", "timeAxisColumn", "handleRangeMouseEvent", "domEvent", "eventName", "EventHelper", "eventNameMap", "StringHelper", "capitalize", "resourceTimeRangeRecord", "trigger", "entityName", "feature", "resourceStore", "getById", "resourceId", "updateEnableMouseEvents", "enable", "_me$mouseEventsDetach", "mouseEventsDetacher", "attachMouseEvents", "on", "element", "delegate", "mousedown", "mouseup", "click", "dblclick", "contextmenu", "mouseover", "mouseout", "thisObj", "whenVisible", "classList", "toggle", "Boolean", "featureClass", "DependencyEditor", "Popup", "items", "handleSelector", "axisLock", "processWidgetConfig", "widget", "dependencyEditFeature", "ref", "showLagField", "showDeleteButton", "afterShow", "args", "deleteButton", "widgetMap", "hidden", "isPartOfStore", "onInternalKeyDown", "DependencyEdit", "autoClose", "saveAndCloseOnEnter", "triggerEvent", "dependencyRecord", "editorConfig", "title", "localeClass", "closable", "fromNameField", "weight", "label", "toNameField", "typeField", "editable", "valueField", "displayField", "localizeDisplayFields", "buildItems", "dialog", "parent", "keys", "DependencyModel", "Type", "L", "localeKey", "lagField", "allowNegative", "bbar", "foo", "saveButton", "color", "cancelButton", "config", "dependencyEdit", "features", "dependencies", "clientListenersDetacher", "ion", "onActivateEditor", "doDestroy", "_this$editor", "destroy", "changeEditorConfig", "ObjectHelper", "owner", "autoShow", "anchor", "scrollAction", "clippedBy", "timeAxisSubGridElement", "bodyContainer", "constrainTo", "isValid", "every", "eachWidget", "onBeforeSave", "onAfterSave", "updateRecord", "lag", "lagUnit", "unit", "magnitude", "fromSide", "toSide", "cleanupProperties", "set", "onPopupKeyDown", "key", "tagName", "toLowerCase", "preventDefault", "onSaveClick", "save", "hide", "onDeleteClick", "deleteDependency", "onCancelClick", "internalShowEditor", "showPoint", "lastPointerDownCoordinate", "getEditor", "loadRecord", "center", "Rectangle", "from", "x", "y", "showBy", "editDependency", "readOnly", "_me$saveButton", "_me$deleteButton", "_me$cancelButton", "new", "rootElement", "internalListeners", "keydown", "console", "warn", "dependency", "fromEvent", "toEvent", "Duration", "dependencyStore", "_client$project", "stores", "add", "project", "commitAsync", "_client$project2", "containsFocus", "revertFocus", "remove", "disabled", "clientX", "clientY", "GridFeatureManager", "registerFeature", "ScheduleContext", "Delayable", "listeners", "datachange", "timeaxisviewmodelupdate", "presetchange", "timelineContextChange", "schedulecontextmenu", "useBackgroundCanvas", "rowManager", "rowheight", "changeTriggerEvent", "_element", "DomHelper", "createElement", "backgroundCanvas", "onTimelineContextChange", "context", "onScheduleContextGesture", "onTimeAxisViewModelUpdate", "source", "_this$context", "includes", "tick", "syncContextElement", "clearContext", "updateContext", "oldContext", "enabled", "row", "rows", "getRowFor", "tickStartDate", "tickEndDate", "currentOrientation", "getTimeSpanRenderData", "startDateMS", "endDateMS", "resourceWidth", "display", "setTranslateXY", "left", "innerHTML", "callback", "delayable", "$config", "equal", "c1", "c2", "tickParentIndex", "EventCopyPaste", "clipboardRecords", "scheduler", "eventclick", "onEventClick", "scheduleclick", "onScheduleClick", "projectChange", "clearClipboard", "_cellClickedContext", "eventData", "assignmentRecord", "meta", "isCut", "isActionAvailable", "_this$client$focusedC", "cellEdit", "getSelection", "isEditing", "focusedCell", "isSpecialRow", "copy", "copyEvents", "cut", "undefined", "paste", "pasteEvents", "records", "selectedAssignments", "assignmentRecords", "slice", "isEventModel", "r", "assignments", "flat", "a", "eventRecords", "_isCut", "clipboard", "assignmentStore", "assignment", "refreshWithTransition", "reason", "$original", "allowOverlap", "isDateRangeAvailable", "toFocus", "pastedEvents", "Set", "pastedEventRecords", "targetResourceRecord", "targetDate", "has", "eventStore", "usesSingleAssignment", "copyPasteAction", "generateNewName", "last", "resources", "newAssignmentRecord", "constraintDate", "detacher", "renderEvent", "navigateTo", "scrollIntoView", "populateEventMenu", "copyEvent", "icon", "onItem", "isAssignmentSelected", "cutEvent", "populateScheduleMenu", "pasteEvent", "count", "originalName", "nameField", "counter", "findRecord", "keyMap", "EventDrag", "DragBase", "constrainDragToResource", "constrainDragToTimeSlot", "externalDropTargetSelector", "validatorFn", "validatorFnThisObj", "unifiedDrag", "snapToPosition", "copyKey", "copyMode", "mode", "capitalizedEventName", "afterConstruct", "changeMode", "dragData", "isRecurring", "updateMode", "setCopying", "setMoving", "eventBarCopies", "el", "isConnected", "grabbedParent", "appendChild", "retainElement", "onAfterDragStart", "handleKeyDownOrMove", "keyEventDetacher", "getRootElement", "keyup", "handleKeyUp", "onDragReset", "_this$keyEventDetache", "onDrop", "_this$dragData$eventB", "getDraggableElement", "drag", "targetSelector", "resolveEventRecord", "eventElement", "isElementDraggable", "_client", "matches", "isDraggable", "getTriggerParams", "browserEvent", "triggerBeforeEventDrag", "eventType", "triggerEventDrag", "newResource", "triggerDragStart", "navigator", "skipNextClick", "triggerDragAbort", "triggerDragAbortFinalized", "triggerAfterDrop", "valid", "currentOverClient", "initialAssignmentsState", "find", "_me$dragData$assignme", "setTimeout", "specialKeyFromEventKey", "isValidDrop", "sourceRecord", "draggedEntities", "constrainDragToTimeline", "checkDragValidity", "_dragData$newResource", "message", "_scheduler$checkEvent", "updateRecords", "fromScheduler", "toScheduler", "copyKeyPressed", "timeDiff", "originalStartDate", "droppedStartDate", "adjustStartDate", "externalDropTarget", "timeSpanInAxis", "DateHelper", "durationMS", "suspendAutoCommit", "updateAssignments", "resumeAutoCommit", "isCopy", "targetEventRecord", "isCrossScheduler", "fromAssignmentStore", "fromEventStore", "toAssignmentStore", "toEventStore", "fromResourceStore", "toResourceStore", "fromResource", "toResource", "useSingleAssignment", "effectiveCopyMode", "event1Date", "eventsToAdd", "eventsToRemove", "assignmentsToAdd", "assignmentsToRemove", "eventsToCheck", "eventsToBatch", "resourcesInStore", "getAllDataRecords", "suspendRefresh", "updated", "updatedEvent", "indexDiff", "indexOf", "constainDragToResource", "isGrouped", "draggedEvent", "eventBar", "eventBarEls", "instanceMeta", "hasTemporaryDragElement", "transient", "addedEvents", "copiedAssignmentsMap", "originalAssignment", "draggedAssignment", "isOccurrenceAssignment", "initialState", "originalEventRecord", "originalResourceRecord", "newStartDate", "keepEvent", "newAssignment", "createRecord", "calendar", "reassignedFrom", "draggedEventResourceIndex", "getAt", "_newResource", "newIndex", "Math", "max", "min", "getNext", "getPrevious", "isCrossResource", "setData", "shouldCopyEvent", "endDateCached", "isEvent", "isOccurrence", "ev", "isEqual", "isBatchUpdating", "endBatch", "processEventDrop", "relatedElements", "entries", "originalId", "cloneRecord", "originalDraggedEvent", "inTimeAxis", "isInTimeAxis", "DomSync", "removeChild", "parentElement", "isRoot", "elRect", "setTopLeft", "addChild", "processCrossSchedulerEventDrop", "added", "beginBatch", "Promise", "all", "resumeRefresh", "lastDomConfig", "selectedEvents", "getProductDragContext", "previousResolvedResource", "previousTargetEventRecord", "resolveResource", "isOverNewResource", "dirty", "proxyElements", "getMinimalDragData", "info", "getElementFromContext", "resolveAssignmentRecord", "startEvent", "ctrlKey", "multiEventSelect", "apply", "getRelatedRecords", "setupProductDragData", "_dateConstraints", "dateConstraints", "_me$getDateConstraint", "getDateConstraints", "constrainRectangle", "getConstrainingRectangle", "eventRegion", "setupConstraints", "snapPixelAmount", "eventBarEl", "getElementFromAssignmentRecord", "addTemporaryDragElement", "createProxy", "_scheduler$getDateCon", "externalDateConstraints", "minDate", "maxDate", "dateRange", "getScheduleRegion", "getDragData", "selectedRecord", "getCoordinate", "milestoneLayoutMode", "milestoneAlign", "offsetWidth", "offsetHeight", "dragProxy", "pageRect", "localRect", "lx", "ly", "eventTarget", "getMouseMoveEventTarget", "contains", "getRowAt", "dataIndex", "querySelector", "roundDate", "Date", "snapRelativeToEventStartDate", "constrainStartDate", "getRecordElement", "getProxyElement", "isDragging", "EventDragCreate", "DragCreateBase", "updateLockLayout", "lock", "dragActiveCls", "handleBeforeDragCreate", "isAvailable", "isWorkingTime", "isSchedulerPro", "ignoreResourceCalendar", "mousedownDate", "dragStart", "_client$onEventCreate", "enableEventAnimations", "createEventRecord", "resourceRecords", "diff", "durationUnit", "isCreating", "isDragCreating", "taskEdit", "doCancel", "captureStm", "assignEventToResource", "lockLayout", "excludeFromLayout", "onEventCreated", "addAsync", "then", "refreshRows", "itemElement", "getElementFromEventRecord", "isInView", "scrollable", "animate", "edgeOffset", "barMargin", "checkValidity", "dragging", "createValidatorFn", "isRowEmpty", "getEventsForResource", "triggerBeforeFinalize", "dimension", "weekStartDay", "draggingEnd", "eventConfig", "modelClass", "fieldMap", "defaultValue", "floor", "resolution", "ceil", "isGanttProjectMixin", "constraintType", "internalUpdateRecord", "hasEventEditor", "finalizeDragCreate", "transferred", "hasStmCapture", "freeStm", "cancelDragCreate", "getTipHtml", "tip", "tooNarrow", "onAborted", "_this$store$unassignE", "_this$store", "unassignEventFromResource", "zeroOffset", "depOffset", "EventTooltip", "TooltipBase", "template", "xss", "startClockHtml", "endClockHtml", "monitorRecordUpdate", "onPaint", "firstPaint", "tooltip", "beforeAlign", "offset", "edgeAligned", "parseAlign", "depTerminalOffset", "zeroMargins", "StickyEvents", "toUpdate", "scroll", "horizontalScroll", "prio", "stickyContents", "syncEventContentPosition", "updateStyles", "onSchedulerScroll", "verticalSyncAllEventsContentPosition", "onHorizontalScroll", "subGrid", "timeAxisSubGrid", "contentEl", "applyStyle", "clear", "resourceMap", "eventsData", "elementConfig", "isResourceTimeRange", "duringGeneration", "useEventBuffer", "bufferAfterWidth", "bufferBeforeWidth", "scrollPosition", "wrapperEl", "getChild", "parseStyle", "contentSize", "contentWidth", "justify", "parentNode", "getStyleValue", "c", "eventStart", "eventEnd", "edgeSizes", "getEventContentMargins", "maxOffset", "Number", "MAX_SAFE_INTEGER", "transform", "stuck", "getEdgeSize", "TimeRanges", "AbstractTimeRanges", "_this$storeDetacher", "storeDetacher", "timeRanges", "_timeRanges", "recurringEvents", "flatMap", "timeSpan", "getOccurrencesForDateRange", "currentTimeLine", "attachToProject", "_me$projectTimeZoneCh", "projectTimeZoneChangeDetacher", "showCurrentTimeLine", "_me$client$project", "timeZoneChange", "updateCurrentTimeLine", "initCurrentTimeLine", "currentTimeInterval", "setInterval", "currentTimeLineUpdateInterval", "_me$project", "timeZone", "setLocalDate", "originalData", "format", "currentDateFormat", "renderRanges", "hideCurrentTimeLine", "clearInterval", "updateShowCurrentTimeLine", "show", "populateTimeAxisHeaderMenu", "checked", "onToggle", "attachToStore", "change", "timeRangeStore", "updateStore", "_timeRangesExposed", "attachToTimeRangeStore", "resolveTimeRangeRecord", "baseSelector", "isVisible", "runWithTransition", "refreshSuspended", "onDragStart", "rangeBodyEl", "getBodyElementByRecord", "originRangeX", "getTranslateX", "originRangeY", "getTranslateY", "showTip", "onInvalidDrop", "box", "newStart", "getDateFromCoordinate", "getStart", "rtl", "setStartDate", "destroyTip", "onResizeStart", "onResizeDrag", "edge", "setTranslateY", "newY", "newHeight", "setTranslateX", "newX", "newWidth", "onResize", "startPos", "endPos", "getEnd", "isStart", "newEnd", "setEndDate", "onInvalidResize", "resize", "reset", "TimeSpan", "SchedulerDom", "Target", "returnWrapper", "_this$foregroundCanva", "_wrapper", "_wrapper$syncIdMap", "wrapper", "hasLinks", "link", "$links", "_this$foregroundCanva2", "_eventRecord$resource", "_this$foregroundCanva3", "getAssignmentForEventAndResource", "getElementsFromEventRecord", "elementOrEvent", "xy", "resolveRowRecord", "_elementOrEvent", "Event", "eventSelector", "assignmentId", "resolveTimeSpanRecord", "getOccurrence", "isRowVisible", "widgetClass", "SchedulerDomEvents", "getTimeSpanMouseEventParams", "getScheduleMouseEventParams", "cellData", "onElementKeyDown", "scheduledEventName", "onElementKeyUp", "SchedulerEventRendering", "milestoneTextPosition", "milestoneCharWidth", "eventLayout", "overlappingEventSorter", "horizontalEventSorterFn", "resourceMargin", "useInitialAnimation", "eventRenderer", "eventRendererThisObj", "eventBarTextField", "eventBodyTemplate", "horizontalLayoutPackClass", "horizontalLayoutStackClass", "resourceColumns", "resourceImagePath", "defaultResourceImageName", "resourceImageExtension", "isFirstRender", "initialAnimationDuration", "narrowEventWidth", "internalEventLayout", "eventPositionMode", "eventScrollMode", "changeEventLayout", "changeInternalEventLayout", "getEventLayout", "updateInternalEventLayout", "oldEventLayout", "changeHorizontalEventSorterFn", "fn", "VersionHelper", "deprecate", "updateOverlappingEventSorter", "_value", "isModel", "getEventLayoutHandler", "horizontal", "layouts", "horizontalStack", "layoutEventVerticallyStack", "horizontalPack", "layoutEventVerticallyPack", "_this$timeAxisColumn", "_resourceColumns", "_this$resourceColumns", "repaintEventsForResource", "repaintEvent", "getResourcesForEvent", "getResourceMargin", "getBarMargin", "getResourceHeight", "rowHeight", "getResourceWidth", "getAppliedResourceHeight", "getRowById", "maxRequestedHeight", "getResourceLayoutSettings", "parentEventRecord", "contentHeight", "getEventStyle", "eventStyle", "getEventColor", "_eventRecord$event", "_eventRecord$parent", "eventColor", "generateRenderData", "includeOutside", "viewport", "eventResize", "$originalId", "taskBarFeature", "_renderData$iconCls2", "isResizable", "startsOutsideView", "endsOutsideView", "leftHandle", "rightHandle", "topHandle", "bottomHandle", "isDirty", "hasPersistableChanges", "clsListObj", "generatedIdCls", "hasGeneratedId", "dirtyCls", "committingCls", "isCommitting", "endsOutsideViewCls", "startsOutsideViewCls", "clippedStart", "clippedEnd", "wrapperClsListObj", "eventCls", "isParent", "isLinked", "clsList", "DomClassList", "internalCls", "clone", "wrapperClsList", "wrapperStyle", "isWrap", "selected", "fixedEventCls", "eventSelectedCls", "eventAssignHighlightCls", "isEventSelected", "inactive", "hasAnimation", "bryntum", "noAnimations", "scrollTop", "tickSize", "delayMS", "maxDelay", "initialAnimationDetacher", "once", "animationend", "delay", "cancelOutstanding", "expires", "alt", "get", "eventBarIconClsField", "rowId", "childContent", "milestoneLabelConfig", "rendererValue", "encodeHtml", "Array", "isArray", "_renderData$iconCls", "isHtml", "class", "isNamedColor", "colorProp", "wrapperChildren", "changeUseInitialAnimation", "updateUseInitialAnimation", "old", "BrowserHelper", "isFirefox", "restartInitialAnimation", "initialAnimation", "_me$initialAnimationD", "stopInitialAnimation", "getMilestoneLabelWidth", "milestoneMeasureElement", "fontSize", "firstElementChild", "bounds", "milestoneWidth", "updateMilestoneLayoutMode", "alwaysOutside", "updateMilestoneTextPosition", "position", "updateMilestoneAlign", "updateMilestoneCharWidth", "SchedulerStores", "ProjectConsumer", "projectStores", "dataName", "batchedUpdate", "changePreCommit", "commitStart", "commit", "exception", "idchange", "beforeLoad", "beforeRemove", "calendarManagerStore", "resourceTimeRangeStore", "startParamName", "endParamName", "passStartEndParameters", "checkVersion", "crudManagerClass", "crudManager", "updateProject", "oldProject", "detachListeners", "onProjectRefresh", "isInitialCommit", "refreshAfterProjectRefresh", "navigateToAfterRefresh", "changeCrudManager", "isCrudManager", "_crudManager", "bindCrudManager", "_store", "Store", "refreshFromRowOnStoreAdd", "isExpand", "suspended", "onStoreAdd", "calculateRowHeights", "onStoreUpdateRecord", "changes", "ignoreCount", "updateResourceStore", "metaMapId", "usesDisplayStore", "onEventIdChange", "params", "onEventStoreIdChange", "onEventStoreBatchedUpdate", "listenToBatchedUpdates", "_mode", "isAssign", "isRemovingAssignment", "onEventStoreChange", "onEventCommit", "resourcesToRepaint", "modified", "prototype", "concat", "onEventCommitStart", "toggleCls", "onEventException", "removed", "onAssignmentCommit", "repaintEventsForAssignmentChanges", "onAssignmentCommitStart", "onAssignmentException", "getResource", "onAssignmentBeforeRemove", "removingAll", "moveTo", "activeAssignment", "GlobalEvents", "lastInteractionType", "next", "focusWithoutScrolling", "focusElement", "resourceTimeRanges", "onBeforeLoad", "applyStartEndParameters", "getResourcesEventsPerTick", "filterFn", "eventsByTick", "startTick", "getTickFromDate", "endTick", "ticks", "defaultScrollOptions", "block", "unrenderedScrollOptions", "highlight", "focus", "SchedulerScroll", "scrollEventIntoView", "scrollResourceEventIntoView", "scrollAssignmentIntoView", "eventIsOutside", "isScheduled", "extendTimeAxis", "currentTimeSpanRange", "setTimeSpan", "valueOf", "infiniteScroll", "visibleDateRange", "visibleMS", "sign", "visibleDate", "tree", "_me$expandTo", "expandTo", "scroller", "forceScrollUpdate", "scrollUnrenderedEventIntoView", "scrollResourceIntoView", "resourceRec", "eventRec", "resolve", "modifiedOptions", "getResourceEventBox", "scrollerViewport", "translate", "totalSize", "scrollLeft", "onEventRender", "targetElement", "initialScrollPromise", "scrollRowIntoView", "SchedulerRegions", "local", "getResourceRegion", "getRowRegion", "getAssignmentEventBox", "includesOutside", "roughly", "getItemBox", "copyProperties", "SchedulerState", "getState", "applyState", "state", "_state$zoomLevelOptio", "propsToCopy", "zoomLevelOptions", "p", "releaseEventActions", "releaseElement", "reuseElement", "renderEventActions", "newElement", "reuseOwnElement", "MAX_WIDTH", "heightEventSorter", "lhs", "rhs", "chronoFields", "getStartEnd", "useEnd", "fieldName", "_eventRecord$hasBatch", "_eventRecord$meta", "hasBatchedChange", "fillTicks", "isResizing", "round", "HorizontalRendering", "scrollBuffer", "bufferSize", "verticalBufferSize", "properties", "Map", "rowMap", "eventConfigs", "isFirstRefresh", "toDrawOnProjectRefresh", "toDrawOnDataReady", "eventSorter", "bind", "renderDone", "removeRows", "translateRow", "offsetRows", "beforeRowHeight", "init", "updateVerticalBufferSize", "renderRows", "_visibleDateRange", "getDateFromXY", "roundingMethod", "allowOutOfRange", "translateToScheduleCoordinate", "getRtlX", "getDateFromPosition", "getBoundingClientRect", "scrollX", "maxX", "abs", "translateToPageCoordinate", "stretch", "getElement", "bottom", "scrollWidth", "taStart", "taEnd", "startX", "getCoordinateFromDate", "endX", "right", "rowRecord", "resourceData", "approx", "d", "rowBox", "getRecordCoords", "absoluteTop", "layout", "rowTop", "rowBottom", "nodeType", "Element", "TEXT_NODE", "eventNode", "getRecordFromElement", "refreshAllWhenReady", "clearAll", "clearDom", "commitFinalized", "onProjectCommitFinalized", "ignoreRecordChanges", "clearResources", "refreshResources", "isCalculated", "calculateAllRowHeights", "topRow", "reinitialize", "attachToAssignmentStore", "refreshPreCommit", "onAssignmentStoreChange", "replaced", "resourceIds", "_assignmentRecord$res", "_assignmentRecord$res2", "isRemoving", "isChangingId", "refreshResourcesWhenReady", "oldAssignment", "oldValue", "refreshResourcesOnDataReady", "onAssignmentStoreRefresh", "attachToEventStore", "onEventStoreRefresh", "isEngineReady", "isResourceTimeRangeStore", "_eventRecord$$linkedR", "renderedEventResources", "$linkedResources", "newEvent", "allChrono", "$entity", "getField", "dateChanges", "_me$project2", "propagatingLoadChanges", "isWritingData", "attachToResourceStore", "clearLayoutCache", "onResourceStoreChange", "isBatchingChanges", "isLeaf", "onTranslateRow", "refreshEventsForResource", "onOffsetRows", "doUpdateTimeView", "calculateRowHeight", "_resourceRecord$assig", "assigned", "eventFilter", "isFiltered", "getEvents", "includeOccurrences", "enableRecurringEvents", "sort", "layoutHandler", "nbrOfBandsRequired", "updateFromHorizontalScroll", "getConnectorStartSide", "getConnectorEndSide", "reLayoutEvents", "onLocaleChange", "onViewportResize", "oldWidth", "oldHeight", "onRenderDone", "onDragAbort", "useWrapper", "onRemoveRows", "delete", "onEarlyScroll", "rendererCalled", "updateFromVerticalScroll", "fromScroll", "returnEnd", "getDateFromCoord", "ignoreRTL", "_viewPresetChanging", "viewportCoords", "range", "timeView", "onVisibleDateRangeChange", "onBeforeRowHeightChange", "ids", "transition", "noRows", "bandIndex", "topFraction", "heightFraction", "domConfig", "syncId", "innerElement", "firstChild", "b", "startA", "dataStartMS", "endA", "dataEndMS", "startB", "endB", "nameA", "nameB", "calculateMS", "startDateField", "endDateField", "pxPerMinute", "getSingleUnitInPixels", "diamondSize", "diamondMS", "setupRenderData", "_scheduler$features$e", "preamble", "postamble", "isProHorizontalRendering", "eventBuffer", "timespanStart", "timespanEnd", "viewStartMS", "viewEndMS", "durationMinutes", "taskRecord", "fillTimeSpanHorizontalPosition", "calculateHorizontalPosition", "respectExclusion", "isEnd", "snapToNextIncluded", "isSafari", "stickyEvents", "continuous", "excluded", "fillTimeSpanVerticalPosition", "managedEventSizing", "includeOutsideTimeAxis", "includeOutsideViewport", "layoutEvents", "allEvents", "eventBox", "layoutEventData", "bandsRequired", "layoutResourceEvents", "resourceEvents", "layoutMode", "textPosition", "eventElementConfig", "taskFeature", "zIndex", "recordOrRow", "force", "draw", "isRow", "getResourceLayout", "resourceLayout", "invalid", "getEventDOMConfigForCurrentView", "labels", "usesLabels", "before", "after", "reusableDOMConfigs", "eventDOMConfigs", "useLeft", "useRight", "prevDomConfig", "visibleEventDOMConfigs", "bodyTop", "_scrollTop", "viewTop", "viewBottom", "_bodyRectangle", "unbuffered", "unmanagedSize", "sync", "onlyChildren", "jsx", "_scheduler$processEve", "_domConfig$elementDat", "reactComponent", "isRelease", "isRender", "processEventContent", "_scheduler$processEve2", "getActiveElement", "isReusingElement", "isRepaint", "recordsOrIds", "ArrayHelper", "asArray", "Model", "asId", "cached", "child", "VerticalLayout", "coordProp", "sizeProp", "columnIndex", "layoutType", "tplData", "clusterIndex", "widthFactor", "leftFactor", "packColumnCount", "packColumnIndex", "availableWidth", "emptyObject", "freeze", "VerticalRendering", "eventMap", "releasedElements", "resourceBufferSize", "verticalLayout", "columnWidthChange", "initialized", "coords", "borderOffsetX", "borderOffsetY", "variableColumnWidths", "totalWidth", "col", "allResourceRecords", "_this$eventMap$get", "scrollY", "_this$eventMap$get2", "_this$eventMap$get3", "_this$eventMap$get3$r", "startY", "endY", "scrollPos", "clientHeight", "onResourceColumnWidthChange", "rendered", "refreshAllResourcesWhenReady", "changeCount", "shouldWaitForInitializeAndEngineReady", "load", "unmaskBody", "firstResource", "lastResource", "_allResourceRecords", "firstIndex", "onResourceStoreRefresh", "refreshFromRerender", "renderResource", "prevScrollX", "scrollHorizontallyTo", "_this$scheduler$timeA", "updateElementId", "releaseTimeSpanDiv", "resourceRange", "getResourceRange", "visibleResources", "withBuffer", "viewportStart", "viewportEnd", "insetStart", "bottomDate", "bodyHeight", "virtualScrollHeight", "scrollHeight", "topDate", "isProVerticalRendering", "dataStartMs", "dataEndMs", "cacheKey", "cache", "resourceIndex", "layoutData", "toLayout", "eventResources", "getMapPath", "internalStyle", "topDateMS", "bottomDateMS", "resourceEntry", "_eventData$elementCon", "isEventElement", "syncConfigs", "featureDomConfigs", "getForegroundDomConfigs", "isReleased", "reusingElement", "onVisibleResourceRangeChange", "descriptionFormats", "month", "week", "day", "SchedulerBase", "TimelineBase", "CrudManagerView", "Describable", "EventSelection", "EventNavigation", "CurrentConfig", "timeCellSelector", "resourceTimeRangeSelector", "stepUnit", "verticalTimeAxisColumn", "createEventOnDblClick", "schedulableAreaSelector", "sortFeatureStore", "timeCellCls", "overScheduledEventClass", "preCalculateHeightLimit", "CrudManager", "testConfig", "loadMaskError", "showDelay", "scheduledblclick", "onTimeAxisCellDblClick", "onPaintOverride", "_me$firstVisibleRow", "_me$lastVisibleRow", "firstVisibleRow", "lastVisibleRow", "createEvent", "onVerticalScroll", "vertical", "onElementMouseOver", "onElementMouseOut", "beforeEventDragStart", "afterEventDragStart", "afterEventDragAbortFinalized", "checkEventDragValidity", "afterEventResizeStart", "eventEditingFeature", "eventEdit", "simpleEventEdit", "editEvent", "_me$eventEditingFeatu", "useEventModelDefaults", "defaultDuration", "defaultValues", "defaultDurationUnit", "_me$eventEditingFeatu2", "getEventElement", "excludeEvent", "isDestroyed", "toggleEmptyText", "_me$crudManager", "toggleClasses", "isLoading", "getRowHeight", "storeKnownHeight", "silent", "estimateTotalHeight", "clearKnownHeights", "dateBounds", "ret", "lastDate", "defaultDescriptionFormat", "getEventRecord", "changeRange", "normalizeUnit", "updateRange", "currentDate", "newDate", "startOf", "updateDate", "changeStepUnit", "previous", "scheduleEvent", "eventRect", "initClass"]
}
