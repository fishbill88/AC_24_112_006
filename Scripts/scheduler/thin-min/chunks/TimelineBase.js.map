{
  "version": 3,
  "sources": ["../../../../chronograph/src/class/Base.js", "../../../../Engine/lib/Engine/calendar/CalendarCacheIntervalMultiple.js", "../../../../Engine/lib/Engine/calendar/CalendarCacheMultiple.js", "../../../../Scheduler/lib/Scheduler/column/DurationColumn.js", "../../../../Scheduler/lib/Scheduler/view/TimeAxisBase.js", "../../../../Scheduler/lib/Scheduler/view/HorizontalTimeAxis.js", "../../../../Scheduler/lib/Scheduler/view/ResourceHeader.js", "../../../../Scheduler/lib/Scheduler/column/TimeAxisColumn.js", "../../../../Scheduler/lib/Scheduler/preset/ViewPreset.js", "../../../../Scheduler/lib/Scheduler/preset/PresetStore.js", "../../../../Scheduler/lib/Scheduler/preset/PresetManager.js", "../../../../Scheduler/lib/Scheduler/data/TimeAxis.js", "../../../../Scheduler/lib/Scheduler/feature/base/DragBase.js", "../../../../Scheduler/lib/Scheduler/feature/EventResize.js", "../../../../Scheduler/lib/Scheduler/feature/base/DragCreateBase.js", "../../../../Scheduler/lib/Scheduler/feature/base/TooltipBase.js", "../../../../Scheduler/lib/Scheduler/feature/AbstractTimeRanges.js", "../../../../Scheduler/lib/Scheduler/feature/ColumnLines.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyCreation.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyGridCache.js", "../../../../Scheduler/lib/Scheduler/util/RectangularPathFinder.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyLineGenerator.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/Dependencies.js", "../../../../Scheduler/lib/Scheduler/feature/EventFilter.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/NonWorkingTimeMixin.js", "../../../../Scheduler/lib/Scheduler/feature/NonWorkingTime.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/TimeAxisHeaderMenu.js", "../../../../Scheduler/lib/Scheduler/view/model/TimeAxisViewModel.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDateMapper.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDomEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineViewPresets.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineZoomable.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineEventRendering.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineScroll.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineState.js", "../../../../Scheduler/lib/Scheduler/view/Header.js", "../../../../Scheduler/lib/Scheduler/view/TimeAxisSubGrid.js", "../../../../Scheduler/lib/Scheduler/view/TimelineBase.js"],
  "sourcesContent": ["//---------------------------------------------------------------------------------------------------------------------\n/**\n * This is a base class, providing the type-safe static constructor [[new]]. This is very convenient when using\n * [[Mixin|mixins]], as mixins can not have types in the constructors.\n */\nexport class Base {\n    /**\n     * This method applies its 1st argument (if any) to the current instance using `Object.assign()`.\n     *\n     * Supposed to be overridden in the subclasses to customize the instance creation process.\n     *\n     * @param props\n     */\n    initialize(props) {\n        props && Object.assign(this, props);\n    }\n    /**\n     * This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the\n     * class properties. It will generate a compilation error, if unknown property is provided.\n     *\n     * For example:\n     *\n     * ```ts\n     * class MyClass extends Base {\n     *     prop     : string\n     * }\n     *\n     * const instance : MyClass = MyClass.new({ prop : 'prop', wrong : 11 })\n     * ```\n     *\n     * will produce:\n     *\n     * ```plaintext\n     * TS2345: Argument of type '{ prop: string; wrong: number; }' is not assignable to parameter of type 'Partial<MyClass>'.\n     * Object literal may only specify known properties, and 'wrong' does not exist in type 'Partial<MyClass>'\n     * ```\n     *\n     * The only thing this constructor does is create an instance and call the [[initialize]] method on it, forwarding\n     * the first argument. The customization of instance is supposed to be performed in that method.\n     *\n     * @param props\n     */\n    static new(props) {\n        const instance = new this();\n        instance.initialize(props);\n        return instance;\n    }\n}\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\nexport class CalendarCacheIntervalMultiple {\n    constructor(config) {\n        this.intervalGroups = [];\n        config && Object.assign(this, config);\n    }\n    combineWith(interval) {\n        const copy = this.intervalGroups.slice();\n        copy.push([interval.calendar, interval]);\n        return new CalendarCacheIntervalMultiple({ intervalGroups: copy });\n    }\n    getIsWorkingForEvery() {\n        if (this.isWorkingForEvery != null)\n            return this.isWorkingForEvery;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (!intervals[0].isWorking)\n                return this.isWorkingForEvery = false;\n        }\n        return this.isWorkingForEvery = true;\n    }\n    getIsWorkingForSome() {\n        if (this.isWorkingForSome != null)\n            return this.isWorkingForSome;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (intervals[0].isWorking)\n                return this.isWorkingForSome = true;\n        }\n        return this.isWorkingForSome = false;\n    }\n    getCalendars() {\n        this.getGroups();\n        return this.calendars;\n    }\n    isCalendarWorking(calendar) {\n        return this.getCalendarsWorkStatus().get(calendar);\n    }\n    getCalendarsWorkStatus() {\n        if (this.calendarsWorkStatus)\n            return this.calendarsWorkStatus;\n        const res = new Map();\n        for (let [calendar, intervals] of this.getGroups()) {\n            // <remove-on-release>\n            // TODO: fix types\n            // </remove-on-release>\n            res.set(calendar, intervals[0].isWorking);\n        }\n        return this.calendarsWorkStatus = res;\n    }\n    getCalendarsWorking() {\n        if (this.calendarsWorking)\n            return this.calendarsWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            // <remove-on-release>\n            // TODO: fix types\n            // </remove-on-release>\n            if (intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsWorking = calendars;\n    }\n    getCalendarsNonWorking() {\n        if (this.calendarsNonWorking)\n            return this.calendarsNonWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            // <remove-on-release>\n            // TODO: fix types\n            // </remove-on-release>\n            if (!intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsNonWorking = calendars;\n    }\n    getGroups() {\n        if (this.intervalsByCalendar)\n            return this.intervalsByCalendar;\n        const calendars = this.calendars = [];\n        const intervalsByCalendar = new Map();\n        this.intervalGroups.forEach(([calendar, interval]) => {\n            let data = intervalsByCalendar.get(calendar);\n            if (!data) {\n                calendars.push(calendar);\n                data = [];\n                intervalsByCalendar.set(calendar, data);\n            }\n            data.push.apply(data, interval.intervals);\n        });\n        intervalsByCalendar.forEach((intervals, calendar) => {\n            const unique = stripDuplicates(intervals);\n            unique.sort(\n            // sort in decreasing order\n            (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());\n            intervalsByCalendar.set(calendar, unique);\n        });\n        return this.intervalsByCalendar = intervalsByCalendar;\n    }\n}\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\nimport { CalendarCache } from \"./CalendarCache.js\";\nimport { CalendarCacheIntervalMultiple } from \"./CalendarCacheIntervalMultiple.js\";\nimport { IntervalCache } from \"./IntervalCache.js\";\n/**\n * The calendar cache for combination of multiple calendars\n */\nexport class CalendarCacheMultiple extends CalendarCache {\n    constructor(config) {\n        super(config);\n        this.calendarCaches = stripDuplicates(this.calendarCaches);\n        this.intervalCache = new IntervalCache({\n            emptyInterval: new CalendarCacheIntervalMultiple(),\n            combineIntervalsFn: (interval1, interval2) => {\n                return interval1.combineWith(interval2);\n            }\n        });\n    }\n    fillCache(startDate, endDate) {\n        this.calendarCaches.forEach(calendarCache => {\n            calendarCache.fillCache(startDate, endDate);\n            this.includeWrappingRangeFrom(calendarCache, startDate, endDate);\n        });\n    }\n}\nconst COMBINED_CALENDARS_CACHE = new Map();\nexport const combineCalendars = (calendars) => {\n    const uniqueOnly = stripDuplicates(calendars);\n    if (uniqueOnly.length === 0)\n        throw new Error(\"No calendars to combine\");\n    uniqueOnly.sort((calendar1, calendar2) => {\n        if (calendar1.internalId < calendar2.internalId)\n            return -1;\n        else\n            return 1;\n    });\n    const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');\n    const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');\n    let cached = COMBINED_CALENDARS_CACHE.get(hash);\n    let res;\n    if (cached && cached.versionsHash === versionsHash)\n        res = cached.cache;\n    else {\n        res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache) });\n        // COMBINED_CALENDARS_CACHE.set(hash, {\n        //     versionsHash    : versionsHash,\n        //     cache           : res\n        // })\n    }\n    return res;\n};\n", "import ColumnStore from '../../Grid/data/ColumnStore.js';\nimport NumberColumn from '../../Grid/column/NumberColumn.js';\nimport Duration from '../../Core/data/Duration.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/DurationField.js';\n\n/**\n * @module Scheduler/column/DurationColumn\n */\n\n/**\n * A column showing the task {@link Scheduler/model/TimeSpan#field-fullDuration duration}. Please note, this column\n * is preconfigured and expects its field to be of the {@link Core.data.Duration} type.\n *\n * The default editor is a {@link Core.widget.DurationField}. It parses time units, so you can enter \"4d\"\n * indicating 4 days duration, or \"4h\" indicating 4 hours, etc. The numeric magnitude can be either an integer or a\n * float value. Both \",\" and \".\" are valid decimal separators. For example, you can enter \"4.5d\" indicating 4.5 days\n * duration, or \"4,5h\" indicating 4.5 hours.\n *\n * {@inlineexample Scheduler/column/DurationColumn.js}\n * @extends Grid/column/NumberColumn\n * @classType duration\n * @column\n */\nexport default class DurationColumn extends NumberColumn {\n    compositeField = true;\n\n    //region Config\n\n    static get $name() {\n        return 'DurationColumn';\n    }\n\n    static get type() {\n        return 'duration';\n    }\n\n    static get isGanttColumn() {\n        return true;\n    }\n\n    static get fields() {\n        return [\n            /**\n             * Precision of displayed duration, defaults to use {@link Scheduler.view.Scheduler#config-durationDisplayPrecision}.\n             * Specify an integer value to override that setting, or `false` to use raw value\n             * @config {Number|Boolean} decimalPrecision\n             */\n            { name : 'decimalPrecision', defaultValue : 1 }\n        ];\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * Min value\n             * @config {Number}\n             */\n            min : null,\n\n            /**\n             * Max value\n             * @config {Number}\n             */\n            max : null,\n\n            /**\n             * Step size for spin button clicks.\n             * @member {Number} step\n             */\n            /**\n             * Step size for spin button clicks. Also used when pressing up/down keys in the field.\n             * @config {Number}\n             * @default\n             */\n            step : 1,\n\n            /**\n             * Large step size, defaults to 10 * `step`. Applied when pressing SHIFT and stepping either by click or\n             * using keyboard.\n             * @config {Number}\n             * @default 10\n             */\n            largeStep : 0,\n\n            field         : 'fullDuration',\n            text          : 'L{Duration}',\n            instantUpdate : true,\n            // Undocumented, used by Filter feature to get type of the filter field\n            filterType    : 'duration',\n\n            sortable(durationEntity1, durationEntity2) {\n                const\n                    ms1 = durationEntity1[this.field],\n                    ms2 = durationEntity2[this.field];\n\n                return ms1 - ms2;\n            }\n        };\n    }\n\n    construct() {\n        super.construct(...arguments);\n\n        const sortFn = this.sortable;\n\n        this.sortable = (...args) => sortFn.call(this, ...args);\n    }\n\n    get defaultEditor() {\n        const { max, min, step, largeStep } = this;\n\n        // Remove any undefined configs, to allow config system to use default values instead\n        return ObjectHelper.cleanupProperties({\n            type : 'duration',\n            name : this.field,\n            max,\n            min,\n            step,\n            largeStep\n        });\n    }\n\n    //endregion\n\n    //region Internal\n\n    get durationUnitField() {\n        return `${this.field}Unit`;\n    }\n\n    roundValue(duration) {\n        const\n            nbrDecimals = typeof this.grid.durationDisplayPrecision === 'number' ? this.grid.durationDisplayPrecision : this.decimalPrecision,\n            multiplier  = Math.pow(10, nbrDecimals),\n            rounded     = Math.round(duration * multiplier) / multiplier;\n\n        return rounded;\n    }\n\n    formatValue(duration, durationUnit) {\n        if (duration instanceof Duration) {\n            durationUnit = duration.unit;\n            duration     = duration.magnitude;\n        }\n\n        duration = this.roundValue(duration);\n\n        return duration + ' ' + DateHelper.getLocalizedNameOfUnit(durationUnit, duration !== 1);\n    }\n\n    //endregion\n\n    //region Render\n\n    defaultRenderer({ record, isExport }) {\n        const\n            value         = record[this.field],\n            type          = typeof value,\n            durationValue = type === 'number' ? value : value?.magnitude,\n            durationUnit  = type === 'number' ? record[this.durationUnitField] : value?.unit;\n\n        // in case of bad input (for instance NaN, undefined or NULL value)\n        if (typeof durationValue !== 'number') {\n            return isExport ? '' : null;\n        }\n\n        return this.formatValue(durationValue, durationUnit);\n    }\n\n    //endregion\n\n    // Used with CellCopyPaste as fullDuration doesn't work via record.get\n    toClipboardString({ record }) {\n        return record[this.field].toString();\n    }\n\n    fromClipboardString({ string, record }) {\n        const duration = DateHelper.parseDuration(string, true, this.durationUnit);\n\n        if (duration && 'magnitude' in duration) {\n            return duration;\n        }\n\n        return record.fullDuration;\n    }\n\n    calculateFillValue({ value, record }) {\n        return this.fromClipboardString({ string : value, record });\n    }\n\n}\n\nColumnStore.registerColumnType(DurationColumn);\n", "import Widget from '../../Core/widget/Widget.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n\n/**\n * @module Scheduler/view/TimeAxisBase\n */\n\nfunction isLastLevel(level, levels) {\n    return level === levels.length - 1;\n}\n\nfunction isLastCell(level, cell) {\n    return cell === level.cells[level.cells.length - 1];\n}\n\n/**\n * Base class for HorizontalTimeAxis and VerticalTimeAxis. Contains shared functionality to only render ticks in view,\n * should not be used directly.\n *\n * @extends Core/widget/Widget\n * @private\n * @abstract\n */\nexport default class TimeAxisBase extends Widget {\n\n    static $name = 'TimeAxisBase';\n\n    //region Config\n\n    static configurable = {\n        /**\n         * The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class\n         * to the row (for special styling). Copied from Scheduler/Gantt.\n         * @config {Number}\n         * @default\n         */\n        compactCellWidthThreshold : 15,\n\n        // TimeAxisViewModel\n        model : null,\n\n        cls : null,\n\n        /**\n         * Style property to use as cell size. Either width or height depending on orientation\n         * @config {'width'|'height'}\n         * @private\n         */\n        sizeProperty : null,\n\n        /**\n         * Style property to use as cells position. Either left or top depending on orientation\n         * @config {'left'|'top'}\n         * @private\n         */\n        positionProperty : null\n    };\n\n    startDate = null;\n    endDate   = null;\n    levels    = [];\n    size      = null;\n\n    // Set visible date range\n    set range({ startDate, endDate }) {\n        const me = this;\n\n        // Only process a change\n        if (me.startDate - startDate || me.endDate - endDate) {\n            me.startDate = startDate;\n            me.endDate = endDate;\n            me.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Html & rendering\n\n    // Generates element configs for all levels defined by the current ViewPreset\n    buildCells(start = this.startDate, end = this.endDate) {\n        const\n            me                   = this,\n            { sizeProperty }     = me,\n            {\n                stickyHeaders,\n                isVertical\n            }                    = me.client || {},\n            featureHeaderConfigs = [],\n            { length }           = me.levels;\n\n        const cellConfigs = me.levels.map((level, i) => {\n            const stickyHeader = stickyHeaders && (isVertical || i < length - 1);\n\n            return {\n                className : {\n                    'b-sch-header-row'                     : 1,\n                    [`b-sch-header-row-${level.position}`] : 1,\n                    'b-sch-header-row-main'                : i === me.model.viewPreset.mainHeaderLevel,\n                    'b-lowest'                             : isLastLevel(i, me.levels),\n                    'b-sticky-header'                      : stickyHeader\n                },\n                syncOptions : {\n                    // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                    // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                    // wide tickSizes\n                    releaseThreshold : 5,\n                    syncIdField      : 'tickIndex'\n                },\n                dataset : {\n                    headerFeature  : `headerRow${i}`,\n                    headerPosition : level.position\n                },\n                // Only include cells in view\n                children : level.cells?.filter(cell => cell.start < end && cell.end > start).map((cell, j) => ({\n                    role      : 'presentation',\n                    className : {\n                        'b-sch-header-timeaxis-cell' : 1,\n                        [cell.headerCellCls]         : cell.headerCellCls,\n                        [`b-align-${cell.align}`]    : cell.align,\n                        'b-last'                     : isLastCell(level, cell)\n                    },\n                    dataset : {\n                        tickIndex : cell.index,\n                        // Used in export tests to resolve dates from tick elements\n                        ...globalThis.DEBUG && { date : cell.start.getTime() }\n                    },\n                    style : {\n                        // DomHelper appends px to numeric dimensions\n                        [me.positionProperty]   : cell.coord,\n                        [sizeProperty]          : cell.width,\n                        [`min-${sizeProperty}`] : cell.width\n                    },\n                    children : [\n                        {\n                            tag       : 'span',\n                            role      : 'presentation',\n                            className : {\n                                'b-sch-header-text' : 1,\n                                'b-sticky-header'   : stickyHeader\n                            },\n                            html : cell.value\n                        }\n                    ]\n                }))\n            };\n        });\n\n        // When tested in isolation there is no client\n        me.client?.getHeaderDomConfigs(featureHeaderConfigs);\n\n        cellConfigs.push(...featureHeaderConfigs);\n\n        // noinspection JSSuspiciousNameCombination\n        return {\n            className   : me.widgetClassList,\n            syncOptions : {\n                // Do not keep entire levels no longer used, for example after switching view preset\n                releaseThreshold : 0\n            },\n            children : cellConfigs\n        };\n    }\n\n    render(targetElement) {\n        super.render(targetElement);\n\n        this.refresh(true);\n    }\n\n    /**\n     * Refresh the UI\n     * @param {Boolean} [rebuild] Specify `true` to force a rebuild of the underlying header level definitions\n     */\n    refresh(rebuild = !this.levels.length) {\n        const\n            me               = this,\n            { columnConfig } = me.model,\n            { levels }       = me,\n            oldLevelsCount   = levels.length;\n\n        if (rebuild) {\n            levels.length = 0;\n\n            columnConfig.forEach((cells, position) => levels[position] = {\n                position,\n                cells\n            });\n\n            me.size = levels[0].cells.reduce((sum, cell) => sum + cell.width, 0);\n\n            const { parentElement } = me.element;\n\n            // Don't mutate a classList unless necessary. Browsers invalidate the style.\n            if (parentElement && (levels.length !== oldLevelsCount || rebuild)) {\n                parentElement.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);\n                parentElement.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);\n            }\n        }\n\n        if (!me.startDate || !me.endDate) {\n            return;\n        }\n\n        // Boil down levels to only show what is in view\n        DomSync.sync({\n            domConfig     : me.buildCells(),\n            targetElement : me.element,\n            syncIdField   : 'headerFeature'\n        });\n\n        me.trigger('refresh');\n    }\n\n    //endregion\n\n    // Our widget class doesn't include \"base\".\n    get widgetClass() {\n        return 'b-timeaxis';\n    }\n}\n", "import TimeAxisBase from './TimeAxisBase.js';\n\n/**\n * @module Scheduler/view/HorizontalTimeAxis\n */\n\n/**\n * A visual horizontal representation of the time axis described in the\n * {@link Scheduler.preset.ViewPreset#field-headers} field.\n * Normally you should not interact with this class directly.\n *\n * @extends Scheduler/view/TimeAxisBase\n * @private\n */\nexport default class HorizontalTimeAxis extends TimeAxisBase {\n\n    //region Config\n\n    static $name = 'HorizontalTimeAxis';\n\n    static type = 'horizontaltimeaxis';\n\n    static configurable = {\n        model        : null,\n        sizeProperty : 'width'\n    };\n\n    //endregion\n\n    get positionProperty() {\n        return this.owner?.rtl ? 'right' : 'left';\n    }\n\n    get width() {\n        return this.size;\n    }\n\n    onModelUpdate() {\n        // Force rebuild when availableSpace has changed, to recalculate width and maybe apply compact styling\n        // <remove-on-release>\n        // TODO: this.width is the scrollWidth and this.model.availableSpace is the clientWidth\n        //  These are always going to be different (unless forceFit is set on the Gantt), so theres\n        //  no optimization. Likely this should always refresh(true) anyway since we do not know *what*\n        //  changed in the model update.\n        //  Time axis sub grid could also be collapsed (availableSpace === 0)\n        // </remove-on-release>\n        if (this.model.availableSpace > 0 && this.model.availableSpace !== this.width) {\n            this.refresh(true);\n        }\n    }\n\n    updateModel(timeAxisViewModel) {\n        this.detachListeners('tavm');\n\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onModelUpdate',\n            thisObj : this\n        });\n    }\n}\n", "import Widget from '../../Core/widget/Widget.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n\n/**\n * @module Scheduler/view/ResourceHeader\n */\n\n/**\n * Header widget that renders resource column headers and acts as the interaction point for resource columns in vertical\n * mode. Note that it uses virtual rendering and element reusage to gain performance, only headers in view are available\n * in DOM. Because of this you should avoid direct element manipulation, any such changes can be discarded at any time.\n *\n * By default, it displays resources `name` and also applies its `iconCls` if any, like this:\n *\n * ```html\n * <i class=\"iconCls\">name</i>\n * ```\n *\n * If Scheduler is configured with a {@link Scheduler.view.Scheduler#config-resourceImagePath} the\n * header will render miniatures for the resources, using {@link Scheduler.model.ResourceModel#field-imageUrl}\n * or {@link Scheduler.model.ResourceModel#field-image} with fallback to\n * {@link Scheduler.model.ResourceModel#field-name} + {@link Scheduler.view.Scheduler#config-resourceImageExtension}\n * for unset values.\n *\n * The contents and styling of the resource cells in the header can be customized using {@link #config-headerRenderer}:\n *\n * ```javascript\n * new Scheduler({\n *     mode            : 'vertical',\n *     resourceColumns : {\n *         headerRenderer : ({ resourceRecord }) => `Hello ${resourceRecord.name}`\n *     }\n * }\n *```\n *\n * The width of the resource columns is determined by the {@link #config-columnWidth} config.\n *\n * @extends Core/widget/Widget\n */\nexport default class ResourceHeader extends Widget {\n\n    //region Config\n\n    static $name = 'ResourceHeader';\n\n    static type = 'resourceheader';\n\n    static configurable = {\n        /**\n         * Resource store used to render resource headers. Assigned from Scheduler.\n         * @config {Scheduler.data.ResourceStore}\n         * @private\n         */\n        resourceStore : null,\n\n        /**\n         * Custom header renderer function. Can be used to manipulate the element config used to create the element\n         * for the header:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer({ elementConfig, resourceRecord }) {\n         *       elementConfig.dataset.myExtraData = 'extra';\n         *       elementConfig.style.fontWeight = 'bold';\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * See {@link DomConfig} for more information.\n         * Please take care to not break the default configs :)\n         *\n         * Or as a template by returning HTML from the function:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer : ({ resourceRecord }) => `\n         *       <div class=\"my-custom-template\">\n         *       ${resourceRecord.firstName} {resourceRecord.surname}\n         *       </div>\n         *     `\n         *   }\n         * });\n         * ```\n         *\n         * NOTE: When using `headerRenderer` no default internal markup is applied to the resource header cell,\n         * `iconCls` and {@link Scheduler.model.ResourceModel#field-imageUrl} or {@link Scheduler.model.ResourceModel#field-image}\n         * will have no effect unless you supply custom markup for them.\n         *\n         * @config {Function}\n         * @param {Object} params Object containing the params below\n         * @param {Scheduler.model.ResourceModel} params.resourceRecord Resource whose header is being rendered\n         * @param {DomConfig} params.elementConfig A config object used to create the element for the resource\n         */\n        headerRenderer : null,\n\n        /**\n         * Set to `false` to render just the resource name, `true` to render an avatar (or initials if no image exists)\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value : true,\n\n            $config : 'nullify'\n        },\n\n        /**\n         * Assign to toggle resource columns **fill* mode. `true` means they will stretch (grow) to fill viewport, `false`\n         * that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fillWidth\n         */\n        /**\n         * Automatically resize resource columns to **fill** available width. Set to `false` to always respect the\n         * configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fillWidth : true,\n\n        /**\n         * Assign to toggle resource columns **fit* mode. `true` means they will grow or shrink to always fit viewport,\n         * `false` that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fitWidth\n         */\n        /**\n         * Automatically resize resource columns to always **fit** available width.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fitWidth : false,\n\n        /**\n         * Width for each resource column.\n         *\n         * This is used for resources which are not are loaded with a {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Number}\n         */\n        columnWidth : 150,\n\n        // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js\n        imagePath : null,\n\n        // Copied from Scheduler#resourceImageExtension on creation in TimeAxisColumn.js\n        imageExtension : null,\n\n        // Copied from Scheduler#defaultResourceImageName on creation in TimeAxisColumn.js\n        defaultImageName : null,\n\n        availableWidth : null\n    };\n\n    /**\n     * An index of the first visible resource in vertical mode\n     * @property {Number}\n     * @readonly\n     * @private\n     */\n    firstResource = -1;\n    /**\n     * An index of the last visible resource in vertical mode\n     * @property {Number}\n     * @readonly\n     * @private\n     */\n    lastResource  = -1;\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        const me = this;\n\n        // Inject this into owning Scheduler early because code further down\n        // can call code which uses scheduler.resourceColumns.\n        config.scheduler._resourceColumns = me;\n\n        super.construct(config);\n\n        if (me.imagePath != null) {\n            // Need to increase height a bit when displaying images\n            me.element.classList.add('b-has-images');\n        }\n\n        EventHelper.on({\n            element     : me.element,\n            delegate    : '.b-resourceheader-cell',\n            capture     : true,\n            click       : 'onResourceMouseEvent',\n            dblclick    : 'onResourceMouseEvent',\n            contextmenu : 'onResourceMouseEvent',\n            thisObj     : me\n        });\n    }\n\n    changeShowAvatars(show) {\n        this.avatarRendering?.destroy();\n\n        if (show) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.element\n            });\n        }\n\n        return show;\n    }\n\n    updateShowAvatars() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    updateResourceStore(store) {\n        const me = this;\n\n        me.detachListeners('resourceStore');\n\n        if (store) {\n            store.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreDataChange',\n                thisObj         : me\n            });\n\n            // Already have data? Update width etc\n            if (store.count) {\n                me.onResourceStoreDataChange({});\n            }\n        }\n    }\n\n    // Redraw resource headers on any data change\n    onResourceStoreDataChange({ action }) {\n        const me    = this;\n\n        // These must be ingested before we assess the source of column widths\n        // so that they can be cleared *after* their values have been cached.\n        me.getConfig('fillWidth');\n        me.getConfig('fitWidth');\n        me.updateWidthCache();\n\n        const\n            {\n                element\n            }     = me,\n            width = me.totalWidth;\n\n        // If we have some defined columnWidths in the resourceStore\n        // we must then bypass configured fitWidth and fillWidth behaviour.\n        if (me.scheduler.variableColumnWidths) {\n            me._fillWidth = me._fitWidth = false;\n        }\n        else {\n            me._fillWidth = me.configuredFillWidth;\n            me._fitWidth = me.configuredFitWidth;\n        }\n\n        if (width !== me.width) {\n            DomHelper.setLength(element, 'width', width);\n            // During setup, silently set the width. It will then render correctly. After setup, let the world know...\n            me.column.set('width', width, me.column.grid.isConfiguring);\n        }\n\n        if (action === 'removeall') {\n            // Keep nothing\n            element.innerHTML = '';\n        }\n\n        if (action === 'remove' || action === 'add' || action === 'filter' || me.fitWidth || me.fillWidth) {\n            me.refreshWidths();\n        }\n\n        me.column.grid.toggleEmptyText();\n    }\n\n    get totalWidth() {\n        return this.updateWidthCache();\n    }\n\n    updateWidthCache() {\n        let result          = 0;\n        const { scheduler } = this;\n\n        // Flag so that VerticalRendering#getResourceRange knows\n        // whether to use fast or slow mode to ascertain visible columns.\n        scheduler.variableColumnWidths = false;\n\n        scheduler.resourceStore.forEach(resource => {\n            // Set the start position for each resource with respect to the widths\n            resource.instanceMeta(scheduler).insetStart = result;\n            resource.instanceMeta(scheduler).insetEnd   = result + (resource.columnWidth || scheduler.resourceColumnWidth);\n\n            if (resource.columnWidth == null) {\n                result += scheduler.resourceColumnWidth;\n            }\n            else {\n                result += resource.columnWidth;\n                scheduler.variableColumnWidths = true;\n            }\n        });\n\n        return result;\n    }\n\n    //endregion\n\n    //region Properties\n\n    changeColumnWidth(columnWidth) {\n        // Cache configured value, because if *all* resources have their own columnWidths\n        // the property will be nulled, but if we ever recieve a new resource with no\n        // columnWidth, or a columnWidth is nulled, we then have to fall back to using this.\n        if (!this.refreshingWidths) {\n            this.configuredColumnWidth = columnWidth;\n        }\n        return columnWidth;\n    }\n\n    updateColumnWidth(width, oldWidth) {\n        const me = this;\n\n        // Flag set in refreshWidths, do not want to create a loop\n        if (!me.refreshingWidths) {\n            me.refreshWidths();\n        }\n\n        if (!me.isConfiguring) {\n            // If resources are grouped, I need to refresh manually the cached width of resource header columns\n            if (me.resourceStore.isGrouped) {\n                me.updateWidthCache();\n            }\n\n            me.refresh();\n            // Cannot trigger with requested width, might have changed because of fit/fill\n            me.trigger('columnWidthChange', { width, oldWidth });\n        }\n    }\n\n    changeFillWidth(fillWidth) {\n        return this.configuredFillWidth = fillWidth;\n    }\n\n    updateFillWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n\n    changeFitWidth(fitWidth) {\n        return this.configuredFitWidth = fitWidth;\n    }\n\n    updateFitWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n\n    getImageURL(imageName) {\n        return StringHelper.joinPaths([this.imagePath || '', imageName || '']);\n    }\n\n    updateImagePath() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Fit to width\n\n    updateAvailableWidth(width) {\n        this.refreshWidths();\n    }\n\n    // Updates the column widths according to fill and fit settings\n    refreshWidths() {\n        const\n            me    = this,\n            {\n                availableWidth,\n                configuredColumnWidth\n            }     = me,\n            count = me.resourceStore?.count;\n\n        // Bail out if availableWidth not yet set or resource store not assigned/loaded\n        // or column widths are defined in the resources.\n        if (!availableWidth || !count || me.scheduler.variableColumnWidths) {\n            return;\n        }\n\n        me.refreshingWidths = true;\n\n        const\n            // Fit width if configured to do so or if configured to fill and used width is less than available width\n            fit           = me.fitWidth || me.fillWidth && configuredColumnWidth * count < availableWidth,\n            useWidth      = fit ? Math.floor(availableWidth / count) : configuredColumnWidth,\n            shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;\n\n        DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0, me);\n\n        me.columnWidth = useWidth;\n\n        me.refreshingWidths = false;\n    }\n\n    //endregion\n\n    //region Rendering\n\n    // Visual resource range, set by VerticalRendering + its buffer\n    set visibleResources({ firstResource, lastResource }) {\n        this.firstResource = firstResource;\n        this.lastResource = lastResource;\n\n        this.updateWidthCache();\n        this.refresh();\n    }\n\n    /**\n     * Refreshes the visible headers\n     */\n    refresh() {\n        const\n            me         = this,\n            {\n                firstResource,\n                scheduler,\n                resourceStore,\n                lastResource\n            }          = me,\n            {\n                variableColumnWidths\n            }          = scheduler,\n            groupField = resourceStore.isGrouped && resourceStore.groupers[0].field,\n            configs    = [];\n\n        me.element.classList.toggle('b-grouped', Boolean(groupField));\n\n        if (!me.column.grid.isConfiguring && firstResource > -1 && lastResource > -1 && lastResource < resourceStore.count) {\n            let currentGroup;\n            // Gather element configs for resource headers in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                const\n                    resourceRecord = resourceStore.allResourceRecords[i],\n                    groupRecord    = resourceRecord.instanceMeta(resourceStore).groupParent,\n                    groupChildren  = groupRecord?.groupChildren;\n\n                if (groupField && groupRecord.id !== currentGroup?.dataset.resourceId) {\n                    const\n                        groupLeft  = groupChildren[0].instanceMeta(scheduler).insetStart,\n                        groupWidth = groupChildren[groupChildren.length - 1].instanceMeta(scheduler).insetEnd - groupLeft;\n\n                    currentGroup = {\n                        className : 'b-resourceheader-group-cell',\n                        dataset   : {\n                            resourceId : groupRecord.id\n                        },\n                        style : {\n                            left  : groupLeft,\n                            width : groupWidth\n                        },\n                        children : [\n                            {\n                                tag  : 'span',\n                                html : StringHelper.encodeHtml(groupChildren[0][groupField])\n                            },\n                            {\n                                className : 'b-resourceheader-group-children',\n                                children  : []\n                            }\n                        ]\n                    };\n\n                    configs.push(currentGroup);\n                }\n\n                const\n                    instanceMeta  = resourceRecord.instanceMeta(scheduler),\n                    // Possible variable column width taken from the resources, fallback to scheduler's default\n                    width         = resourceRecord.columnWidth || me.columnWidth,\n                    position      = groupField ? instanceMeta.insetStart - currentGroup.style.left //groupChildren[0].instanceMeta(scheduler).insetStart\n                        : variableColumnWidths ? instanceMeta.insetStart : i * me.columnWidth,\n                    elementConfig = {\n                        // Might look like overkill to use DomClassList here, but can be used in headerRenderer\n                        className : new DomClassList({\n                            'b-resourceheader-cell' : 1\n                        }),\n                        dataset : {\n                            resourceId : resourceRecord.id\n                        },\n                        style : {\n                            [scheduler.rtl ? 'right' : 'left'] : position,\n                            width\n                        },\n                        children : []\n                    };\n\n                // Let a configured headerRenderer have a go at it before applying\n                if (me.headerRenderer) {\n                    const value = me.headerRenderer({ elementConfig, resourceRecord });\n\n                    if (value != null) {\n                        elementConfig.html = value;\n                    }\n                }\n                // No headerRenderer, apply default markup\n                else {\n                    let imageUrl;\n\n                    if (resourceRecord.imageUrl) {\n                        imageUrl = resourceRecord.imageUrl;\n                    }\n                    else {\n                        if (me.imagePath != null) {\n                            if (resourceRecord.image !== false) {\n                                const imageName = resourceRecord.image ||\n                                    resourceRecord.name?.toLowerCase() + me.imageExtension;\n                                imageUrl = me.getImageURL(imageName);\n                            }\n                        }\n                    }\n\n                    // By default showing resource name and optionally avatar\n                    elementConfig.children.push(\n                        me.showAvatars && me.avatarRendering.getResourceAvatar({\n                            resourceRecord,\n                            initials        : resourceRecord.initials,\n                            color           : resourceRecord.eventColor,\n                            iconCls         : resourceRecord.iconCls,\n                            defaultImageUrl : me.defaultImageName && me.getImageURL(me.defaultImageName),\n                            imageUrl\n                        }),\n                        {\n                            tag       : 'span',\n                            className : 'b-resource-name',\n                            html      : StringHelper.encodeHtml(resourceRecord.name)\n                        }\n                    );\n                }\n\n                if (groupField) {\n                    currentGroup.children[1].children.push(elementConfig);\n                }\n                else {\n                    configs.push(elementConfig);\n                }\n            }\n        }\n\n        // Sync changes to the header\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : configs\n            },\n            targetElement : me.element,\n            syncIdField   : 'resourceId'\n            // <remove-on-release>\n            // TODO: Add callback here to trigger events when rendering/derendering header cells. Sooner or later\n            //  someone is going to ask for a way to render JSX or what not to the header\n            // </remove-on-release>\n        });\n    }\n\n    //endregion\n\n    onResourceMouseEvent(event) {\n        const\n            resourceCell   = event.target.closest('.b-resourceheader-cell'),\n            resourceRecord = this.resourceStore.getById(resourceCell.dataset.resourceId);\n\n        this.trigger('resourceHeader' + StringHelper.capitalize(event.type), {\n            resourceRecord,\n            event\n        });\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the header, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Assigned from Scheduler\n        delete result.resourceStore;\n        delete result.column;\n        delete result.type;\n\n        return result;\n    }\n}\n", "import WidgetColumn from '../../Grid/column/WidgetColumn.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Events from '../../Core/mixin/Events.js';\nimport HorizontalTimeAxis from '../view/HorizontalTimeAxis.js';\nimport ResourceHeader from '../view/ResourceHeader.js';\n\n/**\n * @module Scheduler/column/TimeAxisColumn\n */\n\n/**\n * A column containing the timeline \"viewport\", in which events, dependencies etc. are drawn.\n * Normally you do not need to interact with or create this column, it is handled by Scheduler.\n *\n * If you wish to output custom contents inside the time axis row cells, you can provide your custom column configuration\n * using the {@link #config-renderer} like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    appendTo         : document.body\n *    columns          : [\n *       { text : 'Name', field : 'name', width : 130 },\n *       {\n *           type : 'timeAxis',\n *           renderer({ record, cellElement }) {\n *               return '<div class=\"cool-chart\"></div>';\n *           }\n *       }\n *    ]\n * });\n * ```\n *\n * @extends Grid/column/WidgetColumn\n * @column\n */\nexport default class TimeAxisColumn extends Events(WidgetColumn) {\n    //region Config\n\n    static $name = 'TimeAxisColumn';\n\n    static get fields() {\n        return [\n            // Exclude some irrelevant fields from getCurrentConfig()\n            { name : 'locked', persist : false },\n            { name : 'flex', persist : false },\n            { name : 'width', persist : false },\n            { name : 'cellCls', persist : false },\n            { name : 'field', persist : false },\n            'mode'\n        ];\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             */\n            draggable : false,\n\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             */\n            groupable : false,\n\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             */\n            hideable : false,\n\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             */\n            showColumnPicker : false,\n\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             */\n            filterable : false,\n\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             */\n            sortable : false,\n\n            /**\n             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n             * @config {Boolean} resizable\n             * @default false\n             * @category Interaction\n             */\n            resizable : false,\n\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             */\n            searchable : false,\n\n            /**\n             * @config {String} editor\n             * @hide\n             */\n            editor : false,\n\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             */\n            enableCellContextMenu : false,\n\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n\n            /**\n             * CSS class added to the header of this column\n             * @config {String} cls\n             * @category Rendering\n             * @default 'b-sch-timeaxiscolumn'\n             */\n            cls : 'b-sch-timeaxiscolumn',\n\n            // needs to have width specified, flex-basis messes measurements up\n            needWidth : true,\n\n            mode       : null,\n            region     : 'normal',\n            exportable : false,\n            htmlEncode : false\n        };\n    }\n\n    static get type() {\n        return 'timeAxis';\n    }\n\n    //region Init\n\n    construct(config) {\n        const me = this;\n\n        super.construct(...arguments);\n\n        me.thisObj = me;\n        me.timeAxisViewModel = me.grid.timeAxisViewModel;\n        // A bit hacky, because mode is a field and not a config\n        // eslint-disable-next-line no-self-assign\n        me.mode = me.mode;\n\n        me.grid.ion({\n            paint   : 'onTimelinePaint',\n            thisObj : me,\n            once    : true\n        });\n    }\n\n    static get autoExposeFields() {\n        return true;\n    }\n\n    // endregion\n\n    doDestroy() {\n        this.resourceColumns?.destroy();\n        this.timeAxisView?.destroy();\n        super.doDestroy();\n    }\n\n    set mode(mode) {\n        const\n            me       = this,\n            { grid } = me;\n\n        me.set('mode', mode);\n\n        // In horizontal mode this column has a time axis header on top, with timeline ticks\n        if (mode === 'horizontal') {\n            me.timeAxisView = new HorizontalTimeAxis({\n                model                     : me.timeAxisViewModel,\n                compactCellWidthThreshold : me.compactCellWidthThreshold,\n                owner                     : grid,\n                client                    : grid\n            });\n        }\n        // In vertical mode, it instead displays resources at top\n        else if (mode === 'vertical') {\n            // <remove-on-release>\n            // TODO: Most other vertical stuff is handled in VerticalRendering, move there?\n            // </remove-on-release>\n            me.resourceColumns = ResourceHeader.new({\n                column           : me,\n                scheduler        : grid,\n                resourceStore    : grid.resourceStore,\n                imagePath        : grid.resourceImagePath,\n                imageExtension   : grid.resourceImageExtension,\n                defaultImageName : grid.defaultResourceImageName\n            }, grid.resourceColumns || {});\n\n            me.relayEvents(me.resourceColumns, [\n                'resourceheaderclick',\n                'resourceheaderdblclick',\n                'resourceheadercontextmenu'\n            ]);\n        }\n    }\n\n    get mode() {\n        return this.get('mode');\n    }\n\n    // <remove-on-release>\n    // TODO: define all configs as fields and set below to false...\n    // </remove-on-release>\n\n    //region Events\n\n    onViewModelUpdate({ source : viewModel }) {\n        const me = this;\n\n        if (me.grid.timeAxisSubGrid.collapsed) {\n            return;\n        }\n\n        if (me.mode === 'horizontal') {\n            // render the time axis view into the column header element\n            me.refreshHeader(true);\n\n            me.width = viewModel.totalSize;\n\n            me.grid.refresh();\n\n            // When width is set above, that ends up on a columnsResized listener, but the refreshing of the fake\n            // scrollers to accommodate the new width is not done in this timeframe, so the upcoming centering related\n            // to preset change cannot work. So we have to refresh the fake scrollers now\n            me.subGrid.refreshFakeScroll();\n        }\n        else if (me.mode === 'vertical') {\n            // Refresh to rerender cells, in the process updating the vertical timeaxis to reflect view model changes\n            me.grid.refreshRows();\n        }\n    }\n\n    // Called on paint. SubGrid has its width so this is the earliest time to configure the TimeAxisViewModel with\n    // correct width\n    onTimelinePaint({ firstPaint }) {\n        const me = this;\n\n        if (!me.subGrid.insertRowsBefore) {\n            return;\n        }\n\n        if (firstPaint) {\n            me.subGridElement.classList.add('b-timeline-subgrid');\n\n            if (me.mode === 'vertical') {\n                me.refreshHeader();\n\n                // The above operation can cause height change.\n                me.grid?.onHeightChange();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Rendering\n\n    /**\n     * Refreshes the columns header contents (which is either a HorizontalTimeAxis or a ResourceHeader). Useful if you\n     * have rendered some extra meta data that depends on external data such as the EventStore or ResourceStore.\n     */\n    refreshHeader(internal) {\n        const\n            me          = this,\n            { element } = me;\n\n        if (element) {\n\n            if (me.mode === 'horizontal') {\n                // Force timeAxisViewModel to regenerate its column config, which calls header renderers etc.\n                !internal && me.timeAxisViewModel.update(undefined, undefined, true);\n\n                if (!me.timeAxisView.rendered) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n\n                    me.timeAxisView.render(element);\n                }\n                else {\n                    // Force rebuild of cells in case external data has changed (cheap since it still syncs to DOM)\n                    me.timeAxisView.refresh(true);\n                }\n            }\n            else if (me.mode === 'vertical') {\n                if (!me.resourceColumns.currentElement) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n\n                    me.resourceColumns.render(element);\n                }\n\n                // Vertical's resourceColumns is redrawn with the events, no need here\n            }\n        }\n    }\n\n    internalRenderer(renderData) {\n        const { grid } = this;\n        // No drawing of events before engines initial commit\n        if (grid.project.isInitialCommitPerformed || grid.project.isDelayingCalculation) {\n            grid.currentOrientation.renderer(renderData);\n\n            return super.internalRenderer(renderData);\n        }\n    }\n\n    //endregion\n\n    get timeAxisViewModel() {\n        return this._timeAxisViewModel;\n    }\n\n    set timeAxisViewModel(timeAxisViewModel) {\n        const me = this;\n\n        me.detachListeners('tavm');\n\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onViewModelUpdate',\n            prio    : -10000,\n            thisObj : me\n        });\n\n        me._timeAxisViewModel = timeAxisViewModel;\n\n        if (me.timeAxisView) {\n            me.timeAxisView.model = timeAxisViewModel;\n        }\n    }\n\n    // Width of the time axis column is solely determined by the zoom level. We should not keep it part of the state\n    // otherwise restoring the state might break the normal zooming process.\n    // Covered by SchedulerState.t\n    // https://github.com/bryntum/support/issues/5545\n    getState() {\n        const state = super.getState();\n\n        delete state.width;\n        delete state.flex;\n\n        return state;\n    }\n}\n\nColumnStore.registerColumnType(TimeAxisColumn);\n", "import Model from '../../Core/data/Model.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/preset/ViewPreset\n */\n\n/**\n * An object containing a unit identifier and an increment variable, used to define the `timeResolution` of a\n * `ViewPreset`.\n * @typedef {Object} ViewPresetTimeResolution\n * @property {String} unit The unit of the resolution, e.g. 'minute'\n * @property {Number} increment The increment of the resolution, e.g. 15\n */\n\n/**\n * Defines a header level for a ViewPreset.\n *\n * A sample header configuration can look like below\n * ```javascript\n * headers    : {\n *     {\n *         unit        : \"month\",\n *         renderer : function(start, end, headerConfig, index) {\n *             var month = start.getMonth();\n *             // Simple alternating month in bold\n *             if (start.getMonth() % 2) {\n *                 return '<strong>' + month + '</strong>';\n *             }\n *             return month;\n *         },\n *         align       : 'start' // `start` or `end`, omit to center content (default)\n *     },\n *     {\n *         unit        : \"week\",\n *         increment   : 1,\n *         renderer    : function(start, end, headerConfig, index) {\n *             return 'foo';\n *         }\n *     },\n * }\n * ```\n *\n * @typedef {Object} ViewPresetHeaderRow\n * @property {'start'|'center'|'end'} align The text alignment for the cell. Valid values are `start` or `end`, omit\n * this to center text content (default). Can also be added programmatically in `the renderer`.\n * @property {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit The unit of time\n * represented by each cell in this header row. See also increment property. Valid values are \"millisecond\", \"second\",\n * \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n * @property {String} headerCellCls A CSS class to add to the cells in the time axis header row. Can also be added\n * programmatically in the `renderer`.\n * @property {Number} increment The number of units each header cell will represent (e.g. 30 together with unit:\n * \"minute\" for 30 minute cells)\n * @property {String} dateFormat Defines how the cell date will be formatted\n * @property {Function} renderer A custom renderer function used to render the cell content. It should return text/HTML\n * to put in the header cell.\n *\n * ```javascript\n * function (startDate, endDate, headerConfig, i) {\n *   // applies special CSS class to align header left\n *   headerConfig.align = \"start\";\n *   // will be added as a CSS class of the header cell DOM element\n *   headerConfig.headerCellCls = \"myClass\";\n *\n *   return DateHelper.format(startDate, 'YYYY-MM-DD');\n * }\n * ```\n *\n * The render function is called with the following parameters:\n *\n * @property {Date} renderer.startDate The start date of the cell.\n * @property {Date} renderer.endDate The end date of the cell.\n * @property {Object} renderer.headerConfig An object containing the header config.\n * @property {'start'|'center'|'end'} [renderer.headerConfig.align] The text alignment for the cell. See `align` above.\n * @property {String} [renderer.headerConfig.headerCellCls] A CSS class to add to the cells in the time axis header row.\n * See `headerCellCls` above.\n * @property {Number} renderer.index The index of the cell in the row.\n * @property {Object} thisObj `this` reference for the renderer function\n * @property {Function} cellGenerator A function that should return an array of objects containing 'start', 'end' and\n * 'header' properties. Use this if you want full control over how the header rows are generated.\n *\n * **Note:** `cellGenerator` cannot be used for the bottom level of your headers.\n *\n * Example :\n * ```javascript\n * viewPreset : {\n *     displayDateFormat : 'H:mm',\n *     shiftIncrement    : 1,\n *     shiftUnit         : 'WEEK',\n *     timeResolution    : {\n *         unit      : 'MINUTE',\n *         increment : 10\n *     },\n *     headers           : [\n *         {\n *             unit          : 'year',\n *             // Simplified scenario, assuming view will always just show one US fiscal year\n *             cellGenerator : (viewStart, viewEnd) => [{\n *                 start  : viewStart,\n *                 end    : viewEnd,\n *                 header : `Fiscal Year ${viewStart.getFullYear() + 1}`\n *             }]\n *         },\n *         {\n *             unit : 'quarter',\n *             renderer(start, end, cfg) {\n *                 const\n *                     quarter       = Math.floor(start.getMonth() / 3) + 1,\n *                     fiscalQuarter = quarter === 4 ? 1 : (quarter + 1);\n *\n *                 return `FQ${fiscalQuarter} ${start.getFullYear() + (fiscalQuarter === 1 ? 1 : 0)}`;\n *             }\n *         },\n *         {\n *             unit       : 'month',\n *             dateFormat : 'MMM Y'\n *         }\n *     ]\n *  },\n * ```\n */\n\n/**\n * A ViewPreset is a record of {@link Scheduler.preset.PresetStore PresetStore} which describes the granularity\n * of the timeline view of a {@link Scheduler.view.Scheduler Scheduler} and the layout and subdivisions of the timeline header.\n *\n * You can create a new instance by specifying all fields:\n *\n * ```javascript\n * const myViewPreset = new ViewPreset({\n *     id   : 'myPreset',              // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *\n *     name : 'My view preset',        // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *\n *     tickWidth  : 24,                // Time column width in horizontal mode\n *     tickHeight : 50,                // Time column height in vertical mode\n *     displayDateFormat : 'HH:mm',    // Controls how dates will be displayed in tooltips etc\n *\n *     shiftIncrement : 1,             // Controls how much time to skip when calling shiftNext and shiftPrevious.\n *     shiftUnit      : 'day',         // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *     defaultSpan    : 12,            // By default, if no end date is supplied to a view it will show 12 hours\n *\n *     timeResolution : {              // Dates will be snapped to this resolution\n *         unit      : 'minute',       // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *         increment : 15\n *     },\n *\n *     headers : [                     // This defines your header rows from top to bottom\n *         {                           // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'thisObj'\n *             unit       : 'day',\n *             dateFormat : 'ddd DD/MM'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'HH:mm'\n *         }\n *     ],\n *\n *     columnLinesFor : 1              // Defines header level column lines will be drawn for. Defaults to the last level.\n * });\n * ```\n *\n * Or you can extend one of view presets registered in {@link Scheduler.preset.PresetManager PresetManager}:\n *\n * ```javascript\n * const myViewPreset2 = new ViewPreset({\n *     id   : 'myPreset',                  // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *     name : 'My view preset',            // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *     base : 'hourAndDay',                // Extends 'hourAndDay' view preset provided by PresetManager. You can pick out any of PresetManager's view presets: PresetManager.records\n *\n *     timeResolution : {                  // Override time resolution\n *         unit      : 'minute',\n *         increment : 15                  // Make it increment every 15 mins\n *     },\n *\n *     headers : [                         // Override headers\n *         {\n *             unit       : 'day',\n *             dateFormat : 'DD.MM.YYYY'   // Use different date format for top header 01.10.2020\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n * ```\n *\n * See {@link Scheduler.preset.PresetManager PresetManager} for the list of base presets. You may add your own\n * presets to this global list:\n *\n * ```javascript\n * PresetManager.add(myViewPreset);     // Adds new preset to the global scope. All newly created scheduler instances will have it too.\n *\n * const scheduler = new Scheduler({\n *     viewPreset : 'myPreset'\n *     // other configs...\n * });\n * ```\n *\n * Or add them on an individual basis to Scheduler instances:\n *\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * scheduler.presets.add(myViewPreset); // Adds new preset to the scheduler instance only. All newly created scheduler instances will **not** have it.\n *\n * scheduler.viewPreset = 'myPreset';\n * ```\n *\n * ## Defining custom header rows\n *\n * You can have any number of header rows by specifying {@link #field-headers}, see {@link #typedef-ViewPresetHeaderRow}\n * for the config object format and {@link Core.helper.DateHelper} for the supported date formats, or use to render\n * custom contents into the row cells.\n *\n * ```javascript\n *  headers : [\n *      {\n *          unit       : 'month',\n *          dateFormat : 'MM.YYYY'\n *      },\n *      {\n *          unit       : 'week',\n *          renderer   : ({ startDate }) => `Week ${DateHelper.format(startDate, 'WW')}`\n *      }\n *  ]\n * ```\n *\n * {@inlineexample Scheduler/preset/CustomHeader.js}\n *\n * This live demo shows a custom ViewPreset with AM/PM time format:\n * @inlineexample Scheduler/preset/amPmPreset.js\n * @extends Core/data/Model\n */\nexport default class ViewPreset extends Model {\n\n    static $name = 'ViewPreset';\n\n    static get fields() {\n        return [\n            /**\n             * The name of an existing view preset to extend\n             * @field {String} base\n             */\n            { name : 'base', type : 'string' },\n\n            /**\n             * The name of the view preset\n             * @field {String} name\n             */\n            { name : 'name', type : 'string' },\n\n            /**\n             * The height of the row in horizontal orientation\n             * @field {Number} rowHeight\n             * @default\n             */\n            {\n                name         : 'rowHeight',\n                defaultValue : 24\n            },\n\n            /**\n             * The width of the time tick column in horizontal orientation\n             * @field {Number} tickWidth\n             * @default\n             */\n            {\n                name         : 'tickWidth',\n                defaultValue : 50\n            },\n\n            /**\n             * The height of the time tick column in vertical orientation\n             * @field {Number} tickHeight\n             * @default\n             */\n            {\n                name         : 'tickHeight',\n                defaultValue : 50\n            },\n\n            /**\n             * Defines how dates will be formatted in tooltips etc\n             * @field {String} displayDateFormat\n             * @default\n             */\n            {\n                name         : 'displayDateFormat',\n                defaultValue : 'HH:mm'\n            },\n\n            /**\n             * The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.\n             * Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} shiftUnit\n             * @default\n             */\n            {\n                name         : 'shiftUnit',\n                defaultValue : 'hour'\n            },\n\n            /**\n             * The amount to shift (in shiftUnits)\n             * @field {Number} shiftIncrement\n             * @default\n             */\n            {\n                name         : 'shiftIncrement',\n                defaultValue : 1\n            },\n\n            /**\n             * The amount of time to show by default in a view (in the unit defined by {@link #field-mainUnit})\n             * @field {Number} defaultSpan\n             * @default\n             */\n            {\n                name         : 'defaultSpan',\n                defaultValue : 12\n            },\n\n            /**\n             * Initially set to a unit. Defaults to the unit defined by the middle header.\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} mainUnit\n             */\n            {\n                name : 'mainUnit'\n            },\n\n            /**\n             * Note: Currently, this field only applies when changing viewPreset with the {@link Scheduler.widget.ViewPresetCombo}.\n             *\n             * Set to a number and that amount of {@link #field-mainUnit} will be added to the startDate. For example: A\n             * start value of `5` together with the mainUnit `hours` will add 5 hours to the startDate. This can achieve\n             * a \"day view\" that starts 5 AM.\n             *\n             * Set to a string unit (for example week, day, month) and the startDate will be the start of that unit\n             * calculated from current startDate. A start value of `week` will result in a startDate in the first day of\n             * the week.\n             *\n             * If set to a number or not set at all, the startDate will be calculated at the beginning of current\n             * mainUnit.\n             * @field {Number|String} start\n             */\n            {\n                name : 'start'\n            },\n\n            /**\n             * An object containing a unit identifier and an increment variable. This value means minimal task duration\n             * you can create using UI. For example when you drag create a task or drag & drop a task, if increment is 5\n             * and unit is 'minute' that means that you can create a 5-minute-long task, or move it 5 min\n             * forward/backward. This config maps to scheduler's\n             * {@link Scheduler.view.mixin.TimelineDateMapper#property-timeResolution} config.\n             *\n             * ```javascript\n             * timeResolution : {\n             *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             *   increment : 5\n             * }\n             * ```\n             *\n             * @field {ViewPresetTimeResolution} timeResolution\n             */\n            'timeResolution',\n\n            /**\n             * An array containing one or more {@link #typedef-ViewPresetHeaderRow} config objects, each of\n             * which defines a level of headers for the scheduler.\n             * The `main` unit will be the last header's unit, but this can be changed using the\n             * {@link #field-mainHeaderLevel} field.\n             * @field {ViewPresetHeaderRow[]} headers\n             */\n            'headers',\n\n            /**\n             * Index of the {@link #field-headers} array to define which header level is the `main` header.\n             * Defaults to the bottom header.\n             * @field {Number} mainHeaderLevel\n             */\n            'mainHeaderLevel',\n\n            /**\n             * Index of a header level in the {@link #field-headers} array for which column lines are drawn. See\n             * {@link Scheduler.feature.ColumnLines}.\n             * Defaults to the bottom header.\n             * @field {Number} columnLinesFor\n             */\n            'columnLinesFor'\n        ];\n    }\n\n    construct() {\n        super.construct(...arguments);\n        this.normalizeUnits();\n    }\n\n    generateId(owner) {\n        const\n            me    = this,\n            {\n                headers\n            }     = me,\n            parts = [];\n\n        // If we were subclassed from a base, use that id as the basis of our.\n        let result = Object.getPrototypeOf(me.data).id;\n\n        if (!result) {\n            for (let { length } = headers, i = length - 1; i >= 0; i--) {\n                const\n                    { unit, increment } = headers[i],\n                    multiple            = increment > 1;\n\n                parts.push(`${multiple ? increment : ''}${i ? unit : StringHelper.capitalize(unit)}${multiple ? 's' : ''}`);\n            }\n\n            // Use upwards header units so eg \"monthAndYear\"\n            result = parts.join('And');\n        }\n\n        // If duplicate, decorate the generated by adding details.\n        // For example make it \"hourAndDay-50by80\"\n        // Only interrogate the store if it is loaded. If consulted during\n        // a load, the idMap will be created empty\n        if (owner.count && owner.includes(result)) {\n            result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;\n            // If still duplicate use increment\n            if (owner.includes(result)) {\n                result += `-${me.bottomHeader.increment}`;\n                // And if STILL duplicate, make it unique with a suffix\n                if (owner.includes(result)) {\n                    result = IdHelper.generateId(`${result}-`);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    normalizeUnits() {\n        const\n            me                                     = this,\n            { timeResolution, headers, shiftUnit } = me;\n\n        if (headers) {\n            // Make sure date \"unit\" constant specified in the preset are resolved\n            for (let i = 0, { length } = headers; i < length; i++) {\n                const header = headers[i];\n\n                header.unit = DH.normalizeUnit(header.unit);\n                if (header.splitUnit) {\n                    header.splitUnit = DH.normalizeUnit(header.splitUnit);\n                }\n                if (!('increment' in header)) {\n                    headers[i] = Object.assign({\n                        increment : 1\n                    }, header);\n                }\n            }\n        }\n\n        if (timeResolution) {\n            timeResolution.unit = DH.normalizeUnit(timeResolution.unit);\n        }\n\n        if (shiftUnit) {\n            me.shiftUnit = DH.normalizeUnit(shiftUnit);\n        }\n    }\n\n    // Process legacy columnLines config into a headers array.\n    static normalizeHeaderConfig(data) {\n        const\n            { headerConfig, columnLinesFor, mainHeaderLevel } = data,\n            headers                                           = data.headers = [];\n\n        if (headerConfig.top) {\n            if (columnLinesFor === 'top') {\n                data.columnLinesFor = 0;\n            }\n            if (mainHeaderLevel === 'top') {\n                data.mainHeaderLevel = 0;\n            }\n            headers[0] = headerConfig.top;\n        }\n        if (headerConfig.middle) {\n            if (columnLinesFor === 'middle') {\n                data.columnLinesFor = headers.length;\n            }\n            if (mainHeaderLevel === 'middle') {\n                data.mainHeaderLevel = headers.length;\n            }\n            headers.push(headerConfig.middle);\n        }\n        else {\n            throw new Error('ViewPreset.headerConfig must be configured with a middle');\n        }\n        if (headerConfig.bottom) {\n            // Main level is middle when using headerConfig object.\n            data.mainHeaderLevel = headers.length - 1;\n\n            // There *must* be a middle above this bottom header\n            // so that is the columnLines one by default.\n            if (columnLinesFor == null) {\n                data.columnLinesFor = headers.length - 1;\n            }\n            else if (columnLinesFor === 'bottom') {\n                data.columnLinesFor = headers.length;\n            }\n\n            // There *must* be a middle above this bottom header\n            // so that is the main one by default.\n            if (mainHeaderLevel == null) {\n                data.mainHeaderLevel = headers.length - 1;\n            }\n            if (mainHeaderLevel === 'bottom') {\n                data.mainHeaderLevel = headers.length;\n            }\n\n            headers.push(headerConfig.bottom);\n        }\n    }\n\n    // These are read-only once configured.\n    set() {}\n\n    inSet() {}\n\n    get columnLinesFor() {\n        return ('columnLinesFor' in this.data) ? this.data.columnLinesFor : this.headers.length - 1;\n    }\n\n    get tickSize() {\n        return this._tickSize || this.tickWidth;\n    }\n\n    get tickWidth() {\n        return ('tickWidth' in this.data) ? this.data.tickWidth : 50;\n    }\n\n    get tickHeight() {\n        return ('tickHeight' in this.data) ? this.data.tickHeight : 50;\n    }\n\n    get headerConfig() {\n        // Configured in the legacy manner, just return the configured value.\n        if (this.data.headerConfig) {\n            return this.data.headerConfig;\n        }\n\n        // Rebuild the object based upon the configured headers array.\n        const\n            result      = {},\n            { headers } = this,\n            { length }  = headers;\n\n        switch (length) {\n            case 1 :\n                result.middle = headers[0];\n                break;\n            case 2:\n                if (this.mainHeaderLevel === 0) {\n                    result.middle = headers[0];\n                    result.bottom = headers[1];\n                }\n                else {\n                    result.top    = headers[0];\n                    result.middle = headers[1];\n                }\n                break;\n            case 3:\n                result.top    = headers[0];\n                result.middle = headers[1];\n                result.bottom = headers[2];\n                break;\n            default:\n                throw new Error('headerConfig object not supported for >3 header levels');\n        }\n\n        return result;\n    }\n\n    set mainHeaderLevel(mainHeaderLevel) {\n        this.data.mainHeaderLevel = mainHeaderLevel;\n    }\n\n    get mainHeaderLevel() {\n        if ('mainHeaderLevel' in this.data) {\n            return this.data.mainHeaderLevel;\n        }\n\n        // 3 headers, then it's the middle\n        if (this.data.headers.length === 3) {\n            return 1;\n        }\n\n        // Assume it goes top, middle.\n        // If it's middle, top, use mainHeaderLevel : 0\n        return this.headers.length - 1;\n    }\n\n    get mainHeader() {\n        return this.headers[this.mainHeaderLevel];\n    }\n\n    get topHeader() {\n        return this.headers[0];\n    }\n\n    get topUnit() {\n        return this.topHeader.unit;\n    }\n\n    get topIncrement() {\n        return this.topHeader.increment;\n    }\n\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n\n    get leafUnit() {\n        return this.bottomHeader.unit;\n    }\n\n    get leafIncrement() {\n        return this.bottomHeader.increment;\n    }\n\n    get mainUnit() {\n        if ('mainUnit' in this.data) {\n            return this.data.mainUnit;\n        }\n        return this.mainHeader.unit;\n    }\n\n    get msPerPixel() {\n        const { bottomHeader } = this;\n\n        return Math.round(DH.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);\n    }\n\n    get isValid() {\n        const me = this;\n\n        let valid = true;\n\n        // Make sure all date \"unit\" constants are valid\n        for (const header of me.headers) {\n            valid = valid && Boolean(DH.normalizeUnit(header.unit));\n        }\n\n        if (me.timeResolution) {\n            valid = valid && DH.normalizeUnit(me.timeResolution.unit);\n        }\n\n        if (me.shiftUnit) {\n            valid = valid && DH.normalizeUnit(me.shiftUnit);\n        }\n\n        return valid;\n    }\n}\n", "import { unitMagnitudes } from '../../Core/helper/DateHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport '../../Scheduler/localization/En.js';\nimport Store from '../../Core/data/Store.js';\nimport PresetManager from './PresetManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/preset/PresetStore\n */\n\n/**\n * A special Store subclass which holds {@link Scheduler.preset.ViewPreset ViewPresets}.\n * Each ViewPreset in this store represents a zoom level. The store data is sorted in special\n * zoom order. That is zoomed out to zoomed in. The first Preset will produce the narrowest event bars\n * the last one will produce the widest event bars.\n *\n * To specify view presets (zoom levels) please provide set of view presets to the scheduler:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @extends Core/data/Store\n */\nexport default class PresetStore extends Localizable(Store) {\n\n    static get $name() {\n        return 'PresetStore';\n    }\n\n    static get defaultConfig() {\n        return {\n            useRawData : true,\n\n            modelClass : ViewPreset,\n\n            /**\n             * Specifies the sort order of the presets in the store.\n             * By default they are in zoomed out to zoomed in order. That is\n             * presets which will create widest event bars to presets\n             * which will produce narrowest event bars.\n             *\n             * Configure this as `-1` to reverse this order.\n             * @config {Number}\n             * @default\n             */\n            zoomOrder : 1\n        };\n    }\n\n    set storage(storage) {\n        super.storage = storage;\n\n        // Maintained in order automatically while adding.\n        this.storage.addSorter((lhs, rhs) => {\n            const\n                leftBottomHeader  = lhs.bottomHeader,\n                rightBottomHeader = rhs.bottomHeader;\n\n            // Sort order:\n            //  Milliseconds per pixel.\n            //  Tick size.\n            //  Unit magnitude.\n            //  Increment size.\n            const\n                order = rhs.msPerPixel - lhs.msPerPixel ||\n                unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] ||\n                leftBottomHeader.increment - rightBottomHeader.increment;\n\n            return order * this.zoomOrder;\n        });\n    }\n\n    get storage() {\n        return super.storage;\n    }\n\n    getById(id) {\n        // If we do not know about the id, inherit it from the PresetManager singleton\n        return super.getById(id) || !this.isPresetManager && PresetManager.getById(id);\n    }\n\n    createRecord(data, ...args) {\n        let result;\n\n        if (data.isViewPreset) {\n            return data;\n        }\n        if (typeof data === 'string') {\n            result = this.getById(data);\n        }\n        else if (typeof data === 'number') {\n            result = this.getAt(data);\n        }\n        // Its a ViewPreset data object\n        else {\n            // If it's extending an existing ViewPreset, inherit then override\n            // the data from the base.\n            if (data.base) {\n                data = this.copyBaseValues(data);\n            }\n\n            // Model constructor will call generateId if no id is provided\n            return super.createRecord(data, ...args);\n        }\n        if (!result) {\n            throw new Error(`ViewPreset ${data} does not exist`);\n        }\n        return result;\n    }\n\n    updateLocalization() {\n        super.updateLocalization();\n\n        const me = this;\n\n        // Collect presets from store...\n        let presets = me.allRecords;\n\n        // and basePresets if we are the PresetManager\n        if (me.isPresetManager) {\n            presets = new Set(presets.concat(Object.values(me.basePresets)));\n        }\n\n        presets.forEach(preset => {\n            let localePreset = me.optionalL(`L{PresetManager.${preset.id}}`, null, true);\n\n            // Default presets generated from base presets use localization of base if they have no own\n            if (typeof localePreset === 'string' && preset.baseId) {\n                localePreset = me.optionalL(`L{PresetManager.${preset.baseId}}`, null, true);\n            }\n\n            // Apply any custom format defined in locale, or the original format if none exists\n            if (localePreset && typeof localePreset === 'object') {\n                if (!preset.originalDisplayDateFormat) {\n                    preset.originalDisplayDateFormat = preset.displayDateFormat;\n                }\n\n                // <remove-on-release>\n                // TODO: work around to work topDateFormat for weekAndDay viewPreset localization.\n                //  it must be fixed on: https://github.com/bryntum/support/issues/1775\n                // </remove-on-release>\n                // it there is a topDateFormat but preset.mainHeaderLevel is 0, means the middle header is the top header actually,\n                // so convert property to middle (if middle doesn't exists) to localization understand (topDateFormat for weekAndDay for example)\n                // topDateFormat doesn't work when mainHeaderLevel is 0 because it doesn't have top config\n                // but has top header visually (Check on get headerConfig method in ViewPreset class)\n                if (preset.mainHeaderLevel === 0 && localePreset.topDateFormat) {\n                    localePreset.middleDateFormat = localePreset.middleDateFormat || localePreset.topDateFormat;\n                }\n\n                preset.setData('displayDateFormat', localePreset.displayDateFormat || preset.originalDisplayDateFormat);\n\n                ['top', 'middle', 'bottom'].forEach(level => {\n                    const\n                        levelConfig           = preset.headerConfig[level],\n                        localeLevelDateFormat = localePreset[level + 'DateFormat'];\n\n                    if (levelConfig) {\n                        if (!levelConfig.originalDateFormat) {\n                            levelConfig.originalDateFormat = levelConfig.dateFormat;\n                        }\n\n                        // if there was defined topDateFormat on locale file for example, use it instead of renderer from basePresets (https://github.com/bryntum/support/issues/1307)\n                        if (localeLevelDateFormat && levelConfig.renderer) {\n                            levelConfig.renderer = null;\n                        }\n\n                        levelConfig.dateFormat = localeLevelDateFormat || levelConfig.originalDateFormat;\n\n                    }\n                });\n\n                // The preset names are used in ViewPresetCombo and are localized by default\n                if (localePreset.name) {\n                    if (!preset.unlocalizedName) {\n                        preset.unlocalizedName = preset.name;\n                    }\n                    preset.setData('name', localePreset.name);\n                }\n                else if (preset.unlocalizedName && preset.unlocalizedName !== preset.name) {\n                    preset.name = preset.unlocalizedName;\n                    preset.unlocalizedName = null;\n                }\n            }\n        });\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // Preset config on Scheduler/Gantt expects array of presets and not store config\n    getCurrentConfig(options) {\n        return super.getCurrentConfig(options).data;\n    }\n\n    copyBaseValues(presetData) {\n        let base = this.getById(presetData.base);\n\n        if (!base) {\n            throw new Error(`ViewPreset base '${presetData.base}' does not exist.`);\n        }\n        base = ObjectHelper.clone(base.data);\n        delete base.id;\n        delete base.name;\n\n        // Merge supplied data into a clone of the base ViewPreset's data\n        // so that the new one overrides the base.\n        return ObjectHelper.merge(base, presetData);\n    }\n\n    add(preset) {\n        preset = Array.isArray(preset) ? preset : [preset];\n\n        preset.forEach(preset => {\n            // If a ViewPreset instance that extends another preset was added\n            // Only in add we can apply the base data\n            if (preset.isViewPreset && preset.base) {\n                preset.data = this.copyBaseValues(preset.originalData);\n            }\n        });\n        return super.add(...arguments);\n    }\n}\n", "import DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport PresetStore from './PresetStore.js';\n\n// No module tag here. That stops the singleton from being included by the docs.\n\n/**\n * ## Intro\n * This is a global Store of {@link Scheduler.preset.ViewPreset ViewPresets}, required to supply initial data to\n * Scheduler's {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n *\n * You can provide new view presets globally or for a specific scheduler.\n *\n * **NOTE:** You **cannot** modify existing records in the PresetManager store. You can either remove\n * preset records from the store or add new records to the store.\n * Also please keep in mind, all changes provided to the PresetManager store are not reflected to the\n * {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} of schedulers that already exist!\n *\n * If you want to have just a few presets (also known as zoom levels) in your Scheduler, you can slice corresponding records\n * from the `PresetManager` and apply them to the Scheduler `presets` config.\n * ```javascript\n * const newPresets = PresetManager.records.slice(10, 12);\n *\n * const scheduler = new Scheduler({\n *     presets    : newPresets, // Only 2 zoom levels are available\n *     viewPreset : newPresets[0].id\n * });\n * ```\n *\n * If you want to adjust all default presets and assign to a specific scheduler you are going to create,\n * you can extend them and pass as an array to the Scheduler `presets` config.\n * Here is an example of how to set the same `timeResolution` to all `ViewPresets`.\n * ```javascript\n * const newPresets = PresetManager.map(preset => {\n *     return {\n *         id             : 'my_' + preset.id,\n *         base           : preset.id, // Based on an existing preset\n *         timeResolution : {\n *             unit      : 'day',\n *             increment : 1\n *         }\n *     };\n * });\n *\n * const scheduler = new Scheduler({\n *     presets     : newPresets,\n *     viewPreset : 'my_hourAndDay'\n * });\n * ```\n *\n * If you want to do the same for **all** schedulers which will be created next, you can register new presets in a loop.\n * ```javascript\n * PresetManager.records.forEach(preset => {\n *     // Pass the same ID, so when a new preset is added to the store,\n *     // it will replace the current one.\n *     PresetManager.registerPreset(preset.id, {\n *        id             : preset.id,\n *        base           : preset.id,\n *        timeResolution : {\n *            unit      : 'day',\n *            increment : 1\n *        }\n *    });\n * });\n * ```\n *\n * Here is an example of how to add a new `ViewPreset` to the global `PresetManager` store and to the already created\n * scheduler `presets`.\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * const newGlobalPresets = PresetManager.add({\n *     id              : 'myNewPreset',\n *     base            : 'hourAndDay', // Based on an existing preset\n *     columnLinesFor  : 0,\n *     // Override headers\n *     headers : [\n *         {\n *             unit       : 'day',\n *             // Use different date format for top header 01.10.2020\n *             dateFormat : 'DD.MM.YYYY'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n *\n * // Add new presets to the scheduler that has been created before changes\n * // to PresetManager are applied\n * scheduler.presets.add(newGlobalPresets);\n * ```\n *\n * ## Predefined presets\n *\n * Predefined presets are:\n *\n * - `secondAndMinute` - creates a 2 level header - minutes and seconds:\n * {@inlineexample Scheduler/preset/secondAndMinute.js}\n * - `minuteAndHour` - creates a 2 level header - hours and minutes:\n * {@inlineexample Scheduler/preset/minuteAndHour.js}\n * - `hourAndDay` - creates a 2 level header - days and hours:\n * {@inlineexample Scheduler/preset/hourAndDay.js}\n * - `dayAndWeek` - creates a 2 level header - weeks and days:\n * {@inlineexample Scheduler/preset/dayAndWeek.js}\n * - `dayAndMonth` - creates a 2 level header - months and days:\n * {@inlineexample Scheduler/preset/dayAndMonth.js}\n * - `weekAndDay` - just like `dayAndWeek` but with different formatting:\n * {@inlineexample Scheduler/preset/weekAndDay.js}\n * - `weekAndDayLetter` - creates a 2 level header - weeks and day letters:\n * {@inlineexample Scheduler/preset/weekAndDayLetter.js}\n * - `weekAndMonth` - creates a 2 level header - months and weeks:\n * {@inlineexample Scheduler/preset/weekAndMonth.js}\n * - `weekDateAndMonth` - creates a 2 level header - months and weeks (weeks shown by first day only):\n * {@inlineexample Scheduler/preset/weekDateAndMonth.js}\n * - `monthAndYear` - creates a 2 level header - years and months:\n * {@inlineexample Scheduler/preset/monthAndYear.js}\n * - `year` - creates a 2 level header - years and quarters:\n * {@inlineexample Scheduler/preset/year.js}\n * - `manyYears` - creates a 2 level header - 5-years and years:\n * {@inlineexample Scheduler/preset/manyYears.js}\n *\n * See the {@link Scheduler.preset.ViewPreset} and {@link Scheduler.preset.ViewPresetHeaderRow} classes for a\n * description of the view preset properties.\n *\n * ## Localizing View Presets\n * Bryntum Scheduler uses locales for translations including date formats for view presets.\n *\n * To translate date format for view presets just define the date format for the specified region\n * for your locale file, like this:\n * ```javascript\n * const locale = {\n *\n *     localeName : 'En',\n *\n *     // ... Other translations here ...\n *\n *     PresetManager : {\n *         // Translation for the \"weekAndDay\" ViewPreset\n *         weekAndDay : {\n *             // Change the date format for the top and middle levels\n *             topDateFormat    : 'MMM',\n *             middleDateFormat : 'D'\n *         },\n *         // Translation for the \"dayAndWeek\" ViewPreset\n *         dayAndWeek : {\n *             // Change the date format for the top level\n *             topDateFormat : 'MMMM YYYY'\n *         }\n *     }\n * }\n *\n * LocaleManager.applyLocale(locale);\n * ```\n *\n * Check the <a target=\"_blank\" href=\"../examples/localization/\">localization demo</a> and [this guide](#Scheduler/guides/customization/localization.md) for more details.\n *\n * @singleton\n * @extends Scheduler/preset/PresetStore\n */\nclass PresetManager extends PresetStore {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{secondAndMinute}',\n        'L{minuteAndHour}',\n        'L{hourAndDay}',\n        'L{dayAndWeek}',\n        'L{weekAndDay}',\n        'L{day}',\n        'L{week}',\n        'L{dayAndMonth}',\n        'L{weekAndMonth}',\n        'L{weekAndDayLetter}',\n        'L{weekDateAndMonth}',\n        'L{monthAndYear}',\n        'L{year}',\n        'L{manyYears}'\n    ];\n    // endregion\n    // </debug>\n\n    static get $name() {\n        return 'PresetManager';\n    }\n\n    static get defaultConfig() {\n        return {\n            // To not break CSP demo\n            preventSubClassingModel : true,\n\n            basePresets : {\n                secondAndMinute : {\n                    name              : 'Seconds',\n                    tickWidth         : 30,   // Time column width\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LTS', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'minute', // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'second',  // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                        increment : 5\n                    },\n                    // This defines your header rows.\n                    // For each row you can define \"unit\", \"increment\", \"dateFormat\", \"renderer\", \"align\", and \"thisObj\"\n                    headers : [\n                        {\n                            unit       : 'minute',\n                            dateFormat : 'lll'\n                        },\n                        {\n                            unit       : 'second',\n                            increment  : 10,\n                            dateFormat : 'ss'\n                        }\n                    ]\n                },\n                minuteAndHour : {\n                    name              : 'Minutes',\n                    tickWidth         : 60,    // Time column width\n                    tickHeight        : 60,\n                    displayDateFormat : 'll LT', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'hour', // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'minute',  // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                        increment : 15\n                    },\n                    headers : [\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'ddd MM/DD, hA'\n                        },\n                        {\n                            unit       : 'minute',\n                            increment  : 30,\n                            dateFormat : 'mm'\n                        }\n                    ]\n                },\n                hourAndDay : {\n                    name              : 'Day',\n                    tickWidth         : 70,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    headers : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM' //Mon 01/10\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT'\n                        }\n                    ]\n                },\n                day : {\n                    name              : 'Day/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM', // Mon 01/02\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit : 'hour',\n                            renderer(value) {\n                                return `\n                                    <div class=\"b-sch-calendarcolumn-ct\"><span class=\"b-sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"b-sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span></div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                week : {\n                    name              : 'Week/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'week',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'D d',\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT',    // will be overridden by renderer\n                            renderer(value) {\n                                return `\n                                    <div class=\"sch-calendarcolumn-ct\">\n                                    <span class=\"sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span>\n                                    </div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                dayAndWeek : {\n                    name              : 'Days & Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'day',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 5,\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit : 'week',\n                            renderer(start) {\n                                return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');\n                            }\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'dd DD'\n                        }\n                    ]\n                },\n                // dayAndMonth : {\n                //     name              : 'Days & Months',\n                //     tickWidth         : 100,\n                //     tickHeight        : 80,\n                //     displayDateFormat : 'll LT',\n                //     shiftUnit         : 'day',\n                //     shiftIncrement    : 1,\n                //     defaultSpan       : 5,\n                //     timeResolution    : {\n                //         unit      : 'hour',\n                //         increment : 1\n                //     },\n                //     headers : [\n                //         {\n                //             unit       : 'month',\n                //             dateFormat : 'MMMM YYYY',\n                //             align      : 'start'\n                //         },\n                //         {\n                //             unit       : 'day',\n                //             dateFormat : 'dd DD'\n                //         }\n                //     ]\n                // },\n                dayAndMonth : {\n                    name              : 'Month',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'month',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    mainUnit          : 'month',\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMMM YYYY'\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                weekAndDay : {\n                    name              : 'Week',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll hh:mm A',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'YYYY MMMM DD' // 2017 January 01\n                        },\n                        {\n                            unit       : 'day',\n                            increment  : 1,\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndMonth : {\n                    name              : 'Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 105,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 5,\n                    defaultSpan       : 6,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndDayLetter : {\n                    name              : 'Weeks/weekdays',\n                    tickWidth         : 20,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit                : 'week',\n                            dateFormat          : 'ddd DD MMM YYYY',\n                            verticalColumnWidth : 115\n                        },\n                        {\n                            unit                : 'day',\n                            dateFormat          : 'd1',\n                            verticalColumnWidth : 25\n                        }\n                    ]\n                },\n                weekDateAndMonth : {\n                    name              : 'Months/weeks',\n                    tickWidth         : 30,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'YYYY MMMM'\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                monthAndYear : {\n                    name              : 'Months',\n                    tickWidth         : 110,\n                    tickHeight        : 110,\n                    displayDateFormat : 'll',\n                    shiftIncrement    : 3,\n                    shiftUnit         : 'month',\n                    defaultSpan       : 12,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY' //2017\n                        },\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        }\n                    ]\n                },\n                year : {\n                    name                : 'Years',\n                    tickWidth           : 100,\n                    tickHeight          : 100,\n                    resourceColumnWidth : 100,\n                    displayDateFormat   : 'll',\n                    shiftUnit           : 'year',\n                    shiftIncrement      : 1,\n                    defaultSpan         : 1,\n                    timeResolution      : {\n                        unit      : 'month',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY'\n                        },\n                        {\n                            unit : 'quarter',\n                            renderer(start, end, cfg) {\n                                return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);\n                            }\n                        }\n                    ]\n                },\n                manyYears : {\n                    name              : 'Multiple years',\n                    tickWidth         : 40,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'year',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'year',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit      : 'year',\n                            increment : 5,\n                            renderer  : (start, end) => start.getFullYear() + ' - ' + end.getFullYear()\n                        },\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YY',\n                            increment  : 1\n                        }\n                    ]\n                }\n            },\n\n            // This is a list of bryntum-supplied preset adjustments used to create the Scheduler's\n            // default initial set of ViewPresets.\n            defaultPresets : [\n                // Years over years\n                'manyYears',\n                { width : 80, increment : 1, resolution : 1, base : 'manyYears', resolutionUnit : 'YEAR' },\n\n                // Years over quarters\n                'year',\n                { width : 30,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 50,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 200, increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n\n                // Years over months\n                'monthAndYear',\n\n                // Months over weeks\n                'weekDateAndMonth',\n\n                // Months over weeks\n                'weekAndMonth',\n\n                // Months over weeks\n                'weekAndDayLetter',\n\n                // Months over days\n                'dayAndMonth',\n\n                // Weeks over days\n                'weekAndDay',\n                { width : 54, increment : 1, resolution : 1, base : 'weekAndDay', resolutionUnit : 'HOUR' },\n\n                // Days over hours\n                'hourAndDay',\n                { width : 64,  increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 100, increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 64,  increment : 2, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n\n                // Hours over minutes\n                'minuteAndHour',\n                { width : 60,  increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 130, increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 60,  increment : 5,  resolution : 5, base : 'minuteAndHour' },\n                { width : 100, increment : 5,  resolution : 5, base : 'minuteAndHour' },\n\n                // Minutes over seconds\n                'secondAndMinute',\n                { width : 60,  increment : 10, resolution : 5, base : 'secondAndMinute' },\n                { width : 130, increment : 5,  resolution : 5, base : 'secondAndMinute' }\n            ],\n\n            internalListeners : {\n                locale : 'updateLocalization'\n            }\n        };\n    }\n\n    set basePresets(basePresets) {\n        const presetCache = this._basePresets = {};\n\n        for (const id in basePresets) {\n            basePresets[id].id = id;\n            presetCache[id] = this.createRecord(basePresets[id]);\n        }\n    }\n\n    get basePresets() {\n        return this._basePresets;\n    }\n\n    set defaultPresets(defaultPresets) {\n        for (let i = 0, { length } = defaultPresets; i < length; i++) {\n            const\n                presetAdjustment   = defaultPresets[i],\n                isBase             = typeof presetAdjustment === 'string',\n                baseType           = isBase ? presetAdjustment : presetAdjustment.base;\n\n            let preset;\n\n            // The default was just a string, so it's an unmodified instance of a base type.\n            if (isBase) {\n                preset = this.basePresets[baseType];\n            }\n            // If it's an object, it's an adjustment to a base type\n            else {\n                const\n                    config             = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), { id : baseType }),\n                    { timeResolution } = config,\n                    bottomHeader       = config.headers[config.headers.length - 1];\n\n                config.id = undefined;\n\n                if ('width' in presetAdjustment) {\n                    config.tickWidth = presetAdjustment.width;\n                }\n                if ('height' in presetAdjustment) {\n                    config.tickHeight = presetAdjustment.height;\n                }\n                if ('increment' in presetAdjustment) {\n                    bottomHeader.increment = presetAdjustment.increment;\n                }\n                if ('resolution' in presetAdjustment) {\n                    timeResolution.increment = presetAdjustment.resolution;\n                }\n                if ('resolutionUnit' in presetAdjustment) {\n                    timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);\n                }\n\n                preset = this.createRecord(config);\n\n                // Keep id of original preset around, used with localization in PresetStore\n                preset.baseId = baseType;\n            }\n            this.add(preset);\n        }\n    }\n\n    getById(id) {\n        // Look first in the default set, and if it's one of the base types that is not imported into the\n        // default set, then look at the bases.\n        return super.getById(id) || this.basePresets[id];\n    }\n\n    /**\n     * Registers a new view preset base to be used by any scheduler grid or tree on the page.\n     * @param {String} id The unique identifier for this preset\n     * @param {ViewPresetConfig} config The configuration properties of the view preset (see\n     * {@link Scheduler.preset.ViewPreset} for more information)\n     * @returns {Scheduler.preset.ViewPreset} A new ViewPreset based upon the passed configuration.\n     */\n    registerPreset(id, config) {\n        const\n            preset = this.createRecord(Object.assign({\n                id\n            }, config)),\n            existingDuplicate = this.find(p => p.equals(preset));\n\n        if (existingDuplicate) {\n            return existingDuplicate;\n        }\n\n        if (preset.isValid) {\n            this.add(preset);\n        }\n        else {\n            throw new Error('Invalid preset, please check your configuration');\n        }\n\n        return preset;\n    }\n\n    getPreset(preset) {\n        if (typeof preset === 'number') {\n            preset = this.getAt(preset);\n        }\n        if (typeof preset === 'string') {\n            preset = this.getById(preset);\n        }\n        else if (!(preset instanceof ViewPreset)) {\n            preset = this.createRecord(preset);\n        }\n        return preset;\n    }\n\n    /**\n     * Applies preset customizations or fetches a preset view preset using its name.\n     * @param {String|ViewPresetConfig} presetOrId Id of a predefined preset or a preset config object\n     * @returns {Scheduler.preset.ViewPreset} Resulting ViewPreset instance\n     */\n    normalizePreset(preset) {\n        const me = this;\n\n        if (!(preset instanceof ViewPreset)) {\n            if (typeof preset === 'string') {\n                preset = me.getPreset(preset);\n                if (!preset) {\n                    throw new Error('You must define a valid view preset. See PresetManager for reference');\n                }\n            }\n            else if (typeof preset === 'object') {\n                // Look up any existing ViewPreset that it is based upon.\n                if (preset.base) {\n                    const base = this.getById(preset.base);\n\n                    if (!base) {\n                        throw new Error(`ViewPreset base '${preset.base}' does not exist`);\n                    }\n                    // The config is based upon the base's data with the new config object merged in.\n                    preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);\n                }\n\n                // Ensure the new ViewPreset has a legible, logical id which does not already\n                // exist in our store.\n                if (preset.id) {\n                    preset = me.createRecord(preset);\n                }\n                else {\n                    preset = me.createRecord(ObjectHelper.assign({}, preset));\n                    preset.id = preset.generateId(preset);\n                }\n            }\n        }\n\n        return preset;\n    }\n\n    /**\n     * Deletes a view preset\n     * @param {String} id The id of the preset, or the preset instance.\n     */\n    deletePreset(presetOrId) {\n        if (typeof presetOrId === 'string') {\n            presetOrId = this.getById(presetOrId);\n        }\n        else if (typeof presetOrId === 'number') {\n            presetOrId = this.getAt(presetOrId);\n        }\n\n        if (presetOrId) {\n            this.remove(presetOrId);\n\n            // ALso remove it from our base list\n            delete this.basePresets[presetOrId.id];\n        }\n    }\n}\n\nconst pm = new PresetManager();\n\nexport { pm as default };\n", "import Store from '../../Core/data/Store.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport TimeSpan from '../model/TimeSpan.js';\nimport ViewPreset from '../preset/ViewPreset.js';\nimport PresetManager from '../preset/PresetManager.js';\n\n/**\n * @module Scheduler/data/TimeAxis\n */\n\n// Micro-optimized version of TimeSpan for faster reading. Hit a lot and since it is internal fields are guaranteed to\n// not be remapped and changes won't be batches, so we can always return raw value from data avoiding all additional\n// checks and logic\nclass Tick extends TimeSpan {\n    // Only getters on purpose, we do not support manipulating ticks\n\n    get startDate() {\n        return this.data.startDate;\n    }\n\n    get endDate() {\n        return this.data.endDate;\n    }\n}\n\n/**\n * A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this\n * class. This is a pure \"data\" (model) representation of the time axis and has no UI elements.\n *\n * The time axis can be {@link #config-continuous} or not. In continuous mode, each timespan starts where the previous\n * ended, and in non-continuous mode there can be gaps between the ticks.\n * A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time\n * axis.\n *\n * To create a non-continuous time axis you have 2 options. First, you can create a time axis containing only the time\n * spans of interest. To do that, subclass this class and override the {@link #property-generateTicks} method.\n *\n * The other alternative is to call the {@link #function-filterBy} method, passing a function to it which should return\n * `false` if the time tick should be filtered out. Calling {@link Core.data.mixin.StoreFilter#function-clearFilters}\n * will return you to a full time axis.\n *\n * @extends Core/data/Store\n */\nexport default class TimeAxis extends Store {\n    //region Events\n\n    /**\n     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return `false`\n     * to abort the operation.\n     * @event beforeReconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     * @param {Date} startDate The new time axis start date\n     * @param {Date} endDate The new time axis end date\n     */\n\n    /**\n     * Event that is triggered when we end reconfiguring and everything UI-related should be done\n     * @event endReconfigure\n     * @private\n     */\n\n    /**\n     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)\n     * @event reconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n\n    /**\n     * Fires if all the ticks in the timeaxis are filtered out. After firing the filter is temporarily disabled to\n     * return the time axis to a valid state. A disabled filter will be re-enabled the next time ticks are regenerated\n     * @event invalidFilter\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n\n    //endregion\n\n    //region Default config\n\n    static get defaultConfig() {\n        return {\n            modelClass : Tick,\n\n            /**\n             * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).\n             * @config {Boolean}\n             * @default\n             */\n            continuous : true,\n\n            originalContinuous : null,\n\n            /**\n             * Include only certain hours or days in the time axis (makes it `continuous : false`). Accepts and object\n             * with `day` and `hour` properties:\n             * ```\n             * const scheduler = new Scheduler({\n             *     timeAxis : {\n             *         include : {\n             *              // Do not display hours after 17 or before 9 (only display 9 - 17). The `to´ value is not\n             *              // included in the time axis\n             *              hour : {\n             *                  from : 9,\n             *                  to   : 17\n             *              },\n             *              // Do not display sunday or saturday\n             *              day : [0, 6]\n             *         }\n             *     }\n             * }\n             * ```\n             * In most cases we recommend that you use Scheduler's workingTime config instead. It is easier to use and\n             * makes sure all parts of the Scheduler gets updated.\n             * @config {Object}\n             */\n            include : null,\n\n            /**\n             * Automatically adjust the timespan when generating ticks with {@link #property-generateTicks} according to\n             * the `viewPreset` configuration. Setting this to false may lead to shifting time/date of ticks.\n             * @config {Boolean}\n             * @default\n             */\n            autoAdjust : true,\n\n            //isConfigured : false,\n\n            // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick\n            // these dates will contain adjusted start/end (like if the tick has not been truncated)\n            adjustedStart    : null,\n            adjustedEnd      : null,\n            // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`\n            visibleTickStart : null,\n            // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count\n            visibleTickEnd   : null,\n\n            tickCache : {},\n\n            viewPreset       : null,\n            maxTraverseTries : 100,\n            useRawData       : {\n                disableDuplicateIdCheck : true,\n                disableDefaultValue     : true,\n                disableTypeConversion   : true\n            }\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:\n             * ```\n             * {\n             *    startDate : ..., // start date\n             *    endDate   : ...  // end date\n             * }\n             * ```\n             * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.\n             *\n             * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/) example and navigate to \"Compressed non-working time\" tab.\n             *\n             * @param {Date} axisStartDate The start date of the interval\n             * @param {Date} axisEndDate The end date of the interval\n             * @param {String} unit The unit of the time axis\n             * @param {Number} increment The increment for the unit specified.\n             * @returns {Array} ticks The ticks representing the time axis\n             * @config {Function}\n             */\n            generateTicks : null,\n\n            unit                : null,\n            increment           : null,\n            resolutionUnit      : null,\n            resolutionIncrement : null,\n            mainUnit            : null,\n            shiftUnit           : null,\n            shiftIncrement      : 1,\n            defaultSpan         : 1,\n\n            weekStartDay : null,\n\n            // Used to force resolution to match whole ticks, to snap accordingly when using fillTicks in the UI\n            forceFullTicks : null\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    // private\n    construct(config) {\n        const me = this;\n\n        super.construct(config);\n\n        me.originalContinuous = me.continuous;\n\n        me.ion({\n            change : ({ action }) => {\n                // If the change was due to filtering, there will be a refresh event\n                // arriving next, so do not reconfigure\n                if (action !== 'filter') {\n                    me.trigger('reconfigure', { supressRefresh : false });\n                }\n            },\n            refresh        : () => me.trigger('reconfigure', { supressRefresh : false }),\n            endreconfigure : event => me.trigger('reconfigure', event)\n        });\n\n        if (me.startDate) {\n            me.internalOnReconfigure();\n            me.trigger('reconfigure');\n        }\n        else if (me.viewPreset) {\n            const range  = me.getAdjustedDates(new Date());\n            me.startDate = range.startDate;\n            me.endDate   = range.endDate;\n        }\n    }\n\n    get isTimeAxis() {\n        return true;\n    }\n\n    //endregion\n\n    //region Configuration (reconfigure & consumePreset)\n\n    /**\n     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.\n     * @param {Object} config\n     * @param {Boolean} [suppressRefresh]\n     * @private\n     */\n    reconfigure(config, suppressRefresh = false, preventThrow = false) {\n        const\n            me         = this,\n            normalized = me.getAdjustedDates(config.startDate, config.endDate),\n            oldConfig  = {};\n\n        if (me.trigger('beforeReconfigure', { startDate : normalized.startDate, endDate : normalized.endDate, config }) !== false) {\n            me.trigger('beginReconfigure');\n\n            me._configuredStartDate = config.startDate;\n            me._configuredEndDate   = config.endDate;\n\n            // Collect old values for end event\n            for (const propName in config) {\n                oldConfig[propName] = me[propName];\n            }\n\n            const viewPresetChanged = config.viewPreset && config.viewPreset !== me.viewPreset;\n\n            // If changing viewPreset, try to gracefully recover if an applied filter results in an empty view\n            if (viewPresetChanged) {\n                preventThrow = me.isFiltered;\n\n                me.filters.forEach(f => f.disabled = false);\n            }\n            Object.assign(me, config);\n\n            if (me.internalOnReconfigure(preventThrow, viewPresetChanged) === false) {\n                return false;\n            }\n\n            me.trigger('endReconfigure', { suppressRefresh, config, oldConfig });\n        }\n    }\n\n    internalOnReconfigure(preventThrow = false, viewPresetChanged) {\n        const me = this;\n\n        me.isConfigured = true;\n\n        const\n            adjusted   = me.getAdjustedDates(me.startDate, me.endDate, true),\n            normalized = me.getAdjustedDates(me.startDate, me.endDate),\n            start      = normalized.startDate,\n            end        = normalized.endDate;\n\n        if (start >= end) {\n            throw new Error(`Invalid start/end dates. Start date must be less than end date. Start date: ${start}. End date: ${end}.`);\n        }\n\n        const\n            { unit, increment = 1 } = me,\n            ticks                   = me.generateTicks(start, end, unit, increment);\n\n        // Suspending to be able to detect an invalid filter\n        me.suspendEvents();\n        me.maintainFilter = preventThrow;\n        me.data           = ticks;\n        me.maintainFilter = false;\n\n        const { count } = me;\n\n        if (count === 0) {\n            if (preventThrow) {\n                if (viewPresetChanged) {\n                    me.disableFilters();\n                }\n                me.resumeEvents();\n                return false;\n            }\n            throw new Error('Invalid time axis configuration or filter, please check your input data.');\n        }\n\n        // start date is cached, update it to fill after generated ticks\n        me.startDate = me.first.startDate;\n        me.endDate   = me.last.endDate;\n\n        me.resumeEvents();\n\n        if (me.isContinuous) {\n            me.adjustedStart = adjusted.startDate;\n            me.adjustedEnd   = DH.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);\n        }\n        else {\n            me.adjustedStart = me.startDate;\n            me.adjustedEnd   = me.endDate;\n        }\n\n        me.updateVisibleTickBoundaries();\n\n        me.updateTickCache(true);\n    }\n\n    updateVisibleTickBoundaries() {\n        const\n            me = this,\n            {\n                count,\n                unit,\n                startDate,\n                endDate,\n                weekStartDay,\n                increment = 1\n            }  = me;\n\n        // Denominator is amount of milliseconds in a full tick (unit * increment). Normally we use 30 days in a month\n        // and 365 days in a year. But if month is 31 day long or year is a leap one standard formula might calculate\n        // wrong value. e.g. if we're rendering 1 day from August, formula goes like (2021-08-31 - 2021-08-02) / 30 = 1\n        // and renders full tick which is incorrect. For such cases we need to adjust denominator to a correct one.\n        // Thankfully there are only a few of them - month, year and day with DST transition.\n        const\n            startDenominator = DH.getNormalizedUnitDuration(startDate, unit) * increment,\n            endDenominator   = DH.getNormalizedUnitDuration(endDate, unit) * increment;\n\n        // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to\n        // drop it and adjust \"adjustedStart\" accordingly\n        do {\n            me.visibleTickStart = (startDate - me.adjustedStart) / startDenominator;\n\n            // <remove-on-release>\n            // TODO: Changed from round to floor which seems to work, but this is not needed in ExtScheduler. Need to step and see what is different\n            // </remove-on-release>\n            if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);\n\n            if (me.visibleTickStart >= 1) me.adjustedStart = DH.getNext(me.adjustedStart, unit, increment, weekStartDay);\n        } while (me.visibleTickStart >= 1);\n\n        do {\n            me.visibleTickEnd = count - (me.adjustedEnd - endDate) / endDenominator;\n\n            if (count - me.visibleTickEnd >= 1) me.adjustedEnd = DH.getNext(me.adjustedEnd, unit, -1, weekStartDay);\n        } while (count - me.visibleTickEnd >= 1);\n\n        // This flag indicates that the time axis starts exactly on a tick boundary and finishes on a tick boundary\n        // This is used as an optimization flag by TimeAxisViewModel.createHeaderRow\n        me.fullTicks = !me.visibleTickStart && me.visibleTickEnd === count;\n    }\n\n    /**\n     * Get the currently used time unit for the ticks\n     * @readonly\n     * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit\n     */\n\n    /**\n     * Get/set currently used preset\n     * @property {Scheduler.preset.ViewPreset}\n     */\n    get viewPreset() {\n        return this._viewPreset;\n    }\n\n    set viewPreset(preset) {\n        const me = this;\n\n        preset = PresetManager.getPreset(preset);\n\n        if (!(preset instanceof ViewPreset)) {\n            throw new Error('TimeAxis must be configured with the ViewPreset instance that the Scheduler is using');\n        }\n\n        me._viewPreset = preset;\n\n        Object.assign(me, {\n            unit      : preset.bottomHeader.unit,\n            increment : preset.bottomHeader.increment || 1,\n\n            resolutionUnit      : preset.timeResolution.unit,\n            resolutionIncrement : preset.timeResolution.increment,\n\n            mainUnit       : preset.mainHeader.unit,\n            shiftUnit      : preset.shiftUnit || preset.mainHeader.unit,\n            shiftIncrement : preset.shiftIncrement || 1,\n\n            defaultSpan : preset.defaultSpan || 1,\n            presetName  : preset.id,\n\n            // Weekview columns are updated upon 'datachanged' event on this object.\n            // We have to pass headers in order to render them correctly (timeAxisViewModel is incorrect in required time)\n            headers : preset.headers\n        });\n    }\n\n    //endregion\n\n    //region Getters & setters\n\n    get weekStartDay() {\n        return this._weekStartDay ?? DH.weekStartDay;\n    }\n\n    // private\n    get resolution() {\n        return {\n            unit      : this.resolutionUnit,\n            increment : this.resolutionIncrement\n        };\n    }\n\n    // private\n    set resolution(resolution) {\n        this.resolutionUnit      = resolution.unit;\n        this.resolutionIncrement = resolution.increment;\n    }\n\n    get resolutionUnit() {\n        return this.forceFullTicks ? this.unit : this._resolutionUnit;\n    }\n\n    get resolutionIncrement() {\n        return this.forceFullTicks ? this.increment : this._resolutionIncrement;\n    }\n\n    //endregion\n\n    //region Timespan & resolution\n\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     *\n     * **Note** This does **not** preserve the temporal scroll position. You may use\n     * {@link Scheduler.view.Scheduler#function-setTimeSpan} to set the time axis and\n     * maintain temporal scroll position (if possible).\n     * @param {Date} newStartDate The new start date\n     * @param {Date} [newEndDate] The new end date\n     */\n    setTimeSpan(newStartDate, newEndDate, preventThrow = false) {\n        // If providing a 0 span range, add default range\n        if (newEndDate && newStartDate - newEndDate === 0) {\n            newEndDate = null;\n        }\n\n        const\n            me                     = this,\n            { startDate, endDate } = me.getAdjustedDates(newStartDate, newEndDate);\n\n        if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {\n            return me.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n        }\n    }\n\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shift()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {String} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit = this.shiftUnit) {\n        const me = this;\n\n        let { startDate, endDate } = me;\n\n        // Use unfiltered start and end dates when shifting a filtered time axis, to lessen risk of messing it up.\n        // Still not guaranteed to work though\n        if (me.isFiltered) {\n            startDate = me.allRecords[0].startDate;\n            endDate   = me.allRecords[me.allCount - 1].endDate;\n        }\n\n        // Hack for filtered time axis, for example if weekend is filtered out and you shiftPrev() day from monday\n        let tries = 0;\n        do {\n            startDate = DH.add(startDate, amount, unit);\n            endDate   = DH.add(endDate, amount, unit);\n        } while (tries++ < me.maxTraverseTries && me.setTimeSpan(startDate, endDate, {\n            preventThrow : true\n        }) === false);\n    }\n\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`\n     * config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftNext()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount = this.shiftIncrement) {\n        this.shift(amount);\n    }\n\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftPrev()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount = this.shiftIncrement) {\n        this.shift(-amount);\n    }\n\n    //endregion\n\n    //region Filter & continuous\n\n    /**\n     * Filter the time axis by a function (and clears any existing filters first). The passed function will be called with each tick in time axis.\n     * If the function returns `true`, the 'tick' is included otherwise it is filtered. If all ticks are filtered out\n     * the time axis is considered invalid, triggering `invalidFilter` and then removing the filter.\n     * @param {Function} fn The function to be called, it will receive an object with `startDate`/`endDate` properties, and `index` of the tick.\n     * @param {Object} [thisObj] `this` reference for the function\n     * @typings {Promise<any|null>}\n     */\n    filterBy(fn, thisObj = this) {\n        const me = this;\n\n        me.filters.clear();\n\n        super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));\n    }\n\n    filter() {\n        const\n            me     = this,\n            retVal = super.filter(...arguments);\n\n        if (!me.maintainFilter && me.count === 0) {\n            me.resumeEvents();\n            me.trigger('invalidFilter');\n            me.disableFilters();\n        }\n\n        return retVal;\n    }\n\n    disableFilters() {\n        this.filters.forEach(f => f.disabled = true);\n\n        this.filter();\n    }\n\n    triggerFilterEvent(event) {\n        const me = this;\n\n        if (!event.filters.count) {\n            me.continuous = me.originalContinuous;\n        }\n        else {\n            me.continuous = false;\n        }\n\n        // Filters has been applied (or cleared) but listeners are not informed yet, update tick cache to have start and\n        // end dates correct when later redrawing events & header\n        me.updateTickCache();\n\n        super.triggerFilterEvent(event);\n    }\n\n    /**\n     * Returns `true` if the time axis is continuous (will return `false` when filtered)\n     * @property {Boolean}\n     */\n    get isContinuous() {\n        return this.continuous !== false && !this.isFiltered;\n    }\n\n    //endregion\n\n    //region Dates\n\n    getAdjustedDates(startDate, endDate, forceAdjust = false) {\n        const me = this;\n\n        // If providing a 0 span range, add default range\n        if (endDate && startDate - endDate === 0) {\n            endDate = null;\n        }\n\n        startDate = startDate || me.startDate;\n        endDate   = endDate || DH.add(startDate, me.defaultSpan, me.mainUnit);\n\n        return me.autoAdjust || forceAdjust ? {\n            startDate : me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),\n            endDate   : me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)\n        } : {\n            startDate,\n            endDate\n        };\n    }\n\n    /**\n     * Method to get the current start date of the time axis.\n     * @property {Date}\n     */\n    get startDate() {\n        // <remove-on-release>\n        // TODO: added _start as caching, might mess something up when reconfiguring? change here if tests fail\n        // </remove-on-release>\n        return this._start || (this.first ? new Date(this.first.startDate) : null);\n    }\n\n    set startDate(start) {\n        this._start = DH.parse(start);\n    }\n\n    /**\n     * Method to get a the current end date of the time axis\n     * @property {Date}\n     */\n    get endDate() {\n        return this._end || (this.last ? new Date(this.last.endDate) : null);\n    }\n\n    set endDate(end) {\n        if (end) this._end = DH.parse(end);\n    }\n\n    // used in performance critical code for comparisons\n    get startMS() {\n        return this._startMS;\n    }\n\n    // used in performance critical code for comparisons\n    get endMS() {\n        return this._endMS;\n    }\n\n    // Floors a date and optionally snaps it to one of the following resolutions:\n    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.\n    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,\n    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date\n    //\n    // returns a copy of the original date\n    // private\n    floorDate(date, relativeToStart, resolutionUnit, incr) {\n        relativeToStart = relativeToStart !== false;\n\n        const\n            me         = this,\n            relativeTo = relativeToStart ? DH.clone(me.startDate) : null,\n            increment  = incr || me.resolutionIncrement,\n            unit       = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            snap       = (value, increment) => Math.floor(value / increment) * increment;\n\n        if (relativeToStart) {\n            const snappedDuration = snap(DH.diff(relativeTo, date, unit), increment);\n            // <remove-on-release>\n            // TODO: used to be small unit multiplied with factor (minute = seconds, minutes * 60)\n            // </remove-on-release>\n            return DH.add(relativeTo, snappedDuration, unit, false);\n        }\n\n        const dt = DH.clone(date);\n\n        if (unit === 'week') {\n            const\n                day      = dt.getDay() || 7,\n                startDay = me.weekStartDay || 7;\n\n            DH.add(DH.startOf(dt, 'day', false), day >= startDay ? startDay - day : -(7 - startDay + day), 'day', false);\n\n            // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)\n            if (dt.getDay() !== startDay && dt.getHours() === 23) {\n                DH.add(dt, 1, 'hour', false);\n            }\n        }\n        else {\n            // removes \"smaller\" units from date (for example minutes; removes seconds and milliseconds)\n            DH.startOf(dt, unit, false);\n\n            // day and year are 1-based so need to make additional adjustments\n            const\n                modifier     = ['day', 'year'].includes(unit) ? 1 : 0,\n                useUnit      = unit === 'day' ? 'date' : unit,\n                snappedValue = snap(DH.get(dt, useUnit) - modifier, increment) + modifier;\n\n            DH.set(dt, useUnit, snappedValue);\n        }\n\n        return dt;\n    }\n\n    /**\n     * Rounds the date to nearest unit increment\n     * @private\n     */\n    roundDate(date, relativeTo, resolutionUnit = this.resolutionUnit, increment = this.resolutionIncrement || 1) {\n        const\n            me = this,\n            dt = DH.clone(date);\n\n        relativeTo = DH.clone(relativeTo || me.startDate);\n\n        switch (resolutionUnit) {\n            case 'week': {\n                DH.startOf(dt, 'day', false);\n\n                let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,\n                    toAdd;\n\n                if (distanceToWeekStartDay < 0) {\n                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;\n                }\n\n                if (Math.round(distanceToWeekStartDay / 7) === 1) {\n                    toAdd = 7 - distanceToWeekStartDay;\n                }\n                else {\n                    toAdd = -distanceToWeekStartDay;\n                }\n\n                return DH.add(dt, toAdd, 'day', false);\n            }\n\n            case 'month': {\n                const\n                    nbrMonths     = DH.diff(relativeTo, dt, 'month') + DH.as('month', dt.getDay() / DH.daysInMonth(dt)), //*/DH.as('month', DH.diff(relativeTo, dt)) + (dt.getDay() / DH.daysInMonth(dt)),\n                    snappedMonths = Math.round(nbrMonths / increment) * increment;\n                return DH.add(relativeTo, snappedMonths, 'month', false);\n            }\n\n            case 'quarter':\n                DH.startOf(dt, 'month', false);\n                return DH.add(dt, 3 - (dt.getMonth() % 3), 'month', false);\n\n            default: {\n                const\n                    duration        = DH.as(resolutionUnit, DH.diff(relativeTo, dt)),\n                    // Need to find the difference of timezone offsets between relativeTo and original dates. 0 if timezone offsets are the same.\n                    offset          = DH.as(resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),\n                    // Need to add the offset to the whole duration, so the divided value will take DST into account\n                    snappedDuration = Math.round((duration + offset) / increment) * increment;\n\n                // <remove-on-release>\n                // TODO: used to add one res unit lower * factor, minutes = add seconds, minutes * 60\n                // </remove-on-release>\n                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account\n                return DH.add(relativeTo, snappedDuration - offset, resolutionUnit, false);\n            }\n        }\n    }\n\n    // private\n    ceilDate(date, relativeToStart, resolutionUnit, increment) {\n        const me = this;\n\n        relativeToStart = relativeToStart !== false;\n        increment       = increment || (relativeToStart ? me.resolutionIncrement : 1);\n\n        const\n            unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            dt   = DH.clone(date);\n\n        let doCall = false;\n\n        switch (unit) {\n            case 'minute':\n                doCall = !DH.isStartOf(dt, 'minute');\n                break;\n\n            case 'hour':\n                doCall = !DH.isStartOf(dt, 'hour');\n                break;\n\n            case 'day':\n            case 'date':\n                doCall = !DH.isStartOf(dt, 'day');\n                break;\n\n            case 'week':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDay() !== me.weekStartDay || !DH.isEqual(dt, date));\n                break;\n\n            case 'month':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n\n            case 'quarter':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n\n            case 'year':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n        }\n\n        if (doCall) {\n            return DH.getNext(dt, unit, increment, me.weekStartDay);\n        }\n\n        return dt;\n    }\n\n    //endregion\n\n    //region Ticks\n\n    get include() {\n        return this._include;\n    }\n\n    set include(include) {\n        const me = this;\n\n        me._include   = include;\n        me.continuous = !include;\n\n        if (!me.isConfiguring) {\n            me.startDate = me._configuredStartDate;\n            me.endDate   = me._configuredEndDate;\n            me.internalOnReconfigure();\n            me.trigger('includeChange');\n        }\n    }\n\n    // Check if a certain date is included based on timeAxis.include rules\n    processExclusion(startDate, endDate, unit) {\n        const { include } = this;\n\n        if (include) {\n            return Object.entries(include).some(([includeUnit, rule]) => {\n\n                if (!rule) {\n                    return false;\n                }\n\n                const { from, to } = rule;\n\n                // Including the closest smaller unit with a { from, to} rule should affect start & end of the\n                // generated tick. Currently only works for days or smaller.\n                if (DH.compareUnits('day', unit) >= 0 && DH.getLargerUnit(includeUnit) === unit) {\n                    if (from) {\n                        DH.set(startDate, includeUnit, from);\n                    }\n\n                    if (to) {\n                        let stepUnit = unit;\n                        // Stepping back base on date, not day\n                        if (unit === 'day') {\n                            stepUnit = 'date';\n                        }\n                        // Since endDate is not inclusive it points to the next day etc.\n                        // Turns for example 2019-01-10T00:00 -> 2019-01-09T18:00\n                        DH.set(endDate, {\n                            [stepUnit]    : DH.get(endDate, stepUnit) - 1,\n                            [includeUnit] : to\n                        });\n                    }\n                }\n\n                // \"Greater\" unit being included? Then we need to care about it\n                // (for example excluding day will also affect hour, minute etc)\n                if (DH.compareUnits(includeUnit, unit) >= 0) {\n                    const datePart = (includeUnit === 'day' ? startDate.getDay() : DH.get(startDate, includeUnit));\n\n                    if ((from && datePart < from) || (to && datePart >= to)) {\n                        return true;\n                    }\n                }\n            });\n        }\n\n        return false;\n    }\n\n    // Calculate constants used for exclusion when scaling within larger ticks\n    initExclusion() {\n        Object.entries(this.include).forEach(([unit, rule]) => {\n            if (rule) {\n                const { from, to } = rule;\n\n                // For example for hour:\n                // 1. Get the next bigger unit -> day, get ratio -> 24\n                // 2. to 20 - from 8 = 12 hours visible each day. lengthFactor 24 / 12 = 2 means that each hour used\n                // needs to represent 2 hours when drawn (to stretch)\n                // |    ████    | -> |  ████████  |\n                rule.lengthFactor = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from);\n                // <remove-on-release>\n                // TODO: Since `to` is exclusive this should be the correct one... but cannot get it to work throughout\n                // </remove-on-release>\n                rule.lengthFactorExcl = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from - 1);\n\n                // Calculate weighted center to stretch around |   ██x█ |\n                rule.center = from + from / (rule.lengthFactor - 1);\n            }\n        });\n    }\n\n    /**\n     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:\n     * ```\n     * {\n     *    startDate : ..., // start date\n     *    endDate   : ...  // end date\n     * }\n     * ```\n     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.\n     *\n     * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/) example and navigate to \"Compressed non-working time\" tab.\n     *\n     * @member {Function} generateTicks\n     * @param {Date} axisStartDate The start date of the interval\n     * @param {Date} axisEndDate The end date of the interval\n     * @param {String} unit The unit of the time axis\n     * @param {Number} increment The increment for the unit specified.\n     * @returns {Array} ticks The ticks representing the time axis\n     */\n\n    updateGenerateTicks() {\n        if (!this.isConfiguring) {\n            this.reconfigure(this);\n        }\n    }\n\n    _generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {\n        const\n            me            = this,\n            ticks         = [],\n            usesExclusion = Boolean(me.include);\n\n        let intervalEnd,\n            tickEnd,\n            isExcluded,\n            dstDiff                = 0,\n            { startDate, endDate } = me.getAdjustedDates(axisStartDate, axisEndDate);\n\n        me.tickCache = {};\n\n        if (usesExclusion) {\n            me.initExclusion();\n        }\n\n        while (startDate < endDate) {\n            intervalEnd = DH.getNext(startDate, unit, increment, me.weekStartDay);\n\n            if (!me.autoAdjust && intervalEnd > endDate) {\n                intervalEnd = endDate;\n            }\n\n            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct\n            // Only do this for HOUR resolution currently, and only handle it once per tick generation.\n            if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {\n                const prev = ticks[ticks.length - 1];\n\n                dstDiff = ((prev.startDate.getHours() + increment) % 24) - prev.endDate.getHours();\n\n                if (dstDiff !== 0) {\n                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis \"symmetric\".\n                    intervalEnd = DH.add(intervalEnd, dstDiff, 'hour');\n                }\n            }\n\n            isExcluded = false;\n\n            if (usesExclusion) {\n                tickEnd    = new Date(intervalEnd.getTime());\n                isExcluded = me.processExclusion(startDate, intervalEnd, unit);\n            }\n            else {\n                tickEnd = intervalEnd;\n            }\n\n            if (!isExcluded) {\n                ticks.push({\n                    id      : (ticks.length + 1),\n                    startDate,\n                    endDate : intervalEnd\n                });\n                me.tickCache[startDate.getTime()] = ticks.length - 1;\n            }\n\n            startDate = tickEnd;\n        }\n\n        return ticks;\n    }\n\n    /**\n     * How many ticks are visible across the TimeAxis.\n     *\n     * Usually, this is an integer because {@link #config-autoAdjust} means that the start and end\n     * dates are adjusted to be on tick boundaries.\n     * @property {Number}\n     * @internal\n     */\n    get visibleTickTimeSpan() {\n        const me = this;\n        return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;\n    }\n\n    /**\n     * Gets a tick \"coordinate\" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.\n     * @param {Date} date the date\n     * @returns {Number} the tick position on the scale or -1 if the date is not part of the time axis\n     */\n    getTickFromDate(date) {\n        const\n            me     = this,\n            ticks  = me.records,\n            dateMS = date.getTime?.() ?? date;\n\n        let begin = 0,\n            end   = ticks.length - 1,\n            middle, tick, tickStart, tickEnd;\n\n        // Quickly eliminate out of range dates or if we have not been set up with a time range yet\n        if (!ticks.length || dateMS < ticks[0].startDateMS || dateMS > ticks[end].endDateMS) {\n            return -1;\n        }\n        if (me.isContinuous) {\n            // <remove-on-release>\n            // TODO: This is the code from ExtScheduler, it is a calculation without iteration so it should perform better,\n            //  we should consider using it...\n            // if (date - ticks[0].startDate === 0) return this.visibleTickStart;\n            // if (date - ticks[end].endDate === 0) return this.visibleTickEnd;\n            //\n            // const { adjustedStart, adjustedEnd }     = this;\n            //\n            // let tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));\n            //\n            // // for the date == adjustedEnd case\n            // if (tickIndex > end) {\n            //     tickIndex = end;\n            // }\n            //\n            // const tickStart           = tickIndex === 0 ? adjustedStart : ticks[tickIndex].startDate;\n            // const tickEnd             = tickIndex === end ? adjustedEnd : ticks[tickIndex].endDate;\n            //\n            // tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);\n            //\n            // // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but\n            // // from `visibleTickStart` coordinate, this check generally repeats the \"quick bailout\" check in the beginning of the method,\n            // // but still\n            // if (tick < this.visibleTickStart || tick > this.visibleTickEnd) {\n            //     return -1;\n            // }\n            //\n            // return tick;\n            // </remove-on-release>\n\n            // Chop tick cache in half until we find a match\n            while (begin < end) {\n                middle = (begin + end + 1) >> 1;\n                if (dateMS > ticks[middle].endDateMS) {\n                    begin = middle + 1;\n                }\n                else if (dateMS < ticks[middle].startDateMS) {\n                    end = middle - 1;\n                }\n                else {\n                    begin = middle;\n                }\n            }\n            tick      = ticks[begin];\n            tickStart = tick.startDateMS;\n\n            // Part way though, calculate the fraction\n            if (dateMS > tickStart) {\n                tickEnd = tick.endDateMS;\n                begin += (dateMS - tickStart) / (tickEnd - tickStart);\n            }\n\n            return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);\n        }\n        else {\n            for (let i = 0; i <= end; i++) {\n                tickEnd = ticks[i].endDateMS;\n\n                if (dateMS <= tickEnd) {\n                    tickStart = ticks[i].startDateMS;\n\n                    // date < tickStart can occur in filtered case\n                    tick = i + (dateMS > tickStart ? (dateMS - tickStart) / (tickEnd - tickStart) : 0);\n\n                    return tick;\n                }\n            }\n        }\n\n    }\n\n    /**\n     * Gets the time represented by a tick \"coordinate\".\n     * @param {Number} tick the tick \"coordinate\"\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @returns {Date} The date to represented by the tick \"coordinate\", or null if invalid.\n     */\n    getDateFromTick(tick, roundingMethod) {\n        const me = this;\n\n        if (tick === me.visibleTickEnd) {\n            return me.endDate;\n        }\n\n        const\n            wholeTick = Math.floor(tick),\n            fraction  = tick - wholeTick,\n            t         = me.getAt(wholeTick);\n\n        if (!t) {\n            return null;\n        }\n\n        const\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedStart property and should use tick start\n            start = wholeTick === 0 && me.isContinuous ? me.adjustedStart : t.startDate,\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end\n            end   = (wholeTick === me.count - 1) && me.isContinuous ? me.adjustedEnd : t.endDate;\n\n        let date = DH.add(start, fraction * (end - start), 'millisecond');\n\n        if (roundingMethod) {\n            date = me[roundingMethod + 'Date'](date);\n        }\n\n        return date;\n    }\n\n    /**\n     * Returns the ticks of the timeaxis in an array of objects with a \"startDate\" and \"endDate\".\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get ticks() {\n        return this.records;\n    }\n\n    /**\n     * Caches ticks and start/end dates for faster processing during rendering of events.\n     * @private\n     */\n    updateTickCache(onlyStartEnd = false) {\n        const me = this;\n\n        if (me.count) {\n            me._start   = me.first.startDate;\n            me._end     = me.last.endDate;\n            me._startMS = me.startDate.getTime();\n            me._endMS   = me.endDate.getTime();\n        }\n        else {\n            me._start = me._end = me._startMs = me._endMS = null;\n        }\n\n        // onlyStartEnd is true prior to clearing filters, to get start and end dates correctly during that process.\n        // No point in filling tickCache yet in that case, it will be done after the filters are cleared\n        if (!onlyStartEnd) {\n            me.tickCache = {};\n            me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);\n        }\n    }\n\n    //endregion\n\n    //region Axis\n\n    /**\n     * Returns true if the passed date is inside the span of the current time axis.\n     * @param {Date} date The date to query for\n     * @returns {Boolean} true if the date is part of the time axis\n     */\n    dateInAxis(date, inclusiveEnd = false) {\n        const\n            me        = this,\n            axisStart = me.startDate,\n            axisEnd   = me.endDate;\n\n        // Date is between axis start/end and axis is not continuous - need to perform better lookup\n        if (me.isContinuous) {\n            return inclusiveEnd ? DH.betweenLesserEqual(date, axisStart, axisEnd) : DH.betweenLesser(date, axisStart, axisEnd);\n        }\n        else {\n            const length = me.getCount();\n\n            let tickStart, tickEnd, tick;\n\n            for (let i = 0; i < length; i++) {\n                tick      = me.getAt(i);\n                tickStart = tick.startDate;\n                tickEnd   = tick.endDate;\n\n                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {\n                    return date >= tickStart;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the passed timespan is part of the current time axis (in whole or partially).\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @returns {Boolean} true if the timespan is part of the timeaxis\n     */\n    timeSpanInAxis(start, end) {\n        const me = this;\n\n        if (!end || end.getTime() === start.getTime()) {\n            return this.dateInAxis(start, true);\n        }\n\n        if (me.isContinuous) {\n            return DH.intersectSpans(start, end, me.startDate, me.endDate);\n        }\n\n        return (start < me.startDate && end > me.endDate) || me.getTickFromDate(start) !== me.getTickFromDate(end);\n    }\n\n    // Accepts a TimeSpan model (uses its cached MS values to be a bit faster during rendering)\n    isTimeSpanInAxis(timeSpan) {\n        const\n            me                         = this,\n            { startMS, endMS }         = me,\n            { startDateMS }            = timeSpan,\n            endDateMS                  = timeSpan.endDateMS ?? timeSpan.meta.endDateCached;\n\n        // only consider fully scheduled ranges\n        if (!startDateMS || !endDateMS) return false;\n\n        if (endDateMS === startDateMS) {\n            return me.dateInAxis(timeSpan.startDate, true);\n        }\n\n        if (me.isContinuous) {\n            return endDateMS > startMS && startDateMS < endMS;\n        }\n\n        const\n            startTick = me.getTickFromDate(timeSpan.startDate),\n            endTick   = me.getTickFromDate(timeSpan.endDate);\n\n        // endDate is not inclusive\n        // <remove-on-release>\n        // TODO: Handle in getTickFromDate() somehow?\n        // </remove-on-release>\n        if (\n            (startTick === me.count && DH.isEqual(timeSpan.startDate, me.last.endDate)) ||\n            (endTick === 0 && DH.isEqual(timeSpan.endDate, me.first.startDate))\n        ) {\n            return false;\n        }\n\n        return (\n            // Spanning entire axis\n            (startDateMS < startMS && endDateMS > endMS) ||\n            // Unintentionally 0 wide (ticks excluded or outside)\n            startTick !== endTick\n        );\n    }\n\n    //endregion\n\n    //region Iteration\n\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with four parameters, startDate endDate, index, isLastIteration.\n     * @internal\n     * @param {String} unit The unit to use when iterating over the timespan\n     * @param {Number} increment The increment to use when iterating over the timespan\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {\n        const end = this.endDate;\n\n        let dt = this.startDate,\n            i  = 0,\n            intervalEnd;\n\n        if (dt > end) throw new Error('Invalid time axis configuration');\n\n        while (dt < end) {\n            intervalEnd = DH.min(DH.getNext(dt, unit, increment, this.weekStartDay), end);\n            iteratorFn.call(thisObj, dt, intervalEnd, i, intervalEnd >= end);\n            dt = intervalEnd;\n            i++;\n        }\n    }\n\n    //endregion\n}\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DragHelper from '../../../Core/helper/DragHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Widget from '../../../Core/widget/Widget.js';\n\n/**\n * @module Scheduler/feature/base/DragBase\n */\n\n// <remove-on-release>\n// TODO: shift to copy\n// </remove-on-release>\n\n/**\n * Base class for EventDrag (Scheduler) and TaskDrag (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class DragBase extends InstancePlugin {\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            // documented on Schedulers EventDrag feature and Gantt's TaskDrag\n            tooltipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    ${data.startClockHtml}\n                    ${data.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${data.message}</div>\n                </div>\n            `,\n\n            /**\n             * Specifies whether or not to show tooltip while dragging event\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n\n            /**\n             * When enabled, the event being dragged always \"snaps\" to the exact start date that it will have after drop.\n             * @config {Boolean}\n             * @default\n             */\n            showExactDropPosition : false,\n\n            /*\n             * The store from which the dragged items are mapped to the UI.\n             * In Scheduler's implementation of this base class, this will be\n             * an EventStore, in Gantt's implementations, this will be a TaskStore.\n             * Because both derive from this base, we must refer to it as this.store.\n             * @private\n             */\n            store : null,\n\n            /**\n             * An object used to configure the internal {@link Core.helper.DragHelper} class\n             * @config {DragHelperConfig}\n             */\n            dragHelperConfig : null,\n\n            tooltipCls : 'b-eventdrag-tooltip'\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Set to `false` to allow dragging tasks outside the client Scheduler.\n             * Useful when you want to drag tasks between multiple Scheduler instances\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeline : true,\n\n            // documented on Schedulers EventDrag feature, not used for Gantt\n            constrainDragToResource : true,\n\n            constrainDragToTimeSlot : false,\n\n            /**\n             * Yields the {@link Core.widget.Tooltip} which tracks the event during a drag operation.\n             * @member {Core.widget.Tooltip} tip\n             */\n            /**\n             * A config object to allow customization of the {@link Core.widget.Tooltip} which tracks\n             * the event during a drag operation.\n             * @config {TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    align : {\n                        align          : 'b-t',\n                        allowTargetOut : true\n                    },\n                    autoShow                 : true,\n                    updateContentOnMouseMove : true\n                }\n            },\n\n            /**\n             * The `eventDrag`and `taskDrag` events are normally only triggered when the drag operation will lead to a\n             * change in date or assignment. By setting this config to `false`, that logic is bypassed to trigger events\n             * for each native mouse move event.\n             * @prp {Boolean}\n             */\n            throttleDragEvent : true\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    internalSnapToPosition(snapTo) {\n        const { dragData } = this;\n\n        this.snapToPosition?.({\n            assignmentRecord : dragData.assignmentRecord,\n            eventRecord      : dragData.eventRecord,\n            resourceRecord   : dragData.newResource || dragData.resourceRecord,\n            startDate        : dragData.startDate,\n            endDate          : dragData.endDate,\n            snapTo\n        });\n    }\n\n    buildDragHelperConfig() {\n        const\n            me                                  = this,\n            {\n                client,\n                constrainDragToTimeline,\n                constrainDragToResource,\n                constrainDragToTimeSlot,\n                dragHelperConfig = {}\n            }                                   = me,\n            { timeAxisViewModel, isHorizontal } = client,\n            lockY                               = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot,\n            lockX                               = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n\n        // If implementer wants to allow users dragging outside the timeline element, setup the internal dropTargetSelector\n        if (me.externalDropTargetSelector) {\n            dragHelperConfig.dropTargetSelector = `.b-timeaxissubgrid,${me.externalDropTargetSelector}`;\n        }\n\n        return Objects.merge({\n            name                 : me.constructor.name, // useful when debugging with multiple draggers\n            positioning          : 'absolute',\n            lockX,\n            lockY,\n            minX                 : true, // Allows dropping with start before time axis\n            maxX                 : true, // Allows dropping with end after time axis\n            constrain            : false,\n            cloneTarget          : !constrainDragToTimeline,\n            // If we clone event dragged bars, we assume ownership upon drop so we can reuse the element and have animations\n            removeProxyAfterDrop : false,\n            dragWithin           : constrainDragToTimeline ? null : document.body,\n            hideOriginalElement  : true,\n            dropTargetSelector   : '.b-timelinebase',\n\n            // A CSS class added to drop target while dragging events\n            dropTargetCls : me.externalDropTargetSelector ? 'b-drop-target' : '',\n\n            outerElement   : client.timeAxisSubGridElement,\n            targetSelector : client.eventSelector,\n            scrollManager  : constrainDragToTimeline ? client.scrollManager : null,\n            createProxy    : el => me.createProxy(el),\n\n            snapCoordinates : ({ element, newX, newY }) => {\n                const { dragData } = me;\n                // Snapping not supported when dragging outside a scheduler\n                if (me.constrainDragToTimeline && !me.constrainDragToTimeSlot && (me.showExactDropPosition || timeAxisViewModel.snap)) {\n                    const\n                        draggedEventRecord = dragData.draggedEntities[0],\n                        coordinate         = me.getCoordinate(draggedEventRecord, element, [newX, newY]),\n                        snappedDate        = timeAxisViewModel.getDateFromPosition(coordinate, 'round'),\n                        { calendar }       = draggedEventRecord;\n\n                    if (!calendar || snappedDate && calendar.isWorkingTime(snappedDate, DateHelper.add(snappedDate, draggedEventRecord.fullDuration))) {\n                        const snappedPosition = snappedDate && timeAxisViewModel.getPositionFromDate(snappedDate);\n\n                        if (snappedDate && snappedDate >= client.startDate && snappedPosition != null) {\n                            if (isHorizontal) {\n                                newX = snappedPosition;\n                            }\n                            else {\n                                newY = snappedPosition;\n                            }\n                        }\n                    }\n                }\n\n                const snapTo = { x : newX, y : newY };\n\n                me.internalSnapToPosition(snapTo);\n\n                return snapTo;\n            },\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                afterdragstart  : 'onAfterDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                abort           : 'onDragAbort',\n                abortFinalized  : 'onDragAbortFinalized',\n                reset           : 'onDragReset',\n                thisObj         : me\n            }\n        }, dragHelperConfig, {\n            isElementDraggable : (el, event) => {\n                return (!dragHelperConfig || !dragHelperConfig.isElementDraggable || dragHelperConfig.isElementDraggable(el, event)) &&\n                    me.isElementDraggable(el, event);\n            }\n        });\n    }\n\n    /**\n     * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        const\n            me         = this,\n            { client } = me;\n\n        me.drag?.destroy();\n\n        me.drag = DragHelper.new(me.buildDragHelperConfig());\n\n        if (firstPaint) {\n            client.rowManager.ion({\n                changeTotalHeight : () => me.updateYConstraint(me.dragData?.[`${client.scheduledEventName}Record`]),\n                thisObj           : me\n            });\n        }\n\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : client\n            });\n        }\n    }\n\n    doDestroy() {\n        this.drag?.destroy();\n        this.clockTemplate?.destroy();\n        this.tip?.destroy();\n        super.doDestroy();\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-drag-tip`;\n    }\n\n    changeTip(tip, oldTip) {\n        const me = this;\n\n        if (tip) {\n            const result = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                forElement : me.element,\n                id         : me.tipId,\n                getHtml    : me.getTipHtml.bind(me),\n                cls        : me.tooltipCls,\n                owner      : me.client\n            }, tip), {\n                owner    : me.client,\n                defaults : {\n                    type : 'tooltip'\n                }\n            });\n\n            result.ion({ innerHtmlUpdate : 'updateDateIndicator', thisObj : me });\n\n            return result;\n        }\n        else {\n            oldTip?.destroy();\n        }\n    }\n\n    //endregion\n\n    //region Drag events\n\n    createProxy(element) {\n        const proxy = element.cloneNode(true);\n        delete proxy.id;\n\n        proxy.classList.add(`b-sch-${this.client.mode}`);\n        return proxy;\n    }\n\n    onBeforeDragStart({ context, event }) {\n        const\n            me             = this,\n            { client }     = me,\n            dragData       = me.getMinimalDragData(context, event),\n            eventRecord    = dragData?.[`${client.scheduledEventName}Record`],\n            resourceRecord = dragData.resourceRecord;\n\n        if (client.readOnly || me.disabled || !eventRecord || eventRecord.isDraggable === false || eventRecord.readOnly || resourceRecord?.readOnly) {\n            return false;\n        }\n\n        // Cache the date corresponding to the drag start point so that on drag, we can always\n        // perform the same calculation to then find the time delta without having to calculate\n        // the new start and end times from the position that the element is.\n        context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);\n\n        const result = me.triggerBeforeEventDrag(\n            `before${client.capitalizedEventName}Drag`,\n            {\n                ...dragData,\n                event,\n                // to be deprecated\n                context : {\n                    ...context,\n                    ...dragData\n                }\n            }\n        ) !== false;\n\n        if (result) {\n            me.updateYConstraint(eventRecord, resourceRecord);\n\n            // Hook for features that need to react to drag starting, used by NestedEvents\n            client[`before${client.capitalizedEventName}DragStart`]?.(context, dragData);\n        }\n\n        return result;\n    }\n\n    onAfterDragStart({ context, event }) {}\n\n    /**\n     * Returns true if a drag operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isDragging() {\n        return this.drag?.isDragging;\n    }\n\n    // Checked by dependencies to determine if live redrawing is needed\n    get isActivelyDragging() {\n        return this.isDragging && !this.finalizing;\n    }\n\n    /**\n     * Triggered when dragging of an event starts. Initializes drag data associated with the event being dragged.\n     * @private\n     */\n    onDragStart({ context, event }) {\n        const\n            me     = this,\n            // When testing with Selenium, it simulates drag and drop with a single mousemove event, we might be over\n            // another client already\n            client = me.findClientFromTarget(event, context) ?? me.client;\n\n        me.currentOverClient = client;\n        me.drag.unifiedProxy = me.unifiedDrag;\n\n        me.onMouseOverNewTimeline(client, true);\n\n        const dragData = me.dragData = me.getDragData(context);\n\n        // Do not let DomSync reuse the element\n        me.suspendElementRedrawing(context.element);\n\n        if (me.showTooltip && me.tip) {\n            const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;\n\n            me.tip.showBy(tipTarget);\n        }\n\n        me.triggerDragStart(dragData);\n\n        // Hook for features that need to take action after drag starts\n        client[`after${client.capitalizedEventName}DragStart`]?.(context, dragData);\n\n        const\n            {\n                eventMenu,\n                taskMenu\n            }           = client.features,\n            menuFeature = eventMenu || taskMenu;\n\n        // If this is a touch action, hide the context menu which may have shown\n        menuFeature?.hideContextMenu?.(false);\n    }\n\n    updateDateIndicator() {\n        const\n            { startDate, endDate } = this.dragData,\n            { tip, clockTemplate } = this,\n            endDateElement         = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        clockTemplate.updateDateIndicator(tip.element, startDate);\n\n        endDateElement && clockTemplate.updateDateIndicator(endDateElement, endDate);\n    }\n\n    findClientFromTarget(event, context) {\n        let { target } = event;\n\n        // Can't detect target under a touch event\n        if (/^touch/.test(event.type)) {\n            const center = Rectangle.from(context.element, null, true).center;\n\n            target = DomHelper.elementFromPoint(center.x, center.y);\n        }\n\n        const client = Widget.fromElement(target, 'timelinebase');\n        // Do not allow drops on histogram widgets\n        return client?.isResourceHistogram ? null : client;\n    }\n\n    /**\n     * Triggered while dragging an event. Updates drag data, validation etc.\n     * @private\n     */\n    onDrag({ context, event }) {\n        const\n            me    = this,\n            dd    = me.dragData,\n            start = dd.startDate;\n\n        let client;\n\n        if (me.constrainDragToTimeline) {\n            client = me.client;\n        }\n        else {\n            client = me.findClientFromTarget(event, dd.context);\n        }\n\n        me.updateDragContext(context, event);\n\n        if (!client) {\n            return;\n        }\n\n        if (client !== me.currentOverClient) {\n            me.onMouseOverNewTimeline(client);\n        }\n\n        //this.checkShiftChange();\n\n        // Let product specific implementations trigger drag event (eventDrag, taskDrag)\n        if (dd.dirty || !me.throttleDragEvent) {\n            const valid = dd.valid;\n\n            me.triggerEventDrag(dd, start);\n\n            if (valid !== dd.valid) {\n                dd.context.valid = dd.externalDragValidity = dd.valid;\n            }\n        }\n\n        if (me.showTooltip && me.tip) {\n            // If we've an error message to show, force the tip to be visible\n            // even if the target is not in view.\n            me.tip.lastAlignSpec.allowTargetOut = !dd.valid;\n            me.tip.realign();\n        }\n    }\n\n    onMouseOverNewTimeline(newTimeline, initial) {\n        const\n            me                          = this,\n            { drag : { lockX, lockY } } = me,\n            scrollables                 = [];\n\n        me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);\n\n        newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);\n\n        if (!initial) {\n            me.currentOverClient.scrollManager.stopMonitoring();\n        }\n\n        if (!lockX) {\n            scrollables.push({\n                element   : newTimeline.timeAxisSubGrid.scrollable.element,\n                direction : 'horizontal'\n            });\n        }\n\n        if (!lockY) {\n            scrollables.push({\n                element   : newTimeline.scrollable.element,\n                direction : 'vertical'\n            });\n        }\n\n        newTimeline.scrollManager.startMonitoring({\n            scrollables,\n            callback : me.drag.onScrollManagerScrollCallback\n        });\n\n        me.currentOverClient = newTimeline;\n    }\n\n    triggerBeforeEventDropFinalize(eventType, eventData, client) {\n        client.trigger(eventType, eventData);\n    }\n\n    /**\n     * Triggered when dropping an event. Finalizes the operation.\n     * @private\n     */\n    onDrop({ context, event }) {\n        const\n            me                              = this,\n            { currentOverClient, dragData } = me;\n\n        let modified = false;\n\n        me.tip?.hide();\n\n        context.valid = context.valid && me.isValidDrop(dragData);\n\n        // If dropping outside scheduler, we opt in on DragHelper removing the proxy element\n        me.drag.removeProxyAfterDrop = Boolean(dragData.externalDropTarget);\n\n        if (context.valid && dragData.startDate && dragData.endDate) {\n            let beforeDropTriggered = false;\n\n            dragData.finalize = async(valid) => {\n                if (beforeDropTriggered || dragData.async) {\n                    await me.finalize(valid);\n                }\n                else {\n                    // If user finalized operation synchronously in the beforeDropFinalize listener, just use\n                    // the valid param and carry on\n                    // but ignore it, if the context is already marked as invalid\n                    context.valid = context.valid && valid;\n                }\n            };\n\n            me.triggerBeforeEventDropFinalize(`before${currentOverClient.capitalizedEventName}DropFinalize`, {\n                context  : dragData,\n                domEvent : event\n            }, currentOverClient);\n\n            beforeDropTriggered = true;\n\n            // Allow implementer to take control of the flow, by returning false from this listener,\n            // to show a confirmation popup etc. This event is documented in EventDrag and TaskDrag\n            context.async = dragData.async;\n\n            // Internal validation, making sure all dragged records fit inside the view\n            if (!context.async && !dragData.externalDropTarget) {\n                modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;\n            }\n        }\n\n        if (!context.async) {\n            me.finalize(dragData.valid && context.valid && modified);\n        }\n    }\n\n    onDragAbort({ context }) {\n        const me = this;\n\n        me.client.currentOrientation.onDragAbort({ context, dragData : me.dragData });\n\n        // otherwise the event disappears on next refresh (#62)\n        me.resetDraggedElements();\n\n        me.tip?.hide();\n\n        // Trigger eventDragAbort / taskDragAbort depending on product\n        me.triggerDragAbort(me.dragData);\n    }\n\n    // Fired after any abort animation has completed (the point where we want to trigger redraw of progress lines etc)\n    onDragAbortFinalized({ context }) {\n        const me = this;\n\n        me.triggerDragAbortFinalized(me.dragData);\n\n        // Hook for features that need to react on drag abort, used by NestedEvents\n        me.client[`after${me.client.capitalizedEventName}DragAbortFinalized`]?.(context, me.dragData);\n    }\n\n    // For the drag across multiple schedulers, tell all involved scroll managers to stop monitoring\n    onDragReset({ source : dragHelper }) {\n        const\n            me              = this,\n            currentTimeline = me.currentOverClient;\n\n        currentTimeline?.scrollManager.stopMonitoring();\n\n        if (dragHelper.context?.started) {\n            me.resetDraggedElements();\n\n            currentTimeline.trigger(`${currentTimeline.scheduledEventName}DragReset`);\n        }\n\n        currentTimeline?.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);\n        me.dragData = null;\n    }\n\n    resetDraggedElements() {\n        const\n            { dragData }                     = this,\n            { eventBarEls, draggedEntities } = dragData;\n\n        this.resumeRecordElementRedrawing(dragData.record);\n\n        draggedEntities.forEach((record, i) => {\n            this.resumeRecordElementRedrawing(record);\n\n            // <remove-on-release>\n            // TODO: why?\n            // </remove-on-release>\n            eventBarEls[i].classList.remove(this.drag.draggingCls);\n            eventBarEls[i].retainElement = false;\n        });\n\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        dragData.context.element.retainElement = false;\n    }\n\n    /**\n     * Triggered internally on invalid drop.\n     * @private\n     */\n    onInternalInvalidDrop(abort) {\n        const\n            me          = this,\n            { context } = me.drag;\n\n        me.tip?.hide();\n\n        me.triggerAfterDrop(me.dragData, false);\n\n        context.valid = false;\n\n        if (abort) {\n            me.drag.abort();\n        }\n    }\n\n    //endregion\n\n    //region Finalization & validation\n\n    /**\n     * Called on drop to update the record of the event being dropped.\n     * @private\n     * @param {Boolean} updateRecords Specify true to update the record, false to treat as invalid\n     */\n    async finalize(updateRecords) {\n        const\n            me           = this,\n            { dragData } = me;\n\n        // Drag could've been aborted by window blur event. If it is aborted - we have nothing to finalize.\n        if (!dragData || me.finalizing) {\n            return;\n        }\n\n        const { context, draggedEntities, externalDropTarget } = dragData;\n\n        let result;\n\n        me.finalizing = true;\n\n        draggedEntities.forEach((record, i) => {\n            me.resumeRecordElementRedrawing(record);\n\n            // <remove-on-release>\n            // TODO: Why is this needed? EventResize.t.js fails without it\n            // </remove-on-release>\n            dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);\n            dragData.eventBarEls[i].retainElement = false;\n        });\n\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        context.element.retainElement = false;\n\n        if ((externalDropTarget && dragData.valid) || updateRecords) {\n            // updateRecords may or may not be async.\n            // We see if it returns a Promise.\n            result = me.updateRecords(dragData);\n\n            // If updateRecords is async, the calling DragHelper must know this and\n            // go into a awaitingFinalization state.\n            if (!externalDropTarget && Objects.isPromise(result)) {\n                context.async = true;\n                await result;\n            }\n\n            // If the finalize handler decided to change the dragData's validity...\n            if (!dragData.valid) {\n                me.onInternalInvalidDrop(true);\n            }\n            else {\n                if (context.async) {\n                    context.finalize();\n                }\n                if (externalDropTarget) {\n                    // Force a refresh early so that removed events will not temporary be visible while engine is\n                    // recalculating (the row below clears the 'b-hidden' CSS class of the original drag element)\n                    me.client.refreshRows(false);\n                }\n                me.triggerAfterDrop(dragData, true);\n            }\n        }\n        else {\n            me.onInternalInvalidDrop(context.async || dragData.async);\n        }\n\n        me.finalizing = false;\n\n        return result;\n    }\n\n    //endregion\n\n    //region Drag data\n\n    /**\n     * Updates drag data's dates and validity (calls #validatorFn if specified)\n     * @private\n     */\n    updateDragContext(info, event) {\n        const\n            me                  = this,\n            { drag }            = me,\n            dd                  = me.dragData,\n            client              = me.currentOverClient,\n            { isHorizontal }    = client,\n            [record]            = dd.draggedEntities,\n            eventRecord         = record.isAssignment ? record.event : record,\n            lastDragStartDate   = dd.startDate,\n            constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);\n\n        dd.browserEvent = event;\n\n        // getProductDragContext may switch valid flag, need to keep it here\n        Object.assign(dd, me.getProductDragContext(dd));\n\n        if (constrainToTimeSlot) {\n            dd.timeDiff = 0;\n        }\n        else {\n            let timeDiff;\n\n            // Time diff is calculated differently for continuous and non-continuous time axis\n            if (client.timeAxis.isContinuous) {\n                const\n                    timeAxisPosition = client.isHorizontal ? info.pageX ?? info.startPageX : info.pageY ?? info.startPageY,\n                    // Use the localized coordinates to ask the TimeAxisViewModel what date the mouse is at.\n                    // Pass allowOutOfRange as true in case we have dragged out of either side of the timeline viewport.\n                    pointerDate      = client.getDateFromCoordinate(timeAxisPosition, null, false, true);\n\n                timeDiff = dd.timeDiff = pointerDate - info.pointerStartDate;\n            }\n            else {\n                const range = me.resolveStartEndDates(info.element);\n\n                // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n                dd.valid = Boolean(range.startDate && range.endDate);\n\n                if (dd.valid) {\n                    timeDiff = range.startDate - dd.origStart;\n                }\n            }\n\n            // If we got a time diff, we calculate new dates the same way no matter if it's continuous or not.\n            // This prevents no-change drops in non-continuous time axis from being processed by updateAssignments()\n            if (timeDiff !== null) {\n                // calculate and round new startDate based on actual timeDiff\n                dd.startDate = me.adjustStartDate(dd.origStart, timeDiff);\n\n                dd.endDate = DateHelper.add(dd.startDate, eventRecord.fullDuration);\n\n                if (dd.valid) {\n                    dd.timeDiff = dd.startDate - dd.origStart;\n                }\n            }\n        }\n\n        const positionDirty = dd.dirty = dd.dirty || lastDragStartDate - dd.startDate !== 0;\n\n        if (dd.valid) {\n            // If it's fully outside, we don't allow them to drop it - the event would disappear from their control.\n            if (me.constrainDragToTimeline && (dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate)) {\n                dd.valid           = false;\n                dd.context.message = me.L('L{EventDrag.noDropOutsideTimeline}');\n            }\n            else if (positionDirty || dd.externalDropTarget) {\n                // Used to rely on faulty code above that would not be valid initially. With that changed we ignore\n                // checking validity here on drag start, which is detected by not having a pageX\n                const result = dd.externalDragValidity = !event || (info.pageX && me.checkDragValidity(dd, event));\n\n                if (!result || typeof result === 'boolean') {\n                    dd.valid           = result !== false;\n                    dd.context.message = '';\n                }\n                else {\n                    dd.valid           = result.valid !== false;\n                    dd.context.message = result.message;\n                }\n            }\n            else {\n                // Apply cached value from external drag validation\n                dd.valid = dd.externalDragValidity !== false && dd.externalDragValidity?.valid !== false;\n            }\n        }\n        else {\n            dd.valid = false;\n        }\n\n        dd.context.valid = dd.valid;\n    }\n\n    suspendRecordElementRedrawing(record, suspend = true) {\n        this.suspendElementRedrawing(this.getRecordElement(record), suspend);\n        // <remove-on-release>\n        // TODO: temporary get rid of retainElement joggling to check tests\n        // </remove-on-release>\n        record.instanceMeta(this.client).retainElement = suspend;\n    }\n\n    resumeRecordElementRedrawing(record) {\n        this.suspendRecordElementRedrawing(record, false);\n    }\n\n    suspendElementRedrawing(element, suspend = true) {\n        // <remove-on-release>\n        // TODO: temporary get rid of retainElement joggling to check tests\n        // </remove-on-release>\n        if (element) {\n            element.retainElement = suspend;\n        }\n    }\n\n    resumeElementRedrawing(element) {\n        this.suspendElementRedrawing(element, false);\n    }\n\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const\n            me                = this,\n            { client, drag }  = me,\n            productDragData   = me.setupProductDragData(info),\n            {\n                record,\n                eventBarEls,\n                draggedEntities\n            }                 = productDragData,\n            { startEvent }    = drag,\n            timespan          = record.isAssignment ? record.event : record,\n            origStart         = timespan.startDate,\n            origEnd           = timespan.endDate,\n            timeAxis          = client.timeAxis,\n            startsOutsideView = origStart < timeAxis.startDate,\n            endsOutsideView   = origEnd > timeAxis.endDate,\n            multiSelect       = client.isSchedulerBase ? client.multiEventSelect : client.selectionMode.multiSelect,\n            coordinate        = me.getCoordinate(timespan, info.element, [info.elementStartX, info.elementStartY]),\n            clientCoordinate  = me.getCoordinate(timespan, info.element, [info.startClientX, info.startClientY]);\n\n        me.suspendRecordElementRedrawing(record);\n\n        // prevent elements from being released when out of view\n        draggedEntities.forEach(record => me.suspendRecordElementRedrawing(record));\n\n        // Make sure the dragged event is selected (no-op for already selected)\n        // Preserve other selected events if ctrl/meta is pressed\n        if (record.isAssignment) {\n            client.selectAssignment(record, startEvent.ctrlKey && multiSelect);\n        }\n        else {\n            client.selectEvent(record, startEvent.ctrlKey && multiSelect);\n        }\n\n        const dragData = {\n            context : info,\n            ...productDragData,\n\n            sourceDate       : startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),\n            screenSourceDate : client.getDateFromCoordinate(clientCoordinate, null, false),\n\n            startDate : origStart,\n            endDate   : origEnd,\n            timeDiff  : 0,\n\n            origStart,\n            origEnd,\n            startsOutsideView,\n            endsOutsideView,\n\n            duration     : origEnd - origStart,\n            browserEvent : startEvent // So we can know if SHIFT/CTRL was pressed\n        };\n\n        eventBarEls.forEach(el => el.classList.remove('b-sch-event-hover', 'b-active'));\n\n        if (eventBarEls.length > 1) {\n            // RelatedElements are secondary elements moved by the same delta as the grabbed element\n            info.relatedElements = eventBarEls.slice(1);\n        }\n\n        return dragData;\n    }\n\n    //endregion\n\n    //region Constraints\n\n    // private\n    setupConstraints(constrainRegion, elRegion, tickSize, constrained) {\n        const\n            me        = this,\n            xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,\n            yTickSize = 0;\n\n        // If `constrained` is false then we have no date constraints and should constrain mouse position to scheduling area\n        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.\n        if (constrained) {\n            me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);\n        }\n        // And if not constrained, release any constraints from the previous drag.\n        else {\n            // minX being true means allow the start to be before the time axis.\n            // maxX being true means allow the end to be after the time axis.\n            me.setXConstraint(true, true, xTickSize);\n        }\n        me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);\n    }\n\n    updateYConstraint(eventRecord, resourceRecord) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = me.drag,\n            tickSize    = client.timeAxisViewModel.snapPixelAmount;\n\n        // If we're dragging when the vertical size is recalculated by the host grid,\n        // we must update our Y constraint unless we are locked in the Y axis.\n        if (context && !me.drag.lockY) {\n            let constrainRegion;\n\n            // This calculates a relative region which the DragHelper uses within its outerElement\n            if (me.constrainDragToTimeline) {\n                constrainRegion = client.getScheduleRegion(resourceRecord, eventRecord);\n            }\n            // Not constraining to timeline.\n            // Unusual configuration, but this must mean no Y constraining.\n            else {\n                me.setYConstraint(null, null, tickSize);\n                return;\n            }\n\n            me.setYConstraint(\n                constrainRegion.top,\n                constrainRegion.bottom - context.element.offsetHeight,\n                tickSize\n            );\n        }\n        else {\n            me.setYConstraint(null, null, tickSize);\n        }\n    }\n\n    setXConstraint(iLeft, iRight, iTickSize) {\n        const { drag } = this;\n\n        drag.minX = iLeft;\n        drag.maxX = iRight;\n    }\n\n    setYConstraint(iUp, iDown, iTickSize) {\n        const { drag } = this;\n\n        drag.minY = iUp;\n        drag.maxY = iDown;\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    adjustStartDate(startDate, timeDiff) {\n        const rounded = this.client.timeAxis.roundDate(\n            new Date(startDate - 0 + timeDiff),\n            this.client.snapRelativeToEventStartDate ? startDate : false\n        );\n\n        return this.constrainStartDate(rounded);\n    }\n\n    resolveStartEndDates(draggedElement) {\n        const\n            timeline         = this.currentOverClient,\n            { timeAxis }     = timeline,\n            proxyRect        = Rectangle.from(draggedElement.querySelector(timeline.eventInnerSelector), timeline.timeAxisSubGridElement),\n            dd               = this.dragData,\n            [record]         = dd.draggedEntities,\n            eventRecord      = record.isAssignment ? record.event : record,\n            { fullDuration } = eventRecord,\n            fillSnap         = timeline.fillTicks && timeline.snapRelativeToEventStartDate;\n\n        // Non-continuous time axis will return null instead of date for a rectangle outside of the view unless\n        // told to estimate date.\n        // When using fillTicks, we need exact dates for calculations below\n        let {\n            start : startDate, end : endDate\n        } = timeline.getStartEndDatesFromRectangle(proxyRect, fillSnap ? null : 'round', fullDuration, true);\n\n        // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n        if (startDate && endDate) {\n            // When filling ticks, proxy start does not represent actual start date.\n            // Need to compensate to get expected result\n            if (fillSnap) {\n                const\n                    // Events offset into the tick, in MS\n                    offsetMS = eventRecord.startDate - DateHelper.startOf(eventRecord.startDate, timeAxis.unit),\n                    // Proxy length in MS\n                    proxyMS  = endDate - startDate,\n                    // Part of proxy that is \"filled\" and needs to be removed\n                    offsetPx = (offsetMS / proxyMS) * proxyRect.width;\n\n                // Deflate top for vertical mode, left for horizontal mode\n                proxyRect.deflate(offsetPx, 0, 0, offsetPx);\n\n                const proxyStart = proxyRect.getStart(timeline.rtl, !timeline.isVertical);\n\n                // Get date from offset proxy start\n                startDate = timeline.getDateFromCoordinate(proxyStart, null, true);\n                // Snap relative to event start date\n                startDate = timeAxis.roundDate(startDate, eventRecord.startDate);\n            }\n\n            startDate = this.adjustStartDate(startDate, 0);\n\n            if (!dd.startsOutsideView) {\n                // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of\n                // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell\n                if (!timeAxis.dateInAxis(startDate, false)) {\n                    const tick = timeAxis.getTickFromDate(startDate);\n\n                    if (tick >= 0) {\n                        startDate = timeAxis.getDateFromTick(tick);\n                    }\n                }\n\n                endDate = startDate && DateHelper.add(startDate, fullDuration);\n            }\n            else if (!dd.endsOutsideView) {\n                startDate = endDate && DateHelper.add(endDate, -fullDuration);\n            }\n        }\n\n        return {\n            startDate,\n            endDate\n        };\n    }\n\n    //endregion\n\n    //region Dragtip\n\n    /**\n     * Gets html to display in tooltip while dragging event. Uses clockTemplate to display start & end dates.\n     */\n    getTipHtml() {\n        const\n            me                                      = this,\n            { dragData, client, tooltipTemplate }   = me,\n            { startDate, endDate, draggedEntities } = dragData,\n            startText                               = client.getFormattedDate(startDate),\n            endText                                 = client.getFormattedEndDate(endDate, startDate),\n            { valid, message, element, dragProxy }  = dragData.context,\n            tipTarget                               = dragProxy ? dragProxy.firstChild : element,\n            dragged                                 = draggedEntities[0],\n            // Scheduler always drags assignments\n            timeSpanRecord                          = dragged.isTask ? dragged : dragged.event;\n\n        // Keep align target up to date in case of derendering the target when\n        // dragged outside render window, and re-entry into the render window.\n        me.tip.lastAlignSpec.target = tipTarget;\n\n        return tooltipTemplate({\n            valid,\n            startDate,\n            endDate,\n            startText,\n            endText,\n            dragData,\n            message                                : message || '',\n            [client.scheduledEventName + 'Record'] : timeSpanRecord,\n            startClockHtml                         : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : timeSpanRecord.isMilestone\n                ? ''\n                : me.clockTemplate.template({\n                    date : endDate,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n        });\n    }\n\n    //endregion\n\n    //region Configurable\n\n    // Constrain to time slot means lockX if we're horizontal, otherwise lockY\n    updateConstrainDragToTimeSlot(value) {\n        const axis = this.client.isHorizontal ? 'lockX' : 'lockY';\n\n        if (this.drag) {\n            this.drag[axis] = value;\n        }\n    }\n\n    // Constrain to resource means lockY if we're horizontal, otherwise lockX\n    updateConstrainDragToResource(constrainDragToResource) {\n        const me = this;\n\n        if (me.drag) {\n            const\n                { constrainDragToTimeSlot } = me,\n                { isHorizontal }            = me.client;\n\n            if (constrainDragToResource) {\n                me.constrainDragToTimeline = true;\n            }\n            me.drag.lockY = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot;\n            me.drag.lockX = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n        }\n    }\n\n    updateConstrainDragToTimeline(constrainDragToTimeline) {\n        if (!this.isConfiguring) {\n            Object.assign(this.drag, {\n                cloneTarget   : !constrainDragToTimeline,\n                dragWithin    : constrainDragToTimeline ? null : document.body,\n                scrollManager : constrainDragToTimeline ? this.client.scrollManager : null\n            });\n        }\n    }\n\n    constrainStartDate(startDate) {\n        const\n            { dragData }        = this,\n            { dateConstraints } = dragData,\n            scheduleableRecord  = dragData.eventRecord || dragData.taskRecord || dragData.draggedEntities[0];\n\n        if (dateConstraints?.start) {\n            startDate = DateHelper.max(dateConstraints.start, startDate);\n        }\n\n        if (dateConstraints?.end) {\n            startDate = DateHelper.min(new Date(dateConstraints.end - scheduleableRecord.durationMS), startDate);\n        }\n\n        return startDate;\n    }\n\n    //endregion\n\n    //region Product specific, implemented in subclasses\n    getElementFromContext(context) {\n        return context.grabbed || context.dragProxy || context.element;\n    }\n\n    // Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n    getRelatedRecords(record) {\n        return [];\n    }\n\n    getMinimalDragData(info, event) {\n        // Can be overridden in subclass\n        return {};\n    }\n\n    // Check if element can be dropped at desired location\n    isValidDrop(dragData) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Similar to the fn above but also calls validatorFn\n    checkDragValidity(dragData) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Update records being dragged\n    updateRecords(context) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Determine if an element can be dragged\n    isElementDraggable(el, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Get coordinate for correct axis\n    getCoordinate(record, element, coord) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Product specific drag data\n    setupProductDragData(info) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Product specific data in drag context\n    getProductDragContext(dd) {\n        throw new Error('Implement in subclass');\n    }\n\n    getRecordElement(record) {\n        throw new Error('Implement in subclass');\n    }\n\n    //endregion\n}\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n\n/**\n * @module Scheduler/feature/EventResize\n */\n\nconst tipAlign = {\n    top    : 'b-t',\n    right  : 'b100-t100',\n    bottom : 't-b',\n    left   : 'b0-t0'\n};\n\n/**\n * Feature that allows resizing an event by dragging its end.\n *\n * By default it displays a tooltip with the new start and end dates, formatted using\n * {@link Scheduler/view/mixin/TimelineViewPresets#config-displayDateFormat}.\n *\n * ## Customizing the resize tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * eventResize : {\n *     // A minimal end date tooltip\n *     tooltipTemplate : ({ record, endDate }) => {\n *         return DateHelper.format(endDate, 'MMM D');\n *     }\n * }\n * ```\n *\n * This feature is **enabled** by default\n *\n * This feature is extended with a few overrides by the Gantt's `TaskResize` feature.\n *\n * This feature updates the event's `startDate` or `endDate` live in order to leverage the\n * rendering pathway to always yield a correct appearance. The changes are done in\n * {@link Core.data.Model#function-beginBatch batched} mode so that changes do not become\n * eligible for data synchronization or propagation until the operation is completed.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventResize.js\n * @classtype eventResize\n * @feature\n */\nexport default class EventResize extends InstancePlugin.mixin(Draggable, Droppable) {\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler before resizing starts. Return `false` to prevent the action.\n     * @event beforeEventResize\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler when event resizing starts\n     * @event eventResizeStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler on each resize move event\n     * @event eventPartialResize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Date} startDate\n     * @param {Date} endDate\n     * @param {HTMLElement} element\n     */\n\n    /**\n     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     *\n     * ```javascript\n     *  scheduler.on('beforeeventresizefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * @event beforeEventResizeFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.eventRecord Event record being resized\n     * @param {Date} context.startDate New startDate (changed if resizing start side)\n     * @param {Date} context.endDate New endDate (changed if resizing end side)\n     * @param {Date} context.originalStartDate Start date before resize\n     * @param {Date} context.originalEndDate End date before resize\n     * @param {Boolean} context.async Set true to handle resize asynchronously (e.g. to wait for user confirmation)\n     * @param {Function} context.finalize Call this method to finalize resize. This method accepts one argument:\n     *                   pass `true` to update records, or `false`, to ignore changes\n     * @param {Event} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler after the resizing gesture has finished.\n     * @event eventResizeEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Boolean} changed Shows if the record has been changed by the resize action\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     */\n\n    //endregion\n\n    //region Config\n\n    static get $name() {\n        return 'EventResize';\n    }\n\n    static get configurable() {\n        return {\n            draggingItemCls : 'b-sch-event-wrap-resizing',\n\n            resizingItemInnerCls : 'b-sch-event-resizing',\n\n            /**\n             * Use left handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            leftHandle : true,\n\n            /**\n             * Use right handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            rightHandle : true,\n\n            /**\n             * Use top handle when resizing. Only applies when owning client's direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            topHandle : true,\n\n            /**\n             * Use bottom handle when resizing. Only applies when owning client's `direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            bottomHandle : true,\n\n            /**\n             * Resizing handle size to use instead of that determined by CSS\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            handleSize : null,\n\n            /**\n             * Automatically shrink virtual handles when available space < handleSize. The virtual handles will\n             * decrease towards width/height 1, reserving space between opposite handles to for example leave room for\n             * dragging. To configure reserved space, see {@link #config-reservedSpace}.\n             * @config {Boolean}\n             * @default false\n             */\n            dynamicHandleSize : true,\n\n            /**\n             * Set to true to allow resizing to a zero-duration span\n             * @config {Boolean}\n             * @default false\n             */\n            allowResizeToZero : null,\n\n            /**\n             * Room in px to leave unoccupied by handles when shrinking them dynamically (see\n             * {@link #config-dynamicHandleSize}).\n             * @config {Number}\n             * @default\n             */\n            reservedSpace : 5,\n\n            /**\n             * Resizing handle size to use instead of that determined by CSS on touch devices\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            touchHandleSize : null,\n\n            /**\n             * The amount of pixels to move pointer/mouse before it counts as a drag operation.\n             * @config {Number}\n             * @default\n             */\n            dragThreshold : 0,\n\n            dragTouchStartDelay : 0,\n\n            draggingClsSelector : '.b-timeline-base',\n\n            /**\n             * `false` to not show a tooltip while resizing\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n\n            /**\n             * true to see exact event length during resizing\n             * @config {Boolean}\n             * @default\n             */\n            showExactResizePosition : false,\n\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on\n             * the item being resized. Return true if the new duration is valid, false to signal that it is not.\n             * @param {Object} context The resize context, contains the record & dates.\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized.\n             * @param {Date} context.startDate The new start date.\n             * @param {Date} context.endDate The new start date.\n             * @param {Date} context.originalStartDate Start date before resize\n             * @param {Date} context.originalEndDate End date before resize\n             * @param {Event} event The browser Event object\n             * @returns {Boolean}\n             * @config {Function}\n             */\n            validatorFn : () => true,\n\n            /**\n             * `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n\n            /**\n             * Setting this property may change the configuration of the {@link #config-tip}, or\n             * cause it to be destroyed if `null` is passed.\n             *\n             * Reading this property returns the Tooltip instance.\n             * @member {Core.widget.Tooltip|TooltipConfig} tip\n             */\n            /**\n             * If a tooltip is required to illustrate the resize, specify this as `true`, or a config\n             * object for the {@link Core.widget.Tooltip}.\n             * @config {Core.widget.Tooltip|TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    autoShow                 : false,\n                    axisLock                 : true,\n                    trackMouse               : false,\n                    updateContentOnMouseMove : true,\n                    hideDelay                : 0\n                }\n            },\n\n            /**\n             * A template function returning the content to show during a resize operation.\n             * @param {Object} context A context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized\n             * @config {Function} tooltipTemplate\n             */\n            tooltipTemplate : context => `\n                <div class=\"b-sch-tip-${context.valid ? 'valid' : 'invalid'}\">\n                    ${context.startClockHtml}\n                    ${context.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${context.message}</div>\n                </div>\n            `,\n\n            ignoreSelector : '.b-sch-terminal',\n            dragActiveCls  : 'b-resizing-event'\n        };\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['render', 'onEventDataGenerated', 'isEventElementDraggable']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        super.doDestroy();\n\n        this.dragging?.destroy();\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Only active when in these items\n        me.dragSelector = me.dragItemSelector = client.eventSelector;\n\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n\n    // Prevent event dragging when it happens over a resize handle\n    isEventElementDraggable(eventElement, eventRecord, el, event) {\n        const\n            me = this,\n            eventResizable = eventRecord?.resizable;\n\n        // ALLOW event drag:\n        // - if resizing is disabled or event is not resizable\n        // - if it's a milestone Milestones cannot be resized\n        if (me.disabled || !eventResizable || eventRecord.isMilestone) {\n            return true;\n        }\n\n        // not over the event handles\n        return ((eventResizable !== true && eventResizable !== 'start') || !me.isOverStartHandle(event, eventElement)) &&\n            ((eventResizable !== true && eventResizable !== 'end') || !me.isOverEndHandle(event, eventElement));\n    }\n\n    // Called for each event during render, allows manipulation of render data.\n    onEventDataGenerated({ eventRecord, wrapperCls, cls }) {\n        if (eventRecord === this.dragging?.context?.eventRecord) {\n            wrapperCls['b-active'] =\n                wrapperCls[this.draggingItemCls] =\n                wrapperCls['b-over-resize-handle'] =\n                cls['b-resize-handle'] =\n                cls[this.resizingItemInnerCls] = 1;\n        }\n    }\n\n    // Sneak a first peek at the drag event to put necessary date values into the context\n    onDragPointerMove(event) {\n        const\n            {\n                client,\n                dragging\n            }          = this,\n            {\n                visibleDateRange,\n                isHorizontal\n            }          = client,\n            rtl        = isHorizontal && client.rtl,\n            dimension  = isHorizontal ? 'X' : 'Y',\n            pageScroll = globalThis[`page${dimension}Offset`],\n            coord      = event[`page${dimension}`] + (dragging.context?.offset || 0),\n            clientRect = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord = clientRect.getStart(rtl, isHorizontal),\n            endCoord   = clientRect.getEnd(rtl, isHorizontal);\n\n        let date = client.getDateFromCoord({ coord, local : false });\n\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord - pageScroll > startCoord) {\n                date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = visibleDateRange.endDate;\n            }\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord - pageScroll < startCoord) {\n            date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord - pageScroll > endCoord) {\n            date = visibleDateRange.endDate;\n        }\n\n        dragging.clientStartCoord = startCoord;\n        dragging.clientEndCoord = endCoord;\n        dragging.date = date;\n\n        super.onDragPointerMove(event);\n    }\n\n    /**\n     * Returns true if a resize operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isResizing() {\n        return Boolean(this.dragging);\n    }\n\n    beforeDrag(drag) {\n        const\n            { client }     = this,\n            eventRecord    = client.resolveTimeSpanRecord(drag.itemElement),\n            resourceRecord = !client.isGanttBase && client.resolveResourceRecord(client.isVertical ? drag.startEvent : drag.itemElement);\n\n        // Events not part of project are transient records in a Gantt display store and not meant to be modified\n        if (this.disabled || client.readOnly || resourceRecord?.readOnly ||\n            (eventRecord && (eventRecord.readOnly || !(eventRecord.project || eventRecord.isOccurrence))) ||\n            super.beforeDrag(drag) === false) {\n            return false;\n        }\n\n        drag.mousedownDate = drag.date = client.getDateFromCoordinate(drag.event[`page${client.isHorizontal ? 'X' : 'Y'}`], null, false);\n\n        // trigger beforeEventResize or beforeTaskResize depending on product\n        return this.triggerBeforeResize(drag);\n    }\n\n    dragStart(drag) {\n        const\n            me             = this,\n            {\n                client,\n                tip\n            }              = me,\n            {\n                startEvent,\n                itemElement\n            }              = drag,\n            name           = client.scheduledEventName,\n            eventRecord    = client.resolveEventRecord(itemElement),\n            {\n                isBatchUpdating,\n                wrapStartDate,\n                wrapEndDate\n            } = eventRecord,\n            useEventBuffer = client.features.eventBuffer?.enabled,\n            eventStartDate = isBatchUpdating ? eventRecord.get('startDate') : eventRecord.startDate,\n            eventEndDate   = isBatchUpdating ? eventRecord.get('endDate') : eventRecord.endDate,\n            horizontal     = me.dragLock === 'x',\n            rtl            = horizontal && client.rtl,\n            draggingEnd    = me.isOverEndHandle(startEvent, itemElement),\n            toSet          = draggingEnd ? 'endDate' : 'startDate',\n            wrapToSet      = !useEventBuffer ? null : draggingEnd ? 'wrapEndDate' : 'wrapStartDate',\n            otherEnd       = draggingEnd ? 'startDate' : 'endDate',\n            setMethod      = draggingEnd ? 'setEndDate' : 'setStartDate',\n            setOtherMethod = draggingEnd ? 'setStartDate' : 'setEndDate',\n            elRect         = Rectangle.from(itemElement),\n            startCoord     = horizontal ? startEvent.clientX : startEvent.clientY,\n            endCoord       = draggingEnd ? elRect.getEnd(rtl, horizontal) : elRect.getStart(rtl, horizontal),\n            context        = drag.context = {\n                eventRecord,\n                element        : itemElement,\n                timespanRecord : eventRecord,\n                taskRecord     : eventRecord,\n                owner          : me,\n                valid          : true,\n                oldValue       : draggingEnd ? eventEndDate : eventStartDate,\n                startDate      : eventStartDate,\n                endDate        : eventEndDate,\n                offset         : useEventBuffer ? 0 : endCoord - startCoord,\n                edge           : horizontal ? (draggingEnd ? 'right' : 'left') : (draggingEnd ? 'bottom' : 'top'),\n                finalize       : me.finalize,\n                event          : drag.event,\n\n                // these two are public\n                originalStartDate : eventStartDate,\n                originalEndDate   : eventEndDate,\n                wrapStartDate,\n                wrapEndDate,\n                draggingEnd,\n                toSet,\n                wrapToSet,\n                otherEnd,\n                setMethod,\n                setOtherMethod\n            };\n\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = true;\n\n        client.element.classList.add(...me.dragActiveCls.split(' '));\n\n        // During this batch we want the client's UI to update itself using the proposed changes\n        // Only if startDrag has not already done it\n        if (!client.listenToBatchedUpdates) {\n            client.beginListeningForBatchedUpdates();\n        }\n\n        // No changes must get through to data.\n        // Only if startDrag has not already started the batch\n        if (!isBatchUpdating) {\n            me.beginEventRecordBatch(eventRecord);\n        }\n\n        // Let products do their specific stuff\n        me.setupProductResizeContext(context, startEvent);\n\n        // Trigger eventResizeStart or taskResizeStart depending on product\n        // Subclasses (like EventDragCreate) won't actually fire this event.\n        me.triggerEventResizeStart(`${name}ResizeStart`, {\n            [`${name}Record`] : eventRecord,\n            event             : startEvent,\n            ...me.getResizeStartParams(context)\n        }, context);\n\n        // Scheduler renders assignments, Gantt renders Tasks\n        context.resizedRecord = client.resolveAssignmentRecord?.(context.element) || eventRecord;\n\n        if (tip) {\n            // Tip needs to be shown first for getTooltipTarget to be able to measure anchor size\n            tip.show();\n            tip.align = tipAlign[context.edge];\n            tip.showBy(me.getTooltipTarget(drag));\n        }\n    }\n\n    // Subclasses may override this\n    triggerBeforeResize(drag) {\n        const\n            { client }  = this,\n            eventRecord = client.resolveTimeSpanRecord(drag.itemElement);\n\n        return client.trigger(\n            `before${client.capitalizedEventName}Resize`,\n            {\n                [`${client.scheduledEventName}Record`] : eventRecord,\n                event                                  : drag.event,\n                ...this.getBeforeResizeParams({ event : drag.startEvent, element : drag.itemElement })\n            }\n        );\n    }\n\n    // Subclasses may override this\n    triggerEventResizeStart(eventType, event, context) {\n        this.client.trigger(eventType, event);\n\n        // Hook for features that needs to react on resize start\n        this.client[`after${StringHelper.capitalize(eventType)}`]?.(context, event);\n    }\n\n    triggerEventResizeEnd(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n\n    triggerEventPartialResize(eventType, event) {\n        // Trigger eventPartialResize or taskPartialResize depending on product\n        this.client.trigger(eventType, event);\n    }\n\n    triggerBeforeEventResizeFinalize(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n\n    dragEnter(drag) {\n        // We only respond to our own DragContexts\n        return drag.context?.owner === this;\n    }\n\n    resizeEventPartiallyInternal(eventRecord, context) {\n        const\n            { client } = this,\n            // <debug>\n            { detectExcessiveRendering } = client,\n            // </debug>\n            { toSet } = context;\n\n        // <debug>\n        client.detectExcessiveRendering = false;\n        // </debug>\n\n        if (client.features.eventBuffer?.enabled) {\n            if (toSet === 'startDate') {\n                const diff = context.startDate.getTime() - context.originalStartDate.getTime();\n                eventRecord.wrapStartDate = new Date(context.wrapStartDate.getTime() + diff);\n            }\n\n            else if (toSet === 'endDate') {\n                const diff = context.endDate.getTime() - context.originalEndDate.getTime();\n                eventRecord.wrapEndDate = new Date(context.wrapEndDate.getTime() + diff);\n            }\n        }\n\n        eventRecord.set(toSet, context[toSet]);\n\n        // <debug>\n        client.detectExcessiveRendering = detectExcessiveRendering;\n        // </debug>\n    }\n\n    applyDateConstraints(date, eventRecord, context) {\n        const\n            minDate = context.dateConstraints?.start,\n            maxDate = context.dateConstraints?.end;\n\n        // Keep desired date within constraints\n        if (minDate || maxDate) {\n            date = DateHelper.constrain(date, minDate, maxDate);\n            context.snappedDate = DateHelper.constrain(context.snappedDate, minDate, maxDate);\n        }\n\n        return date;\n    }\n\n    // Override the draggable interface so that we can update the bar while dragging outside\n    // the Draggable's rootElement (by default it stops notifications when outside rootElement)\n    moveDrag(drag) {\n        const\n            me          = this,\n            {\n                client,\n                tip\n            }           = me,\n            horizontal  = me.dragLock === 'x',\n            dimension   = horizontal ? 'X' : 'Y',\n            name        = client.scheduledEventName,\n            {\n                visibleDateRange,\n                enableEventAnimations,\n                timeAxis,\n                weekStartDay\n            }           = client,\n            rtl         = horizontal && client.rtl,\n            {\n                resolutionUnit,\n                resolutionIncrement\n            }           = timeAxis,\n            {\n                event,\n                context\n            }           = drag,\n            {\n                eventRecord\n            }           = context,\n            offset      = context.offset * (rtl ? -1 : 1),\n            {\n                isOccurrence\n            }           = eventRecord,\n            eventStart  = eventRecord.get('startDate'),\n            eventEnd    = eventRecord.get('endDate'),\n            coord       = event[`client${dimension}`] + offset,\n            clientRect  = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord  = clientRect.getStart(rtl, horizontal),\n            endCoord    = clientRect.getEnd(rtl, horizontal);\n\n        context.event = event;\n\n        // If this is the last move event recycled because of a scroll, refresh the date\n        if (event.isScroll) {\n            drag.date = client.getDateFromCoordinate(event[`page${dimension}`] + offset, null, false);\n        }\n\n        let crossedOver, avoidedZeroSize,\n            // Use the value set up in onDragPointerMove by default\n            { date } = drag,\n            {\n                toSet,\n                otherEnd,\n                draggingEnd\n            } = context;\n\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord > startCoord) {\n                date = drag.date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = drag.date = visibleDateRange.endDate;\n            }\n\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord < startCoord) {\n            date = drag.date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord > endCoord) {\n            date = drag.date = visibleDateRange.endDate;\n        }\n\n        // Detect crossover which some subclasses might need to process\n        if (toSet === 'endDate') {\n            if (date < eventStart) {\n                crossedOver = -1;\n            }\n        }\n        else {\n            if (date > eventEnd) {\n                crossedOver = 1;\n            }\n        }\n\n        // If we dragged the dragged end over to the opposite side of the start end.\n        // Some subclasses allow this and need to respond. EventDragCreate does this.\n        if (crossedOver && me.onDragEndSwitch) {\n            me.onDragEndSwitch(context, date, crossedOver);\n            otherEnd = context.otherEnd;\n            toSet = context.toSet;\n        }\n\n        if (client.snapRelativeToEventStartDate) {\n            date = timeAxis.roundDate(date, context.oldValue);\n        }\n\n        // The displayed and eventual data value\n        context.snappedDate = DateHelper.round(date, timeAxis.resolution, null, weekStartDay);\n\n        const duration = DateHelper.diff(date, context[otherEnd], resolutionUnit) * (draggingEnd ? -1 : 1);\n\n        // Narrower than half resolutionIncrement will abort drag creation, set flag to have UI reflect this\n        if (me.isEventDragCreate) {\n            context.tooNarrow = duration < resolutionIncrement / 2;\n        }\n        // The mousepoint date means that the duration is less than resolutionIncrement resolutionUnits.\n        // Ensure that the dragged end is at least resolutionIncrement resolutionUnits from the other end.\n        else if (duration < resolutionIncrement) {\n            // Snap to zero if allowed\n            if (me.allowResizeToZero) {\n                context.snappedDate = date = context[otherEnd];\n            }\n            else {\n                const sign = otherEnd === 'startDate' ? 1 : -1;\n                context.snappedDate = date = timeAxis.roundDate(DateHelper.add(eventRecord.get(otherEnd), resolutionIncrement * sign, resolutionUnit));\n                avoidedZeroSize = true;\n            }\n        }\n\n        // take dateConstraints into account\n        date = me.applyDateConstraints(date, eventRecord, context);\n\n        // If the mouse move has changed the detected date\n        if (!context.date || date - context.date || avoidedZeroSize) {\n            context.date = date;\n\n            // The validityFn needs to see the proposed value.\n            // Consult our snap config to see if we should be dragging in snapped mode\n            context[toSet] = me.showExactResizePosition || client.timeAxisViewModel.snap ? context.snappedDate : date;\n\n            // Snapping would take it to zero size - this is not allowed in drag resizing.\n            context.valid = me.allowResizeToZero || context[toSet] - context[toSet === 'startDate' ? 'endDate' : 'startDate'] !== 0;\n\n            // If the date to push into the record is new...\n            if (eventRecord.get(toSet) - context[toSet]) {\n                context.valid = me.checkValidity(context, event);\n                context.message = '';\n\n                if (context.valid && typeof context.valid !== 'boolean') {\n                    context.message = context.valid.message;\n                    context.valid = context.valid.valid;\n                }\n\n                // If users returns nothing, that's interpreted as valid\n                context.valid = (context.valid !== false);\n\n                if (context.valid) {\n                    const partialResizeEvent = {\n                        [`${name}Record`] : eventRecord,\n                        startDate         : eventStart,\n                        endDate           : eventEnd,\n                        element           : drag.itemElement,\n                        context\n                    };\n\n                    // Update the event we are about to fire and the context *before* we update the record\n                    partialResizeEvent[toSet] = context[toSet];\n\n                    // Trigger eventPartialResize or taskPartialResize depending on product\n                    me.triggerEventPartialResize(`${name}PartialResize`, partialResizeEvent);\n\n                    // An occurrence must have a store to announce its batched changes through.\n                    // They must usually never have a store - they are transient, but we\n                    // need to update the UI.\n                    if (isOccurrence) {\n                        eventRecord.stores.push(client.eventStore);\n                    }\n\n                    // Update the eventRecord.\n                    // Use setter rather than accessor so that in a Project, the entity's\n                    // accessor doesn't propagate the change to the whole project.\n                    // Scheduler must not animate this.\n                    client.enableEventAnimations = false;\n\n                    this.resizeEventPartiallyInternal(eventRecord, context);\n\n                    client.enableEventAnimations = enableEventAnimations;\n\n                    if (isOccurrence) {\n                        eventRecord.stores.length = 0;\n                    }\n                }\n\n                // Flag drag created too narrow events as invalid late, want all code above to execute for them\n                // to get the proper size rendered\n                if (context.tooNarrow) {\n                    context.valid = false;\n                }\n            }\n        }\n\n        if (tip) {\n            // In case of edge flip (EventDragCreate), the align point may change\n            tip.align = tipAlign[context.edge];\n            tip.alignTo(me.getTooltipTarget(drag));\n        }\n\n        super.moveDrag(drag);\n    }\n\n    dragEnd(drag) {\n        const { context } = drag;\n\n        if (context) {\n            context.event = drag.event;\n        }\n\n        if (drag.aborted) {\n            context?.finalize(false);\n        }\n        // 062_resize.t.js specifies that if drag was not started but the mouse has moved,\n        // the eventresizestart and eventresizeend must fire\n        else if (!this.isEventDragCreate && !drag.started && !EventHelper.getPagePoint(drag.event).equals(EventHelper.getPagePoint(drag.startEvent))) {\n            this.dragStart(drag);\n            this.cleanup(drag.context, false);\n        }\n    }\n\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate\n            } = context;\n\n        let modified;\n\n        this.tip?.hide();\n\n        context.valid = startDate && endDate && (this.allowResizeToZero || (endDate - startDate > 0)) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end changed\n            context.valid !== false;\n\n        if (context.valid) {\n            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to applying the new values. Triggers beforeEventResizeFinalize or\n            // beforeTaskResizeFinalize depending on product\n            this.triggerBeforeEventResizeFinalize(`before${client.capitalizedEventName}ResizeFinalize`, { context, event, [`${client.scheduledEventName}Record`] : context.eventRecord });\n            modified = true;\n        }\n\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n\n    // This is called with a thisObj of the context object\n    // We set \"me\" to the owner, and \"context\" to the thisObj so that it\n    // reads as if it were a method of this class.\n    async finalize(updateRecord) {\n        const\n            me      = this.owner,\n            context = this,\n            {\n                eventRecord,\n                oldValue,\n                toSet\n            }       = context,\n            {\n                snapRelativeToEventStartDate,\n                timeAxis\n            }       = me.client;\n\n        let wasChanged = false;\n\n        if (updateRecord) {\n            if (snapRelativeToEventStartDate) {\n                context[toSet] = context.snappedDate = timeAxis.roundDate(context.date, oldValue);\n            }\n\n            // Each product updates the record differently\n            wasChanged = await me.internalUpdateRecord(context, eventRecord);\n        }\n        else {\n            // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n            me.cancelEventRecordBatch(eventRecord);\n\n            // Manually trigger redraw of occurrences since they are not part of any stores\n            if (eventRecord.isOccurrence) {\n                eventRecord.resources.forEach(resource => me.client.repaintEventsForResource(resource));\n            }\n        }\n\n        me.cleanup(context, wasChanged);\n    }\n\n    // This is always called on drop or abort.\n    cleanup(context, changed) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                element,\n                eventRecord\n            }                = context,\n            name             = client.scheduledEventName;\n\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = false;\n\n        client.endListeningForBatchedUpdates();\n        me.tip?.hide();\n        me.unHighlightHandle(element);\n        client.element.classList.remove(...me.dragActiveCls.split(' '));\n        // if (dependencies) {\n        //     // When resizing is done and mouse is over element, we show terminals\n        //     if (element.matches(':hover')) {\n        //         dependencies.showTerminals(eventRecord, element);\n        //     }\n        // }\n\n        // Triggers eventResizeEnd or taskResizeEnd depending on product\n        me.triggerEventResizeEnd(`${name}ResizeEnd`, {\n            changed,\n            [`${name}Record`] : eventRecord,\n            ...me.getResizeEndParams(context)\n        });\n    }\n\n    async internalUpdateRecord(context, timespanRecord) {\n        const\n            { client }     = this,\n            { generation } = timespanRecord;\n\n        // Special handling of occurrences, they need normalization since that is not handled by engine at the moment\n        if (timespanRecord.isOccurrence) {\n            client.endListeningForBatchedUpdates();\n\n            // If >1 level deep, just unwind one level.\n            timespanRecord[timespanRecord.batching > 1 ? 'endBatch' : 'cancelBatch']();\n            timespanRecord.set(TimeSpan.prototype.inSetNormalize.call(timespanRecord, {\n                startDate : context.startDate,\n                endDate   : context.endDate\n            }));\n        }\n        else {\n            const toSet = {\n                [context.toSet] : context[context.toSet]\n            };\n\n            // If we have the Engine available, consult it to calculate a corrected duration.\n            // Adjust the dragged date point to conform with the calculated duration.\n            if (timespanRecord.isEntity) {\n                const\n                    {\n                        startDate,\n                        endDate,\n                        draggingEnd\n                    } = context;\n\n                // Fix the duration according to the Entity's rules.\n                context.duration = toSet.duration = timespanRecord.run('calculateProjectedDuration', startDate, endDate);\n\n                // Fix the dragged date point according to the Entity's rules.\n                toSet[context.toSet] = timespanRecord.run('calculateProjectedXDateWithDuration', draggingEnd ? startDate : endDate, draggingEnd, context.duration);\n\n                const setOtherEnd = !timespanRecord[context.otherEnd];\n\n                // Set all values, start and end in case they had never been set\n                // ie, we're now scheduling a previously unscheduled event.\n                if (setOtherEnd) {\n                    toSet[context.otherEnd] = context[context.otherEnd];\n                }\n\n                // Update the record to its final correct state using *batched changes*\n                // These will *not* be propagated, it's just to force the dragged event bar\n                // into its corrected shape before the real changes which will propagate are applied below.\n                // We MUST do it like this because the final state may not be a net change if the changes\n                // got rejected, and in that case, the engine will not end up firing any change events.\n                timespanRecord.set(toSet);\n\n                // Quit listening for batchedUpdate *before* we cancel the batch so that the\n                // change events from the revert do not update the UI.\n                client.endListeningForBatchedUpdates();\n\n                this.cancelEventRecordBatch(timespanRecord);\n\n                // Clear estimated wrap date, exact wrap date will be calculated when referred to from renderer\n                if (client.features.eventBuffer?.enabled) {\n                    timespanRecord[context.wrapToSet] = null;\n                }\n\n                const promisesToWait = [];\n\n                // Really update the data after cancelling the batch\n                if (setOtherEnd) {\n                    promisesToWait.push(timespanRecord[context.setOtherMethod](toSet[context.otherEnd], false));\n                }\n\n                promisesToWait.push(timespanRecord[context.setMethod](toSet[context.toSet], false));\n\n                await Promise.all(promisesToWait);\n\n                timespanRecord.endBatch();\n            }\n            else {\n                // Collect any changes (except the start/end date) that happened during the resize operation\n                const batchChanges = Object.assign({}, timespanRecord.meta.batchChanges);\n                delete batchChanges[context.toSet];\n                client.endListeningForBatchedUpdates();\n\n                this.cancelEventRecordBatch(timespanRecord);\n\n                timespanRecord.set(batchChanges);\n                timespanRecord[context.setMethod](toSet[context.toSet], false);\n            }\n        }\n\n        // wait for project data update\n        await client.project.commitAsync();\n\n        // If the record has been changed\n        return timespanRecord.generation !== generation;\n    }\n\n    onDragItemMouseMove(event) {\n        if (event.pointerType !== 'touch' && !this.handleSelector) {\n            this.checkResizeHandles(event);\n        }\n    }\n\n    /**\n     * Check if mouse is over a resize handle (virtual). If so, highlight.\n     * @private\n     * @param {MouseEvent} event\n     */\n    checkResizeHandles(event) {\n        const\n            me           = this,\n            { overItem } = me;\n\n        // mouse over a target element and allowed to resize?\n        if (overItem && !me.client.readOnly && (!me.allowResize || me.allowResize(overItem, event))) {\n            const eventRecord = me.client.resolveTimeSpanRecord(overItem);\n\n            if (eventRecord?.readOnly) {\n                return;\n            }\n\n            if (me.isOverAnyHandle(event, overItem)) {\n                me.highlightHandle(); // over handle\n            }\n            else {\n                me.unHighlightHandle(); // not over handle\n            }\n        }\n    }\n\n    onDragItemMouseLeave(event, oldOverItem) {\n        this.unHighlightHandle(oldOverItem);\n    }\n\n    /**\n     * Highlights handles (applies css that changes cursor).\n     * @private\n     */\n    highlightHandle() {\n        const\n            {\n                overItem : item,\n                client\n            }      = this,\n            handleTargetElement = item.syncIdMap?.[client.scheduledEventName] ?? item.querySelector(client.eventInnerSelector);\n\n        // over a handle, add cls to change cursor\n        handleTargetElement.classList.add('b-resize-handle');\n        item.classList.add('b-over-resize-handle');\n    }\n\n    /**\n     * Unhighlight handles (removes css).\n     * @private\n     */\n    unHighlightHandle(item = this.overItem) {\n        if (item) {\n            const\n                me    = this,\n                inner = item.syncIdMap?.[me.client.scheduledEventName] ?? item.querySelector(me.client.eventInnerSelector);\n\n            if (inner) {\n                inner.classList.remove('b-resize-handle', me.resizingItemInnerCls);\n            }\n\n            item.classList.remove('b-over-resize-handle', me.draggingItemCls);\n        }\n    }\n\n    isOverAnyHandle(event, target) {\n        return this.isOverStartHandle(event, target) || this.isOverEndHandle(event, target);\n    }\n\n    isOverStartHandle(event, target) {\n        return this.getHandleRect('start', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n\n    isOverEndHandle(event, target) {\n        return this.getHandleRect('end', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n\n    getHandleRect(side, event, eventEl) {\n        if (this.overItem) {\n            eventEl = event.target.closest(`.${this.client.eventCls}`) || eventEl.querySelector(`.${this.client.eventCls}`);\n            if (!eventEl) {\n                return;\n            }\n\n            const\n                me              = this,\n                start           = side === 'start',\n                { client }      = me,\n                rtl             = Boolean(client.rtl),\n                axis            = me.dragLock,\n                horizontal      = axis === 'x',\n                dim             = horizontal ? 'width' : 'height',\n                handleSpec      = `${horizontal ? (start && !rtl) ? 'left' : 'right' : start ? 'top' : 'bottom'}Handle`,\n                { offsetWidth } = eventEl,\n                timespanRecord  = client.resolveTimeSpanRecord(eventEl),\n                resizable       = timespanRecord?.isResizable,\n                eventRect       = Rectangle.from(eventEl),\n                result          = eventRect.clone(),\n                handleStyle     = globalThis.getComputedStyle(eventEl, ':before'),\n                // Larger draggable zones on pure touch devices with no mouse\n                touchHandleSize = (!me.handleSelector && !BrowserHelper.isHoverableDevice) ? me.touchHandleSize : undefined,\n                handleSize      = touchHandleSize || me.handleSize || parseFloat(handleStyle[dim]),\n                handleVisThresh = me.handleVisibilityThreshold || 2 * me.handleSize,\n                centerGap       = me.dynamicHandleSize ? me.reservedSpace / 2 : 0,\n                deflateArgs     = [0, 0, 0, 0];\n\n            // To decide if we are over a valid handle, we first check disabled state\n            // Then this.leftHandle/this.rightHandle/this.topHandle/this.bottomHandle\n            // Then whether there's enough event bar width to accommodate separate handles\n            // Then whether the event itself allows resizing at the specified side.\n            if (!me.disabled && me[handleSpec] && (offsetWidth >= handleVisThresh || me.dynamicHandleSize) && (resizable === true || resizable === side)) {\n                const oppositeEnd = (!horizontal && !start) || (horizontal && (rtl  === start));\n\n                if (oppositeEnd) {\n                    // Push handle start point to other end and clip result to other end\n                    result[axis] += (eventRect[dim] - handleSize);\n                    deflateArgs[horizontal ? 3 : 0] = eventRect[dim] / 2 + centerGap;\n                }\n                else {\n                    deflateArgs[horizontal ? 1 : 2] = eventRect[dim] / 2 + centerGap;\n                }\n\n                // Deflate the event bar rectangle to encapsulate 2px less than the side's own half\n                // so that we can constrain the handle zone to be inside its own half when bar is small.\n                eventRect.deflate(...deflateArgs);\n                result[dim] = handleSize;\n\n                // Constrain handle rectangles to each side so that they can never collide.\n                // Each handle is constrained into its own half.\n                result.constrainTo(eventRect);\n\n                // Zero sized handles cannot be hovered\n                if (result[dim]) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    setupDragContext(event) {\n        const me = this;\n\n        // Only start a drag if we are over a handle zone.\n        if (me.overItem && me.isOverAnyHandle(event, me.overItem) && me.isElementResizable(me.overItem, event)) {\n            const result = super.setupDragContext(event);\n\n            result.scrollManager = me.client.scrollManager;\n\n            return result;\n        }\n    }\n\n    changeHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n\n    changeTouchHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n\n    changeTip(tip, oldTip) {\n        const me = this;\n\n        if (!me.showTooltip) {\n            return null;\n        }\n\n        if (tip) {\n            if (tip.isTooltip) {\n                tip.owner = me;\n            }\n            else {\n                tip = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                    id : me.tipId\n                }, tip, {\n                    getHtml : me.getTipHtml.bind(me),\n                    owner   : me.client\n                }, me.tip), {\n                    owner    : me,\n                    defaults : {\n                        type : 'tooltip'\n                    }\n                });\n            }\n\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                thisObj         : me\n            });\n\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n        }\n        else if (oldTip) {\n            oldTip.destroy();\n            me.clockTemplate?.destroy();\n        }\n\n        return tip;\n    }\n\n    //endregion\n\n    //region Events\n\n    isElementResizable(element, event) {\n        const\n            me             = this,\n            { client }     = me,\n            timespanRecord = client.resolveTimeSpanRecord(element);\n\n        if (client.readOnly) {\n            return false;\n        }\n\n        let resizable = timespanRecord?.isResizable;\n\n        // Not resizable if the mousedown is on a resizing handle of\n        // a percent bar.\n        const\n            handleHoldingElement = element?.syncIdMap[client.scheduledEventName] ?? element,\n            handleEl             = event.target.closest('[class$=\"-handle\"]');\n\n        if (!resizable || (handleEl && handleEl !== handleHoldingElement)) {\n            return false;\n        }\n\n        element = event.target.closest(me.dragSelector);\n\n        if (!element) {\n            return false;\n        }\n\n        const\n            startsOutside = element.classList.contains('b-sch-event-startsoutside'),\n            endsOutside   = element.classList.contains('b-sch-event-endsoutside');\n\n        if (resizable === true) {\n            if (startsOutside && endsOutside) {\n                return false;\n            }\n            else if (startsOutside) {\n                resizable = 'end';\n            }\n            else if (endsOutside) {\n                resizable = 'start';\n            }\n            else {\n                return me.isOverStartHandle(event, element) || me.isOverEndHandle(event, element);\n            }\n        }\n\n        if (\n            (startsOutside && resizable === 'start') ||\n            (endsOutside && resizable === 'end')\n        ) {\n            return false;\n        }\n\n        if (\n            (me.isOverStartHandle(event, element) && resizable === 'start') ||\n            (me.isOverEndHandle(event, element) && resizable === 'end')\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    updateDateIndicator() {\n        const\n            { clockTemplate } = this,\n            {\n                eventRecord,\n                draggingEnd,\n                snappedDate\n            }                 = this.dragging.context,\n            startDate         = draggingEnd ? eventRecord.get('startDate') : snappedDate,\n            endDate           = draggingEnd ? snappedDate : eventRecord.get('endDate'),\n            { element }       = this.tip;\n\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-startdate'), startDate);\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);\n    }\n\n    getTooltipTarget({ itemElement, context }) {\n        const\n            me      = this,\n            { rtl } = me.client,\n            target  = Rectangle.from(itemElement, null, true);\n\n        if (me.dragLock === 'x') {\n            // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.\n            if ((!rtl && context.edge === 'right') || (rtl && context.edge === 'left')) {\n                target.x = target.right - 1;\n            }\n            else {\n                target.x -= me.tip.anchorSize[0] / 2;\n            }\n            target.width = me.tip.anchorSize[0] / 2;\n        }\n        else {\n            // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.\n            if (context.edge === 'bottom') {\n                target.y = target.bottom - 1;\n            }\n            target.height = me.tip.anchorSize[1] / 2;\n        }\n\n        return { target };\n    }\n\n    basicValidityCheck(context, event) {\n        return context.startDate &&\n            (context.endDate > context.startDate || this.allowResizeToZero) &&\n            this.validatorFn.call(this.validatorFnThisObj || this, context, event);\n    }\n\n    //endregion\n\n    //region Tooltip\n\n    getTipHtml({ tip }) {\n        const\n            me = this,\n            {\n                startDate,\n                endDate,\n                toSet,\n                snappedDate,\n                valid,\n                message = '',\n                timespanRecord\n            }  = me.dragging.context;\n\n        // Empty string hides the tip - we get called before the Resizer, so first call will be empty\n        if (!startDate || !endDate) {\n            return tip.html;\n        }\n\n        // Set whichever one we are moving\n        const tipData = {\n            record  : timespanRecord,\n            valid,\n            message,\n            startDate,\n            endDate,\n            [toSet] : snappedDate\n        };\n\n        // Format the two ends. This has to be done outside of the object initializer\n        // because they use properties that are only in the tipData object.\n        tipData.startText = me.client.getFormattedDate(tipData.startDate);\n        tipData.endText = me.client.getFormattedDate(tipData.endDate);\n        tipData.startClockHtml = me.clockTemplate.template({\n            date : tipData.startDate,\n            text : tipData.startText,\n            cls  : 'b-sch-tooltip-startdate'\n        });\n        tipData.endClockHtml = me.clockTemplate.template({\n            date : tipData.endDate,\n            text : tipData.endText,\n            cls  : 'b-sch-tooltip-enddate'\n        });\n\n        return me.tooltipTemplate(tipData);\n    }\n\n    //endregion\n\n    //region Product specific, may be overridden in subclasses\n\n    beginEventRecordBatch(eventRecord) {\n        eventRecord.beginBatch();\n    }\n\n    cancelEventRecordBatch(eventRecord) {\n        // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n        eventRecord.cancelBatch();\n    }\n\n    getBeforeResizeParams(context) {\n        const { client } = this;\n\n        return {\n            resourceRecord : client.resolveResourceRecord(client.isVertical ? context.event : context.element)\n        };\n    }\n\n    getResizeStartParams(context) {\n        return {\n            resourceRecord : context.resourceRecord\n        };\n    }\n\n    getResizeEndParams(context) {\n        return {\n            resourceRecord : context.resourceRecord,\n            event          : context.event\n        };\n    }\n\n    setupProductResizeContext(context, event) {\n        const\n            { client }       = this,\n            { element }      = context,\n            eventRecord      = client.resolveEventRecord(element),\n            resourceRecord   = client.resolveResourceRecord?.(element),\n            assignmentRecord = client.resolveAssignmentRecord?.(element);\n\n        Object.assign(context, {\n            eventRecord,\n            taskRecord      : eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            dateConstraints : client.getDateConstraints?.(resourceRecord, eventRecord)\n        });\n    }\n\n    checkValidity({ startDate, endDate, eventRecord, resourceRecord }) {\n        const { client } = this;\n\n        if (!client.allowOverlap) {\n            if (eventRecord.resources.some(resource => !client.isDateRangeAvailable(startDate, endDate, eventRecord, resource))) {\n                return {\n                    valid   : false,\n                    message : this.L('L{EventDrag.eventOverlapsExisting}')\n                };\n            }\n        }\n        return this.basicValidityCheck(...arguments);\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-resize-tip`;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(EventResize, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventResize, false, 'ResourceHistogram');\n", "import EventResize from '../EventResize.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport Draggable from '../../../Core/mixin/Draggable.js';\nimport TaskEditStm from '../mixin/TaskEditStm.js';\n\n/**\n * @module Scheduler/feature/base/DragCreateBase\n */\nconst getDragCreateDragDistance = function(event) {\n    // Do not allow the drag to begin if the taskEdit feature (if present) is in the process\n    // of canceling. We must wait for it to have cleaned up its data manipulations before\n    // we can add the new, drag-created record\n    if (this.source?.client.features.taskEdit?._canceling) {\n        return false;\n    }\n    return EventHelper.getDistanceBetween(this.startEvent, event);\n};\n\n/**\n * Base class for EventDragCreate (Scheduler) and TaskDragCreate (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Scheduler/feature/EventResize\n */\nexport default class DragCreateBase extends TaskEditStm(EventResize) {\n    //region Config\n\n    static configurable = {\n        /**\n         * true to show a time tooltip when dragging to create a new event\n         * @config {Boolean}\n         * @default\n         */\n        showTooltip : true,\n\n        /**\n         * Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.\n         * @config {Number}\n         * @default\n         */\n        dragTolerance : 2,\n\n        // used by gantt to only allow one task per row\n        preventMultiple : false,\n\n        dragTouchStartDelay : 300,\n\n        /**\n         * `this` reference for the validatorFn\n         * @config {Object}\n         */\n        validatorFnThisObj : null,\n\n        tipTemplate : data => `\n            <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                ${data.startClockHtml}\n                ${data.endClockHtml}\n                <div class=\"b-sch-tip-message\">${data.message}</div>\n            </div>\n        `,\n\n        dragActiveCls : 'b-dragcreating'\n    };\n\n    static pluginConfig = {\n        chain  : ['render', 'onEventDataGenerated'],\n        before : ['onElementContextMenu']\n    };\n\n    construct(scheduler, config) {\n        if (config?.showTooltip === false) {\n            config.tip = null;\n        }\n        super.construct(...arguments);\n    }\n\n    //endregion\n\n    changeValidatorFn(validatorFn) {\n        // validatorFn property is used by the EventResize base to validate each mousemove\n        // We change the property name to createValidatorFn\n        this.createValidatorFn = validatorFn;\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n\n    onDragEndSwitch(context) {\n        const\n            { client }                = this,\n            { enableEventAnimations } = client,\n            {\n                eventRecord,\n                draggingEnd\n            }                         = context,\n            horizontal                = this.dragLock === 'x',\n            { initialDate }           = this.dragging;\n\n        // Setting the new opposite end should not animate\n        client.enableEventAnimations = false;\n\n        // Zero duration at the moment of the flip\n        eventRecord.set({\n            startDate : initialDate,\n            endDate   : initialDate\n        });\n\n        // We're switching to dragging the start\n        if (draggingEnd) {\n            Object.assign(context, {\n                endDate        : initialDate,\n                toSet          : 'startDate',\n                otherEnd       : 'endDate',\n                setMethod      : 'setStartDate',\n                setOtherMethod : 'setEndDate',\n                edge           : horizontal ? 'left' : 'top'\n            });\n        }\n        else {\n            Object.assign(context, {\n                startDate      : initialDate,\n                toSet          : 'endDate',\n                otherEnd       : 'startDate',\n                setMethod      : 'setEndDate',\n                setOtherMethod : 'setStartDate',\n                edge           : horizontal ? 'right' : 'bottom'\n            });\n        }\n\n        context.draggingEnd = this.draggingEnd = !draggingEnd;\n        client.enableEventAnimations = enableEventAnimations;\n    }\n\n    beforeDrag(drag) {\n        const\n            me                       = this,\n            result                   = super.beforeDrag(drag),\n            { pan, eventDragSelect } = me.client.features;\n\n        // Superclass's handler may also veto\n        if (result !== false && (\n            // used by gantt to only allow one task per row\n            (me.preventMultiple && !me.isRowEmpty(drag.rowRecord)) ||\n            me.disabled ||\n            // If Pan is enabled, it has right of way\n            (pan && !pan.disabled) ||\n            // If EventDragSelect is enabled, it has right of way\n            (eventDragSelect && !eventDragSelect.disabled)\n        )) {\n            return false;\n        }\n\n        // Prevent drag select if drag-creating, could collide otherwise\n        // (reset by GridSelection)\n        me.client.preventDragSelect = true;\n\n        return result;\n    }\n\n    startDrag(drag) {\n        const result = super.startDrag(drag);\n\n        // Returning false means operation is aborted.\n        if (result !== false) {\n            const { context } = drag;\n\n            // Date to flip around when changing direction\n            drag.initialDate = context.eventRecord.get(this.draggingEnd ? 'startDate' : 'endDate');\n\n            this.client.trigger('dragCreateStart', {\n                proxyElement   : drag.element,\n                eventElement   : drag.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n\n            // We are always dragging the exact edge of the event element.\n            drag.context.offset   = 0;\n            drag.context.oldValue = drag.mousedownDate;\n        }\n        return result;\n    }\n\n    // Used by our EventResize superclass to know whether the drag point is the end or the beginning.\n    isOverEndHandle() {\n        return this.draggingEnd;\n    }\n\n    setupDragContext(event) {\n        const { client } = this;\n\n        // Only mousedown on an empty cell can initiate drag-create\n        if (client.matchScheduleCell(event.target)) {\n            const resourceRecord = client.resolveResourceRecord(event)?.$original;\n\n            // And there must be a resource backing the cell.\n            if (resourceRecord && !resourceRecord.isSpecialRow) {\n                // Skip the EventResize's setupDragContext. We want the base one.\n                const\n                    result      = Draggable().prototype.setupDragContext.call(this, event),\n                    scrollables = [];\n\n                if (client.isVertical) {\n                    scrollables.push({\n                        element   : client.scrollable.element,\n                        direction : 'vertical'\n                    });\n                }\n                else {\n                    scrollables.push({\n                        element   : client.timeAxisSubGrid.scrollable.element,\n                        direction : 'horizontal'\n                    });\n                }\n\n                result.scrollManager = client.scrollManager;\n                result.monitoringConfig = { scrollables };\n                result.resourceRecord = result.rowRecord = resourceRecord;\n\n                // We use a special method to get the distance moved.\n                // If the TaskEdit feature is still in its canceling phase, then\n                // it returns false which inhibits the start of the drag-create\n                // until the cancelation is complete.\n                result.getDistance = getDragCreateDragDistance;\n                return result;\n            }\n        }\n    }\n\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate,\n                eventRecord\n            } = context,\n            { generation } = eventRecord;\n\n        let modified;\n\n        this.tip?.hide();\n\n        // Handle https://github.com/bryntum/support/issues/3210.\n        // The issue arises when the mouseup arrives very quickly and the commit kicked off\n        // at event add has not yet completed. If it now completes *after* we finalize\n        // the drag, it will reset the event to its initial state.\n        // If that commit has in fact finished, this will be a no-op\n        await client.project.commitAsync();\n\n        // If the above commit in fact reset the event back to the initial state, we have to\n        // force the event rendering to bring it back to the currently known context state.\n        if (eventRecord.generation !== generation) {\n            context.eventRecord[context.toSet] = context.oldValue;\n            context.eventRecord[context.toSet] = context[context.toSet];\n        }\n\n        context.valid = startDate && endDate && (endDate - startDate > 0) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end changed\n            context.valid !== false;\n\n        if (context.valid) {\n            // Seems to be a valid drag-create operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to finalizing the create.\n            client.trigger('beforeDragCreateFinalize', {\n                context,\n                event,\n                proxyElement   : context.element,\n                eventElement   : context.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n            modified = true;\n        }\n\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n\n    updateDragTolerance(dragTolerance) {\n        this.dragThreshold = dragTolerance;\n    }\n\n    //region Tooltip\n\n    changeTip(tip, oldTip) {\n        return super.changeTip(!tip || tip.isTooltip ? tip : ObjectHelper.assign({\n            id : `${this.client.id}-drag-create-tip`\n        }, tip), oldTip);\n    }\n\n    //endregion\n\n    //region Finalize (create EventModel)\n\n    // this method is actually called on the `context` object,\n    // so `this` object inside might not be what you think (see `me = this.owner` below)\n    // not clear what was the motivation for such design\n    async finalize(doCreate) {\n        // only call this method once, do not re-enter\n        if (this.finalized) {\n            return;\n        }\n\n        this.finalized = true;\n\n        const\n            me                = this.owner,\n            context           = this,\n            completeFinalization = () => {\n                if (!me.isDestroyed) {\n                    me.client.trigger('afterDragCreate', {\n                        proxyElement   : context.element,\n                        eventElement   : context.element,\n                        eventRecord    : context.eventRecord,\n                        resourceRecord : context.resourceRecord\n                    });\n                    me.cleanup(context);\n                }\n            };\n\n        if (doCreate) {\n            // Call product specific implementation\n            await me.finalizeDragCreate(context);\n\n            completeFinalization();\n        }\n        // Aborting without going ahead with create - we must deassign and remove the event\n        else {\n            await me.cancelDragCreate(context);\n\n            me.onAborted?.(context);\n            completeFinalization();\n        }\n    }\n\n    async cancelDragCreate(context) {\n    }\n\n    async finalizeDragCreate(context) {\n        // EventResize base class applies final changes to the event record\n        await this.internalUpdateRecord(context, context.eventRecord);\n\n        const stmCapture = {\n            stmInitiallyAutoRecord : this.stmInitiallyAutoRecord,\n            stmInitiallyDisabled   : this.stmInitiallyDisabled,\n            // this flag indicates whether the STM capture has been transferred to\n            // another feature, which will be responsible for finalizing the STM transaction\n            // (otherwise we'll do it ourselves)\n            transferred            : false\n        };\n\n        this.client.trigger('dragCreateEnd', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord,\n            event          : context.event,\n            eventElement   : context.element,\n            stmCapture\n        });\n\n        // Part of the Scheduler API. Triggered by its createEvent method.\n        // Auto-editing features can use this to edit new events.\n        // Note that this may be destroyed by a listener of the previous event.\n        this.client?.trigger('eventAutoCreated', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord\n        });\n\n        return stmCapture.transferred;\n    }\n\n    cleanup(context) {\n        const\n            { client }      = this,\n            { eventRecord } = context;\n\n        // Base class's cleanup is not called, we have to clear this flag.\n        // The isCreating flag is only set if the event is to be handed off to the\n        // eventEdit feature and that feature then has responsibility for clearing it.\n        eventRecord.meta.isResizing = false;\n\n        client.endListeningForBatchedUpdates();\n        this.tip?.hide();\n        client.element.classList.remove(...this.dragActiveCls.split(' '));\n\n        context.element.parentElement.classList.remove('b-sch-dragcreating');\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Prevent right click when drag creating\n     * @returns {Boolean}\n     * @private\n     */\n    onElementContextMenu() {\n        if (this.proxy) {\n            return false;\n        }\n    }\n\n    prepareCreateContextForFinalization(createContext, event, finalize, async = false) {\n        return {\n            ...createContext,\n            async,\n            event,\n            finalize\n        };\n    }\n\n    // Apply drag create \"proxy\" styling\n    onEventDataGenerated(renderData) {\n        if (this.dragging?.context?.eventRecord === renderData.eventRecord) {\n            // Allow custom styling for drag creation element\n            renderData.wrapperCls['b-sch-dragcreating'] = true;\n            // Styling when drag create will be aborted on drop (because it would yield zero duration)\n            renderData.wrapperCls['b-too-narrow'] = this.dragging.context.tooNarrow;\n        }\n    }\n\n    //endregion\n\n    //region Product specific, implemented in subclasses\n\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerBeforeResize() {}\n\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerEventResizeStart() {}\n\n    checkValidity(context, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    handleBeforeDragCreate(dateTime, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    isRowEmpty(rowRecord) {\n        throw new Error('Implement in subclass');\n    }\n\n    //endregion\n}\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\n\n/**\n * @module Scheduler/feature/base/TooltipBase\n */\n\n/**\n * Base class for `EventTooltip` (Scheduler) and `TaskTooltip` (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n */\nexport default class TooltipBase extends InstancePlugin {\n    //region Config\n\n    static get defaultConfig() {\n        return {\n\n            /**\n             * Specify true to have tooltip updated when mouse moves, if you for example want to display date at mouse\n             * position.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            autoUpdate : false,\n\n            /**\n             * The amount of time to hover before showing\n             * @config {Number}\n             * @default\n             */\n            hoverDelay : 250,\n\n            /**\n             * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.\n             *\n             * May be configured as `false` to persist visible after the mouse exits the target element. Configure it\n             * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`\n             * @config {Number}\n             * @default\n             */\n            hideDelay : 100,\n\n            // <remove-on-release>\n            // TODO: Rename to tooltipTemplate, deprecate template\n            // </remove-on-release>\n            template : null,\n\n            cls : null,\n\n            align : {\n                align : 'b-t'\n            },\n\n            clockTemplate : null,\n\n            // Set to true to update tooltip contents if record changes while tip is open\n            monitorRecordUpdate : null,\n\n            testConfig : {\n                hoverDelay : 0\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Triggered before a tooltip is shown. Return `false` to prevent the action.\n     * @preventable\n     * @event beforeShow\n     * @param {Core.widget.Tooltip} source The tooltip being shown.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n\n    /**\n     * Triggered after a tooltip is shown.\n     * @event show\n     * @param {Core.widget.Tooltip} source The tooltip.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n\n    //endregion\n\n    //region Init\n\n    construct(client, config) {\n        const me = this;\n\n        // process initial config into an actual config object\n        config = me.processConfig(config);\n\n        super.construct(client, config);\n\n        // Default triggering selector is the client's inner element selector\n        if (!me.forSelector) {\n            me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy)`;\n        }\n\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n\n        client.ion({\n            [`before${client.scheduledEventName}drag`] : () => {\n                // Using {} on purpose to not return the promise\n                me.tooltip?.hide();\n            }\n        });\n    }\n\n    // TooltipBase feature handles special config cases, where user can supply a function to use as template\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                template : config\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it (used mainly from ReactScheduler)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'tooltip');\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (this.tooltip) {\n            this.tooltip.disabled = disable;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            const\n                me             = this,\n                { client }     = me,\n                ignoreSelector = [\n                    '.b-dragselecting',\n                    '.b-eventeditor-editing',\n                    '.b-taskeditor-editing',\n                    '.b-resizing-event',\n                    '.b-task-percent-bar-resizing-task',\n                    '.b-dragcreating',\n                    `.b-dragging-${client.scheduledEventName}`,\n                    '.b-creating-dependency',\n                    '.b-dragproxy'\n                ].map(cls => `:not(${cls})`).join('');\n\n            me.tooltip?.destroy();\n\n            /**\n             * A reference to the tooltip instance, which will have a special `eventRecord` property that\n             * you can use to get data from the contextual event record to which this tooltip is related.\n             * @member {Core.widget.Tooltip} tooltip\n             * @readonly\n             * @category Misc\n             */\n            const tip = me.tooltip = new Tooltip({\n                axisLock          : 'flexible',\n                id                : me.tipId || `${me.client.id}-event-tip`,\n                cls               : me.tipCls,\n                forSelector       : `.b-timelinebase${ignoreSelector} .b-grid-body-container:not(.b-scrolling) ${me.forSelector}`,\n                scrollAction      : 'realign',\n                forElement        : client.timeAxisSubGridElement,\n                showOnHover       : true,\n                anchorToTarget    : true,\n                getHtml           : me.getTipHtml.bind(me),\n                disabled          : me.disabled,\n                // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n                // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n                // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n                // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n                ...me.config,\n                internalListeners : me.configuredListeners\n            });\n\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                overtarget      : 'onOverNewTarget',\n                show            : 'onTipShow',\n                hide            : 'onTipHide',\n                thisObj         : me\n            });\n\n            // Once instantiated, any Tooltip configs are relayed through the feature directly to the tip\n            Object.keys(tip.$meta.configs).forEach(name => {\n                Object.defineProperty(this, name, {\n                    set : v => tip[name] = v,\n                    get : () => tip[name]\n                });\n            });\n        }\n    }\n\n    //region Listeners\n\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n\n    addListener(...args) {\n        const\n            // Call super method to handle enable/disable feature events\n            defaultDetacher = super.addListener(...args),\n            // Add listener to the `tooltip` instance\n            tooltipDetacher = this.tooltip?.addListener(...args);\n\n        if (defaultDetacher || tooltipDetacher) {\n            return () => {\n                defaultDetacher?.();\n                tooltipDetacher?.();\n            };\n        }\n    }\n\n    removeListener(...args) {\n        super.removeListener(...args);\n\n        // Remove listener from the `tooltip` instance\n        this.tooltip?.removeListener(...args);\n    }\n\n    //endregion\n\n    updateDateIndicator() {\n        const\n            me             = this,\n            tip            = me.tooltip,\n            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        if (!me.record) {\n            return;\n        }\n\n        me.clockTemplate.updateDateIndicator(tip.element, me.record.startDate);\n\n        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, me.record.endDate);\n    }\n\n    resolveTimeSpanRecord(forElement) {\n        return this.client.resolveTimeSpanRecord(forElement);\n    }\n\n    getTipHtml({ tip, activeTarget }) {\n        const\n            me             = this,\n            { client }     = me,\n            recordProp     = me.recordType || `${client.scheduledEventName}Record`,\n            timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);\n\n        // If user has mouseovered a fading away element of a deleted event,\n        // an event record will not be found. In this case the tip must hide.\n        // Instance of check is to not display while propagating\n        if (timeSpanRecord?.startDate instanceof Date) {\n            const\n                { startDate, endDate } = timeSpanRecord,\n                startText              = client.getFormattedDate(startDate),\n                endDateValue           = client.getDisplayEndDate(endDate, startDate),\n                endText                = client.getFormattedDate(endDateValue);\n\n            tip.eventRecord = timeSpanRecord;\n\n            return me.template({\n                tip,\n                // eventRecord for Scheduler, taskRecord for Gantt\n                [`${recordProp}`] : timeSpanRecord,\n                startDate,\n                endDate,\n                startText,\n                endText,\n                startClockHtml    : me.clockTemplate.template({\n                    date : startDate,\n                    text : startText,\n                    cls  : 'b-sch-tooltip-startdate'\n                }),\n                endClockHtml : timeSpanRecord.isMilestone ? '' : me.clockTemplate.template({\n                    date : endDateValue,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n            });\n        }\n        else {\n            tip.hide();\n            return '';\n        }\n    }\n\n    get record() {\n        return this.tooltip.eventRecord;\n    }\n\n    onTipShow() {\n        const me = this;\n\n        if (me.monitorRecordUpdate && !me.updateListener) {\n            me.updateListener = me.client.eventStore.ion({\n                change  : me.onRecordUpdate,\n                buffer  : 300,\n                thisObj : me\n            });\n        }\n    }\n\n    onTipHide() {\n        // To not retain full project when changing project\n        this.tooltip.eventRecord = null;\n\n        this.updateListener?.();\n        this.updateListener = null;\n    }\n\n    onOverNewTarget({ newTarget }) {\n        this.tooltip.eventRecord = this.resolveTimeSpanRecord(newTarget);\n    }\n\n    onRecordUpdate({ record }) {\n        const { tooltip } = this;\n\n        // Make sure the record we are showing the tip for is still relevant\n        // If the change moved the element out from under the mouse, we will be hidden.\n        if (tooltip?.isVisible && record === this.record) {\n            tooltip.updateContent();\n\n            // If we were aligning to the event bar, realign to it.\n            if (tooltip.lastAlignSpec.aligningToElement) {\n                tooltip.realign();\n            }\n            // The pointer is still over the target (otherwise tooltip would be hidden)\n            // So invoke the tooltip's positioning\n            else {\n                tooltip.internalOnPointerOver(this.client.lastPointerEvent);\n            }\n        }\n    }\n}\n", "import DragHelper from '../../Core/helper/DragHelper.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\n\n/**\n * @module Scheduler/feature/AbstractTimeRanges\n */\n\n/**\n * Abstract base class, you should not use this class directly.\n * @abstract\n * @mixes Core/mixin/Delayable\n * @extends Core/mixin/InstancePlugin\n */\nexport default class AbstractTimeRanges extends InstancePlugin.mixin(Delayable) {\n    //region Config\n\n    /**\n     * Fired on the owning Scheduler when a click happens on a time range header element\n     * @event timeRangeHeaderClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when a double click happens on a time range header element\n     * @event timeRangeHeaderDblClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when a right click happens on a time range header element\n     * @event timeRangeHeaderContextMenu\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    static get defaultConfig() {\n        return {\n            // CSS class to apply to range elements\n            rangeCls : 'b-sch-range',\n\n            // CSS class to apply to line elements (0-duration time range)\n            lineCls : 'b-sch-line',\n\n            /**\n             * Set to `true` to enable dragging and resizing of range elements in the header. Only relevant when\n             * {@link #config-showHeaderElements} is `true`.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            enableResizing : false,\n\n            /**\n             * A Boolean specifying whether to show tooltip while resizing range elements, or a\n             * {@link Core.widget.Tooltip} config object which is applied to the tooltip\n             * @config {Boolean|TooltipConfig}\n             * @default\n             * @category Common\n             */\n            showTooltip : true,\n\n            /**\n             * Template used to generate the tooltip contents when hovering a time range header element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       tooltipTemplate({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            tooltipTemplate : null,\n\n            dragTipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    <div class=\"b-sch-tip-name\">${StringHelper.encodeHtml(data.name) || ''}</div>\n                    ${data.startClockHtml}\n                    ${data.endClockHtml || ''}\n                </div>\n            `,\n\n            baseCls : 'b-sch-timerange',\n\n            /**\n             * Function used to generate the HTML content for a time range header element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       headerRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} headerRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            headerRenderer : null,\n\n            /**\n             * Function used to generate the HTML content for a time range body element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       bodyRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} bodyRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            bodyRenderer : null,\n\n            // a unique cls used by subclasses to get custom styling of the elements rendered\n            cls : null,\n\n            narrowThreshold : 80\n        };\n    }\n\n    static configurable = {\n        /**\n         * Set to `false` to not render range elements into the time axis header\n         * @prp {Boolean}\n         * @default\n         * @category Common\n         */\n        showHeaderElements : true\n    };\n\n    // Plugin configuration. This plugin chains some functions in Grid.\n    static pluginConfig = {\n        chain : [\n            'onPaint',\n            'populateTimeAxisHeaderMenu',\n            'onSchedulerHorizontalScroll',\n            'afterScroll',\n            'onInternalResize'\n        ]\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        super.construct(client, config);\n\n        if (client.isVertical) {\n            client.ion({\n                renderRows : me.onUIReady,\n                thisObj    : me,\n                once       : true\n            });\n        }\n\n        // Add a unique cls used by subclasses to get custom styling of the elements rendered\n        // This makes sure that each class only removed its own elements from the DOM\n        me.cls = me.cls || `b-sch-${me.constructor.$$name.toLowerCase()}`;\n\n        me.baseSelector = `.${me.baseCls}.${me.cls}`;\n\n        // header elements are required for interaction\n        if (me.enableResizing) {\n            me.showHeaderElements = true;\n        }\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n\n        me.clockTemplate?.destroy();\n        me.tip?.destroy();\n\n        me.drag?.destroy();\n        me.resize?.destroy();\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        this.renderRanges();\n\n        super.doDisable(disable);\n    }\n\n    setupTimeAxisViewModelListeners() {\n        const me = this;\n\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n\n        me.client.timeAxisViewModel.ion({\n            name    : 'timeAxisViewModel',\n            update  : 'onTimeAxisViewModelUpdate',\n            thisObj : me\n        });\n\n        me.client.timeAxis.ion({\n            name          : 'timeAxis',\n            includeChange : 'renderRanges',\n            thisObj       : me\n        });\n\n        me.updateLineBuffer();\n    }\n\n    onUIReady() {\n        const\n            me         = this,\n            { client } = me;\n\n        // If timeAxisViewModel is swapped, re-setup listeners to new instance\n        client.ion({\n            timeAxisViewModelChange : me.setupTimeAxisViewModelListeners,\n            thisObj                 : me\n        });\n\n        me.setupTimeAxisViewModelListeners();\n\n        if (!client.hideHeaders) {\n            if (me.headerContainerElement) {\n                EventHelper.on({\n                    click       : me.onTimeRangeClick,\n                    dblclick    : me.onTimeRangeClick,\n                    contextmenu : me.onTimeRangeClick,\n                    delegate    : me.baseSelector,\n                    element     : me.headerContainerElement,\n                    thisObj     : me\n                });\n            }\n\n            if (me.enableResizing) {\n\n                me.drag = DragHelper.new({\n                    name               : 'rangeDrag',\n                    lockX              : client.isVertical,\n                    lockY              : client.isHorizontal,\n                    constrain          : true,\n                    outerElement       : me.headerContainerElement,\n                    targetSelector     : `${me.baseSelector}`,\n                    isElementDraggable : (el, event) => !client.readOnly && me.isElementDraggable(el, event),\n                    rtlSource          : client,\n\n                    internalListeners : {\n                        dragstart : 'onDragStart',\n                        drag      : 'onDrag',\n                        drop      : 'onDrop',\n                        reset     : 'onDragReset',\n                        abort     : 'onInvalidDrop',\n                        thisObj   : me\n                    }\n                }, me.dragHelperConfig);\n\n                me.resize = ResizeHelper.new({\n                    direction          : client.mode,\n                    targetSelector     : `${me.baseSelector}.b-sch-range`,\n                    outerElement       : me.headerContainerElement,\n                    isElementResizable : (el, event) => !el.matches('.b-dragging,.b-readonly') && !event.target.matches('.b-fa'),\n                    internalListeners  : {\n                        resizestart : 'onResizeStart',\n                        resizing    : 'onResizeDrag',\n                        resize      : 'onResize',\n                        cancel      : 'onInvalidResize',\n                        reset       : 'onResizeReset',\n                        thisObj     : me\n                    }\n                }, me.resizeHelperConfig);\n            }\n        }\n\n        me.renderRanges();\n\n        if (me.tooltipTemplate) {\n            me.hoverTooltip = new Tooltip({\n                forElement : me.headerContainerElement,\n                getHtml({ activeTarget }) {\n                    const timeRange = me.resolveTimeRangeRecord(activeTarget);\n\n                    return me.tooltipTemplate({ timeRange });\n                },\n                forSelector : '.' + me.baseCls + (me.cls ? '.' + me.cls : '')\n            });\n        }\n    }\n\n    //endregion\n\n    //region Draw\n\n    refresh() {\n        this._timeRanges = null;\n        this.renderRanges();\n    }\n\n    getDOMConfig(startDate, endDate) {\n        const\n            me            = this,\n            bodyConfigs   = [],\n            headerConfigs = [];\n\n        if (!me.disabled) {\n            // clear label rotation map cache here, used to prevent height calculations for every timeRange entry to\n            // speed up using recurrences\n            me._labelRotationMap = {};\n\n            for (const range of me.timeRanges) {\n                const result = me.renderRange(range, startDate, endDate);\n                if (result) {\n                    bodyConfigs.push(result.bodyConfig);\n                    headerConfigs.push(result.headerConfig);\n                }\n            }\n        }\n\n        return [bodyConfigs, headerConfigs];\n    }\n\n    renderRanges() {\n        const\n            me                   = this,\n            { client }           = me,\n            { foregroundCanvas } = client;\n\n        // Scheduler/Gantt might not yet be rendered\n        if (foregroundCanvas && client.isPainted && !client.timeAxisSubGrid.collapsed) {\n            const\n                { headerContainerElement }   = me,\n                updatedBodyElements          = [],\n                [bodyConfigs, headerConfigs] = me.getDOMConfig();\n\n            if (!me.bodyCanvas) {\n                me.bodyCanvas = DomHelper.createElement({\n                    className     : `b-timeranges-canvas ${me.cls}-canvas`,\n                    parent        : foregroundCanvas,\n                    retainElement : true\n                });\n            }\n\n            DomSync.sync({\n                targetElement : me.bodyCanvas,\n                childrenOnly  : true,\n                domConfig     : {\n                    children    : bodyConfigs,\n                    syncOptions : {\n                        releaseThreshold : 0,\n                        syncIdField      : 'id'\n                    }\n                },\n                callback : me.showHeaderElements ? null : ({\n                    targetElement,\n                    action\n                }) => {\n                    // Might need to rotate label when not showing header elements\n                    if (action === 'reuseElement' || action === 'newElement' || action === 'reuseOwnElement') {\n                        // Collect all here, to not force reflows in the middle of syncing\n                        updatedBodyElements.push(targetElement);\n                    }\n                }\n            });\n\n            if (me.showHeaderElements && !me.headerCanvas) {\n                me.headerCanvas = DomHelper.createElement({\n                    className     : `${me.cls}-canvas`,\n                    parent        : headerContainerElement,\n                    retainElement : true\n                });\n            }\n\n            if (me.headerCanvas) {\n                DomSync.sync({\n                    targetElement : me.headerCanvas,\n                    childrenOnly  : true,\n                    domConfig     : {\n                        children    : headerConfigs,\n                        syncOptions : {\n                            releaseThreshold : 0,\n                            syncIdField      : 'id'\n                        }\n                    }\n                });\n            }\n\n            // Rotate labels last, to not force reflows. First check if rotation is needed\n            for (const bodyElement of updatedBodyElements) {\n                me.cacheRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n\n            // Then apply rotation\n            for (const bodyElement of updatedBodyElements) {\n                me.applyRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n        }\n    }\n\n    // Implement in subclasses\n    get timeRanges() {\n        return [];\n    }\n\n    /**\n     * Based on this method result the feature decides whether the provided range should\n     * be rendered or not.\n     * The method checks that the range intersects the current viewport.\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @param {Date} [startDate] Specifies view start date. Defaults to view visible range start\n     * @param {Date} [endDate] Specifies view end date. Defaults to view visible range end\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(\n        range,\n        startDate = this.client.visibleDateRange.startDate,\n        endDate   = this.client.visibleDateRange.endDate\n    ) {\n        const\n            { timeAxis }                                             = this.client,\n            { startDate : rangeStart, endDate : rangeEnd, duration } = range;\n\n        return Boolean(rangeStart && (timeAxis.isContinuous || timeAxis.isTimeSpanInAxis(range)) && DateHelper.intersectSpans(\n            startDate,\n            endDate,\n            rangeStart,\n            // Lines are included longer, to make sure label does not disappear\n            duration ? rangeEnd : DateHelper.add(rangeStart, this._lineBufferDurationMS)\n        ));\n    }\n\n    getRangeDomConfig(timeRange, minDate, maxDate, relativeTo = 0) {\n        const\n            me         = this,\n            { client } = me,\n            { rtl }    = client,\n            startPos   = client.getCoordinateFromDate(DateHelper.max(timeRange.startDate, minDate), {\n                respectExclusion : true\n            }) - relativeTo,\n            endPos     = timeRange.endDate ? client.getCoordinateFromDate(DateHelper.min(timeRange.endDate, maxDate), {\n                respectExclusion : true,\n                isEnd            : true\n            }) - relativeTo : startPos,\n            size       = Math.abs(endPos - startPos),\n            isRange    = size > 0,\n            translateX = rtl ? `calc(${startPos}px - 100%)` : `${startPos}px`;\n\n        return {\n            className : {\n                [me.baseCls]     : 1,\n                [me.cls]         : me.cls,\n                [me.rangeCls]    : isRange,\n                [me.lineCls]     : !isRange,\n                [timeRange.cls]  : timeRange.cls,\n                'b-narrow-range' : isRange && size < me.narrowThreshold,\n                'b-readonly'     : timeRange.readOnly,\n                'b-rtl'          : rtl\n            },\n            dataset : {\n                id : timeRange.id\n            },\n            elementData : {\n                timeRange\n            },\n            style : client.isVertical\n                ? `transform: translateY(${translateX}); ${isRange ? `height:${size}px` : ''};`\n                : `transform: translateX(${translateX}); ${isRange ? `width:${size}px` : ''};`\n        };\n    }\n\n    renderRange(timeRange, startDate, endDate) {\n        const\n            me           = this,\n            { client }   = me,\n            { timeAxis } = client;\n\n        if (me.shouldRenderRange(timeRange, startDate, endDate) && timeAxis.startDate) {\n            const\n                config     = me.getRangeDomConfig(timeRange, timeAxis.startDate, timeAxis.endDate),\n                icon       = timeRange.iconCls && StringHelper.xss`<i class=\"${timeRange.iconCls}\"></i>`,\n                name       = timeRange.name && StringHelper.encodeHtml(timeRange.name),\n                labelTpl   = (name || icon) ? `<label>${icon || ''}${name || '&nbsp;'}</label>` : '',\n                bodyConfig = {\n                    ...config,\n                    style : config.style + (timeRange.style || ''),\n                    html  : me.bodyRenderer ? me.bodyRenderer({ timeRange }) : (me.showHeaderElements && !me.showLabelInBody ? '' : labelTpl)\n                };\n\n            let headerConfig;\n\n            if (me.showHeaderElements) {\n                headerConfig = {\n                    ...config,\n                    html : (me.headerRenderer ? me.headerRenderer({ timeRange }) : (me.showLabelInBody ? '' : labelTpl))\n                };\n            }\n\n            return { bodyConfig, headerConfig };\n        }\n    }\n\n    // Cache label rotation to not have to calculate for each occurrence when using recurring timeranges\n    cacheRotation(range, bodyElement) {\n        // Lines have no label. Do not check label content to do not force DOM layout!\n        if ((!range.iconCls && !range.name) || !range.duration) {\n            return;\n        }\n\n        const label = bodyElement.firstElementChild;\n\n        if (label && !range.recurringTimeSpan) {\n            this._labelRotationMap[range.id] = this.client.isVertical\n                ? label.offsetHeight < bodyElement.offsetHeight\n                : label.offsetWidth > bodyElement.offsetWidth;\n        }\n    }\n\n    applyRotation(range, bodyElement) {\n        const rotate = this._labelRotationMap[range.recurringTimeSpan?.id ?? range.id];\n\n        bodyElement.firstElementChild?.classList.toggle('b-vertical', Boolean(rotate));\n    }\n\n    getBodyElementByRecord(idOrRecord) {\n        const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord?.id;\n\n        return id != null && DomSync.getChild(this.bodyCanvas, id);\n    }\n\n    // Implement in subclasses\n    resolveTimeRangeRecord(el) {}\n\n    get headerContainerElement() {\n        const\n            me                                       = this,\n            { isVertical, timeView, timeAxisColumn } = me.client;\n\n        if (!me._headerContainerElement) {\n            // Render into the subGrid´s header element or the vertical timeaxis depending on mode\n            if (isVertical && timeView.element) {\n                me._headerContainerElement = timeView.element.parentElement;\n            }\n            else if (!isVertical) {\n                me._headerContainerElement = timeAxisColumn.element;\n            }\n        }\n\n        return me._headerContainerElement;\n    }\n\n    //endregion\n\n    //region Settings\n\n    get showHeaderElements() {\n        return !this.client.hideHeaders && this._showHeaderElements;\n    }\n\n    updateShowHeaderElements(show) {\n        const { client } = this;\n\n        if (!this.isConfiguring) {\n            client.element.classList.toggle('b-sch-timeranges-with-headerelements', Boolean(show));\n\n            this.renderRanges();\n        }\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds menu items for the context menu, and may mutate the menu configuration.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ column, items }) {}\n\n    //endregion\n\n    //region Events & hooks\n\n    onPaint({ firstPaint }) {\n        if (firstPaint && this.client.isHorizontal) {\n            this.onUIReady();\n        }\n    }\n\n    onSchedulerHorizontalScroll() {\n        // Don't need a refresh, ranges are already available. Just need to draw those now in view\n        this.client.isHorizontal && this.renderRanges();\n    }\n\n    afterScroll() {\n        this.client.isVertical && this.renderRanges();\n    }\n\n    updateLineBuffer() {\n        const { timeAxisViewModel } = this.client;\n        // Lines have no duration, but we want them to be visible longer for the label to not suddenly disappear.\n        // We use a 300px buffer for that, recalculated as an amount of ms\n        this._lineBufferDurationMS = timeAxisViewModel.getDateFromPosition(300) - timeAxisViewModel.getDateFromPosition(0);\n    }\n\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        if (this.client.isVertical && oldHeight !== newHeight) {\n            this.renderRanges();\n        }\n    }\n\n    onTimeAxisViewModelUpdate() {\n        this.updateLineBuffer();\n\n        this.refresh();\n    }\n\n    onTimeRangeClick(event) {\n        const timeRangeRecord = this.resolveTimeRangeRecord(event.target);\n\n        this.client.trigger(`timeRangeHeader${StringHelper.capitalize(event.type)}`, { event, domEvent : event, timeRangeRecord });\n    }\n\n    //endregion\n\n    //region Drag drop\n\n    showTip(context) {\n        const me = this;\n\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n\n            me.tip = new Tooltip(ObjectHelper.assign({\n                id                       : `${me.client.id}-time-range-tip`,\n                cls                      : 'b-interaction-tooltip',\n                align                    : 'b-t',\n                autoShow                 : true,\n                updateContentOnMouseMove : true,\n                forElement               : context.element,\n                getHtml                  : () => me.getTipHtml(context.record, context.element)\n            }, me.showTooltip));\n        }\n    }\n\n    destroyTip() {\n        if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n    }\n\n    isElementDraggable(el) {\n        el = el.closest(this.baseSelector + ':not(.b-resizing):not(.b-readonly)');\n\n        return el && !el.classList.contains('b-over-resize-handle');\n    }\n\n    onDragStart({ context }) {\n        const { client, drag } = this;\n\n        if (client.isVertical) {\n            drag.minY = 0;\n            // Moving the range, you can drag the start marker down until the end of the range hits the time axis end\n            drag.maxY = client.timeAxisViewModel.totalSize - context.element.offsetHeight;\n            // Setting min/max for X makes drag right of the header valid, but visually still constrained vertically\n            drag.minX = 0;\n            drag.maxX = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            drag.minX = 0;\n            // Moving the range, you can drag the start marker right until the end of the range hits the time axis end\n            drag.maxX = client.timeAxisViewModel.totalSize - context.element.offsetWidth;\n            // Setting min/max for Y makes drag below header valid, but visually still constrained horizontally\n            drag.minY = 0;\n            drag.maxY = Number.MAX_SAFE_INTEGER;\n        }\n\n        client.element.classList.add('b-dragging-timerange');\n    }\n\n    onDrop({ context }) {\n        this.client.element.classList.remove('b-dragging-timerange');\n    }\n\n    onInvalidDrop() {\n        this.drag.reset();\n        this.client.element.classList.remove('b-dragging-timerange');\n\n        this.destroyTip();\n    }\n\n    onDrag() {}\n\n    onDragReset() {}\n\n    // endregion\n\n    // region Resize\n\n    onResizeStart() {}\n\n    onResizeDrag() {}\n\n    onResize() {}\n\n    onInvalidResize() {}\n\n    onResizeReset() {}\n\n    //endregion\n\n    //region Tooltip\n\n    /**\n     * Generates the html to display in the tooltip during drag drop.\n     *\n     */\n    getTipHtml(record, element) {\n        const\n            me         = this,\n            { client } = me,\n            box        = Rectangle.from(element),\n            startPos   = box.getStart(client.rtl, client.isHorizontal),\n            endPos     = box.getEnd(client.rtl, client.isHorizontal),\n            startDate  = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate    = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),\n            startText  = client.getFormattedDate(startDate),\n            endText    = endDate && client.getFormattedEndDate(endDate, startDate);\n\n        return me.dragTipTemplate({\n            name           : record.name || '',\n            startDate,\n            endDate,\n            startText,\n            endText,\n            startClockHtml : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : endText && me.clockTemplate.template({\n                date : endDate,\n                text : endText,\n                cls  : 'b-sch-tooltip-enddate'\n            })\n        });\n    }\n\n    //endregion\n}\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/feature/ColumnLines\n */\nconst emptyObject = Object.freeze({});\n\n/**\n * Displays column lines for ticks, with a different styling for major ticks (by default they are darker). If this\n * feature is disabled, no lines are shown. If it's enabled, line are shown for the tick level which is set in current\n * ViewPreset. Please see {@link Scheduler.preset.ViewPreset#field-columnLinesFor} config for details.\n *\n * The lines are drawn as divs, with only visible lines available in DOM. The color and style of the lines are\n * determined the css rules for `.b-column-line` and `.b-column-line-major`.\n *\n * For vertical mode, this features also draws vertical resource column lines if scheduler is configured with\n * `columnLines : true` (which is the default, see {@link Grid.view.GridBase#config-columnLines}).\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Delayable\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/ColumnLines.js\n * @classtype columnLines\n * @feature\n */\nexport default class ColumnLines extends InstancePlugin.mixin(AttachToProjectMixin, Delayable) {\n    //region Config\n\n    static get $name() {\n        return 'ColumnLines';\n    }\n\n    static get delayable() {\n        return {\n            refresh : {\n                type              : 'raf',\n                cancelOutstanding : true\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            after : ['render', 'updateCanvasSize', 'onVisibleDateRangeChange', 'onVisibleResourceRangeChange']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        client.useBackgroundCanvas = true;\n\n        super.construct(client, config);\n    }\n\n    attachToResourceStore(resourceStore) {\n        const { client } = this;\n\n        super.attachToResourceStore(resourceStore);\n\n        if (client.isVertical) {\n            client.resourceStore.ion({\n                name : 'resourceStore',\n                group({ groupers }) {\n                    if (groupers.length === 0) {\n                        this.refresh();\n                    }\n                },\n                thisObj : this\n            });\n        }\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Draw\n\n    /**\n     * Draw lines when scheduler/gantt is rendered.\n     * @private\n     */\n    render() {\n        this.refresh();\n    }\n\n    getColumnLinesDOMConfig(startDate, endDate) {\n        const\n            me               = this,\n            { client }       = me,\n            { rtl }          = client,\n            m                = rtl ? -1 : 1,\n            {\n                timeAxisViewModel,\n                isHorizontal,\n                resourceStore,\n                variableColumnWidths\n            }                = client,\n            { columnConfig } = timeAxisViewModel;\n\n        const\n            linesForLevel      = timeAxisViewModel.columnLinesFor,\n            majorLinesForLevel = Math.max(linesForLevel - 1, 0),\n            start              = startDate.getTime(),\n            end                = endDate.getTime(),\n            domConfigs         = [],\n            dates              = new Set(),\n            dimension          = isHorizontal ? 'X' : 'Y';\n\n        if (!me.disabled) {\n            const addLineConfig = (tick, isMajor) => {\n                const tickStart = tick.start.getTime();\n                // Only start of tick matters.\n                // Each tick has an exact calculated start position along the time axis\n                // and carries a border on its left, so column lines follow from\n                // tick 1 (zero-based) onwards.\n                if (tickStart > start && tickStart < end && !dates.has(tickStart)) {\n                    dates.add(tickStart);\n                    domConfigs.push({\n                        role      : 'presentation',\n                        className : isMajor ? 'b-column-line-major' : 'b-column-line',\n                        style     : {\n                            transform : `translate${dimension}(${tick.coord * m}px)`\n                        },\n                        dataset : {\n                            line : isMajor ? `major-${tick.index}` : `line-${tick.index}`\n                        }\n                    });\n                }\n            };\n\n            // Collect configs for major lines\n            if (linesForLevel !== majorLinesForLevel) {\n                for (let i = 1; i <= columnConfig[majorLinesForLevel].length - 1; i++) {\n                    addLineConfig(columnConfig[majorLinesForLevel][i], true);\n                }\n            }\n\n            // And normal lines, skipping dates already occupied by major lines\n            for (let i = 1; i <= columnConfig[linesForLevel].length - 1; i++) {\n                addLineConfig(columnConfig[linesForLevel][i], false);\n            }\n\n            // Add vertical resource column lines, if grid is configured to show column lines\n            if (!isHorizontal && client.columnLines) {\n                const\n                    { columnWidth } = client.resourceColumns;\n                let {\n                    first : firstResource,\n                    last  : lastResource\n                }               = client.currentOrientation.getResourceRange(true);\n\n                let nbrGroupHeaders = 0;\n\n                if (firstResource > -1) {\n                    for (let i = firstResource; i < lastResource + 1; i++) {\n                        const\n                            resourceRecord = resourceStore.getAt(i);\n\n                        // Only add lines for group children\n                        if (resourceRecord.isGroupHeader) {\n                            lastResource++;\n                            nbrGroupHeaders++;\n                            continue;\n                        }\n\n                        const\n                            instanceMeta = resourceRecord.instanceMeta(resourceStore),\n                            left         = variableColumnWidths ? instanceMeta.insetStart + resourceRecord.columnWidth - 1 : (i - nbrGroupHeaders + 1) * columnWidth - 1;\n\n                        domConfigs.push({\n                            className : {\n                                'b-column-line'            : 1,\n                                'b-resource-column-line'   : 1,\n                                'b-resource-group-divider' : resourceStore.isGrouped && instanceMeta.groupParent?.groupChildren[instanceMeta.groupParent?.groupChildren.length - 1] === resourceRecord\n                            },\n                            style : {\n                                transform : `translateX(${left * m}px)`\n                            },\n                            dataset : {\n                                line : `resource-${i}`\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        return domConfigs;\n    }\n\n    /**\n     * Draw column lines that are in view\n     * @private\n     */\n    refresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { timeAxis }           = client,\n            { startDate, endDate } = client.visibleDateRange || emptyObject,\n            axisStart              = timeAxis.startDate;\n\n        // Early bailout for timeaxis without start date or when starting with schedule collapsed\n        if (!axisStart || !startDate || me.client.timeAxisSubGrid.collapsed) {\n            return;\n        }\n\n        if (!me.element) {\n            me.element = DomHelper.createElement({\n                parent    : client.backgroundCanvas,\n                className : 'b-column-lines-canvas'\n            });\n        }\n\n        const domConfigs = me.getColumnLinesDOMConfig(startDate, endDate);\n\n        DomSync.sync({\n            targetElement : me.element,\n            onlyChildren  : true,\n            domConfig     : {\n                children    : domConfigs,\n                syncOptions : {\n                    // When zooming in and out we risk getting a lot of released lines if we do not limit it\n                    releaseThreshold : 4\n                }\n            },\n            syncIdField : 'line'\n        });\n    }\n\n    //endregion\n\n    //region Events\n\n    // Called when visible date range changes, for example from zooming, scrolling, resizing\n    onVisibleDateRangeChange() {\n        this.refresh();\n    }\n\n    // Called when visible resource range changes, for example on scroll and resize\n    onVisibleResourceRangeChange({ firstResource, lastResource }) {\n        this.refresh();\n    }\n\n    updateCanvasSize() {\n        this.refresh();\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt']);\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DependencyBaseModel from '../../model/DependencyBaseModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/feature/mixin/DependencyCreation\n */\n\n// <remove-on-release>\n// TODO: refactor this class using StateChart utility to be implemented in Core/util/StateChart.js or XState library if allowed to be used\n// </remove-on-release>\n\n/**\n * Mixin for Dependencies feature that handles dependency creation (drag & drop from terminals which are shown on hover).\n * Requires {@link Core.mixin.Delayable} to be mixed in alongside.\n *\n * @mixin\n */\nexport default Target => class DependencyCreation extends (Target || Base) {\n    static get $name() {\n        return 'DependencyCreation';\n    }\n\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            /**\n             * `false` to require a drop on a target event bar side circle to define the dependency type.\n             * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n             * determine the target task side.\n             *\n             * @member {Boolean} allowDropOnEventBar\n             */\n            /**\n             * `false` to require a drop on a target event bar side circle to define the dependency type.\n             * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n             * determine the target task side.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            allowDropOnEventBar : true,\n\n            /**\n             * `false` to not show a tooltip while creating a dependency\n             * @config {Boolean}\n             * @default\n             */\n            showCreationTooltip : true,\n\n            /**\n             * A tooltip config object that will be applied to the dependency creation {@link Core.widget.Tooltip}\n             * @config {TooltipConfig}\n             */\n            creationTooltip : null,\n\n            /**\n             * A template function that will be called to generate the HTML contents of the dependency creation tooltip.\n             * You can return either an HTML string or a {@link DomConfig} object.\n             * @prp {Function} creationTooltipTemplate\n             * @param {Object} data Data about the dependency being created\n             * @param {Scheduler.model.TimeSpan} data.source The from event\n             * @param {Scheduler.model.TimeSpan} data.target The target event\n             * @param {String} data.fromSide The from side (start, end, top, bottom)\n             * @param {String} data.toSide The target side (start, end, top, bottom)\n             * @param {Boolean} data.valid The validity of the dependency\n             * @returns {String|DomConfig}\n             */\n\n            /**\n             * CSS class used for terminals\n             * @config {String}\n             * @default\n             */\n            terminalCls : 'b-sch-terminal',\n\n            /**\n             * Where (on event bar edges) to display terminals. The sides are `'start'`, `'top'`,\n             * `'end'` and `'bottom'`\n             * @config {String[]}\n             */\n            terminalSides : ['start', 'top', 'end', 'bottom'],\n\n            /**\n             * Set to `false` to not allow creating dependencies\n             * @config {Boolean}\n             * @default\n             */\n            allowCreate : true\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(view, config) {\n        super.construct(view, config);\n\n        const me = this;\n\n        me.view = view;\n        me.eventName = view.scheduledEventName;\n\n        view.ion({ readOnly : () => me.updateCreateListeners() });\n\n        me.updateCreateListeners();\n\n        me.chain(view, 'onElementTouchMove', 'onElementTouchMove');\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners('view');\n\n        me.creationData = null;\n\n        me.pointerUpMoveDetacher?.();\n        me.creationTooltip?.destroy();\n\n        super.doDestroy();\n    }\n\n    updateCreateListeners() {\n        const me = this;\n\n        if (!me.view) {\n            return;\n        }\n\n        me.detachListeners('view');\n\n        if (me.isCreateAllowed) {\n            me.view.ion({\n                name                          : 'view',\n                [`${me.eventName}mouseenter`] : 'onTimeSpanMouseEnter',\n                [`${me.eventName}mouseleave`] : 'onTimeSpanMouseLeave',\n                thisObj                       : me\n            });\n        }\n    }\n\n    set allowCreate(value) {\n        this._allowCreate = value;\n\n        this.updateCreateListeners();\n    }\n\n    get allowCreate() {\n        return this._allowCreate;\n    }\n\n    get isCreateAllowed() {\n        return this.allowCreate && !this.view.readOnly && !this.disabled;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Show terminals when mouse enters event/task element\n     * @private\n     */\n    onTimeSpanMouseEnter({\n        event, source, [`${this.eventName}Record`]: record, [`${this.eventName}Element`]: element\n    }) {\n        if (!record.isCreating && !record.readOnly && (!this.client.features.nestedEvents || record.parent.isRoot)) {\n            const\n                me               = this,\n                { creationData } = me,\n                eventBarElement  = DomHelper.down(element, source.eventInnerSelector);\n\n            // When we enter a different event than the one we started on\n            if (record !== creationData?.source) {\n                me.showTerminals(record, eventBarElement);\n\n                if (creationData && event.target.closest(me.client.eventSelector)) {\n                    creationData.timeSpanElement = eventBarElement;\n                    me.onOverTargetEventBar(event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Hide terminals when mouse leaves event/task element\n     * @private\n     */\n    onTimeSpanMouseLeave(event) {\n        const\n            me               = this,\n            { creationData } = me,\n            element          = event[`${me.eventName}Element`],\n            timeSpanLeft     = DomHelper.down(element, me.view.eventInnerSelector),\n            target           = event.event?.relatedTarget,\n            timeSpanElement  = creationData?.timeSpanElement;\n\n        // Can happen when unhovering an occurrence during update\n        if (!target) {\n            return;\n        }\n\n        if (!creationData || !timeSpanElement || !target || !DomHelper.isDescendant(timeSpanElement, target)) {\n            // We cannot hide the terminals for non-trusted events because non-trusted means it's\n            // synthesized from a touchmove event and if the source element of a touchmove\n            // leaves the DOM, the touch gesture is ended.\n            if (event.event.isTrusted || (timeSpanLeft !== creationData?.sourceElement)) {\n                me.hideTerminals(element);\n            }\n        }\n\n        if (creationData && !creationData.finalizing) {\n            creationData.timeSpanElement = null;\n            me.onOverNewTargetWhileCreating(undefined, undefined, event);\n        }\n    }\n\n    onTerminalMouseOver(event) {\n        if (this.creationData) {\n            this.onOverTargetEventBar(event);\n        }\n    }\n\n    /**\n     * Remove hover styling when mouse leaves terminal. Also hides terminals when mouse leaves one it and not creating a\n     * dependency.\n     * @private\n     */\n    onTerminalMouseOut(event) {\n        const\n            me               = this,\n            { creationData } = me,\n            eventElement     = event.target.closest(me.view.eventSelector);\n\n        if (eventElement && (!me.showingTerminalsFor || !DomHelper.isDescendant(eventElement, me.showingTerminalsFor)) && (!creationData || eventElement !== creationData.timeSpanElement)) {\n            me.hideTerminals(eventElement);\n            me.view.unhover(eventElement, event);\n        }\n\n        if (creationData) {\n            me.onOverNewTargetWhileCreating(event.relatedTarget, creationData.target, event);\n        }\n    }\n\n    /**\n     * Start creating a dependency when mouse is pressed over terminal\n     * @private\n     */\n    onTerminalPointerDown(event) {\n        const me = this;\n\n        // ignore non-left button clicks\n        if (event.button === 0 && !me.creationData) {\n            const\n                scheduler              = me.view,\n                timeAxisSubGridElement = scheduler.timeAxisSubGridElement,\n                terminalNode           = event.target,\n                timeSpanElement        = terminalNode.closest(scheduler.eventInnerSelector),\n                viewBounds             = Rectangle.from(scheduler.element, document.body);\n\n            event.stopPropagation();\n\n            me.creationData = {\n                sourceElement  : timeSpanElement,\n                source         : scheduler.resolveTimeSpanRecord(timeSpanElement).$original,\n                fromSide       : terminalNode.dataset.side,\n                startPoint     : Rectangle.from(terminalNode, timeAxisSubGridElement).center,\n                startX         : event.pageX - viewBounds.x + scheduler.scrollLeft,\n                startY         : event.pageY - viewBounds.y + scheduler.scrollTop,\n                valid          : false,\n                sourceResource : scheduler.resolveResourceRecord?.(event),\n                tooltip        : me.creationTooltip\n            };\n\n            me.pointerUpMoveDetacher = EventHelper.on({\n                pointerup : {\n                    element : scheduler.element.getRootNode(),\n                    handler : 'onMouseUp',\n                    passive : false\n                },\n                pointermove : {\n                    element : timeAxisSubGridElement,\n                    handler : 'onMouseMove',\n                    passive : false\n                },\n                thisObj : me\n            });\n\n            // If root element is anything but Document (it could be Document Fragment or regular Node in case of LWC)\n            // then we should also add listener to document to cancel dependency creation\n            me.documentPointerUpDetacher = EventHelper.on({\n                pointerup : {\n                    element : document,\n                    handler : 'onDocumentMouseUp'\n                },\n                keydown : {\n                    element : document,\n                    handler : ({ key }) => {\n                        if (key === 'Escape') {\n                            me.abort();\n                        }\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    onElementTouchMove(event) {\n        super.onElementTouchMove?.(event);\n\n        if (this.connector) {\n            // Prevent touch scrolling while dragging a connector\n            event.preventDefault();\n        }\n    }\n\n    /**\n     * Update connector line showing dependency between source and target when mouse moves. Also check if mouse is over\n     * a valid target terminal\n     * @private\n     */\n    onMouseMove(event) {\n        const\n            me                            = this,\n            { view, creationData : data } = me,\n            viewBounds                    = Rectangle.from(view.element, document.body),\n            deltaX                        = (event.pageX - viewBounds.x + view.scrollLeft) - data.startX,\n            deltaY                        = (event.pageY - viewBounds.y + view.scrollTop) - data.startY,\n            length                        = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,\n            angle                         = Math.atan2(deltaY, deltaX);\n\n        let { connector } = me;\n\n        if (!connector) {\n            if (me.onRequestDragCreate(event) === false) {\n                return;\n            }\n            connector = me.connector;\n        }\n\n        connector.style.width     = `${length}px`;\n        connector.style.transform = `rotate(${angle}rad)`;\n\n        me.lastMouseMoveEvent = event;\n    }\n\n    onRequestDragCreate(event) {\n        const\n            me                            = this,\n            { view, creationData : data } = me;\n\n        /**\n         * Fired on the owning Scheduler/Gantt before a dependency creation drag operation starts. Return `false` to\n         * prevent it\n         * @event beforeDependencyCreateDrag\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        if (view.trigger('beforeDependencyCreateDrag', { data, source : data.source }) === false) {\n            me.abort();\n            return false;\n        }\n\n        view.element.classList.add('b-creating-dependency');\n\n        me.createConnector(data.startPoint.x, data.startPoint.y);\n\n        /**\n         * Fired on the owning Scheduler/Gantt when a dependency creation drag operation starts\n         * @event dependencyCreateDragStart\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        view.trigger('dependencyCreateDragStart', { data, source : data.source  });\n\n        if (me.showCreationTooltip) {\n            const tip = me.creationTooltip || (me.creationTooltip = me.createDragTooltip());\n\n            me.creationData.tooltip = tip;\n\n            tip.disabled = false;\n            tip.show();\n\n            tip.onMouseMove(event);\n        }\n\n        view.scrollManager.startMonitoring({\n            scrollables : [\n                {\n                    element   : view.timeAxisSubGrid.scrollable.element,\n                    direction : 'horizontal'\n                },\n                {\n                    element   : view.scrollable.element,\n                    direction : 'vertical'\n                }\n            ],\n            callback : () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent)\n        });\n    }\n\n    onOverTargetEventBar(event) {\n        const\n            me                                                = this,\n            { view, creationData: data, allowDropOnEventBar } = me,\n            { target }                                        = event;\n\n        let overEventRecord = view.resolveTimeSpanRecord(target).$original;\n\n        // use main event if a segment resolved\n        if (overEventRecord?.isEventSegment) {\n            overEventRecord = overEventRecord.event;\n        }\n\n        if (Objects.isPromise(data.valid) || (!allowDropOnEventBar && !target.classList.contains(me.terminalCls))) {\n            return;\n        }\n\n        if (overEventRecord !== data.source) {\n            me.onOverNewTargetWhileCreating(target, overEventRecord, event);\n        }\n    }\n\n    async onOverNewTargetWhileCreating(targetElement, overEventRecord, event) {\n        const\n            me                                                            = this,\n            { view, creationData : data, allowDropOnEventBar, connector } = me;\n\n        if (Objects.isPromise(data.valid)) {\n            return;\n        }\n\n        // stop target updating if dependency finalizing in progress\n        if (data.finalizing) {\n            return;\n        }\n\n        // Connector might not exist at this point because `pointerout` on the terminal might fire before `pointermove`\n        // on the time axis subgrid. This is difficult to reproduce, so shouldn't be triggered often.\n        // https://github.com/bryntum/support/issues/3116#issuecomment-894256799\n        if (!connector) {\n            return;\n        }\n\n        connector.classList.remove('b-valid', 'b-invalid');\n        data.timeSpanElement && DomHelper.removeClsGlobally(data.timeSpanElement, 'b-sch-terminal-active');\n\n        if (!overEventRecord || overEventRecord === data.source || (!allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls))) {\n            data.target = data.toSide = null;\n            data.valid = false;\n            connector.classList.add('b-invalid');\n        }\n        else {\n            const\n                target     = data.target = overEventRecord,\n                { source } = data;\n\n            let toSide  = targetElement.dataset.side;\n\n            // If we allow dropping anywhere on a task, resolve target side based on the default type of the\n            // dependency model used\n            if (allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls)) {\n                toSide = me.getTargetSideFromType(me.dependencyStore.modelClass.fieldMap.type.defaultValue || DependencyBaseModel.Type.EndToStart);\n            }\n\n            if (view.resolveResourceRecord) {\n                data.targetResource = view.resolveResourceRecord(event);\n            }\n\n            let dependencyType;\n\n            data.toSide = toSide;\n\n            const\n                fromSide       = data.fromSide,\n                updateValidity = valid => {\n                    if (!me.isDestroyed) {\n                        data.valid = valid;\n                        targetElement.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        connector.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        /**\n                         * Fired on the owning Scheduler/Gantt when asynchronous dependency validation completes\n                         * @event dependencyValidationComplete\n                         * @on-owner\n                         * @param {Scheduler.model.TimeSpan} source The source task\n                         * @param {Scheduler.model.TimeSpan} target The target task\n                         * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n                         */\n                        view.trigger('dependencyValidationComplete', {\n                            data,\n                            source,\n                            target,\n                            dependencyType\n                        });\n                    }\n                };\n\n            // NOTE: Top/Bottom sides are not taken into account due to\n            //       scheduler doesn't check for type value anyway, whereas\n            //       gantt will reject any other dependency types undefined in\n            //       DependencyBaseModel.Type enumeration.\n            switch (true) {\n                case fromSide === 'start' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.StartToStart;\n                    break;\n                case fromSide === 'start' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.StartToEnd;\n                    break;\n                case fromSide === 'end' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.EndToStart;\n                    break;\n                case fromSide === 'end' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.EndToEnd;\n                    break;\n            }\n\n            /**\n             * Fired on the owning Scheduler/Gantt when asynchronous dependency validation starts\n             * @event dependencyValidationStart\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n             */\n            view.trigger('dependencyValidationStart', {\n                data,\n                source,\n                target,\n                dependencyType\n            });\n\n            let valid = data.valid = me.dependencyStore.isValidDependency(source, target, dependencyType);\n\n            // Promise is returned when using the engine\n            if (Objects.isPromise(valid)) {\n                valid = await valid;\n                updateValidity(valid);\n            }\n            else {\n                updateValidity(valid);\n            }\n\n            const validityCls = valid ? 'b-valid' : 'b-invalid';\n            connector.classList.add(validityCls);\n            data.timeSpanElement?.querySelector(`.b-sch-terminal[data-side=${toSide}]`)?.classList.add('b-sch-terminal-active', validityCls);\n        }\n\n        me.updateCreationTooltip();\n    }\n\n    /**\n     * Create a new dependency if mouse release over valid terminal. Hides connector\n     * @private\n     */\n    async onMouseUp() {\n        const\n            me   = this,\n            data = me.creationData;\n\n        data.finalizing = true;\n        me.pointerUpMoveDetacher?.();\n\n        if (data.valid) {\n            /**\n             * Fired on the owning Scheduler/Gantt when a dependency drag creation operation is about to finalize\n             *\n             * @event beforeDependencyCreateFinalize\n             * @on-owner\n             * @preventable\n             * @async\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {'start'|'end'|'top'|'bottom'} fromSide The from side (start / end / top / bottom)\n             * @param {'start'|'end'|'top'|'bottom'} toSide The to side (start / end / top / bottom)\n             */\n            const result = await me.view.trigger('beforeDependencyCreateFinalize', data);\n\n            if (result === false) {\n                data.valid = false;\n            }\n            // Await any async validation logic before continuing\n            else if (Objects.isPromise(data.valid)) {\n                data.valid = await data.valid;\n            }\n\n            if (data.valid) {\n                let dependency = me.createDependency(data);\n\n                if (dependency !== null) {\n                    if (Objects.isPromise(dependency)) {\n                        dependency = await dependency;\n                    }\n\n                    data.dependency = dependency;\n\n                    /**\n                     * Fired on the owning Scheduler/Gantt when a dependency drag creation operation succeeds\n                     * @event dependencyCreateDrop\n                     * @on-owner\n                     * @param {Scheduler.model.TimeSpan} source The source task\n                     * @param {Scheduler.model.TimeSpan} target The target task\n                     * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n                     */\n                    me.view.trigger('dependencyCreateDrop', { data, source : data.source, target : data.target, dependency });\n                    me.doAfterDependencyDrop(data);\n                }\n            }\n            else {\n                me.doAfterDependencyDrop(data);\n            }\n        }\n        else {\n            data.valid = false;\n            me.doAfterDependencyDrop(data);\n        }\n\n        me.abort();\n    }\n\n    doAfterDependencyDrop(data) {\n        /**\n         * Fired on the owning Scheduler/Gantt after a dependency drag creation operation finished, no matter to outcome\n         * @event afterDependencyCreateDrop\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         * @param {Scheduler.model.TimeSpan} target The target task\n         * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n         */\n        this.view.trigger('afterDependencyCreateDrop', {\n            data,\n            ...data\n        });\n    }\n\n    onDocumentMouseUp({ target }) {\n        if (!this.view.timeAxisSubGridElement.contains(target)) {\n            this.abort();\n        }\n    }\n\n    /**\n     * Aborts dependency creation, removes proxy and cleans up listeners\n     */\n    abort() {\n        const\n            me                     = this,\n            { view, creationData } = me;\n\n        // Remove terminals from source and target events.\n        if (creationData) {\n            const { source, sourceResource, target, targetResource } = creationData;\n\n            if (source) {\n                const el = view.getElementFromEventRecord(source, sourceResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n            if (target) {\n                const el = view.getElementFromEventRecord(target, targetResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n        }\n\n        if (me.creationTooltip) {\n            me.creationTooltip.disabled = true;\n        }\n\n        me.creationData = me.lastMouseMoveEvent = null;\n\n        me.pointerUpMoveDetacher?.();\n\n        me.documentPointerUpDetacher?.();\n\n        me.removeConnector();\n    }\n\n    //endregion\n\n    //region Connector\n\n    /**\n     * Creates a connector line that visualizes dependency source & target\n     * @private\n     */\n    createConnector(x, y) {\n        const\n            me       = this,\n            { view } = me;\n\n        me.clearTimeout(me.removeConnectorTimeout);\n        me.connector = DomHelper.createElement({\n            parent    : view.timeAxisSubGridElement,\n            className : `${me.baseCls}-connector`,\n            style     : `left:${x}px;top:${y}px`\n        });\n\n        view.element.classList.add('b-creating-dependency');\n    }\n\n    createDragTooltip() {\n        const\n            me       = this,\n            { view } = me;\n\n        return me.creationTooltip = Tooltip.new({\n            id             : `${view.id}-dependency-drag-tip`,\n            cls            : 'b-sch-dependency-creation-tooltip',\n            loadingMsg     : '',\n            anchorToTarget : false,\n            // Keep tip visible until drag drop operation is finalized\n            forElement     : view.timeAxisSubGridElement,\n            trackMouse     : true,\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            constrainTo    : null,\n\n            header : {\n                dock : 'right'\n            },\n\n            internalListeners : {\n                // Show initial content immediately\n                beforeShow : 'updateCreationTooltip',\n                thisObj    : me\n            }\n        }, me.creationTooltip);\n    }\n\n    /**\n     * Remove connector\n     * @private\n     */\n    removeConnector() {\n        const\n            me                  = this,\n            { connector, view } = me;\n\n        if (connector) {\n            connector.classList.add('b-removing');\n            connector.style.width = '0';\n            me.removeConnectorTimeout = me.setTimeout(() => {\n                connector.remove();\n                me.connector = null;\n            }, 200);\n        }\n\n        view.element.classList.remove('b-creating-dependency');\n        me.creationTooltip && me.creationTooltip.hide();\n\n        view.scrollManager.stopMonitoring();\n    }\n\n    //endregion\n\n    //region Terminals\n\n    /**\n     * Show terminals for specified event at sides defined in #terminalSides.\n     * @param {Scheduler.model.TimeSpan} timeSpanRecord Event/task to show terminals for\n     * @param {HTMLElement} element Event/task element\n     */\n    showTerminals(timeSpanRecord, element) {\n        const me = this;\n\n        // Record not part of project is a transient record in a display store, not meant to be manipulated\n        if (!me.isCreateAllowed || !timeSpanRecord.project) {\n            return;\n        }\n\n        const\n            cls                 = me.terminalCls,\n            terminalsVisibleCls = `${cls}s-visible`;\n\n        // We operate on the event bar, not the wrap\n        element = DomHelper.down(element, me.view.eventInnerSelector);\n\n        // bail out if terminals already shown or if view is readonly\n        // do not draw new terminals if we are resizing event\n        if (!element.classList.contains(terminalsVisibleCls) && !me.view.element.classList.contains('b-resizing-event') && !me.view.readOnly) {\n            /**\n             * Fired on the owning Scheduler/Gantt before showing dependency terminals on a task or event. Return `false` to\n             * prevent it\n             * @event beforeShowTerminals\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The hovered task\n             */\n            if (me.client.trigger('beforeShowTerminals', { source : timeSpanRecord }) === false) {\n                return;\n            }\n\n            // create terminals for desired sides\n            me.terminalSides.forEach(side => {\n                // Allow code to use left for the start side and right for the end side\n                side = me.fixSide(side);\n\n                const terminal = DomHelper.createElement({\n                    parent    : element,\n                    className : `${cls} ${cls}-${side}`,\n                    dataset   : {\n                        side,\n                        feature : true\n                    }\n                });\n\n                terminal.detacher = EventHelper.on({\n                    element     : terminal,\n                    mouseover   : 'onTerminalMouseOver',\n                    mouseout    : 'onTerminalMouseOut',\n                    // Needs to be pointerdown to match DragHelper, otherwise will be preventing wrong event\n                    pointerdown : {\n                        handler : 'onTerminalPointerDown',\n                        capture : true\n                    },\n                    thisObj : me\n                });\n            });\n\n            element.classList.add(terminalsVisibleCls);\n            timeSpanRecord.internalCls.add(terminalsVisibleCls);\n\n            me.showingTerminalsFor = element;\n        }\n    }\n\n    fixSide(side) {\n        if (side === 'left') {\n            return 'start';\n        }\n        if (side === 'right') {\n            return 'end';\n        }\n        return side;\n    }\n\n    /**\n     * Hide terminals for specified event\n     * @param {HTMLElement} eventElement Event element\n     */\n    hideTerminals(eventElement) {\n        // remove all terminals\n        const\n            me                  = this,\n            eventParams         = me.client.getTimeSpanMouseEventParams(eventElement),\n            timeSpanRecord      = eventParams?.[`${me.eventName}Record`],\n            terminalsVisibleCls = `${me.terminalCls}s-visible`;\n\n        DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, terminal => {\n            terminal.detacher && terminal.detacher();\n            terminal.remove();\n        });\n\n        DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);\n        timeSpanRecord.internalCls.remove(terminalsVisibleCls);\n\n        me.showingTerminalsFor = null;\n    }\n\n    //endregion\n\n    //region Dependency creation\n\n    /**\n     * Create a new dependency from source terminal to target terminal\n     * @internal\n     */\n    createDependency(data) {\n        const\n            { source, target, fromSide, toSide } = data,\n            type                                 = (fromSide === 'start' ? 0 : 2) + (toSide === 'end' ? 1 : 0);\n\n        const newDependency = this.dependencyStore.add({\n            from : source.id,\n            to   : target.id,\n            type,\n            fromSide,\n            toSide\n        });\n\n        return newDependency !== null ? newDependency[0] : null;\n    }\n\n    getTargetSideFromType(type) {\n        if (type === DependencyBaseModel.Type.StartToStart || type === DependencyBaseModel.Type.EndToStart) {\n            return 'start';\n        }\n\n        return 'end';\n    }\n\n    //endregion\n\n    //region Tooltip\n\n    /**\n     * Update dependency creation tooltip\n     * @private\n     */\n    updateCreationTooltip() {\n        const\n            me            = this,\n            data          = me.creationData,\n            { valid }     = data,\n            tip           = me.creationTooltip,\n            { classList } = tip.element;\n\n        // Promise, when using engine\n        if (Objects.isPromise(valid)) {\n            classList.remove('b-invalid');\n            classList.add('b-checking');\n\n            return new Promise(resolve => valid.then(valid => {\n                data.valid = valid;\n\n                if (!tip.isDestroyed) {\n                    resolve(me.updateCreationTooltip());\n                }\n            }));\n        }\n\n        tip.html = me.creationTooltipTemplate(data);\n    }\n\n    creationTooltipTemplate(data) {\n        const\n            me                 = this,\n            { tooltip, valid } = data,\n            { classList }      = tooltip.element;\n\n        Object.assign(data, {\n            fromText : StringHelper.encodeHtml(data.source.name),\n            toText   : StringHelper.encodeHtml(data.target?.name ?? ''),\n            fromSide : data.fromSide,\n            toSide   : data.toSide || ''\n        });\n\n        let tipTitleIconClsSuffix,\n            tipTitleText;\n\n        classList.toggle('b-invalid', !valid);\n        classList.remove('b-checking');\n\n        // Valid\n        if (valid === true) {\n            tipTitleIconClsSuffix = 'valid';\n            tipTitleText          = me.L('L{Dependencies.valid}');\n        }\n        // Invalid\n        else {\n            tipTitleIconClsSuffix = 'invalid';\n            tipTitleText          = me.L('L{Dependencies.invalid}');\n        }\n\n        tooltip.title = `<i class=\"b-icon b-icon-${tipTitleIconClsSuffix}\"></i>${tipTitleText}`;\n\n        return {\n            children : [{\n                className : 'b-sch-dependency-tooltip',\n                children  : [\n                    { dataset : { ref : 'fromLabel' }, tag : 'label', text : me.L('L{Dependencies.from}') },\n                    { dataset : { ref : 'fromText' }, text : data.fromText },\n                    { dataset : { ref : 'fromBox' }, className : `b-sch-box b-${data.fromSide}` },\n                    { dataset : { ref : 'toLabel' }, tag : 'label', text : me.L('L{Dependencies.to}') },\n                    { dataset : { ref : 'toText' }, text : data.toText },\n                    { dataset : { ref : 'toBox' }, className : `b-sch-box b-${data.toSide}` }\n                ]\n            }]\n        };\n    }\n\n    //endregion\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            this.updateCreateListeners();\n        }\n\n        super.doDisable(disable);\n    }\n};\n", "// <remove-on-release>\n// TODO: Consider basing on visible row count\n// </remove-on-release>\nconst ROWS_PER_CELL = 25;\n\n// Mixin that handles the dependency grid cache\n//\n// Grid cache explainer\n// ────────────────────\n// The purpose of the grid cache is to reduce the amount of dependencies we have to iterate over when drawing by\n// partitioning them into a virtual grid. With for example 10k deps we would have to iterate over all 10k on\n// each draw since any of them might be intersecting the view.\n//\n// The cells are horizontally based on ticks (50 per cell) and vertically on rows (also 50 per cell. Each cell\n// lists which dependencies intersect it. When drawing we only have to iterate over the dependencies for the\n// cells that intersect the viewport.\n//\n// The grid cache is populated when dependencies are drawn. Any change to deps, resources, events or assignments\n// clears the cache.\n//\n// The dependency drawn below will be included in the set that is considered for drawing if tickCell 0 or\n// tickCell 1 and rowCell 0 intersects the current view (it is thus represented twice in the grid cache)\n//\n//       tickCell 0           tickCell 1\n//       tick 0-49            tick 50-99\n//    ┌────────────────────┬─────────────────────┐\n// r r│0,0                 │1,0                  │\n// o o│     │              │                     │\n// w w│     │     !!!!!!!!!│!!!!!!!!!!!          │\n// C  │     │     ! View   │          !          │\n// e 0│     │     ! port   │          !          │\n// l -│     │     !        │          !          │\n// l 4│     └─────!────────┼──────────!────►     │\n// 0 9│           !        │          !          │\n//    ├────────────────────┼─────────────────────┤\n// r r│0,1        !        │1,1       !          │\n// o o│           !        │          !          │\n// w w│           !!!!!!!!!│!!!!!!!!!!!          │\n// C  │                    │                     │\n// e 5│                    │                     │\n// l 0│                    │                     │\n// l -│                    │                     │\n// 1 9│                    │                     │\n//   9└────────────────────┴─────────────────────┘\n//               uoᴉʇɐɹʇsnꞁꞁᴉ əɥɔɐɔ pᴉɹ⅁\nexport default Target => class DependencyGridCache extends Target {\n    static $name = 'DependencyGridCache';\n\n    gridCache = null;\n\n    // Dependencies that might intersect the current viewport and thus should be considered for drawing\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        const\n            me            = this,\n            { gridCache } = me,\n            { timeAxis }  = me.client;\n\n        if (gridCache) {\n            const\n                dependencies = new Set(),\n                fromMSCell   = Math.floor((startMS - timeAxis.startMS) / me.MS_PER_CELL),\n                toMSCell     = Math.floor((endMS - timeAxis.startMS) / me.MS_PER_CELL),\n                fromRowCell  = Math.floor(startIndex / ROWS_PER_CELL),\n                toRowCell    = Math.floor(endIndex / ROWS_PER_CELL);\n\n            for (let i = fromMSCell; i <= toMSCell; i++) {\n                const msCell = gridCache[i];\n                if (msCell) {\n                    for (let j = fromRowCell; j <= toRowCell; j++) {\n                        const intersectingDependencies = msCell[j];\n                        if (intersectingDependencies) {\n                            for (let i = 0; i < intersectingDependencies.length; i++) {\n                                dependencies.add(intersectingDependencies[i]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return dependencies;\n        }\n    }\n\n    // A (single) dependency was drawn, we might want to store info about it in the grid cache\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        const me = this;\n\n        if (me.constructGridCache) {\n            const\n                { MS_PER_CELL } = me,\n                {\n                    startMS : timeAxisStartMS,\n                    endMS   : timeAxisEndMS\n                }               = me.client.timeAxis,\n                timeAxisCells   = Math.ceil((timeAxisEndMS - timeAxisStartMS) / MS_PER_CELL),\n                fromMSCell      = Math.floor((fromDateMS - timeAxisStartMS) / MS_PER_CELL),\n                toMSCell        = Math.floor((toDateMS - timeAxisStartMS) / MS_PER_CELL),\n                fromRowCell     = Math.floor(fromIndex / ROWS_PER_CELL),\n                toRowCell       = Math.floor(toIndex / ROWS_PER_CELL),\n                firstMSCell     = Math.min(fromMSCell, toMSCell),\n                lastMSCell      = Math.max(fromMSCell, toMSCell),\n                firstRowCell    = Math.min(fromRowCell, toRowCell),\n                lastRowCell     = Math.max(fromRowCell, toRowCell);\n\n            // Ignore dependencies fully outside of the time axis\n            if ((firstMSCell < 0 && lastMSCell < 0) || (firstMSCell > timeAxisCells && lastMSCell > timeAxisCells)) {\n                return;\n            }\n\n            // Cache from time axis start, to time axis end (\"cropping\" deps starting or ending outside)\n            const\n                startMSCell = Math.max(firstMSCell, 0),\n                endMSCell   = Math.min(lastMSCell, timeAxisCells);\n\n            for (let i = startMSCell; i <= endMSCell; i++) {\n                const msCell = me.gridCache[i] ?? (me.gridCache[i] = {});\n                for (let j = firstRowCell; j <= lastRowCell; j++) {\n                    const rowCell = msCell[j] ?? (msCell[j] = []);\n                    rowCell.push(dependency);\n                }\n            }\n        }\n    }\n\n    // All dependencies are about to be drawn, check if we need to build the grid cache\n    beforeDraw() {\n        const me = this;\n\n        if (!me.gridCache) {\n            const { visibleDateRange } = me.client;\n\n            me.constructGridCache = true;\n\n            // Adjust number of ms used in grid cache to match viewport\n            me.MS_PER_CELL = Math.max(visibleDateRange.endMS - visibleDateRange.startMS, 1000);\n\n            // Start with empty cache, will be populated as deps are drawn\n            me.gridCache = {};\n        }\n    }\n\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        this.constructGridCache = false;\n    }\n\n    reset() {\n        this.gridCache = null;\n    }\n};\n", "import Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport WalkHelper from '../../Core/helper/WalkHelper.js';\n\n// Start adjusting if there is system scaling > 130%\nconst\n    THRESHOLD      = Math.min(1 / globalThis.devicePixelRatio, 0.75),\n    BOX_PROPERTIES = ['start', 'end', 'top', 'bottom'],\n    equalEnough    = (a, b) => Math.abs(a - b) < 0.1,\n    sideToSide     = {\n        l : 'left',\n        r : 'right',\n        t : 'top',\n        b : 'bottom'\n    };\n\n/**\n * @module Scheduler/util/RectangularPathFinder\n */\n\n/**\n * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.\n * @private\n */\nexport default class RectangularPathFinder extends Base {\n    static get configurable() {\n        return {\n            /**\n             * Default start connection side: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            startSide : 'right',\n\n            // /**\n            //  * Default start arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // startArrowSize : 0,\n\n            /**\n             * Default start arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            startArrowMargin : 12,\n\n            /**\n             * Default starting connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            startShift : 0,\n\n            /**\n             * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            endSide : 'left',\n\n            // /**\n            //  * Default end arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // endArrowSize : 0,\n\n            /**\n             * Default end arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            endArrowMargin : 12,\n\n            /**\n             * Default ending connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            endShift : 0,\n\n            /**\n             * Start / End box vertical margin, the amount of pixels from top and bottom line of a box where drawing\n             * is prohibited\n             * @config {Number}\n             * @default\n             */\n            verticalMargin : 2,\n\n            /**\n             * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing\n             * @config {Number}\n             * @default\n             */\n            horizontalMargin : 5,\n\n            /**\n             * Other rectangular areas (obstacles) to search path through\n             * @config {Object[]}\n             * @default\n             */\n            otherBoxes : null,\n\n            /**\n             * The owning Scheduler. Mandatory so that it can determin RTL state.\n             * @config {Scheduler.view.Scheduler}\n             * @private\n             */\n            client : {}\n        };\n    }\n\n    /**\n     * Returns list of horizontal and vertical segments connecting two boxes\n     * <pre>\n     *    |    | |  |    |       |\n     *  --+----+----+----*-------*---\n     *  --+=>Start  +----*-------*--\n     *  --+----+----+----*-------*--\n     *    |    | |  |    |       |\n     *    |    | |  |    |       |\n     *  --*----*-+-------+-------+--\n     *  --*----*-+         End <=+--\n     *  --*----*-+-------+-------+--\n     *    |    | |  |    |       |\n     * </pre>\n     * Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical\n     * margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds\n     * the shortest path with minimum amount of turns. In short it's mix of \"Lee\" and \"Dijkstra pathfinding\"\n     * with turns amount taken into account for distance calculation.\n     *\n     * The algorithm is not very performant though, it's O(N^2), where N is amount of\n     * points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since\n     * two box middle points are not permitted) that might be ok for now.\n     *\n     * @param {Object} lineDef An object containing any of the class configuration option overrides as well\n     *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,\n     *                         `endHorizontalMargin`, `endVerticalMargin` properties\n     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box\n     * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box\n     * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box\n     * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box\n     *\n     *\n     * @returns {Object[]|Boolean} Array of line segments or false if path cannot be found\n     * @returns {Number} return.x1\n     * @returns {Number} return.y1\n     * @returns {Number} return.x2\n     * @returns {Number} return.y2\n     */\n    //\n    //@ignore\n    //@privateparam {Function[]|Function} noPathFallbackFn\n    //     A function or array of functions which will be tried in case a path can't be found\n    //     Each function will be given a line definition it might try to adjust somehow and return.\n    //     The new line definition returned will be tried to find a path.\n    //     If a function returns false, then next function will be called if any.\n    //\n    findPath(lineDef, noPathFallbackFn) {\n        const\n            me              = this,\n            originalLineDef = lineDef;\n\n        let lineDefFull,\n            startBox,\n            endBox,\n            startShift,\n            endShift,\n            startSide,\n            endSide,\n            // startArrowSize,\n            // endArrowSize,\n            startArrowMargin,\n            endArrowMargin,\n            horizontalMargin,\n            verticalMargin,\n            startHorizontalMargin,\n            startVerticalMargin,\n            endHorizontalMargin,\n            endVerticalMargin,\n            otherHorizontalMargin,\n            otherVerticalMargin,\n            otherBoxes,\n\n            connStartPoint, connEndPoint,\n            pathStartPoint, pathEndPoint,\n            gridStartPoint, gridEndPoint,\n            startGridBox, endGridBox,\n            grid, path, tryNum;\n\n        noPathFallbackFn = ArrayHelper.asArray(noPathFallbackFn);\n\n        for (tryNum = 0; lineDef && !path;) {\n            lineDefFull = Object.assign(me.config, lineDef);\n\n            startBox              = lineDefFull.startBox;\n            endBox                = lineDefFull.endBox;\n            startShift            = lineDefFull.startShift;\n            endShift              = lineDefFull.endShift;\n            startSide             = lineDefFull.startSide;\n            endSide               = lineDefFull.endSide;\n            // startArrowSize        = lineDefFull.startArrowSize;\n            // endArrowSize          = lineDefFull.endArrowSize;\n            startArrowMargin      = lineDefFull.startArrowMargin;\n            endArrowMargin        = lineDefFull.endArrowMargin;\n            horizontalMargin      = lineDefFull.horizontalMargin;\n            verticalMargin        = lineDefFull.verticalMargin;\n            startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin;\n            startVerticalMargin   = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin;\n            endHorizontalMargin   = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin;\n            endVerticalMargin     = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin;\n            otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin') ? lineDefFull.otherHorizontalMargin : horizontalMargin;\n            otherVerticalMargin   = lineDefFull.hasOwnProperty('otherVerticalMargin') ? lineDefFull.otherVerticalMargin : verticalMargin;\n            otherBoxes            = lineDefFull.otherBoxes;\n\n            startSide = me.normalizeSide(startSide);\n            endSide   = me.normalizeSide(endSide);\n\n            connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);\n            connEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);\n\n            startGridBox   = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide/*, startArrowSize*/, startArrowMargin, startHorizontalMargin, startVerticalMargin);\n            endGridBox     = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide/*, endArrowSize*/, endArrowMargin, endHorizontalMargin, endVerticalMargin);\n\n            // Iterate over points and merge those which are too close to each other (e.g. if difference is less than one\n            // over devicePixelRatio we won't even see this effect in GUI)\n            // https://github.com/bryntum/support/issues/3923\n            BOX_PROPERTIES.forEach(property => {\n                // We're talking subpixel precision here, so it doesn't really matter which value we choose\n                if (Math.abs(startGridBox[property] - endGridBox[property]) <= THRESHOLD) {\n                    endGridBox[property] = startGridBox[property];\n                }\n            });\n\n            if (me.shouldLookForPath(startBox, endBox, startGridBox, endGridBox)) {\n                otherBoxes     = otherBoxes?.map(box =>\n                    me.calcGridBaseBoxFromBoxAndDrawParams(box, false/*, 0*/, 0, otherHorizontalMargin, otherVerticalMargin)\n                );\n                pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);\n                pathEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);\n                grid           = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);\n                gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);\n                gridEndPoint   = me.convertDecartPointToGridPoint(grid, pathEndPoint);\n                path           = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);\n            }\n\n            //<debug>\n            // drawPathGrid(grid, lineDef.startBox, lineDef.endBox, startGridBox, endGridBox, otherBoxes, 4);\n            //</debug>\n\n            // Loop if\n            // - path is still not found\n            // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array\n            // - have noPathFallBackFn array\n            // - current try number is less then noPathFallBackFn array length\n            for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {\n                lineDef = (noPathFallbackFn[tryNum])(lineDefFull, originalLineDef);\n            }\n        }\n\n        if (path) {\n            path = me.prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide);\n            path = me.appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide);\n            path = me.optimizePath(path);\n        }\n\n        return path;\n    }\n\n    // Compares boxes relative position in the given direction.\n    //  0 - 1 is to the left/top of 2\n    //  1 - 1 overlaps with left/top edge of 2\n    //  2 - 1 is inside 2\n    // -2 - 2 is inside 1\n    //  3 - 1 overlaps with right/bottom edge of 2\n    //  4 - 1 is to the right/bottom of 2\n    static calculateRelativePosition(box1, box2, vertical = false) {\n        const\n            startProp = vertical ? 'top' : 'start',\n            endProp   = vertical ? 'bottom' : 'end';\n\n        let result;\n\n        if (box1[endProp] < box2[startProp]) {\n            result = 0;\n        }\n        else if (box1[endProp] <= box2[endProp] && box1[endProp] >= box2[startProp] && box1[startProp] < box2[startProp]) {\n            result = 1;\n        }\n        else if (box1[startProp] >= box2[startProp] && box1[endProp] <= box2[endProp]) {\n            result = 2;\n        }\n        else if (box1[startProp] < box2[startProp] && box1[endProp] > box2[endProp]) {\n            result = -2;\n        }\n        else if (box1[startProp] <= box2[endProp] && box1[endProp] > box2[endProp]) {\n            result = 3;\n        }\n        else {\n            result = 4;\n        }\n\n        return result;\n    }\n\n    // Checks if relative position of the original and marginized boxes is the same\n    static boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox, vertical = false) {\n        const\n            calculateOverlap = RectangularPathFinder.calculateRelativePosition,\n            originalOverlap  = calculateOverlap(startBox, endBox, vertical),\n            finalOverlap     = calculateOverlap(gridStartBox, gridEndBox, vertical);\n\n        return originalOverlap !== finalOverlap;\n    }\n\n    shouldLookForPath(startBox, endBox, gridStartBox, gridEndBox) {\n        let result = true;\n\n        // Only calculate overlap if boxes are narrow in horizontal direction\n        if (\n            // We refer to the original arrow margins because during lookup those might be nullified and we need some\n            // criteria to tell if events are too narrow\n            (startBox.end - startBox.start <= this.startArrowMargin || endBox.end - endBox.start <= this.endArrowMargin) &&\n            Math.abs(RectangularPathFinder.calculateRelativePosition(startBox, endBox, true)) === 2\n        ) {\n            result = !RectangularPathFinder.boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox);\n        }\n\n        return result;\n    }\n\n    getConnectionCoordinatesFromBoxSideShift(box, side, shift) {\n        let coords;\n\n        // Note that we deal with screen geometry here, not logical dependency sides\n        // Possible 'start' and 'end' have been resolved to box sides.\n        switch (side) {\n            case 'left':\n                coords = {\n                    x : box.start,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'right':\n                coords = {\n                    x : box.end,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'top':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.top\n                };\n                break;\n            case 'bottom':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.bottom\n                };\n                break;\n        }\n\n        return coords;\n    }\n\n    calcGridBaseBoxFromBoxAndDrawParams(box, side/*, arrowSize*/, arrowMargin, horizontalMargin, verticalMargin) {\n        let gridBox;\n\n        switch (this.normalizeSide(side)) {\n            case 'left':\n                gridBox = {\n                    start  : box.start - Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'right':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'top':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - Math.max(/*arrowSize + */arrowMargin, verticalMargin),\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'bottom':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + Math.max(/*arrowSize + */arrowMargin, verticalMargin)\n                };\n                break;\n            default:\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n        }\n\n        return gridBox;\n    }\n\n    normalizeSide(side) {\n        const { rtl } = this.client;\n\n        side => sideToSide[side] || side;\n\n        if (side === 'start') {\n            return rtl ? 'right' : 'left';\n        }\n        if (side === 'end') {\n            return rtl ? 'left' : 'right';\n        }\n        return side;\n    }\n\n    buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {\n        let xs, ys,\n            y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point;\n\n        const\n            points       = {},\n            linearPoints = [];\n\n        xs = [\n            startGridBox.start,\n            (startSide === 'left' || startSide === 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,\n            startGridBox.end,\n            endGridBox.start,\n            (endSide === 'left' || endSide === 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,\n            endGridBox.end\n        ];\n        ys = [\n            startGridBox.top,\n            (startSide === 'top' || startSide === 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,\n            startGridBox.bottom,\n            endGridBox.top,\n            (endSide === 'top' || endSide === 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,\n            endGridBox.bottom\n        ];\n\n        if (otherGridBoxes) {\n            otherGridBoxes.forEach(box => {\n                xs.push(box.start, (box.start + box.end) / 2, box.end);\n                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);\n            });\n        }\n\n        xs = [...new Set(xs.sort((a, b) => a - b))];\n        ys = [...new Set(ys.sort((a, b) => a - b))];\n\n        // <remove-on-release>\n        // TODO: fastest way to make unique, Set is slower\n        // for ( let i = 0, I = array.length; i < I; i++ ) {\n        //     if ( ~array.indexOf( array[ i ], i + 1 ) ) {\n        //         array.splice( i, 1 );\n        //         i--;\n        //         I--;\n        //     }\n        // }\n        // </remove-on-release>\n\n        for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {\n            points[iy] = points[iy] || {};\n            y          = ys[iy];\n            for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {\n                x = xs[ix];\n\n                permitted = (\n                    (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) &&\n                    (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom)\n                );\n\n                if (otherGridBoxes) {\n                    for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {\n                        box       = otherGridBoxes[ib];\n                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom) ||\n                            // Allow point if it is a path start/end even if point is inside any box\n                            (x === pathStartPoint.x && y === pathStartPoint.y) ||\n                            (x === pathEndPoint.x && y === pathEndPoint.y);\n                    }\n                }\n\n                point = {\n                    distance : Number.MAX_SAFE_INTEGER,\n                    permitted,\n                    x,\n                    y,\n                    ix,\n                    iy\n                };\n\n                points[iy][ix] = point;\n                linearPoints.push(point);\n            }\n        }\n\n        return {\n            width  : xs.length,\n            height : ys.length,\n            xs,\n            ys,\n            points,\n            linearPoints\n        };\n    }\n\n    convertDecartPointToGridPoint(grid, point) {\n        const\n            x = grid.xs.indexOf(point.x),\n            y = grid.ys.indexOf(point.y);\n\n        return grid.points[y][x];\n    }\n\n    findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {\n        const me = this;\n\n        let path = false;\n\n        if (gridStartPoint.permitted && gridEndPoint.permitted) {\n            grid = me.waveForward(grid, gridStartPoint, 0);\n            path = me.collectPath(grid, gridEndPoint, endSide);\n        }\n\n        return path;\n    }\n\n    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)\n    getGridPointNeighbors(grid, gridPoint, predicateFn) {\n        const\n            ix     = gridPoint.ix,\n            iy     = gridPoint.iy,\n            result = [];\n\n        let neighbor;\n\n        // NOTE:\n        // It's important to push bottom neighbors first since this method is used\n        // in collectPath(), which recursively collects path from end to start node\n        // and if bottom neighbors are pushed first in result array then collectPath()\n        // will produce a line which is more suitable (pleasant looking) for our purposes.\n        if (iy < grid.height - 1) {\n            neighbor = grid.points[iy + 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (iy > 0) {\n            neighbor = grid.points[iy - 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix < grid.width - 1) {\n            neighbor = grid.points[iy][ix + 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix > 0) {\n            neighbor = grid.points[iy][ix - 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n\n        return result;\n    }\n\n    waveForward(grid, gridStartPoint, distance) {\n        const me = this;\n\n        // I use the WalkHelper here because a point on a grid and it's neighbors might be considered as a hierarchy.\n        // The point is the parent node, and it's neighbors are the children nodes. Thus the grid here is hierarchical\n        // data structure which can be walked. WalkHelper walks non-recursively which is exactly what I need as well.\n        WalkHelper.preWalkUnordered(\n            // Walk starting point - a node is a grid point and it's distance from the starting point\n            [gridStartPoint, distance],\n            // Children query function\n            // NOTE: It's important to fix neighbor distance first, before waving to a neighbor, otherwise waving might\n            //       get through a neighbor point setting it's distance to a value more than (distance + 1) whereas we,\n            //       at the children querying moment in time, already know that the possibly optimal distance is (distance + 1)\n            ([point, distance]) => me.getGridPointNeighbors(\n                grid,\n                point,\n                neighborPoint => neighborPoint.permitted && (neighborPoint.distance > distance + 1)\n            ).map(\n                neighborPoint => [neighborPoint, distance + 1] // Neighbor distance fixation\n            ),\n            // Walk step iterator function\n            ([point, distance]) => point.distance = distance // Neighbor distance applying\n        );\n\n        return grid;\n    }\n\n    collectPath(grid, gridEndPoint, endSide) {\n        const\n            me   = this,\n            path = [];\n\n        let pathFound = true,\n            neighbors,\n            lowestDistanceNeighbor,\n            xDiff, yDiff;\n\n        while (pathFound && gridEndPoint.distance) {\n            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, point =>\n                point.permitted && (point.distance === gridEndPoint.distance - 1)\n            );\n\n            pathFound = neighbors.length > 0;\n\n            if (pathFound) {\n                // Prefer turnless neighbors first\n                neighbors = neighbors.sort((a, b) => {\n                    let xDiff, yDiff;\n\n                    xDiff = a.ix - gridEndPoint.ix;\n                    yDiff = a.iy - gridEndPoint.iy;\n\n                    const resultA = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n\n                    xDiff = b.ix - gridEndPoint.ix;\n                    yDiff = b.iy - gridEndPoint.iy;\n\n                    const resultB = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n\n                    if (resultA > resultB) return 1;\n                    if (resultA < resultB) return -1;\n                    // apply additional sorting to be sure to pick bottom path in IE\n                    if (resultA === resultB) return a.y > b.y ? -1 : 1;\n                });\n\n                lowestDistanceNeighbor = neighbors[0];\n\n                path.push({\n                    x1 : lowestDistanceNeighbor.x,\n                    y1 : lowestDistanceNeighbor.y,\n                    x2 : gridEndPoint.x,\n                    y2 : gridEndPoint.y\n                });\n\n                // Detecting new side, either xDiff or yDiff must be 0 (but not both)\n                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;\n                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;\n\n                switch (true) {\n                    case !yDiff && xDiff > 0:\n                        endSide = 'left';\n                        break;\n                    case !yDiff && xDiff < 0:\n                        endSide = 'right';\n                        break;\n                    case !xDiff && yDiff > 0:\n                        endSide = 'top';\n                        break;\n                    case !xDiff && yDiff < 0:\n                        endSide = 'bottom';\n                        break;\n                }\n\n                gridEndPoint = lowestDistanceNeighbor;\n            }\n        }\n\n        return pathFound && path.reverse() || false;\n    }\n\n    prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide) {\n        if (path.length > 0) {\n            const\n                firstSegment   = path[0],\n                prependSegment = {\n                    x2 : firstSegment.x1,\n                    y2 : firstSegment.y1\n                };\n\n            switch (startSide) {\n                case 'left':\n                    prependSegment.x1 = connStartPoint.x/* - startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'right':\n                    prependSegment.x1 = connStartPoint.x/* + startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'top':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* - startArrowSize*/;\n                    break;\n                case 'bottom':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* + startArrowSize*/;\n                    break;\n            }\n\n            path.unshift(prependSegment);\n        }\n\n        return path;\n    }\n\n    appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide) {\n        if (path.length > 0) {\n            const\n                lastSegment   = path[path.length - 1],\n                appendSegment = {\n                    x1 : lastSegment.x2,\n                    y1 : lastSegment.y2\n                };\n\n            switch (endSide) {\n                case 'left':\n                    appendSegment.x2 = connEndPoint.x/* - endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'right':\n                    appendSegment.x2 = connEndPoint.x/* + endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'top':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* - endArrowSize*/;\n                    break;\n                case 'bottom':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* + endArrowSize*/;\n                    break;\n            }\n\n            path.push(appendSegment);\n        }\n\n        return path;\n    }\n\n    optimizePath(path) {\n        const optPath = [];\n\n        let prevSegment,\n            curSegment;\n\n        if (path.length > 0) {\n            prevSegment = path.shift();\n            optPath.push(prevSegment);\n\n            while (path.length > 0) {\n                curSegment = path.shift();\n                // both segments are as good as equal\n                if (\n                    equalEnough(prevSegment.x1, curSegment.x1) && equalEnough(prevSegment.y1, curSegment.y1) &&\n                    equalEnough(prevSegment.x2, curSegment.x2) && equalEnough(prevSegment.y2, curSegment.y2)\n                ) {\n                    prevSegment = curSegment;\n                }\n                // both segments are horizontal or very nearly so\n                else if (equalEnough(prevSegment.y1, prevSegment.y2) && equalEnough(curSegment.y1, curSegment.y2)) {\n                    prevSegment.x2 = curSegment.x2;\n                }\n                // both segments are vertical or very nearly so\n                else if (equalEnough(prevSegment.x1, prevSegment.x2) && equalEnough(curSegment.x1, curSegment.x2)) {\n                    prevSegment.y2 = curSegment.y2;\n                }\n                // segments have different orientation (path turn)\n                else {\n                    optPath.push(curSegment);\n                    prevSegment = curSegment;\n                }\n            }\n        }\n\n        return optPath;\n    }\n}\n\n//<debug>\nfunction createBox(startBox, deltaX, deltaY, scale, stroke) {\n    const points = [\n        [startBox.start * scale - deltaX, startBox.top * scale - deltaY],\n        [startBox.start * scale - deltaX, startBox.bottom * scale - deltaY],\n        [startBox.end * scale - deltaX, startBox.bottom * scale - deltaY],\n        [startBox.end * scale - deltaX, startBox.top * scale - deltaY],\n        [startBox.start * scale - deltaX, startBox.top * scale - deltaY]\n    ].map(pair => `${pair[0]},${pair[1]}`).join(' ');\n\n    return `<polyline points=\"${points}\" style=\"stroke:${stroke || 'blue'};stroke-width:4;\"/>`;\n}\n// eslint-disable-next-line no-unused-vars\nfunction drawPathGrid(grid, sourceBox, targetBox, sourceRegion, targetRegion, otherBoxes, scale = 4) {\n    const\n        rowHeight       = 61,\n        xs              = grid.xs.map(x => x * scale),\n        ys              = grid.ys.map(y => y * scale),\n        xsLength        = xs.length,\n        ysLength        = ys.length,\n        verticalLines   = xs.map(x => `<line style=\"stroke:black\" x1=\"${x - xs[0]}\" x2=\"${x - xs[0]}\"\" y1=\"0\" y2=\"${ys[ysLength - 1] - ys[0]}\"/>`),\n        horizontalLines = ys.map(y => `<line style=\"stroke:black\" x1=\"0\" x2=\"${xs[xsLength - 1] - xs[0]}\"\" y1=\"${y - ys[0]}\" y2=\"${y - ys[0]}\" style=\"${y / scale === rowHeight ? 'stroke:red' : ''}\"/>`),\n        extraLines      = [];\n\n    sourceRegion && extraLines.push(createBox(sourceRegion, xs[0], ys[0], scale, 'green'));\n    targetRegion && extraLines.push(createBox(targetRegion, xs[0], ys[0], scale, 'green'));\n    sourceBox && extraLines.push(createBox(sourceBox, xs[0], ys[0], scale));\n    targetBox && extraLines.push(createBox(targetBox, xs[0], ys[0], scale));\n\n    (otherBoxes || []).forEach(box => extraLines.push(createBox(box, xs[0], ys[0], scale, 'red')));\n\n    console.log(`<svg width=\"${xs[xsLength - 1] - xs[0]}\" height=\"${ys[ysLength - 1] - ys[0]}\">${\n        verticalLines.concat(horizontalLines, extraLines).join('')}</svg>`);\n}\n//</debug>\n", "import DependencyModel from '../../model/DependencyModel.js';\nimport RectangularPathFinder from '../../util/RectangularPathFinder.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\n\n// <remove-on-release>\n// TODO: Tests\n// </remove-on-release>\n\n// Determine a line segments drawing direction\nfunction drawingDirection(pointSet) {\n    if (pointSet.x1 === pointSet.x2) {\n        return pointSet.y2 > pointSet.y1 ? 'd' : 'u';\n    }\n\n    return pointSet.x2 > pointSet.x1 ? 'r' : 'l';\n}\n\n// Determine a line segments length\nfunction segmentLength(pointSet) {\n    return pointSet.x1 === pointSet.x2 ? pointSet.y2 - pointSet.y1 : pointSet.x2 - pointSet.x1;\n}\n\n// Define an arc to tie two line segments together\nfunction arc(pointSet, nextPointSet, radius) {\n    const\n        corner  = drawingDirection(pointSet) + drawingDirection(nextPointSet),\n        // Flip x if this or next segment is drawn right to left\n        rx      = radius * (corner.includes('l') ? -1 : 1),\n        // Flip y if this or next segment is drawn bottom to top\n        ry      = radius * (corner.includes('u') ? -1 : 1),\n        // Positive (0) or negative (1) angle\n        sweep   = corner === 'ur' || corner === 'lu' || corner === 'dl' || corner === 'rd' ? 1 : 0;\n\n    return `a${rx},${ry} 0 0 ${sweep} ${rx},${ry}`;\n}\n\n// Define a line for a set of points, tying it together with the next set with an arc when applicable\nfunction line(pointSet, nextPointSet, location, radius, prevRadius) {\n\n    // Horizontal or vertical line\n    let line      = pointSet.x1 === pointSet.x2 ? 'v' : 'h',\n        useRadius = radius;\n\n    // Add an arc?\n    if (radius) {\n        const\n            // Length of this line segment\n            length     = segmentLength(pointSet),\n            // Length of the next one. Both are needed to determine max radius (half of the shortest delta)\n            nextLength = nextPointSet ? Math.abs(segmentLength(nextPointSet)) : Number.MAX_SAFE_INTEGER,\n            // Line direction\n            sign       = Math.sign(length);\n\n        // If we are not passed a radius from the previous line drawn, we use the configured radius. It is used to shorten\n        // this lines length to fit the arc that connects it to the previous line\n        if (prevRadius == null) {\n            prevRadius = radius;\n        }\n\n        // We cannot use a radius larger than half our or our successor's length, doing so would make the segment too long\n        // when the arc is created\n        if (Math.abs(length) < radius * 2 || nextLength < radius * 2) {\n            useRadius = Math.min(Math.abs(length), nextLength) / 2;\n        }\n\n        const\n            // Radius of neighbouring arcs, subtracted from length below...\n            subtract  = location === 'single' ? 0 : location === 'first' ? useRadius : location === 'between' ? prevRadius + useRadius : /*last*/ prevRadius,\n            // ...to produce the length of the line segment to draw\n            useLength = length - subtract * sign;\n\n        // Apply line segment length, unless it passed over 0 in which case we stick to 0\n        line += Math.sign(useLength) !== sign ? 0 : useLength;\n\n        // Add an arc if applicable\n        if (location !== 'last' && location !== 'single' && useRadius > 0) {\n            line += ` ${arc(pointSet, nextPointSet, useRadius)}`;\n        }\n    }\n    // Otherwise take a shorter code path\n    else {\n        line += segmentLength(pointSet);\n    }\n\n    return {\n        line,\n        currentRadius : radius !== useRadius ? useRadius : null\n    };\n}\n\n// Define an SVG path base on points from the path finder.\n// Each segment in the path can be joined by an arc\nfunction pathMapper(radius, points) {\n    const { length } = points;\n\n    if (!length) {\n        return '';\n    }\n\n    let currentRadius = null;\n\n    return `M${points[0].x1},${points[0].y1} ${points.map((pointSet, i) => {\n        // Segment placement among all segments, used to determine if an arc should be added\n        const\n            location =\n                  length === 1 ? 'single'\n                      : i === length - 1 ? 'last'\n                          : i === 0 ? 'first'\n                              : 'between',\n            lineSpec = line(pointSet, points[i + 1], location, radius, currentRadius);\n\n        ({ currentRadius } = lineSpec);\n\n        return lineSpec.line;\n    }).join(' ')}`;\n}\n\n// Mixin that holds the code needed to generate DomConfigs for dependency lines\nexport default Target => class DependencyLineGenerator extends Target {\n    static $name = 'DependencyLineGenerator';\n\n    lineCache = {};\n\n    onSVGReady() {\n        // <remove-on-release>\n        // TODO: Get rid of pathFinderConfig?? Move to configurable\n        // </remove-on-release>\n        const me = this;\n\n        me.pathFinder = new RectangularPathFinder({\n            ...me.pathFinderConfig,\n            client : me.client\n        });\n        me.lineDefAdjusters = me.createLineDefAdjusters();\n\n        me.createMarker();\n    }\n\n    changeRadius(radius) {\n        if (radius !== null) {\n            ObjectHelper.assertNumber(radius, 'radius');\n        }\n\n        return radius;\n    }\n\n    updateRadius() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    updateRenderer() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    changeClickWidth(width) {\n        if (width !== null) {\n            ObjectHelper.assertNumber(width, 'clickWidth');\n        }\n\n        return width;\n    }\n\n    updateClickWidth() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    //region Marker\n\n    createMarker() {\n        const\n            me            = this,\n            { markerDef } = me,\n            svg           = this.client.svgCanvas,\n            // SVG markers has to use an id, we want the id to be per scheduler when using multiple\n            markerId      = markerDef ? `${me.client.id}-arrowEnd` : 'arrowEnd';\n\n        me.marker?.remove();\n\n        svg.style.setProperty('--scheduler-dependency-marker', `url(#${markerId})`);\n\n        me.marker = DomHelper.createElement({\n            parent        : svg,\n            id            : markerId, // no-sanity\n            tag           : 'marker',\n            className     : 'b-sch-dependency-arrow',\n            ns            : 'http://www.w3.org/2000/svg',\n            markerHeight  : 11,\n            markerWidth   : 11,\n            refX          : 8.5,\n            refY          : 3,\n            viewBox       : '0 0 9 6',\n            orient        : 'auto-start-reverse',\n            markerUnits   : 'userSpaceOnUse',\n            retainElement : true,\n            children      : [{\n                tag : 'path',\n                ns  : 'http://www.w3.org/2000/svg',\n                d   : me.markerDef ?? 'M3,0 L3,6 L9,3 z'\n            }]\n        });\n    }\n\n    updateMarkerDef() {\n        if (!this.isConfiguring) {\n            this.createMarker();\n        }\n    }\n\n    //endregion\n\n    //region DomConfig\n\n    getAssignmentElement(assignment) {\n        // If we are dragging an event, we need to use the proxy element\n        // (which is not the original element if we are not constrained to timeline)\n        const proxyElement = this.client.features.eventDrag?.getProxyElement?.(assignment);\n\n        return proxyElement || this.client.getElementFromAssignmentRecord(assignment);\n    }\n\n    // Generate a DomConfig for a dependency line between two assignments (tasks in Gantt)\n    getDomConfigs(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me     = this,\n            key    = me.getDependencyKey(dependency, fromAssignment, toAssignment),\n            // Under certain circumstances (scrolling) we might be able to reuse the previous DomConfig.\n            cached = me.lineCache[key];\n\n        // Create line def if not cached, or we are live drawing and have event elements (dragging, transitioning etc)\n        if (me.constructLineCache || !cached || forceBoxes || (me.drawingLive && (me.getAssignmentElement(fromAssignment) || me.getAssignmentElement(toAssignment)))) {\n            const\n                lineDef     = me.prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes),\n                points      = lineDef && me.pathFinder.findPath(lineDef, me.lineDefAdjusters),\n                {\n                    client,\n                    clickWidth\n                }           = me,\n                { toEvent } = dependency;\n\n            if (points) {\n                const\n                    highlighted = me.highlighted.get(dependency),\n                    domConfig   = {\n                        tag     : 'path',\n                        ns      : 'http://www.w3.org/2000/svg',\n                        d       : pathMapper(me.radius ?? 0, points),\n                        role    : 'presentation',\n                        dataset : {\n                            syncId : key,\n                            depId  : dependency.id,\n                            fromId : fromAssignment.id,\n                            toId   : toAssignment.id\n                        },\n                        elementData : {\n                            dependency,\n                            points\n                        },\n                        class : {\n                            [me.baseCls]                                : 1,\n                            [dependency.cls]                            : dependency.cls,\n                            // Data highlight\n                            [dependency.highlighted]                    : dependency.highlighted,\n                            // Feature highlight\n                            [highlighted && [...highlighted].join(' ')] : highlighted,\n                            [me.noMarkerCls]                            : lineDef.hideMarker,\n                            'b-inactive'                                : dependency.active === false,\n                            'b-sch-bidirectional-line'                  : dependency.bidirectional,\n                            'b-readonly'                                : dependency.readOnly,\n                            // If target event is outside the view add special CSS class to hide marker (arrow)\n                            'b-sch-dependency-ends-outside' :\n                                (!toEvent.milestone && (toEvent.endDate <= client.startDate || client.endDate <= toEvent.startDate)) ||\n                                (toEvent.milestone && (toEvent.endDate < client.startDate || client.endDate < toEvent.startDate))\n                        }\n                    };\n\n                me.renderer?.({\n                    domConfig,\n                    points,\n                    dependencyRecord     : dependency,\n                    fromAssignmentRecord : fromAssignment,\n                    toAssignmentRecord   : toAssignment,\n                    fromBox              : lineDef.startBox,\n                    toBox                : lineDef.endBox,\n                    fromSide             : lineDef.startSide,\n                    toSide               : lineDef.endSide\n                });\n\n                const configs = [domConfig];\n\n                if (clickWidth > 1) {\n                    configs.push({\n                        ...domConfig, // Shallow on purpose, to not waste perf cloning deeply\n                        class : {\n                            ...domConfig.class,\n                            'b-click-area' : 1\n                        },\n                        dataset : {\n                            ...domConfig.dataset,\n                            syncId : `${domConfig.dataset.syncId}-click-area`\n                        },\n                        style : {\n                            strokeWidth : clickWidth\n                        }\n                    });\n                }\n\n                return me.lineCache[key] = configs;\n            }\n\n            // Nothing to draw or cache\n            return me.lineCache[key] = null;\n        }\n\n        return cached;\n    }\n\n    //endregion\n\n    //region Bounds\n\n    // Generates `otherBoxes` config for rectangular path finder, which push dependency line to the row boundary.\n    // It should be enough to return single box with top/bottom taken from row top/bottom and left/right taken from source\n    // box, extended by start arrow margin to both sides.\n    generateBoundaryBoxes(box, side) {\n        // We need two boxes for the bottom edge, because otherwise path cannot be found. Ideally that shouldn't be\n        // necessary. Other solution would be to adjust bottom by -1px, but that would make some dependency lines to take\n        // 1px different path on a row boundary, which doesn't look nice (but slightly more performant)\n        if (side === 'bottom') {\n            return [\n                {\n                    start  : box.left,\n                    end    : box.left + box.width / 2,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                },\n                {\n                    start  : box.left + box.width / 2,\n                    end    : box.right,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n        else {\n            return [\n                {\n                    start  : box.left - this.pathFinder.startArrowMargin,\n                    end    : box.right + this.pathFinder.startArrowMargin,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n\n        // //<debug>\n        // globalThis.DEBUG && boxes.forEach(box => {\n        //     DomHelper.createElement({\n        //         parent : document.querySelector('.b-sch-foreground-canvas'),\n        //         html   : `<div style=\"left:${box.start}px;top:${box.top}px;width:${box.end - box.start}px;height:${box.bottom - box.top}px;border:1px solid green;position:absolute;\"></div>`\n        //     });\n        // });\n        // //</debug>\n    }\n\n    // Bounding box for an assignment, uses elements bounds if rendered\n    getAssignmentBounds(assignment) {\n        const\n            { client } = this,\n            element    = this.getAssignmentElement(assignment);\n\n        if (element && !client.isExporting) {\n            const rectangle = Rectangle.from(element, this.relativeTo);\n\n            if (client.isHorizontal) {\n                let row = client.getRowById(assignment.resource.id);\n\n                // Outside of its row? It is being dragged, resolve new row\n                if (rectangle.y < row.top || rectangle.bottom > row.bottom) {\n                    const overRow = client.rowManager.getRowAt(rectangle.center.y, true);\n                    if (overRow) {\n                        row = overRow;\n                    }\n                }\n\n                rectangle.rowTop = row.top;\n                rectangle.rowBottom = row.bottom;\n            }\n\n            return rectangle;\n        }\n\n        return client.isEngineReady && client.getAssignmentEventBox(assignment, true);\n    }\n\n    //endregion\n\n    //region Sides\n\n    getConnectorStartSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);\n    }\n\n    getConnectorEndSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);\n    }\n\n    getDependencyStartSide(dependency) {\n        const { fromEvent, type, fromSide } = dependency;\n\n        if (fromSide) {\n            return fromSide;\n        }\n\n        switch (true) {\n            case type === DependencyModel.Type.StartToEnd:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(fromEvent);\n\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.EndToEnd:\n                return this.getConnectorEndSide(fromEvent);\n\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorEndSide(fromEvent);\n        }\n    }\n\n    getDependencyEndSide(dependency) {\n        const { toEvent, type, toSide } = dependency;\n\n        if (toSide) {\n            return toSide;\n        }\n\n        // Fallback to view trait if dependency end side is not given /*or can be obtained from type*/\n        switch (true) {\n            case type === DependencyModel.Type.EndToEnd:\n            case type === DependencyModel.Type.StartToEnd:\n                return this.getConnectorEndSide(toEvent);\n\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(toEvent);\n\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorStartSide(toEvent);\n        }\n    }\n\n    //endregion\n\n    //region Line def\n\n    // An array of functions used to alter path config when no path found.\n    // It first tries to shrink arrow margins and secondly hides arrows entirely\n    createLineDefAdjusters() {\n        const { client } = this;\n\n        function shrinkArrowMargins(lineDef) {\n            const { barMargin } = client;\n\n            let adjusted = false;\n\n            if (lineDef.startArrowMargin > barMargin || lineDef.endArrowMargin > barMargin) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = barMargin;\n                adjusted = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        function resetArrowMargins(lineDef) {\n            let adjusted = false;\n\n            if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = 0;\n                adjusted = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        function shrinkHorizontalMargin(lineDef, originalLineDef) {\n            let adjusted = false;\n\n            if (lineDef.horizontalMargin > 2) {\n                lineDef.horizontalMargin = 1;\n                adjusted = true;\n                originalLineDef.hideMarker = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        return [\n            shrinkArrowMargins,\n            resetArrowMargins,\n            shrinkHorizontalMargin\n        ];\n    }\n\n    // Overridden in Gantt\n    adjustLineDef(dependency, lineDef) {\n        return lineDef;\n    }\n\n    // Prepare data to feed to the path finder\n    prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me             = this,\n            startSide      = me.getDependencyStartSide(dependency),\n            endSide        = me.getDependencyEndSide(dependency),\n            startRectangle = forceBoxes?.from ?? me.getAssignmentBounds(fromAssignment),\n            endRectangle   = forceBoxes?.to ?? me.getAssignmentBounds(toAssignment),\n            otherBoxes     = [];\n\n        if (!startRectangle || !endRectangle) {\n            return null;\n        }\n\n        let {\n            startArrowMargin,\n            verticalMargin\n        } = me.pathFinder;\n\n        if (me.client.isHorizontal) {\n            // Only add otherBoxes if assignments are in different resources\n            if (startRectangle.rowTop != null && startRectangle.rowTop !== endRectangle.rowTop) {\n                otherBoxes.push(...me.generateBoundaryBoxes(startRectangle, startSide));\n            }\n\n            // Do not change start arrow margin in case dependency is bidirectional\n            if (!dependency.bidirectional) {\n                if (/(top|bottom)/.test(startSide)) {\n                    startArrowMargin = me.client.barMargin / 2;\n                }\n\n                verticalMargin = me.client.barMargin / 2;\n            }\n        }\n\n        return me.adjustLineDef(dependency, {\n            startBox              : startRectangle,\n            endBox                : endRectangle,\n            otherBoxes,\n            startArrowMargin,\n            verticalMargin,\n            otherVerticalMargin   : 0,\n            otherHorizontalMargin : 0,\n            startSide,\n            endSide\n        });\n    }\n\n    //endregion\n\n    //region Cache\n\n    // All dependencies are about to be drawn, check if we need to build the line cache\n    beforeDraw() {\n        super.beforeDraw();\n\n        if (!Object.keys(this.lineCache).length) {\n            this.constructLineCache = true;\n        }\n    }\n\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        super.afterDraw();\n\n        this.constructLineCache = false;\n    }\n\n    reset() {\n        super.reset();\n\n        this.lineCache = {};\n    }\n\n    //endregion\n\n};\n", "import Tooltip from '../../../Core/widget/Tooltip.js';\n\n/**\n * @module Scheduler/feature/mixin/DependencyTooltip\n */\n\nconst\n    // Map dependency type to side of a box, for displaying an icon in the tooltip\n    fromBoxSide = [\n        'start',\n        'start',\n        'end',\n        'end'\n    ],\n    toBoxSide   = [\n        'start',\n        'end',\n        'start',\n        'end'\n    ];\n\n/**\n * Mixin that adds tooltip support to the {@link Scheduler/feature/Dependencies} feature.\n * @mixin\n */\nexport default Target => class DependencyTooltip extends Target {\n    static $name = 'DependencyTooltip';\n\n    static configurable = {\n        /**\n         * Set to true to show a tooltip when hovering a dependency line\n         * @config {Boolean}\n         */\n        showTooltip : true,\n\n        /**\n         * A template function allowing you to configure the contents of the tooltip shown when hovering a\n         * dependency line. You can return either an HTML string or a {@link DomConfig} object.\n         * @prp {Function} tooltipTemplate\n         * @param {Scheduler.model.DependencyBaseModel} dependency The dependency record\n         * @returns {String|DomConfig}\n         */\n        tooltipTemplate(dependency) {\n            return {\n                children : [{\n                    className : 'b-sch-dependency-tooltip',\n                    children  : [\n                        { tag : 'label', text : this.L('L{Dependencies.from}') },\n                        { text : dependency.fromEvent.name },\n                        { className : `b-sch-box b-${dependency.fromSide || fromBoxSide[dependency.type]}` },\n                        { tag : 'label', text : this.L('L{Dependencies.to}') },\n                        { text : dependency.toEvent.name },\n                        { className : `b-sch-box b-${dependency.toSide || toBoxSide[dependency.type]}` }\n                    ]\n                }]\n            };\n        },\n\n        /**\n         * A tooltip config object that will be applied to the dependency hover tooltip. Can be used to for example\n         * customize delay\n         * @config {TooltipConfig}\n         */\n        tooltip : {\n            $config : 'nullify',\n\n            value : {}\n        }\n    };\n\n    changeTooltip(tooltip, old) {\n        const me = this;\n\n        old?.destroy();\n\n        if (!me.showTooltip || !tooltip) {\n            return null;\n        }\n\n        return Tooltip.new({\n            align          : 'b-t',\n            id             : `${me.client.id}-dependency-tip`,\n            // <remove-on-release>\n            // TODO: need some way better to specify this. maybe each feature should be queried?\n            // </remove-on-release>\n            forSelector    : `.b-timelinebase:not(.b-eventeditor-editing,.b-taskeditor-editing,.b-resizing-event,.b-dragcreating,.b-dragging-event,.b-creating-dependency) .${me.baseCls}`,\n            forElement     : me.client.timeAxisSubGridElement,\n            showOnHover    : true,\n            hoverDelay     : 0,\n            hideDelay      : 0,\n            anchorToTarget : false,\n            textContent    : false, // Skip max-width setting\n            trackMouse     : false,\n            getHtml        : me.getHoverTipHtml.bind(me)\n        }, tooltip);\n    }\n\n    /**\n     * Generates DomConfig content for the tooltip shown when hovering a dependency\n     * @param {Object} tooltipConfig\n     * @returns {DomConfig} DomConfig used as tooltips content\n     * @private\n     */\n    getHoverTipHtml({ activeTarget }) {\n        return this.tooltipTemplate(this.resolveDependencyRecord(activeTarget));\n    }\n};\n", "import DomSync from '../../Core/helper/DomSync.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport DependencyCreation from './mixin/DependencyCreation.js';\nimport DependencyGridCache from './mixin/DependencyGridCache.js';\nimport DependencyLineGenerator from './mixin/DependencyLineGenerator.js';\nimport DependencyTooltip from './mixin/DependencyTooltip.js';\n\nconst eventNameMap = {\n    click       : 'Click',\n    dblclick    : 'DblClick',\n    contextmenu : 'ContextMenu'\n};\n/**\n * @module Scheduler/feature/Dependencies\n */\n\nconst collectLinkedAssignments = assignment => {\n    const result = [assignment];\n\n    if (assignment.resource?.hasLinks) {\n        // Fake linked assignments\n        result.push(...assignment.resource.$links.map(l => ({\n            id               : `${l.id}_${assignment.id}`,\n            resource         : l,\n            event            : assignment.event,\n            drawDependencies : assignment.drawDependencies\n        })));\n    }\n\n    return result;\n};\n\n/**\n * Feature that draws dependencies between events. Uses a {@link Scheduler.data.DependencyStore} to determine which\n * dependencies to draw, if none is defined one will be created automatically. Dependencies can also be specified as\n * `scheduler.dependencies`, see example below:\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * Dependencies also work in vertical mode:\n *\n * {@inlineexample Scheduler/feature/DependenciesVertical.js}\n *\n * To customize the dependency tooltip, you can provide the {@link #config-tooltip} config and specify a\n * {@link Core.widget.Tooltip#config-getHtml} function. For example:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         dependencies : {\n *             tooltip : {\n *                 getHtml({ activeTarget }) {\n *                     const dependencyModel = scheduler.resolveDependencyRecord(activeTarget);\n *\n *                     if (!dependencyModel) return null;\n *\n *                     const { fromEvent, toEvent } = dependencyModel;\n *\n *                     return `${fromEvent.name} (${fromEvent.id}) -> ${toEvent.name} (${toEvent.id})`;\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * ## Styling dependency lines\n *\n * You can easily customize the arrows drawn between events. To change all arrows, apply the following basic SVG CSS:\n *\n * ```css\n * .b-sch-dependency {\n *    stroke-width: 2;\n *    stroke : red;\n * }\n *\n * .b-sch-dependency-arrow {\n *     fill: red;\n * }\n * ```\n *\n * To style an individual dependency line, you can provide a [cls](#Scheduler/model/DependencyModel#field-cls) in your\n * data:\n *\n * ```json\n * {\n *     \"id\"   : 9,\n *     \"from\" : 7,\n *     \"to\"   : 8,\n *     \"cls\"  : \"special-dependency\"\n * }\n * ```\n *\n * ```scss\n * // Make line dashed\n * .b-sch-dependency {\n *    stroke-dasharray: 5, 5;\n * }\n * ```\n *\n * To customize the marker used for the lines (the arrow header), you can supply a SVG path definition to the\n * {@link #config-markerDef} config:\n *\n * {@inlineexample Scheduler/feature/DependenciesMarker.js}\n *\n * You can also specify a {@link #config-radius} to get lines with rounded \"corners\", for a less boxy look:\n *\n * {@inlineexample Scheduler/feature/DependenciesRadius.js}\n *\n * For advanced use cases, you can also manipulate the {@link DomConfig} used to create a dependency line in a\n * {@link #config-renderer} function.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @mixes Core/mixin/Delayable\n * @mixes Scheduler/feature/mixin/DependencyCreation\n * @mixes Scheduler/feature/mixin/DependencyTooltip\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencies\n * @feature\n */\nexport default class Dependencies extends InstancePlugin.mixin(\n    AttachToProjectMixin,\n    Delayable,\n    DependencyCreation,\n    DependencyGridCache,\n    DependencyLineGenerator,\n    DependencyTooltip\n) {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{DependencyType.SS}',\n        'L{DependencyType.SF}',\n        'L{DependencyType.FS}',\n        'L{DependencyType.FF}',\n        'L{DependencyType.StartToStart}',\n        'L{DependencyType.StartToEnd}',\n        'L{DependencyType.EndToStart}',\n        'L{DependencyType.EndToEnd}',\n        'L{DependencyType.long}',\n        'L{DependencyType.short}'\n    ];\n    // endregion\n    // </debug>\n\n    static $name = 'Dependencies';\n\n    /**\n     * Fired when dependencies are rendered\n     * @on-owner\n     * @event dependenciesDrawn\n     */\n\n    //region Config\n\n    static configurable = {\n        /**\n         * The CSS class to add to a dependency line when hovering over it\n         * @config {String}\n         * @default\n         * @private\n         */\n        overCls : 'b-sch-dependency-over',\n\n        /**\n         * The CSS class applied to dependency lines\n         * @config {String}\n         * @default\n         * @private\n         */\n        baseCls : 'b-sch-dependency',\n\n        /**\n         * The CSS class applied to a too narrow dependency line (to hide markers)\n         * @config {String}\n         * @default\n         * @private\n         */\n        noMarkerCls : 'b-sch-dependency-markerless',\n\n        /**\n         * SVG path definition used as marker (arrow head) for the dependency lines.\n         * Should fit in a viewBox that is 9 x 6.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Circular marker\n         *             markerDef : 'M 2,3 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0'\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @default 'M3,0 L3,6 L9,3 z'\n         */\n        markerDef : null,\n\n        /**\n         * Radius (in px) used to draw arcs where dependency line segments connect. Specify it to get a rounded look.\n         * The radius will during drawing be reduced as needed on a per segment basis to fit lines.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Round the corner where line segments connect, similar to 'border-radius: 5px'\n         *             radius : 5\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * <div class=\"note\">Using a radius slightly degrades dependency rendering performance. If your app displays\n         * a lot of dependencies, it might be worth taking this into account when deciding if you want to use radius\n         * or not</div>\n         *\n         * @config {Number}\n         */\n        radius : null,\n\n        /**\n         * Renderer function, supply one if you want to manipulate the {@link DomConfig} object used to draw a\n         * dependency line between two assignments.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             renderer({ domConfig, fromAssignmentRecord : from, toAssignmentRecord : to }) {\n         *                 // Add a custom CSS class to dependencies between important assignments\n         *                 domConfig.class.important = from.important || to.important;\n         *                 domConfig.class.veryImportant = from.important && to.important;\n         *             }\n         *         }\n         *     }\n         * }\n         * ```\n         *\n         * @param {Object} renderData\n         * @param {DomConfig} renderData.domConfig that will be used to create the dependency line, can be manipulated by the\n         * renderer\n         * @param {Scheduler.model.DependencyModel} renderData.dependencyRecord The dependency being rendered\n         * @param {Scheduler.model.AssignmentModel} renderData.fromAssignmentRecord Drawing line from this assignment\n         * @param {Scheduler.model.AssignmentModel} renderData.toAssignmentRecord Drawing line to this assignment\n         * @param {Object[]} renderData.points A collection of points making up the line segments for the dependency\n         * line. Read-only in the renderer, any manipulation should be done to `domConfig`\n         * @param {Core.helper.util.Rectangle} renderData.fromBox Bounds for the fromAssignment's element\n         * @param {Core.helper.util.Rectangle} renderData.toBox Bounds for the toAssignment's element\n         * @param {'top'|'right'|'bottom'|'left'} renderData.fromSide Drawn from this side of the fromAssignment\n         * @param {'top'|'right'|'bottom'|'left'} renderData.toSide Drawn to this side of the fromAssignment\n         * @prp {Function}\n         */\n        renderer : null,\n\n        /**\n         * Specify `true` to highlight incoming and outgoing dependencies when hovering an event.\n         * @prp {Boolean}\n         */\n        highlightDependenciesOnEventHover : null,\n\n        /**\n         * Specify `false` to prevent dependencies from being drawn during scroll, for smoother scrolling in schedules\n         * with lots of dependencies. Dependencies will be drawn when scrolling stops instead.\n         * @prp {Boolean}\n         * @default\n         */\n        drawOnScroll : true,\n\n        /**\n         * The clickable/touchable width of the dependency line in pixels. Setting this to a number greater than 1 will\n         * draw an invisible but clickable line along the same path as the dependency line, making it easier to click.\n         * The tradeoff is that twice as many lines will be drawn, which can affect performance.\n         * @prp {Number}\n         */\n        clickWidth : null\n    };\n\n    static delayable = {\n        doRefresh : 10\n    };\n\n    static get pluginConfig() {\n        return {\n            chain  : ['render', 'onPaint', 'onElementClick', 'onElementDblClick', 'onElementContextMenu', 'onElementMouseOver', 'onElementMouseOut', 'bindStore'],\n            assign : ['getElementForDependency', 'getElementsForDependency', 'resolveDependencyRecord']\n        };\n    };\n\n    domConfigs  = new Map();\n    drawingLive = false;\n    lastScrollX = null;\n    highlighted = new Map();\n    // Cached lookups\n    visibleResources = null;\n    usingLinks       = null;\n    visibleDateRange = null;\n    relativeTo       = null;\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        const { scheduledEventName } = client;\n\n        client.ion({\n            svgCanvasCreated                            : 'onSVGReady',\n            // These events trigger live refresh behaviour\n            animationStart                              : 'refresh',\n            // eventDrag in Scheduler, taskDrag in Gantt\n            [scheduledEventName + 'DragStart']          : 'refresh',\n            [scheduledEventName + 'DragAbort']          : 'refresh',\n            [scheduledEventName + 'ResizeStart']        : 'refresh',\n            [scheduledEventName + 'SegmentDragStart']   : 'refresh',\n            [scheduledEventName + 'SegmentResizeStart'] : 'refresh',\n            // These events shift the surroundings to such extent that grid cache needs rebuilding to be sure that\n            // all dependencies are considered\n            timelineViewportResize                      : 'reset',\n            timeAxisViewModelUpdate                     : 'reset',\n            toggleNode                                  : 'reset',\n            thisObj                                     : this\n        });\n\n        client.rowManager.ion({\n            refresh           : 'reset', // For example when changing barMargin or rowHeight\n            changeTotalHeight : 'reset', // For example when collapsing groups\n            thisObj           : this\n        });\n\n        this.bindStore(client.store);\n    }\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Need a flag to clear dependencies when disabled, since drawing is otherwise disabled too\n            this._isDisabling = disable;\n            this.draw();\n            this._isDisabling = false;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    //region RefreshTriggers\n\n    get rowStore() {\n        return this.client.isVertical ? this.client.resourceStore : this.client.store;\n    }\n\n    // React to replacing or refreshing a display store\n    bindStore(store) {\n        const me = this;\n\n        if (!me.client.isVertical) {\n            me.detachListeners('store');\n\n            if (me.client.usesDisplayStore) {\n                store?.ion({\n                    name    : 'store',\n                    refresh : 'onStoreRefresh',\n                    thisObj : me\n                });\n\n                me.reset();\n            }\n        }\n    }\n\n    onStoreRefresh() {\n        this.reset();\n    }\n\n    // <remove-on-release>\n    // TODO: Need toggleNode, viewportResize, translateRow, changeTotalHeight, idChange ?\n    // </remove-on-release>\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        project?.ion({\n            name            : 'project',\n            commitFinalized : 'reset',\n            thisObj         : this\n        });\n    }\n\n    attachToResourceStore(resourceStore) {\n        super.attachToResourceStore(resourceStore);\n\n        resourceStore?.ion({\n            name    : 'resourceStore',\n            change  : 'onResourceStoreChange',\n            refresh : 'onResourceStoreChange',\n            thisObj : this\n        });\n    }\n\n    onResourceStoreChange() {\n        // Might have added or removed links, need to re-cache the flag\n        this.usingLinks = null;\n        this.reset();\n    }\n\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n\n        eventStore?.ion({\n            name    : 'eventStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n\n        assignmentStore?.ion({\n            name    : 'assignmentStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    attachToDependencyStore(dependencyStore) {\n        super.attachToDependencyStore(dependencyStore);\n\n        dependencyStore?.ion({\n            name    : 'dependencyStore',\n            change  : 'reset',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    updateDrawOnScroll(drawOnScroll) {\n        const me = this;\n\n        me.detachListeners('scroll');\n\n        if (drawOnScroll) {\n            me.client.ion({\n                name             : 'scroll',\n                scroll           : 'doRefresh',\n                horizontalScroll : 'onHorizontalScroll',\n                prio             : -100, // After Scheduler draws on scroll, since we target elements\n                thisObj          : me\n            });\n        }\n        else {\n            me.client.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n\n            me.client.timeAxisSubGrid.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n        }\n    }\n\n    onHorizontalScroll({ subGrid, scrollX }) {\n        if (scrollX !== this.lastScrollX && subGrid === this.client.timeAxisSubGrid) {\n            this.lastScrollX = scrollX;\n            this.draw();\n        }\n    }\n\n    onPaint() {\n        this.refresh();\n    }\n\n    //endregion\n\n    //region Dependency types\n\n    // Used by DependencyField\n    static getLocalizedDependencyType(type) {\n        return type ? this.L(`L{DependencyType.${type}}`) : '';\n    }\n\n    //endregion\n\n    //region Elements\n\n    getElementForDependency(dependency, fromAssignment, toAssignment) {\n        return this.getElementsForDependency(dependency, fromAssignment, toAssignment)[0];\n    }\n\n    // NOTE: If we ever make this public we should change it to use the syncIdMap. Currently not needed since only\n    // used in tests\n    getElementsForDependency(dependency, fromAssignment, toAssignment) {\n        // Selector targeting all instances of a dependency\n        let selector = `[data-dep-id=\"${dependency.id}\"]`;\n\n        // Optionally narrow it down to a single instance (assignment)\n        if (fromAssignment) {\n            selector += `[data-from-id=\"${fromAssignment.id}\"]`;\n        }\n        if (toAssignment) {\n            selector += `[data-to-id=\"${toAssignment.id}\"]`;\n        }\n\n        return Array.from(this.client.svgCanvas.querySelectorAll(selector));\n    }\n\n    /**\n     * Returns the dependency record for a DOM element\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     */\n    resolveDependencyRecord(element) {\n        return element.elementData?.dependency;\n    }\n\n    isDependencyElement(element) {\n        return element.matches(`.${this.baseCls}`);\n    }\n\n    //endregion\n\n    //region DOM Events\n\n    onElementClick(event) {\n        const dependency = this.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            const eventName = eventNameMap[event.type];\n\n            /**\n             * Fires on the owning Scheduler/Gantt when a context menu event is registered on a dependency line.\n             * @event dependencyContextMenu\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.\n             * @event dependencyClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a double click is registered on a dependency line.\n             * @event dependencyDblClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            this.client.trigger(`dependency${eventName}`, {\n                dependency,\n                event\n            });\n        }\n    }\n\n    onElementDblClick(event) {\n        return this.onElementClick(event);\n    }\n\n    onElementContextMenu(event) {\n        return this.onElementClick(event);\n    }\n\n    onElementMouseOver(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves over a dependency line.\n             * @event dependencyMouseOver\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOver', {\n                dependency,\n                event\n            });\n\n            if (me.overCls) {\n                me.highlight(dependency);\n            }\n        }\n    }\n\n    onElementMouseOut(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves out of a dependency line.\n             * @event dependencyMouseOut\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOut', {\n                dependency,\n                event\n            });\n\n            if (me.overCls) {\n                me.unhighlight(dependency);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Export\n\n    // Export calls this fn to determine if a dependency should be included or not\n    isDependencyVisible(dependency) {\n        const\n            me           = this,\n            { rowStore } = me,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n\n        // Bail out early in case source or target doesn't exist\n        if (!fromEvent || !toEvent) {\n            return false;\n        }\n\n        const\n            fromResource = fromEvent.resource,\n            toResource   = toEvent.resource;\n\n        // Verify these are real existing Resources and not collapsed away (resource not existing in resource store)\n        if (!rowStore.isAvailable(fromResource) || !rowStore.isAvailable(toResource)) {\n            return false;\n        }\n\n        return fromEvent.isModel &&\n            !fromResource.instanceMeta(rowStore).hidden &&\n            !toResource.instanceMeta(rowStore).hidden;\n    }\n\n    //endregion\n\n    //region Highlight\n\n    updateHighlightDependenciesOnEventHover(enable) {\n        const me = this;\n\n        if (enable) {\n            const { client } = me;\n\n            client.ion({\n                name                                       : 'highlightOnHover',\n                [`${client.scheduledEventName}MouseEnter`] : params => me.highlightEventDependencies(params.eventRecord || params.taskRecord),\n                [`${client.scheduledEventName}MouseLeave`] : params => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord),\n                thisObj                                    : me\n            });\n        }\n        else {\n            me.detachListeners('highlightOnHover');\n        }\n    }\n\n    highlight(dependency, cls = this.overCls) {\n        let classes = this.highlighted.get(dependency);\n\n        if (!classes) {\n            this.highlighted.set(dependency, classes = new Set());\n        }\n\n        classes.add(cls);\n\n        // Update element directly instead of refreshing and letting DomSync handle it,\n        // to optimize highlight performance with many dependencies on screen\n        for (const element of this.getElementsForDependency(dependency)) {\n            element.classList.add(cls);\n        }\n    }\n\n    unhighlight(dependency, cls = this.overCls) {\n        const classes = this.highlighted.get(dependency);\n\n        if (classes) {\n            classes.delete(cls);\n\n            if (!classes.size) {\n                this.highlighted.delete(dependency);\n            }\n        }\n\n        // Update element directly instead of refreshing and letting DomSync handle it,\n        // to optimize highlight performance with many dependencies on screen\n        for (const element of this.getElementsForDependency(dependency)) {\n            element.classList.remove(cls);\n        }\n    }\n\n    highlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.highlight(dep, cls));\n    }\n\n    unhighlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.unhighlight(dep, cls));\n    }\n\n    //endregion\n\n    //region Drawing\n\n    // Implemented in DependencyGridCache to return dependencies that might intersect the current viewport and thus\n    // should be considered for drawing. Fallback value here is used when there is no grid cache (which happens when it\n    // is reset. Also useful in case we want to have it configurable or opt out automatically for small datasets)\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        // Get records from grid cache\n        return super.getDependenciesToConsider?.(startMS, endMS, startIndex, endIndex) ??\n            // Falling back to using all valid deps (fix for not trying to draw conflicted deps)\n            this.project.dependencyStore.records.filter(d => d.isValid);\n    }\n\n    // String key used as syncId\n    getDependencyKey(dependency, fromAssignment, toAssignment) {\n        return `dep:${dependency.id};from:${fromAssignment.id};to:${toAssignment.id}`;\n    }\n\n    // <remove-on-release>\n    // Draw a single dependency, if it is in view (overridden in Gantt)\n    // TODO: Was public\n    // </remove-on-release>\n    drawDependency(dependency, batch = false, forceBoxes = null) {\n        const\n            me           = this,\n            {\n                domConfigs,\n                client,\n                rowStore,\n                topIndex,\n                bottomIndex\n            }            = me,\n            {\n                eventStore,\n                useInitialAnimation\n            }            = client,\n            { idMap }    = rowStore,\n            {\n                startMS,\n                endMS\n            }            = me.visibleDateRange,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n\n        let fromAssigned = fromEvent.assigned,\n            toAssigned   = toEvent.assigned;\n\n        if (\n            // No point in trying to draw dep between unscheduled/non-existing events\n            fromEvent.isScheduled && toEvent.isScheduled &&\n            // Or between filtered out events\n            eventStore.includes(fromEvent) && eventStore.includes(toEvent) &&\n            // Or unassigned ones\n            fromAssigned?.size && toAssigned?.size\n        ) {\n            // Add links, if used\n            if (me.usingLinks) {\n                fromAssigned = [...fromAssigned].flatMap(collectLinkedAssignments);\n                toAssigned = [...toAssigned].flatMap(collectLinkedAssignments);\n            }\n\n            for (const from of fromAssigned) {\n                for (const to of toAssigned) {\n                    const\n                        // Using direct lookup in idMap instead of indexOf() for performance.\n                        // Resource might be filtered out or not exist at all\n                        fromIndex  = idMap[from.resource?.id]?.index,\n                        toIndex    = idMap[to.resource?.id]?.index,\n                        fromDateMS = Math.min(fromEvent.startDateMS, toEvent.startDateMS),\n                        toDateMS   = Math.max(fromEvent.endDateMS, toEvent.endDateMS);\n\n                    // Draw only if dependency intersects view, unless it is part of an export\n                    if (\n                        client.isExporting || fromIndex != null && toIndex != null &&\n                        (from.drawDependencies !== false && to.drawDependencies !== false) &&\n                        (rowStore.isAvailable(from.resource) && (rowStore.isAvailable(to.resource))) && !(\n                            // Both ends above view\n                            (fromIndex < topIndex && toIndex < topIndex) ||\n                            // Both ends below view\n                            (fromIndex > bottomIndex && toIndex > bottomIndex) ||\n                            // Both ends before view\n                            (fromDateMS < startMS && toDateMS < startMS) ||\n                            // Both ends after view\n                            (fromDateMS > endMS && toDateMS > endMS)\n                        )\n                    ) {\n                        const\n                            key            = me.getDependencyKey(dependency, from, to),\n                            lineDomConfigs = me.getDomConfigs(dependency, from, to, forceBoxes);\n\n                        if (lineDomConfigs) {\n                            // Allow deps to match animation delay of their events (the bottommost one) when fading in\n                            if (useInitialAnimation) {\n                                lineDomConfigs[0].style = {\n                                    animationDelay : `${Math.max(fromIndex, toIndex) / 20 * 1000}ms`\n                                };\n                            }\n\n                            domConfigs.set(key, lineDomConfigs);\n                        }\n                        // No room to draw a line\n                        else {\n                            domConfigs.delete(key);\n                        }\n                    }\n\n                    // Give mixins a shot at running code after a dependency is drawn. Used by grid cache to cache the\n                    // dependency (when needed)\n                    me.afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n                }\n            }\n        }\n\n        if (!batch) {\n            me.domSync();\n        }\n    }\n\n    // Hooks used by grid cache, to keep code in this file readable\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        super.afterDrawDependency?.(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n    }\n\n    beforeDraw() {\n        super.beforeDraw?.();\n    }\n\n    afterDraw() {\n        super.afterDraw?.();\n    }\n\n    // Update DOM\n    domSync(targetElement = this.client.svgCanvas) {\n        DomSync.sync({\n            targetElement,\n            domConfig : {\n                onlyChildren : true,\n                children     : Array.from(this.domConfigs.values()).flat()\n            },\n            syncIdField      : 'syncId',\n            releaseThreshold : 0,\n            strict           : true,\n            callback() {\n                // <remove-on-release>\n                // TODO: trigger events\n                // </remove-on-release>\n            }\n        });\n    }\n\n    fillDrawingCache() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Cache subgrid bounds for the duration of this draw call to not have to figure it out per dep\n        me.relativeTo = Rectangle.from(client.foregroundCanvas);\n\n        // Cache other lookups too\n        me.visibleResources = client.visibleResources;\n        me.visibleDateRange = client.visibleDateRange;\n\n        me.topIndex     = me.rowStore.indexOf(me.visibleResources.first);\n        me.bottomIndex  = me.rowStore.indexOf(me.visibleResources.last);\n\n        // Cache link lookup, to avoid semi-expensive flatMap calls in drawDependency\n        if (me.usingLinks == null) {\n            me.usingLinks = client.resourceStore.some(r => r.hasLinks);\n        }\n    }\n\n    // Draw all dependencies intersecting the current viewport immediately\n    draw() {\n        const\n            me         = this,\n            { client } = me;\n\n        if (client.refreshSuspended || !client.foregroundCanvas || !client.isEngineReady || (me.disabled && !me._isDisabling) || client.isExporting) {\n            return;\n        }\n\n        me.fillDrawingCache();\n\n        me.domConfigs.clear();\n\n        // Nothing to draw if there are no rows or no ticks or we are disabled\n        if (client.firstVisibleRow && client.lastVisibleRow && client.timeAxis.count && !me.disabled &&\n            (me.visibleDateRange.endMS - me.visibleDateRange.startMS > 0)\n        ) {\n            const\n                { visibleDateRange } = client,\n                {\n                    topIndex,\n                    bottomIndex\n                }                   = me,\n                dependencies        = me.getDependenciesToConsider(visibleDateRange.startMS, visibleDateRange.endMS, topIndex, bottomIndex);\n\n            // Give mixins a shot at doing something before deps are drawn. Used by grid cache to determine if\n            // the cache should be rebuilt\n            me.beforeDraw();\n\n            for (const dependency of dependencies) {\n                me.drawDependency(dependency, true);\n            }\n\n            // Give mixins a shot at doing something after all deps are drawn\n            me.afterDraw();\n        }\n\n        me.domSync();\n\n        client.trigger('dependenciesDrawn');\n    }\n\n    //endregion\n\n    //region Refreshing\n\n    // Performs a draw on next frame, not intended to be called directly, call refresh() instead\n    doRefresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { scheduledEventName } = client;\n\n        me.draw();\n\n        // Refresh each frame during animations, during dragging & resizing  (if we have dependencies)\n        me.drawingLive = client.dependencyStore.count &&\n            (\n                client.isAnimating || (client.useInitialAnimation && client.eventStore.count) ||\n                client.features[`${scheduledEventName}Drag`]?.isActivelyDragging ||\n                client.features[`${scheduledEventName}Resize`]?.isResizing ||\n                client.features[`${scheduledEventName}SegmentDrag`]?.isActivelyDragging ||\n                client.features[`${scheduledEventName}SegmentResize`]?.isResizing\n            );\n\n        me.drawingLive && me.refresh();\n    }\n\n    /**\n     * Redraws dependencies on the next animation frame\n     */\n    refresh() {\n        const { client } = this;\n\n        // Queue up a draw unless refresh is suspended\n        if (!client.refreshSuspended && !this.disabled && client.isPainted && !client.timeAxisSubGrid.collapsed) {\n            this.doRefresh();\n        }\n    }\n\n    // Resets grid cache and performs a draw on next frame. Conditions when it should be called:\n    // * Zooming\n    // * Shifting time axis\n    // * Resizing window\n    // * CRUD\n    // ...\n    reset() {\n        super.reset?.();\n        this.refresh();\n    }\n\n    /**\n     * Draws all dependencies for the specified task.\n     * @deprecated 5.1 The Dependencies feature was refactored and this fn is no longer needed\n     */\n    drawForEvent() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Dependencies.drawForEvent() is no longer needed');\n        this.refresh();\n    }\n\n    //endregion\n\n    //region Scheduler hooks\n\n    render() {\n        // Pull in the svg canvas early to have it available during drawing\n        this.client.getConfig('svgCanvas');\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(Dependencies, false, ['Scheduler', 'ResourceHistogram']);\nGridFeatureManager.registerFeature(Dependencies, true, 'SchedulerPro');\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\n\n/**\n * @module Scheduler/feature/EventFilter\n */\n\n/**\n * Adds event filter menu items to the timeline header context menu.\n *\n * {@inlineexample Scheduler/feature/EventFilter.js}\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *   features : {\n *     eventFilter : true // `true` by default, set to `false` to disable the feature and remove the menu item from the timeline header\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventFilter\n * @feature\n */\nexport default class EventFilter extends InstancePlugin {\n\n    static get $name() {\n        return 'EventFilter';\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['populateTimeAxisHeaderMenu']\n        };\n    }\n\n    /**\n     * Populates the header context menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        const me = this;\n\n        items.eventsFilter = {\n            text        : 'L{filterEvents}',\n            icon        : 'b-fw-icon b-icon-filter',\n            disabled    : me.disabled,\n            localeClass : me,\n            weight      : 100,\n            menu        : {\n                type        : 'popup',\n                localeClass : me,\n                items       : {\n                    nameFilter : {\n                        weight               : 110,\n                        type                 : 'textfield',\n                        cls                  : 'b-eventfilter b-last-row',\n                        clearable            : true,\n                        keyStrokeChangeDelay : 300,\n                        label                : 'L{byName}',\n                        localeClass          : me,\n                        width                : 200,\n                        internalListeners    : {\n                            change  : me.onEventFilterChange,\n                            thisObj : me\n                        }\n                    }\n                },\n                onBeforeShow({ source : menu }) {\n                    const\n                        [filterByName] = menu.items,\n                        filter         = me.store.filters.getBy('property', 'name');\n\n                    filterByName.value = filter?.value || '';\n                }\n            }\n        };\n    }\n\n    onEventFilterChange({ value }) {\n        if (value !== '') {\n            this.store.filter('name', value);\n        }\n        else {\n            this.store.removeFilter('name');\n        }\n    }\n\n    get store() {\n        const { client } = this;\n\n        return client.isGanttBase ? client.store : client.eventStore;\n    }\n}\n\nEventFilter.featureClass = 'b-event-filter';\n\nGridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);\nGridFeatureManager.registerFeature(EventFilter, false, 'ResourceHistogram');\n", "import DateHelper from '../../../Core/helper/DateHelper.js';\nimport TimeSpan from '../../model/TimeSpan.js';\n\n/**\n * @module Scheduler/feature/mixin/NonWorkingTimeMixin\n */\n\n/**\n * Mixin with functionality shared between {@link Scheduler/feature/NonWorkingTime} and\n * {@link Scheduler/feature/EventNonWorkingTime}.\n * @mixin\n */\nexport default Target => class NonWorkingTimeMixin extends Target {\n    static $name = 'NonWorkingTimeMixin';\n\n    static configurable = {\n        /**\n         * The maximum time axis unit to display non-working ranges for ('hour' or 'day' etc).\n         * When zooming to a view with a larger unit, no non-working time elements will be rendered.\n         *\n         * **Note:** Be careful with setting this config to big units like 'year'. When doing this,\n         * make sure the timeline {@link Scheduler/view/TimelineBase#config-startDate start} and\n         * {@link Scheduler/view/TimelineBase#config-endDate end} dates are set tightly.\n         * When using a long range (for example many years) with non-working time elements rendered per hour,\n         * you will end up with millions of elements, impacting performance.\n         * When zooming, use the {@link Scheduler/view/mixin/TimelineZoomable#config-zoomKeepsOriginalTimespan} config.\n         * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n         * @default\n         */\n        maxTimeAxisUnit : 'week'\n    };\n\n    getNonWorkingTimeRanges(calendar, startDate, endDate) {\n        if (!calendar.getNonWorkingTimeRanges) {\n            const result = [];\n\n            // <remove-on-release>\n            // TODO: Ask arcady if there is a built-in way for this\n            // </remove-on-release>\n\n            calendar.forEachAvailabilityInterval(\n                { startDate, endDate, isForward : true },\n                (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                    for (const [entry, cache] of calendarCacheInterval.intervalGroups) {\n                        if (!cache.getIsWorking()) {\n                            result.push({\n                                name      : entry.name,\n                                iconCls   : entry.iconCls,\n                                cls       : entry.cls,\n                                startDate : intervalStartDate,\n                                endDate   : intervalEndDate\n                            });\n                        }\n                    }\n                }\n            );\n\n            return result;\n        }\n\n        return calendar.getNonWorkingTimeRanges(startDate, endDate);\n    }\n\n    getCalendarTimeRanges(calendar, ignoreName = false) {\n        const\n            me                      = this,\n            { timeAxis, fillTicks } = me.client,\n            { unit, increment }     = timeAxis,\n            shouldPaint             = !me.maxTimeAxisUnit || DateHelper.compareUnits(unit, me.maxTimeAxisUnit) <= 0;\n\n        if (calendar && shouldPaint && timeAxis.count) {\n            const\n                allRanges     = me.getNonWorkingTimeRanges(calendar, timeAxis.startDate, timeAxis.endDate),\n                timeSpans     = allRanges.map(interval => new TimeSpan({\n                    name      : interval.name,\n                    cls       : `b-nonworkingtime ${interval.cls || ''}`,\n                    startDate : interval.startDate,\n                    endDate   : interval.endDate\n                })),\n                mergedSpans = [];\n\n            let prevRange = null;\n\n            // intervals returned by the calendar are not merged, let's combine them to yield fewer elements\n            for (const range of timeSpans) {\n                if (prevRange && range.startDate <= prevRange.endDate && (ignoreName || range.name === prevRange.name) && range.duration > 0) {\n                    prevRange.endDate = range.endDate;\n                }\n                else {\n                    mergedSpans.push(range);\n                    range.setData('id', `nonworking-${mergedSpans.length}`);\n                    prevRange = range;\n                }\n            }\n\n            // When filling ticks, non-working-time ranges are cropped to full ticks too\n            if (fillTicks) {\n                mergedSpans.forEach(span => {\n                    span.setStartEndDate(\n                        DateHelper.ceil(span.startDate, { magnitude : increment, unit }),\n                        DateHelper.floor(span.endDate, { magnitude : increment, unit })\n                    );\n                });\n            }\n\n            return mergedSpans;\n        }\n        else {\n            return [];\n        }\n    }\n\n    //region Basic scheduler calendar\n\n    setupDefaultCalendar() {\n        const { client, project } = this;\n\n        if (\n            // Might have been set up by NonWorkingTime / EventNonWorkingTime already\n            !this.autoGeneratedWeekends &&\n            // For basic scheduler...\n            !client.isSchedulerPro &&\n            !client.isGantt &&\n            // ...that uses the default calendar...\n            project.effectiveCalendar === project.defaultCalendar &&\n            // ...and has no defined intervals\n            !project.defaultCalendar.intervalStore.count\n        ) {\n            this.autoGeneratedWeekends = true;\n            this.updateDefaultCalendar();\n        }\n    }\n\n    updateDefaultCalendar() {\n        if (this.autoGeneratedWeekends) {\n            const\n                calendar     = this.client.project.effectiveCalendar,\n                intervals    = this.defaultNonWorkingIntervals,\n                hasIntervals = Boolean(intervals.length);\n\n            calendar.clearIntervals(hasIntervals);\n\n            // Update weekends as non-working time\n            if (hasIntervals) {\n                calendar.addIntervals(intervals);\n            }\n        }\n    }\n\n    updateLocalization() {\n        super.updateLocalization?.();\n\n        this.autoGeneratedWeekends && this.updateDefaultCalendar();\n    }\n\n    get defaultNonWorkingIntervals() {\n        const dayNames  = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\n        return DateHelper.nonWorkingDaysAsArray.map(dayIndex => ({\n            recurrentStartDate : `on ${dayNames[dayIndex]} at 0:00`,\n            recurrentEndDate   : `on ${dayNames[(dayIndex + 1) % 7]} at 0:00`,\n            isWorking          : false\n        }));\n    }\n\n    //endregion\n};\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport NonWorkingTimeMixin from './mixin/NonWorkingTimeMixin.js';\n\n/**\n * @module Scheduler/feature/NonWorkingTime\n */\n\n/**\n * Feature that allows styling of weekends (and other non working time) by adding timeRanges for those days.\n *\n * {@inlineexample Scheduler/feature/NonWorkingTime.js}\n *\n * By default, the basic Scheduler's calendar is empty. When enabling this feature in the basic Scheduler, it injects\n * Saturday and Sunday weekend intervals if no intervals are encountered. For Scheduler Pro, it visualizes the project\n * calendar and does not automatically inject anything. You have to define a Calendar in the application and assign it\n * to the project, for more information on how to do that, please see Scheduler Pro's Scheduling/Calendars guide.\n *\n * Please note that to not clutter the view (and have a large negative effect on performance) the feature does not\n * render ranges shorter than the base unit used by the time axis. The behavior can be disabled with\n * {@link #config-hideRangesOnZooming} config.\n *\n * The feature also bails out of rendering ranges for very zoomed out views completely for the same reasons (see\n * {@link #config-maxTimeAxisUnit} for details).\n *\n * Also note that the feature uses virtualized rendering, only the currently visible non-working-time ranges are\n * available in the DOM.\n *\n * This feature is **off** by default for Scheduler, but **enabled** by default for Scheduler Pro.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @demo Scheduler/nonworkingdays\n * @classtype nonWorkingTime\n * @mixes Scheduler/feature/mixin/NonWorkingTimeMixin\n * @feature\n */\nexport default class NonWorkingTime extends AbstractTimeRanges.mixin(AttachToProjectMixin, NonWorkingTimeMixin) {\n    //region Default config\n\n    static $name = 'NonWorkingTime';\n\n    /** @hideconfigs enableResizing, store*/\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to `true` to highlight non working periods of time\n             * @config {Boolean}\n             * @deprecated Since 5.2.0, will be removed since the feature is pointless if set to false\n             */\n            highlightWeekends : null,\n\n            /**\n             * The feature by default does not render ranges smaller than the base unit used by the time axis.\n             * Set this config to `false` to disable this behavior.\n             *\n             * <div class=\"note\">The {@link #config-maxTimeAxisUnit} config defines a zoom level at which to bail out of\n             * rendering ranges completely.</div>\n             * @config {Boolean}\n             * @default\n             */\n            hideRangesOnZooming : true,\n\n            showHeaderElements : true,\n            showLabelInBody    : true,\n\n            autoGeneratedWeekends : false\n        };\n    }\n\n    static pluginConfig = {\n        chain : [\n            'onPaint',\n            'attachToProject',\n            'updateLocalization',\n            'onConfigChange',\n            'onSchedulerHorizontalScroll'\n        ]\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.attachToCalendar(null);\n        super.doDestroy();\n    }\n\n    set highlightWeekends(highlight) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Deprecated in favour of disabling the feature');\n\n        this.disabled = !highlight;\n    }\n\n    get highlightWeekends() {\n        return !this.disabled;\n    }\n\n    onConfigChange({ name }) {\n        if (!this.isConfiguring && name === 'fillTicks') {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        this.attachToCalendar(project.effectiveCalendar);\n\n        // if there's no graph yet - need to delay this call until it appears, but not for scheduler\n        if (!project.graph && !this.client.isScheduler) {\n            project.ion({\n                name      : 'project',\n                dataReady : { fn : () => this.attachToCalendar(project.effectiveCalendar), once : true },\n                thisObj   : this\n            });\n        }\n\n        project.ion({\n            name           : 'project',\n            calendarChange : () => this.attachToCalendar(project.effectiveCalendar),\n            thisObj        : this\n        });\n    }\n\n    //endregion\n\n    //region TimeAxisViewModel\n\n    onTimeAxisViewModelUpdate(...args) {\n        this._timeAxisUnitDurationMs = null;\n        return super.onTimeAxisViewModelUpdate(...args);\n    }\n\n    //endregion\n\n    //region Calendar\n\n    attachToCalendar(calendar) {\n        const\n            me                  = this,\n            { project, client } = me;\n\n        me.detachListeners('calendar');\n\n        me.autoGeneratedWeekends = false;\n\n        if (calendar) {\n            // Sets up a default weekend calendar for basic Scheduler, when no calendar is set\n            me.setupDefaultCalendar();\n\n            calendar.intervalStore.ion({\n                name   : 'calendar',\n                change : () => me.setTimeout(() => me.refresh(), 1)\n            });\n        }\n\n        // On changing calendar we react to a data level event which is triggered after project refresh.\n        // Redraw right away\n        if (client.isEngineReady && !client.project.isDelayingCalculation && !client.isDestroying) {\n            me.refresh();\n        }\n        // Initially there is no guarantee we are ready to draw, wait for refresh\n        else if (!project.isDestroyed) {\n            me.detachListeners('initialProjectListener');\n            project.ion({\n                name : 'initialProjectListener',\n                refresh({ isCalculated }) {\n                    // Cant render early, have to wait for calculations\n                    if (isCalculated !== false) {\n                        me.refresh();\n                        me.detachListeners('initialProjectListener');\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    get calendar() {\n        return this.project?.effectiveCalendar;\n    }\n\n    //endregion\n\n    //region Draw\n\n    get timeAxisUnitDurationMs() {\n        // calculate and cache duration of the timeAxis unit in milliseconds\n        if (!this._timeAxisUnitDurationMs) {\n            this._timeAxisUnitDurationMs = DateHelper.as('ms', 1, this.client.timeAxis.unit);\n        }\n\n        return this._timeAxisUnitDurationMs;\n    }\n\n    /**\n     * Based on this method result the feature decides whether the provided non-working period should\n     * be rendered or not.\n     * The method checks that the range has non-zero {@link Scheduler.model.TimeSpan#field-duration},\n     * lays in the visible timespan and its duration is longer or equal the base timeaxis unit\n     * (if {@link #config-hideRangesOnZooming} is `true`).\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(range) {\n        // if the range is longer or equal than one timeAxis unit then render it\n        return super.shouldRenderRange(range) && (!this.hideRangesOnZooming || range.durationMS >= this.timeAxisUnitDurationMs);\n    }\n\n    // Calendar intervals as TimeSpans, with adjacent intervals merged to create fewer\n    get timeRanges() {\n        const me = this;\n\n        if (!me._timeRanges) {\n            me._timeRanges = me.getCalendarTimeRanges(me.calendar);\n        }\n\n        return me._timeRanges;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(NonWorkingTime, false, 'Scheduler');\nGridFeatureManager.registerFeature(NonWorkingTime, true, ['SchedulerPro', 'Gantt', 'ResourceHistogram']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/ScheduleTooltip\n */\n\n/**\n * Feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule.\n * To hide the schedule tooltip, just disable this feature:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : false\n *     }\n * });\n * ```\n *\n * You can also output a message along with the default time indicator (to indicate resource availability etc)\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    features : {\n *       scheduleTooltip : {\n *           getText(date, event, resource) {\n *               return 'Hovering ' + resource.name;\n *           }\n *       }\n *   }\n * });\n * ```\n *\n * To take full control over the markup shown in the tooltip you can override the {@link #function-generateTipContent} method:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             generateTipContent({ date, event, resourceRecord }) {\n *                 return `\n *                     <dl>\n *                         <dt>Date</dt><dd>${date}</dd>\n *                         <dt>Resource</dt><dd>${resourceRecord.name}</dd>\n *                     </dl>\n *                 `;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Configuration properties from the feature are passed down into the resulting {@link Core.widget.Tooltip} instance.\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             // Don't show the tip until the mouse has been over the schedule for three seconds\n *             hoverDelay : 3000\n *         }\n *     }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/ScheduleTooltip.js\n * @classtype scheduleTooltip\n * @feature\n */\nexport default class ScheduleTooltip extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'ScheduleTooltip';\n    }\n\n    static get configurable() {\n        return {\n            messageTemplate : data => `<div class=\"b-sch-hovertip-msg\">${data.message}</div>`,\n\n            /**\n             * Set to `true` to hide this tooltip when hovering non-working time. Defaults to `false` for Scheduler,\n             * `true` for SchedulerPro\n             * @config {Boolean}\n             */\n            hideForNonWorkingTime : null\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    /**\n     * Set up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        if (!firstPaint) {\n            return;\n        }\n\n        const\n            me         = this,\n            { client } = me;\n\n        if (client.isSchedulerPro && me.hideForNonWorkingTime === undefined) {\n            me.hideForNonWorkingTime = true;\n        }\n\n        let reshowListener;\n\n        const tip = me.hoverTip = new Tooltip({\n            id                       : `${client.id}-schedule-tip`,\n            cls                      : 'b-sch-scheduletip',\n            allowOver                : true,\n            hoverDelay               : 0,\n            hideDelay                : 100,\n            showOnHover              : true,\n            forElement               : client.timeAxisSubGridElement,\n            anchorToTarget           : false,\n            trackMouse               : true,\n            updateContentOnMouseMove : true,\n            // disable text content and monitor resize for tooltip, otherwise it doesn't\n            // get sized properly on first appearance\n            monitorResize            : false,\n            textContent              : false,\n            forSelector              : '.b-schedulerbase:not(.b-dragging-event):not(.b-dragcreating) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            getHtml                  : me.getHoverTipHtml.bind(me),\n            onDocumentMouseDown(event) {\n                // Click on the scheduler hides until the very next\n                // non-button-pressed mouse move!\n                if (tip.forElement.contains(event.event.target)) {\n                    reshowListener = EventHelper.on({\n                        thisObj   : me,\n                        element   : client.timeAxisSubGridElement,\n                        mousemove : e => tip.internalOnPointerOver(e),\n                        capture   : true\n                    });\n                }\n\n                const hideAnimation = tip.hideAnimation;\n                tip.hideAnimation = false;\n                tip.constructor.prototype.onDocumentMouseDown.call(tip, event);\n                tip.hideAnimation = hideAnimation;\n            },\n            // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n            // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n            // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n            // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n            ...me.config,\n            internalListeners : me.configuredListeners\n        });\n\n        // We have to add our own listener after instantiation because it may conflict with a configured listener\n        tip.ion({\n            pointerover({ event }) {\n                const buttonsPressed = 'buttons' in event ? event.buttons > 0\n                    : event.which > 0; // fallback for Safari which doesn't support 'buttons'\n\n                // This is the non-button-pressed mousemove\n                // after the document mousedown\n                if (!buttonsPressed && reshowListener) {\n                    reshowListener();\n                }\n\n                // Never any tooltip while interaction is ongoing and a mouse button is pressed\n                return !me.disabled && !buttonsPressed;\n            },\n            innerhtmlupdate({ source }) {\n                me.clockTemplate.updateDateIndicator(source.element, me.lastTime);\n            }\n        });\n\n        // Update tooltip after zooming\n        client.ion({\n            timeAxisViewModelUpdate : 'updateTip',\n            thisObj                 : me\n        });\n\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n    }\n\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n\n    updateTip() {\n        if (this.hoverTip.isVisible) {\n            this.hoverTip.updateContent();\n        }\n    }\n\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'hoverTip');\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Contents\n\n    /**\n     * @deprecated Use {@link #function-generateTipContent} instead.\n     * Gets html to display in hover tooltip (tooltip displayed on empty parts of scheduler)\n     * @private\n     */\n    getHoverTipHtml({ tip, event }) {\n        const\n            me        = this,\n            scheduler = me.client,\n            date      = event && scheduler.getDateFromDomEvent(event, 'floor', true);\n\n        let html      = me.lastHtml;\n\n        // event.target might be null in the case of being hosted in a web component https://github.com/bryntum/bryntum-suite/pull/4488\n        if (date && event.target) {\n            const resourceRecord = scheduler.resolveResourceRecord(event);\n\n            // resourceRecord might be null if user hover over the tooltip, but we shouldn't hide the tooltip in this case\n            if ((resourceRecord && (date - me.lastTime !== 0 || resourceRecord.id !== me.lastResourceId))) {\n                if (me.hideForNonWorkingTime) {\n                    const isWorkingTime = resourceRecord.isWorkingTime(date);\n\n                    tip.element.classList.toggle('b-nonworking-time', !isWorkingTime);\n                }\n\n                me.lastResourceId = resourceRecord.id;\n                html              = me.lastHtml = me.generateTipContent({ date, event, resourceRecord });\n            }\n        }\n        else {\n            tip.hide();\n            me.lastTime = null;\n            me.lastResourceId = null;\n        }\n\n        return html;\n    }\n\n    /**\n     * Called as mouse pointer is moved over a new resource or time block. You can override this to show\n     * custom HTML in the tooltip.\n     * @param {Object} context\n     * @param {Date} context.date The date of the hovered point\n     * @param {Event} context.event The DOM event that triggered this tooltip to show\n     * @param {Scheduler.model.ResourceModel} context.resourceRecord The resource record\n     * @returns {String} The HTML contents to show in the tooltip (an empty return value will hide the tooltip)\n     */\n    generateTipContent({ date, event, resourceRecord }) {\n        const\n            me          = this,\n            clockHtml   = me.clockTemplate.generateContent({\n                date,\n                text : me.client.getFormattedDate(date)\n            }),\n            messageHtml = me.messageTemplate({\n                message : me.getText(date, event, resourceRecord) || ''\n            });\n\n        me.lastTime = date;\n\n        return clockHtml + messageHtml;\n    }\n\n    /**\n     * Override this to render custom text to default hover tip\n     * @param {Date} date\n     * @param {Event} event Browser event\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @returns {String}\n     */\n    getText(date, event, resourceRecord) {}\n\n    //endregion\n}\n\n// <remove-on-release>\n// TODO: Refactor SASS so that auto-generated class name of 'b-' + cls.name.toLowerCase() can be used.\n// </remove-on-release>\nScheduleTooltip.featureClass = 'b-scheduletip';\n\nGridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(ScheduleTooltip, false, 'ResourceUtilization');\n", "import HeaderMenu from '../../Grid/feature/HeaderMenu.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport '../../Core/widget/Slider.js';\n\n/**\n * @module Scheduler/feature/TimeAxisHeaderMenu\n */\nconst setTimeSpanOptions = {\n    maintainVisibleStart : true\n};\n\n/**\n * Adds scheduler specific menu items to the timeline header context menu.\n *\n * ## Default timeaxis header menu items\n *\n * Here is the list of menu items provided by this and other features:\n *\n * | Reference          | Text                  | Weight | Feature                                           | Description                  |\n * |--------------------|-----------------------|--------|---------------------------------------------------|------------------------------|\n * | `eventsFilter`     | Filter tasks          | 100    | {@link Scheduler.feature.EventFilter EventFilter} | Submenu for event filtering  |\n * | \\>`nameFilter`     | By name               | 110    | {@link Scheduler.feature.EventFilter EventFilter} | Filter by `name`             |\n * | `zoomLevel`        | Zoom                  | 200    | *This feature*                                    | Submenu for timeline zooming |\n * | \\>`zoomSlider`     | -                     | 210    | *This feature*                                    | Changes current zoom level   |\n * | `dateRange`        | Date range            | 300    | *This feature*                                    | Submenu for timeline range   |\n * | \\>`startDateField` | Start date            | 310    | *This feature*                                    | Start date for the timeline  |\n * | \\>`endDateField`   | End date              | 320    | *This feature*                                    | End date for the timeline    |\n * | \\>`leftShiftBtn`   | <                     | 330    | *This feature*                                    | Shift backward               |\n * | \\>`todayBtn`       | Today                 | 340    | *This feature*                                    | Go to today                  |\n * | \\>`rightShiftBtn`  | \\>                    | 350    | *This feature*                                    | Shift forward                |\n * | `currentTimeLine`  | Show current timeline | 400    | {@link Scheduler.feature.TimeRanges TimeRanges}   | Show current time line       |\n *\n * \\> - first level of submenu\n *\n * ## Customizing the menu items\n *\n * The menu items in the TimeAxis Header menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * ### Add extra items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem() {\n *                         ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : {\n *                     text : 'Scale'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customizing submenu items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *      features : {\n *          timeAxisHeaderMenu : {\n *              items : {\n *                  dateRange : {\n *                      menu : {\n *                          items : {\n *                              todayBtn : {\n *                                  text : 'Now'\n *                              }\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n * });\n * ```\n *\n * ### Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ items }) {\n *                  // Add an extra item dynamically\n *                 items.coolItem = {\n *                     text : 'Cool action',\n *                     onItem() {\n *                           // ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the [\"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\"](#Scheduler/guides/customization/contextmenu.md)\n * guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Grid/feature/HeaderMenu\n * @demo Scheduler/basic\n * @classtype timeAxisHeaderMenu\n * @feature\n * @inlineexample Scheduler/feature/TimeAxisHeaderMenu.js\n */\nexport default class TimeAxisHeaderMenu extends HeaderMenu {\n\n    //region Config\n\n    static get $name() {\n        return 'TimeAxisHeaderMenu';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             *   features         : {\n             *       timeAxisHeaderMenu : {\n             *           processItems({ items }) {\n             *               // Add or hide existing items here as needed\n             *               items.myAction = {\n             *                   text   : 'Cool action',\n             *                   icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                   onItem : () => console.log('Some coolness'),\n             *                   weight : 300 // Move to end\n             *               };\n             *\n             *               // Hide zoom slider\n             *               items.zoomLevel.hidden = true;\n             *           }\n             *       }\n             *   },\n             * ```\n             *\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null,\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed in the intro section of this class. You can\n             * configure existing items by passing a configuration object to the keyed items.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         timeAxisHeaderMenu : {\n             *             items : {\n             *                 eventsFilter : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n\n            type : 'timeAxisHeader'\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateTimeAxisHeaderMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for the time axis header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event timeAxisHeaderMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    /**\n     * This event fires on the owning Scheduler after the context menu is shown for a header\n     * @event timeAxisHeaderMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the header context menu.\n     * @event timeAxisHeaderMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    //endregion\n\n    construct() {\n        super.construct(...arguments);\n\n        if (this.triggerEvent.includes('click') && this.client.zoomOnTimeAxisDoubleClick) {\n            this.client.zoomOnTimeAxisDoubleClick = false;\n        }\n    }\n\n    shouldShowMenu(eventParams) {\n        const\n            { column, targetElement } = eventParams,\n            { client } = this;\n\n        if (client.isHorizontal) {\n            return column?.enableHeaderContextMenu !== false && column?.isTimeAxisColumn;\n        }\n\n        return targetElement.matches('.b-sch-header-timeaxis-cell');\n    }\n\n    showContextMenu(eventParams) {\n        super.showContextMenu(...arguments);\n\n        if (this.menu) {\n            // the TimeAxis's context menu probably will cause scrolls because it manipulates the dates.\n            // The menu should not hide on scroll when for a TimeAxisColumn\n            this.menu.scrollAction = 'realign';\n        }\n    }\n\n    populateTimeAxisHeaderMenu({ items }) {\n        const\n            me         = this,\n            { client } = me,\n            dateStep   = {\n                magnitude : client.timeAxis.shiftIncrement,\n                unit      : client.timeAxis.shiftUnit\n            };\n\n        Object.assign(items, {\n            zoomLevel : {\n                text        : 'L{pickZoomLevel}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search-plus',\n                disabled    : !client.presets.count || me.disabled,\n                weight      : 200,\n                menu        : {\n                    type  : 'popup',\n                    items : {\n                        zoomSlider : {\n                            weight               : 210,\n                            type                 : 'slider',\n                            minWidth             : 130,\n                            showValue            : false,\n                            // so that we can use the change event which is easier to inject in tests\n                            triggerChangeOnInput : true\n                        }\n                    },\n                    onBeforeShow({ source : menu }) {\n                        const [zoom] = menu.items;\n\n                        zoom.min = client.minZoomLevel;\n                        zoom.max = client.maxZoomLevel;\n                        zoom.value = client.zoomLevel;\n\n                        // Default slider value is 50 which causes the above to trigger onZoomSliderChange (when\n                        // maxZoomLevel < 50) if we add our listener prior to this point.\n                        me.zoomDetatcher = zoom.ion({ change : 'onZoomSliderChange', thisObj : me });\n                    },\n                    onHide() {\n                        if (me.zoomDetatcher) {\n                            me.zoomDetatcher();\n                            me.zoomDetatcher = null;\n                        }\n                    }\n                }\n            },\n            dateRange : {\n                text        : 'L{activeDateRange}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-calendar',\n                weight      : 300,\n                menu        : {\n                    type     : 'popup',\n                    cls      : 'b-sch-timeaxis-menu-daterange-popup',\n                    defaults : {\n                        localeClass : me\n                    },\n                    items : {\n                        startDateField : {\n                            type              : 'datefield',\n                            label             : 'L{startText}',\n                            weight            : 310,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        endDateField : {\n                            type              : 'datefield',\n                            label             : 'L{endText}',\n                            weight            : 320,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        leftShiftBtn : {\n                            type              : 'button',\n                            weight            : 330,\n                            cls               : 'b-left-nav-btn',\n                            icon              : 'b-icon b-icon-previous',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            margin            : 0,\n                            internalListeners : {\n                                click   : me.onLeftShiftBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        todayBtn : {\n                            type              : 'button',\n                            weight            : 340,\n                            cls               : 'b-today-nav-btn',\n                            color             : 'b-blue b-raised',\n                            text              : 'L{todayText}',\n                            flex              : 4,\n                            margin            : '0 8',\n                            internalListeners : {\n                                click   : me.onTodayBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        rightShiftBtn : {\n                            type              : 'button',\n                            weight            : 350,\n                            cls               : 'b-right-nav-btn',\n                            icon              : 'b-icon b-icon-next',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            internalListeners : {\n                                click   : me.onRightShiftBtnClick,\n                                thisObj : me\n                            }\n                        }\n                    },\n                    internalListeners : {\n                        paint   : me.initDateRangeFields,\n                        thisObj : me\n                    }\n                }\n            }\n        });\n    }\n\n    onZoomSliderChange({ value }) {\n        const me = this;\n\n        // Zooming maintains timeline center point by scrolling the newly rerendered timeline to the\n        // correct point to maintain the visual center. Temporarily inhibit context menu hide on scroll\n        // of its context element.\n        me.menu.scrollAction = 'realign';\n\n        me.client.zoomLevel = value;\n\n        me.menu.setTimeout({\n            fn                : () => me.menu.scrollAction = 'hide',\n            delay             : 100,\n            cancelOutstanding : true\n        });\n    }\n\n    initDateRangeFields({ source : dateRange, firstPaint }) {\n        if (firstPaint) {\n            const { widgetMap } = dateRange;\n\n            this.startDateField = widgetMap.startDateField;\n            this.endDateField = widgetMap.endDateField;\n        }\n\n        this.initDates();\n    }\n\n    initDates() {\n        const me = this;\n\n        me.startDateField.suspendEvents();\n        me.endDateField.suspendEvents();\n\n        // The actual scheduler start dates may include time, but our Date field cannot currently handle\n        // a time portion and throws it away, so when we need the value from an unchanged field, we need\n        // to use the initialValue set from the timeAxis values.\n        // Until our DateField can optionally include a time value, this is the solution.\n        me.startDateField.value = me.startDateFieldInitialValue = me.client.startDate;\n        me.endDateField.value = me.endDateFieldInitialValue = me.client.endDate;\n\n        me.startDateField.resumeEvents();\n        me.endDateField.resumeEvents();\n    }\n\n    onRangeDateFieldChange({ source }) {\n        const\n            me               = this,\n            startDateChanged = (source === me.startDateField),\n            { client }       = me,\n            { timeAxis }     = client,\n            startDate        = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value;\n\n        let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;\n\n        // When either of the fields is changed, we no longer use its initialValue from the timeAxis start or end\n        // so that gets nulled to indicate that it's unavailable and the real field value is to be used.\n        if (startDateChanged) {\n            me.startDateFieldInitialValue = null;\n        }\n        else {\n            me.endDateFieldInitialValue = null;\n        }\n\n        // Because the start and end dates are exclusive, avoid a zero\n        // length time axis by incrementing the end by one tick unit\n        // if they are the same.\n        if (!(endDate - startDate)) {\n            endDate = DateHelper.add(endDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n        // if start date got bigger than end date set end date to start date plus one tick\n        else if (endDate < startDate) {\n            endDate = DateHelper.add(startDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n\n        // setTimeSpan will try to keep the scroll position the same.\n        client.setTimeSpan(startDate, endDate, setTimeSpanOptions);\n\n        me.initDates();\n    }\n\n    onLeftShiftBtnClick() {\n        this.client.timeAxis.shiftPrevious();\n        this.initDates();\n    }\n\n    onTodayBtnClick() {\n        const today = DateHelper.clearTime(new Date());\n\n        this.client.setTimeSpan(today, DateHelper.add(today, 1, 'day'));\n        this.initDates();\n    }\n\n    onRightShiftBtnClick() {\n        this.client.timeAxis.shiftNext();\n        this.initDates();\n    }\n}\n\nGridFeatureManager.registerFeature(TimeAxisHeaderMenu, true, ['Scheduler', 'Gantt']);\nGridFeatureManager.registerFeature(TimeAxisHeaderMenu, false, 'ResourceHistogram');\n", "import DH from '../../../Core/helper/DateHelper.js';\nimport Events from '../../../Core/mixin/Events.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ViewPreset from '../../preset/ViewPreset.js';\nimport '../../data/TimeAxis.js';\n\n/**\n * @module Scheduler/view/model/TimeAxisViewModel\n */\n\n/**\n * This class is an internal view model class, describing the visual representation of a {@link Scheduler.data.TimeAxis}.\n * The config for the header rows is described in the {@link Scheduler.preset.ViewPreset#field-headers headers}.\n * To calculate the size of each cell in the time axis, this class requires:\n *\n * - availableSpace  - The total width or height available for the rendering\n * - tickSize       - The fixed width or height of each cell in the lowest header row. This value is normally read from the\n * {@link Scheduler.preset.ViewPreset viewPreset} but this can also be updated programmatically using the {@link #property-tickSize} setter\n *\n * Normally you should not interact with this class directly.\n *\n * @extends Core/mixin/Events\n */\nexport default class TimeAxisViewModel extends Events() {\n    //region Default config\n\n    // <remove-on-release>\n    // TODO: replace _availableSpace etc. with availableSpace in config and make setters work during config phase\n    // </remove-on-release>\n\n    static get defaultConfig() {\n        return {\n            /**\n             * The time axis providing the underlying data to be visualized\n             * @config {Scheduler.data.TimeAxis}\n             * @internal\n             */\n            timeAxis : null,\n\n            /**\n             * The available width/height, this is normally not known by the consuming UI component using this model\n             * class until it has been fully rendered. The consumer of this model should set\n             * {@link #property-availableSpace} when its width has changed.\n             * @config {Number}\n             * @internal\n             */\n            availableSpace : null,\n\n            /**\n             * The \"tick width\" for horizontal mode or \"tick height\" for vertical mode, to use for the cells in the\n             * bottom most header row.\n             * This value is normally read from the {@link Scheduler.preset.ViewPreset viewPreset}\n             * @config {Number}\n             * @default\n             * @internal\n             */\n            tickSize : 100,\n\n            /**\n             * true if there is a requirement to be able to snap events to a certain view resolution.\n             * This has implications of the {@link #config-tickSize} that can be used, since all widths must be in even pixels.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            snap : false,\n\n            /**\n             * true if cells in the bottom-most row should be fitted to the {@link #property-availableSpace available space}.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            forceFit : false,\n\n            headers : null,\n\n            mode : 'horizontal', // or 'vertical'\n\n            //used for Exporting. Make sure the tick columns are not recalculated when resizing.\n            suppressFit : false,\n\n            // cache of the config currently used.\n            columnConfig : [],\n\n            // the view preset name to apply initially\n            viewPreset : null,\n\n            // The default header level to draw column lines for\n            columnLinesFor : null,\n\n            originalTickSize : null,\n\n            headersDatesCache : []\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(config) {\n        const me = this;\n\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n\n        super.construct(config);\n\n        const viewPreset = me.timeAxis.viewPreset || me.viewPreset;\n\n        if (viewPreset) {\n            if (viewPreset instanceof ViewPreset) {\n                me.consumeViewPreset(viewPreset);\n            }\n            else {\n                const preset = PresetManager.getPreset(viewPreset);\n                preset && me.consumeViewPreset(preset);\n            }\n        }\n\n        // When time axis is changed, reconfigure the model\n        me.timeAxis.ion({ reconfigure : 'onTimeAxisReconfigure', thisObj : me });\n\n        me.configured = true;\n    }\n\n    doDestroy() {\n        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);\n        super.doDestroy();\n    }\n\n    /**\n     * Used to calculate the range to extend the TimeAxis to during infinite scroll.\n     * @param {Date} date\n     * @param {Boolean} centered\n     * @param {Scheduler.preset.ViewPreset} [preset] Optional, the preset for which to calculate the range.\n     * defaults to the currently active ViewPreset\n     * @returns {Object} `{ startDate, endDate }`\n     * @internal\n     */\n    calculateInfiniteScrollingDateRange(date, centered, preset = this.viewPreset) {\n        const\n            {\n                timeAxis,\n                availableSpace\n            } = this,\n            {\n                bufferCoef\n            } = this.owner,\n            {\n                leafUnit,\n                leafIncrement,\n                topUnit,\n                topIncrement,\n                tickSize\n            } = preset,\n            // If the units are the same and the increments are integer, snap to the top header's unit & increment\n            useTop    = leafUnit === topUnit && Math.round(topIncrement) === topIncrement && Math.round(leafIncrement) === leafIncrement,\n            snapSize  = useTop ? topIncrement : leafIncrement,\n            snapUnit  = useTop ? topUnit      : leafUnit;\n\n        // if provided date is the central point on the timespan\n        if (centered) {\n            const halfSpan = Math.ceil((availableSpace * bufferCoef + (availableSpace / 2)) / tickSize);\n\n            return {\n                startDate : timeAxis.floorDate(DH.add(date, -halfSpan * leafIncrement, leafUnit), false, snapUnit, snapSize),\n                endDate   : timeAxis.ceilDate(DH.add(date, halfSpan * leafIncrement, leafUnit), false, snapUnit, snapSize)\n            };\n        }\n        // if provided date is the left coordinate of the visible timespan area\n        else {\n            const bufferedTicks = Math.ceil(availableSpace * bufferCoef / tickSize);\n\n            return {\n                startDate : timeAxis.floorDate(DH.add(date, -bufferedTicks * leafIncrement, leafUnit), false, snapUnit, snapSize),\n                endDate   : timeAxis.ceilDate(DH.add(date, Math.ceil((availableSpace / tickSize + bufferedTicks) * leafIncrement), leafUnit), false, snapUnit, snapSize)\n            };\n        }\n    }\n\n    /**\n     * Returns an array representing the headers of the current timeAxis. Each element is an array representing the cells for that level in the header.\n     * @returns {Object[]} An array of headers, each element being an array representing each cell (with start date and end date) in the timeline representation.\n     * @internal\n     */\n    get columnConfig() {\n        return this._columnConfig;\n    }\n\n    set columnConfig(config) {\n        this._columnConfig = config;\n    }\n\n    get headers() {\n        return this._headers;\n    }\n\n    set headers(headers) {\n        if (headers && headers.length && headers[headers.length - 1].cellGenerator) {\n            throw new Error('`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.');\n        }\n\n        this._headers = headers;\n    }\n\n    get isTimeAxisViewModel() {\n        return true;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fires after the model has been updated.\n     * @event update\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n\n    /**\n     * Fires after the model has been reconfigured.\n     * @event reconfigure\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n\n    //endregion\n\n    //region Mode\n\n    /**\n     * Using horizontal mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isHorizontal() {\n        return this.mode !== 'vertical';\n    }\n\n    /**\n     * Using vertical mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n\n    /**\n     * Gets/sets the forceFit value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set forceFit(value) {\n        if (value !== this._forceFit) {\n            this._forceFit = value;\n            this.update();\n        }\n    }\n\n    //endregion\n\n    //region Reconfigure & update\n\n    reconfigure(config) {\n        // clear the cached headers\n        this.headers = null;\n\n        // Ensure correct ordering\n        this.setConfig(config);\n\n        this.trigger('reconfigure');\n    }\n\n    onTimeAxisReconfigure({ source : timeAxis, suppressRefresh }) {\n        if (this.viewPreset !== timeAxis.viewPreset) {\n            this.consumeViewPreset(timeAxis.viewPreset);\n        }\n        if (!suppressRefresh && timeAxis.count > 0) {\n            this.update();\n        }\n    }\n\n    /**\n     * Updates the view model current timeAxis configuration and available space.\n     * @param {Number} [availableSpace] The available space for the rendering of the axis (used in forceFit mode)\n     * @param {Boolean} [silent] Pass `true` to suppress the firing of the `update` event.\n     * @param {Boolean} [forceUpdate] Pass `true` to fire the `update` event even if the size has not changed.\n     * @internal\n     */\n    update(availableSpace, silent = false, forceUpdate = false) {\n        const\n            me                    = this,\n            { timeAxis, headers } = me,\n            spaceAvailable        = availableSpace !== 0;\n\n        // We're in configuration, or no change, quit\n        if (me.isConfiguring || (spaceAvailable && me._availableSpace === availableSpace)) {\n            if (forceUpdate) {\n                me.trigger('update');\n            }\n            return;\n        }\n\n        me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);\n\n        if (typeof me.availableSpace !== 'number') {\n            throw new Error('Invalid available space provided to TimeAxisModel');\n        }\n\n        me.columnConfig = [];\n\n        // The \"column width\" is considered to be the width of each tick in the lowest header row and this width\n        // has to be same for all cells in the lowest row.\n        const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);\n\n        if (typeof tickSize !== 'number' || tickSize <= 0) {\n            throw new Error('Invalid timeAxis tick size');\n        }\n\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n\n        // totalSize is cached because of frequent calls which calculate it.\n        me._totalSize = null;\n\n        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering\n        for (let pos = 0, { length } = headers; pos < length; pos++) {\n            const header = headers[pos];\n\n            if (header.cellGenerator) {\n                const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);\n\n                me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);\n            }\n            else {\n                me.columnConfig[pos] = me.createHeaderRow(pos, header);\n            }\n        }\n\n        if (!silent) {\n            me.trigger('update');\n        }\n    }\n\n    //endregion\n\n    //region Date / position mapping\n\n    /**\n     * Returns the distance in pixels for a timespan with the given start and end date.\n     * @param {Date} start start date\n     * @param {Date} end end date\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceBetweenDates(start, end) {\n        return this.getPositionFromDate(end) - this.getPositionFromDate(start);\n    }\n\n    /**\n     * Returns the distance in pixels for a time span\n     * @param {Number} durationMS Time span duration in ms\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceForDuration(durationMs) {\n        return this.getSingleUnitInPixels('millisecond') * durationMs;\n    }\n\n    /**\n     * Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.\n     * @param {Date} date the date to query for.\n     * @returns {Number} the coordinate representing the date\n     * @category Date mapping\n     */\n    getPositionFromDate(date, options = {}) {\n        const tick = this.getScaledTick(date, options);\n\n        if (tick === -1) {\n            return -1;\n        }\n\n        return this.tickSize * (tick - this.timeAxis.visibleTickStart);\n    }\n\n    // Translates a tick along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledTick(date, { respectExclusion, snapToNextIncluded, isEnd, min, max }) {\n        const\n            { timeAxis }      = this,\n            { include, unit } = timeAxis;\n\n        let tick = timeAxis.getTickFromDate(date);\n\n        if (tick !== -1 && respectExclusion && include) {\n            let tickChanged = false;\n\n            // Stretch if we are using a larger unit than 'hour', except if it is 'day'. If so, it is already handled\n            // by a cheaper reconfiguration of the ticks in `generateTicks`\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const\n                    { from, to, lengthFactor, center } = include.hour,\n                    // Original hours\n                    originalHours                      = date.getHours(),\n                    // Crop to included hours\n                    croppedHours                       = Math.min(Math.max(originalHours, from), to);\n\n                // If we are not asked to snap (when other part of span is not included) any cropped away hour\n                // should be considered excluded\n                if (!snapToNextIncluded && croppedHours !== originalHours) {\n                    return -1;\n                }\n\n                const\n                    // Should scale hour and smaller units (seconds will hardly affect visible result...)\n                    fractionalHours = croppedHours + date.getMinutes() / 60,\n                    // Number of hours from the center    |xxxx|123c----|xxx|\n                    hoursFromCenter = center - fractionalHours,\n                    // Step from center to stretch event  |x|112233c----|xxx|\n                    newHours        = center - hoursFromCenter * lengthFactor;\n\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newHours - originalHours, 'h');\n\n                tickChanged = true;\n            }\n\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, to, lengthFactor, center } = include.day;\n\n                //region Crop\n                let checkDay = date.getDay();\n\n                // End date is exclusive, check the day before if at 00:00\n                if (isEnd && date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0 && date.getMilliseconds() === 0) {\n                    if (--checkDay < 0) {\n                        checkDay = 6;\n                    }\n                }\n                let addDays = 0;\n\n                if (checkDay < from || checkDay >= to) {\n                    // If end date is in view but start date is excluded, snap to next included day\n                    if (snapToNextIncluded) {\n\n                        // Step back to \"to-1\" (not inclusive) for end date\n                        if (isEnd) {\n                            addDays = (to - checkDay - 8) % 7;\n                        }\n                        // Step forward to \"from\" for start date\n                        else {\n                            addDays = (from - checkDay + 7) % 7;\n                        }\n\n                        date = DH.add(date, addDays, 'd');\n                        date = DH.startOf(date, 'd', false);\n\n                        // Keep end after start and vice versa\n                        if (\n                            (max && date.getTime() >= max) ||\n                            (min && date.getTime() <= min)\n                        ) {\n                            return -1;\n                        }\n                    }\n                    else {\n                        // day excluded at not snapping to next\n                        return -1;\n                    }\n                }\n                //endregion\n\n                const\n                    { weekStartDay } = timeAxis,\n                    // Center to stretch around, for some reason pre-calculated cannot be used for sundays :)\n                    fixedCenter      = date.getDay() === 0 ? 0 : center,\n                    // Should scale day and smaller units (minutes will hardly affect visible result...)\n                    fractionalDay    = date.getDay() + date.getHours() / 24, //+ dateClone.getMinutes() / (24 * 1440),\n                    // Number of days from the calculated center\n                    daysFromCenter   = fixedCenter - fractionalDay,\n                    // Step from center to stretch event\n                    newDay           = fixedCenter - daysFromCenter * lengthFactor;\n\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newDay - fractionalDay + weekStartDay, 'd');\n\n                tickChanged = true;\n            }\n\n            // Now the date might start somewhere else (fraction of ticks)\n            if (tickChanged) {\n                // When stretching date might end up outside of time axis, making it invalid to use. Clip it to time axis\n                // to circumvent this\n                date = DH.constrain(date, timeAxis.startDate, timeAxis.endDate);\n\n                // Get a new tick based on the \"scaled\" date\n                tick = timeAxis.getTickFromDate(date);\n            }\n        }\n\n        return tick;\n    }\n\n    /**\n     * Gets the date for a position on the time axis\n     * @param {Number} position The page X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange=false] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Date mapping\n     */\n    getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            tick         = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;\n\n        if (tick < 0 || tick > timeAxis.count) {\n            if (allowOutOfRange) {\n                let result;\n\n                // Subtract the correct number of tick units from the start date\n                if (tick < 0) {\n                    result = DH.add(timeAxis.startDate, tick, timeAxis.unit);\n                }\n                else {\n                    // Add the correct number of tick units to the end date\n                    result = DH.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);\n                }\n\n                // Honour the rounding requested\n                if (roundingMethod) {\n                    result = timeAxis[roundingMethod + 'Date'](result);\n                }\n                return result;\n            }\n            return null;\n        }\n\n        return timeAxis.getDateFromTick(tick, roundingMethod);\n    }\n\n    // Translates a position along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledPosition(position) {\n        const { include, unit, weekStartDay } = this.timeAxis;\n\n        // Calculations are\n\n        if (include) {\n            const dayWidth = this.getSingleUnitInPixels('day');\n\n            // Have to calculate day before hour to get end result correct\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, lengthFactor } = include.day,\n                    // Scaling happens within a week, determine position within it\n                    positionInWeek         = position % (dayWidth * 7),\n                    // Store were the week starts to be able to re-add it after scale\n                    weekStartPosition      = position - positionInWeek;\n                // Scale position using calculated length per day factor, adding the width of excluded days\n                position                     = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;\n            }\n\n            // Hours are not taken into account when viewing days, since the day ticks are reconfigured in\n            // `generateTicks` instead\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const { from, lengthFactorExcl } = include.hour,\n                    hourWidth                  = this.getSingleUnitInPixels('hour'),\n                    // Scaling happens within a day, determine position within it\n                    positionInDay              = position % dayWidth,\n                    // Store were the day starts to be able to re-add it after scale\n                    dayStartPosition           = position - positionInDay;\n                // Scale position using calculated length per day factor, adding the width of excluded hours\n                position                         = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;\n            }\n        }\n\n        return position;\n    }\n\n    /**\n     * Returns the amount of pixels for a single unit\n     * @internal\n     * @returns {Number} The unit in pixel\n     */\n    getSingleUnitInPixels(unit) {\n        const me = this;\n\n        return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DH.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);\n    }\n\n    /**\n     * Returns the pixel increment for the current view resolution.\n     * @internal\n     * @returns {Number} The increment\n     */\n    get snapPixelAmount() {\n        if (this.snap) {\n            const { resolution } = this.timeAxis;\n            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);\n        }\n        return 1;\n    }\n\n    //endregion\n\n    //region Sizes\n\n    /**\n     * Get/set the current time column size (the width or height of a cell in the bottom-most time axis header row,\n     * depending on mode)\n     * @internal\n     * @property {Number}\n     */\n    get tickSize() {\n        return this._tickSize;\n    }\n\n    set tickSize(size) {\n        this.setTickSize(size, false);\n    }\n\n    setTickSize(size, suppressEvent) {\n        this._tickSize = this.originalTickSize = size;\n\n        this.update(undefined, suppressEvent);\n    }\n\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n\n    // Calculates the time column width/height based on the value defined viewPreset \"tickWidth/tickHeight\". It also\n    // checks for the forceFit view option and the snap, both of which impose constraints on the time column width\n    // configuration.\n    calculateTickSize(proposedSize) {\n        const\n            me                                  = this,\n            { forceFit, timeAxis, suppressFit } = me,\n            timelineUnit                        = timeAxis.unit;\n\n        let size  = 0,\n            ratio = 1; //Number.MAX_VALUE;\n\n        if (me.snap) {\n            const resolution = timeAxis.resolution;\n            ratio            = DH.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;\n        }\n\n        if (!suppressFit) {\n            const fittingSize = me.availableSpace / timeAxis.visibleTickTimeSpan;\n\n            size = (forceFit || proposedSize < fittingSize) ? fittingSize : proposedSize;\n\n            if (ratio > 0 && (!forceFit || ratio < 1)) {\n                size = Math.max(1, ratio * size) / ratio;\n            }\n        }\n        else {\n            size = proposedSize;\n        }\n\n        return size;\n    }\n\n    /**\n     * Returns the total width/height of the time axis representation, depending on mode.\n     * @returns {Number} The width or height\n     * @internal\n     * @readonly\n     */\n    get totalSize() {\n        // Floor the space to prevent spurious overflow\n        return this._totalSize || (this._totalSize = Math.floor(this.tickSize * this.timeAxis.visibleTickTimeSpan));\n    }\n\n    /**\n     * Get/set the available space for the time axis representation. If size changes it will cause it to update its\n     * contents and fire the {@link #event-update} event.\n     * @internal\n     * @property {Number}\n     */\n    get availableSpace() {\n        return this._availableSpace;\n    }\n\n    set availableSpace(space) {\n        const me = this;\n        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't\n        // occupy the available space - and gets stretched\n        me._availableSpace = Math.max(0, space);\n\n        if (me._availableSpace > 0) {\n            const newTickSize = me.calculateTickSize(me.originalTickSize);\n\n            if (newTickSize > 0 && newTickSize !== me.tickSize) {\n                me.update();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Fitting & snapping\n\n    /**\n     * Returns start dates for ticks at the specified level in format { date, isMajor }.\n     * @param {Number} level Level in headers array, `0` meaning the topmost...\n     * @param {Boolean} useLowestHeader Use lowest level\n     * @param getEnd\n     * @returns {Array}\n     * @internal\n     */\n    getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {\n        const\n            me            = this,\n            ticks         = [],\n            linesForLevel = useLowestHeader ? me.lowestHeader : level,\n            majorLevel    = me.majorHeaderLevel,\n            levelUnit     = me.headers && me.headers[level].unit,\n            majorUnit     = majorLevel != null && me.headers && me.headers[majorLevel].unit,\n            validMajor    = majorLevel != null && DH.doesUnitsAlign(majorUnit, levelUnit),\n            hasGenerator  = !!(me.headers && me.headers[linesForLevel].cellGenerator);\n\n        if (hasGenerator) {\n            const cells = me.columnConfig[linesForLevel];\n\n            for (let i = 1, l = cells.length; i < l; i++) {\n                ticks.push({ date : cells[i].startDate });\n            }\n        }\n        else {\n            me.forEachInterval(linesForLevel, (start, end) => {\n                ticks.push({\n                    date    : getEnd ? end : start,\n                    // do not want to consider tick to be major tick, hence the check for majorHeaderLevel\n                    isMajor : majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)\n                });\n            });\n        }\n\n        return ticks;\n    }\n\n    get forceFit() {\n        return this._forceFit;\n    }\n\n    /**\n     * This function fits the time columns into the available space in the time axis column.\n     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.\n     * @internal\n     */\n    fitToAvailableSpace(suppressEvent) {\n        const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);\n        this.setTickSize(proposedSize, suppressEvent);\n    }\n\n    get snap() {\n        return this._snap;\n    }\n\n    /**\n     * Gets/sets the snap value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set snap(value) {\n        if (value !== this._snap) {\n            this._snap = value;\n            if (this.configured) {\n                this.update();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Headers\n\n    // private\n    createHeaderRow(position, headerRowConfig, headerCells) {\n        const\n            me                            = this,\n            cells                         = [],\n            { align, headerCellCls = '' } = headerRowConfig,\n            today                         = DH.clearTime(new Date()),\n            { timeAxis }                  = me,\n            tickLevel                     = me.headers.length - 1,\n            createCellContext             = (start, end, i, isLast, data) => {\n                let value = DH.format(start, headerRowConfig.dateFormat);\n\n                const\n                    // So that we can use shortcut tickSize as the tickLevel cell width.\n                    // We can do this if the TimeAxis is aligned to start and end on tick boundaries\n                    // or if it's not the first or last tick.\n                    // getDistanceBetweenDates is an expensive operation.\n                    isInteriorTick = i > 0 && !isLast,\n                    cellData       = {\n                        align,\n                        start,\n                        end,\n                        value : data ? data.header : value,\n                        headerCellCls,\n                        width : tickLevel === position && me.owner && (timeAxis.fullTicks || isInteriorTick) ? me.owner.tickSize : me.getDistanceBetweenDates(start, end),\n                        index : i\n                    };\n                if (cellData.width === 0) {\n                    return;\n                }\n\n                // Vertical mode uses absolute positioning for header cells\n                cellData.coord = size - 1;\n                size += cellData.width;\n\n                me.headersDatesCache[position][start.getTime()] = 1;\n\n                if (headerRowConfig.renderer) {\n                    value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i);\n\n                    cellData.value = value == null ? '' : value;\n                }\n\n                // To be able to style individual day cells, weekends or other important days\n                if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {\n                    cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();\n\n                    if (DH.clearTime(start, true) - today === 0) {\n                        cellData.headerCellCls += ' b-sch-dayheadercell-today';\n                    }\n                }\n\n                cells.push(cellData);\n            };\n\n        let size = 0;\n\n        me.headersDatesCache[position] = {};\n\n        if (headerCells) {\n            headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, i === headerCells.length - 1, cellData));\n        }\n        else {\n            me.forEachInterval(position, createCellContext);\n        }\n\n        return cells;\n    }\n\n    get mainHeader() {\n        return ('mainHeaderLevel' in this) ? this.headers[this.mainHeaderLevel] : this.bottomHeader;\n    }\n\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n\n    get lowestHeader() {\n        return this.headers.length - 1;\n    }\n\n    /**\n     * This method is meant to return the level of the header which 2nd lowest.\n     * It is used for {@link #function-isMajorTick} method\n     * @returns {String}\n     * @private\n     */\n    get majorHeaderLevel() {\n        const { headers } = this;\n\n        if (headers) {\n            return Math.max(headers.length - 2, 0);\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //region Ticks\n\n    /**\n     * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the\n     * upper header level.\n     * @param {Date} date\n     * @returns {Boolean}\n     * @private\n     */\n    isMajorTick(date) {\n        const nextLevel = this.majorHeaderLevel;\n        // if forceFit is used headersDatesCache won´t have been generated yet on the first call here,\n        // since no size is set yet\n        return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;\n    }\n\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @param {Number} position The index of the header in the headers array.\n     * @param {Function} iteratorFn The function to call, will be called with start date, end date and \"tick index\"\n     * @param {Object} [thisObj] `this` reference for the function\n     * @internal\n     */\n    forEachInterval(position, iteratorFn, thisObj = this) {\n        const { headers, timeAxis } = this;\n\n        if (headers) {\n            // This is the lowest header row, which should be fed the data in the tickStore (or a row above using same unit)\n            if (position === headers.length - 1) {\n                timeAxis.forEach((r, index) =>\n                    iteratorFn.call(thisObj, r.startDate, r.endDate, index, index === timeAxis.count - 1)\n                );\n            }\n            // All other rows\n            else {\n                const header = headers[position];\n\n                timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);\n            }\n        }\n    }\n\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @internal\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachMainInterval(iteratorFn, thisObj) {\n        this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);\n    }\n\n    //endregion\n\n    //region ViewPreset\n\n    consumeViewPreset(preset) {\n        const me = this;\n\n        // clear the cached headers\n        me.headers = null;\n\n        me.getConfig('tickSize');\n\n        // Since we are bypassing the tickSize setter below, ensure that\n        // the config initial setter has been removed by referencing the property.\n        // We only do this to avoid multiple updates from this.\n        // <remove-on-release>\n        // TODO: Fix this issue, and do not bypass setters.\n        // </remove-on-release>\n        me.viewPreset = preset;\n\n        Object.assign(me, {\n            headers         : preset.headers,\n            columnLinesFor  : preset.columnLinesFor,\n            mainHeaderLevel : preset.mainHeaderLevel,\n            _tickSize       : me.isHorizontal ? preset.tickWidth : preset.tickHeight\n        });\n\n        me.originalTickSize = me.tickSize;\n    }\n\n    //endregion\n}\n", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n\n// Used to avoid having to create huge amounts of Date objects\nconst tempDate = new Date();\n\n/**\n * @module Scheduler/view/mixin/TimelineDateMapper\n */\n\n/**\n * Mixin that contains functionality to convert between coordinates and dates etc.\n *\n * @mixin\n */\nexport default Target => class TimelineDateMapper extends (Target || Base) {\n    static $name = 'TimelineDateMapper';\n\n    static configurable = {\n        /**\n         * Set to `true` to snap to the current time resolution increment while interacting with scheduled events.\n         *\n         * The time resolution increment is either determined by the currently applied view preset, or it can be\n         * overridden using {@link #property-timeResolution}.\n         *\n         * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n         * enabled, snapping will align to full ticks, regardless of the time resolution.</div>\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        snap : false\n    };\n\n    //region Coordinate <-> Date\n\n    getRtlX(x) {\n        if (this.rtl && this.isHorizontal) {\n            x = this.timeAxisViewModel.totalSize - x;\n        }\n        return x;\n    }\n\n    /**\n     * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.\n     * If the coordinate is not in the currently rendered view, null will be returned unless the `allowOutOfRange`\n     * parameter is passed a `true`.\n     * @param {Number} coordinate The X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler view element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The Date corresponding to the X or Y coordinate\n     * @category Dates\n     */\n    getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false, ignoreRTL = false) {\n        if (!local) {\n            coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);\n        }\n\n        // Time axis is flipped for RTL\n        if (!ignoreRTL) {\n            coordinate = this.getRtlX(coordinate);\n        }\n\n        return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);\n    }\n\n    getDateFromCoord(options) {\n        return this.getDateFromCoordinate(options.coord, options.roundingMethod, options.local, options.allowOutOfRange, options.ignoreRTL);\n    }\n\n    /**\n     * Gets the date for an XY coordinate regardless of the orientation of the time axis.\n     * @param {Array} xy The page X and Y coordinates\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Dates\n     */\n    getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {\n        return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);\n    }\n\n    /**\n     * Gets the time for a DOM event such as 'mousemove' or 'click' regardless of the orientation of the time axis.\n     * @param {Event} e the Event instance\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The date corresponding to the EventObject's position along the orientation of the time axis.\n     * @category Dates\n     */\n    getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {\n        return this.getDateFromXY([e.pageX, e.pageY], roundingMethod, false, allowOutOfRange);\n    }\n\n    /**\n     * Gets the start and end dates for an element Region\n     * @param {Core.helper.util.Rectangle} rect The rectangle to map to start and end dates\n     * @param {'floor'|'round'|'ceil'} roundingMethod Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Number} duration The duration in MS of the underlying event\n     * @returns {Object} an object containing start/end properties\n     */\n    getStartEndDatesFromRectangle(rect, roundingMethod, duration, allowOutOfRange = false) {\n        const\n            me               = this,\n            { isHorizontal } = me,\n            startPos         = isHorizontal ? rect.x : rect.top,\n            endPos           = isHorizontal ? rect.right : rect.bottom;\n\n        let start, end;\n\n        // Element within bounds\n        if (startPos >= 0 && endPos < me.timeAxisViewModel.totalSize) {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true);\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true);\n        }\n        // Starts before, start is worked backwards from end\n        else if (startPos < 0) {\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true, allowOutOfRange);\n            start = end && DateHelper.add(end, -duration, 'ms');\n        }\n        // Ends after, end is calculated from the start\n        else {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true, allowOutOfRange);\n            end = start && DateHelper.add(start, duration, 'ms');\n        }\n\n        return {\n            start, end\n        };\n    }\n\n    //endregion\n\n    //region Date display\n\n    /**\n     * Method to get a displayed end date value, see {@link #function-getFormattedEndDate} for more info.\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {Date} The date value to display\n     */\n    getDisplayEndDate(endDate, startDate) {\n        if (\n            // If time is midnight,\n            endDate.getHours() === 0 && endDate.getMinutes() === 0 &&\n\n            // and end date is greater then start date\n            (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) &&\n\n            // and UI display format doesn't contain hour info (in this case we'll just display the exact date)\n            !DateHelper.formatContainsHourInfo(this.displayDateFormat)\n        ) {\n            // format the date inclusively as 'the whole previous day'.\n            endDate = DateHelper.add(endDate, -1, 'day');\n        }\n\n        return endDate;\n    }\n\n    /**\n     * Method to get a formatted end date for a scheduled event, the grid uses the \"displayDateFormat\" property defined in the current view preset.\n     * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,\n     * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {String} The formatted date\n     */\n    getFormattedEndDate(endDate, startDate) {\n        return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));\n    }\n\n    //endregion\n\n    //region Other date functions\n\n    /**\n     * Gets the x or y coordinate relative to the scheduler element, or page coordinate (based on the 'local' flag)\n     * If the coordinate is not in the currently rendered view, -1 will be returned.\n     * @param {Date|Number} date the date to query for (or a date as ms)\n     * @param {Boolean|Object} options true to return a coordinate local to the scheduler view element (defaults to true),\n     * also accepts a config object like { local : true }.\n     * @returns {Number} the x or y position representing the date on the time axis\n     * @category Dates\n     */\n    getCoordinateFromDate(date, options = true) {\n        const\n            me                    = this,\n            { timeAxisViewModel } = me,\n            {\n                isContinuous,\n                startMS,\n                endMS,\n                startDate,\n                endDate,\n                unit\n            }                     = me.timeAxis,\n            dateMS                = date.valueOf();\n\n        // Avoiding to break the API while allowing passing options through to getPositionFromDate()\n        if (options === true) {\n            options = {\n                local : true\n            };\n        }\n        else if (!options) {\n            options = {\n                local : false\n            };\n        }\n        else if (!('local' in options)) {\n            options.local = true;\n        }\n\n        let pos;\n\n        // <remove-on-release>\n        // TODO: for 6.0 try to normalize and just use dates as input for this method,\n        //  then this if-statement would not be needed\n        // </remove-on-release>\n        if (!(date instanceof Date)) {\n            tempDate.setTime(date);\n            date = tempDate;\n        }\n\n        // Shortcut for continuous time axis that is using a unit that can be reliably translated to days (or smaller)\n        if (isContinuous &&\n            date.getTimezoneOffset() === startDate.getTimezoneOffset() &&\n            startDate.getTimezoneOffset() === endDate.getTimezoneOffset() &&\n            DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1\n        ) {\n            if (dateMS < startMS || dateMS > endMS) {\n                return -1;\n            }\n            pos = (dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize;\n        }\n        // Non-continuous or using for example months (vary in length)\n        else {\n            pos = timeAxisViewModel.getPositionFromDate(date, options);\n        }\n\n        // RTL coords from the end of the time axis\n        if (me.rtl && me.isHorizontal) {\n            pos = timeAxisViewModel.totalSize - pos;\n        }\n\n        if (!options.local) {\n            pos = me.currentOrientation.translateToPageCoordinate(pos);\n        }\n\n        return pos;\n    }\n\n    /**\n     * Returns the distance in pixels for the time span in the view.\n     * @param {Date} startDate The start date of the span\n     * @param {Date} endDate The end date of the span\n     * @returns {Number} The distance in pixels\n     * @category Dates\n     */\n    getTimeSpanDistance(startDate, endDate) {\n        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);\n    }\n\n    /**\n     * Returns the center date of the currently visible timespan of scheduler.\n     *\n     * @property {Date}\n     * @readonly\n     * @category Dates\n     */\n    get viewportCenterDate() {\n        const { timeAxis, timelineScroller } = this;\n\n        // Take the easy way if the axis is continuous.\n        // We can just work out how far along the time axis the viewport center is.\n        if (timeAxis.isContinuous) {\n            // The offset from the start of the whole time axis\n            const timeAxisOffset = (timelineScroller.position + timelineScroller.clientSize / 2) / timelineScroller.scrollSize;\n\n            return new Date(timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * timeAxisOffset);\n        }\n        return this.getDateFromCoordinate(timelineScroller.position + timelineScroller.clientSize / 2);\n    }\n\n    get viewportCenterDateCached() {\n        return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);\n    }\n\n    //endregion\n\n    //region TimeAxis getters/setters\n\n    /**\n     * Gets/sets the current time resolution object, which contains a unit identifier and an increment count\n     * `{ unit, increment }`. This value means minimal task duration you can create using UI.\n     *\n     * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'\n     * that means that you can create tasks in 5 minute increments, or move it in 5 minute steps.\n     *\n     * This value is taken from viewPreset {@link Scheduler.preset.ViewPreset#field-timeResolution timeResolution}\n     * config by default. When supplying a `Number` to the setter only the `increment` is changed and the `unit` value\n     * remains untouched.\n     *\n     * ```javascript\n     * timeResolution : {\n     *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n     *   increment : 5\n     * }\n     * ```\n     *\n     * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n     * enabled, the resolution will be in full ticks regardless of configured value.</div>\n     *\n     * @property {Object|Number}\n     * @category Dates\n     */\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n\n    set timeResolution(resolution) {\n        this.timeAxis.resolution = (typeof resolution === 'number') ? {\n            increment : resolution,\n            unit      : this.timeAxis.resolution.unit\n        } : resolution;\n    }\n\n    //endregion\n\n    //region Snap\n\n    get snap() {\n        return this._timeAxisViewModel?.snap ?? this._snap;\n    }\n\n    updateSnap(snap) {\n        if (!this.isConfiguring) {\n            this.timeAxisViewModel.snap = snap;\n            this.timeAxis.forceFullTicks = snap && this.fillTicks;\n        }\n    }\n\n    //endregion\n\n    onSchedulerHorizontalScroll({ subGrid, scrollLeft, scrollX }) {\n        // Invalidate cached center date unless we are scrolling to center on it.\n        if (!this.scrollingToCenter) {\n            this.cachedCenterDate = null;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomDataStore from '../../../Core/data/DomDataStore.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineDomEvents\n */\n\nconst { eventNameMap } = EventHelper;\n\n/**\n * An object which encapsulates a schedule timeline tick context based on a DOM event. This will include\n * the row and resource information and the tick and time information for a DOM pointer event detected\n * in the timeline.\n * @typedef {Object} TimelineContext\n * @property {Event} domEvent The DOM event which triggered the context change.\n * @property {HTMLElement} eventElement If the `domEvent` was on an event bar, this will be the event bar element.\n * @property {HTMLElement} cellElement The cell element under the `domEvent`\n * @property {Date} date The date corresponding to the `domEvent` position in the timeline\n * @property {Scheduler.model.TimeSpan} tick A {@link Scheduler.model.TimeSpan} record which encapsulates the contextual tick\n * @property {Number} tickIndex The contextual tick index. This may be fractional.\n * @property {Number} tickParentIndex The integer contextual tick index.\n * @property {Date} tickStartDate The start date of the contextual tick.\n * @property {Date} tickEndDate The end date of the contextual tick.\n * @property {Grid.row.Row} row The contextual {@link Grid.row.Row}\n * @property {Number} index The contextual row index\n * @property {Scheduler.model.EventModel} [eventRecord] The contextual event record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.AssignmentModel} [assignmentRecord] The contextual assignment record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.ResourceModel} [resourceRecord] The contextual resource record(if any)  if the event source is a `Scheduler`\n */\n\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class TimelineDomEvents extends (Target || Base) {\n    /**\n     * Fires after a click on a time axis cell\n     * @event timeAxisHeaderClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n\n    /**\n     * Fires after a double click on a time axis cell\n     * @event timeAxisHeaderDblClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n\n    /**\n     * Fires after a right click on a time axis cell\n     * @event timeAxisHeaderContextMenu\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n\n    static $name = 'TimelineDomEvents';\n\n    //region Default config\n\n    static configurable = {\n        /**\n         * The currently hovered timeline context. This is updated as the mouse or pointer moves over the timeline.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         * @category Dates\n         */\n        timelineContext : {\n            $config : {\n                // Reject non-changes so that when set from scheduleMouseMove and EventMouseMove,\n                // we only update the context and fire events when it changes.\n                equal(c1, c2) {\n                    // index is the resource index, tickParentIndex is the\n                    // tick's index in the TimeAxis.\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        },\n\n        /**\n         * By default, scrolling the schedule will update the {@link #property-timelineContext} to reflect the new\n         * currently hovered context. When displaying a large number of events on screen at the same time, this will\n         * have a slight impact on scrolling performance. In such scenarios, opt out of this behavior by setting\n         * this config to `false`.\n         * @default\n         * @prp {Boolean}\n         * @category Misc\n         */\n        updateTimelineContextOnScroll : true\n    };\n\n    static properties = {\n        schedulerEvents : {\n            pointermove : 'handleScheduleEvent',\n            mouseover   : 'handleScheduleEvent',\n            mousedown   : 'handleScheduleEvent',\n            mouseup     : 'handleScheduleEvent',\n            click       : 'handleScheduleEvent',\n            dblclick    : 'handleScheduleEvent',\n            contextmenu : 'handleScheduleEvent',\n            mousemove   : 'handleScheduleEvent',\n            mouseout    : 'handleScheduleEvent'\n        },\n\n        schedulerEnterLeaveEvents : {\n            mouseenter : 'handleScheduleEnterLeaveEvent',\n            mouseleave : 'handleScheduleEnterLeaveEvent',\n            capture    : true\n        }\n    };\n\n    static delayable = {\n        // Allow the scroll event to complete in its thread, and dispatch the mousemove event next AF\n        onScheduleScroll : 'raf'\n    };\n\n    // Currently hovered events (can be parent + child)\n    hoveredEvents = new Set();\n\n    //endregion\n\n    //region Init\n\n    /**\n     * Adds listeners for DOM events for the scheduler and its events.\n     * Which events is specified in Scheduler#schedulerEvents.\n     * @private\n     */\n    initDomEvents() {\n        const\n            me = this,\n            {\n                schedulerEvents,\n                schedulerEnterLeaveEvents\n            }  = me;\n\n        // Set thisObj and element of the configured listener specs.\n        schedulerEvents.element = schedulerEnterLeaveEvents.element = me.timeAxisSubGridElement;\n        schedulerEvents.thisObj = schedulerEnterLeaveEvents.thisObj = me;\n        EventHelper.on(schedulerEvents);\n        EventHelper.on(schedulerEnterLeaveEvents);\n\n        // This is to handle scroll events while the mouse is over the schedule.\n        // For example magic mouse or touchpad scrolls, or scrolls caused by keyboard\n        // navigation while the mouse happens to be over the schedule.\n        // The context must update. We must consider any scroll because the document\n        // or some other wrapping element could be scrolling the Scheduler under the mouse.\n        if (BrowserHelper.supportsPointerEventConstructor) {\n            EventHelper.on({\n                element : document,\n                scroll  : 'onScheduleScroll',\n                capture : true,\n                thisObj : me\n            });\n        }\n    };\n\n    //endregion\n\n    //region Event handling\n    getTimeSpanMouseEventParams(eventElement, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    getScheduleMouseEventParams(cellData, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    /**\n     * Wraps dom Events for the scheduler and event bars and fires as our events.\n     * For example click -> scheduleClick or eventClick\n     * @private\n     * @param event\n     */\n    handleScheduleEvent(event) {\n        const\n            me              = this,\n            timelineContext = me.getTimelineEventContext(event);\n\n        // Cache the last pointer event so that  when scrolling below the mouse\n        // we can inject mousemove events at that point.\n        me.lastPointerEvent = event;\n\n        // We are over the schedule region\n        if (timelineContext) {\n            // Only fire a scheduleXXXX event if we are *not* over an event.\n            // If over an event fire (event|task)XXXX.\n            me.trigger(`${timelineContext.eventElement ? me.scheduledEventName : 'schedule'}${eventNameMap[event.type] || StringHelper.capitalize(event.type)}`, timelineContext);\n        }\n\n        // If the context has changed, updateTimelineContext will fire events\n        me.timelineContext = timelineContext;\n    }\n\n    handleScheduleEnterLeaveEvent(event) {\n        if (event.target.parentElement === this.foregroundCanvas) {\n            this.handleScheduleEvent(event);\n        }\n    }\n\n    /**\n     * This handles the scheduler being scrolled below the mouse by trackpad or keyboard events.\n     * The context, if present needs to be recalculated.\n     * @private\n     */\n    onScheduleScroll({ target }) {\n        const me = this;\n        // If the latest mouse event resulted in setting a context, we need to reproduce that event at the same clientX,\n        // clientY in order to keep the context up to date while scrolling.\n        // If the scroll is because of a pan feature drag (on us or a partner), we must not do this.\n        // Target might be removed in salesforce by Locker Service if scroll event occurs on body\n        if (\n            target && me.updateTimelineContextOnScroll && !me.features.pan?.isActive &&\n            !me.partners.some(p => p.features.pan?.isActive) &&\n            (target.contains(me.element) || me.bodyElement.contains(target))\n        ) {\n            const { timelineContext, lastPointerEvent } = me;\n\n            if (timelineContext) {\n                const\n                    targetElement = DomHelper.elementFromPoint(timelineContext.domEvent.clientX, timelineContext.domEvent.clientY),\n                    pointerEvent  = new BrowserHelper.PointerEventConstructor('pointermove', lastPointerEvent),\n                    mouseEvent    = new MouseEvent('mousemove', lastPointerEvent);\n\n                // See https://github.com/bryntum/support/issues/6274\n                // The pointerId does not propagate correctly on the synthetic PointerEvent, but also is readonly, so\n                // redefine the property. This is required by Ext JS gesture publisher which tracks pointer movements\n                // while a pointer is down. Without the correct pointerId, Ext JS would see this move as a \"missed\"\n                // pointerdown and forever await its pointerup (i.e., it would get stuck in the activeTouches). This\n                // would cause all future events to be perceived as part of or the end of a drag and would never again\n                // dispatch pointer events correctly. Finally, lastPointerEvent.pointerId is often incorrect (undefined\n                // in fact), so check the most recent pointerdown/touchstart event and default to 1\n                Object.defineProperty(pointerEvent, 'pointerId', {\n                    value : GlobalEvents.currentPointerDown?.pointerId ?? GlobalEvents.currentTouch?.identifier ?? 1\n                });\n\n                // Drag code should ignore these synthetic events\n                pointerEvent.scrollInitiated = mouseEvent.scrollInitiated = true;\n\n                // Emulate the correct browser sequence for mouse move events\n                targetElement?.dispatchEvent(pointerEvent);\n                targetElement?.dispatchEvent(mouseEvent);\n            }\n        }\n    }\n\n    updateTimelineContext(context, oldContext) {\n        /**\n         * Fired when the pointer-activated {@link #property-timelineContext} has changed.\n         * @event timelineContextChange\n         * @param {TimelineContext} oldContext The tick/resource context being deactivated.\n         * @param {TimelineContext} context The tick/resource context being activated.\n         */\n        this.trigger('timelineContextChange', { oldContext, context });\n\n        if (!context) {\n            this.trigger('scheduleMouseLeave');\n        }\n    }\n\n    /**\n     * Gathers contextual information about the schedule contextual position of the passed event.\n     *\n     * Used by schedule mouse event handlers, but also by the scheduleContext feature.\n     * @param {Event} domEvent The DOM event to gather context for.\n     * @returns {TimelineContext} the schedule DOM event context\n     * @internal\n     */\n    getTimelineEventContext(domEvent) {\n        const\n            me           = this,\n            eventElement = domEvent.target.closest(me.eventInnerSelector),\n            cellElement  = me.getCellElementFromDomEvent(domEvent);\n\n        if (cellElement) {\n            const clickedDate = me.getDateFromDomEvent(domEvent, 'floor');\n\n            if (!clickedDate) {\n                return;\n            }\n\n            const\n                cellData    = DomDataStore.get(cellElement),\n                mouseParams = eventElement ? me.getTimeSpanMouseEventParams(eventElement, domEvent) : me.getScheduleMouseEventParams(cellData, domEvent);\n\n            if (!mouseParams) {\n                return;\n            }\n\n            const\n                index     = me.isVertical ? me.resourceStore.indexOf(mouseParams.resourceRecord) : cellData.row.dataIndex,\n                tickIndex = me.timeAxis.getTickFromDate(clickedDate),\n                tick      = me.timeAxis.getAt(Math.floor(tickIndex));\n\n            if (tick) {\n                return {\n                    isTimelineContext : true,\n                    domEvent,\n                    eventElement,\n                    cellElement,\n                    index,\n                    tick,\n                    tickIndex,\n                    date              : clickedDate,\n                    tickStartDate     : tick.startDate,\n                    tickEndDate       : tick.endDate,\n                    tickParentIndex   : tick.parentIndex,\n                    row               : cellData.row,\n                    event             : domEvent,\n                    ...mouseParams\n                };\n            }\n        }\n    }\n\n    getCellElementFromDomEvent({ target, clientY, type }) {\n        const\n            me           = this,\n            {\n                isVertical,\n                foregroundCanvas\n            }            = me,\n            eventElement = target.closest(me.eventSelector);\n\n        // If event was on an event bar, calculate the cell.\n        if (eventElement) {\n            return me.getCell({\n                [isVertical ? 'row' : 'record'] : isVertical ? 0 : me.resolveRowRecord(eventElement),\n                column                          : me.timeAxisColumn\n            });\n        }\n        // If event was triggered by an element in the foreground canvas, but not an event element\n        // we need to ascertain the cell \"behind\" that element to be able to create the context.\n        else if (foregroundCanvas.contains(target)) {\n            // Only trigger a Scheduler event if the event was on the background itself.\n            // Otherwise, we will trigger unexpected events on things like dependency lines which historically\n            // have never triggered scheduleXXXX events. The exception to this is the mousemove event which\n            // needs to always fire so that timelineContext and scheduleTooltip correctly track the mouse\n            if (target === foregroundCanvas || type === 'mousemove') {\n                return me.rowManager.getRowAt(clientY, false)?.getCell(me.timeAxisColumn.id);\n            }\n        }\n        else {\n            // Event was inside a row, or on a row border.\n            return target.matches('.b-grid-row') ? target.firstElementChild : target.closest(me.timeCellSelector);\n        }\n    }\n\n    // Overridden by ResourceTimeRanges to \"pass events through\" to the schedule\n    matchScheduleCell(element) {\n        return element.closest(this.timeCellSelector);\n    }\n\n    onElementMouseButtonEvent(event) {\n        const targetCell = event.target.closest('.b-sch-header-timeaxis-cell');\n        if (targetCell) {\n            const\n                me           = this,\n                position     = targetCell.parentElement.dataset.headerPosition,\n                headerCells  = me.timeAxisViewModel.columnConfig[position],\n                index        = me.timeAxis.isFiltered ? headerCells.findIndex(cell => cell.index == targetCell.dataset.tickIndex) : targetCell.dataset.tickIndex,\n                cellConfig   = headerCells[index],\n                contextMenu  = me.features.contextMenu;\n\n            // Skip same events with Grid context menu triggerEvent\n            if (!contextMenu || event.type !== contextMenu.triggerEvent) {\n                this.trigger(`timeAxisHeader${StringHelper.capitalize(event.type)}`, {\n                    startDate : cellConfig.start,\n                    endDate   : cellConfig.end,\n                    event\n                });\n            }\n        }\n    }\n\n    onElementMouseDown(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementMouseDown(event);\n    }\n\n    onElementClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementClick(event);\n    }\n\n    onElementDblClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementDblClick(event);\n    }\n\n    onElementContextMenu(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementContextMenu(event);\n    }\n\n    /**\n     * Relays mouseover events as eventmouseenter if over rendered event.\n     * Also adds Scheduler#overScheduledEventClass to the hovered element.\n     * @private\n     */\n    onElementMouseOver(event) {\n        super.onElementMouseOver(event);\n\n        const\n            me                = this,\n            { target }        = event,\n            { hoveredEvents } = me;\n\n        // We must be over the event bar\n        if (target.closest(me.eventInnerSelector) && !me.features.eventDrag?.isDragging) {\n            const eventElement = target.closest(me.eventSelector);\n\n            if (!hoveredEvents.has(eventElement) && !me.preventOverCls) {\n                hoveredEvents.add(eventElement);\n                eventElement.classList.add(me.overScheduledEventClass);\n\n                const params = me.getTimeSpanMouseEventParams(eventElement, event);\n                if (params) {\n                    // do not fire this event if model cannot be found\n                    // this can be the case for \"b-sch-dragcreator-proxy\" elements for example\n                    me.trigger(`${me.scheduledEventName}MouseEnter`, params);\n                }\n            }\n        }\n        else if (hoveredEvents.size) {\n            me.unhoverAll(event);\n        }\n    }\n\n    /**\n     * Relays mouseout events as eventmouseleave if out from rendered event.\n     * Also removes Scheduler#overScheduledEventClass from the hovered element.\n     * @private\n     */\n    onElementMouseOut(event) {\n        super.onElementMouseOut(event);\n\n        const\n            me                        = this,\n            { target, relatedTarget } = event,\n            eventInner                = target.closest(me.eventInnerSelector),\n            eventWrap                 = target.closest(me.eventSelector),\n            timeSpanRecord            = me.resolveTimeSpanRecord(target);\n\n        // We must be over the event bar\n        // <remove-on-release>\n        // TODO: this isDragging check should be done in the feature (all drag/resize features actually) and here we should have a hook call\n        // </remove-on-release>\n        if (eventInner && timeSpanRecord && me.hoveredEvents.has(eventWrap) && !me.features.eventDrag?.isDragging) {\n            // out to child shouldn't count...\n            if (relatedTarget && DomHelper.isDescendant(eventInner, relatedTarget)) {\n                return;\n            }\n\n            me.unhover(eventWrap, event);\n        }\n    }\n\n    unhover(element, event) {\n        const me = this;\n\n        element.classList.remove(me.overScheduledEventClass);\n        me.trigger(`${me.scheduledEventName}MouseLeave`, me.getTimeSpanMouseEventParams(element, event));\n        me.hoveredEvents.delete(element);\n    }\n\n    unhoverAll(event) {\n        for (const element of this.hoveredEvents) {\n            !element.isReleased && !element.classList.contains('b-released') && this.unhover(element, event);\n        }\n\n        // Might not be empty because of conditional unhover above\n        this.hoveredEvents.clear();\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport PresetStore from '../../preset/PresetStore.js';\nimport DateHelper, { unitMagnitudes } from '../../../Core/helper/DateHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineViewPresets\n */\n\nconst\n    datesDiffer = (d1 = 0, d2 = 0) => d2 - d1;\n\n/**\n * View preset handling.\n *\n * A Scheduler's {@link #config-presets} are loaded with a default set of {@link Scheduler.preset.ViewPreset ViewPresets}\n * which are defined by the system in the {@link Scheduler.preset.PresetManager PresetManager}.\n *\n * The zooming feature works by reconfiguring the Scheduler with a new {@link Scheduler.preset.ViewPreset ViewPreset} selected\n * from the {@link #config-presets} store.\n *\n * {@link Scheduler.preset.ViewPreset ViewPresets} can be added and removed from the store to change the amount of available steps.\n * Range of zooming in/out can be also modified with {@link Scheduler.view.mixin.TimelineZoomable#config-maxZoomLevel} / {@link Scheduler.view.mixin.TimelineZoomable#config-minZoomLevel} properties.\n *\n * This mixin adds additional methods to the column : {@link Scheduler.view.mixin.TimelineZoomable#property-maxZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#property-minZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomToLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomIn},\n * {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOut}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomInFull}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOutFull}.\n *\n * **Notice**: Zooming is not supported when `forceFit` option is set to true for the Scheduler or for filtered timeaxis.\n *\n * @mixin\n */\nexport default Target => class TimelineViewPresets extends (Target || Base) {\n    static get $name() {\n        return 'TimelineViewPresets';\n    }\n\n    //region Default config\n\n    static get configurable() {\n        return {\n            /**\n             * A string key used to lookup a predefined {@link Scheduler.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),\n             * managed by {@link Scheduler.preset.PresetManager}. See {@link Scheduler.preset.PresetManager} for more information.\n             * Or a config object for a viewPreset.\n             *\n             * Options:\n             * - 'secondAndMinute'\n             * - 'minuteAndHour'\n             * - 'hourAndDay'\n             * - 'dayAndWeek'\n             * - 'dayAndMonth'\n             * - 'weekAndDay'\n             * - 'weekAndMonth',\n             * - 'monthAndYear'\n             * - 'year'\n             * - 'manyYears'\n             * - 'weekAndDayLetter'\n             * - 'weekDateAndMonth'\n             * - 'day'\n             * - 'week'\n             *\n             * If passed as a config object, the settings from the viewPreset with the provided `base` property will be used along\n             * with any overridden values in your object.\n             *\n             * To override:\n             * ```javascript\n             * viewPreset : {\n             *   base    : 'hourAndDay',\n             *   id      : 'myHourAndDayPreset',\n             *   headers : [\n             *       {\n             *           unit      : \"hour\",\n             *           increment : 12,\n             *           renderer  : (startDate, endDate, headerConfig, cellIdx) => {\n             *               return \"\";\n             *           }\n             *       }\n             *   ]\n             * }\n             * ```\n             * or set a new valid preset config if the preset is not registered in the {@link Scheduler.preset.PresetManager}.\n             *\n             * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not\n             * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.\n             * @config {String|ViewPresetConfig}\n             * @default\n             * @category Common\n             */\n            viewPreset : 'weekAndDayLetter',\n\n            /**\n             * Get the {@link Scheduler.preset.PresetStore} created for the Scheduler,\n             * or set an array of {@link Scheduler.preset.ViewPreset} config objects.\n             * @member {Scheduler.preset.PresetStore|ViewPresetConfig[]} presets\n             * @category Common\n             */\n            /**\n             * An array of {@link Scheduler.preset.ViewPreset} config objects\n             * which describes the available timeline layouts for this scheduler.\n             *\n             * By default, a predefined set is loaded from the {@link Scheduler.preset.PresetManager}.\n             *\n             * A {@link Scheduler.preset.ViewPreset} describes the granularity of the\n             * timeline view and the layout and subdivisions of the timeline header.\n             * @config {ViewPresetConfig[]} presets\n             *\n             * @category Common\n             */\n            presets : true,\n\n            /**\n             * Defines how dates will be formatted in tooltips etc. This config has priority over similar config on the\n             * view preset. For allowed values see {@link Core.helper.DateHelper#function-format-static}.\n             *\n             * By default, this is ingested from {@link Scheduler.preset.ViewPreset} upon change of\n             * {@link Scheduler.preset.ViewPreset} (Such as when zooming in or out). But Setting this\n             * to your own value, overrides that behaviour.\n             * @prp {String}\n             * @category Scheduled events\n             */\n            displayDateFormat : null\n        };\n    }\n\n    //endregion\n\n    /**\n     * Get/set the current view preset\n     * @member {Scheduler.preset.ViewPreset|ViewPresetConfig|String} viewPreset\n     * @param [viewPreset.options]\n     * @param {Date} [viewPreset.options.startDate] A new start date for the time axis\n     * @param {Date} [viewPreset.options.endDate] A new end date for the time axis\n     * @param {Date} [viewPreset.options.centerDate] Where to center the new time axis\n     * @category Common\n    */\n\n    //region Get/set\n\n    changePresets(presets) {\n        const config = {\n            owner : this\n        };\n        let data = [];\n\n        // By default includes all presets\n        if (presets === true) {\n            data = PresetManager.allRecords;\n        }\n        // Accepts an array of presets\n        else if (Array.isArray(presets)) {\n            for (const preset of presets) {\n                // If we got a presetId\n                if (typeof preset === 'string') {\n                    const presetRecord = PresetManager.getById(preset);\n                    if (presetRecord) {\n                        data.push(presetRecord);\n                    }\n                }\n                else {\n                    data.push(preset);\n                }\n            }\n        }\n        // Or a store config object\n        else {\n            ObjectHelper.assign(config, presets);\n        }\n        // Creates store first and then adds data, because data config does not support a mix of raw objects and records.\n        const presetStore = new PresetStore(config);\n        presetStore.add(data);\n\n        return presetStore;\n    }\n\n    changeViewPreset(viewPreset, oldViewPreset) {\n        const\n            me           = this,\n            { presets } = me;\n\n        if (viewPreset) {\n            viewPreset = presets.createRecord(viewPreset);\n\n            // If an existing ViewPreset id is used, this will replace it.\n            if (!presets.includes(viewPreset)) {\n                presets.add(viewPreset);\n            }\n        }\n        else {\n            viewPreset = presets.first;\n        }\n\n        const\n            lastOpts = me.lastViewPresetOptions || {},\n            options  = viewPreset.options || (viewPreset.options = {}),\n            event    = options.event = {\n                startDate : options.startDate,\n                endDate   : options.endDate,\n                from      : oldViewPreset,\n                to        : viewPreset,\n                preset    : viewPreset\n            },\n            presetChanged  = !me._viewPreset || !me._viewPreset.equals(viewPreset),\n            optionsChanged = datesDiffer(options.startDate, lastOpts.startDate) ||\n                datesDiffer(options.endDate, lastOpts.endDate) ||\n                datesDiffer(options.centerDate, lastOpts.centerDate) ||\n                (options.startDate && datesDiffer(options.startDate, me.startDate)) ||\n                (options.endDate && datesDiffer(options.endDate, me.endDate));\n\n        // Only return the value for onward processing if there's a change\n        if (presetChanged || optionsChanged) {\n\n            // Bypass the no-change check if the viewPreset is the same and we only got in here\n            // because different options were asked for.\n            if (!presetChanged) {\n                me._viewPreset = null;\n            }\n\n            /**\n             * Fired before the {@link #config-viewPreset} is changed.\n             * @event beforePresetChange\n             * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n             * @param {Date} startDate The new start date of the timeline.\n             * @param {Date} endDate The new end date of the timeline.\n             * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n             * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n             * @preventable\n             */\n            // Do not trigger events for the initial preset\n            if (me.isConfiguring || me.trigger('beforePresetChange', event) !== false) {\n                return viewPreset;\n            }\n        }\n    }\n\n    get displayDateFormat() {\n        return this._displayDateFormat || this.viewPreset.displayDateFormat;\n    }\n\n    updateDisplayDateFormat(format) {\n        // Start/EndDateColumn listens for this to change their format to match\n        this.trigger('displayDateFormatChange', { format });\n    }\n\n    /**\n     * Method to get a formatted display date\n     * @private\n     * @param {Date} date The date\n     * @returns {String} The formatted date\n     */\n    getFormattedDate(date) {\n        return DateHelper.format(date, this.displayDateFormat);\n    }\n\n    updateViewPreset(preset) {\n        const\n            me          = this,\n            { options } = preset,\n            {\n                event,\n                startDate,\n                endDate\n            }           = options,\n            {\n                isHorizontal,\n                _timeAxis : timeAxis,    // Do not tickle the getter, we are just peeking to see if it's there yet.\n                _timeAxisViewModel : timeAxisViewModel // Ditto\n            } = me,\n            rtl = isHorizontal && me.rtl;\n\n        let\n            {\n                centerDate,\n                zoomDate,\n                zoomPosition\n            }           = options,\n            forceUpdate = false;\n\n        // Options must not be reused when this preset is used again.\n        delete preset.options;\n\n        // Raise flag to prevent partner from changing view preset if one is in progress\n        me._viewPresetChanging = true;\n\n        if (timeAxis && !me.isConfiguring) {\n            const { timelineScroller } = me;\n\n            // Cache options only when they are applied so that non-change vetoing in changeViewPreset is accurate\n            me.lastViewPresetOptions = options;\n\n            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it\n            if (timeAxis.isConfigured) {\n                // None of this reconfiguring should cause a refresh\n                me.suspendRefresh();\n\n                // Set up these configs only if we actually have them.\n                const timeAxisCfg = ObjectHelper.copyProperties({}, me, [\n                    'weekStartDay',\n                    'startTime',\n                    'endTime'\n                ]);\n\n                if (me.infiniteScroll) {\n                    Object.assign(timeAxisCfg, timeAxisViewModel.calculateInfiniteScrollingDateRange(\n                        centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2),\n                        true,\n                        preset\n                    ));\n                }\n                // if startDate is provided we use it and the provided endDate\n                else if (startDate) {\n                    timeAxisCfg.startDate = startDate;\n                    timeAxisCfg.endDate = endDate;\n\n                    // if both dates are provided we can calculate centerDate for the viewport\n                    if (!centerDate && endDate) {\n                        centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);\n                    }\n\n                    // when no start/end dates are provided we use the current timespan\n                }\n                else {\n                    timeAxisCfg.startDate = timeAxis.startDate;\n                    timeAxisCfg.endDate = endDate || timeAxis.endDate;\n\n                    if (!centerDate) {\n                        centerDate = me.viewportCenterDate;\n                    }\n                }\n\n                timeAxis.isConfigured = false;\n                timeAxisCfg.viewPreset = preset;\n                timeAxis.reconfigure(timeAxisCfg, true);\n\n                timeAxisViewModel.reconfigure({\n                    viewPreset : preset,\n                    headers    : preset.headers,\n\n                    // This was hardcoded to 'middle' prior to the Preset refactor.\n                    // In the old code, the default headers were 'top' and 'middle', which\n                    // meant that 'middle' meant the lowest header.\n                    // So this is now length - 1.\n                    columnLinesFor : preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,\n\n                    tickSize : isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60\n                });\n\n                // Allow refresh to run after the reconfiguring, without refreshing since we will do that below anyway\n                me.resumeRefresh(false);\n            }\n\n            me.refresh();\n\n            // if view is rendered and scroll is not disabled by \"notScroll\" option\n            if (!options.notScroll && me.isPainted) {\n                if (options.visibleDate) {\n                    me.visibleDate = options.visibleDate;\n                }\n                // If a zoom at a certain date position is being requested, scroll the zoomDate\n                // to the required zoomPosition so that the zoom happens centered where the\n                // pointer events that are driving it targeted.\n                else if (zoomDate && zoomPosition) {\n                    const\n                        unitMagnitude = unitMagnitudes[timeAxis.resolutionUnit],\n                        unit          = unitMagnitude > 3 ? 'hour' : 'minute',\n                        milliseconds  = DateHelper.asMilliseconds((unit === 'minute' ? 15 : 1), unit),\n                        // Round the date to either 15 minutes for fine levels or 1 hour for coarse levels\n                        targetDate    = new Date(Math.round(zoomDate / milliseconds) * milliseconds);\n\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with zoom info, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.zoomDate = zoomDate;\n                    event.zoomPosition = zoomPosition;\n                    event.zoomLevel = options.zoomLevel;\n\n                    // Move the targetDate back under the mouse position as indicated by zoomPosition.\n                    // That is the offset into the TimeAxisSubGridElement.\n                    if (rtl) {\n                        timelineScroller.position = timelineScroller.scrollWidth - (me.getCoordinateFromDate(targetDate) + zoomPosition);\n                    }\n                    else {\n                        timelineScroller.position = me.getCoordinateFromDate(targetDate) - zoomPosition;\n                    }\n                }\n                // and we have centerDate to scroll to\n                else if (centerDate) {\n                    // remember the central date we scroll to (it gets reset after user scroll)\n                    me.cachedCenterDate = centerDate;\n\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with a centerDate, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.centerDate = centerDate;\n\n                    const\n                        viewportSize = me.timelineScroller.clientSize,\n                        centerCoord  = rtl ? me.timeAxisViewModel.totalSize - me.getCoordinateFromDate(centerDate, true)\n                            : me.getCoordinateFromDate(centerDate, true),\n                        coord        = Math.max(centerCoord - viewportSize / 2, 0);\n\n                    // The horizontal scroll handler must not invalidate the cached center\n                    // when this scroll event rolls round on the next frame.\n                    me.scrollingToCenter = true;\n\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if (coord === (me.isHorizontal ? me.scrollLeft : me.scrollTop)) {\n                        forceUpdate = true;\n                    }\n                    else if (me.isHorizontal) {\n                        me.scrollHorizontallyTo(coord, false);\n                    }\n                    else {\n                        me.scrollVerticallyTo(coord, false);\n                    }\n\n                    // Release the lock on scrolling invalidating the cached center.\n                    me.setTimeout(() => {\n                        me.scrollingToCenter = false;\n                    }, 100);\n                }\n                else {\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if ((me.isHorizontal ? me.scrollLeft : me.scrollTop) === 0) {\n                        forceUpdate = true;\n                    }\n                    // If we don't have a center date to scroll to, we reset scroll (this is bw compatible behavior)\n                    else {\n                        me.timelineScroller.scrollTo(0);\n                    }\n                }\n            }\n        }\n\n        // Update Scheduler element showing what preset is applied\n        me.dataset.presetId = preset.id;\n\n        /**\n         * Fired after the {@link #config-viewPreset} has changed.\n         * @event presetChange\n         * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n         * @param {Date} startDate The new start date of the timeline.\n         * @param {Date} centerDate The new center date of the timeline.\n         * @param {Date} endDate The new end date of the timeline.\n         * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n         * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n         * @preventable\n         */\n        me.trigger('presetChange', event);\n\n        me._viewPresetChanging = false;\n\n        if (forceUpdate) {\n            if (me.isHorizontal) {\n                me.currentOrientation.updateFromHorizontalScroll(me.scrollLeft, me.scrollX);\n            }\n            else {\n                me.currentOrientation.updateFromVerticalScroll(me.scrollTop);\n            }\n        }\n    }\n\n    //endregion\n\n    doDestroy() {\n        if (this._presets.owner === this) {\n            this._presets.destroy();\n        }\n        super.doDestroy();\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Cannot store name, will not be allowed when reapplying\n        if (result.viewPreset && result.viewPreset.name && !result.viewPreset.base) {\n            delete result.viewPreset.name;\n        }\n\n        return result;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineZoomable\n */\n\n/**\n * Options which may be used when changing the {@link Scheduler.view.Scheduler#property-viewPreset} property.\n *\n * @typedef {Object} ChangePresetOptions\n * @property {VisibleDate} [visibleDate] A `visibleDate` specification to bring into view after the new\n * `ViewPreset` is applied.\n * @property {Date} [startDate] New time frame start. If provided along with end, view will be centered in this\n * time interval, ignoring centerDate config. __Ignored if {@link Scheduler.view.Scheduler#config-infiniteScroll} is used.__\n * @property {Date} [endDate] New time frame end. __Ignored if {@link Scheduler.view.Scheduler#config-infiniteScroll} is used.__\n * @property {Date} [centerDate] Date to keep in center. Is ignored when start and end are provided.\n * @property {Date} [zoomDate] The date that should be positioned at the passed `datePosition` client offset.\n * @property {Number} [zoomPosition] The client offset at which the passed `zoomDate` should be positioned.\n * @property {Number} [width] Lowest tick width. Might be increased automatically\n */\n\n/**\n * Mixin providing \"zooming\" functionality.\n *\n * The zoom levels are stored as instances of {@link Scheduler.preset.ViewPreset}s, and are\n * cached centrally in the {@link Scheduler.preset.PresetManager}.\n *\n * The default presets are loaded into the {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}\n * store upon Scheduler instantiation. Preset selection is covered in the\n * {@link Scheduler.view.mixin.TimelineViewPresets} mixin.\n *\n * To specify custom zoom levels please provide a set of view presets to the global PresetManager store **before**\n * scheduler creation, or provide a set of view presets to a specific scheduler only:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @mixin\n */\nexport default Target => class TimelineZoomable extends (Target || Base) {\n    static $name = 'TimelineZoomable';\n\n    static defaultConfig = {\n        /**\n         * If true, you can zoom in and out on the time axis using CTRL-key + mouse wheel.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomOnMouseWheel : true,\n\n        /**\n         * True to zoom to time span when double-clicking a time axis cell.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomOnTimeAxisDoubleClick : true,\n\n        /**\n         * The minimum zoom level to which {@link #function-zoomOut} will work. Defaults to 0 (year ticks)\n         * @config {Number}\n         * @category Zoom\n         * @default\n         */\n        minZoomLevel : 0,\n\n        /**\n         * The maximum zoom level to which {@link #function-zoomIn} will work. Defaults to the number of\n         * {@link Scheduler.preset.ViewPreset ViewPresets} available, see {@link Scheduler/view/mixin/TimelineViewPresets#property-presets}\n         * for information. Unless you have modified the collection of available presets, the max zoom level is\n         * milliseconds.\n         * @config {Number}\n         * @category Zoom\n         * @default 23\n         */\n        maxZoomLevel : null,\n\n        /**\n         * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make\n         * the scrolling area `visibleZoomFactor` times wider than the timeline area itself. Used in\n         * {@link #function-zoomToSpan} and {@link #function-zoomToLevel} functions.\n         * @config {Number}\n         * @default\n         * @category Zoom\n         */\n        visibleZoomFactor : 5,\n\n        /**\n         * Whether the originally rendered timespan should be preserved while zooming. By default, it is set to `false`,\n         * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to\n         * render. When setting this option to `true`, be careful not to allow to zoom a big timespan in seconds\n         * resolution for example. That will cause **a lot** of HTML content to be rendered and affect performance. You\n         * can use {@link #config-minZoomLevel} and {@link #config-maxZoomLevel} config options for that.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomKeepsOriginalTimespan : null\n    };\n\n    // We cache the last mousewheel position, so that during zooming we can\n    // maintain a stable zoom point even if the mouse moves a little.\n    lastWheelTime = -1;\n    lastZoomPosition = -1;\n\n    construct(config) {\n        const me = this;\n\n        super.construct(config);\n\n        if (me.zoomOnMouseWheel) {\n            EventHelper.on({\n                element   : me.timeAxisSubGridElement,\n                wheel     : 'onWheel',\n                // Throttle zooming with the wheel a bit to have greater control of it\n                throttled : {\n                    buffer : 100,\n                    // Prevent events from slipping through the throttle, causing scroll\n                    alt    : e => e.ctrlKey && e.preventDefault()\n                },\n                thisObj : me,\n                capture : true,\n                passive : false\n            });\n        }\n\n        if (me.zoomOnTimeAxisDoubleClick) {\n            me.ion({\n                timeaxisheaderdblclick : ({ startDate, endDate }) => {\n                    if (!me.forceFit) {\n                        me.zoomToSpan({\n                            startDate,\n                            endDate\n                        });\n                    }\n                }\n            });\n        }\n    }\n\n    get maxZoomLevel() {\n        return this._maxZoomLevel || (this.presets.count - 1);\n    }\n\n    /**\n     * Get/set the {@link #config-maxZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set maxZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = this.presets.count - 1;\n        }\n\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `maxZoomLevel`');\n        }\n\n        this._maxZoomLevel = level;\n    }\n\n    get minZoomLevel() {\n        return this._minZoomLevel;\n    }\n\n    /**\n     * Sets the {@link #config-minZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set minZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = 0;\n        }\n\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `minZoomLevel`');\n        }\n\n        this._minZoomLevel = level;\n    }\n\n    /**\n     * Current zoom level, which is equal to the {@link Scheduler.preset.ViewPreset ViewPreset} index\n     * in the provided array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets zoom levels}.\n     * @property {Number}\n     * @category Zoom\n     */\n    get zoomLevel() {\n        return this.presets.indexOf(this.viewPreset);\n    }\n\n    // noinspection JSAnnotator\n    set zoomLevel(level) {\n        this.zoomToLevel(level);\n    }\n\n    /**\n     * Returns number of milliseconds per pixel.\n     * @param {Object} level Element from array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.\n     * Otherwise, density will be calculated for actual tick width.\n     * @returns {Number} Return number of milliseconds per pixel.\n     * @private\n     */\n    getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {\n        const\n            { bottomHeader } = preset,\n            // Scheduler uses direction independent tickSize, but presets are allowed to define different sizes for\n            // vertical and horizontal -> cant use preset.tickSize here\n            width            = this.isHorizontal ? preset.tickWidth : preset.tickHeight;\n\n        // trying to convert the unit + increment to a number of milliseconds\n        // this number is not fixed (month can be 28, 30 or 31 day), but at least this conversion\n        // will be consistent (should be no DST changes at year 1)\n        return Math.round(\n            (DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) /\n            // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)\n            // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`\n            (ignoreActualWidth ? width : preset.actualWidth || width)\n        );\n    }\n\n    /**\n     * Zooms to passed view preset, saving center date. Method accepts config object as a first argument, which can be\n     * reduced to primitive type (string,number) when no additional options required. e.g.:\n     * ```javascript\n     * // zooming to preset\n     * scheduler.zoomTo({ preset : 'hourAndDay' })\n     * // shorthand\n     * scheduler.zoomTo('hourAndDay')\n     *\n     * // zooming to level\n     * scheduler.zoomTo({ level : 0 })\n     * // shorthand\n     * scheduler.zoomTo(0)\n     * ```\n     *\n     * It is also possible to zoom to a time span by omitting `preset` and `level` configs, in which case scheduler sets\n     * the time frame to a specified range and applies zoom level which allows to fit all columns to this range. The\n     * given time span will be centered in the scheduling view (unless `centerDate` config provided). In the same time,\n     * the start/end date of the whole time axis will be extended to allow scrolling for user.\n     * ```javascript\n     * // zooming to time span\n     * scheduler.zoomTo({\n     *     startDate : new Date(..),\n     *     endDate : new Date(...)\n     * });\n     * ```\n     *\n     * @param {ViewPresetConfig|Object|String|Number} config Config object, preset name or zoom level index.\n     * @param {String} [config.preset] Preset name to zoom to. Ignores level config in this case\n     * @param {Number} [config.level] Zoom level to zoom to. Is ignored, if preset config is provided\n     * @param {VisibleDate} [config.visibleDate] A `visibleDate` specification to bring into view after the zoom.\n     * @param {Date} [config.startDate] New time frame start. If provided along with end, view will be centered in this\n     * time interval (unless `centerDate` is present)\n     * @param {Date} [config.endDate] New time frame end\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Date} [config.zoomDate] The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} [config.zoomPosition] The client offset at which the passed `date` should be positioned.\n     * @param {Number} [config.width] Lowest tick width. Might be increased automatically\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on (used, when zooming to span)\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on (used, when zooming to span)\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on (used, when zooming to span)\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on (used, when zooming to span)\n     * @category Zoom\n     */\n    zoomTo(config) {\n        const me = this;\n\n        if (typeof config === 'object') {\n            if (config.preset) {\n                me.zoomToLevel(config.preset, config);\n            }\n            else if (config.level != null) {\n                me.zoomToLevel(config.level, config);\n            }\n            else {\n                me.zoomToSpan(config);\n            }\n        }\n        else {\n            me.zoomToLevel(config);\n        }\n    }\n\n    /**\n     * Allows zooming to certain level of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} array.\n     * Automatically limits zooming between {@link #config-maxZoomLevel} and {@link #config-minZoomLevel}. Can also set\n     * time axis timespan to the supplied start and end dates.\n     *\n     * @param {Number} preset Level to zoom to.\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToLevel(preset, options = {}) {\n        if (this.forceFit) {\n            console.warn('Warning: The forceFit setting and zooming cannot be combined');\n            return;\n        }\n        // Sanitize numeric zooming.\n        if (typeof preset === 'number') {\n            preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);\n        }\n\n        const\n            me                 = this,\n            { presets }       = me,\n            tickSizeProp       = me.isVertical ? 'tickHeight' : 'tickWidth',\n            newPreset          = presets.createRecord(preset),\n            configuredTickSize = newPreset[tickSizeProp],\n            startDate          = options.startDate ? new Date(options.startDate) : null,\n            endDate            = options.endDate ? new Date(options.endDate) : null;\n\n        // If an existing ViewPreset id is used, this will replace it.\n        presets.add(newPreset);\n\n        let span = startDate && endDate ? { startDate, endDate } : null;\n\n        const\n            centerDate             = options.centerDate ? new Date(options.centerDate) : (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached);\n\n        let scrollableViewportSize = me.isVertical ? me.scrollable.clientHeight : me.timeAxisSubGrid.width;\n\n        if (scrollableViewportSize === 0) {\n            const\n                { _beforeCollapseState } = me.timeAxisSubGrid;\n\n            if (me.isHorizontal && me.timeAxisSubGrid.collapsed && _beforeCollapseState?.width) {\n                scrollableViewportSize = _beforeCollapseState.width;\n            }\n            else {\n                return null;\n            }\n        }\n\n        // Always calculate an optimal date range for the new zoom level\n        if (!span) {\n            span = me.calculateOptimalDateRange(centerDate, scrollableViewportSize, newPreset);\n        }\n\n        // Temporarily override tick size while reconfiguring the TimeAxisViewModel\n        if ('width' in options) {\n            newPreset.setData(tickSizeProp, options.width);\n        }\n\n        me.isZooming = true;\n\n        // Passed through to the viewPreset changing method\n        newPreset.options = {\n            ...options,\n            startDate : span.startDate || me.startDate,\n            endDate   : span.endDate || me.endDate,\n            centerDate\n        };\n        me.viewPreset = newPreset;\n\n        // after switching the view preset the `width` config of the zoom level may change, because of adjustments\n        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method\n        // will return the exact level index after zooming\n        newPreset.actualWidth = me.timeAxisViewModel.tickSize;\n\n        me.isZooming = false;\n\n        // Restore the tick size because the default presets are shared.\n        newPreset.setData(tickSizeProp, configuredTickSize);\n\n        return me.zoomLevel;\n    }\n\n    /**\n     * Changes the range of the scheduling chart to fit all the events in its event store.\n     * @param {Object} [options] Options object for the zooming operation.\n     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible\n     * date\n     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible\n     * date\n     */\n    zoomToFit(options) {\n        const eventStore = this.eventStore,\n            span       = eventStore.getTotalTimeSpan();\n\n        options = {\n            leftMargin  : 0,\n            rightMargin : 0,\n            ...options,\n            ...span\n        };\n\n        // Make sure we received a time span, event store might be empty\n        if (options.startDate && options.endDate) {\n            if (options.endDate > options.startDate) {\n                this.zoomToSpan(options);\n            }\n            else {\n                // If we only had a zero time span, just scroll it into view\n                this.scrollToDate(options.startDate);\n            }\n        }\n    }\n\n    /**\n     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.\n     *\n     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole\n     * time axis will be extended in the same way as {@link #function-zoomToLevel} method does, to allow scrolling for\n     * user.\n     *\n     * @param {Object} config The time frame.\n     * @param {Date} config.startDate The time frame start.\n     * @param {Date} config.endDate The time frame end.\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on\n     *\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToSpan(config = {}) {\n        if (config.leftMargin || config.rightMargin) {\n            config.adjustStart = 0;\n            config.adjustEnd = 0;\n        }\n\n        if (!config.leftMargin) config.leftMargin = 0;\n        if (!config.rightMargin) config.rightMargin = 0;\n\n        if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');\n\n        const\n            me           = this,\n            { timeAxis } = me,\n            // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt\n            needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;\n\n        let {\n            startDate,\n            endDate\n        } = config;\n\n        if (needToAdjust) {\n            startDate = DateHelper.add(startDate, -config.adjustStart, timeAxis.mainUnit);\n            endDate   = DateHelper.add(endDate, config.adjustEnd, timeAxis.mainUnit);\n        }\n\n        if (startDate <= endDate) {\n            // get scheduling view width\n            const\n                { availableSpace } = me.timeAxisViewModel,\n                presets = me.presets.allRecords,\n                diffMS  = endDate - startDate || 1;\n\n            // if potential width of col is less than col width provided by zoom level\n            //   - we'll zoom out panel until col width fit into width from zoom level\n            // and if width of column is more than width from zoom level\n            //   - we'll zoom in until col width fit won't fit into width from zoom level\n\n            let currLevel = me.zoomLevel,\n                inc, range;\n\n            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level\n            if (currLevel === -1) currLevel = 0;\n\n            let msPerPixel             = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true),\n                // increment to get next zoom level:\n                // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,\n                // so that more content will \"fit\" into 1 px\n                //\n                // +1 mean that given timespan will already fit into available width in the current zoom level, but,\n                // perhaps if we'll zoom in a bit more, the fitting will be better\n                candidateLevel         = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1),\n                zoomLevel, levelToZoom = null;\n\n            // loop over zoom levels\n            while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {\n                // get zoom level\n                zoomLevel = presets[candidateLevel];\n\n                msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n                const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;\n\n                // if zooming out\n                if (inc === -1) {\n                    // if columns fit into available space, then all is fine, we've found appropriate zoom level\n                    if (spanWidth <= availableSpace) {\n                        levelToZoom = candidateLevel;\n                        // stop searching\n                        break;\n                    }\n                    // if zooming in\n                }\n                else {\n                    // if columns still fits into available space, we need to remember the candidate zoom level as a potential\n                    // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit\n                    // into available view\n                    if (spanWidth <= availableSpace) {\n                        // if it's not currently active level\n                        if (currLevel !== candidateLevel - inc) {\n                            // remember this level as applicable\n                            levelToZoom = candidateLevel;\n                        }\n                    }\n                    else {\n                        // Sanity check to find the following case:\n                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is \"too small\" to fit and had to be expanded,\n                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel\n                        break;\n                    }\n                }\n\n                candidateLevel += inc;\n            }\n\n            // If we didn't find a large/small enough zoom level, use the lowest/highest level\n            levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;\n\n            // presets is the array of all ViewPresets this Scheduler is using\n            zoomLevel = presets[levelToZoom];\n\n            const unitToZoom = zoomLevel.bottomHeader.unit;\n\n            // Extract the correct msPerPixel value for the new zoom level\n            msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n\n            if (config.leftMargin || config.rightMargin) {\n                // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly\n                startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);\n                endDate   = new Date(endDate.getTime() + msPerPixel * config.rightMargin);\n            }\n\n            const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;\n\n            if (tickCount === 0) {\n                return null;\n            }\n\n            const\n                customWidth = Math.floor(availableSpace / tickCount),\n                centerDate  = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);\n\n            if (needToAdjust) {\n                range = {\n                    startDate,\n                    endDate\n                };\n            }\n            else {\n                range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);\n            }\n\n            let result = me.zoomLevel;\n\n            // No change of zoom level needed, just move to the date range\n            if (me.zoomLevel === levelToZoom) {\n                timeAxis.reconfigure(range);\n            }\n            else {\n                result = me.zoomToLevel(levelToZoom,\n                    Object.assign(range, {\n                        width : customWidth,\n                        centerDate\n                    })\n                );\n            }\n\n            if (me.infiniteScroll) {\n                me.scrollToDate(startDate, { block : 'start' });\n            }\n\n            return result;\n        }\n\n        return null;\n    }\n\n    /**\n     * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view\n     * will zoom in by this value. Otherwise, a value of `1` will be used.\n     *\n     * @param {Number} [levels] (optional) amount of levels to zoom in\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomIn(levels = 1, options) {\n        // Allow zoomIn({ visibleDate : ... })\n        if (typeof levels === 'object') {\n            options = levels;\n            levels = 1;\n        }\n        const currentZoomLevelIndex = this.zoomLevel;\n\n        if (currentZoomLevelIndex >= this.maxZoomLevel) {\n            return null;\n        }\n\n        return this.zoomToLevel(currentZoomLevelIndex + levels, options);\n    }\n\n    /**\n     * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view\n     * will zoom out by this value. Otherwise, a value of `1` will be used.\n     *\n     * @param {Number} levels (optional) amount of levels to zoom out\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOut(levels = 1, options) {\n        // Allow zoomOut({ visibleDate : ... })\n        if (typeof levels === 'object') {\n            options = levels;\n            levels = 1;\n        }\n        const currentZoomLevelIndex = this.zoomLevel;\n\n        if (currentZoomLevelIndex <= this.minZoomLevel) {\n            return null;\n        }\n\n        return this.zoomToLevel(currentZoomLevelIndex - levels, options);\n    }\n\n    /**\n     * Zooms in the timeline to the {@link #config-maxZoomLevel} according to the array of zoom levels.\n     *\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomInFull(options) {\n        return this.zoomToLevel(this.maxZoomLevel, options);\n    }\n\n    /**\n     * Zooms out the timeline to the {@link #config-minZoomLevel} according to the array of zoom levels.\n     *\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOutFull(options) {\n        return this.zoomToLevel(this.minZoomLevel, options);\n    }\n\n    /*\n     * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,\n     * as rendering too many columns takes noticeable amount of time so their number is limited.\n     * @category Zoom\n     * @private\n     */\n    calculateOptimalDateRange(centerDate, viewportSize, viewPreset, userProvidedSpan) {\n        // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming\n        // (even in case when user has provided own interval)\n        // other methods may override/hook into `calculateOptimalDateRange` to insert own processing\n        // (infinite scrolling feature does)\n        if (userProvidedSpan) return userProvidedSpan;\n\n        const\n            me               = this,\n            { timeAxis }     = me,\n            { bottomHeader } = viewPreset,\n            tickWidth        = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;\n\n        if (me.zoomKeepsOriginalTimespan) {\n            return {\n                startDate : timeAxis.startDate,\n                endDate   : timeAxis.endDate\n            };\n        }\n\n        const\n            unit       = bottomHeader.unit,\n            difference = Math.ceil(viewportSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2),\n            startDate  = DateHelper.add(centerDate, -difference, unit),\n            endDate    = DateHelper.add(centerDate, difference, unit);\n\n        if (me.infiniteScroll) {\n            return me.timeAxisViewModel.calculateInfiniteScrollingDateRange(centerDate, true);\n        }\n        else {\n            return {\n                startDate : timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),\n                endDate   : timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)\n            };\n        }\n    }\n\n    onElementMouseMove(event) {\n        const\n            {\n                isHorizontal,\n                zoomContext\n            } = this;\n\n        super.onElementMouseMove(event);\n\n        if (event.isTrusted && zoomContext) {\n            // Invalidate the zoomContext if mouse has strayed away from it\n            if (Math.abs(event[`client${isHorizontal ? 'X' : 'Y'}`] - zoomContext.coordinate) > 10) {\n                this.zoomContext = null;\n            }\n        }\n    }\n\n    async onWheel(event) {\n        if (event.ctrlKey && !this.forceFit) {\n            event.preventDefault();\n\n            const\n                me           = this,\n                {\n                    zoomContext,\n                    isHorizontal,\n                    timelineScroller,\n                    zoomLevel\n                }            = me,\n                now          = performance.now(),\n                coordinate   = event[`client${isHorizontal ? 'X' : 'Y'}`];\n\n            let zoomPosition = coordinate - timelineScroller.viewport[`${isHorizontal ? 'x' : 'y'}`];\n\n            // zoomPosition is the offset into the TimeAxisSubGridElement.\n            if (isHorizontal && me.rtl) {\n                zoomPosition = timelineScroller.viewport.width + timelineScroller.viewport.x - coordinate;\n            }\n\n            // If we are in a fast-arriving stream of wheel events, we use the same zoomDate as last time.\n            // If it's a new zoom gesture or the pointer has strayed away from the context then ascertain\n            // the gesture's center date\n            if (now - me.lastWheelTime > 200 || !zoomContext || Math.abs(coordinate - me.zoomContext.coordinate) > 20) {\n                // We're creating a zoom gesture which lasts as long as the\n                // wheel events keep arriving at the same timeline position\n                me.zoomContext = {\n                    // So we can track if we're going in (to finer resolutions)\n                    zoomLevel,\n\n                    // Pointer client(X|Y)\n                    coordinate,\n\n                    // Full TimeAxis offset position at which to place the date\n                    zoomPosition,\n\n                    // The date to place at the position\n                    zoomDate : me.getDateFromDomEvent(event)\n                };\n            }\n            // Use the current zoomContext's zoomDate, but at each level, the relative position of that date\n            // in the TimeAxis has to be corrected as the TimeAxis grows and scrolls to keep the zoomPosition\n            // stable.\n            else {\n                // If we zoom in to a finer resolution, get a more accurate centering date.\n                // If gesture was started at a years/months level, the date will be inaccurate.\n                if (zoomLevel > zoomContext.zoomLevel) {\n                    zoomContext.zoomDate = me.getDateFromDomEvent(event);\n                    zoomContext.zoomLevel = zoomLevel;\n                }\n                zoomContext.zoomPosition = zoomPosition;\n            }\n\n            me.lastWheelTime = now;\n            me[`zoom${event.deltaY > 0 ? 'Out' : 'In'}`](undefined, me.zoomContext);\n        }\n    }\n\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     * @param {Date} startDate The new start date\n     * @param {Date} [endDate] The new end date. If omitted or equal to startDate, the\n     * {@link Scheduler.preset.ViewPreset#field-defaultSpan} property of the current view preset will be used to\n     * calculate the new end date.\n     */\n    setTimeSpan(startDate, endDate) {\n        this.timeAxis.setTimeSpan(startDate, endDate);\n    }\n\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shift} for more information.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit) {\n        this.timeAxis.shift(amount, unit);\n    }\n\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount\n     * specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftNext} for more information.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount) {\n        this.timeAxis.shiftNext(amount);\n    }\n\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount\n     * specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftPrevious} for more\n     * information.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount) {\n        this.timeAxis.shiftPrevious(amount);\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineEventRendering\n */\n\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixin\n */\nexport default Target => class TimelineEventRendering extends (Target || Base) {\n    static get $name() {\n        return 'TimelineEventRendering';\n    }\n\n    //region Default config\n\n    static get defaultConfig() {\n        return {\n            resourceMargin : null,\n\n            /**\n             * When `true`, events are sized and positioned based on rowHeight, resourceMargin and barMargin settings.\n             * Set this to `false` if you want to control height and vertical position using CSS instead.\n             *\n             * Note that events always get an absolute top position, but when this setting is enabled that position\n             * will match row's top. To offset within the row using CSS, use `transform : translateY(y)`.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            managedEventSizing : true,\n\n            /**\n             * The CSS class added to an event/assignment when it is newly created\n             * in the UI and unsynced with the server.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            generatedIdCls : 'b-sch-dirty-new',\n\n            /**\n             * The CSS class added to an event when it has unsaved modifications\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            dirtyCls : 'b-sch-dirty',\n\n            /**\n             * The CSS class added to an event when it is currently committing changes\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            committingCls : 'b-sch-committing',\n\n            /**\n             * The CSS class added to an event/assignment when it ends outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            endsOutsideViewCls : 'b-sch-event-endsoutside',\n\n            /**\n             * The CSS class added to an event/assignment when it starts outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            startsOutsideViewCls : 'b-sch-event-startsoutside',\n\n            /**\n             * The CSS class added to an event/assignment when it is not draggable.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            fixedEventCls : 'b-sch-event-fixed',\n\n            /**\n             * Event style used by default. Events and resources can specify their own style, with priority order being:\n             * Event -> Resource -> Scheduler default. Determines the appearance of the event by assigning a CSS class\n             * to it. Available styles are:\n             *\n             * * `'plain'` (default) - flat look\n             * * `'border'` - has border in darker shade of events color\n             * * `'colored'` - has colored text and wide left border in same color\n             * * `'hollow'` - only border + text until hovered\n             * * `'line'` - as a line with the text below it\n             * * `'dashed'` - as a dashed line with the text below it\n             * * `'minimal'` - as a thin line with small text above it\n             * * `'rounded'` - minimalistic style with rounded corners\n             * * `null` - do not apply a default style and take control using custom CSS (easily overridden basic styling will be used).\n             *\n             * In addition, there are two styles intended to be used when integrating with Bryntum Calendar. To match\n             * the look of Calendar events, you can use:\n             *\n             * * `'calendar'` - a variation of the \"colored\" style matching the default style used by Calendar\n             * * `'interday'` - a variation of the \"plain\" style, for interday events\n             *\n             * @config {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'|null}\n             * @default\n             * @category Scheduled events\n             */\n            eventStyle : 'plain',\n\n            /**\n             * Event color used by default. Events and resources can specify their own color, with priority order being:\n             * Event -> Resource -> Scheduler default. Available colors are:\n             * * `HEX colors`\n             * * `'red'`\n             * * `'pink'`\n             * * `'purple'`\n             * * `'violet'`\n             * * `'indigo'`\n             * * `'blue'`\n             * * `'cyan'`\n             * * `'teal'`\n             * * `'green'`\n             * * `'lime'`\n             * * `'yellow'`\n             * * `'orange'`\n             * * `'deep-orange'`\n             * * `'gray'`\n             * * `'gantt-green'` (Useful when you want to match the color to the default color in Gantt)\n             * * `null` - do not apply a default color and take control using custom CSS (an easily overridden color will be used to make sure events are still visible).\n             *\n             * @member {'red'|'pink'|'purple'|'violet'|'indigo'|'blue'|'cyan'|'teal'|'green'|'lime'|'yellow'|'orange'|'deep-orange'|'gray'|'gantt-green'|String|null} eventColor\n             * @category Scheduled events\n             */\n            /**\n             * The event color used by the Scheduler. Events and resources can specify their own color. See\n             * {@link #property-eventColor} for more details.\n             *\n             * @config {'red'|'pink'|'purple'|'violet'|'indigo'|'blue'|'cyan'|'teal'|'green'|'lime'|'yellow'|'orange'|'deep-orange'|'gray'|'gantt-green'|String|null} eventColor\n             * @default 'green'\n             * @category Scheduled events\n             */\n            eventColor : 'green',\n\n            /**\n             * The width/height (depending on vertical / horizontal mode) of all the time columns.\n             * @config {Number}\n             * @category Scheduled events\n             */\n            tickSize : null\n        };\n    }\n\n    static configurable = {\n        /**\n         * Controls how much space to leave between stacked event bars in px.\n         *\n         * Value will be constrained by half the row height in horizontal mode.\n         *\n         * @prp {Number}\n         * @default\n         * @category Scheduled events\n         */\n        barMargin : 10,\n\n        /**\n         * Specify `true` to force rendered events/tasks to fill entire ticks. This only affects rendering, start\n         * and end dates retain their value on the data level.\n         *\n         * When enabling `fillTicks` you should consider either disabling EventDrag/TaskDrag and EventResize/TaskResize,\n         * or enabling {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}. Otherwise their behaviour might not\n         * be what a user expects.\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        fillTicks : false\n    };\n\n    //endregion\n\n    //region Settings\n\n    updateFillTicks(fillTicks) {\n        if (!this.isConfiguring) {\n            this.timeAxis.forceFullTicks = fillTicks && this.snap;\n\n            this.refreshWithTransition();\n\n            this.trigger('stateChange');\n        }\n    }\n\n    changeBarMargin(margin) {\n        ObjectHelper.assertNumber(margin, 'barMargin');\n\n        // bar margin should not exceed half of the row height\n        if (this.isHorizontal && this.rowHeight) {\n            return Math.min(Math.ceil(this.rowHeight / 2), margin);\n        }\n\n        return margin;\n    }\n\n    updateBarMargin() {\n        if (this.rendered) {\n            this.currentOrientation.onBeforeRowHeightChange();\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n\n    // Documented in SchedulerEventRendering to not show up in Gantt docs\n    get resourceMargin() {\n        return this._resourceMargin == null ? this.barMargin : this._resourceMargin;\n    }\n\n    set resourceMargin(margin) {\n        const me = this;\n\n        ObjectHelper.assertNumber(margin, 'resourceMargin');\n\n        // bar margin should not exceed half of the row height\n        if (me.isHorizontal && me.rowHeight) {\n            margin = Math.min(Math.ceil(me.rowHeight / 2), margin);\n        }\n\n        if (me._resourceMargin !== margin) {\n            me._resourceMargin = margin;\n            if (me.rendered) {\n                me.currentOrientation.onBeforeRowHeightChange();\n                me.refreshWithTransition();\n            }\n        }\n    }\n\n    /**\n     * Get/set the width/height (depending on mode) of all the time columns to the supplied value.\n     * There is a limit for the tick size value. Its minimal allowed value is calculated so ticks would fit the available space.\n     * Only applicable when {@link Scheduler.view.TimelineBase#config-forceFit} is set to `false`.\n     * To set `tickSize` freely skipping that limitation please set {@link Scheduler.view.TimelineBase#config-suppressFit} to `true`.\n     * @property {Number}\n     * @category Scheduled events\n     */\n    set tickSize(width) {\n        ObjectHelper.assertNumber(width, 'tickSize');\n\n        this.timeAxisViewModel.tickSize = width;\n    }\n\n    get tickSize() {\n        return this.timeAxisViewModel.tickSize;\n    }\n\n    /**\n     * Predefined event colors, useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventColors() {\n        return ['red', 'pink', 'purple', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'lime', 'yellow', 'orange', 'deep-orange', 'gray'];\n    }\n\n    /**\n     * Predefined event styles , useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventStyles() {\n        return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal', 'rounded'];\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineScroll\n */\nconst\n    maintainVisibleStart = {\n        maintainVisibleStart : true\n    },\n    defaultScrollOptions = {\n        block : 'nearest'\n    };\n\n/**\n * Functions for scrolling to events, dates etc.\n *\n * @mixin\n */\nexport default Target => class TimelineScroll extends (Target || Base) {\n    static get $name() {\n        return 'TimelineScroll';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * This config defines the size of the start and end invisible parts of the timespan when {@link #config-infiniteScroll} set to `true`.\n             *\n             * It should be provided as a coefficient, which will be multiplied by the size of the scheduling area.\n             *\n             * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to\n             * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting\n             * in 2200px of totally rendered content.\n             *\n             * @config {Number}\n             * @category Infinite scroll\n             * @default\n             */\n            bufferCoef : 5,\n\n            /**\n             * This config defines the scroll limit, which, when exceeded will cause a timespan shift.\n             * The limit is calculated as the `panelWidth * {@link #config-bufferCoef} * bufferThreshold`. During scrolling, if the left or right side\n             * has less than that of the rendered content - a shift is triggered.\n             *\n             * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan\n             * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.\n             * @config {Number}\n             * @category Infinite scroll\n             * @default\n             */\n            bufferThreshold : 0.2,\n\n            /**\n             * Configure as `true` to automatically adjust the panel timespan during scrolling in the time dimension,\n             * when the scroller comes close to the start/end edges.\n             *\n             * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based\n             * on the {@link #config-bufferCoef} option, and is thus not controlled by the {@link Scheduler/view/TimelineBase#config-startDate}\n             * and {@link Scheduler/view/TimelineBase#config-endDate} configs. The moment when the timespan shift\n             * happens is determined by the {@link #config-bufferThreshold} value.\n             *\n             * To specify initial point in time to view, supply the\n             * {@link Scheduler/view/TimelineBase#config-visibleDate} config.\n             *\n             * @config {Boolean} infiniteScroll\n             * @category Infinite scroll\n             * @default\n             */\n            infiniteScroll : false\n        };\n    }\n\n    initScroll() {\n        const\n            me = this,\n            {\n                isHorizontal,\n                visibleDate\n            }  = me;\n\n        super.initScroll();\n\n        const { scrollable } = isHorizontal ? me.timeAxisSubGrid : me;\n\n        scrollable.ion({\n            scroll  : 'onTimelineScroll',\n            thisObj : me\n        });\n\n        // Ensure the TimeAxis starts life at the correct size with buffer zones\n        // outside the visible window.\n        if (me.infiniteScroll) {\n            const\n                setTimeSpanOptions     = visibleDate ? { ...visibleDate, visibleDate : visibleDate.date } : { visibleDate : me.viewportCenterDate, block : 'center' },\n                { startDate, endDate } = me.timeAxisViewModel.calculateInfiniteScrollingDateRange(setTimeSpanOptions.visibleDate, setTimeSpanOptions.block === 'center');\n\n            // Don't ask to maintain visible start - we're initializing - there's no visible start yet.\n            // If there's a visibleDate set, it will execute its scroll on paint.\n            me.setTimeSpan(\n                startDate,\n                endDate,\n                setTimeSpanOptions\n            );\n        }\n    }\n\n    /**\n     * A {@link Core.helper.util.Scroller} which scrolls the time axis in whatever {@link Scheduler.view.Scheduler#config-mode} the\n     * Scheduler is configured, either `horiontal` or `vertical`.\n     *\n     * The width and height dimensions are replaced by `size`. So this will expose the following properties:\n     *\n     *    - `clientSize` The size of the time axis viewport.\n     *    - `scrollSize` The full scroll size of the time axis viewport\n     *    - `position` The position scrolled to along the time axis viewport\n     *\n     * @property {Core.helper.util.Scroller}\n     * @readonly\n     * @category Scrolling\n     */\n    get timelineScroller() {\n        const me = this;\n\n        if (!me.scrollInitialized) {\n            me.initScroll();\n        }\n        return me._timelineScroller || (me._timelineScroller = new TimelineScroller({\n            widget       : me,\n            scrollable   : me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n            isHorizontal : me.isHorizontal\n        }));\n    }\n\n    doDestroy() {\n        this._timelineScroller?.destroy();\n\n        super.doDestroy();\n    }\n\n    onTimelineScroll({ source }) {\n        // On scroll, check if we are nearing the end to see if the sliding window needs moving.\n        // onSchedulerHorizontalScroll is delayed to animationFrame\n        if (this.infiniteScroll) {\n            this.checkTimeAxisScroll(source[this.isHorizontal ? 'x' : 'y']);\n        }\n    }\n\n    checkTimeAxisScroll(scrollPos) {\n        const\n            me             = this,\n            scrollable     = me.timelineScroller,\n            { clientSize } = scrollable,\n            requiredSize   = clientSize * me.bufferCoef,\n            limit          = requiredSize * me.bufferThreshold,\n            maxScroll      = scrollable.maxPosition,\n            { style }      = me.timeAxisSubGrid.virtualScrollerElement;\n\n        // if scroll violates limits let's shift timespan\n        if ((maxScroll - scrollPos < limit) || scrollPos < limit) {\n            // If they were dragging the thumb, this must be a one-time thing. They *must* lose contact\n            // with the thumb when the window shift occurs and the thumb zooms back to the center.\n            // Changing for a short time to overflow:hidden terminates the thumb drag.\n            // They can start again from the center, the reset happens very quickly.\n            style.overflow = 'hidden';\n            style.pointerEvents = 'none';\n\n            // Avoid content height changing when scrollbar disappears\n            style.paddingBottom = `${DomHelper.scrollBarWidth}px`;\n\n            me.setTimeout(() => {\n                style.overflow = '';\n                style.paddingBottom = '';\n                style.pointerEvents = '';\n            }, 100);\n\n            me.shiftToDate(me.getDateFromCoordinate(scrollPos, null, true, false, true));\n        }\n    }\n\n    shiftToDate(date, centered) {\n        const newRange = this.timeAxisViewModel.calculateInfiniteScrollingDateRange(date, centered);\n\n        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position\n        this.setTimeSpan(newRange.startDate, newRange.endDate, maintainVisibleStart);\n    }\n\n    // If we change to infinite scrolling dynamically, it should create the buffer zones.\n    updateInfiniteScroll(infiniteScroll) {\n        // At construction time, this is handled in initScroll.\n        // This is just here to handle dynamic updates.\n        if (!this.isConfiguring && infiniteScroll) {\n            this.checkTimeAxisScroll(this.timelineScroller.position);\n        }\n    }\n\n    //region Scroll to date\n\n    /**\n     * Scrolls the timeline \"tick\" encapsulating the passed `Date` into view according to the passed options.\n     * @param {Date} date The date to which to scroll the timeline\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    async scrollToDate(date, options = {}) {\n        const\n            me               = this,\n            {\n                timeAxis,\n                visibleDateRange,\n                infiniteScroll\n            }              = me,\n            {\n                unit,\n                increment\n            }              = timeAxis,\n            edgeOffset     = options.edgeOffset || 0,\n            visibleWidth   = DateHelper.ceil(visibleDateRange.endDate, increment + ' ' + unit) - DateHelper.floor(visibleDateRange.startDate, increment + ' ' + unit),\n            direction      = date > me.viewportCenterDate ? 1 : -1,\n            extraScroll    = (infiniteScroll ? visibleWidth * me.bufferCoef * me.bufferThreshold : (options.block === 'center' ? visibleWidth / 2 : (edgeOffset ? me.getMilliSecondsPerPixelForZoomLevel(me.viewPreset) * edgeOffset : 0))) * direction,\n            visibleDate    = new Date(date.getTime() + extraScroll),\n            shiftDirection = visibleDate > timeAxis.endDate ? 1 : visibleDate < timeAxis.startDate ? -1 : 0;\n\n        // Required visible date outside TimeAxis and infinite scrolling, that has opinions about how\n        // much scroll range has to be created after the target date.\n        if (shiftDirection && me.infiniteScroll) {\n            me.shiftToDate(new Date(date - extraScroll), null, true);\n            // shift to date could trigger a native browser async scroll out of our control. If a scroll\n            // happens during scrollToCoordinate, the scrolling is cancelled so we wait a bit here\n            await me.nextAnimationFrame();\n        }\n\n        const\n            scrollerViewport = me.timelineScroller.viewport,\n            localCoordinate  = me.getCoordinateFromDate(date, true),\n            // Available space can be less than tick size (Export.t.js in Gantt)\n            width            = Math.min(me.timeAxisViewModel.tickSize, me.timeAxisViewModel.availableSpace),\n            target           = me.isHorizontal\n                // In RTL coordinate is for the right edge of the tick, so we need to subtract width\n                ? new Rectangle(me.getCoordinateFromDate(date, false) - (me.rtl ? width : 0), scrollerViewport.y, width, scrollerViewport.height)\n                : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);\n\n        await me.scrollToCoordinate(localCoordinate, target, date, options);\n    }\n\n    /**\n     * Scrolls to current time.\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollToNow(options = {}) {\n        return this.scrollToDate(new Date(), options);\n    }\n\n    /**\n     * Used by {@link #function-scrollToDate} to scroll to correct coordinate.\n     * @param {Number} localCoordinate Coordinate to scroll to\n     * @param {Date} date Date to scroll to, used for reconfiguring the time axis\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @private\n     * @category Scrolling\n     */\n    async scrollToCoordinate(localCoordinate, target, date, options = {}) {\n        const me = this;\n\n        // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with\n        // startTime/endTime config\n        if (localCoordinate < 0) {\n            // adjust the timeaxis first\n            const\n                visibleSpan         = me.endDate - me.startDate,\n                { unit, increment } = me.timeAxis,\n                newStartDate        = DateHelper.floor(new Date(date.getTime() - (visibleSpan / 2)), increment + ' ' + unit),\n                newEndDate          = DateHelper.add(newStartDate, visibleSpan);\n\n            // We're trying to reconfigure time span to current dates, which means we are as close to center as it\n            // could be. Do nothing then.\n            // covered by 1102_panel_api\n            if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {\n                me.setTimeSpan(newStartDate, newEndDate);\n\n                return me.scrollToDate(date, options);\n            }\n\n            return;\n        }\n\n        await me.timelineScroller.scrollIntoView(target, options);\n\n        // Horizontal scroll is triggered on next frame in SubGrid.js, view is not up to date yet. Resolve on next frame\n        return !me.isDestroyed && me.nextAnimationFrame();\n    }\n\n    //endregion\n\n    //region Relative scrolling\n    // These methods are important to users because although they are mixed into the top level Grid/Scheduler,\n    // for X scrolling the explicitly target the SubGrid that holds the scheduler.\n\n    /**\n     * Get/set the `scrollLeft` value of the SubGrid that holds the scheduler.\n     *\n     * This may be __negative__ when the writing direction is right-to-left.\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollLeft(left) {\n        this.timeAxisSubGrid.scrollable.element.scrollLeft = left;\n    }\n\n    get scrollLeft() {\n        return this.timeAxisSubGrid.scrollable.element.scrollLeft;\n    }\n\n    /**\n     * Get/set the writing direction agnostic horizontal scroll position.\n     *\n     * This is always the __positive__ offset from the scroll origin whatever the writing\n     * direction in use.\n     *\n     * Applies to the SubGrid that holds the scheduler\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollX(x) {\n        this.timeAxisSubGrid.scrollable.x = x;\n    }\n\n    get scrollX() {\n        return this.timeAxisSubGrid.scrollable.x;\n    }\n\n    /**\n     * Get/set vertical scroll\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollTop(top) {\n        this.scrollable.y = top;\n    }\n\n    get scrollTop() {\n        return this.scrollable.y;\n    }\n\n    /**\n     * Horizontal scrolling. Applies to the SubGrid that holds the scheduler\n     * @param {Number} x\n     * @param {ScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollHorizontallyTo(coordinate, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);\n    }\n\n    /**\n     * Vertical scrolling\n     * @param {Number} y\n     * @param {ScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollVerticallyTo(y, options = true) {\n        return this.scrollable.scrollTo(null, y, options);\n    }\n\n    /**\n     * Scrolls the subgrid that contains the scheduler\n     * @param {Number} x\n     * @param {ScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollTo(x, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n\n// Internal class used to interrogate and manipulate the timeline scroll position.\n// This delegates all operations to the appropriate Scroller, horizontal or vertical.\nclass TimelineScroller extends Scroller {\n    static get configurable() {\n        return {\n            position : null,\n            x        : null,\n            y        : null\n        };\n    }\n\n    // This class is passive about configuring the element.\n    // It has no opinions about *how* the overflow is handled.\n    updateOverflowX() {}\n    updateOverflowY() {}\n\n    onScroll(e) {\n        super.onScroll(e);\n        this._position = null;\n    }\n\n    syncPartners(force) {\n        this.scrollable.syncPartners(force);\n    }\n\n    updatePosition(position) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = position;\n    }\n\n    get viewport() {\n        return this.scrollable.viewport;\n    }\n\n    get position() {\n        return this._position = this.scrollable[this.isHorizontal ? 'x' : 'y'];\n    }\n\n    get clientSize() {\n        return this.scrollable[`client${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n\n    get scrollSize() {\n        return this.scrollable[`scroll${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n\n    get maxPosition() {\n        return this.scrollable[`max${this.isHorizontal ? 'X' : 'Y'}`];\n    }\n\n    scrollTo(position, options) {\n        return this.isHorizontal ? this.scrollable.scrollTo(position, null, options) : this.scrollable.scrollTo(null, position, options);\n    }\n\n    scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {\n        // Use the correct delta by default, but if it's zero, accommodate axis error.\n        return this.isHorizontal ? this.scrollable.scrollBy(xDelta || yDelta, 0, options) : this.scrollable.scrollBy(0, yDelta || xDelta, options);\n    }\n\n    scrollIntoView() {\n        return this.scrollable.scrollIntoView(...arguments);\n    }\n\n    // We accommodate mistakes. Setting X and Y sets the appropriate scroll axis position\n    changeX(x) {\n        this.position = x;\n    }\n\n    changeY(y) {\n        this.position = y;\n    }\n\n    get x() {\n        return this.position;\n    }\n\n    set x(x) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = x;\n    }\n\n    get y() {\n        return this.position;\n    }\n\n    set y(y) {\n        this.scroller[this.isHorizontal ? 'x' : 'y'] = y;\n    }\n\n    get clientWidth() {\n        return this.clientSize;\n    }\n\n    get clientHeight() {\n        return this.clientSize;\n    }\n\n    get scrollWidth() {\n        return this.scrollSize;\n    }\n\n    get scrollHeight() {\n        return this.scrollSize;\n    }\n\n    get maxX() {\n        return this.maxPosition;\n    }\n\n    get maxY() {\n        return this.maxPosition;\n    }\n}\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineState\n */\n\nconst copyProperties = [\n    'barMargin'\n];\n\n/**\n * Mixin for Timeline base that handles state. It serializes the following timeline properties:\n *\n * * barMargin\n * * zoomLevel\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class TimelineState extends (Target || Base) {\n    static get $name() {\n        return 'TimelineState';\n    }\n\n    /**\n     * Gets or sets timeline's state. Check out {@link Scheduler.view.mixin.TimelineState} mixin for details.\n     * @member {Object} state\n     * @property {Object[]} state.columns\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.style\n     * @property {String} state.selectedCell\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @property {Object} state.subGrids\n     * @property {Number} state.barMargin\n     * @property {Number} state.zoomLevel\n     * @category State\n     */\n\n    /**\n     * Get timeline's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            state = ObjectHelper.copyProperties(super.getState(), me, copyProperties);\n\n        state.zoomLevel = me.zoomLevel;\n\n        state.zoomLevelOptions = {\n            startDate  : me.startDate,\n            endDate    : me.endDate,\n            // With infinite scroll reading viewportCenterDate too early will lead to exception\n            centerDate : !me.infiniteScroll || me.timeAxisViewModel.availableSpace ? me.viewportCenterDate : undefined,\n            width      : me.tickSize\n        };\n\n        return state;\n    }\n\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n\n        me.suspendRefresh();\n\n        ObjectHelper.copyProperties(me, state, copyProperties);\n\n        super.applyState(state);\n\n        if (state.zoomLevel != null) {\n            // Do not restore left scroll, infinite scroll should do all the work\n            if (me.infiniteScroll) {\n                if (state?.scroll?.scrollLeft) {\n                    state.scroll.scrollLeft = {};\n                }\n            }\n\n            if (me.isPainted) {\n                me.zoomToLevel(state.zoomLevel, state.zoomLevelOptions);\n            }\n            else {\n                me._zoomAfterPaint = { zoomLevel : state.zoomLevel, zoomLevelOptions : state.zoomLevelOptions };\n            }\n        }\n\n        me.resumeRefresh(true);\n    }\n\n    onPaint(...args) {\n        super.onPaint(...args);\n\n        if (this._zoomAfterPaint) {\n            const { zoomLevel, zoomLevelOptions } = this._zoomAfterPaint;\n\n            this.zoomToLevel(zoomLevel, zoomLevelOptions);\n\n            delete this._zoomAfterPaint;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import GridHeader from '../../Grid/view/Header.js';\n\n/**\n * @module Scheduler/view/Header\n */\n\n/**\n * Custom header subclass which handles the existence of the special TimeAxisColumn\n *\n * @extends Grid/view/Header\n * @private\n */\nexport default class Header extends GridHeader {\n    static get $name() {\n        return 'SchedulerHeader';\n    }\n\n    refreshContent() {\n        // Only render contents into the header once as it contains the special rendering of the TimeAxisColumn\n        // In case ResizeObserver polyfill is used headers element will have resize monitors inserted and we should\n        // take that into account\n        // https://github.com/bryntum/support/issues/3444\n        if (!this.headersElement?.querySelector('.b-sch-timeaxiscolumn')) {\n            super.refreshContent();\n        }\n    }\n}\n", "import SubGrid from '../../Grid/view/SubGrid.js';\nimport Header from './Header.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/view/TimeAxisSubGrid\n */\n\n/**\n * Widget that encapsulates the SubGrid part of the scheduler which houses the timeline view.\n * @extends Grid/view/SubGrid\n * @private\n */\nexport default class TimeAxisSubGrid extends SubGrid {\n\n    static get $name() {\n        return 'TimeAxisSubGrid';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'timeaxissubgrid';\n    }\n\n    static get configurable() {\n        return {\n            // A Scheduler's SubGrid doesn't accept external columns moving in\n            sealedColumns : true,\n\n            // Use Scheduler's Header class\n            headerClass : Header\n        };\n    }\n\n    startConfigure(config) {\n        const { grid : scheduler } = config;\n\n        // Scheduler references its TimeAxisSubGrid instance through this property.\n        scheduler.timeAxisSubGrid = this;\n\n        super.startConfigure(config);\n\n        if (scheduler.isHorizontal) {\n            config.header = {\n                cls : {\n                    'b-sticky-headers' : scheduler.stickyHeaders\n                }\n            };\n            // We don't use what the GridSubGrids mixin tells us to.\n            // We use the Sheduler's Header class.\n            delete config.headerClass;\n        }\n\n        // If user have not specified a width or flex for scheduler region, default to flex=1\n        if (!('flex' in config || 'width' in config)) {\n            config.flex = 1;\n        }\n    }\n\n    changeScrollable() {\n        const\n            me         = this,\n            scrollable = super.changeScrollable(...arguments);\n\n        // TimeAxisSubGrid's X axis is stretched by its canvas.\n        // We don't need the Scroller's default stretching implementation.\n        if (scrollable) {\n            Object.defineProperty(scrollable, 'scrollWidth', {\n                get() {\n                    return this.element?.scrollWidth ?? 0;\n                },\n                set() {\n                    // Setting the scroll width to be wide just updates the canvas side in Scheduler.\n                    // We do not need the Scroller's default stretcher element to be added.\n                    // Note that \"me\" here is the TimeAxisSubGrid, so we are calling Scheduler.\n                    me.grid.updateCanvasSize();\n                }\n            });\n        }\n\n        return scrollable;\n    }\n\n    syncScrollingPartners(addCls = true) {\n        // Swallow scroll syncing calls that happen during view preset changes, that process triggers multiple when\n        // it first changes tickWidth, then scrolls to center and then an additional sync on scroll end\n        if (!this.grid._viewPresetChanging) {\n            super.syncScrollingPartners(addCls);\n        }\n    }\n\n    /**\n     * This is an event handler triggered when the TimeAxisSubGrid changes size.\n     * Its height changes when content height changes, and that is not what we are\n     * interested in here. If the *width* changes, that means the visible viewport\n     * has changed size.\n     * @param {HTMLElement} element\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} oldWidth\n     * @param {Number} oldHeight\n     * @private\n     */\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        const me = this;\n\n        // We, as the TimeAxisSubGrid dictate the scheduler viewport width\n        if (me.isPainted && width !== oldWidth) {\n            const\n                scheduler  = me.grid,\n                bodyHeight = scheduler._bodyRectangle.height;\n\n            // Avoid ResizeObserver errors when this operation may create a scrollbar\n            if (DomHelper.scrollBarWidth && width < oldWidth) {\n                me.monitorResize = false;\n            }\n            scheduler.onSchedulerViewportResize(width, bodyHeight, oldWidth, bodyHeight);\n\n            // Revert to monitoring on the next animation frame.\n            // This is to avoid \"ResizeObserver loop completed with undelivered notifications.\"\n            if (!me.monitorResize) {\n                me.requestAnimationFrame(() => me.monitorResize = true);\n            }\n        }\n\n        super.onInternalResize(...arguments);\n    }\n\n    // When restoring state we need to update time axis size immediately, resize event is not triggered fast enough to\n    // restore center date consistently\n    clearWidthCache() {\n        super.clearWidthCache();\n\n        // Check if we are in horizontal mode\n        if (this.owner.isHorizontal) {\n            this.owner.updateViewModelAvailableSpace(this.width);\n        }\n    }\n\n    async expand() {\n        const { owner } = this;\n\n        await super.expand();\n\n        if (owner.isPainted) {\n            owner.timeAxisViewModel.update(this.width, false, true);\n        }\n    }\n}\n\n// Register this widget type with its Factory\nTimeAxisSubGrid.initClass();\n", "import GlobalEvents from '../../Core/GlobalEvents.js';\nimport GridBase from '../../Grid/view/GridBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport FunctionHelper from '../../Core/helper/FunctionHelper.js';\nimport ResizeMonitor from '../../Core/helper/ResizeMonitor.js';\nimport Collection from '../../Core/util/Collection.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport TimeAxis from '../data/TimeAxis.js';\n\nimport TimeAxisViewModel from './model/TimeAxisViewModel.js';\nimport TimelineDateMapper from './mixin/TimelineDateMapper.js';\nimport TimelineDomEvents from './mixin/TimelineDomEvents.js';\nimport TimelineViewPresets from './mixin/TimelineViewPresets.js';\nimport TimelineZoomable from './mixin/TimelineZoomable.js';\nimport RecurringEvents from './mixin/RecurringEvents.js';\nimport TimelineEventRendering from './mixin/TimelineEventRendering.js';\nimport TimelineScroll from './mixin/TimelineScroll.js';\nimport TimelineState from './mixin/TimelineState.js';\nimport './TimeAxisSubGrid.js';\n\nconst\n    exitTransition = {\n        fn                : 'exitTransition',\n        delay             : 0,\n        cancelOutstanding : true\n    },\n    emptyObject    = {};\n\n/**\n * @module Scheduler/view/TimelineBase\n */\n\n/**\n * Options accepted by the Scheduler's {@link Scheduler.view.Scheduler#config-visibleDate} property.\n *\n * @typedef {Object} VisibleDate\n * @property {Date} date The date to bring into view.\n * @property {'start'|'end'|'center'|'nearest'} [block] How far to scroll the date.\n * @property {Number} [edgeOffset] edgeOffset A margin around the date to bring into view.\n * @property {AnimateScrollOptions|Boolean|Number} [animate] Set to `true` to animate the scroll by 300ms,\n * or the number of milliseconds to animate over, or an animation config object.\n */\n\n/**\n * Abstract base class used by timeline based components such as Scheduler and Gantt. Based on Grid, supplies a \"locked\"\n * region for columns and a \"normal\" for rendering of events etc.\n * @abstract\n *\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineState\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/view/mixin/RecurringEvents\n *\n * @extends Grid/view/Grid\n */\nexport default class TimelineBase extends GridBase.mixin(\n    TimelineDateMapper,\n    TimelineDomEvents,\n    TimelineEventRendering,\n    TimelineScroll,\n    TimelineState,\n    TimelineViewPresets,\n    TimelineZoomable,\n    RecurringEvents\n) {\n    //region Config\n\n    static get $name() {\n        return 'TimelineBase';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'timelinebase';\n    }\n\n    static configurable = {\n        partnerSharedConfigs : {\n            value : ['timeAxisViewModel', 'timeAxis', 'viewPreset'],\n\n            $config : {\n                merge : 'distinct'\n            }\n        },\n\n        /**\n         * Get/set startDate. Defaults to current date if none specified.\n         *\n         * When using {@link #config-infiniteScroll}, use {@link #config-visibleDate} to control initially visible date\n         * instead.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} startDate\n         * @category Common\n         */\n        /**\n         * The start date of the timeline (if not configure with {@link #config-infiniteScroll}).\n         *\n         * If omitted, and a TimeAxis has been set, the start date of the provided {@link Scheduler.data.TimeAxis} will\n         * be used. If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no\n         * date information exists in the event data set, it defaults to the current date and time.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n         *\n         * When using {@link #config-infiniteScroll}, use {@link #config-visibleDate} to control initially visible date\n         * instead.\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        startDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n\n        /**\n         * Get/set endDate. Defaults to startDate + default span of the used ViewPreset.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} endDate\n         * @category Common\n         */\n        /**\n         * The end date of the timeline (if not configure with {@link #config-infiniteScroll}).\n         *\n         * If omitted, it will be calculated based on the {@link #config-startDate} setting and the 'defaultSpan'\n         * property of the current {@link #config-viewPreset}.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        endDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n\n        /**\n         * When set, the text in the major time axis header sticks in the scrolling viewport as long as possible.\n         * @config {Boolean}\n         * @default\n         * @category Time axis\n         */\n        stickyHeaders : true,\n\n        /**\n         * A scrolling `options` object describing the scroll action, including a `date` option\n         * which references a `Date`. See {@link #function-scrollToDate} for details about scrolling options.\n         *\n         * ```javascript\n         *     // The date we want in the center of the Scheduler viewport\n         *     myScheduler.visibleDate = {\n         *         date    : new Date(2023, 5, 17, 12),\n         *         block   : 'center',\n         *         animate : true\n         *     };\n         * ```\n         * @member {Object} visibleDate\n         * @category Common\n         */\n        /**\n         * A date to bring into view initially on the scrollable timeline.\n         *\n         * This may be configured as either a `Date` or a scrolling `options` object describing\n         * the scroll action, including a `date` option which references a `Date`.\n         *\n         * See {@link #function-scrollToDate} for details about scrolling options.\n         *\n         * Note that if a naked `Date` is passed, it will be stored internally as a scrolling options object\n         * using the following defaults:\n         *\n         * ```javascript\n         * {\n         *     date  : <The Date object>,\n         *     block : 'nearest'\n         * }\n         * ```\n         *\n         * This moves the date into view by the shortest scroll, so that it just appears at an edge.\n         *\n         * To bring your date of interest to the center of the viewport, configure your\n         * Scheduler thus:\n         *\n         * ```javascript\n         *     visibleDate : {\n         *         date  : new Date(2023, 5, 17, 12),\n         *         block : 'center'\n         *     }\n         * ```\n         * @config {Date|VisibleDate}\n         * @category Common\n         */\n        visibleDate : null,\n\n        /**\n         * CSS class to add to rendered events\n         * @config {String}\n         * @category CSS\n         * @private\n         */\n        eventCls : null,\n\n        /**\n         * Set to `true` to force the time columns to fit to the available space (horizontal or vertical depends on mode).\n         * Note that setting {@link #config-suppressFit} to `true`, will disable `forceFit` functionality. Zooming\n         * cannot be used when `forceFit` is set.\n         * @prp {Boolean}\n         * @default\n         * @category Time axis\n         */\n        forceFit : false,\n\n        /**\n         * Set to a time zone or a UTC offset. This will set the projects\n         * {@link Scheduler.model.ProjectModel#config-timeZone} config accordingly. As this config is only a referer,\n         * please se project's config {@link Scheduler.model.ProjectModel#config-timeZone documentation} for more\n         * information.\n         *\n         * ```javascript\n         * new Calendar(){\n         *   timeZone : 'America/Chicago'\n         * }\n         * ```\n         * @prp {String|Number} timeZone\n         * @category Misc\n         */\n        timeZone : null\n\n    };\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.\n             * When omitted, the week start day is retrieved from the active locale class.\n             * @config {Number} weekStartDay\n             * @category Time axis\n             */\n\n            /**\n             * An object with format `{ fromDay, toDay, fromHour, toHour }` that describes the working days and hours.\n             * This object will be used to populate TimeAxis {@link Scheduler.data.TimeAxis#config-include} property.\n             *\n             * Using it results in a non-continuous time axis. Any ticks not covered by the working days and hours will\n             * be excluded. Events within larger ticks (for example if using week as the unit for ticks) will be\n             * stretched to fill the gap otherwise left by the non working hours.\n             *\n             * As with end dates, `toDay` and `toHour` are exclusive. Thus `toDay : 6` means that day 6 (saturday) will\n             * not be included.\n             *\n             *\n             * **NOTE:** When this feature is enabled {@link Scheduler.view.mixin.TimelineZoomable Zooming feature} is\n             * not supported. It's recommended to disable zooming controls:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     zoomOnMouseWheel          : false,\n             *     zoomOnTimeAxisDoubleClick : false,\n             *     ...\n             * });\n             * ```\n             *\n             * @config {Object}\n             * @category Time axis\n             */\n            workingTime : null,\n\n            /**\n             * A backing data store of 'ticks' providing the input date data for the time axis of timeline panel.\n             * @member {Scheduler.data.TimeAxis} timeAxis\n             * @readonly\n             * @category Time axis\n             */\n\n            /**\n             * A {@link Scheduler.data.TimeAxis} config object or instance, used to create a backing data store of\n             * 'ticks' providing the input date data for the time axis of timeline panel. Created automatically if none\n             * supplied.\n             * @config {TimeAxisConfig|Scheduler.data.TimeAxis}\n             * @category Time axis\n             */\n            timeAxis : null,\n\n            /**\n             * The backing view model for the visual representation of the time axis.\n             * Either a real instance or a simple config object.\n             * @private\n             * @config {Scheduler.view.model.TimeAxisViewModel|TimeAxisViewModelConfig}\n             * @category Time axis\n             */\n            timeAxisViewModel : null,\n\n            /**\n             * You can set this option to `false` to make the timeline panel start and end on the exact provided\n             * {@link #config-startDate}/{@link #config-endDate} w/o adjusting them.\n             * @config {Boolean}\n             * @default\n             * @category Time axis\n             */\n            autoAdjustTimeAxis : true,\n\n            /**\n             * Affects drag drop and resizing of events when {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}\n             * is enabled.\n             *\n             * If set to `true`, dates will be snapped relative to event start. e.g. for a zoom level with\n             * `timeResolution = { unit: \"s\", increment: \"20\" }`, an event that starts at 10:00:03 and is dragged would\n             * snap its start date to 10:00:23, 10:00:43 etc.\n             *\n             * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start)\n             * - 10:00:03 -> 10:00:20, 10:00:40 etc.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            snapRelativeToEventStartDate : false,\n\n            /**\n             * Set to `true` to prevent auto calculating of a minimal {@link Scheduler.view.mixin.TimelineEventRendering#property-tickSize}\n             * to always fit the content to the screen size. Setting this property on `true` will disable {@link #config-forceFit} behaviour.\n             * @config {Boolean}\n             * @default false\n             * @category Time axis\n             */\n            suppressFit : false,\n\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            timeCellCls : null,\n\n            scheduledEventName : null,\n\n            //dblClickTime : 200,\n\n            /**\n             * A CSS class to apply to each event in the view on mouseover.\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : null,\n\n            // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations\n            preventOverCls : false,\n\n            // This setting is set to true by features that need it\n            useBackgroundCanvas : false,\n\n            /**\n             * Set to `false` if you don't want event bar DOM updates to animate.\n             * @prp {Boolean}\n             * @default true\n             * @category Scheduled events\n             */\n            enableEventAnimations : true,\n\n            disableGridRowModelWarning : true,\n\n            // does not look good with locked columns and also interferes with event animations\n            animateRemovingRows : false,\n\n            /**\n             * Partners this Timeline panel with another Timeline in order to sync their region sizes (sub-grids like locked, normal will get the same width),\n             * start and end dates, view preset, zoom level and scrolling position. All these values will be synced with the timeline defined as the `partner`.\n             *\n             * - To add a new partner dynamically see {@link #function-addPartner} method.\n             * - To remove existing partner see {@link #function-removePartner} method.\n             * - To check if timelines are partners see {@link #function-isPartneredWith} method.\n             *\n             * Column widths and hide/show state are synced between partnered schedulers when the column set is identical.\n             * @config {Scheduler.view.TimelineBase}\n             * @category Time axis\n             */\n            partner : null,\n\n            schedulerRegion : 'normal',\n\n            transitionDuration : 200,\n            // internal timer id reference\n            animationTimeout   : null,\n\n            /**\n             * Region to which columns are added when they have none specified\n             * @config {String}\n             * @default\n             * @category Misc\n             */\n            defaultRegion : 'locked',\n\n            /**\n             * Decimal precision used when displaying durations, used by tooltips and DurationColumn.\n             * Specify `false` to use raw value\n             * @config {Number|Boolean}\n             * @default\n             * @category Common\n             */\n            durationDisplayPrecision : 1,\n\n            asyncEventSuffix : 'PreCommit',\n\n            viewportResizeTimeout : 250,\n            /**\n             * An object with configuration for the {@link Scheduler.column.TimeAxisColumn} in horizontal\n             * {@link Scheduler.view.SchedulerBase#config-mode}.\n             *\n             * Example:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     timeAxisColumn : {\n             *         renderer : ({ record, cellElement }) => {\n             *             // output some markup as a layer below the events layer, you can draw a chart for example\n             *         }\n             *     },\n             *     ...\n             * });\n             * ```\n             *\n             * @config {TimeAxisColumnConfig} timeAxisColumn\n             * @category Time axis\n             */\n\n            testConfig : {\n                viewportResizeTimeout : 50\n            }\n        };\n    }\n\n    timeCellSelector = null;\n\n    updateTimeZone(timeZone) {\n        if (this.isConfiguring) {\n            this.project._isConfiguringTimeZone = true;\n        }\n        this.project.timeZone = timeZone;\n    }\n\n    get timeZone() {\n        return this.project.timeZone;\n    }\n\n    //endregion\n\n    //region Feature hooks\n\n    /**\n     * Populates the event context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.EventModel} options.eventRecord The context event.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Scheduler.model.AssignmentModel} options.assignmentRecord The context assignment if any.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateEventMenu() {}\n\n    /**\n     * Populates the time axis context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Date} options.date The Date corresponding to the mouse position in the time axis.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateScheduleMenu() {}\n\n    // Called when visible date range potentially changes such as when scrolling in\n    // the time axis.\n    onVisibleDateRangeChange(range) {\n        if (!this.handlingVisibleDateRangeChange) {\n            const\n                me                    = this,\n                { _visibleDateRange } = me,\n                dateRangeChange       = !_visibleDateRange || (_visibleDateRange.startDate - range.startDate || _visibleDateRange.endDate - range.endDate);\n\n            if (dateRangeChange) {\n                me.timeView.range                 = range;\n                me.handlingVisibleDateRangeChange = true;\n\n                /**\n                 * Fired when the range of dates visible within the viewport changes. This will be when\n                 * scrolling along a time axis.\n                 *\n                 * __Note__ that this event will fire frequently during scrolling, so any listener\n                 * should probably be added with the `buffer` option to slow down the calls to your\n                 * handler function :\n                 *\n                 * ```javascript\n                 * listeners : {\n                 *     visibleDateRangeChange({ old, new }) {\n                 *         this.updateRangeRequired(old, new);\n                 *     },\n                 *     // Only call once. 300 ms after the last event was detected\n                 *     buffer : 300\n                 * }\n                 * ```\n                 * @event visibleDateRangeChange\n                 * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                me.trigger('visibleDateRangeChange', {\n                    old : _visibleDateRange,\n                    new : range\n                });\n                me.handlingVisibleDateRangeChange = false;\n                me._visibleDateRange              = range;\n            }\n        }\n    }\n\n    // Called when visible resource range changes in vertical mode\n    onVisibleResourceRangeChange() {}\n\n    //endregion\n\n    //region Init\n\n    construct(config = {}) {\n        const me = this;\n\n        super.construct(config);\n\n        me.$firstVerticalOverflow = true;\n\n        me.initDomEvents();\n\n        me.currentOrientation.init();\n\n        me.rowManager.ion({\n            refresh : () => {\n                me.forceLayout = false;\n            }\n        });\n    }\n\n    // Override from Grid.view.GridSubGrids\n    createSubGrid(region, config = {}) {\n        const\n            me                = this,\n            { stickyHeaders } = me;\n\n        // We are creating the TimeAxisSubGrid\n        if (region === (me.schedulerRegion || 'normal')) {\n            config.type = 'timeaxissubgrid';\n        }\n\n        // The assumption is that if we are in vertical mode, the locked SubGrid\n        // is used to house the verticalTimeAxis, and so it must all be overflow:visible\n        else if (region === 'locked' && stickyHeaders && me.isVertical) {\n            config.scrollable = {\n                overflowX : 'visible',\n                overflowY : 'visible'\n            };\n\n            // It's the child of the overflowElement\n            me.bodyContainer.classList.add('b-sticky-headers');\n        }\n\n        return super.createSubGrid(region, config);\n    }\n\n    doDestroy() {\n        const\n            me                                    = this,\n            { partneredWith, currentOrientation } = me;\n\n        currentOrientation?.destroy();\n\n        // Break links between this TimeLine and any partners.\n        if (partneredWith) {\n            partneredWith.forEach(p => {\n                me.removePartner(p);\n            });\n            partneredWith.destroy();\n        }\n        else {\n            me.timeAxisViewModel.destroy();\n            me.timeAxis.destroy();\n        }\n\n        super.doDestroy();\n    }\n\n    startConfigure(config) {\n        super.startConfigure(config);\n\n        // When the body height changes, we must update the SchedulerViewport's height\n        ResizeMonitor.addResizeListener(this.bodyContainer, this.onBodyResize.bind(this));\n\n        // partner needs to be initialized first so that the various shared\n        // configs are assigned first before we default them in.\n        this.getConfig('partner');\n    }\n\n    changeStartDate(startDate) {\n        if (typeof startDate === 'string') {\n            startDate = DateHelper.parse(startDate);\n        }\n        return startDate;\n    }\n\n    onPaint({ firstPaint }) {\n        // Upon first paint we need to pass the forceUpdate flag in case we are sharing the TimAxisViewModel\n        // with another Timeline which will already have done this.\n        if (firstPaint) {\n            // Take height from container element\n            // <remove-on-release>\n            // TODO: make flex element inherit height from parent (min-height: 100% doesn't work)\n            // </remove-on-release>\n            const\n                me             = this,\n                scrollable     = me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n                // Use exact subpixel available space so that tick size calculation is correct.\n                availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? 'width' : 'height'];\n\n            // silent = true if infiniteScroll. If that is set, TimelineScroll.initScroll which is\n            // called by the base class's onPaint reconfigures the TAVM when it initializes.\n            me.timeAxisViewModel.update(availableSpace, me.infiniteScroll, true);\n\n            // If infiniteScroll caused the TAVM update to be silent, force the rendering to\n            // get hold of the scroll state and visible range\n            if (me.infiniteScroll) {\n                me.currentOrientation.doUpdateTimeView?.();\n            }\n        }\n\n        super.onPaint(...arguments);\n    }\n\n    onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX) {\n        // rerender cells in scheduler column on horizontal scroll to display events in view\n        this.currentOrientation.updateFromHorizontalScroll(scrollX);\n\n        super.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX);\n    }\n\n    /**\n     * Overrides initScroll from Grid, listens for horizontal scroll to do virtual event rendering\n     * @private\n     */\n    initScroll() {\n        const me = this;\n\n        let frameCount = 0;\n\n        super.initScroll();\n\n        me.ion({\n            horizontalScroll : ({ subGrid, scrollLeft, scrollX }) => {\n                if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying && !me.refreshSuspended) {\n                    me.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX);\n                }\n                frameCount++;\n            }\n        });\n\n        if (me.testPerformance === 'horizontal') {\n            me.setTimeout(() => {\n                const start     = performance.now();\n                let scrollSpeed = 5,\n                    direction   = 1;\n\n                const scrollInterval = me.setInterval(() => {\n                    scrollSpeed = scrollSpeed + 5;\n\n                    me.scrollX += (10 + Math.floor(scrollSpeed)) * direction;\n\n                    if (direction === 1 && me.scrollX > 5500) {\n                        direction   = -1;\n                        scrollSpeed = 5;\n                    }\n\n                    if (direction === -1 && me.scrollX <= 0) {\n                        const\n                            done    = performance.now(), // eslint-disable-line no-undef\n                            elapsed = done - start;\n\n                        const\n                            timePerFrame = elapsed / frameCount,\n                            fps          = Math.round((1000 / timePerFrame) * 10) / 10;\n\n                        clearInterval(scrollInterval);\n\n                        console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');\n                    }\n                }, 0);\n            }, 500);\n        }\n    }\n\n    //endregion\n\n    /**\n     * Calls the specified function (returning its return value) and preserves the timeline center\n     * point. This is a useful way of retaining the user's visual context while making updates\n     * and changes to the view which require major changes or a full refresh.\n     * @param {Function} fn The function to call.\n     * @param {Object} thisObj The `this` context for the function.\n     * @param {...*} args Parameters to the function.\n     */\n    preserveViewCenter(fn, thisObj = this, ...args) {\n        const\n            me             = this,\n            centerDate     = me.viewportCenterDate,\n            result         = fn.apply(thisObj, args),\n            scroller       = me.timelineScroller,\n            { clientSize } = scroller,\n            scrollStart    = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - clientSize / 2), 0);\n\n        me.scrollingToCenter = true;\n        scroller.scrollTo(scrollStart, false).then(() => me.scrollingToCenter = false);\n\n        return result;\n    }\n\n    /**\n     * Changes this Scheduler's time axis timespan to the supplied start and end dates.\n     *\n     * @async\n     * @param {Date} newStartDate The new start date\n     * @param {Date} newEndDate The new end date\n     * @param {Object} [options] An object containing modifiers for the time span change operation.\n     * @param {Boolean} [options.maintainVisibleStart] Specify as `true` to keep the visible start date stable.\n     * @param {Date} [options.visibleDate] The date inside the range to scroll into view\n     */\n    setTimeSpan(newStartDate, newEndDate, options = emptyObject) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            {\n                preventThrow = false, // Private, only used by the shift method.\n                maintainVisibleStart = false,\n                visibleDate\n            }            = options,\n            {\n                startDate,\n                endDate\n            }            = timeAxis.getAdjustedDates(newStartDate, newEndDate),\n            startChanged = timeAxis.startDate - startDate !== 0,\n            endChanged   = timeAxis.endDate - endDate !== 0;\n\n        if (startChanged || endChanged) {\n            if (maintainVisibleStart) {\n                const\n                    {\n                        timeAxisViewModel\n                    }             = me,\n                    { totalSize } = timeAxisViewModel,\n                    oldTickSize   = timeAxisViewModel.tickSize,\n                    scrollable    = me.timelineScroller,\n                    currentScroll = scrollable.position,\n                    visibleStart  = timeAxisViewModel.getDateFromPosition(currentScroll);\n\n                // If the current visibleStart is in the new range, maintain it\n                // So that there is no visual jump.\n                if (visibleStart >= startDate && visibleStart < endDate) {\n                    // We need to correct the scroll position as soon as the TimeAxisViewModel\n                    // has updated itself and before any other UI updates which that may trigger.\n                    timeAxisViewModel.ion({\n                        update() {\n                            const tickSizeChanged = timeAxisViewModel.tickSize !== oldTickSize;\n\n                            // Ensure the canvas element matches the TimeAxisViewModel's new totalSize.\n                            // This creates the required scroll range to be able to have the scroll\n                            // position correct before any further UI updates.\n                            me.updateCanvasSize();\n\n                            // If *only* the start moved, we can keep scroll position the same\n                            // by adjusting it by the amount the start moved.\n                            if (startChanged && !endChanged && !tickSizeChanged) {\n                                scrollable.position += (timeAxisViewModel.totalSize - totalSize);\n                            }\n                            // If only the end has changed, and tick size is same, we can maintain\n                            // the same scroll position.\n                            else if (!startChanged && !tickSizeChanged) {\n                                scrollable.position = currentScroll;\n                            }\n                            // Fall back to restoring the position by restoring the visible start time\n                            else {\n                                scrollable.position = timeAxisViewModel.getPositionFromDate(visibleStart);\n                            }\n\n                            // Force partners to sync with what we've just done to reset the scroll.\n                            // We are now in control.\n                            scrollable.syncPartners(true);\n                        },\n                        prio : 10000,\n                        once : true\n                    });\n                }\n            }\n\n            const returnValue = timeAxis.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n\n            if (visibleDate) {\n                return me.scrollToDate(visibleDate, options).then(() => returnValue);\n            }\n\n            return returnValue;\n        }\n    }\n\n    //region Config getters/setters\n\n    /**\n     * Returns `true` if any of the events/tasks or feature injected elements (such as ResourceTimeRanges) are within\n     * the {@link #config-timeAxis}\n     * @property {Boolean}\n     * @readonly\n     * @category Scheduled events\n     */\n    get hasVisibleEvents() {\n        return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some(t => this.timeAxis.isTimeSpanInAxis(t));\n    }\n\n    // Template function to be chained in features to determine if any elements are in time axis (needed since we cannot\n    // currently chain getters). Negated to not break chain. First feature that has elements visible returns false,\n    // which prevents other features from being queried.\n    noFeatureElementsInAxis() { }\n\n    // Private getter used to piece together event names such as beforeEventDrag / beforeTaskDrag. Could also be used\n    // in templates.\n    get capitalizedEventName() {\n        if (!this._capitalizedEventName) {\n            this._capitalizedEventName = StringHelper.capitalize(this.scheduledEventName);\n        }\n\n        return this._capitalizedEventName;\n    }\n\n    set partner(partner) {\n        this._partner = partner;\n\n        this.addPartner(partner);\n    }\n\n    /**\n     * Partners this Timeline with the passed Timeline in order to sync the horizontal scrolling position and zoom level.\n     *\n     * - To remove existing partner see {@link #function-removePartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to partner with\n     */\n    addPartner(partner) {\n        const me = this;\n\n        if (!me.isPartneredWith(partner)) {\n            const partneredWith = me.partneredWith || (me.partneredWith = new Collection());\n\n            // Each must know about the other so that they can sync others upon region resize\n            partneredWith.add(partner);\n\n            (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);\n\n            // Flush through viewPreset initGetter so that the setup in setConfig doesn't\n            // take them to be the class's defined getters.\n            me.getConfig('viewPreset');\n\n            partner.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : me\n            });\n            partner.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : me\n            });\n\n            // collect configs that are meant to be shared between partners\n            const partnerSharedConfig = me.partnerSharedConfigs.reduce((config, configName) => {\n                config[configName] = partner[configName];\n                return config;\n            }, {});\n\n            me.setConfig(partnerSharedConfig);\n\n            me.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n\n            if (me.isPainted) {\n                me.scrollable.addPartner(partner.scrollable, me.isHorizontal ? 'x' : 'y');\n\n                partner.syncPartnerSubGrids();\n            }\n            else {\n                // When initScroll comes round, make sure it syncs with the partner\n                me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {\n                    me.scrollable.addPartner(partner.scrollable, me.isHorizontal ? 'x' : 'y');\n                    partner.syncPartnerSubGrids();\n                }, me);\n            }\n        }\n    }\n\n    /**\n     * Breaks the link between current Timeline and the passed Timeline\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to unlink from\n     */\n    removePartner(partner) {\n        const\n            me                = this,\n            { partneredWith } = me;\n\n        if (me.isPartneredWith(partner)) {\n            partneredWith.remove(partner);\n            me.scrollable.removePartner(partner.scrollable);\n            me.un({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.un({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n\n            partner.removePartner(me);\n        }\n    }\n\n    /**\n     * Checks whether the passed timeline is partnered with the current timeline.\n     * @param {Scheduler.view.TimelineBase} partner The timeline to check the partnering with\n     * @returns {Boolean} Returns `true` if the timelines are partnered\n     */\n    isPartneredWith(partner) {\n        return Boolean(this.partneredWith?.includes(partner));\n    }\n\n    /**\n     * Called when a partner scheduler changes its overflowing state. The scrollable\n     * of a Grid/Scheduler only handles overflowY, so this will mean the addition\n     * or removal of a vertical scrollbar.\n     *\n     * All partners must stay in sync. If another parter has a vertical scrollbar\n     * and we do not, we must set our overflowY to 'scroll' so that we show an empty\n     * scrollbar to keep widths synchronized.\n     * @param {Object} event A {@link Core.helper.util.Scroller#event-overflowChange} event\n     * @internal\n     */\n    onPartnerOverflowChange({ source : otherScrollable, y }) {\n        const\n            { scrollable } = this,\n            ourY           = scrollable.hasOverflow('y');\n\n        // If we disagree with our partner, the partner which doesn't have\n        // overflow, has to become overflowY : scroll\n        if (ourY !== y) {\n            if (ourY) {\n                otherScrollable.overflowY = 'scroll';\n            }\n            else {\n                otherScrollable.overflowY = true;\n                scrollable.overflowY      = 'scroll';\n                this.refreshVirtualScrollbars();\n            }\n        }\n        // If we agree with our partner, we can reset ourselves to overflowY : auto\n        else {\n            scrollable.overflowY = true;\n        }\n    }\n\n    onPartnerPresetChange({ preset, startDate, endDate, centerDate, zoomDate, zoomPosition, zoomLevel }) {\n        if (!this._viewPresetChanging && this.viewPreset !== preset) {\n\n            // Passed through to the viewPreset changing method\n            preset.options  = {\n                startDate,\n                endDate,\n                centerDate,\n                zoomDate,\n                zoomPosition,\n                zoomLevel\n            };\n            this.viewPreset = preset;\n        }\n    }\n\n    get partner() {\n        return this._partner;\n    }\n\n    /**\n     * Returns the partnered timelines.\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To remove existing partner see {@link #function-removePartner} method.\n     *\n     * @readonly\n     * @member {Scheduler.view.TimelineBase} partners\n     * @category Time axis\n     */\n    get partners() {\n        const partners = this.partner ? [this.partner] : [];\n\n        if (this.partneredWith) {\n            partners.push.apply(partners, this.partneredWith.allValues);\n        }\n\n        return partners;\n    }\n\n    get timeAxisColumn() {\n        return this.columns && this._timeAxisColumn;\n    }\n\n    changeColumns(columns, currentStore) {\n        const me = this;\n        let timeAxisColumnIndex, timeAxisColumnConfig;\n\n        // No columns means destroy\n        if (columns) {\n            const isArray = Array.isArray(columns);\n\n            let cols = columns;\n\n            if (!isArray) {\n                cols = columns.data;\n            }\n\n            timeAxisColumnIndex = cols && cols.length;\n\n            cols.some((col, index) => {\n                if (col.type === 'timeAxis') {\n                    timeAxisColumnIndex  = index;\n                    timeAxisColumnConfig = ObjectHelper.assign(col, me.timeAxisColumn);\n                    return true;\n                }\n                return false;\n            });\n\n            // <remove-on-release>\n            // TODO: Move to Scheduler\n            // </remove-on-release>\n            if (me.isVertical) {\n                cols = [\n                    ObjectHelper.assign({\n                        type : 'verticalTimeAxis'\n                    }, me.verticalTimeAxisColumn),\n                    // Make space for a regular TimeAxisColumn after the VerticalTimeAxisColumn\n                    cols[timeAxisColumnIndex]\n                ];\n\n                timeAxisColumnIndex = 1;\n            }\n            else {\n                // We're going to mutate this array which we do not own, so copy it first.\n                cols = cols.slice();\n            }\n\n            // Fix up the timeAxisColumn config in place\n            cols[timeAxisColumnIndex] = this._timeAxisColumn || {\n                type    : 'timeAxis',\n                cellCls : me.timeCellCls,\n                mode    : me.mode,\n                ...timeAxisColumnConfig\n            };\n\n            // If we are passed a raw array, or the Store we are passed is owned by another\n            // Scheduler, pass the raw column data ro the Grid's changeColumns\n            if (isArray || (columns.isStore && columns.owner !== this)) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n\n        return super.changeColumns(columns, currentStore);\n    }\n\n    updateColumns(columns, was) {\n        super.updateColumns(columns, was);\n\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            const\n                me             = this,\n                timeAxisColumn = me._timeAxisColumn = me.columns.find(c => c.isTimeAxisColumn);\n\n            if (me.isVertical) {\n                me.verticalTimeAxisColumn = me.columns.find(c => c.isVerticalTimeAxisColumn);\n                me.verticalTimeAxisColumn.relayAll(me);\n            }\n\n            // Set up event relaying early\n            timeAxisColumn.relayAll(me);\n        }\n    }\n\n    onColumnsChanged({ action, changes, record : column, records }) {\n        const { timeAxisColumn, columns } = this;\n        // If someone replaces the column set (syncing leads to batch), ensure time axis is always added\n        if ((action === 'dataset' || action === 'batch') && !columns.includes(timeAxisColumn)) {\n            columns.add(timeAxisColumn, true);\n        }\n        // <remove-on-release>\n        // TODO: Have ResourceHeader call this directly instead of relying on event?\n        // </remove-on-release>\n        else if (column === timeAxisColumn && 'width' in changes) {\n            this.updateCanvasSize();\n        }\n\n        column && this.partneredWith?.forEach(partner => {\n            const partnerColumn = partner.columns.getAt(column.allIndex);\n\n            if (partnerColumn?.shouldSync(column)) {\n                const partnerChanges = {};\n                for (const k in changes) {\n                    partnerChanges[k] = changes[k].value;\n                }\n                partnerColumn.set(partnerChanges);\n            }\n        });\n\n        super.onColumnsChanged(...arguments);\n    }\n\n    get timeView() {\n        const me = this;\n        // Maintainer, we need to ensure that the columns property is initialized\n        // if this getter is called at configuration time before columns have been ingested.\n        return me.columns && me.isVertical\n            ? me.verticalTimeAxisColumn?.view\n            : me.timeAxisColumn?.timeAxisView;\n    }\n\n    updateEventCls(eventCls) {\n        const me = this;\n\n        if (!me.eventSelector) {\n            // No difference with new rendering, released have 'b-released' only\n            me.unreleasedEventSelector = me.eventSelector = `.${eventCls}-wrap`;\n        }\n        if (!me.eventInnerSelector) {\n            me.eventInnerSelector = `.${eventCls}`;\n        }\n    }\n\n    set timeAxisViewModel(timeAxisViewModel) {\n        const\n            me            = this,\n            currentModel  = me._timeAxisViewModel,\n            tavmListeners = {\n                name    : 'timeAxisViewModel',\n                update  : 'onTimeAxisViewModelUpdate',\n                prio    : 100,\n                thisObj : me\n            };\n\n        if ((me.partner && !timeAxisViewModel) || (currentModel && currentModel === timeAxisViewModel)) {\n            return;\n        }\n\n        if (currentModel?.owner === me) {\n            // We created this model, destroy it\n            currentModel.destroy();\n        }\n\n        me.detachListeners('timeAxisViewModel');\n\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (timeAxisViewModel?.isTimeAxisViewModel) {\n            timeAxisViewModel.ion(tavmListeners);\n        }\n        else {\n            timeAxisViewModel = TimeAxisViewModel.new({\n                mode              : me._mode,\n                snap              : me.snap,\n                forceFit          : me.forceFit,\n                timeAxis          : me.timeAxis,\n                suppressFit       : me.suppressFit,\n                internalListeners : tavmListeners,\n                owner             : me\n            }, timeAxisViewModel);\n        }\n\n        // Replace in dependent classes relying on the model\n        if (!me.isConfiguring) {\n            if (me.isHorizontal) {\n                me.timeAxisColumn.timeAxisViewModel = timeAxisViewModel;\n            }\n            else {\n                me.verticalTimeAxisColumn.view.model = timeAxisViewModel;\n            }\n        }\n\n        me._timeAxisViewModel = timeAxisViewModel;\n\n        me.relayEvents(timeAxisViewModel, ['update'], 'timeAxisViewModel');\n\n        if (currentModel && timeAxisViewModel) {\n            me.trigger('timeAxisViewModelChange', { timeAxisViewModel });\n        }\n    }\n\n    /**\n     * The internal view model, describing the visual representation of the time axis.\n     * @property {Scheduler.view.model.TimeAxisViewModel}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisViewModel() {\n        if (!this._timeAxisViewModel) {\n            this.timeAxisViewModel = null;\n        }\n        return this._timeAxisViewModel;\n    }\n\n    get suppressFit() {\n        return this._timeAxisViewModel?.suppressFit ?? this._suppressFit;\n    }\n\n    set suppressFit(value) {\n        if (this._timeAxisViewModel) {\n            this.timeAxisViewModel.suppressFit = value;\n        }\n        else {\n            this._suppressFit = value;\n        }\n    }\n\n    set timeAxis(timeAxis) {\n        const\n            me                = this,\n            currentTimeAxis   = me._timeAxis,\n            timeAxisListeners = {\n                name        : 'timeAxis',\n                reconfigure : 'onTimeAxisReconfigure',\n                thisObj     : me\n            };\n\n        if (me.partner && !timeAxis || (currentTimeAxis && currentTimeAxis === timeAxis)) {\n            return;\n        }\n\n        if (currentTimeAxis) {\n            if (currentTimeAxis.owner === me) {\n                // We created this model, destroy it\n                currentTimeAxis.destroy();\n            }\n        }\n\n        me.detachListeners('timeAxis');\n\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (!timeAxis?.isTimeAxis) {\n            timeAxis = ObjectHelper.assign({\n                owner          : me,\n                viewPreset     : me.viewPreset,\n                autoAdjust     : me.autoAdjustTimeAxis,\n                weekStartDay   : me.weekStartDay,\n                forceFullTicks : me.fillTicks && me.snap\n            }, timeAxis);\n\n            if (me.startDate) {\n                timeAxis.startDate = me.startDate;\n            }\n            if (me.endDate) {\n                timeAxis.endDate = me.endDate;\n            }\n\n            if (me.workingTime) {\n                me.applyWorkingTime(timeAxis);\n            }\n\n            timeAxis = new TimeAxis(timeAxis);\n        }\n\n        // Inform about reconfiguring the timeaxis, to allow users to react to start & end date changes\n        timeAxis.ion(timeAxisListeners);\n\n        me._timeAxis = timeAxis;\n    }\n\n    onTimeAxisReconfigure({ config, oldConfig }) {\n        if (config) {\n            const dateRangeChange = !oldConfig || (oldConfig.startDate - config.startDate || oldConfig.endDate - config.endDate);\n\n            if (dateRangeChange) {\n                /**\n                 * Fired when the range of dates encapsulated by the UI changes. This will be when\n                 * moving a view in time by reconfiguring its {@link #config-timeAxis}. This will happen\n                 * when zooming, or changing {@link #config-viewPreset}.\n                 *\n                 * Contrast this with the {@link #event-visibleDateRangeChange} event which fires much\n                 * more frequently, during scrolling along the time axis and changing the __visible__\n                 * date range.\n                 * @event dateRangeChange\n                 * @param {Scheduler.view.TimelineBase} source This Scheduler/Gantt instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                this.trigger('dateRangeChange', {\n                    old : {\n                        startDate : oldConfig.startDate,\n                        endDate   : oldConfig.endDate\n                    },\n                    new : {\n                        startDate : config.startDate,\n                        endDate   : config.endDate\n                    }\n                });\n            }\n        }\n\n        /**\n         * Fired when the timeaxis has changed, for example by zooming or configuring a new time span.\n         * @event timeAxisChange\n         * @param {Scheduler.view.Scheduler} source - This Scheduler\n         * @param {Object} config Config object used to reconfigure the time axis.\n         * @param {Date} config.startDate New start date (if supplied)\n         * @param {Date} config.endDate New end date (if supplied)\n         */\n        this.trigger('timeAxisChange', { config });\n    }\n\n    get timeAxis() {\n        if (!this._timeAxis) {\n            this.timeAxis = null;\n        }\n        return this._timeAxis;\n    }\n\n    updateForceFit(value) {\n        if (this._timeAxisViewModel) {\n            this._timeAxisViewModel.forceFit = value;\n        }\n    }\n\n    /**\n     * Get/set working time. Assign `null` to stop using working time. See {@link #config-workingTime} config for details.\n     * @property {Object}\n     * @category Scheduled events\n     */\n    set workingTime(config) {\n        this._workingTime = config;\n\n        if (!this.isConfiguring) {\n            this.applyWorkingTime(this.timeAxis);\n        }\n    }\n\n    get workingTime() {\n        return this._workingTime;\n    }\n\n    // Translates the workingTime configs into TimeAxis#include rules, applies them and then refreshes the header and\n    // redraws the events\n    applyWorkingTime(timeAxis) {\n        const me     = this,\n            config = me._workingTime;\n\n        if (config) {\n            let hour = null;\n            // Only use valid values\n            if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {\n                hour = { from : config.fromHour, to : config.toHour };\n            }\n\n            let day = null;\n            // Only use valid values\n            if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {\n                day = { from : config.fromDay, to : config.toDay };\n            }\n\n            if (hour || day) {\n                timeAxis.include = {\n                    hour,\n                    day\n                };\n            }\n            else {\n                // No valid rules, restore timeAxis\n                timeAxis.include = null;\n            }\n        }\n        else {\n            // No rules, restore timeAxis\n            timeAxis.include = null;\n        }\n\n        if (me.isPainted) {\n            // Refreshing header, which also recalculate tickSize and header data\n            me.timeAxisColumn.refreshHeader();\n            // Update column lines\n            me.features.columnLines?.refresh();\n\n            // Animate event changes\n            me.refreshWithTransition();\n        }\n    }\n\n    updateStartDate(date) {\n        this.setStartDate(date);\n    }\n\n    /**\n     * Sets the timeline start date.\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new start date is greater than end date, it will throw an exception.\n     *\n     * @param {Date} date The new start date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `true`.\n     */\n    setStartDate(date, keepDuration = true) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n\n        if (ta && endDate) {\n            if (date) {\n                let calcEndDate = endDate;\n\n                if (keepDuration && startDate) {\n                    const diff  = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcEndDate = DateHelper.add(date, diff, mainUnit);\n                }\n\n                me.setTimeSpan(date, calcEndDate);\n            }\n        }\n        else {\n            me._tempStartDate = date;\n        }\n    }\n\n    get startDate() {\n        const me = this;\n\n        if (me._timeAxis) {\n            return me._timeAxis.startDate;\n        }\n\n        return me._tempStartDate || new Date();\n    }\n\n    changeEndDate(date) {\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        this.setEndDate(date);\n    }\n\n    /**\n     * Sets the timeline end date\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new end date is less than start date, it will throw an exception.\n     *\n     * @param {Date} date The new end date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `false`.\n     */\n    setEndDate(date, keepDuration = false) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n\n        if (ta && startDate) {\n            if (date) {\n                let calcStartDate = startDate;\n\n                if (keepDuration && endDate) {\n                    const diff    = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcStartDate = DateHelper.add(date, -diff, mainUnit);\n                }\n\n                me.setTimeSpan(calcStartDate, date);\n            }\n        }\n        else {\n            me._tempEndDate = date;\n        }\n    }\n\n    get endDate() {\n        const me = this;\n\n        if (me._timeAxis) {\n            return me._timeAxis.endDate;\n        }\n\n        return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);\n    }\n\n    changeVisibleDate(options) {\n        if (options instanceof Date) {\n            return { date : options, block : 'nearest' };\n        }\n        if (options instanceof Object) {\n            return {\n                date : options.date,\n                ...options\n            };\n        }\n    }\n\n    updateVisibleDate(options) {\n        const me = this;\n\n        // Infinite scroll initialization takes care of its visibleDate after\n        // calculating the optimum scroll range in TimelineScroll#initScroll\n        if (!(me.infiniteScroll && me.isConfiguring)) {\n            if (me.isPainted) {\n                me.scrollToDate(options.date, options);\n            }\n            else {\n                me.ion({\n                    paint : () => me.scrollToDate(options.date, options),\n                    once  : true\n                });\n            }\n        }\n    }\n\n    get features() {\n        return super.features;\n    }\n\n    // add region resize by default\n    set features(features) {\n        features = features === true ? {} : features;\n\n        if (!('regionResize' in features)) {\n            features.regionResize = true;\n        }\n\n        super.features = features;\n    }\n\n    get eventStyle() {\n        return this._eventStyle;\n    }\n\n    set eventStyle(style) {\n        this._eventStyle = style;\n\n        this.refreshWithTransition();\n\n        this.trigger('stateChange');\n    }\n\n    get eventColor() {\n        return this._eventColor;\n    }\n\n    set eventColor(color) {\n        this._eventColor = color;\n\n        this.refreshWithTransition();\n\n        this.trigger('stateChange');\n    }\n\n    //endregion\n\n    //region Event handlers\n\n    onLocaleChange() {\n        super.onLocaleChange();\n\n        const oldAutoAdjust = this.timeAxis.autoAdjust;\n        // Time axis should rebuild as weekStartDay may have changed\n        this.timeAxis.reconfigure({\n            autoAdjust : false\n        });\n\n        // Silently set it back to what the user had for next view refresh\n        this.timeAxis.autoAdjust = oldAutoAdjust;\n    }\n\n    /**\n     * Called when the element which encapsulates the Scheduler's visible height changes size.\n     * We only respond to *height* changes here. The TimeAxisSubGrid monitors its own width.\n     * @param {HTMLElement} element\n     * @param {DOMRect} oldRect\n     * @param {DOMRect} newRect\n     * @private\n     */\n    onBodyResize(element, oldRect, { width, height }) {\n        // Uncache old value upon element resize, not upon initial sizing\n        if (this.isVertical && oldRect && width !== oldRect.width) {\n            delete this.timeAxisSubGrid._width;\n        }\n\n        const newWidth = this.timeAxisSubGrid.element.offsetWidth;\n\n        // The Scheduler (The Grid) dictates the viewport height.\n        // Don't react on first invocation which will be initial size.\n        if (this._bodyRectangle && oldRect && (height !== oldRect.height)) {\n            this.onSchedulerViewportResize(newWidth, height, newWidth, oldRect.height);\n        }\n    }\n\n    // Note: This function is throttled in construct(), since it will do a full redraw per call\n    onSchedulerViewportResize(width, height, oldWidth, oldHeight) {\n        if (this.isPainted) {\n            const\n                me = this,\n                {\n                    isHorizontal,\n                    partneredWith\n                }  = me;\n\n            me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);\n\n            // Raw width is always correct for horizontal layout because the TimeAxisSubGrid\n            // never shows a scrollbar. It's always contained by an owning Grid which shows\n            // the vertical scrollbar.\n            me.updateViewModelAvailableSpace(isHorizontal ? width : Math.floor(height));\n\n            if (partneredWith && !me.isSyncingFromPartner) {\n                me.syncPartnerSubGrids();\n            }\n\n            /**\n             * Fired when the *scheduler* viewport (not the overall Scheduler element) changes size.\n             * This happens when the grid changes height, or when the subgrid which encapsulates the\n             * scheduler column changes width.\n             * @event timelineViewportResize\n             * @param {Core.widget.Widget} source - This Scheduler\n             * @param {Number} width The new width\n             * @param {Number} height The new height\n             * @param {Number} oldWidth The old width\n             * @param {Number} oldHeight The old height\n             */\n            me.trigger('timelineViewportResize', { width, height, oldWidth, oldHeight });\n        }\n    }\n\n    updateViewModelAvailableSpace(space) {\n        this.timeAxisViewModel.availableSpace = space;\n    }\n\n    onTimeAxisViewModelUpdate() {\n        if (!this._viewPresetChanging && !this.timeAxisSubGrid.collapsed) {\n            this.updateCanvasSize();\n            this.currentOrientation.onTimeAxisViewModelUpdate();\n        }\n    }\n\n    syncPartnerSubGrids() {\n        this.partneredWith.forEach(partner => {\n            if (!partner.isSyncingFromPartner) {\n                partner.isSyncingFromPartner = true;\n                this.eachSubGrid(subGrid => {\n                    const partnerSubGrid = partner.subGrids[subGrid.region];\n\n                    // If there is a difference, sync the partner SubGrid state\n                    if (partnerSubGrid.width !== subGrid.width) {\n                        if (subGrid.collapsed) {\n                            partnerSubGrid.collapse();\n                        }\n                        else {\n                            if (partnerSubGrid.collapsed) {\n                                partnerSubGrid.expand();\n                            }\n                            // When using flexed subgrid, make sure flex values has prio over width\n                            if (subGrid.flex) {\n                                // If flex values match, resize should be fine without changing anything\n                                if (subGrid.flex !== partnerSubGrid.flex) {\n                                    partnerSubGrid.flex = subGrid.flex;\n                                }\n                            }\n                            else {\n                                partnerSubGrid.width = subGrid.width;\n                            }\n                        }\n                    }\n                });\n                partner.isSyncingFromPartner = false;\n            }\n        });\n    }\n\n    //endregion\n\n    //region Mode\n\n    get currentOrientation() {\n        throw new Error('Implement in subclass');\n    }\n\n    // Horizontal is the default, overridden in scheduler\n    get isHorizontal() {\n        return true;\n    }\n\n    //endregion\n\n    //region Canvases and elements\n\n    get backgroundCanvas() {\n        return this._backgroundCanvas;\n    }\n\n    get foregroundCanvas() {\n        return this._foregroundCanvas;\n    }\n\n    get svgCanvas() {\n        const me = this;\n        if (!me._svgCanvas) {\n            const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            svg.setAttribute('id', IdHelper.generateId('svg'));\n            // To not be recycled by DomSync\n            svg.retainElement = true;\n            me.foregroundCanvas.appendChild(svg);\n            me.trigger('svgCanvasCreated', { svg });\n        }\n        return me._svgCanvas;\n    }\n\n    /**\n     * Returns the subGrid containing the time axis\n     * @member {Grid.view.SubGrid} timeAxisSubGrid\n     * @readonly\n     * @category Time axis\n     */\n\n    /**\n     * Returns the html element for the subGrid containing the time axis\n     * @property {HTMLElement}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisSubGridElement() {\n        // Hit a lot, caching the element (it will never change)\n\n        if (!this._timeAxisSubGridElement) {\n            // We need the TimeAxisSubGrid to exist, so regions must be initialized\n            this.getConfig('regions');\n\n            this._timeAxisSubGridElement = this.timeAxisColumn?.subGridElement;\n        }\n\n        return this._timeAxisSubGridElement;\n    }\n\n    updateCanvasSize() {\n        const\n            me            = this,\n            { totalSize } = me.timeAxisViewModel,\n            width         = me.isHorizontal ? totalSize : me.timeAxisColumn.width;\n\n        let result = false;\n\n        if (me.isVertical) {\n            // Ensure vertical scroll range accommodates the TimeAxis\n            if (me.isPainted) {\n                // We used to have a bug here from not including the row border in the total height. Border is now\n                // removed, but leaving code here just in case some client is using border\n                me.refreshTotalHeight(totalSize + me._rowBorderHeight, true);\n            }\n\n            // Canvas might need a height in vertical mode, if ticks does not fill height (suppressFit : true)\n            if (me.suppressFit) {\n                DomHelper.setLength(me.foregroundCanvas, 'height', totalSize);\n            }\n\n            result = true;\n        }\n\n        if (width !== me.$canvasWidth && me.foregroundCanvas) {\n            if (me.backgroundCanvas) {\n                DomHelper.setLength(me.backgroundCanvas, 'width', width);\n            }\n\n            DomHelper.setLength(me.foregroundCanvas, 'width', width);\n\n            me.$canvasWidth = width;\n\n            result = true;\n        }\n\n        return result;\n    }\n\n    /**\n     * A chainable function which Features may hook to add their own content to the timeaxis header.\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the header\n     */\n    getHeaderDomConfigs(configs) {}\n\n    /**\n     * A chainable function which Features may hook to add their own content to the foreground canvas\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the foreground canvas\n     */\n    getForegroundDomConfigs(configs) {}\n\n    //endregion\n\n    //region Grid overrides\n\n    async onStoreDataChange({ action }) {\n        const me = this;\n\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            // When repopulating stores (pro and up on data reload), the engine is not in a valid state until committed.\n            // Don't want to commit here, since it might be repopulating multiple stores.\n            // Instead delay grids refresh until project is ready\n            if (action === 'dataset' && me.project.isRepopulatingStores) {\n                await me.project.await('refresh', false);\n            }\n\n            super.onStoreDataChange(...arguments);\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n\n    refresh(forceLayout = true) {\n        const me = this;\n\n        if (me.isPainted && !me.refreshSuspended) {\n            // We need to refresh if there are Features laying claim to the visible time axis.\n            // Or there are events which fall inside the time axis.\n            // Or (if no events fall inside the time axis) there are event elements to remove.\n            if (me.isVertical || me.hasVisibleEvents || me.timeAxisSubGridElement.querySelector(me.eventSelector)) {\n                if (me.isEngineReady) {\n                    me.refreshRows(false, forceLayout);\n                }\n                else {\n                    me.refreshAfterProjectRefresh             = true;\n                    me.currentOrientation.refreshAllWhenReady = true;\n                }\n            }\n            // Even if there are no events in our timeline, Features\n            // assume there will be a refresh event from the RowManager\n            // after a refresh request so fire it here.\n            else {\n                me.rowManager.trigger('refresh');\n            }\n        }\n    }\n\n    render() {\n        const\n            me          = this,\n            schedulerEl = me.timeAxisSubGridElement;\n\n        if (me.useBackgroundCanvas) {\n            me._backgroundCanvas = DomHelper.createElement({\n                className   : 'b-sch-background-canvas',\n                parent      : schedulerEl,\n                nextSibling : schedulerEl.firstElementChild\n            });\n        }\n\n        // The font-size trick is no longer used by scheduler, since it allows per resource margins\n        const fgCanvas = me._foregroundCanvas = DomHelper.createElement({\n            className : 'b-sch-foreground-canvas',\n            style     : `font-size:${(me.rowHeight - me.resourceMargin * 2)}px`,\n            parent    : schedulerEl\n        });\n\n        me.timeAxisSubGrid.insertRowsBefore = fgCanvas;\n\n        // Size correctly in case ticks does not fill height\n        if (me.isVertical && me.suppressFit) {\n            me.updateCanvasSize();\n        }\n\n        super.render(...arguments);\n    }\n\n    // <remove-on-release>\n    // TODO: refreshRows -> refresh in grid?\n    // </remove-on-release>\n    refreshRows(returnToTop = false, reLayoutEvents = true) {\n        const me = this;\n\n        if (me.isConfiguring) {\n            return;\n        }\n\n        me.currentOrientation.refreshRows(reLayoutEvents);\n\n        super.refreshRows(returnToTop);\n    }\n\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !Boolean(event.target.closest('.b-sch-foreground-canvas'));\n        }\n        return super.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n\n    // This GridSelection override disables drag-selection in timeaxis column for scheduler and gantt\n    onCellNavigate(me, from, to) {\n        if (to.cell?.classList.contains('b-timeaxis-cell') && !GlobalEvents.currentMouseDown?.target.classList.contains('b-grid-cell')) {\n            this.preventDragSelect = true;\n        }\n        super.onCellNavigate(...arguments);\n    }\n\n    //endregion\n\n    //region Other\n\n    // duration = false prevents transition\n    runWithTransition(fn, duration) {\n        const me = this;\n\n        // Do not attempt to enter animating state if we are not visible\n        if (me.isVisible) {\n            // Allow calling with true/false to keep code simpler in other places\n            if (duration == null || duration === true) {\n                duration = me.transitionDuration;\n            }\n\n            // Ask Grid superclass to enter the animated state if requested and enabled.\n            if (duration && me.enableEventAnimations) {\n                if (!me.hasTimeout('exitTransition')) {\n                    me.isAnimating = true;\n                }\n\n                // Exit animating state in duration milliseconds.\n                exitTransition.delay = duration;\n                me.setTimeout(exitTransition);\n            }\n        }\n\n        fn();\n    }\n\n    exitTransition() {\n        this.isAnimating = false;\n        this.trigger('transitionend');\n    }\n\n    // Awaited by CellEdit to make sure that the editor is not moved until row heights have transitioned, to avoid it\n    // ending up misaligned\n    async waitForAnimations() {\n        // If project is calculating, we should await that too. It might lead to transitions\n        if (!this.isEngineReady) {\n            await this.project.await('dataReady', false);\n        }\n\n        await super.waitForAnimations();\n    }\n\n    /**\n     * Refreshes the grid with transitions enabled.\n     */\n    refreshWithTransition(forceLayout, duration) {\n        const me = this;\n\n        // No point in starting a transition if we cant refresh anyway\n        if (!me.refreshSuspended && me.isPainted) {\n            // Since we suspend refresh when loading with CrudManager, rows might not have been initialized yet\n            if (!me.rowManager.topRow) {\n                me.rowManager.reinitialize();\n            }\n            else {\n                me.runWithTransition(() => me.refresh(forceLayout), duration);\n            }\n        }\n    }\n\n    /**\n     * Returns an object representing the visible date range\n     * @property {Object}\n     * @property {Date} visibleDateRange.startDate\n     * @property {Date} visibleDateRange.endDate\n     * @readonly\n     * @category Dates\n     */\n    get visibleDateRange() {\n        return this.currentOrientation.visibleDateRange;\n    }\n\n    // This override will force row selection on timeaxis column selection, effectively disabling cell selection there\n    isRowNumberSelecting(...selectors) {\n        return super.isRowNumberSelecting(...selectors) ||\n            selectors.some(cs => cs.column ? cs.column.isTimeAxisColumn : cs.cell?.closest('.b-timeaxis-cell'));\n    }\n\n    //endregion\n\n    /**\n     * Returns a rounded duration value to be displayed in UI (tooltips, labels etc)\n     * @param {Number} The raw duration value\n     * @param {Number} [nbrDecimals] The number of decimals, defaults to {@link #config-durationDisplayPrecision}\n     * @returns {Number} The rounded duration\n     */\n    formatDuration(duration, nbrDecimals = this.durationDisplayPrecision) {\n        const multiplier = Math.pow(10, nbrDecimals);\n\n        return Math.round(duration * multiplier) / multiplier;\n    }\n\n    beginListeningForBatchedUpdates() {\n        this.listenToBatchedUpdates = (this.listenToBatchedUpdates || 0) + 1;\n    }\n\n    endListeningForBatchedUpdates() {\n        if (this.listenToBatchedUpdates) {\n            this.listenToBatchedUpdates -= 1;\n        }\n    }\n\n    onConnectedCallback(connected, initialConnect) {\n        if (connected && !initialConnect) {\n            this.timeAxisSubGrid.scrollable.x += 0.5;\n        }\n    }\n\n    updateRtl(rtl) {\n        const\n            me                = this,\n            { isConfiguring } = me;\n\n        let visibleDateRange;\n\n        if (!isConfiguring) {\n            visibleDateRange = me.visibleDateRange;\n        }\n\n        super.updateRtl(rtl);\n\n        if (!isConfiguring) {\n            me.currentOrientation.clearAll();\n            if (me.infiniteScroll) {\n                me.shiftToDate(visibleDateRange.startDate);\n                me.scrollToDate(visibleDateRange.startDate, { block : 'start' });\n            }\n            else {\n                me.timelineScroller.position += 0.5;\n            }\n        }\n    }\n\n    /**\n     * Applies the start and end date to each event store request (formatted in the same way as the start date field,\n     * defined in the EventStore Model class).\n     * @category Data\n     * @private\n     */\n    applyStartEndParameters(params) {\n        const\n            me    = this,\n            field = me.eventStore.modelClass.fieldMap.startDate;\n\n        if (me.passStartEndParameters) {\n            params[me.startParamName] = field.print(me.startDate);\n            params[me.endParamName] = field.print(me.endDate);\n        }\n    }\n}\n\n// Register this widget type with its Factory\nTimelineBase.initClass();\n\n// Has to be here because Gantt extends TimelineBase\nVersionHelper.setVersion('scheduler', '5.3.7');\n"],
  "mappings": "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",
  "names": ["Base", "initialize", "props", "Object", "assign", "new", "instance", "CalendarCacheIntervalMultiple", "constructor", "config", "intervalGroups", "combineWith", "interval", "copy", "slice", "push", "calendar", "getIsWorkingForEvery", "isWorkingForEvery", "_calendar", "intervals", "getGroups", "isWorking", "getIsWorkingForSome", "isWorkingForSome", "getCalendars", "calendars", "isCalendarWorking", "getCalendarsWorkStatus", "get", "calendarsWorkStatus", "res", "Map", "set", "getCalendarsWorking", "calendarsWorking", "getCalendarsNonWorking", "calendarsNonWorking", "intervalsByCalendar", "forEach", "data", "apply", "unique", "stripDuplicates", "sort", "interval1", "interval2", "getPriorityField", "CalendarCacheMultiple", "CalendarCache", "calendarCaches", "intervalCache", "IntervalCache", "emptyInterval", "combineIntervalsFn", "fillCache", "startDate", "endDate", "calendarCache", "includeWrappingRangeFrom", "COMBINED_CALENDARS_CACHE", "combineCalendars", "uniqueOnly", "length", "Error", "calendar1", "calendar2", "internalId", "hash", "map", "join", "versionsHash", "version", "cached", "cache", "DurationColumn", "NumberColumn", "compositeField", "$name", "type", "isGanttColumn", "fields", "name", "defaultValue", "defaults", "min", "max", "step", "largeStep", "field", "text", "instantUpdate", "filterType", "sortable", "durationEntity1", "durationEntity2", "ms1", "ms2", "construct", "arguments", "sortFn", "args", "call", "defaultEditor", "ObjectHelper", "cleanupProperties", "durationUnitField", "roundValue", "duration", "nbrDecimals", "grid", "durationDisplayPrecision", "decimalPrecision", "multiplier", "Math", "pow", "round", "formatValue", "durationUnit", "Duration", "unit", "magnitude", "DateHelper", "getLocalizedNameOfUnit", "defaultRenderer", "record", "isExport", "value", "durationValue", "toClipboardString", "toString", "fromClipboardString", "string", "parseDuration", "fullDuration", "calculateFillValue", "ColumnStore", "registerColumnType", "_$name", "isLastLevel", "level", "levels", "isLastCell", "cell", "cells", "TimeAxisBase", "Widget", "size", "range", "me", "refresh", "buildCells", "start", "end", "_me$client", "sizeProperty", "stickyHeaders", "isVertical", "client", "featureHeaderConfigs", "cellConfigs", "i", "_level$cells", "stickyHeader", "className", "position", "model", "viewPreset", "mainHeaderLevel", "syncOptions", "releaseThreshold", "syncIdField", "dataset", "headerFeature", "headerPosition", "children", "filter", "j", "role", "headerCellCls", "align", "tickIndex", "index", "globalThis", "DEBUG", "date", "getTime", "style", "positionProperty", "coord", "width", "tag", "html", "getHeaderDomConfigs", "widgetClassList", "render", "targetElement", "rebuild", "columnConfig", "oldLevelsCount", "reduce", "sum", "parentElement", "element", "classList", "remove", "add", "DomSync", "sync", "domConfig", "trigger", "widgetClass", "__publicField", "configurable", "compactCellWidthThreshold", "cls", "HorizontalTimeAxis", "_this$owner", "owner", "rtl", "onModelUpdate", "availableSpace", "updateModel", "timeAxisViewModel", "detachListeners", "ion", "update", "thisObj", "ResourceHeader", "firstResource", "lastResource", "scheduler", "_resourceColumns", "imagePath", "EventHelper", "on", "delegate", "capture", "click", "dblclick", "contextmenu", "changeShowAvatars", "show", "_this$avatarRendering", "avatarRendering", "destroy", "AvatarRendering", "updateShowAvatars", "isConfiguring", "updateResourceStore", "store", "changePreCommit", "count", "onResourceStoreDataChange", "action", "getConfig", "updateWidthCache", "totalWidth", "variableColumnWidths", "_fillWidth", "_fitWidth", "configuredFillWidth", "configuredFitWidth", "DomHelper", "setLength", "column", "innerHTML", "fitWidth", "fillWidth", "refreshWidths", "toggleEmptyText", "result", "resourceStore", "resource", "instanceMeta", "insetStart", "insetEnd", "columnWidth", "resourceColumnWidth", "changeColumnWidth", "refreshingWidths", "configuredColumnWidth", "updateColumnWidth", "oldWidth", "isGrouped", "changeFillWidth", "updateFillWidth", "changeFitWidth", "updateFitWidth", "getImageURL", "imageName", "StringHelper", "joinPaths", "updateImagePath", "updateAvailableWidth", "_me$resourceStore", "availableWidth", "fit", "useWidth", "floor", "shouldAnimate", "enableEventAnimations", "abs", "_columnWidth", "addTemporaryClass", "visibleResources", "groupField", "groupers", "configs", "toggle", "Boolean", "currentGroup", "_currentGroup", "resourceRecord", "allResourceRecords", "groupRecord", "groupParent", "groupChildren", "id", "resourceId", "groupLeft", "groupWidth", "left", "encodeHtml", "elementConfig", "DomClassList", "headerRenderer", "imageUrl", "image", "_resourceRecord$name", "toLowerCase", "imageExtension", "showAvatars", "getResourceAvatar", "initials", "color", "eventColor", "iconCls", "defaultImageUrl", "defaultImageName", "onlyChildren", "onResourceMouseEvent", "event", "resourceCell", "target", "closest", "getById", "capitalize", "getCurrentConfig", "options", "$config", "TimeAxisColumn", "Events", "WidgetColumn", "persist", "draggable", "groupable", "hideable", "showColumnPicker", "filterable", "resizable", "searchable", "editor", "enableCellContextMenu", "tooltipRenderer", "needWidth", "mode", "region", "exportable", "htmlEncode", "paint", "once", "autoExposeFields", "doDestroy", "_this$resourceColumns", "_this$timeAxisView", "resourceColumns", "timeAxisView", "resourceImagePath", "resourceImageExtension", "defaultResourceImageName", "relayEvents", "onViewModelUpdate", "source", "viewModel", "timeAxisSubGrid", "collapsed", "refreshHeader", "totalSize", "subGrid", "refreshFakeScroll", "refreshRows", "onTimelinePaint", "firstPaint", "insertRowsBefore", "subGridElement", "_me$grid", "onHeightChange", "internal", "undefined", "rendered", "currentElement", "internalRenderer", "renderData", "project", "isInitialCommitPerformed", "isDelayingCalculation", "currentOrientation", "renderer", "_timeAxisViewModel", "prio", "getState", "state", "flex", "ViewPreset", "Model", "normalizeUnits", "generateId", "headers", "parts", "getPrototypeOf", "increment", "multiple", "includes", "tickWidth", "tickHeight", "bottomHeader", "IdHelper", "timeResolution", "shiftUnit", "header", "DH", "normalizeUnit", "splitUnit", "normalizeHeaderConfig", "headerConfig", "columnLinesFor", "top", "middle", "bottom", "inSet", "tickSize", "_tickSize", "mainHeader", "topHeader", "topUnit", "topIncrement", "leafUnit", "leafIncrement", "mainUnit", "msPerPixel", "asMilliseconds", "isValid", "valid", "PresetStore", "Localizable", "Store", "defaultConfig", "useRawData", "modelClass", "zoomOrder", "storage", "addSorter", "lhs", "rhs", "leftBottomHeader", "rightBottomHeader", "unitMagnitudes", "isPresetManager", "PresetManager", "createRecord", "isViewPreset", "getAt", "base", "copyBaseValues", "updateLocalization", "presets", "allRecords", "Set", "concat", "values", "basePresets", "preset", "localePreset", "optionalL", "baseId", "originalDisplayDateFormat", "displayDateFormat", "topDateFormat", "middleDateFormat", "setData", "levelConfig", "localeLevelDateFormat", "originalDateFormat", "dateFormat", "unlocalizedName", "presetData", "clone", "merge", "Array", "isArray", "originalData", "preventSubClassingModel", "secondAndMinute", "shiftIncrement", "defaultSpan", "minuteAndHour", "hourAndDay", "day", "format", "week", "dayAndWeek", "getShortNameOfUnit", "dayAndMonth", "weekAndDay", "weekAndMonth", "weekAndDayLetter", "verticalColumnWidth", "weekDateAndMonth", "monthAndYear", "year", "cfg", "toUpperCase", "getMonth", "manyYears", "getFullYear", "defaultPresets", "resolution", "resolutionUnit", "internalListeners", "locale", "presetCache", "_basePresets", "presetAdjustment", "isBase", "baseType", "setPrototypeOf", "height", "getUnitByName", "registerPreset", "existingDuplicate", "find", "p", "equals", "getPreset", "normalizePreset", "deletePreset", "presetOrId", "pm", "Tick", "TimeSpan", "TimeAxis", "continuous", "originalContinuous", "include", "autoAdjust", "adjustedStart", "adjustedEnd", "visibleTickStart", "visibleTickEnd", "tickCache", "maxTraverseTries", "disableDuplicateIdCheck", "disableDefaultValue", "disableTypeConversion", "generateTicks", "resolutionIncrement", "weekStartDay", "forceFullTicks", "change", "supressRefresh", "endreconfigure", "internalOnReconfigure", "getAdjustedDates", "Date", "isTimeAxis", "reconfigure", "suppressRefresh", "preventThrow", "normalized", "oldConfig", "_configuredStartDate", "_configuredEndDate", "propName", "viewPresetChanged", "isFiltered", "filters", "f", "disabled", "isConfigured", "adjusted", "ticks", "suspendEvents", "maintainFilter", "disableFilters", "resumeEvents", "first", "last", "isContinuous", "getNext", "updateVisibleTickBoundaries", "updateTickCache", "startDenominator", "getNormalizedUnitDuration", "endDenominator", "fullTicks", "_viewPreset", "presetName", "_a", "_weekStartDay", "_resolutionUnit", "_resolutionIncrement", "setTimeSpan", "newStartDate", "newEndDate", "shift", "amount", "allCount", "tries", "shiftNext", "shiftPrevious", "filterBy", "fn", "clear", "tick", "retVal", "triggerFilterEvent", "forceAdjust", "floorDate", "ceilDate", "_start", "parse", "_end", "startMS", "_startMS", "endMS", "_endMS", "relativeToStart", "incr", "relativeTo", "snap", "snappedDuration", "diff", "dt", "getDay", "startDay", "startOf", "getHours", "modifier", "useUnit", "snappedValue", "roundDate", "distanceToWeekStartDay", "toAdd", "nbrMonths", "as", "daysInMonth", "snappedMonths", "offset", "getTimezoneOffset", "doCall", "isStartOf", "isEqual", "getDate", "_include", "processExclusion", "entries", "some", "includeUnit", "rule", "from", "to", "compareUnits", "getLargerUnit", "stepUnit", "datePart", "initExclusion", "lengthFactor", "getUnitToBaseUnitRatio", "lengthFactorExcl", "center", "updateGenerateTicks", "_generateTicks", "axisStartDate", "axisEndDate", "usesExclusion", "intervalEnd", "tickEnd", "isExcluded", "dstDiff", "prev", "visibleTickTimeSpan", "getTickFromDate", "_date$getTime", "records", "dateMS", "begin", "tickStart", "startDateMS", "endDateMS", "getDateFromTick", "roundingMethod", "wholeTick", "fraction", "t", "onlyStartEnd", "_startMs", "dateInAxis", "inclusiveEnd", "axisStart", "axisEnd", "betweenLesserEqual", "betweenLesser", "getCount", "timeSpanInAxis", "intersectSpans", "isTimeSpanInAxis", "timeSpan", "meta", "endDateCached", "startTick", "endTick", "forEachAuxInterval", "iteratorFn", "DragBase", "InstancePlugin", "tooltipTemplate", "startClockHtml", "endClockHtml", "message", "showTooltip", "showExactDropPosition", "dragHelperConfig", "tooltipCls", "constrainDragToTimeline", "constrainDragToResource", "constrainDragToTimeSlot", "tip", "allowTargetOut", "autoShow", "updateContentOnMouseMove", "throttleDragEvent", "pluginConfig", "chain", "internalSnapToPosition", "snapTo", "_this$snapToPosition", "dragData", "snapToPosition", "assignmentRecord", "eventRecord", "newResource", "buildDragHelperConfig", "isHorizontal", "lockY", "lockX", "externalDropTargetSelector", "dropTargetSelector", "Objects", "positioning", "minX", "maxX", "constrain", "cloneTarget", "removeProxyAfterDrop", "dragWithin", "document", "body", "hideOriginalElement", "dropTargetCls", "outerElement", "timeAxisSubGridElement", "targetSelector", "eventSelector", "scrollManager", "createProxy", "el", "snapCoordinates", "newX", "newY", "draggedEventRecord", "draggedEntities", "coordinate", "getCoordinate", "snappedDate", "getDateFromPosition", "isWorkingTime", "snappedPosition", "getPositionFromDate", "x", "y", "beforedragstart", "dragstart", "afterdragstart", "drag", "drop", "abort", "abortFinalized", "reset", "isElementDraggable", "onPaint", "_me$drag", "DragHelper", "rowManager", "changeTotalHeight", "_me$dragData", "updateYConstraint", "scheduledEventName", "clockTemplate", "ClockTemplate", "_this$drag", "_this$clockTemplate", "_this$tip", "tipId", "changeTip", "oldTip", "Tooltip", "mergeConfigs", "forElement", "getHtml", "getTipHtml", "bind", "innerHtmlUpdate", "proxy", "cloneNode", "onBeforeDragStart", "context", "getMinimalDragData", "readOnly", "isDraggable", "pointerStartDate", "getDateFromXY", "startClientX", "startPageY", "triggerBeforeEventDrag", "capitalizedEventName", "_client", "onAfterDragStart", "isDragging", "_this$drag2", "isActivelyDragging", "finalizing", "onDragStart", "_client2", "_menuFeature$hideCont", "findClientFromTarget", "currentOverClient", "unifiedProxy", "unifiedDrag", "onMouseOverNewTimeline", "getDragData", "suspendElementRedrawing", "tipTarget", "dragProxy", "firstChild", "showBy", "triggerDragStart", "eventMenu", "taskMenu", "features", "menuFeature", "hideContextMenu", "updateDateIndicator", "endDateElement", "querySelector", "test", "Rectangle", "elementFromPoint", "fromElement", "isResourceHistogram", "onDrag", "dd", "updateDragContext", "dirty", "triggerEventDrag", "externalDragValidity", "lastAlignSpec", "realign", "newTimeline", "initial", "scrollables", "stopMonitoring", "scrollable", "direction", "startMonitoring", "callback", "onScrollManagerScrollCallback", "triggerBeforeEventDropFinalize", "eventType", "eventData", "onDrop", "_me$tip", "modified", "hide", "isValidDrop", "externalDropTarget", "beforeDropTriggered", "finalize", "async", "domEvent", "origStart", "onDragAbort", "_me$tip2", "resetDraggedElements", "triggerDragAbort", "onDragAbortFinalized", "_me$client2", "triggerDragAbortFinalized", "onDragReset", "dragHelper", "_dragHelper$context", "currentTimeline", "started", "eventBarEls", "resumeRecordElementRedrawing", "draggingCls", "retainElement", "onInternalInvalidDrop", "_me$tip3", "triggerAfterDrop", "updateRecords", "isPromise", "info", "isAssignment", "lastDragStartDate", "constrainToTimeSlot", "browserEvent", "getProductDragContext", "timeDiff", "timeAxis", "timeAxisPosition", "pageX", "startPageX", "pageY", "pointerDate", "getDateFromCoordinate", "resolveStartEndDates", "adjustStartDate", "positionDirty", "L", "checkDragValidity", "_dd$externalDragValid", "suspendRecordElementRedrawing", "suspend", "getRecordElement", "resumeElementRedrawing", "productDragData", "setupProductDragData", "startEvent", "timespan", "origEnd", "startsOutsideView", "endsOutsideView", "multiSelect", "isSchedulerBase", "multiEventSelect", "selectionMode", "elementStartX", "elementStartY", "clientCoordinate", "startClientY", "selectAssignment", "ctrlKey", "selectEvent", "sourceDate", "screenSourceDate", "relatedElements", "setupConstraints", "constrainRegion", "elRegion", "constrained", "xTickSize", "yTickSize", "setXConstraint", "right", "setYConstraint", "snapPixelAmount", "getScheduleRegion", "offsetHeight", "iLeft", "iRight", "iTickSize", "iUp", "iDown", "minY", "maxY", "rounded", "snapRelativeToEventStartDate", "constrainStartDate", "draggedElement", "timeline", "proxyRect", "eventInnerSelector", "fillSnap", "fillTicks", "getStartEndDatesFromRectangle", "offsetMS", "proxyMS", "offsetPx", "deflate", "proxyStart", "getStart", "startText", "getFormattedDate", "endText", "getFormattedEndDate", "dragged", "timeSpanRecord", "isTask", "template", "isMilestone", "updateConstrainDragToTimeSlot", "axis", "updateConstrainDragToResource", "updateConstrainDragToTimeline", "dateConstraints", "scheduleableRecord", "taskRecord", "durationMS", "getElementFromContext", "grabbed", "getRelatedRecords", "tipAlign", "EventResize", "mixin", "Draggable", "Droppable", "draggingItemCls", "resizingItemInnerCls", "leftHandle", "rightHandle", "topHandle", "bottomHandle", "handleSize", "dynamicHandleSize", "allowResizeToZero", "reservedSpace", "touchHandleSize", "dragThreshold", "dragTouchStartDelay", "draggingClsSelector", "showExactResizePosition", "validatorFn", "validatorFnThisObj", "axisLock", "trackMouse", "hideDelay", "ignoreSelector", "dragActiveCls", "_this$dragging", "dragging", "dragSelector", "dragItemSelector", "dragRootElement", "dropRootElement", "dragLock", "isEventElementDraggable", "eventElement", "eventResizable", "isOverStartHandle", "isOverEndHandle", "onEventDataGenerated", "wrapperCls", "_this$dragging2", "_this$dragging2$conte", "onDragPointerMove", "_dragging$context", "visibleDateRange", "dimension", "pageScroll", "clientRect", "startCoord", "endCoord", "getEnd", "getDateFromCoord", "local", "clientStartCoord", "clientEndCoord", "isResizing", "beforeDrag", "resolveTimeSpanRecord", "itemElement", "isGanttBase", "resolveResourceRecord", "isOccurrence", "mousedownDate", "triggerBeforeResize", "dragStart", "_client$features$even", "_client$resolveAssign", "resolveEventRecord", "isBatchUpdating", "wrapStartDate", "wrapEndDate", "useEventBuffer", "eventBuffer", "enabled", "eventStartDate", "eventEndDate", "horizontal", "draggingEnd", "toSet", "wrapToSet", "otherEnd", "setMethod", "setOtherMethod", "elRect", "clientX", "clientY", "timespanRecord", "oldValue", "edge", "originalStartDate", "originalEndDate", "split", "listenToBatchedUpdates", "beginListeningForBatchedUpdates", "beginEventRecordBatch", "setupProductResizeContext", "triggerEventResizeStart", "getResizeStartParams", "resizedRecord", "resolveAssignmentRecord", "getTooltipTarget", "getBeforeResizeParams", "_this$client", "_this$client2", "triggerEventResizeEnd", "triggerEventPartialResize", "triggerBeforeEventResizeFinalize", "dragEnter", "_drag$context", "resizeEventPartiallyInternal", "_client$features$even2", "applyDateConstraints", "_context$dateConstrai", "_context$dateConstrai2", "minDate", "maxDate", "moveDrag", "eventStart", "eventEnd", "isScroll", "crossedOver", "avoidedZeroSize", "onDragEndSwitch", "isEventDragCreate", "tooNarrow", "sign", "checkValidity", "partialResizeEvent", "stores", "eventStore", "alignTo", "dragEnd", "aborted", "getPagePoint", "cleanup", "dragDrop", "updateRecord", "wasChanged", "internalUpdateRecord", "cancelEventRecordBatch", "resources", "repaintEventsForResource", "changed", "endListeningForBatchedUpdates", "unHighlightHandle", "getResizeEndParams", "generation", "batching", "prototype", "inSetNormalize", "isEntity", "_client$features$even3", "run", "setOtherEnd", "promisesToWait", "Promise", "all", "endBatch", "batchChanges", "commitAsync", "onDragItemMouseMove", "pointerType", "handleSelector", "checkResizeHandles", "overItem", "allowResize", "isOverAnyHandle", "highlightHandle", "onDragItemMouseLeave", "oldOverItem", "_item$syncIdMap", "item", "syncIdMap", "_item$syncIdMap2", "inner", "_this$getHandleRect", "getHandleRect", "contains", "_this$getHandleRect2", "side", "eventEl", "eventCls", "dim", "handleSpec", "offsetWidth", "isResizable", "eventRect", "handleStyle", "getComputedStyle", "BrowserHelper", "isHoverableDevice", "parseFloat", "handleVisThresh", "handleVisibilityThreshold", "centerGap", "deflateArgs", "constrainTo", "setupDragContext", "isElementResizable", "changeHandleSize", "VersionHelper", "deprecate", "changeTouchHandleSize", "isTooltip", "innerhtmlupdate", "_me$clockTemplate", "_element", "handleHoldingElement", "handleEl", "startsOutside", "endsOutside", "anchorSize", "basicValidityCheck", "tipData", "beginBatch", "cancelBatch", "_client$resolveResour", "_client$resolveAssign2", "_client$getDateConstr", "getDateConstraints", "allowOverlap", "isDateRangeAvailable", "GridFeatureManager", "registerFeature", "getDragCreateDragDistance", "_this$source", "_this$source$client$f", "taskEdit", "_canceling", "getDistanceBetween", "DragCreateBase", "TaskEditStm", "changeValidatorFn", "createValidatorFn", "initialDate", "pan", "eventDragSelect", "preventMultiple", "isRowEmpty", "rowRecord", "preventDragSelect", "startDrag", "proxyElement", "matchScheduleCell", "$original", "isSpecialRow", "monitoringConfig", "getDistance", "updateDragTolerance", "dragTolerance", "doCreate", "finalized", "completeFinalization", "isDestroyed", "finalizeDragCreate", "_me$onAborted", "cancelDragCreate", "onAborted", "stmCapture", "stmInitiallyAutoRecord", "stmInitiallyDisabled", "transferred", "_this$tip2", "onElementContextMenu", "prepareCreateContextForFinalization", "createContext", "_this$dragging$contex", "handleBeforeDragCreate", "dateTime", "tipTemplate", "before", "TooltipBase", "autoUpdate", "hoverDelay", "monitorRecordUpdate", "testConfig", "processConfig", "forSelector", "_me$tooltip", "tooltip", "setConfig", "destroyProperties", "doDisable", "disable", "_me$tooltip2", "tipCls", "scrollAction", "showOnHover", "anchorToTarget", "configuredListeners", "overtarget", "keys", "$meta", "defineProperty", "v", "processConfiguredListeners", "addListener", "_this$tooltip", "defaultDetacher", "tooltipDetacher", "removeListener", "_this$tooltip2", "activeTarget", "recordProp", "recordType", "endDateValue", "getDisplayEndDate", "onTipShow", "updateListener", "onRecordUpdate", "buffer", "onTipHide", "_this$updateListener", "onOverNewTarget", "newTarget", "isVisible", "updateContent", "aligningToElement", "internalOnPointerOver", "lastPointerEvent", "AbstractTimeRanges", "Delayable", "rangeCls", "lineCls", "enableResizing", "dragTipTemplate", "baseCls", "bodyRenderer", "narrowThreshold", "renderRows", "onUIReady", "$$name", "baseSelector", "showHeaderElements", "_me$resize", "resize", "renderRanges", "setupTimeAxisViewModelListeners", "includeChange", "updateLineBuffer", "timeAxisViewModelChange", "hideHeaders", "headerContainerElement", "onTimeRangeClick", "rtlSource", "ResizeHelper", "matches", "resizestart", "resizing", "cancel", "resizeHelperConfig", "hoverTooltip", "timeRange", "resolveTimeRangeRecord", "_timeRanges", "getDOMConfig", "bodyConfigs", "headerConfigs", "_labelRotationMap", "timeRanges", "renderRange", "bodyConfig", "foregroundCanvas", "isPainted", "updatedBodyElements", "bodyCanvas", "createElement", "parent", "childrenOnly", "headerCanvas", "bodyElement", "cacheRotation", "elementData", "applyRotation", "shouldRenderRange", "rangeStart", "rangeEnd", "_lineBufferDurationMS", "getRangeDomConfig", "startPos", "getCoordinateFromDate", "respectExclusion", "endPos", "isEnd", "isRange", "translateX", "icon", "xss", "labelTpl", "showLabelInBody", "label", "firstElementChild", "recurringTimeSpan", "_range$recurringTimeS", "_bodyElement$firstEle", "rotate", "getBodyElementByRecord", "idOrRecord", "getChild", "timeView", "timeAxisColumn", "_headerContainerElement", "_showHeaderElements", "updateShowHeaderElements", "populateTimeAxisHeaderMenu", "items", "onSchedulerHorizontalScroll", "afterScroll", "onInternalResize", "newWidth", "newHeight", "oldHeight", "onTimeAxisViewModelUpdate", "timeRangeRecord", "showTip", "destroyTip", "Number", "MAX_SAFE_INTEGER", "onInvalidDrop", "onResizeStart", "onResizeDrag", "onResize", "onInvalidResize", "onResizeReset", "box", "emptyObject", "freeze", "ColumnLines", "AttachToProjectMixin", "delayable", "cancelOutstanding", "after", "useBackgroundCanvas", "attachToResourceStore", "group", "getColumnLinesDOMConfig", "m", "linesForLevel", "majorLinesForLevel", "domConfigs", "dates", "addLineConfig", "isMajor", "has", "transform", "line", "columnLines", "getResourceRange", "nbrGroupHeaders", "_instanceMeta$groupPa", "_instanceMeta$groupPa2", "isGroupHeader", "backgroundCanvas", "onVisibleDateRangeChange", "onVisibleResourceRangeChange", "updateCanvasSize", "DependencyCreation", "Target", "allowDropOnEventBar", "showCreationTooltip", "creationTooltip", "terminalCls", "terminalSides", "allowCreate", "view", "eventName", "updateCreateListeners", "_me$pointerUpMoveDeta", "_me$creationTooltip", "creationData", "pointerUpMoveDetacher", "isCreateAllowed", "_allowCreate", "onTimeSpanMouseEnter", "isCreating", "nestedEvents", "isRoot", "eventBarElement", "down", "showTerminals", "timeSpanElement", "onOverTargetEventBar", "onTimeSpanMouseLeave", "_event$event", "timeSpanLeft", "relatedTarget", "isDescendant", "isTrusted", "sourceElement", "hideTerminals", "onOverNewTargetWhileCreating", "onTerminalMouseOver", "onTerminalMouseOut", "showingTerminalsFor", "unhover", "onTerminalPointerDown", "button", "_scheduler$resolveRes", "terminalNode", "viewBounds", "stopPropagation", "fromSide", "startPoint", "startX", "scrollLeft", "startY", "scrollTop", "sourceResource", "pointerup", "getRootNode", "handler", "passive", "pointermove", "documentPointerUpDetacher", "keydown", "key", "onElementTouchMove", "_super$onElementTouch", "connector", "preventDefault", "onMouseMove", "deltaX", "deltaY", "sqrt", "angle", "atan2", "onRequestDragCreate", "lastMouseMoveEvent", "createConnector", "createDragTooltip", "_overEventRecord", "overEventRecord", "isEventSegment", "removeClsGlobally", "toSide", "_data$timeSpanElement", "_data$timeSpanElement2", "getTargetSideFromType", "dependencyStore", "fieldMap", "DependencyBaseModel", "Type", "EndToStart", "targetResource", "dependencyType", "updateValidity", "StartToStart", "StartToEnd", "EndToEnd", "isValidDependency", "validityCls", "updateCreationTooltip", "onMouseUp", "_me$pointerUpMoveDeta2", "dependency", "createDependency", "doAfterDependencyDrop", "onDocumentMouseUp", "_me$pointerUpMoveDeta3", "_me$documentPointerUp", "getElementFromEventRecord", "removeConnector", "clearTimeout", "removeConnectorTimeout", "loadingMsg", "dock", "beforeShow", "setTimeout", "terminalsVisibleCls", "fixSide", "terminal", "feature", "detacher", "mouseover", "mouseout", "pointerdown", "internalCls", "eventParams", "getTimeSpanMouseEventParams", "forEachSelector", "newDependency", "resolve", "then", "creationTooltipTemplate", "_data$target", "fromText", "toText", "tipTitleIconClsSuffix", "tipTitleText", "title", "ref", "ROWS_PER_CELL", "DependencyGridCache", "gridCache", "getDependenciesToConsider", "startIndex", "endIndex", "dependencies", "fromMSCell", "MS_PER_CELL", "toMSCell", "fromRowCell", "toRowCell", "msCell", "intersectingDependencies", "afterDrawDependency", "fromIndex", "toIndex", "fromDateMS", "toDateMS", "constructGridCache", "timeAxisStartMS", "timeAxisEndMS", "timeAxisCells", "ceil", "firstMSCell", "lastMSCell", "firstRowCell", "lastRowCell", "startMSCell", "endMSCell", "beforeDraw", "afterDraw", "THRESHOLD", "devicePixelRatio", "BOX_PROPERTIES", "equalEnough", "a", "b", "RectangularPathFinder", "startSide", "startArrowMargin", "startShift", "endSide", "endArrowMargin", "endShift", "verticalMargin", "horizontalMargin", "otherBoxes", "findPath", "lineDef", "noPathFallbackFn", "originalLineDef", "lineDefFull", "startBox", "endBox", "startHorizontalMargin", "startVerticalMargin", "endHorizontalMargin", "endVerticalMargin", "otherHorizontalMargin", "otherVerticalMargin", "connStartPoint", "connEndPoint", "pathStartPoint", "pathEndPoint", "gridStartPoint", "gridEndPoint", "startGridBox", "endGridBox", "path", "tryNum", "ArrayHelper", "asArray", "hasOwnProperty", "normalizeSide", "getConnectionCoordinatesFromBoxSideShift", "calcGridBaseBoxFromBoxAndDrawParams", "property", "shouldLookForPath", "_otherBoxes", "buildPathGrid", "convertDecartPointToGridPoint", "findPathOnGrid", "prependPathWithArrowStaffSegment", "appendPathWithArrowStaffSegment", "optimizePath", "calculateRelativePosition", "box1", "box2", "vertical", "startProp", "endProp", "boxOverlapChanged", "gridStartBox", "gridEndBox", "calculateOverlap", "originalOverlap", "finalOverlap", "coords", "arrowMargin", "gridBox", "otherGridBoxes", "xs", "ys", "ix", "iy", "xslen", "yslen", "ib", "blen", "permitted", "point", "points", "linearPoints", "distance", "indexOf", "waveForward", "collectPath", "getGridPointNeighbors", "gridPoint", "predicateFn", "neighbor", "WalkHelper", "preWalkUnordered", "neighborPoint", "pathFound", "neighbors", "lowestDistanceNeighbor", "xDiff", "yDiff", "resultA", "resultB", "x1", "y1", "x2", "y2", "reverse", "firstSegment", "prependSegment", "unshift", "lastSegment", "appendSegment", "optPath", "prevSegment", "curSegment", "drawingDirection", "pointSet", "segmentLength", "arc", "nextPointSet", "radius", "corner", "rx", "ry", "location", "prevRadius", "useRadius", "nextLength", "subtract", "useLength", "currentRadius", "pathMapper", "lineSpec", "DependencyLineGenerator", "lineCache", "onSVGReady", "pathFinder", "pathFinderConfig", "lineDefAdjusters", "createLineDefAdjusters", "createMarker", "changeRadius", "assertNumber", "updateRadius", "updateRenderer", "changeClickWidth", "updateClickWidth", "_me$marker", "markerDef", "svg", "svgCanvas", "markerId", "marker", "setProperty", "ns", "markerHeight", "markerWidth", "refX", "refY", "viewBox", "orient", "markerUnits", "d", "updateMarkerDef", "getAssignmentElement", "assignment", "_this$client$features", "_this$client$features2", "eventDrag", "getProxyElement", "getElementFromAssignmentRecord", "getDomConfigs", "fromAssignment", "toAssignment", "forceBoxes", "getDependencyKey", "constructLineCache", "drawingLive", "prepareLineDef", "clickWidth", "toEvent", "_me$renderer", "highlighted", "syncId", "depId", "fromId", "toId", "class", "noMarkerCls", "hideMarker", "active", "bidirectional", "milestone", "dependencyRecord", "fromAssignmentRecord", "toAssignmentRecord", "fromBox", "toBox", "strokeWidth", "generateBoundaryBoxes", "rowTop", "rowBottom", "getAssignmentBounds", "isExporting", "rectangle", "row", "getRowById", "overRow", "getRowAt", "isEngineReady", "getAssignmentEventBox", "getConnectorStartSide", "getConnectorEndSide", "getDependencyStartSide", "fromEvent", "DependencyModel", "getDependencyEndSide", "shrinkArrowMargins", "barMargin", "resetArrowMargins", "shrinkHorizontalMargin", "adjustLineDef", "startRectangle", "endRectangle", "fromBoxSide", "toBoxSide", "DependencyTooltip", "changeTooltip", "old", "textContent", "getHoverTipHtml", "resolveDependencyRecord", "eventNameMap", "collectLinkedAssignments", "_assignment$resource", "hasLinks", "$links", "l", "drawDependencies", "Dependencies", "lastScrollX", "usingLinks", "svgCanvasCreated", "animationStart", "timelineViewportResize", "timeAxisViewModelUpdate", "toggleNode", "bindStore", "_isDisabling", "draw", "rowStore", "usesDisplayStore", "onStoreRefresh", "attachToProject", "commitFinalized", "onResourceStoreChange", "attachToEventStore", "attachToAssignmentStore", "assignmentStore", "attachToDependencyStore", "updateDrawOnScroll", "drawOnScroll", "scroll", "horizontalScroll", "scrollEnd", "onHorizontalScroll", "scrollX", "getLocalizedDependencyType", "getElementForDependency", "getElementsForDependency", "selector", "querySelectorAll", "_element$elementData", "isDependencyElement", "onElementClick", "onElementDblClick", "onElementMouseOver", "overCls", "highlight", "onElementMouseOut", "unhighlight", "isDependencyVisible", "fromResource", "toResource", "isAvailable", "isModel", "hidden", "updateHighlightDependenciesOnEventHover", "enable", "params", "highlightEventDependencies", "unhighlightEventDependencies", "classes", "delete", "dep", "_super$getDependencie", "drawDependency", "batch", "_fromAssigned", "_toAssigned", "topIndex", "bottomIndex", "useInitialAnimation", "idMap", "fromAssigned", "assigned", "toAssigned", "isScheduled", "flatMap", "_idMap$from$resource$", "_from$resource", "_idMap$to$resource$id", "_to$resource", "lineDomConfigs", "animationDelay", "domSync", "_super$afterDrawDepen", "_super$beforeDraw", "_super$afterDraw", "flat", "strict", "fillDrawingCache", "r", "refreshSuspended", "firstVisibleRow", "lastVisibleRow", "doRefresh", "_client$features", "_client$features2", "_client$features3", "_client$features4", "isAnimating", "_super$reset", "drawForEvent", "highlightDependenciesOnEventHover", "EventFilter", "eventsFilter", "localeClass", "weight", "menu", "nameFilter", "clearable", "keyStrokeChangeDelay", "onEventFilterChange", "onBeforeShow", "filterByName", "getBy", "removeFilter", "featureClass", "NonWorkingTimeMixin", "getNonWorkingTimeRanges", "forEachAvailabilityInterval", "isForward", "intervalStartDate", "intervalEndDate", "calendarCacheInterval", "entry", "getIsWorking", "getCalendarTimeRanges", "ignoreName", "shouldPaint", "maxTimeAxisUnit", "allRanges", "timeSpans", "mergedSpans", "prevRange", "span", "setStartEndDate", "setupDefaultCalendar", "autoGeneratedWeekends", "isSchedulerPro", "isGantt", "effectiveCalendar", "defaultCalendar", "intervalStore", "updateDefaultCalendar", "defaultNonWorkingIntervals", "hasIntervals", "clearIntervals", "addIntervals", "_super$updateLocaliza", "dayNames", "nonWorkingDaysAsArray", "dayIndex", "recurrentStartDate", "recurrentEndDate", "NonWorkingTime", "highlightWeekends", "hideRangesOnZooming", "attachToCalendar", "onConfigChange", "graph", "isScheduler", "dataReady", "calendarChange", "_timeAxisUnitDurationMs", "isDestroying", "isCalculated", "_this$project", "timeAxisUnitDurationMs", "ScheduleTooltip", "messageTemplate", "hideForNonWorkingTime", "reshowListener", "hoverTip", "allowOver", "monitorResize", "onDocumentMouseDown", "mousemove", "e", "hideAnimation", "pointerover", "buttonsPressed", "buttons", "which", "lastTime", "updateTip", "getDateFromDomEvent", "lastHtml", "lastResourceId", "generateTipContent", "clockHtml", "generateContent", "messageHtml", "getText", "setTimeSpanOptions", "maintainVisibleStart", "TimeAxisHeaderMenu", "HeaderMenu", "processItems", "triggerEvent", "zoomOnTimeAxisDoubleClick", "shouldShowMenu", "enableHeaderContextMenu", "isTimeAxisColumn", "showContextMenu", "dateStep", "zoomLevel", "zoomSlider", "minWidth", "showValue", "triggerChangeOnInput", "zoom", "minZoomLevel", "maxZoomLevel", "zoomDetatcher", "onHide", "dateRange", "startDateField", "labelWidth", "required", "onRangeDateFieldChange", "endDateField", "leftShiftBtn", "margin", "onLeftShiftBtnClick", "todayBtn", "onTodayBtnClick", "rightShiftBtn", "onRightShiftBtnClick", "initDateRangeFields", "onZoomSliderChange", "delay", "widgetMap", "initDates", "startDateFieldInitialValue", "endDateFieldInitialValue", "startDateChanged", "today", "clearTime", "TimeAxisViewModel", "forceFit", "suppressFit", "originalTickSize", "headersDatesCache", "unitToPixelsCache", "consumeViewPreset", "configured", "un", "onTimeAxisReconfigure", "calculateInfiniteScrollingDateRange", "centered", "bufferCoef", "useTop", "snapSize", "snapUnit", "halfSpan", "bufferedTicks", "_columnConfig", "_headers", "cellGenerator", "isTimeAxisViewModel", "_forceFit", "silent", "forceUpdate", "spaceAvailable", "_availableSpace", "calculateTickSize", "_totalSize", "pos", "headerCells", "createHeaderRow", "getDistanceBetweenDates", "getDistanceForDuration", "durationMs", "getSingleUnitInPixels", "getScaledTick", "snapToNextIncluded", "tickChanged", "hour", "originalHours", "croppedHours", "fractionalHours", "getMinutes", "hoursFromCenter", "newHours", "checkDay", "getSeconds", "getMilliseconds", "addDays", "fixedCenter", "fractionalDay", "daysFromCenter", "newDay", "allowOutOfRange", "getScaledPosition", "dayWidth", "positionInWeek", "weekStartPosition", "hourWidth", "positionInDay", "dayStartPosition", "setTickSize", "suppressEvent", "proposedSize", "timelineUnit", "ratio", "fittingSize", "space", "newTickSize", "getDates", "useLowestHeader", "lowestHeader", "majorLevel", "majorHeaderLevel", "levelUnit", "majorUnit", "validMajor", "doesUnitsAlign", "forEachInterval", "isMajorTick", "fitToAvailableSpace", "_snap", "headerRowConfig", "tickLevel", "createCellContext", "isLast", "isInteriorTick", "cellData", "nextLevel", "forEachMainInterval", "tempDate", "TimelineDateMapper", "getRtlX", "ignoreRTL", "translateToScheduleCoordinate", "xy", "rect", "getYear", "formatContainsHourInfo", "valueOf", "setTime", "translateToPageCoordinate", "getTimeSpanDistance", "viewportCenterDate", "timelineScroller", "timeAxisOffset", "clientSize", "scrollSize", "viewportCenterDateCached", "cachedCenterDate", "_this$_timeAxisViewMo", "updateSnap", "scrollingToCenter", "TimelineDomEvents", "hoveredEvents", "initDomEvents", "schedulerEvents", "schedulerEnterLeaveEvents", "supportsPointerEventConstructor", "getScheduleMouseEventParams", "handleScheduleEvent", "timelineContext", "getTimelineEventContext", "handleScheduleEnterLeaveEvent", "onScheduleScroll", "_me$features$pan", "updateTimelineContextOnScroll", "isActive", "partners", "_p$features$pan", "_GlobalEvents$current", "_GlobalEvents$current2", "pointerEvent", "PointerEventConstructor", "mouseEvent", "MouseEvent", "GlobalEvents", "currentPointerDown", "pointerId", "currentTouch", "identifier", "scrollInitiated", "dispatchEvent", "updateTimelineContext", "oldContext", "cellElement", "getCellElementFromDomEvent", "clickedDate", "DomDataStore", "mouseParams", "dataIndex", "isTimelineContext", "tickStartDate", "tickEndDate", "tickParentIndex", "parentIndex", "getCell", "resolveRowRecord", "_me$rowManager$getRow", "timeCellSelector", "onElementMouseButtonEvent", "targetCell", "findIndex", "cellConfig", "contextMenu", "onElementMouseDown", "_me$features$eventDra", "preventOverCls", "overScheduledEventClass", "unhoverAll", "_me$features$eventDra2", "eventInner", "eventWrap", "isReleased", "equal", "c1", "c2", "properties", "mousedown", "mouseup", "mouseenter", "mouseleave", "datesDiffer", "d1", "d2", "TimelineViewPresets", "changePresets", "presetRecord", "presetStore", "changeViewPreset", "oldViewPreset", "lastOpts", "lastViewPresetOptions", "presetChanged", "optionsChanged", "centerDate", "_displayDateFormat", "updateDisplayDateFormat", "updateViewPreset", "_timeAxis", "zoomDate", "zoomPosition", "_viewPresetChanging", "suspendRefresh", "timeAxisCfg", "copyProperties", "infiniteScroll", "resumeRefresh", "notScroll", "visibleDate", "unitMagnitude", "milliseconds", "targetDate", "scrollWidth", "viewportSize", "centerCoord", "scrollHorizontallyTo", "scrollVerticallyTo", "scrollTo", "presetId", "updateFromHorizontalScroll", "updateFromVerticalScroll", "_presets", "TimelineZoomable", "lastWheelTime", "lastZoomPosition", "zoomOnMouseWheel", "wheel", "throttled", "alt", "timeaxisheaderdblclick", "zoomToSpan", "_maxZoomLevel", "_minZoomLevel", "zoomToLevel", "getMilliSecondsPerPixelForZoomLevel", "ignoreActualWidth", "actualWidth", "zoomTo", "console", "warn", "tickSizeProp", "newPreset", "configuredTickSize", "scrollableViewportSize", "clientHeight", "_beforeCollapseState", "calculateOptimalDateRange", "isZooming", "zoomToFit", "getTotalTimeSpan", "leftMargin", "rightMargin", "scrollToDate", "adjustStart", "adjustEnd", "needToAdjust", "diffMS", "currLevel", "inc", "candidateLevel", "levelToZoom", "spanWidth", "unitToZoom", "tickCount", "getDurationInUnit", "customWidth", "block", "zoomIn", "currentZoomLevelIndex", "zoomOut", "zoomInFull", "zoomOutFull", "userProvidedSpan", "zoomKeepsOriginalTimespan", "difference", "visibleZoomFactor", "onElementMouseMove", "zoomContext", "onWheel", "now", "performance", "viewport", "TimelineEventRendering", "resourceMargin", "managedEventSizing", "generatedIdCls", "dirtyCls", "committingCls", "endsOutsideViewCls", "startsOutsideViewCls", "fixedEventCls", "eventStyle", "updateFillTicks", "refreshWithTransition", "changeBarMargin", "rowHeight", "updateBarMargin", "onBeforeRowHeightChange", "_resourceMargin", "eventColors", "eventStyles", "defaultScrollOptions", "TimelineScroll", "bufferThreshold", "initScroll", "scrollInitialized", "_timelineScroller", "TimelineScroller", "widget", "_this$_timelineScroll", "onTimelineScroll", "checkTimeAxisScroll", "scrollPos", "requiredSize", "limit", "maxScroll", "maxPosition", "virtualScrollerElement", "overflow", "pointerEvents", "paddingBottom", "scrollBarWidth", "shiftToDate", "newRange", "updateInfiniteScroll", "edgeOffset", "visibleWidth", "extraScroll", "nextAnimationFrame", "scrollerViewport", "localCoordinate", "scrollToCoordinate", "scrollToNow", "visibleSpan", "scrollIntoView", "Scroller", "updateOverflowX", "updateOverflowY", "onScroll", "_position", "syncPartners", "force", "updatePosition", "scrollBy", "xDelta", "yDelta", "changeX", "changeY", "scroller", "clientWidth", "scrollHeight", "TimelineState", "zoomLevelOptions", "applyState", "_state$scroll", "_zoomAfterPaint", "Header", "GridHeader", "refreshContent", "_this$headersElement", "headersElement", "TimeAxisSubGrid", "SubGrid", "sealedColumns", "headerClass", "startConfigure", "changeScrollable", "_this$element", "syncScrollingPartners", "addCls", "bodyHeight", "_bodyRectangle", "onSchedulerViewportResize", "requestAnimationFrame", "clearWidthCache", "updateViewModelAvailableSpace", "expand", "initClass", "exitTransition", "TimelineBase", "GridBase", "RecurringEvents", "workingTime", "autoAdjustTimeAxis", "timeCellCls", "disableGridRowModelWarning", "animateRemovingRows", "partner", "schedulerRegion", "transitionDuration", "animationTimeout", "defaultRegion", "asyncEventSuffix", "viewportResizeTimeout", "updateTimeZone", "timeZone", "_isConfiguringTimeZone", "populateEventMenu", "populateScheduleMenu", "handlingVisibleDateRangeChange", "_visibleDateRange", "$firstVerticalOverflow", "init", "forceLayout", "createSubGrid", "overflowX", "overflowY", "bodyContainer", "partneredWith", "removePartner", "ResizeMonitor", "addResizeListener", "onBodyResize", "changeStartDate", "getBoundingClientRect", "_me$currentOrientatio", "_me$currentOrientatio2", "doUpdateTimeView", "frameCount", "testPerformance", "scrollSpeed", "scrollInterval", "setInterval", "timePerFrame", "fps", "clearInterval", "log", "eventPositionMode", "eventScrollMode", "preserveViewCenter", "scrollStart", "startChanged", "endChanged", "oldTickSize", "currentScroll", "visibleStart", "tickSizeChanged", "returnValue", "hasVisibleEvents", "noFeatureElementsInAxis", "_capitalizedEventName", "_partner", "addPartner", "isPartneredWith", "Collection", "presetchange", "overflowChange", "partnerSharedConfig", "partnerSharedConfigs", "configName", "syncPartnerSubGrids", "FunctionHelper", "createSequence", "_this$partneredWith", "onPartnerOverflowChange", "otherScrollable", "ourY", "hasOverflow", "refreshVirtualScrollbars", "onPartnerPresetChange", "allValues", "columns", "_timeAxisColumn", "changeColumns", "currentStore", "timeAxisColumnIndex", "timeAxisColumnConfig", "cols", "col", "verticalTimeAxisColumn", "cellCls", "isStore", "updateColumns", "was", "c", "isVerticalTimeAxisColumn", "relayAll", "onColumnsChanged", "changes", "_this$partneredWith2", "partnerColumn", "allIndex", "shouldSync", "partnerChanges", "k", "_me$verticalTimeAxisC", "_me$timeAxisColumn", "updateEventCls", "unreleasedEventSelector", "currentModel", "tavmListeners", "_mode", "_suppressFit", "currentTimeAxis", "timeAxisListeners", "applyWorkingTime", "updateForceFit", "_workingTime", "fromHour", "toHour", "fromDay", "toDay", "_me$features$columnLi", "updateStartDate", "setStartDate", "keepDuration", "ta", "calcEndDate", "_tempStartDate", "changeEndDate", "setEndDate", "calcStartDate", "_tempEndDate", "changeVisibleDate", "updateVisibleDate", "regionResize", "_eventStyle", "_eventColor", "onLocaleChange", "oldAutoAdjust", "oldRect", "_width", "onViewportResize", "isSyncingFromPartner", "eachSubGrid", "partnerSubGrid", "subGrids", "collapse", "_backgroundCanvas", "_foregroundCanvas", "_svgCanvas", "createElementNS", "setAttribute", "appendChild", "_timeAxisSubGridElement", "_this$timeAxisColumn", "refreshTotalHeight", "_rowBorderHeight", "$canvasWidth", "getForegroundDomConfigs", "onStoreDataChange", "isRepopulatingStores", "await", "whenVisible", "refreshAfterProjectRefresh", "refreshAllWhenReady", "schedulerEl", "nextSibling", "fgCanvas", "returnToTop", "reLayoutEvents", "getCellDataFromEvent", "includeSingleAxisMatch", "onCellNavigate", "_to$cell", "currentMouseDown", "runWithTransition", "hasTimeout", "waitForAnimations", "topRow", "reinitialize", "isRowNumberSelecting", "selectors", "cs", "_cs$cell", "formatDuration", "onConnectedCallback", "connected", "initialConnect", "updateRtl", "clearAll", "applyStartEndParameters", "passStartEndParameters", "startParamName", "print", "endParamName", "setVersion"]
}
