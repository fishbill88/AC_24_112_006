{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/localization/En.js", "../../../../Scheduler/lib/Scheduler/data/mixin/AttachToProjectMixin.js", "../../../../Scheduler/lib/Scheduler/data/mixin/ProjectConsumer.js", "../../../../Scheduler/lib/Scheduler/tooltip/ClockTemplate.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TaskEditStm.js", "../../../../Scheduler/lib/Scheduler/feature/base/TimeSpanMenuBase.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceConfirmationPopup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceFrequencyCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthDaysButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthsButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceStopConditionCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrencePositionsCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceEditorPanel.js", "../../../../Scheduler/lib/Scheduler/feature/EventMenu.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleMenu.js", "../../../../Scheduler/lib/Scheduler/view/mixin/RecurringEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/CurrentConfig.js", "../../../../Scheduler/lib/Scheduler/view/mixin/EventNavigation.js"],
  "sourcesContent": ["import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Grid/localization/En.js';\n\nconst locale = {\n\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n\n    Object : {\n        newEvent : 'New event'\n    },\n\n    ResourceInfoColumn : {\n        eventCountText : data => data + ' event' + (data !== 1 ? 's' : '')\n    },\n\n    Dependencies : {\n        from    : 'From',\n        to      : 'To',\n        valid   : 'Valid',\n        invalid : 'Invalid'\n    },\n\n    DependencyType : {\n        SS           : 'SS',\n        SF           : 'SF',\n        FS           : 'FS',\n        FF           : 'FF',\n        StartToStart : 'Start-to-Start',\n        StartToEnd   : 'Start-to-Finish',\n        EndToStart   : 'Finish-to-Start',\n        EndToEnd     : 'Finish-to-Finish',\n        short        : [\n            'SS',\n            'SF',\n            'FS',\n            'FF'\n        ],\n        long : [\n            'Start-to-Start',\n            'Start-to-Finish',\n            'Finish-to-Start',\n            'Finish-to-Finish'\n        ]\n    },\n\n    DependencyEdit : {\n        From              : 'From',\n        To                : 'To',\n        Type              : 'Type',\n        Lag               : 'Lag',\n        'Edit dependency' : 'Edit dependency',\n        Save              : 'Save',\n        Delete            : 'Delete',\n        Cancel            : 'Cancel',\n        StartToStart      : 'Start to Start',\n        StartToEnd        : 'Start to End',\n        EndToStart        : 'End to Start',\n        EndToEnd          : 'End to End'\n    },\n\n    EventEdit : {\n        Name         : 'Name',\n        Resource     : 'Resource',\n        Start        : 'Start',\n        End          : 'End',\n        Save         : 'Save',\n        Delete       : 'Delete',\n        Cancel       : 'Cancel',\n        'Edit event' : 'Edit event',\n        Repeat       : 'Repeat'\n    },\n\n    EventDrag : {\n        eventOverlapsExisting : 'Event overlaps existing event for this resource',\n        noDropOutsideTimeline : 'Event may not be dropped completely outside the timeline'\n    },\n\n    SchedulerBase : {\n        'Add event'      : 'Add event',\n        'Delete event'   : 'Delete event',\n        'Unassign event' : 'Unassign event'\n    },\n\n    TimeAxisHeaderMenu : {\n        pickZoomLevel   : 'Zoom',\n        activeDateRange : 'Date range',\n        startText       : 'Start date',\n        endText         : 'End date',\n        todayText       : 'Today'\n    },\n\n    EventCopyPaste : {\n        copyEvent  : 'Copy event',\n        cutEvent   : 'Cut event',\n        pasteEvent : 'Paste event'\n    },\n\n    EventFilter : {\n        filterEvents : 'Filter tasks',\n        byName       : 'By name'\n    },\n\n    TimeRanges : {\n        showCurrentTimeLine : 'Show current timeline'\n    },\n\n    PresetManager : {\n        secondAndMinute : {\n            displayDateFormat : 'll LTS',\n            name              : 'Seconds'\n        },\n        minuteAndHour : {\n            topDateFormat     : 'ddd MM/DD, hA',\n            displayDateFormat : 'll LST'\n        },\n        hourAndDay : {\n            topDateFormat     : 'ddd MM/DD',\n            middleDateFormat  : 'LST',\n            displayDateFormat : 'll LST',\n            name              : 'Day'\n        },\n        day : {\n            name : 'Day/hours'\n        },\n        week : {\n            name : 'Week/hours'\n        },\n        dayAndWeek : {\n            displayDateFormat : 'll LST',\n            name              : 'Week/days'\n        },\n        dayAndMonth : {\n            name : 'Month'\n        },\n        weekAndDay : {\n            displayDateFormat : 'll LST',\n            name              : 'Week'\n        },\n        weekAndMonth : {\n            name : 'Weeks'\n        },\n        weekAndDayLetter : {\n            name : 'Weeks/weekdays'\n        },\n        weekDateAndMonth : {\n            name : 'Months/weeks'\n        },\n        monthAndYear : {\n            name : 'Months'\n        },\n        year : {\n            name : 'Years'\n        },\n        manyYears : {\n            name : 'Multiple years'\n        }\n    },\n\n    RecurrenceConfirmationPopup : {\n        'delete-title'              : 'You are deleting an event',\n        'delete-all-message'        : 'Do you want to delete all occurrences of this event?',\n        'delete-further-message'    : 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',\n        'delete-further-btn-text'   : 'Delete All Future Events',\n        'delete-only-this-btn-text' : 'Delete Only This Event',\n        'update-title'              : 'You are changing a repeating event',\n        'update-all-message'        : 'Do you want to change all occurrences of this event?',\n        'update-further-message'    : 'Do you want to change only this occurrence of the event, or this and all future occurrences?',\n        'update-further-btn-text'   : 'All Future Events',\n        'update-only-this-btn-text' : 'Only This Event',\n        Yes                         : 'Yes',\n        Cancel                      : 'Cancel',\n        width                       : 600\n    },\n\n    RecurrenceLegend : {\n        ' and '                         : ' and ',\n        Daily                           : 'Daily',\n        'Weekly on {1}'                 : ({ days }) => `Weekly on ${days}`,\n        'Monthly on {1}'                : ({ days }) => `Monthly on ${days}`,\n        'Yearly on {1} of {2}'          : ({ days, months }) => `Yearly on ${days} of ${months}`,\n        'Every {0} days'                : ({ interval }) => `Every ${interval} days`,\n        'Every {0} weeks on {1}'        : ({ interval, days }) => `Every ${interval} weeks on ${days}`,\n        'Every {0} months on {1}'       : ({ interval, days }) => `Every ${interval} months on ${days}`,\n        'Every {0} years on {1} of {2}' : ({ interval, days, months }) => `Every ${interval} years on ${days} of ${months}`,\n        position1                       : 'the first',\n        position2                       : 'the second',\n        position3                       : 'the third',\n        position4                       : 'the fourth',\n        position5                       : 'the fifth',\n        'position-1'                    : 'the last',\n        day                             : 'day',\n        weekday                         : 'weekday',\n        'weekend day'                   : 'weekend day',\n        daysFormat                      : ({ position, days }) => `${position} ${days}`\n    },\n\n    RecurrenceEditor : {\n        'Repeat event'      : 'Repeat event',\n        Cancel              : 'Cancel',\n        Save                : 'Save',\n        Frequency           : 'Frequency',\n        Every               : 'Every',\n        DAILYintervalUnit   : 'day(s)',\n        WEEKLYintervalUnit  : 'week(s)',\n        MONTHLYintervalUnit : 'month(s)',\n        YEARLYintervalUnit  : 'year(s)',\n        Each                : 'Each',\n        'On the'            : 'On the',\n        'End repeat'        : 'End repeat',\n        'time(s)'           : 'time(s)'\n    },\n\n    RecurrenceDaysCombo : {\n        day           : 'day',\n        weekday       : 'weekday',\n        'weekend day' : 'weekend day'\n    },\n\n    RecurrencePositionsCombo : {\n        position1    : 'first',\n        position2    : 'second',\n        position3    : 'third',\n        position4    : 'fourth',\n        position5    : 'fifth',\n        'position-1' : 'last'\n    },\n\n    RecurrenceStopConditionCombo : {\n        Never     : 'Never',\n        After     : 'After',\n        'On date' : 'On date'\n    },\n\n    RecurrenceFrequencyCombo : {\n        None    : 'No repeat',\n        Daily   : 'Daily',\n        Weekly  : 'Weekly',\n        Monthly : 'Monthly',\n        Yearly  : 'Yearly'\n    },\n\n    RecurrenceCombo : {\n        None   : 'None',\n        Custom : 'Custom...'\n    },\n\n    Summary : {\n        'Summary for' : date => `Summary for ${date}`\n    },\n\n    ScheduleRangeCombo : {\n        completeview : 'Complete schedule',\n        currentview  : 'Visible schedule',\n        daterange    : 'Date range',\n        completedata : 'Complete schedule (for all events)'\n    },\n\n    SchedulerExportDialog : {\n        'Schedule range' : 'Schedule range',\n        'Export from'    : 'From',\n        'Export to'      : 'To'\n    },\n\n    ExcelExporter : {\n        'No resource assigned' : 'No resource assigned'\n    },\n\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n\n    DurationColumn : {\n        Duration : 'Duration'\n    }\n};\n\nexport default LocaleHelper.publishLocale(locale);\n", "/**\n * @module Scheduler/data/mixin/AttachToProjectMixin\n */\n\n/**\n * Mixin that calls the target class `attachToProject()` function when a new project is assigned to Scheduler/Gantt.\n *\n * @mixin\n */\nexport default Target => class AttachToProjectMixin extends Target {\n    static get $name() {\n        return 'AttachToProjectMixin';\n    }\n\n    async afterConstruct() {\n        super.afterConstruct();\n\n        const\n            me            = this,\n            projectHolder = (me.client || me.grid),\n            { project }   = projectHolder;\n\n        projectHolder.projectSubscribers.push(me);\n\n        // Attach to already existing stores\n        if (project) {\n            me.attachToProject(project);\n            me.attachToResourceStore(project.resourceStore);\n            me.attachToEventStore(project.eventStore);\n            me.attachToAssignmentStore(project.assignmentStore);\n            me.attachToDependencyStore(project.dependencyStore);\n            me.attachToCalendarManagerStore(project.calendarManagerStore);\n        }\n    }\n\n    /**\n     * Override to take action when the project instance is replaced.\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     */\n    attachToProject(project) {\n        this.detachListeners('project');\n\n        this._project = project;\n    }\n\n    /**\n     * Override to take action when the EventStore instance is replaced, either from being replaced on the project or\n     * from assigning a new project.\n     *\n     * @param {Scheduler.data.EventStore} store\n     */\n    attachToEventStore(store) {\n        this.detachListeners('eventStore');\n    }\n\n    /**\n     * Override to take action when the ResourceStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.ResourceStore} store\n     */\n    attachToResourceStore(store) {\n        this.detachListeners('resourceStore');\n    }\n\n    /**\n     * Override to take action when the AssignmentStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.AssignmentStore} store\n     */\n    attachToAssignmentStore(store) {\n        this.detachListeners('assignmentStore');\n    }\n\n    /**\n     * Override to take action when the DependencyStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.DependencyStore} store\n     */\n    attachToDependencyStore(store) {\n        this.detachListeners('dependencyStore');\n    }\n\n    // <remove-on-release>\n    // TODO: Move attachToCalendarMangerStore to Pro somehow\n    // </remove-on-release>\n\n    /**\n     * Override to take action when the CalendarManagerStore instance is replaced, either from being replaced on the\n     * project or from assigning a new project.\n     *\n     * @param {Core.data.Store} store\n     */\n    attachToCalendarManagerStore(store) {\n        this.detachListeners('calendarManagerStore');\n    }\n\n    get project() {\n        return this._project;\n    }\n\n    get calendarManagerStore() {\n        return this.project.calendarManagerStore;\n    }\n\n    get assignmentStore() {\n        return this.project.assignmentStore;\n    }\n\n    get resourceStore() {\n        return this.project.resourceStore;\n    }\n\n    get eventStore() {\n        return this.project.eventStore;\n    }\n\n    get dependencyStore() {\n        return this.project.dependencyStore;\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport ProjectModel from '../../model/ProjectModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\n\n/**\n * @module Scheduler/data/mixin/ProjectConsumer\n */\n\nconst engineStoreNames = [\n    'assignmentStore',\n    'dependencyStore',\n    'eventStore',\n    'resourceStore'\n];\n\n/**\n * Creates a Project using any configured stores, and sets the stores configured into the project into\n * the host object.\n *\n * @mixin\n */\nexport default Target => class ProjectConsumer extends (Target || Base) {\n    static get $name() {\n        return 'ProjectConsumer';\n    }\n\n    //region Default config\n\n    static get declarable() {\n        return ['projectStores'];\n    }\n\n    static get configurable() {\n        return {\n            projectModelClass : ProjectModel,\n\n            // <remove-on-release>\n            //TODO: move to SchedulerProBase and SchedulerBase to specify different types\n            // </remove-on-release>\n            /**\n             * The {@link Scheduler.model.ProjectModel} instance, containing the data visualized by the Scheduler.\n             *\n             * **Note:** In SchedulerPro the project is instance of SchedulerPro.model.ProjectModel class.\n             * @member {Scheduler.model.ProjectModel} project\n             * @typings {ProjectModel}\n             * @category Data\n             */\n            /**\n             * A {@link Scheduler.model.ProjectModel} instance or a config object. The project holds all Scheduler data.\n             * Can be omitted in favor of individual store configs or {@link Scheduler.view.mixin.SchedulerStores#config-crudManager} config.\n             *\n             * **Note:** This config is **mandatory** in SchedulerPro. See SchedulerPro.model.ProjectModel class.\n             * @config {Scheduler.model.ProjectModel|ProjectModelConfig} project\n             * @category Data\n             */\n            project : {},\n\n            /**\n             * Configure as `true` to destroy the Project and stores when `this` is destroyed.\n             * @config {Boolean}\n             * @category Data\n             */\n            destroyStores : null,\n\n            // Will be populated by AttachToProjectMixin which features mix in\n            projectSubscribers : []\n        };\n    }\n\n    #suspendedByRestore;\n\n    //endregion\n\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n\n        super.startConfigure(config);\n    }\n\n    //region Project\n\n    // This is where all the ingestion happens.\n    // At config time, the changers inject incoming values into the project config object\n    // that we are building. At the end we instantiate the project with all incoming\n    // config values filled in.\n    changeProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectStoreNames,\n                projectDataNames\n            }  = me.constructor;\n\n        me.projectCallbacks = new Set();\n\n        if (project) {\n            // Flag for changes to know what stage we are at\n            me.buildingProjectConfig = true;\n\n            if (!project.isModel) {\n                // When configuring, prio order:\n                // 1. If using an already existing CrudManager, it is assumed to already have the stores we should use,\n                //    adopt them as ours.\n                // 2. If a supplied store already has a project, it is assumed to be shared with another scheduler and\n                //    that project is adopted as ours. Unless we are given some store not part of that project,\n                //    in which case we create a new project.\n                // 3. Use stores from a supplied project config.\n                // 4. Use stores configured on scheduler.\n                // + Pass on inline data (events, resources, dependencies, assignments -> xxData on the project config)\n                //\n                // What happens during project initialization is this:\n                // this._project is the project *config* object.\n                // changeXxxx methods put incoming values directly into it through this.project\n                // to be used as its configuration.\n                // So when it is instantiated, it has had all configs injected.\n                if (me.isConfiguring) {\n                    // Set property for changers to put incoming values into\n                    me._project = project;\n\n                    // crudManager will be a clone of the raw config if it is a raw config.\n                    const { crudManager } = me;\n\n                    // Pull in stores from the crudManager config first\n                    if (crudManager) {\n                        const { isCrudManager } = crudManager;\n\n                        for (const storeName of projectStoreNames) {\n                            if (crudManager[storeName]) {\n\n                                // We configure the project with the stores, and *not* the CrudManager.\n                                // The CrudManager ends up having its project set and thereby adopting ours.\n                                me[storeName] = crudManager[storeName];\n\n                                // If it's just a config, take the stores out.\n                                // We will *configure* it with this project and it will ingest\n                                // its stores from there.\n                                if (!isCrudManager) {\n                                    delete crudManager[storeName];\n                                }\n                            }\n                        }\n                    }\n\n                    // Pull in all our configured stores into the project config object.\n                    // That also extracts any project into this._sharedProject\n                    me.getConfig('projectStores');\n\n                    // Referencing these data configs causes them to be pulled into\n                    // the _project.xxxData config property if they are present.\n                    for (const dataName of projectDataNames) {\n                        me.getConfig(dataName);\n                    }\n                }\n\n                const { eventStore } = project;\n                let { _sharedProject : sharedProject } = me;\n\n                // Delay autoLoading until listeners are set up, to be able to inject params\n                if (eventStore && !eventStore.isEventStoreMixin && eventStore.autoLoad && !eventStore.count) {\n                    eventStore.autoLoad = false;\n                    me.delayAutoLoad = true;\n                }\n\n                // We should not adopt a project from a store if we are given any store not part of that project\n                if (sharedProject && engineStoreNames.some(store => project[store] && project[store] !== sharedProject[store])) {\n                    // We have to chain any store used by the other project, they can only belong to one\n                    for (const store of engineStoreNames) {\n                        if (project[store] && project[store] === sharedProject[store]) {\n                            project[store] = project[store].chain();\n                        }\n                    }\n\n                    sharedProject = null;\n                }\n\n                // Use sharedProject if found, else instantiate our config.\n                project = sharedProject || new me.projectModelClass(project);\n\n                // Clear the property so that the updater is called.\n                delete me._project;\n            }\n\n            // In the updater, configs are live\n            me.buildingProjectConfig = false;\n        }\n\n        return project;\n    }\n\n    /**\n     * Implement in subclass to take action when project is replaced.\n     *\n     * __`super.updateProject(...arguments)` must be called first.__\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     * @category Data\n     */\n    updateProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectListeners,\n                crudManager\n            }  = me;\n\n        me.detachListeners('projectConsumer');\n\n        // When we set the crudManager now, it will go through to the CrudManagerVIew\n        delete me._crudManager;\n\n        if (project) {\n            projectListeners.thisObj = me;\n            project.ion(projectListeners);\n\n            // If the project is a CrudManager, use it as such.\n            if (project.isCrudManager) {\n                me.crudManager = project;\n            }\n            // Apply the project to CrudManager, making sure the same stores are used there and here\n            else if (crudManager) {\n                crudManager.project = project;\n\n                // CrudManager goes through the changer as usual and is initialized\n                // from the Project, not any stores it was originally configured with.\n                me.crudManager = crudManager;\n            }\n\n            // Notifies classes that mix AttachToProjectMixin that we have a new project\n            me.projectSubscribers.forEach(subscriber => subscriber.attachToProject(project));\n\n            // Sets the project's stores into the host object\n            for (const storeName of me.constructor.projectStoreNames) {\n                me[storeName] = project[storeName];\n            }\n\n            // Listeners are set up, if EventStore was configured with autoLoad now is the time to load\n            if (me.delayAutoLoad) {\n                // Restore the flag, not needed but to look good on inspection\n                project.eventStore.autoLoad = true;\n                project.eventStore.load();\n            }\n\n            project.stm?.ion({\n                name           : 'projectConsumer',\n                restoringStart : 'onProjectRestoringStart',\n                restoringStop  : 'onProjectRestoringStop',\n                thisObj        : me\n            });\n\n        }\n\n        me.trigger('projectChange', { project });\n    }\n\n    // Implementation here because we need to get first look at it to adopt its stores\n    changeCrudManager(crudManager) {\n        // Set the property to be scanned for incoming stores.\n        // If it's a config, it will be stripped of those stores prior to construction.\n        if (this.buildingProjectConfig) {\n            this._crudManager = crudManager.isCrudManager ? crudManager : Object.assign({}, crudManager);\n        }\n        else {\n            return super.changeCrudManager(crudManager);\n        }\n    }\n\n    // Called when project changes are committed, after data is written back to records\n    onProjectDataReady() {\n        const me = this;\n\n        // Only update the UI when we are visible\n        me.whenVisible(() => {\n            if (me.projectCallbacks.size) {\n                me.projectCallbacks.forEach(callback => callback());\n                me.projectCallbacks.clear();\n            }\n        }, null, null, 'onProjectDataReady');\n    }\n\n    onProjectRestoringStart({ stm }) {\n        const { rawQueue } = stm;\n        // Suspend refresh if undo/redo potentially leads to multiple refreshes\n        if (rawQueue.length && rawQueue[rawQueue.length - 1].length > 1) {\n            this.#suspendedByRestore = true;\n            this.suspendRefresh();\n        }\n    }\n\n    onProjectRestoringStop() {\n        if (this.#suspendedByRestore) {\n            this.#suspendedByRestore = false;\n            this.resumeRefresh(true);\n        }\n    }\n\n    // Overridden in CalendarStores.js\n    onBeforeTimeZoneChange() {}\n\n    // When project changes time zone, change start and end dates\n    onTimeZoneChange({ timeZone, oldTimeZone }) {\n        const me = this;\n\n        // The timeAxis timeZone could be equal to timeZone if we are a partnered scheduler\n        if (me.startDate && me.timeAxis.timeZone !== timeZone) {\n            const startDate = oldTimeZone != null ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;\n            me.startDate = timeZone != null ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;\n\n            // Saves the timeZone on the timeAxis as it is shared between partnered schedulers\n            me.timeAxis.timeZone = timeZone;\n        }\n    }\n\n    /**\n     * Accepts a callback that will be called when the underlying project is ready (no commit pending and current commit\n     * finalized)\n     * @param {Function} callback\n     * @category Data\n     */\n    whenProjectReady(callback) {\n        // Might already be ready, call directly\n        if (this.isEngineReady) {\n            callback();\n        }\n        else {\n            this.projectCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * Returns `true` if engine is in a stable calculated state, `false` otherwise.\n     * @property {Boolean}\n     * @category Misc\n     */\n    get isEngineReady() {\n        // NonWorkingTime calls this during destruction, hence the ?.\n        return Boolean(this.project.isEngineReady?.());\n    }\n\n    //endregion\n\n    //region Destroy\n\n    // Cleanup, destroys stores if this.destroyStores is true.\n    doDestroy() {\n        super.doDestroy();\n\n        if (this.destroyStores) {\n            // Shared project might already be destroyed\n            !this.project.isDestroyed && this.project.destroy();\n        }\n    }\n\n    //endregion\n\n    get projectStores() {\n        const { projectStoreNames } = this.constructor;\n\n        return projectStoreNames.map(storeName => this[storeName]);\n    }\n\n    static get projectStoreNames() {\n        return Object.keys(this.projectStores);\n    }\n\n    static get projectDataNames() {\n        return this.projectStoreNames.reduce((result, storeName) => {\n            const { dataName } = this.projectStores[storeName];\n\n            if (dataName) {\n                result.push(dataName);\n            }\n            return result;\n        }, []);\n    }\n\n    static setupProjectStores(cls, meta) {\n        const { projectStores } = cls;\n\n        if (projectStores) {\n            const\n                projectListeners  = {\n                    name                 : 'projectConsumer',\n                    dataReady            : 'onProjectDataReady',\n                    change               : 'relayProjectDataChange',\n                    beforeTimeZoneChange : 'onBeforeTimeZoneChange',\n                    timeZoneChange       : 'onTimeZoneChange'\n                },\n                storeConfigs      = {\n                    projectListeners\n                };\n\n            let previousDataName;\n\n            // Create a property and updater for each dataName and a changer for each store\n            for (const storeName in projectStores) {\n                const { dataName } = projectStores[storeName];\n\n                // Define \"eventStore\" and \"events\" configs\n                storeConfigs[storeName] = storeConfigs[dataName] = null;\n\n                // Define up the \"events\" property\n                if (dataName) {\n                    // Getter to return store data\n                    Object.defineProperty(meta.class.prototype, dataName, {\n                        configurable : true, // So that Config can add its setter.\n                        get() {\n                            // get events() { return this.project.eventStore.records; }\n                            return this.project[storeName]?.records;\n                        }\n                    });\n\n                    // Create an updater for the data name;\n                    this.createDataUpdater(storeName, dataName, previousDataName, meta);\n                }\n\n                this.createStoreDescriptor(meta, storeName, projectStores[storeName], projectListeners);\n\n                // The next data updater must reference this data name\n                previousDataName = dataName;\n            }\n\n            // Create the projectListeners config.\n            this.setupConfigs(meta, storeConfigs);\n        }\n    }\n\n    static createDataUpdater(storeName, dataName, previousDataName, meta) {\n        // Create eg \"updateEvents(data)\".\n        // We need it to call this.getConfig('resources') so that ordering of\n        // data ingestion is corrected.\n        meta.class.prototype[`update${StringHelper.capitalize(dataName)}`] = function(data) {\n            const { project } = this;\n\n            // Ensure a dataName that we depend on is called in.\n            // For example dependencies must load in order after the events.\n            previousDataName && this.getConfig(previousDataName);\n\n            if (this.buildingProjectConfig) {\n                // Set the property in the project config object.\n                // eg project.eventsData = [...]\n                project[`${dataName}Data`] = data;\n            }\n            else {\n                // Live update the project when in use.\n                project[storeName].data = data;\n            }\n        };\n    }\n\n    // eslint-disable-next-line bryntum/no-listeners-in-lib\n    static createStoreDescriptor(meta, storeName, { listeners }, projectListeners) {\n        const\n            { prototype : clsProto } = meta.class,\n            storeNameCap             = StringHelper.capitalize(storeName);\n\n        // Set up onProjectEventStoreChange to set this.eventStore\n        projectListeners[`${storeName}Change`] = function({ store }) {\n            this[storeName] = store;\n        };\n\n        // create changeEventStore\n        clsProto[`change${storeNameCap}`] = function(store, oldStore) {\n            const\n                me           = this,\n                { project }  = me,\n                storeProject = store?.project;\n\n            if (me.buildingProjectConfig) {\n                // Capture any project found at project config time\n                // to use as our shared project\n                if (storeProject?.isProjectModel) {\n                    me._sharedProject = storeProject;\n                }\n\n                // Set the property in the project config object.\n                // Must not go through the updater. It's too early to\n                // inform host of store change.\n                project[storeName] = store;\n                return;\n            }\n\n            // Live update the project when in use.\n            if (!me.initializingProject) {\n                if (project[storeName] !== store) {\n                    project[`set${storeNameCap}`](store);\n                    store = project[storeName];\n                }\n            }\n\n            // Implement processing here instead of creating a separate updater.\n            // Subclasses can implement updaters.\n            if (store !== oldStore) {\n                if (listeners) {\n                    listeners.thisObj = me;\n                    listeners.name = `${storeName}Listeners`;\n\n                    me.detachListeners(listeners.name);\n\n                    store.ion(listeners);\n                }\n\n                // Set backing var temporarily, so it can be accessed from AttachToProjectMixin subscribers\n                me[`_${storeName}`] = store;\n\n                // Notifies classes that mix AttachToProjectMixin that we have a new XxxxxStore\n                me.projectSubscribers.forEach(subscriber => {\n                    subscriber[`attachTo${storeNameCap}`]?.(store);\n                });\n\n                me[`_${storeName}`] = null;\n            }\n            return store;\n        };\n    }\n\n    relayProjectDataChange(event) {\n        // Don't trigger change event for tree node collapse/expand\n        if ((event.isExpand || event.isCollapse) && !event.records[0].fieldMap.expanded.persist) {\n            return;\n        }\n\n        /**\n         * Fired when data in any of the projects stores changes.\n         *\n         * Basically a relayed version of each store's own change event, decorated with which store it originates from.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event dataChange\n         * @param {Scheduler.data.mixin.ProjectConsumer} source Owning component\n         * @param {Scheduler.model.mixin.ProjectModelMixin} project Project model\n         * @param {Core.data.Store} store Affected store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        return this.trigger('dataChange', { project : event.source, ...event, source : this });\n    }\n\n    //region WidgetClass\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n    //endregion\n};\n", "import Base from '../../Core/Base.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\n\n/**\n * @module Scheduler/tooltip/ClockTemplate\n */\n\n/**\n * A template showing a clock, it consumes an object containing a date and a text\n * @private\n */\nexport default class ClockTemplate extends Base {\n    static get defaultConfig() {\n        return {\n            minuteHeight : 8,\n            minuteTop    : 2,\n            hourHeight   : 8,\n            hourTop      : 2,\n            handLeft     : 10,\n            div          : document.createElement('div'),\n            scheduler    : null, // may be passed to the constructor if needed\n            // `b-sch-clock-day` for calendar icon\n            // `b-sch-clock-hour` for clock icon\n            template(data) {\n                return `<div class=\"b-sch-clockwrap b-sch-clock-${data.mode || this.mode} ${data.cls || ''}\">\n                    <div class=\"b-sch-clock\">\n                        <div class=\"b-sch-hour-indicator\">${DateHelper.format(data.date, 'MMM')}</div>\n                        <div class=\"b-sch-minute-indicator\">${DateHelper.format(data.date, 'D')}</div>\n                        <div class=\"b-sch-clock-dot\"></div>\n                    </div>\n                    <span class=\"b-sch-clock-text\">${StringHelper.encodeHtml(data.text)}</span>\n                </div>`;\n            }\n        };\n    }\n\n    generateContent(data) {\n        return this.div.innerHTML = this.template(data);\n    }\n\n    updateDateIndicator(el, date) {\n        const\n            hourIndicatorEl   = el?.querySelector('.b-sch-hour-indicator'),\n            minuteIndicatorEl = el?.querySelector('.b-sch-minute-indicator');\n\n        if (date && hourIndicatorEl && minuteIndicatorEl && BrowserHelper.isBrowserEnv) {\n            if (this.mode === 'hour') {\n                hourIndicatorEl.style.transform   = `rotate(${(date.getHours() % 12) * 30}deg)`;\n                minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;\n            }\n            else {\n                hourIndicatorEl.style.transform   = 'none';\n                minuteIndicatorEl.style.transform = 'none';\n            }\n        }\n    }\n\n    set mode(mode) {\n        this._mode = mode;\n    }\n\n    // `day` mode for calendar icon\n    // `hour` mode for clock icon\n    get mode() {\n        if (this._mode) {\n            return this._mode;\n        }\n\n        //<debug>\n        if (!this.scheduler) {\n            throw new Error('`scheduler` config has to be specified for the clock template');\n        }\n        //</debug>\n\n        const\n            unitLessThanDay        = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, 'day') < 0,\n            formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);\n\n        return unitLessThanDay && formatContainsHourInfo ? 'hour' : 'day';\n    }\n\n    set template(template) {\n        this._template = template;\n    }\n\n    /**\n     * Get the clock template, which accepts an object of format { date, text }\n     * @property {function(*): string}\n     */\n    get template() {\n        return this._template;\n    }\n}\n", "import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/feature/mixin/TaskEditStm\n */\n\n/**\n * Mixin adding STM transactable behavior to TaskEdit feature.\n *\n * @mixin\n */\nexport default Target => class TaskEditStm extends (Target || Base) {\n    static get $name() {\n        return 'TaskEditStm';\n    }\n\n    captureStm(startTransaction = false) {\n        const\n            me      = this,\n            project = me.project,\n            stm     = project.getStm();\n\n        if (me.hasStmCapture) {\n            return;\n        }\n\n        me.hasStmCapture = true;\n        me.stmInitiallyDisabled = stm.disabled;\n        me.stmInitiallyAutoRecord = stm.autoRecord;\n\n        if (me.stmInitiallyDisabled) {\n            stm.enable();\n            // it seems this branch has never been exercised by tests\n            // but the intention is to stop the auto-recording while\n            // task editor is active (all editing is one manual transaction)\n            stm.autoRecord = false;\n        }\n        else {\n            if (me.stmInitiallyAutoRecord) {\n                stm.autoRecord = false;\n            }\n            if (stm.isRecording) {\n                stm.stopTransaction();\n            }\n        }\n\n        if (startTransaction) {\n            this.startStmTransaction();\n        }\n    }\n\n    startStmTransaction() {\n        this.project.getStm().startTransaction();\n    }\n\n    commitStmTransaction() {\n        const\n            me  = this,\n            stm = me.project.getStm();\n\n        if (!me.hasStmCapture) {\n            throw new Error('Does not have STM capture, no transaction to commit');\n        }\n\n        if (stm.enabled) {\n            stm.stopTransaction();\n\n            if (me.stmInitiallyDisabled) {\n                stm.resetQueue();\n            }\n        }\n    }\n\n    async rejectStmTransaction() {\n        const\n            stm        = this.project.getStm(),\n            { client } = this;\n\n        if (!this.hasStmCapture) {\n            throw new Error('Does not have STM capture, no transaction to reject');\n        }\n\n        if (stm.enabled) {\n            if (stm.transaction?.length) {\n                client.suspendRefresh();\n\n                stm.rejectTransaction();\n\n                await client.resumeRefresh(true);\n            }\n            else {\n                stm.stopTransaction();\n            }\n        }\n    }\n\n    enableStm() {\n        this.project.getStm().enable();\n    }\n\n    disableStm() {\n        this.project.getStm().disable();\n    }\n\n    freeStm(commitOrReject = null) {\n        if (commitOrReject === true) {\n            this.commitStmTransaction();\n        }\n        else if (commitOrReject === false) {\n            // Note - we don't wait for async to complete here\n            this.rejectStmTransaction();\n        }\n\n        const\n            me  = this,\n            stm = me.project.getStm();\n\n        if (!me.hasStmCapture) {\n            return;\n        }\n\n        stm.disabled = me.stmInitiallyDisabled;\n        stm.autoRecord = me.stmInitiallyAutoRecord;\n        me.hasStmCapture = false;\n    };\n};\n", "import ContextMenuBase from '../../../Core/feature/base/ContextMenuBase.js';\n\n/**\n * @module Scheduler/feature/base/TimeSpanMenuBase\n */\n\n/**\n * Abstract base class used by other context menu features which show the context menu for TimeAxis.\n * Using this class you can make sure the menu expects the target to disappear,\n * since it can be scroll out of the scheduling zone.\n *\n * Features that extend this class are:\n *  * {@link Scheduler/feature/EventMenu};\n *  * {@link Scheduler/feature/ScheduleMenu};\n *  * {@link Scheduler/feature/TimeAxisHeaderMenu};\n *\n * @extends Core/feature/base/ContextMenuBase\n * @abstract\n */\nexport default class TimeSpanMenuBase extends ContextMenuBase {\n}\n", "import Popup from '../../../Core/widget/Popup.js';\n\n/**\n * @module Scheduler/view/recurrence/RecurrenceConfirmationPopup\n */\n\n/**\n * A confirmation dialog shown when modifying a recurring event or some of its occurrences.\n * For recurring events, the dialog informs the user that the change will be applied to all occurrences.\n *\n * For occurrences, the dialog lets the user choose if the change should affect all future occurrences,\n * or this occurrence only.\n *\n * Usage example:\n *\n * ```javascript\n * const confirmation = new RecurrenceConfirmationPopup();\n *\n * confirmation.confirm({\n *     eventRecord : recurringEvent,\n *     actionType  : \"delete\",\n *     changerFn   : () => recurringEvent.remove(event)\n * });\n * ```\n *\n * @classType recurrenceconfirmation\n * @extends Core/widget/Popup\n */\nexport default class RecurrenceConfirmationPopup extends Popup {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{delete-further-message}',\n        'L{update-further-message}',\n        'L{delete-all-message}',\n        'L{update-all-message}',\n        'L{delete-further-btn-text}',\n        'L{update-further-btn-text}',\n        'L{delete-only-this-btn-text}',\n        'L{update-only-this-btn-text}',\n        'L{delete-title}',\n        'L{update-title}'\n    ];\n    // endregion\n    // </debug>\n\n    static get $name() {\n        return 'RecurrenceConfirmationPopup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrenceconfirmation';\n    }\n\n    static get defaultConfig() {\n        return {\n            localizableProperties : [],\n            align                 : 'b-t',\n            autoShow              : false,\n            autoClose             : false,\n            closeAction           : 'onRecurrenceClose',\n            modal                 : true,\n            centered              : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            draggable             : true,\n            closable              : true,\n            floating              : true,\n            eventRecord           : null,\n            cls                   : 'b-sch-recurrenceconfirmation',\n            bbar                  : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    changeSingleButton : {\n                        weight  : 100,\n                        cls     : 'b-raised',\n                        color   : 'b-blue',\n                        text    : 'L{update-only-this-btn-text}',\n                        onClick : 'up.onChangeSingleButtonClick'\n                    },\n                    changeMultipleButton : {\n                        weight  : 200,\n                        color   : 'b-green',\n                        text    : 'L{Object.Yes}',\n                        onClick : 'up.onChangeMultipleButtonClick'\n                    },\n                    cancelButton : {\n                        weight  : 300,\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelButtonClick'\n                    }\n                }\n            }\n        };\n    }\n\n    /**\n     * Reference to the \"Apply changes to multiple occurrences\" button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeMultipleButton() {\n        return this.widgetMap.changeMultipleButton;\n    }\n\n    /**\n     * Reference to the button that causes changing of the event itself only, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeSingleButton() {\n        return this.widgetMap.changeSingleButton;\n    }\n\n    /**\n     * Reference to the cancel button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get cancelButton() {\n        return this.widgetMap.cancelButton;\n    }\n\n    /**\n     * Handler for \"Apply changes to multiple occurrences\" {@link #property-changeMultipleButton button}.\n     * It calls {@link #function-processMultipleRecords} and then hides the dialog.\n     */\n    onChangeMultipleButtonClick() {\n        this.processMultipleRecords();\n        this.hide();\n    }\n\n    /**\n     * Handler for the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     * It calls {@link #function-processSingleRecord} and then hides the dialog.\n     */\n    onChangeSingleButtonClick() {\n        this.processSingleRecord();\n        this.hide();\n    }\n\n    /**\n     * Handler for {@link #property-cancelButton cancel button}.\n     * It calls `cancelFn` provided to {@link #function-confirm} call and then hides the dialog.\n     */\n    onCancelButtonClick() {\n        this.cancelFn && this.cancelFn.call(this.thisObj);\n        this.hide();\n    }\n\n    onRecurrenceClose() {\n        if (this.cancelFn) {\n            this.cancelFn.call(this.thisObj);\n        }\n        this.hide();\n    }\n\n    /**\n     * Displays the confirmation.\n     * Usage example:\n     *\n     * ```javascript\n     * const popup = new RecurrenceConfirmationPopup();\n     *\n     * popup.confirm({\n     *     eventRecord,\n     *     actionType : \"delete\",\n     *     changerFn  : () => eventStore.remove(record)\n     * });\n     * ```\n     *\n     * @param {Object} config The following config options are supported:\n     * @param {Scheduler.model.EventModel} config.eventRecord   Event being modified.\n     * @param {'update'|'delete'} config.actionType Type of modification to be applied to the event. Can be\n     * either \"update\" or \"delete\".\n     * @param {Function} config.changerFn A function that should be called to apply the change to the event upon user\n     * choice.\n     * @param {Function} [config.thisObj] `changerFn` and `cancelFn` functions scope.\n     * @param {Function} [config.cancelFn] Function called on `Cancel` button click.\n     */\n    confirm(config = {}) {\n        const me = this;\n\n        //<debug>\n        if (!config || !config.actionType || !config.eventRecord) {\n            throw new Error('actionType and eventRecord must be specified for Scheduler.view.recurrence.RecurrenceConfirmationPopup');\n        }\n        //</debug>\n\n        [\n            'actionType',\n            'eventRecord',\n            'title',\n            'html',\n            'changerFn',\n            'cancelFn',\n            'finalizerFn',\n            'thisObj'\n        ].forEach(prop => {\n            if (prop in config) me[prop] = config[prop];\n        });\n\n        me.updatePopupContent();\n\n        return super.show(config);\n    }\n\n    updatePopupContent() {\n        const\n            me                                                         = this,\n            { changeMultipleButton, changeSingleButton, cancelButton } = me.widgetMap,\n            { eventRecord, actionType = 'update' }                     = me,\n            isMaster                                                   = eventRecord?.isRecurring;\n\n        if (isMaster) {\n            changeMultipleButton.text = me.L('L{Object.Yes}');\n            me.html = me.L(`${actionType}-all-message`);\n        }\n        else {\n            changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);\n            me.html = me.L(`${actionType}-further-message`);\n        }\n\n        changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);\n        cancelButton.text = me.L('L{Object.Cancel}');\n\n        me.width = me.L('L{width}');\n\n        me.title = me.L(`${actionType}-title`);\n    }\n\n    /**\n     * Applies changes to multiple occurrences as reaction on \"Apply changes to multiple occurrences\"\n     * {@link #property-changeMultipleButton button} click.\n     */\n    processMultipleRecords() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n\n        eventRecord.beginBatch();\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n\n        // afterChange will promote it to being an new recurring base because there's still recurrence\n        eventRecord.endBatch();\n\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n\n    /**\n     * Applies changes to a single record by making it a \"real\" event and adding an exception to the recurrence.\n     * The method is called as reaction on clicking the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     */\n    processSingleRecord() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n\n        eventRecord.beginBatch();\n\n        let firstOccurrence;\n\n        // If that's a master event get its very first occurrence\n        if (eventRecord?.isRecurring) {\n            eventRecord.recurrence.forEachOccurrence(eventRecord.startDate, null, (occurrence, isFirst, index) => {\n                // index 1 is used by to the event itself, > 1 since there might be exceptions\n                if (index > 1) {\n                    firstOccurrence = occurrence;\n                    return false;\n                }\n            });\n        }\n\n        // turn the 1st occurrence into a new \"master\" event\n        firstOccurrence?.convertToRealEvent();\n\n        // When the changes apply, because there's no recurrence, it will become an exception\n        eventRecord.recurrence = null;\n\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n\n        // Must also change after the callback in case the callback sets the rule.\n        // This will update the batch update data block to prevent it being set back to recurring.\n        eventRecord.recurrenceRule = null;\n\n        // afterChange will promote it to being an exception because there's no recurrence\n        eventRecord.endBatch();\n\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n\n    updateLocalization() {\n        this.updatePopupContent();\n        super.updateLocalization();\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrenceConfirmationPopup.initClass();\n", "import Combo from '../../../../Core/widget/Combo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceFrequencyCombo\n */\n\n/**\n * A combobox field allowing to pick frequency in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencefrequencycombo\n */\nexport default class RecurrenceFrequencyCombo extends Combo {\n\n    static $name = 'RecurrenceFrequencyCombo';\n\n    // Factoryable type name\n    static type = 'recurrencefrequencycombo';\n\n    static configurable = {\n        editable              : false,\n        displayField          : 'text',\n        valueField            : 'value',\n        localizeDisplayFields : true,\n        addNone               : false\n    };\n\n    buildItems() {\n        return [\n            ...(this.addNone ? [{ text : 'L{None}', value : 'NONE' }] : []),\n            { value : 'DAILY',   text : 'L{Daily}' },\n            { value : 'WEEKLY',  text : 'L{Weekly}' },\n            { value : 'MONTHLY', text : 'L{Monthly}' },\n            { value : 'YEARLY',  text : 'L{Yearly}' }\n        ];\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceFrequencyCombo.initClass();\n", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysCombo\n */\n\n/**\n * A combobox field allowing to pick days for the `Monthly` and `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencedayscombo\n */\nexport default class RecurrenceDaysCombo extends Combo {\n\n    static get $name() {\n        return 'RecurrenceDaysCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedayscombo';\n    }\n\n    static get defaultConfig() {\n        const\n            allDaysValueAsArray = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'],\n            allDaysValue        = allDaysValueAsArray.join(',');\n\n        return {\n            allDaysValue,\n            editable            : false,\n            defaultValue        : allDaysValue,\n            workingDaysValue    : allDaysValueAsArray.filter((day, index) => !DateHelper.nonWorkingDays[index]).join(','),\n            nonWorkingDaysValue : allDaysValueAsArray.filter((day, index) => DateHelper.nonWorkingDays[index]).join(','),\n            splitCls            : 'b-recurrencedays-split',\n            displayField        : 'text',\n            valueField          : 'value'\n        };\n    }\n\n    buildItems() {\n        const me = this;\n\n        me._weekDays = null;\n\n        return me.weekDays.concat([\n            { value : me.allDaysValue,        text : me.L('L{day}'), cls : me.splitCls },\n            { value : me.workingDaysValue,    text : me.L('L{weekday}') },\n            { value : me.nonWorkingDaysValue, text : me.L('L{weekend day}') }\n        ]);\n    }\n\n    get weekDays() {\n        const me = this;\n\n        if (!me._weekDays) {\n            const weekStartDay = DateHelper.weekStartDay;\n\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({ text, value : RecurrenceDayRuleEncoder.encodeDay(index) }));\n\n            // we should start week w/ weekStartDay\n            me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n\n        return me._weekDays;\n    }\n\n    set value(value) {\n        const me = this;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n\n        super.value = value;\n    }\n\n    get value() {\n        let value = super.value;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        return value;\n    }\n}\n\n// Register this widget type with its Factory\nRecurrenceDaysCombo.initClass();\n", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup\n */\n\n/**\n * A segmented button field allowing to pick days for the \"Weekly\" mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * {@inlineexample Scheduler/view/RecurrenceDaysButtonGroup.js}\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceDaysButtonGroup extends ButtonGroup {\n\n    static get $name() {\n        return 'RecurrenceDaysButtonGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedaysbuttongroup';\n    }\n\n    static get defaultConfig() {\n        return {\n            defaults : {\n                cls        : 'b-raised',\n                toggleable : true\n            }\n        };\n    }\n\n    construct(config = {}) {\n        const me = this;\n\n        config.columns = 7;\n        config.items   = me.buildItems();\n\n        super.construct(config);\n    }\n\n    updateItemText(item) {\n        const day = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];\n\n        item.text = DateHelper.getDayName(day).substring(0, 3);\n    }\n\n    buildItems() {\n        const me = this;\n\n        if (!me.__items) {\n            const weekStartDay = DateHelper.weekStartDay;\n\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({\n                text  : text.substring(0, 3),\n                value : RecurrenceDayRuleEncoder.encodeDay(index)\n            }));\n\n            // we should start week w/ weekStartDay\n            me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n\n        return me.__items;\n    }\n\n    set value(value) {\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        super.value = value;\n    }\n\n    get value() {\n        let value = super.value;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        return value;\n    }\n\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceDaysButtonGroup.initClass();\n", "import ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n\n/**\n * A segmented button field allowing to pick month days for the `Monthly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthDaysButtonGroup extends ButtonGroup {\n\n    static get $name() {\n        return 'RecurrenceMonthDaysButtonGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthdaysbuttongroup';\n    }\n\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n\n    get minValue() {\n        return 1;\n    }\n\n    get maxValue() {\n        return 31;\n    }\n\n    construct(config = {}) {\n        const me = this;\n\n        config.columns = 7;\n        config.items   = me.buildItems();\n\n        super.construct(config);\n    }\n\n    buildItems() {\n        const\n            me    = this,\n            items = [];\n\n        for (let value = me.minValue; value <= me.maxValue; value++) {\n            // button config\n            items.push({\n                text : value + '',\n                value\n            });\n        }\n\n        return items;\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrenceMonthDaysButtonGroup.initClass();\n", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n\n/**\n * A segmented button field allowing to pick months for the `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthsButtonGroup extends ButtonGroup {\n\n    static get $name() {\n        return 'RecurrenceMonthsButtonGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthsbuttongroup';\n    }\n\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n\n    construct(config = {}) {\n        const me = this;\n\n        config.columns = 4;\n        config.items   = me.buildItems();\n\n        super.construct(config);\n    }\n\n    buildItems() {\n        return DateHelper.getMonthNames().map((item, index) => ({\n            text  : item.substring(0, 3),\n            value : index + 1 // 1-based\n        }));\n    }\n\n    updateItemText(item) {\n        item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);\n    }\n\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrenceMonthsButtonGroup.initClass();\n", "import Combo from '../../../../Core/widget/Combo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceStopConditionCombo\n */\n\n/**\n * A combobox field allowing to choose stop condition for the recurrence in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencestopconditioncombo\n */\nexport default class RecurrenceStopConditionCombo extends Combo {\n\n    static get $name() {\n        return 'RecurrenceStopConditionCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencestopconditioncombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            placeholder  : 'Never',\n            displayField : 'text',\n            valueField   : 'value'\n        };\n    }\n\n    buildItems() {\n        return [\n            { value : 'never', text : this.L('L{Never}') },\n            { value : 'count', text : this.L('L{After}') },\n            { value : 'date',  text : this.L('L{On date}') }\n        ];\n    }\n\n    set value(value) {\n        // Use 'never' instead of falsy value\n        value = value || 'never';\n\n        super.value = value;\n    }\n\n    get value() {\n        return super.value;\n    }\n\n    get recurrence() {\n        return this._recurrence;\n    }\n\n    set recurrence(recurrence) {\n        let value = null;\n\n        if (recurrence.endDate) {\n            value = 'date';\n        }\n        else if (recurrence.count) {\n            value = 'count';\n        }\n\n        this._recurrence = recurrence;\n\n        this.value = value;\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceStopConditionCombo.initClass();\n", "import ArrayHelper from '../../../../Core/helper/ArrayHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrencePositionsCombo\n */\n\n/**\n * A combobox field allowing to specify day positions in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence editor}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencepositionscombo\n */\nexport default class RecurrencePositionsCombo extends Combo {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{position1}',\n        'L{position2}',\n        'L{position3}',\n        'L{position4}',\n        'L{position5}'\n    ];\n    // endregion\n    // </debug>\n\n    static get $name() {\n        return 'RecurrencePositionsCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencepositionscombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            splitCls     : 'b-sch-recurrencepositions-split',\n            displayField : 'text',\n            valueField   : 'value',\n            defaultValue : 1,\n            maxPosition  : 5\n        };\n    }\n\n    buildItems() {\n        return this.buildDayNumbers().concat([\n            { value : '-1', text : this.L('L{position-1}'), cls : this.splitCls }\n        ]);\n    }\n\n    buildDayNumbers() {\n        return ArrayHelper.populate(this.maxPosition, i => (\n            { value : i + 1, text : this.L(`position${i + 1}`) }\n        ));\n    }\n\n    set value(value) {\n        const me = this;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n\n        super.value = value;\n    }\n\n    get value() {\n        const value = super.value;\n\n        return value ? `${value}`.split(',').map(item => parseInt(item, 10)) : [];\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrencePositionsCombo.initClass();\n", "import RecurrenceDayRuleEncoder from '../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\nimport Panel from '../../../Core/widget/Panel.js';\nimport '../../../Core/widget/Widget.js';\nimport '../../../Core/widget/Button.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../../../Core/widget/DateField.js';\nimport '../../../Core/widget/NumberField.js';\nimport './field/RecurrenceFrequencyCombo.js';\nimport './field/RecurrenceDaysCombo.js';\nimport './field/RecurrenceDaysButtonGroup.js';\nimport './field/RecurrenceMonthDaysButtonGroup.js';\nimport './field/RecurrenceMonthsButtonGroup.js';\nimport './field/RecurrenceStopConditionCombo.js';\nimport './field/RecurrencePositionsCombo.js';\n\n/**\n * @module Scheduler/view/recurrence/RecurrenceEditorPanel\n */\n\n/**\n * Panel containing fields used to edit a {@link Scheduler.model.RecurrenceModel recurrence model}. Used by\n * {@link Scheduler/view/recurrence/RecurrenceEditor}, and by the recurrence tab in Scheduler Pro's event editor.\n *\n * Not intended to be used separately.\n *\n * @extends Core/widget/Panel\n * @classType recurrenceeditorpanel\n * @private\n */\nexport default class RecurrenceEditorPanel extends Panel {\n\n    static $name = 'RecurrenceEditorPanel';\n\n    static type = 'recurrenceeditorpanel';\n\n    static configurable = {\n        cls     : 'b-recurrenceeditor',\n        record  : false,\n        addNone : false,\n        items   : {\n            frequencyField : {\n                type     : 'recurrencefrequencycombo',\n                name     : 'frequency',\n                label    : 'L{RecurrenceEditor.Frequency}',\n                weight   : 10,\n                onChange : 'up.onFrequencyFieldChange',\n                addNone  : 'up.addNone'\n            },\n            intervalField : {\n                type     : 'numberfield',\n                weight   : 15,\n                name     : 'interval',\n                label    : 'L{RecurrenceEditor.Every}',\n                min      : 1,\n                required : true\n            },\n            daysButtonField : {\n                type         : 'recurrencedaysbuttongroup',\n                weight       : 20,\n                name         : 'days',\n                forFrequency : 'WEEKLY'\n            },\n            // the radio button enabling \"monthDaysButtonField\" in MONTHLY mode\n            monthDaysRadioField : {\n                type         : 'checkbox',\n                weight       : 30,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY',\n                label        : 'L{RecurrenceEditor.Each}',\n                checked      : true,\n                onChange     : 'up.onMonthDaysRadioFieldChange'\n            },\n            monthDaysButtonField : {\n                type         : 'recurrencemonthdaysbuttongroup',\n                weight       : 40,\n                name         : 'monthDays',\n                forFrequency : 'MONTHLY'\n            },\n            monthsButtonField : {\n                type         : 'recurrencemonthsbuttongroup',\n                weight       : 50,\n                name         : 'months',\n                forFrequency : 'YEARLY'\n            },\n            // the radio button enabling positions & days combos in MONTHLY & YEARLY modes\n            positionAndDayRadioField : {\n                type         : 'checkbox',\n                weight       : 60,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY|YEARLY',\n                label        : 'L{RecurrenceEditor.On the}',\n                onChange     : 'up.onPositionAndDayRadioFieldChange'\n            },\n            positionsCombo : {\n                type         : 'recurrencepositionscombo',\n                weight       : 80,\n                name         : 'positions',\n                forFrequency : 'MONTHLY|YEARLY'\n            },\n            daysCombo : {\n                type         : 'recurrencedayscombo',\n                weight       : 90,\n                name         : 'days',\n                forFrequency : 'MONTHLY|YEARLY',\n                flex         : 1\n            },\n            stopRecurrenceField : {\n                type     : 'recurrencestopconditioncombo',\n                weight   : 100,\n                label    : 'L{RecurrenceEditor.End repeat}',\n                onChange : 'up.onStopRecurrenceFieldChange'\n            },\n            countField : {\n                type     : 'numberfield',\n                weight   : 110,\n                name     : 'count',\n                min      : 2,\n                required : true,\n                disabled : true,\n                label    : ' '\n            },\n            endDateField : {\n                type     : 'datefield',\n                weight   : 120,\n                name     : 'endDate',\n                hidden   : true,\n                disabled : true,\n                label    : ' ',\n                required : true\n            }\n        }\n    };\n\n    updateRecord(record) {\n        super.updateRecord(record);\n\n        const\n            me = this,\n            {\n                frequencyField,\n                daysButtonField,\n                monthDaysButtonField,\n                monthsButtonField,\n                monthDaysRadioField,\n                positionAndDayRadioField,\n                stopRecurrenceField\n            }  = me.widgetMap;\n\n        if (record) {\n            const\n                event     = record.timeSpan,\n                startDate = event?.startDate;\n\n            // some fields default values are calculated based on event \"startDate\" value\n            if (startDate) {\n                // if no \"days\" value provided\n                if (!record.days || !record.days.length) {\n                    daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];\n                }\n\n                // if no \"monthDays\" value provided\n                if (!record.monthDays || !record.monthDays.length) {\n                    monthDaysButtonField.value = startDate.getDate();\n                }\n\n                // if no \"months\" value provided\n                if (!record.months || !record.months.length) {\n                    monthsButtonField.value = startDate.getMonth() + 1;\n                }\n            }\n\n            // if the record has both \"days\" & \"positions\" fields set check \"On the\" checkbox\n            if (record.days && record.positions) {\n                positionAndDayRadioField.check();\n                // <remove-on-release>\n                // TODO: if toggleGroup members are not painted automatic unchecking doesn't work\n                // </remove-on-release>\n                if (!me.isPainted) {\n                    monthDaysRadioField.uncheck();\n                }\n            }\n            else {\n                monthDaysRadioField.check();\n                // <remove-on-release>\n                // TODO: if toggleGroup members are not painted automatic unchecking doesn't work\n                // </remove-on-release>\n                if (!me.isPainted) {\n                    positionAndDayRadioField.uncheck();\n                }\n            }\n\n            stopRecurrenceField.recurrence = record;\n        }\n        else {\n            frequencyField.value = 'NONE';\n        }\n    }\n\n    /**\n     * Updates the provided recurrence model with the contained form data.\n     * If recurrence model is not provided updates the last loaded recurrence model.\n     * @internal\n     */\n    syncEventRecord(recurrence) {\n        // get values relevant to the RecurrenceModel (from enabled fields only)\n        const values = this.getValues((w) => w.name in recurrence && !w.disabled);\n\n        // Disabled field does not contribute to values, clear manually\n        if (!('endDate' in values)) {\n            values.endDate = null;\n        }\n        if (!('count' in values)) {\n            values.count = null;\n        }\n\n        recurrence.set(values);\n    }\n\n    toggleStopFields() {\n        const\n            me                           = this,\n            { countField, endDateField } = me.widgetMap;\n\n        switch (me.widgetMap.stopRecurrenceField.value) {\n\n            case 'count' :\n                countField.show();\n                countField.enable();\n                endDateField.hide();\n                endDateField.disable();\n                break;\n\n            case 'date' :\n                countField.hide();\n                countField.disable();\n                endDateField.show();\n                endDateField.enable();\n                break;\n\n            default :\n                countField.hide();\n                endDateField.hide();\n                countField.disable();\n                endDateField.disable();\n        }\n    }\n\n    onMonthDaysRadioFieldChange({ checked }) {\n        const { monthDaysButtonField } = this.widgetMap;\n\n        monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);\n    }\n\n    onPositionAndDayRadioFieldChange({ checked }) {\n        const { daysCombo, positionsCombo } = this.widgetMap;\n\n        // toggle day & positions combos\n        daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);\n    }\n\n    onStopRecurrenceFieldChange() {\n        this.toggleStopFields();\n    }\n\n    isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {\n        return !widget.forFrequency || widget.forFrequency.includes(frequency);\n    }\n\n    onFrequencyFieldChange({ value, oldValue, valid }) {\n        const\n            me    = this,\n            items = me.queryAll(w => 'forFrequency' in w),\n            {\n                intervalField,\n                stopRecurrenceField\n            }     = me.widgetMap;\n\n        if (valid && value) {\n            for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n\n                if (me.isWidgetAvailableForFrequency(item, value)) {\n                    item.show();\n                    item.enable();\n                }\n                else {\n                    item.hide();\n                    item.disable();\n                }\n            }\n\n            // Special handling of NONE\n            intervalField.hidden = stopRecurrenceField.hidden = value === 'NONE';\n\n            if (value !== 'NONE') {\n                intervalField.hint = me.L(`L{RecurrenceEditor.${value}intervalUnit}`);\n            }\n\n            // When a non-recurring record is loaded, intervalField is set to empty. We want it to default to 1 here\n            // to not look weird (defaults to 1 on the data layer)\n            if (oldValue === 'NONE' && intervalField.value == null) {\n                intervalField.value = 1;\n            }\n\n            me.toggleFieldsState();\n        }\n    }\n\n    toggleFieldsState() {\n        const\n            me            = this,\n            { widgetMap } = me;\n\n        me.onMonthDaysRadioFieldChange({ checked : widgetMap.monthDaysRadioField.checked });\n        me.onPositionAndDayRadioFieldChange({ checked : widgetMap.positionAndDayRadioField.checked });\n        me.onStopRecurrenceFieldChange();\n    }\n\n    updateLocalization() {\n        // do extra labels translation (not auto-translated yet)\n        const { countField, intervalField, frequencyField } = this.widgetMap;\n\n        countField.hint = this.L('L{RecurrenceEditor.time(s)}');\n\n        if (frequencyField.value && frequencyField.value !== 'NONE') {\n            intervalField.hint = this.L(`L{RecurrenceEditor.${frequencyField.value}intervalUnit}`);\n        }\n\n        super.updateLocalization();\n    }\n\n}\n\n// Register this widget type with its Factory\nRecurrenceEditorPanel.initClass();\n", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport TimeSpanMenuBase from './base/TimeSpanMenuBase.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\n\n/**\n * @module Scheduler/feature/EventMenu\n */\n\n/**\n * Displays a context menu for events. Items are populated by other features and/or application code.\n *\n * {@inlineexample Scheduler/feature/EventMenu.js}\n *\n * ### Default event menu items\n *\n * Here is the list of menu items provided by the feature and populated by the other features:\n *\n * | Reference       | Text           | Weight | Feature                                  | Description                                                       |\n * |-----------------|----------------|--------|------------------------------------------|-------------------------------------------------------------------|\n * | `editEvent`     | Edit event     | 100    | {@link Scheduler/feature/EventEdit}      | Edit in the event editor. Hidden when read-only                   |\n * | `copyEvent`     | Copy event     | 110    | {@link Scheduler/feature/EventCopyPaste} | Copy event or assignment. Hidden when read-only                   |\n * | `cutEvent `     | Cut event      | 120    | {@link Scheduler/feature/EventCopyPaste} | Cut event or assignment. Hidden when read-only                    |\n * | `deleteEvent`   | Delete event   | 200    | *This feature*                           | Remove event. Hidden when read-only                               |\n * | `unassignEvent` | Unassign event | 300    | *This feature*                           | Unassign event. Hidden when read-only, shown for multi-assignment |\n * | `splitEvent`    | Split event    | 650    | *Scheduler Pro only*                     | Split an event into two segments at the mouse position            |\n * | `renameSegment` | Rename segment | 660    | *Scheduler Pro only*                     | Show an inline editor to rename the segment                       |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Event menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({eventRecord}) {\n *                         eventRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent   : false,\n *                 unassignEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent : {\n *                     text : 'Delete booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items for all events or specific events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             // Process items before menu is shown\n *             processItems({eventRecord, items}) {\n *                  // Push an extra item for conferences\n *                  if (eventRecord.type === 'conference') {\n *                      items.showSessionItem = {\n *                          text : 'Show sessions',\n *                          onItem({eventRecord}) {\n *                              // ...\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for secret events\n *                  if (eventRecord.type === 'secret') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Note that the {@link #property-menuContext} is applied to the Menu's `item` event, so your `onItem`\n * handler's single event parameter also contains the following properties:\n *\n * - **source** The {@link Scheduler.view.Scheduler} who's UI was right clicked.\n * - **targetElement** The element right clicked on.\n * - **eventRecord** The {@link Scheduler.model.EventModel event record} clicked on.\n * - **resourceRecord** The {@link Scheduler.model.ResourceModel resource record} clicked on.\n * - **assignmentRecord** The {@link Scheduler.model.AssignmentModel assignment record} clicked on.\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @demo Scheduler/eventmenu\n * @classtype eventMenu\n * @feature\n */\nexport default class EventMenu extends TimeSpanMenuBase {\n    //region Config\n\n    static get $name() {\n        return 'EventMenu';\n    }\n\n    /**\n     * @member {Object} menuContext\n     * An informational object containing contextual information about the last activation\n     * of the context menu. The base properties are listed below.\n     * @property {Event} menuContext.domEvent The initiating event.\n     * @property {Event} menuContext.event DEPRECATED: The initiating event.\n     * @property {Number[]} menuContext.point The client `X` and `Y` position of the initiating event.\n     * @property {HTMLElement} menuContext.targetElement The target to which the menu is being applied.\n     * @property {Object<String,MenuItemConfig>} menuContext.items The context menu **configuration** items.\n     * @property {Core.data.Model[]} menuContext.selection The record selection in the client (Grid, Scheduler, Gantt or Calendar).\n     * @property {Scheduler.model.EventModel} menuContext.eventRecord The event record clicked on.\n     * @property {Scheduler.model.ResourceModel} menuContext.resourceRecord The resource record clicked on.\n     * @property {Scheduler.model.AssignmentModel} menuContext.assignmentRecord The assignment record clicked on.\n     * @readonly\n     */\n\n    static get configurable() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    eventMenu : {\n             *         processItems({ items, eventRecord, assignmentRecord, resourceRecord }) {\n             *             // Add or hide existing items here as needed\n             *             items.myAction = {\n             *                 text   : 'Cool action',\n             *                 icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                 onItem : () => console.log(`Clicked ${eventRecord.name}`),\n             *                 weight : 1000 // Move to end\n             *             };\n             *\n             *            if (!eventRecord.allowDelete) {\n             *                 items.deleteEvent.hidden = true;\n             *             }\n             *         }\n             *     }\n             * },\n             * ```\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.EventModel} context.eventRecord The record representing the current event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord The assignment record\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null,\n\n            type : 'event'\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed below. These are the property names which you may\n             * configure:\n             *\n             * - `deleteEvent` Deletes the context event.\n             * - `unassignEvent` Unassigns the context event from the current resource (only added when multi assignment is used).\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventMenu : {\n             *             items : {\n             *                 deleteEvent   : null,\n             *                 unassignEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateEventMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for an event. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event eventMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     * @param {MouseEvent} [event] Pointer event which triggered the context menu (if any)\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the context menu.\n     * @event eventMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    /**\n     * This event fires on the owning Scheduler after showing the context menu for an event\n     * @event eventMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    //endregion\n\n    get resourceStore() {\n        // In horizontal mode, we use store (might be a display store), in vertical & calendar we use resourceStore\n        return this.client.isHorizontal ? this.client.store : this.client.resourceStore;\n    }\n\n    getDataFromEvent(event) {\n        const\n            data             = super.getDataFromEvent(event),\n            eventElement     = data.targetElement,\n            { client }       = this,\n            eventRecord      = client.resolveEventRecord(eventElement),\n            // For vertical mode the resource must be resolved from the event\n            resourceRecord   = eventRecord && (client.resolveResourceRecord(eventElement) || this.resourceStore.last)?.$original,\n            assignmentRecord = eventRecord && client.resolveAssignmentRecord(eventElement);\n\n        return Object.assign(data, {\n            eventElement,\n            eventRecord,\n            resourceRecord,\n            assignmentRecord\n        });\n    }\n\n    getTargetElementFromEvent({ target }) {\n        return target.closest(this.client.eventSelector) || target;\n    }\n\n    shouldShowMenu(eventParams) {\n        return eventParams.eventRecord;\n    }\n\n    /**\n     * Shows context menu for the provided event. If record is not rendered (outside of time span/filtered)\n     * menu won't appear.\n     * @param {Scheduler.model.EventModel} eventRecord Event record to show menu for.\n     * @param {Object} [options]\n     * @param {HTMLElement} options.targetElement Element to align context menu to.\n     * @param {MouseEvent} options.event Browser event.\n     * If provided menu will be aligned according to clientX/clientY coordinates.\n     * If omitted, context menu will be centered to event element.\n     */\n    showContextMenuFor(eventRecord, { targetElement, event } = {}) {\n        if (this.disabled) {\n            return;\n        }\n\n        if (!targetElement) {\n            targetElement = this.getElementFromRecord(eventRecord);\n\n            // If record is not rendered, do nothing\n            if (!targetElement) {\n                return;\n            }\n        }\n\n        DomHelper.triggerMouseEvent(targetElement, this.tiggerEvent);\n    }\n\n    getElementFromRecord(record) {\n        return this.client.getElementsFromEventRecord(record)[0];\n    }\n\n    populateEventMenu({ items, eventRecord, assignmentRecord }) {\n        const { client } = this;\n\n        items.deleteEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly\n        };\n        items.unassignEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly || client.eventStore.usesSingleAssignment\n        };\n    }\n\n    // This generates the fixed, unchanging part of the items and is only called once\n    // to generate the baseItems of the feature.\n    // The dynamic parts which are set by populateEventMenu have this merged into them.\n    changeItems(items) {\n        const { client } = this;\n\n        return Objects.merge({\n            deleteEvent : {\n                text   : 'L{SchedulerBase.Delete event}',\n                icon   : 'b-icon b-icon-trash',\n                weight : 200,\n                onItem({ menu, eventRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    client.removeEvents(client.isEventSelected(eventRecord) ? client.selectedEvents : [eventRecord]);\n                }\n            },\n            unassignEvent : {\n                text   : 'L{SchedulerBase.Unassign event}',\n                icon   : 'b-icon b-icon-unassign',\n                weight : 300,\n                onItem({ menu, eventRecord, resourceRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n\n                    if (client.isEventSelected(eventRecord)) {\n                        client.assignmentStore.remove(client.selectedAssignments);\n                    }\n                    else {\n                        eventRecord.unassign(resourceRecord);\n                    }\n                }\n            }\n        }, items);\n    }\n}\n\nEventMenu.featureClass = '';\n\nGridFeatureManager.registerFeature(EventMenu, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventMenu, false, 'ResourceHistogram');\n", "import TimeSpanMenuBase from '../../Scheduler/feature/base/TimeSpanMenuBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/feature/ScheduleMenu\n */\n\n/**\n * Displays a context menu for empty parts of the schedule. Items are populated in the first place\n * by configurations of this Feature, then by other features and/or application code.\n *\n * ### Default scheduler zone menu items\n *\n * The Scheduler menu feature provides only one item:\n *\n * | Reference      | Text        | Weight | Feature                                  | Description                                                           |\n * |----------------|-------------|--------|------------------------------------------|-----------------------------------------------------------------------|\n * | `addEvent`     | Add event   | 100    | *This feature*                           | Add new event at the target time and resource. Hidden when read-only  |\n * | `pasteEvent`   | Paste event | 110    | {@link Scheduler/feature/EventCopyPaste} | Paste event at the target time and resource. Hidden when is read-only |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Scheduler menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({date, resourceRecord, items}) {\n *                         // Custom date based action\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : {\n *                     text : 'Create new booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             // Process items before menu is shown\n *             processItems({date, resourceRecord, items}) {\n *                  // Add an extra item for ancient times\n *                  if (date < new Date(2018, 11, 17)) {\n *                      items.modernize = {\n *                          text : 'Modernize',\n *                          ontItem({date}) {\n *                              // Custom date based action\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for Sundays\n *                  if (date.getDay() === 0) {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @demo Scheduler/basic\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @classtype scheduleMenu\n * @feature\n */\nexport default class ScheduleMenu extends TimeSpanMenuBase {\n    //region Config\n\n    static get $name() {\n        return 'ScheduleMenu';\n    }\n\n    static get defaultConfig() {\n        return {\n            type : 'schedule',\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed below. These are the predefined property names which you may\n             * configure:\n             *\n             * - `addEvent` Add an event for at the resource and time indicated by the `contextmenu` event.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         scheduleMenu : {\n             *             items : {\n             *                 addEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    scheduleMenu : {\n             *         processItems({ items, date, resourceRecord }) {\n             *            // Add or hide existing items here as needed\n             *            items.myAction = {\n             *                text   : 'Cool action',\n             *                icon   : 'b-fa b-fa-cat',\n             *                onItem : () => console.log(`Clicked on ${resourceRecord.name} at ${date}`),\n             *                weight : 1000 // Move to end\n             *            };\n             *\n             *            if (!resourceRecord.allowAdd) {\n             *                items.addEvent.hidden = true;\n             *            }\n             *        }\n             *    }\n             * },\n             * ```\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Date} context.date The clicked date\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the\n             * {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateScheduleMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for an event. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event scheduleMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the context menu.\n     * @event scheduleMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    /**\n     * This event fires on the owning Scheduler after showing the context menu for an event\n     * @event scheduleMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    //endregion\n\n    shouldShowMenu(eventParams) {\n        const\n            { client } = this,\n            {\n                targetElement,\n                resourceRecord\n            } = eventParams,\n            isTimeAxisColumn = client.timeAxisSubGridElement.contains(targetElement);\n\n        return !targetElement.closest(client.eventSelector) && isTimeAxisColumn && !(resourceRecord && resourceRecord.isSpecialRow);\n    }\n\n    getDataFromEvent(event) {\n        // Process event if it wasn't yet processed\n        if (DomHelper.isDOMEvent(event)) {\n            const\n                { client }     = this,\n                cellData       = client.getCellDataFromEvent?.(event),\n                date           = client.getDateFromDomEvent?.(event, 'floor'),\n                // For vertical mode the resource must be resolved from the event\n                resourceRecord = client.resolveResourceRecord(event) || client.isVertical && client.resourceStore.last;\n\n            return ObjectHelper.assign(super.getDataFromEvent(event), cellData, { date, resourceRecord });\n        }\n\n        return event;\n    }\n\n    populateScheduleMenu({ items, resourceRecord, date }) {\n        const { client } = this;\n\n        // Menu can work for ResourceHistogram which doesn't have event store\n        if (!client.readOnly && client.eventStore) {\n            items.addEvent = {\n                text     : 'L{SchedulerBase.Add event}',\n                icon     : 'b-icon b-icon-add',\n                disabled : !resourceRecord || resourceRecord.readOnly || !resourceRecord.isWorkingTime(date),\n                weight   : 100,\n                onItem() {\n                    client.createEvent(date, resourceRecord, client.getRowFor(resourceRecord));\n                }\n            };\n        }\n    }\n}\n\nScheduleMenu.featureClass = '';\n\nGridFeatureManager.registerFeature(ScheduleMenu, true, 'Scheduler');\n", "import Base from '../../../Core/Base.js';\nimport '../recurrence/RecurrenceConfirmationPopup.js';\n\n/**\n * @module Scheduler/view/mixin/RecurringEvents\n */\n\n/**\n * A mixin that adds recurring events functionality to the Scheduler.\n *\n * The main purpose of the code in here is displaying a {@link Scheduler.view.recurrence.RecurrenceConfirmationPopup special confirmation}\n * on user mouse dragging/resizing/deleting recurring events and their occurrences.\n *\n * @mixin\n */\nexport default Target => class RecurringEvents extends (Target || Base) {\n    static $name = 'RecurringEvents';\n\n    static configurable = {\n        /**\n         * Enables showing occurrences of recurring events across the scheduler's time axis.\n         *\n         * Enables extra recurrence UI fields in the system-provided event editor (not in Scheduler Pro's task editor).\n         * @config {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        enableRecurringEvents : false,\n\n        recurrenceConfirmationPopup : {\n            $config : ['lazy'],\n            value   : {\n                type : 'recurrenceconfirmation'\n            }\n        }\n    };\n\n    construct(config) {\n        super.construct(config);\n\n        this.ion({\n            beforeEventDropFinalize   : 'onRecurrableBeforeEventDropFinalize',\n            beforeEventResizeFinalize : 'onRecurrableBeforeEventResizeFinalize',\n            beforeAssignmentDelete    : 'onRecurrableAssignmentBeforeDelete'\n        });\n    }\n\n    changeRecurrenceConfirmationPopup(recurrenceConfirmationPopup, oldRecurrenceConfirmationPopup) {\n        // Widget.reconfigure reither reconfigures an existing instance, or creates a new one, or,\n        // if the configuration is null, destroys the existing instance.\n        const result = this.constructor.reconfigure(oldRecurrenceConfirmationPopup, recurrenceConfirmationPopup, 'recurrenceconfirmation');\n        result.owner = this;\n        return result;\n    }\n\n    findRecurringEventToConfirmDelete(eventRecords) {\n        // show confirmation if we deal with at least one recurring event (or its occurrence)\n        // and if the record is not being edited by event editor (since event editor has its own confirmation)\n        return eventRecords.find(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n    }\n\n    onRecurrableAssignmentBeforeDelete({ assignmentRecords, context }) {\n        const\n            eventRecords = assignmentRecords.map(as => as.event),\n            eventRecord  = this.findRecurringEventToConfirmDelete(eventRecords);\n\n        if (this.enableRecurringEvents && eventRecord) {\n            this.recurrenceConfirmationPopup.confirm({\n                actionType : 'delete',\n                eventRecord,\n                changerFn() {\n                    context.finalize(true);\n                },\n                cancelFn() {\n                    context.finalize(false);\n                }\n            });\n\n            return false;\n        }\n    }\n\n    onRecurrableBeforeEventDropFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecords } = context,\n                recurringEvents = eventRecords.filter(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n\n            if (recurringEvents.length) {\n                context.async = true;\n\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType  : 'update',\n                    eventRecord : recurringEvents[0],\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n\n    onRecurrableBeforeEventResizeFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecord } = context,\n                isRecurring     = eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);\n\n            if (isRecurring) {\n                context.async = true;\n\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType : 'update',\n                    eventRecord,\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n\n    // Make sure occurrence cache is up-to-date when reassigning events\n    onAssignmentChange({ action, records : assignments }) {\n        if (action !== 'dataset' && Array.isArray(assignments)) {\n            for (const assignment of assignments) {\n                if (assignment.event?.isRecurring && !assignment.event.isBatchUpdating) {\n                    assignment.event.removeOccurrences();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns occurrences of the provided recurring event across the date range of this Scheduler.\n     * @param  {Scheduler.model.TimeSpan} recurringEvent Recurring event for which occurrences should be retrieved.\n     * @returns {Scheduler.model.TimeSpan[]} Array of the provided timespans occurrences.\n     *\n     * __Empty if the passed event is not recurring, or has no occurrences in the date range.__\n     *\n     * __If the date range encompasses the start point, the recurring event itself will be the first entry.__\n     * @category Data\n     */\n    getOccurrencesFor(recurringEvent) {\n        return this.eventStore.getOccurrencesForTimeSpan(recurringEvent, this.timeAxis.startDate, this.timeAxis.endDate);\n    }\n\n    /**\n     * Internal utility function to remove events. Used when pressing [DELETE] or [BACKSPACE] or when clicking the\n     * delete button in the event editor. Triggers a preventable `beforeEventDelete` or `beforeAssignmentDelete` event.\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} eventRecords Records to remove\n     * @param {Function} [callback] Optional callback executed after triggering the event but before deletion\n     * @returns {Boolean} Returns `false` if the operation was prevented, otherwise `true`\n     * @internal\n     * @fires beforeEventDelete\n     * @fires beforeAssignmentDelete\n     */\n    async removeEvents(eventRecords, callback = null, popupOwner = this) {\n        const me = this;\n\n        if (!me.readOnly && eventRecords.length) {\n            const context = {\n                finalize(removeRecord = true) {\n                    if (callback) {\n                        callback(removeRecord);\n                    }\n\n                    if (removeRecord !== false) {\n                        if (eventRecords.some(record => record.isOccurrence || record.event?.isOccurrence)) {\n                            eventRecords.forEach(record => record.isOccurrenceAssignment ? record.event.remove() : record.remove());\n                        }\n                        else {\n                            const store = eventRecords[0].isAssignment ? me.assignmentStore : me.eventStore;\n\n                            store.remove(eventRecords);\n                        }\n                    }\n                }\n            };\n\n            let shouldFinalize;\n\n            if (eventRecords[0].isAssignment) {\n                /**\n                 * Fires before an assignment is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or\n                 * by the event editor. Can for example be used to display a custom dialog to confirm deletion, in which\n                 * case records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeAssignmentDelete({ assignmentRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the assignments on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the assignments if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeAssignmentDelete\n                 * @param {Scheduler.view.Scheduler} source  The Scheduler instance\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]   Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 */\n                shouldFinalize = me.trigger('beforeAssignmentDelete', { assignmentRecords : eventRecords, context });\n            }\n            else {\n                /**\n                 * Fires before an event is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or by the\n                 * event editor. Can for example be used to display a custom dialog to confirm deletion, in which case\n                 * records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeEventDelete({ eventRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the events on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the events if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeEventDelete\n                 * @param {Scheduler.view.Scheduler} source  The Scheduler instance\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]  Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 */\n                shouldFinalize = me.trigger('beforeEventDelete', { eventRecords, context });\n            }\n\n            if (shouldFinalize !== false) {\n                const recurringEventRecord = eventRecords.find(eventRecord => eventRecord.isRecurring || eventRecord.isOccurrence);\n\n                if (recurringEventRecord) {\n                    me.recurrenceConfirmationPopup.owner = popupOwner;\n                    me.recurrenceConfirmationPopup.confirm({\n                        actionType  : 'delete',\n                        eventRecord : recurringEventRecord,\n                        changerFn() {\n                            context.finalize(true);\n                        },\n                        cancelFn() {\n                            context.finalize(false);\n                        }\n                    });\n                }\n                else {\n                    context.finalize(true);\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "/**\n * @module Scheduler/view/mixin/CurrentConfig\n */\n\nconst\n    stores = [\n        'eventStore',\n        'taskStore',\n        'assignmentStore',\n        'resourceStore',\n        'dependencyStore',\n        'timeRangeStore',\n        'resourceTimeRangeStore'\n    ],\n    inlineProperties = [\n        'events',\n        'tasks',\n        'resources',\n        'assignments',\n        'dependencies',\n        'timeRanges',\n        'resourceTimeRanges'\n    ];\n\n/**\n * Mixin that makes sure inline data & crud manager data are removed from current config for products using a project.\n * The data is instead inlined in the project (by ProjectModel.js)\n *\n * @mixin\n * @private\n */\nexport default Target => class CurrentConfig extends Target {\n\n    static get $name() {\n        return 'CurrentConfig';\n    }\n\n    preProcessCurrentConfigs(configs) {\n        // Remove inline data on the component\n        for (const prop of inlineProperties) {\n            delete configs[prop];\n        }\n\n        super.preProcessCurrentConfigs(configs);\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const\n            project = this.project.getCurrentConfig(options),\n            result = super.getCurrentConfig(options);\n\n        // Force project with inline data\n        if (project) {\n            result.project = project;\n\n            const { crudManager } = result;\n\n            // Transfer crud store configs to project (mainly fields)\n            if (crudManager) {\n                for (const store of stores) {\n                    if (crudManager[store]) {\n                        project[store] = crudManager[store];\n                    }\n                }\n            }\n\n            if (Object.keys(project).length === 0) {\n                delete result.project;\n            }\n        }\n\n        // Store (resource store) data is included in project\n        delete result.data;\n\n        // Remove CrudManager, since data will be placed inline\n        delete result.crudManager;\n\n        return result;\n    }\n\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Navigator from '../../../Core/helper/util/Navigator.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport Location from '../../../Grid/util/Location.js';\n\n/**\n * @module Scheduler/view/mixin/EventNavigation\n */\n\nconst\n    preventDefault  = e => e.preventDefault(),\n    isArrowKey = {\n        ArrowRight : 1,\n        ArrowLeft  : 1,\n        ArrowUp    : 1,\n        ArrowDown  : 1\n    },\n    animate100 = {\n        animate : 100\n    },\n    emptyObject = Object.freeze({});\n\n/**\n * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.\n * @mixin\n */\nexport default Target => class EventNavigation extends Delayable(Target || Base) {\n    static get $name() {\n        return 'EventNavigation';\n    }\n\n    //region Default config\n\n    static get configurable() {\n        return {\n            /**\n             * A config object to use when creating the {@link Core.helper.util.Navigator}\n             * to use to perform keyboard navigation in the timeline.\n             * @config {NavigatorConfig}\n             * @default\n             * @category Misc\n             * @internal\n             */\n            navigator : {\n                allowCtrlKey   : true,\n                scrollSilently : true,\n                keys           : {\n                    Space     : 'onEventSpaceKey',\n                    Enter     : 'onEventEnterKey',\n                    Delete    : 'onDeleteKey',\n                    Backspace : 'onDeleteKey',\n                    ArrowUp   : 'onArrowUpKey',\n                    ArrowDown : 'onArrowDownKey',\n                    Escape    : 'onEscapeKey',\n\n                    // These are processed by GridNavigation's handlers\n                    Tab         : 'onTab',\n                    'SHIFT+Tab' : 'onShiftTab'\n                }\n            },\n\n            isNavigationKey : {\n                ArrowDown  : 1,\n                ArrowUp    : 1,\n                ArrowLeft  : 1,\n                ArrowRight : 1\n            }\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS class name to add to focused events.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            focusCls : 'b-active',\n\n            /**\n             * Allow using [Delete] and [Backspace] to remove events/assignments\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            enableDeleteKey : true,\n\n            // Number in milliseconds to buffer handlers execution. See `Delayable.throttle` function docs.\n            onDeleteKeyBuffer      : 500,\n            navigatePreviousBuffer : 200,\n            navigateNextBuffer     : 200,\n\n            testConfig : {\n                onDeleteKeyBuffer : 1\n            }\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fired when a user gesture causes the active item to change.\n     * @event navigate\n     * @param {Event} event The browser event which instigated navigation. May be a click or key or focus event.\n     * @param {HTMLElement|null} item The newly active item, or `null` if focus moved out.\n     * @param {HTMLElement|null} oldItem The previously active item, or `null` if focus is moving in.\n     */\n\n    //endregion\n\n    construct(config) {\n        const me = this;\n\n        me.isInTimeAxis = me.isInTimeAxis.bind(me);\n        me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me);\n\n        super.construct(config);\n    }\n\n    changeNavigator(navigator) {\n        const me = this;\n\n        me.getConfig('subGridConfigs');\n\n        return new Navigator(me.constructor.mergeConfigs({\n            ownerCmp         : me,\n            target           : me.timeAxisSubGridElement,\n            processEvent     : me.processEvent,\n            itemSelector     : `.${me.eventCls}-wrap`,\n            focusCls         : me.focusCls,\n            navigatePrevious : me.throttle(me.navigatePrevious, { delay : me.navigatePreviousBuffer, throttled : preventDefault }),\n            navigateNext     : me.throttle(me.navigateNext, { delay : me.navigateNextBuffer, throttled : preventDefault })\n        }, navigator));\n    }\n\n    doDestroy() {\n        this.navigator.destroy();\n        super.doDestroy();\n    }\n\n    isInTimeAxis(record) {\n        // If event is hidden by workingTime configs, horizontal mapper would raise a flag on instance meta\n        // We still need to check if time span is included in axis\n        return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);\n    }\n\n    onElementKeyDown(keyEvent) {\n        const\n            me              = this,\n            { navigator }   = me;\n\n        // If we're focused in the time axis, and *not* on an event, then ENTER means\n        // jump down into the first visible assignment in the cell.\n        if (me.focusedCell?.rowIndex !== -1 && me.focusedCell?.column === me.timeAxisColumn && !keyEvent.target.closest(navigator.itemSelector) && keyEvent.key === 'Enter') {\n            const firstAssignment = me.getFirstVisibleAssignment();\n            if (firstAssignment) {\n                me.navigateTo(firstAssignment, {\n                    uiEvent : keyEvent\n                });\n                return false;\n            }\n        }\n        else {\n            super.onElementKeyDown?.(keyEvent);\n        }\n    }\n\n    getFirstVisibleAssignment(location = this.focusedCell) {\n        const\n            me = this,\n            {\n                currentOrientation,\n                rowManager,\n                eventStore\n            } = me;\n\n        if (me.isHorizontal) {\n            let renderedEvents = currentOrientation.rowMap.get(rowManager.getRow(location.rowIndex));\n\n            if (renderedEvents?.length) {\n                return renderedEvents[0]?.elementData.assignmentRecord;\n            }\n            else {\n                renderedEvents = currentOrientation.resourceMap.get(location.id)?.eventsData;\n                if (renderedEvents?.length) {\n                    // When events are gathered from resource, we need to check they're available\n                    return renderedEvents.filter(e => eventStore.isAvailable(e.eventRecord))[0]?.assignmentRecord;\n                }\n            }\n        }\n        else {\n            const\n                firstResource = [...currentOrientation.resourceMap.values()][0],\n                renderedEvents = firstResource && Object.values(firstResource);\n\n            if (renderedEvents?.length) {\n                return renderedEvents.filter(e => eventStore.isAvailable(e.renderData.eventRecord))[0].renderData.assignmentRecord;\n            }\n        }\n    }\n\n    onGridBodyFocusIn(focusEvent) {\n        const isGridCellFocus = focusEvent.target.closest(this.focusableSelector);\n\n        // Event navigation only has a say when navigation is inside the TimeAxisSubGrid\n        if (this.timeAxisSubGridElement.contains(focusEvent.target)) {\n            const\n                me                  = this,\n                { navigationEvent } = me,\n                { target }          = focusEvent,\n                eventFocus          = target.closest(me.navigator.itemSelector),\n                destinationCell     = eventFocus ? me.normalizeCellContext({\n                    rowIndex : me.isVertical ? 0\n                        : me.resourceStore.indexOf(me.resolveResourceRecord(target)),\n                    column : me.timeAxisColumn,\n                    target\n                }) : new Location(target);\n\n            // Don't take over what the event navigator does if it's doing event navigation.\n            // Just silently cache our actionable location.\n            if (eventFocus) {\n                const { _focusedCell } = me;\n\n                me._focusedCell = destinationCell;\n                me.onCellNavigate?.(me, _focusedCell, destinationCell, navigationEvent, true);\n                return;\n            }\n\n            // Depending on how we got here, try to focus the first event in the cell *if we're in a cell*.\n            if (isGridCellFocus && (!navigationEvent || isArrowKey[navigationEvent.key])) {\n                const firstAssignment = me.getFirstVisibleAssignment(destinationCell);\n                if (firstAssignment) {\n                    me.navigateTo(firstAssignment, {\n                        // Only change scroll if focus came from key press\n                        scrollIntoView : Boolean(navigationEvent && navigationEvent.type !== 'mousedown'),\n                        uiEvent        : navigationEvent || focusEvent\n                    });\n                    return;\n                }\n            }\n        }\n\n        // Grid-level focus movement, let superclass handle it.\n        if (isGridCellFocus) {\n            super.onGridBodyFocusIn(focusEvent);\n        }\n    }\n\n    /*\n     * Override of GridNavigation#focusCell method to handle the TimeAxisColumn.\n     * Not needed until we implement full keyboard accessibility.\n     */\n    accessibleFocusCell(cellSelector, options) {\n        const me                     = this;\n\n        cellSelector = me.normalizeCellContext(cellSelector);\n\n        if (cellSelector.columnId === me.timeAxisColumn.id) {\n            // <remove-on-release>\n\n            // const lastFocusedCell        = me.lastFocusedCell = me._focusedCell,\n            //     lastFocusedCellElement = lastFocusedCell && me.getCell(lastFocusedCell),\n            //     newCell = me.getCell(cellSelector),\n            //     // Flag if the lastFocusedCellElement is DOCUMENT_POSITION_FOLLOWING newCell\n            //     backwards = !!(lastFocusedCellElement && (newCell.compareDocumentPosition(lastFocusedCellElement) & 4));\n\n            // // Navigating into the Scheduler, need to enable this back (for situations where we know focus was requested as a result of a keyboard input)...\n            // let newEvent = me.getRecordFromElement(newCell);\n\n            // me._focusedCell = cellSelector;\n\n            // // Scheduler where row is a Resource which might have many events\n            // // TODO: https://app.assembla.com/spaces/bryntum/tickets/6526 this class should\n            // // not know about Gantt.\n            // if (!newEvent.isTask) {\n            //     const resourceEvents = newEvent.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate);\n            //     newEvent = resourceEvents[backwards ? resourceEvents.length - 1 : 0];\n            // }\n\n            // options.event.eventRecord = newEvent;\n\n            // if (newEvent && me.activeEvent !== newEvent) {\n            //     lastFocusedCellElement && lastFocusedCellElement.classList.remove('b-focused');\n            //     me.scrollResourceEventIntoView(me.store.getById(cellSelector.id), newEvent, {\n            //         animate : 100\n            //     }).then(() => {\n            //         me.activeEvent = newEvent;\n            //     });\n            // }\n\n            // </remove-on-release>\n        }\n        else {\n            return super.focusCell(cellSelector, options);\n        }\n    }\n\n    // Interface method to extract the navigated to record from a populated 'navigate' event.\n    // Gantt, Scheduler and Calendar handle event differently, adding different properties to it.\n    // This method is meant to be overridden to return correct target from event\n    normalizeTarget(event) {\n        return event.assignmentRecord;\n    }\n\n    getPrevious(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n\n        let resourceRecord = assignmentRecord.resource,\n            previousEvent  = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];\n\n        // At first event for resource, traverse up the resource store.\n        if (!previousEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (\n                let rowIdx = resourceStore.indexOf(resourceRecord) - 1;\n                (!previousEvent || (isDelete && previousEvent === eventRecord)) && rowIdx >= 0;\n                rowIdx--\n            ) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n\n                previousEvent = events.length && events[events.length - 1];\n            }\n        }\n\n        return me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord);\n    }\n\n    navigatePrevious(keyEvent) {\n        const\n            me                 = this,\n            previousAssignment = me.getPrevious(me.normalizeTarget(keyEvent));\n\n        keyEvent.preventDefault();\n        if (previousAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(previousAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n\n        // No previous event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n\n    getNext(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    // start/end are required to limit time\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n\n        let resourceRecord = assignmentRecord.resource,\n            nextEvent      = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];\n\n        // At last event for resource, traverse down the resource store\n        if (!nextEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || (isDelete && nextEvent === eventRecord)) && rowIdx < resourceStore.count; rowIdx++) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n\n                nextEvent = events[0];\n            }\n        }\n\n        return me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord);\n    }\n\n    navigateNext(keyEvent) {\n        const\n            me             = this,\n            nextAssignment = me.getNext(me.normalizeTarget(keyEvent));\n\n        keyEvent.preventDefault();\n        if (nextAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(nextAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n\n        // No next event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n\n    doGridNavigation(keyEvent) {\n        if (!keyEvent.handled && keyEvent.key.indexOf('Arrow') === 0) {\n            this[`navigate${keyEvent.key.substring(5)}ByKey`](keyEvent);\n        }\n    }\n\n    async navigateTo(targetAssignment, {\n        scrollIntoView = true,\n        uiEvent        = {}\n    } = emptyObject) {\n        const\n            me                      = this,\n            { navigator }           = me,\n            { skipScrollIntoView }  = navigator;\n\n        if (targetAssignment) {\n            if (scrollIntoView) {\n                // No key processing during scroll\n                navigator.disabled = true;\n                await me.scrollAssignmentIntoView(targetAssignment, animate100);\n                navigator.disabled = false;\n            }\n            else {\n                navigator.skipScrollIntoView = true;\n            }\n\n            // Panel can be destroyed before promise is resolved\n            // Perform a sanity check to make sure element is still in the DOM (syncIdMap actually).\n            if (!me.isDestroyed && this.getElementFromAssignmentRecord(targetAssignment)) {\n                me.activeAssignment = targetAssignment;\n                navigator.skipScrollIntoView = skipScrollIntoView;\n                navigator.trigger('navigate', {\n                    event : uiEvent,\n                    item  : me.getElementFromAssignmentRecord(targetAssignment).closest(navigator.itemSelector)\n                });\n            }\n        }\n    }\n\n    set activeAssignment(assignmentRecord) {\n        const assignmentEl = this.getElementFromAssignmentRecord(assignmentRecord, true);\n\n        if (assignmentEl) {\n            this.navigator.activeItem = assignmentEl;\n        }\n    }\n\n    get activeAssignment() {\n        const { activeItem } = this.navigator;\n\n        if (activeItem) {\n            return this.resolveAssignmentRecord(activeItem);\n        }\n    }\n\n    get previousActiveEvent() {\n        const { previousActiveItem } = this.navigator;\n\n        if (previousActiveItem) {\n            return this.resolveEventRecord(previousActiveItem);\n        }\n    }\n\n    processEvent(keyEvent) {\n        const\n            me           = this,\n            eventElement = keyEvent.target.closest(me.eventSelector);\n\n        if (!me.navigator.disabled && eventElement) {\n            keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);\n            keyEvent.eventRecord = me.resolveEventRecord(eventElement);\n            keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);\n        }\n\n        return keyEvent;\n    }\n\n    onDeleteKey(keyEvent) {\n        const me = this;\n        if (!me.readOnly && me.enableDeleteKey) {\n            const records = me.eventStore.usesSingleAssignment ? me.selectedEvents : me.selectedAssignments;\n\n            me.removeEvents(records.filter(r => !r.readOnly));\n        }\n    }\n\n    onArrowUpKey(keyEvent) {\n        this.focusCell({\n            rowIndex : this.focusedCell.rowIndex - 1,\n            column   : this.timeAxisColumn\n        });\n        keyEvent.handled = true;\n    }\n\n    onArrowDownKey(keyEvent) {\n        if (this.focusedCell.rowIndex < this.resourceStore.count - 1) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex + 1,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n\n    onEscapeKey(keyEvent) {\n        if (!keyEvent.target.closest('.b-dragging')) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n\n    onEventSpaceKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n\n    onEventEnterKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n\n    get isActionableLocation() {\n        // Override from grid if the Navigator's location is an event (or task if we're in Gantt)\n        // Being focused on a task/event means that it's *not* actionable. It's not valid to report\n        // that we're \"inside\" the cell in a TimeLine, so ESC must not attempt to focus the cell.\n        if (!this.navigator.activeItem) {\n            return super.isActionableLocation;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n"],
  "mappings": "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",
  "names": ["locale", "localeName", "localeDesc", "localeCode", "Object", "newEvent", "ResourceInfoColumn", "eventCountText", "data", "Dependencies", "from", "to", "valid", "invalid", "DependencyType", "SS", "SF", "FS", "FF", "StartToStart", "StartToEnd", "EndToStart", "EndToEnd", "short", "long", "DependencyEdit", "From", "To", "Type", "Lag", "Save", "Delete", "Cancel", "EventEdit", "Name", "Resource", "Start", "End", "Repeat", "EventDrag", "eventOverlapsExisting", "noDropOutsideTimeline", "SchedulerBase", "TimeAxisHeaderMenu", "pickZoomLevel", "activeDateRange", "startText", "endText", "todayText", "EventCopyPaste", "copyEvent", "cutEvent", "pasteEvent", "EventFilter", "filterEvents", "byName", "TimeRanges", "showCurrentTimeLine", "PresetManager", "secondAndMinute", "displayDateFormat", "name", "minuteAndHour", "topDateFormat", "hourAndDay", "middleDateFormat", "day", "week", "dayAndWeek", "dayAndMonth", "weekAndDay", "weekAndMonth", "weekAndDayLetter", "weekDateAndMonth", "monthAndYear", "year", "manyYears", "RecurrenceConfirmationPopup", "Yes", "width", "RecurrenceLegend", "Daily", "Weekly on {1}", "days", "Monthly on {1}", "Yearly on {1} of {2}", "months", "Every {0} days", "interval", "Every {0} weeks on {1}", "Every {0} months on {1}", "Every {0} years on {1} of {2}", "position1", "position2", "position3", "position4", "position5", "weekday", "daysFormat", "position", "RecurrenceEditor", "Frequency", "Every", "DAILYintervalUnit", "WEEKLYintervalUnit", "MONTHLYintervalUnit", "YEARLYintervalUnit", "Each", "RecurrenceDaysCombo", "RecurrencePositionsCombo", "RecurrenceStopConditionCombo", "Never", "After", "RecurrenceFrequencyCombo", "None", "Weekly", "Monthly", "Yearly", "RecurrenceCombo", "Custom", "Summary", "date", "ScheduleRangeCombo", "completeview", "currentview", "daterange", "completedata", "SchedulerExportDialog", "ExcelExporter", "CrudManagerView", "serverResponseLabel", "DurationColumn", "Duration", "LocaleHelper", "publishLocale", "AttachToProjectMixin", "Target", "$name", "afterConstruct", "me", "projectHolder", "client", "grid", "project", "projectSubscribers", "push", "attachToProject", "attachToResourceStore", "resourceStore", "attachToEventStore", "eventStore", "attachToAssignmentStore", "assignmentStore", "attachToDependencyStore", "dependencyStore", "attachToCalendarManagerStore", "calendarManagerStore", "detachListeners", "_project", "store", "engineStoreNames", "ProjectConsumer", "_a", "Base", "__privateAdd", "_suspendedByRestore", "declarable", "configurable", "projectModelClass", "ProjectModel", "destroyStores", "startConfigure", "config", "getConfig", "changeProject", "oldProject", "projectStoreNames", "projectDataNames", "constructor", "projectCallbacks", "Set", "buildingProjectConfig", "isModel", "isConfiguring", "crudManager", "isCrudManager", "storeName", "dataName", "_sharedProject", "sharedProject", "isEventStoreMixin", "autoLoad", "count", "delayAutoLoad", "some", "chain", "updateProject", "projectListeners", "_crudManager", "_project$stm", "thisObj", "ion", "forEach", "subscriber", "load", "stm", "restoringStart", "restoringStop", "trigger", "changeCrudManager", "assign", "onProjectDataReady", "whenVisible", "size", "callback", "clear", "onProjectRestoringStart", "rawQueue", "length", "__privateSet", "suspendRefresh", "onProjectRestoringStop", "__privateGet", "resumeRefresh", "onBeforeTimeZoneChange", "onTimeZoneChange", "timeZone", "oldTimeZone", "startDate", "timeAxis", "TimeZoneHelper", "fromTimeZone", "toTimeZone", "whenProjectReady", "isEngineReady", "add", "_this$project$isEngin", "_this$project", "Boolean", "call", "doDestroy", "isDestroyed", "destroy", "projectStores", "map", "keys", "reduce", "result", "setupProjectStores", "cls", "meta", "dataReady", "change", "beforeTimeZoneChange", "timeZoneChange", "storeConfigs", "previousDataName", "defineProperty", "class", "prototype", "get", "_this$project$storeNa", "records", "createDataUpdater", "createStoreDescriptor", "setupConfigs", "StringHelper", "capitalize", "listeners", "clsProto", "storeNameCap", "oldStore", "_store", "storeProject", "isProjectModel", "initializingProject", "_subscriber", "relayProjectDataChange", "event", "isExpand", "isCollapse", "fieldMap", "expanded", "persist", "source", "widgetClass", "ClockTemplate", "defaultConfig", "minuteHeight", "minuteTop", "hourHeight", "hourTop", "handLeft", "div", "document", "createElement", "scheduler", "template", "mode", "DateHelper", "format", "encodeHtml", "text", "generateContent", "innerHTML", "updateDateIndicator", "el", "hourIndicatorEl", "querySelector", "minuteIndicatorEl", "BrowserHelper", "isBrowserEnv", "style", "transform", "getHours", "getMinutes", "_mode", "unitLessThanDay", "compareUnits", "timeAxisViewModel", "timeResolution", "unit", "formatContainsHourInfo", "_template", "_$name", "TaskEditStm", "captureStm", "startTransaction", "getStm", "hasStmCapture", "stmInitiallyDisabled", "disabled", "stmInitiallyAutoRecord", "autoRecord", "enable", "isRecording", "stopTransaction", "startStmTransaction", "commitStmTransaction", "Error", "enabled", "resetQueue", "rejectStmTransaction", "_stm$transaction", "transaction", "rejectTransaction", "enableStm", "disableStm", "disable", "freeStm", "commitOrReject", "TimeSpanMenuBase", "ContextMenuBase", "Popup", "type", "localizableProperties", "align", "autoShow", "autoClose", "closeAction", "modal", "centered", "scrollAction", "constrainTo", "globalThis", "draggable", "closable", "floating", "eventRecord", "bbar", "defaults", "localeClass", "items", "changeSingleButton", "weight", "color", "onClick", "changeMultipleButton", "cancelButton", "widgetMap", "onChangeMultipleButtonClick", "processMultipleRecords", "hide", "onChangeSingleButtonClick", "processSingleRecord", "onCancelButtonClick", "cancelFn", "onRecurrenceClose", "confirm", "prop", "updatePopupContent", "show", "actionType", "isRecurring", "L", "html", "title", "changerFn", "finalizerFn", "beginBatch", "endBatch", "_firstOccurrence", "firstOccurrence", "recurrence", "forEachOccurrence", "occurrence", "isFirst", "index", "convertToRealEvent", "recurrenceRule", "updateLocalization", "initClass", "Combo", "buildItems", "addNone", "value", "__publicField", "editable", "displayField", "valueField", "localizeDisplayFields", "allDaysValueAsArray", "allDaysValue", "join", "defaultValue", "workingDaysValue", "filter", "nonWorkingDays", "nonWorkingDaysValue", "splitCls", "_weekDays", "weekDays", "concat", "weekStartDay", "dayNames", "getDayNames", "RecurrenceDayRuleEncoder", "encodeDay", "slice", "Array", "isArray", "findRecord", "RecurrenceDaysButtonGroup", "ButtonGroup", "toggleable", "construct", "columns", "updateItemText", "item", "decodeDay", "getDayName", "substring", "__items", "onLocaleChange", "widgetClassList", "classList", "RecurrenceMonthDaysButtonGroup", "minValue", "maxValue", "RecurrenceMonthsButtonGroup", "getMonthNames", "getMonthName", "placeholder", "_recurrence", "endDate", "maxPosition", "buildDayNumbers", "ArrayHelper", "populate", "i", "split", "parseInt", "RecurrenceEditorPanel", "Panel", "updateRecord", "record", "frequencyField", "daysButtonField", "monthDaysButtonField", "monthsButtonField", "monthDaysRadioField", "positionAndDayRadioField", "stopRecurrenceField", "timeSpan", "getDay", "monthDays", "getDate", "getMonth", "positions", "check", "isPainted", "uncheck", "syncEventRecord", "values", "getValues", "w", "set", "toggleStopFields", "countField", "endDateField", "onMonthDaysRadioFieldChange", "checked", "isWidgetAvailableForFrequency", "onPositionAndDayRadioFieldChange", "daysCombo", "positionsCombo", "onStopRecurrenceFieldChange", "widget", "frequency", "forFrequency", "includes", "onFrequencyFieldChange", "oldValue", "queryAll", "intervalField", "hidden", "hint", "toggleFieldsState", "label", "onChange", "min", "required", "toggleGroup", "flex", "EventMenu", "processItems", "pluginConfig", "isHorizontal", "getDataFromEvent", "_ref", "eventElement", "targetElement", "resolveEventRecord", "resourceRecord", "resolveResourceRecord", "last", "$original", "assignmentRecord", "resolveAssignmentRecord", "getTargetElementFromEvent", "target", "closest", "eventSelector", "shouldShowMenu", "eventParams", "showContextMenuFor", "getElementFromRecord", "DomHelper", "triggerMouseEvent", "tiggerEvent", "getElementsFromEventRecord", "populateEventMenu", "deleteEvent", "readOnly", "unassignEvent", "usesSingleAssignment", "changeItems", "Objects", "merge", "icon", "onItem", "menu", "_menu$focusInEvent", "revertTarget", "focusInEvent", "relatedTarget", "focus", "navigator", "activeItem", "removeEvents", "isEventSelected", "selectedEvents", "_menu$focusInEvent2", "remove", "selectedAssignments", "unassign", "featureClass", "GridFeatureManager", "registerFeature", "ScheduleMenu", "isTimeAxisColumn", "timeAxisSubGridElement", "contains", "isSpecialRow", "isDOMEvent", "_client$getCellDataFr", "_client$getDateFromDo", "cellData", "getCellDataFromEvent", "getDateFromDomEvent", "isVertical", "ObjectHelper", "populateScheduleMenu", "addEvent", "isWorkingTime", "createEvent", "getRowFor", "RecurringEvents", "beforeEventDropFinalize", "beforeEventResizeFinalize", "beforeAssignmentDelete", "changeRecurrenceConfirmationPopup", "recurrenceConfirmationPopup", "oldRecurrenceConfirmationPopup", "reconfigure", "owner", "findRecurringEventToConfirmDelete", "eventRecords", "find", "supportsRecurring", "isOccurrence", "onRecurrableAssignmentBeforeDelete", "assignmentRecords", "context", "as", "enableRecurringEvents", "finalize", "onRecurrableBeforeEventDropFinalize", "recurringEvents", "async", "onRecurrableBeforeEventResizeFinalize", "onAssignmentChange", "action", "assignments", "assignment", "_assignment$event", "isBatchUpdating", "removeOccurrences", "getOccurrencesFor", "recurringEvent", "getOccurrencesForTimeSpan", "popupOwner", "removeRecord", "_record$event", "isOccurrenceAssignment", "isAssignment", "shouldFinalize", "recurringEventRecord", "$config", "stores", "inlineProperties", "CurrentConfig", "preProcessCurrentConfigs", "configs", "getCurrentConfig", "options", "preventDefault", "e", "isArrowKey", "ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown", "animate100", "animate", "emptyObject", "freeze", "SchedulerEventNavigation", "Delayable", "allowCtrlKey", "scrollSilently", "Space", "Enter", "Backspace", "Escape", "Tab", "isNavigationKey", "focusCls", "enableDeleteKey", "onDeleteKeyBuffer", "navigatePreviousBuffer", "navigateNextBuffer", "testConfig", "isInTimeAxis", "bind", "onDeleteKey", "throttle", "changeNavigator", "Navigator", "mergeConfigs", "ownerCmp", "processEvent", "itemSelector", "eventCls", "navigatePrevious", "delay", "throttled", "navigateNext", "instanceMeta", "excluded", "isTimeSpanInAxis", "onElementKeyDown", "keyEvent", "_me$focusedCell", "_me$focusedCell2", "focusedCell", "rowIndex", "column", "timeAxisColumn", "key", "firstAssignment", "getFirstVisibleAssignment", "navigateTo", "uiEvent", "_super$onElementKeyDo", "location", "currentOrientation", "rowManager", "_renderedEvents", "renderedEvents", "rowMap", "getRow", "_renderedEvents$", "elementData", "_currentOrientation$r", "_renderedEvents2", "resourceMap", "id", "eventsData", "_renderedEvents$filte", "isAvailable", "firstResource", "renderData", "onGridBodyFocusIn", "focusEvent", "isGridCellFocus", "focusableSelector", "navigationEvent", "eventFocus", "destinationCell", "normalizeCellContext", "indexOf", "Location", "_me$onCellNavigate", "_focusedCell", "onCellNavigate", "scrollIntoView", "accessibleFocusCell", "cellSelector", "columnId", "focusCell", "normalizeTarget", "getPrevious", "isDelete", "eventSorter", "resourceEvents", "getEvents", "resource", "sort", "previousEvent", "rowIdx", "getAt", "events", "getAssignmentForEventAndResource", "previousAssignment", "ctrlKey", "clearEventSelection", "doGridNavigation", "getNext", "nextEvent", "nextAssignment", "handled", "targetAssignment", "skipScrollIntoView", "scrollAssignmentIntoView", "getElementFromAssignmentRecord", "activeAssignment", "assignmentEl", "previousActiveEvent", "previousActiveItem", "r", "onArrowUpKey", "onArrowDownKey", "onEscapeKey", "onEventSpaceKey", "onEventEnterKey", "isActionableLocation"]
}
