{
  "version": 3,
  "sources": ["../../../../chronograph/src/util/Helpers.js", "../../../../chronograph/src/environment/Debug.js", "../../../../chronograph/src/class/RequiredProperty.js", "../../../../chronograph/src/graph/WalkDepth.js", "../../../../chronograph/src/cycle_resolver/CycleResolver.js", "../../../../chronograph/src/chrono/Effect.js", "../../../../chronograph/src/chrono/CycleResolver.js", "../../../../chronograph/src/primitives/Calculation.js", "../../../../chronograph/src/chrono/Quark.js", "../../../../chronograph/src/chrono/Identifier.js", "../../../../chronograph/src/chrono/Revision.js", "../../../../chronograph/src/util/LeveledQueue.js", "../../../../chronograph/src/chrono/TransactionCycleDetectionWalkContext.js", "../../../../chronograph/src/chrono/TransactionWalkDepth.js", "../../../../chronograph/src/chrono/Transaction.js", "../../../../chronograph/src/chrono/Graph.js", "../../../../chronograph/src/schema/EntityMeta.js", "../../../../chronograph/src/replica/Replica.js", "../../../../chronograph/src/replica/Identifier.js", "../../../../chronograph/src/schema/Field.js", "../../../../chronograph/src/replica/Entity.js", "../../../../chronograph/src/replica/Reference.js", "../../../../chronograph/src/replica/ReferenceBucket.js", "../../../../chronograph/src/schema/Schema.js", "../../../../Engine/lib/Engine/chrono/ModelFieldAtom.js", "../../../../Engine/lib/Engine/chrono/ChronoModelMixin.js", "../../../../Engine/lib/Engine/localization/En.js", "../../../../Engine/lib/Engine/scheduling/DateInterval.js", "../../../../Engine/lib/Engine/chrono/SchedulingIssueEffect.js", "../../../../Engine/lib/Engine/chrono/Conflict.js", "../../../../Engine/lib/Engine/quark/ChronoPartOfProjectGenericMixin.js", "../../../../Engine/lib/Engine/quark/store/mixin/ChronoStoreMixin.js", "../../../../Engine/lib/Engine/quark/store/mixin/ChronoPartOfProjectStoreMixin.js", "../../../../Engine/lib/Engine/quark/model/mixin/ChronoPartOfProjectModelMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseCalendarMixin.js", "../../../../Engine/lib/Engine/chrono/Replica.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseAssignmentMixin.js", "../../../../Engine/lib/Engine/quark/store/ChronoAssignmentStoreMixin.js", "../../../../Engine/lib/Engine/quark/store/ChronoCalendarManagerStoreMixin.js", "../../../../Engine/lib/Engine/quark/store/ChronoDependencyStoreMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseEventDispatcher.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/HasCalendarMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseEventMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseHasAssignmentsMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/HasDependenciesMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicEvent.js", "../../../../Engine/lib/Engine/quark/store/ChronoEventStoreMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseResourceMixin.js", "../../../../Engine/lib/Engine/quark/store/ChronoResourceStoreMixin.js", "../../../../Engine/lib/Engine/scheduling/DurationConverterMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/BaseDependencyMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/ChronoAbstractProjectMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/HasSubEventsMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/HasChildrenMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicProjectMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/ConstrainedEarlyEventMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/HasDateConstraintMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/ScheduledByDependenciesEarlyEventMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProAssignmentMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProDependencyMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/HasPercentDoneMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProHasAssignmentsMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProEventSegment.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SplitEventMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/HasEffortMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/HasEffortDispatcher.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/HasSchedulingModeMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/scheduling_modes/FixedDurationDispatcher.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/scheduling_modes/FixedDurationMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProEvent.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProResourceMixin.js", "../../../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProProjectMixin.js", "../../../lib/SchedulerPro/widget/ModelCombo.js", "../../../lib/SchedulerPro/widget/CalendarField.js", "../../../lib/SchedulerPro/data/mixin/PartOfProject.js", "../../../lib/SchedulerPro/model/AssignmentModel.js", "../../../lib/SchedulerPro/data/AssignmentStore.js", "../../../lib/SchedulerPro/model/CalendarIntervalModel.js", "../../../lib/SchedulerPro/model/CalendarModel.js", "../../../lib/SchedulerPro/data/CalendarManagerStore.js", "../../../lib/SchedulerPro/model/DependencyModel.js", "../../../lib/SchedulerPro/data/DependencyStore.js", "../../../lib/SchedulerPro/model/mixin/PercentDoneMixin.js", "../../../lib/SchedulerPro/model/EventSegmentModel.js", "../../../lib/SchedulerPro/data/stm/action/EventUpdateAction.js", "../../../lib/SchedulerPro/model/ResourceModel.js", "../../../lib/SchedulerPro/data/ResourceStore.js", "../../../lib/SchedulerPro/data/stm/StateTrackingManager.js", "../../../lib/SchedulerPro/model/VersionModel.js", "../../../lib/SchedulerPro/data/VersionStore.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogTransactionModel.js", "../../../lib/SchedulerPro/data/ChangeLogStore.js", "../../../lib/SchedulerPro/data/mixin/ProjectCrudManager.js", "../../../lib/SchedulerPro/feature/EventResize.js", "../../../lib/SchedulerPro/feature/EventSegmentResize.js", "../../../lib/SchedulerPro/feature/EventSegments.js", "../../../lib/SchedulerPro/feature/PercentBar.js", "../../../lib/SchedulerPro/widget/taskeditor/mixin/ReadyStatePropagator.js", "../../../lib/SchedulerPro/localization/En.js", "../../../lib/SchedulerPro/widget/TaskEditorBase.js", "../../../lib/SchedulerPro/widget/taskeditor/mixin/EventLoader.js", "../../../lib/SchedulerPro/widget/taskeditor/EditorTab.js", "../../../lib/SchedulerPro/widget/taskeditor/FormTab.js", "../../../lib/SchedulerPro/widget/StartDateField.js", "../../../lib/SchedulerPro/widget/EndDateField.js", "../../../lib/SchedulerPro/widget/EffortField.js", "../../../lib/SchedulerPro/widget/taskeditor/GeneralTab.js", "../../../lib/SchedulerPro/widget/DependencyTypePicker.js", "../../../lib/SchedulerPro/widget/taskeditor/DependencyTab.js", "../../../lib/SchedulerPro/widget/taskeditor/SuccessorsTab.js", "../../../lib/SchedulerPro/widget/taskeditor/PredecessorsTab.js", "../../../lib/SchedulerPro/widget/taskeditor/ResourcesTab.js", "../../../lib/SchedulerPro/widget/ConstraintTypePicker.js", "../../../lib/SchedulerPro/widget/SchedulingModePicker.js", "../../../lib/SchedulerPro/widget/taskeditor/AdvancedTab.js", "../../../lib/SchedulerPro/widget/taskeditor/NotesTab.js", "../../../lib/SchedulerPro/widget/GanttTaskEditor.js", "../../../lib/SchedulerPro/widget/taskeditor/SchedulerGeneralTab.js", "../../../lib/SchedulerPro/widget/taskeditor/RecurrenceTab.js", "../../../lib/SchedulerPro/widget/taskeditor/SchedulerAdvancedTab.js", "../../../lib/SchedulerPro/widget/SchedulerTaskEditor.js", "../../../lib/SchedulerPro/feature/TaskEdit.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogEntity.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogDependencyEntity.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogAssignmentEntity.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogAction.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogMoveAction.js", "../../../lib/SchedulerPro/model/changelog/ChangeLogUpdateAction.js", "../../../lib/SchedulerPro/feature/Versions.js", "../../../lib/SchedulerPro/model/mixin/ProjectChangeHandlerMixin.js", "../../../lib/SchedulerPro/model/mixin/ProjectWebSocketHandlerMixin.js", "../../../lib/SchedulerPro/view/mixin/ProjectProgressMixin.js", "../../../lib/SchedulerPro/widget/SchedulingIssueResolutionPopup.js", "../../../lib/SchedulerPro/widget/CycleResolutionPopup.js", "../../../lib/SchedulerPro/view/mixin/SchedulingIssueResolution.js"],
  "sourcesContent": ["//---------------------------------------------------------------------------------------------------------------------\n// assume 32-bit platform (https://v8.dev/blog/react-cliff)\nimport { CI } from \"../collection/Iterator.js\";\nexport const MIN_SMI = -Math.pow(2, 30);\nexport const MAX_SMI = Math.pow(2, 30) - 1;\n//---------------------------------------------------------------------------------------------------------------------\nexport const uppercaseFirst = (str) => str.slice(0, 1).toUpperCase() + str.slice(1);\n//---------------------------------------------------------------------------------------------------------------------\nexport const isAtomicValue = (value) => Object(value) !== value;\n//---------------------------------------------------------------------------------------------------------------------\nexport const typeOf = (value) => Object.prototype.toString.call(value).slice(8, -1);\n//---------------------------------------------------------------------------------------------------------------------\nexport const defineProperty = (target, property, value) => {\n    Object.defineProperty(target, property, { value, enumerable: true, configurable: true });\n    return value;\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const prototypeValue = (value) => {\n    return function (target, propertyKey) {\n        target[propertyKey] = value;\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const copyMapInto = (sourceMap, targetMap) => {\n    for (const [key, value] of sourceMap)\n        targetMap.set(key, value);\n    return targetMap;\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const copySetInto = (sourceSet, targetSet) => {\n    for (const value of sourceSet)\n        targetSet.add(value);\n    return targetSet;\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const delay = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));\n//---------------------------------------------------------------------------------------------------------------------\nexport const matchAll = function* (regexp, testStr) {\n    let match;\n    while ((match = regexp.exec(testStr)) !== null) {\n        yield match;\n    }\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const allMatches = function (regexp, testStr) {\n    return CI(matchAll(regexp, testStr)).map(match => CI(match).drop(1)).concat().toArray();\n};\nlet isRegeneratorRuntime = null;\nexport const isGeneratorFunction = function (func) {\n    if (isRegeneratorRuntime === null)\n        isRegeneratorRuntime = typeof regeneratorRuntime !== 'undefined';\n    if (isRegeneratorRuntime === true) {\n        return regeneratorRuntime.isGeneratorFunction(func);\n    }\n    else {\n        return func.constructor.name === 'GeneratorFunction';\n    }\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const isPromise = function (obj) {\n    return obj && typeof obj.then === 'function';\n};\n", "import { Base } from \"../class/Base.js\";\nimport { CI } from \"../collection/Iterator.js\";\nimport { matchAll } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const DEBUG = false;\nconst emptyFn = (...args) => undefined;\nexport const DEBUG_ONLY = (func) => DEBUG ? func : emptyFn;\nexport const debug = DEBUG_ONLY((e) => {\n    debugger;\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport const warn = DEBUG_ONLY((e) => {\n    if (typeof console !== 'undefined')\n        console.warn(e);\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport class StackEntry extends Base {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class SourceLinePoint extends Base {\n    constructor() {\n        super(...arguments);\n        this.stackEntries = [];\n    }\n    static fromError(e) {\n        const res = SourceLinePoint.new({\n            exception: e,\n            stackEntries: parseErrorStack(e.stack)\n        });\n        return res;\n    }\n    static fromThisCall() {\n        const sourceLinePoint = this.fromError(new Error());\n        sourceLinePoint.stackEntries.splice(0, 2);\n        return sourceLinePoint;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n// sample stack\n// Error\n//     at exceptionCatcher (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/environment/Debug.js:15:11)\n//     at Function.fromCurrentCall (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/environment/Debug.js:39:38)\n//     at Object.get (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/replica/Entity.js:31:73)\n//     at MinimalGanttProject.set (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/replica/Entity.js:222:23)\n//     at MinimalGanttProject.set data [as data] (http://lh/bryntum-suite/SchedulingEngine/lib/Engine/chrono/ChronoModelMixin.js:48:31)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Core/data/Model.js:290:17)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Core/mixin/Events.js:236:15)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Engine/chrono/ChronoModelMixin.js:21:19)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicProjectMixin.js:53:19)\n//     at new Base (http://lh/bryntum-suite/SchedulingEngine/lib/Core/Base.js:55:14)\"\nconst parseErrorStack = (stack) => {\n    return CI(matchAll(/^   +at\\s*(.*?)\\s*\\((https?:\\/\\/.*?):(\\d+):(\\d+)/gm, stack))\n        .map(match => StackEntry.new({\n        statement: match[1],\n        sourceFile: match[2],\n        sourceLine: Number(match[3]),\n        sourceCharPos: Number(match[4])\n    }))\n        .toArray();\n};\n", "import { DEBUG_ONLY } from \"../environment/Debug.js\";\nconst RequiredProperties = Symbol('RequiredProperties');\nconst emptyFn = () => undefined;\nexport const required = DEBUG_ONLY((proto, propertyKey) => {\n    let required = proto[RequiredProperties];\n    if (!required)\n        required = proto[RequiredProperties] = [];\n    required.push(propertyKey);\n});\nexport const validateRequiredProperties = DEBUG_ONLY((context) => {\n    const required = context[RequiredProperties];\n    if (required) {\n        for (let i = 0; i < required.length; i++)\n            if (context[required[i]] === undefined)\n                throw new Error(`Required attribute [${String(required[i])}] is not provided`);\n    }\n});\n", "import { Base } from \"../class/Base.js\";\nexport var OnCycleAction;\n(function (OnCycleAction) {\n    OnCycleAction[\"Cancel\"] = \"Cancel\";\n    OnCycleAction[\"Resume\"] = \"Resume\";\n})(OnCycleAction || (OnCycleAction = {}));\n//---------------------------------------------------------------------------------------------------------------------\nexport const WalkSource = Symbol('WalkSource');\nexport const NOT_VISITED = -1;\nexport const VISITED_TOPOLOGICALLY = -2;\n//---------------------------------------------------------------------------------------------------------------------\nexport class WalkContext extends Base {\n    constructor() {\n        super(...arguments);\n        this.visited = new Map();\n        this.toVisit = [];\n        this.currentEpoch = 0;\n    }\n    startFrom(sourceNodes) {\n        this.continueFrom(sourceNodes);\n    }\n    continueFrom(sourceNodes) {\n        this.toVisit.push.apply(this.toVisit, sourceNodes.map(node => { return { node: node, from: WalkSource, label: undefined }; }));\n        this.walkDepth();\n    }\n    onNode(node, walkStep) {\n    }\n    onTopologicalNode(node) {\n    }\n    onCycle(node, stack) {\n        return OnCycleAction.Cancel;\n    }\n    forEachNext(node, func) {\n        throw new Error(\"Abstract method called\");\n    }\n    collectNext(node, toVisit, visitInfo) {\n        throw new Error(\"Abstract method called\");\n    }\n    getVisitedInfo(node) {\n        return this.visited.get(node);\n    }\n    setVisitedInfo(node, visitedAt, info) {\n        if (!info) {\n            info = { visitedAt, visitEpoch: this.currentEpoch };\n            this.visited.set(node, info);\n        }\n        else {\n            info.visitedAt = visitedAt;\n            info.visitEpoch = this.currentEpoch;\n        }\n        return info;\n    }\n    walkDepth() {\n        const visited = this.visited;\n        const toVisit = this.toVisit;\n        let depth;\n        while (depth = toVisit.length) {\n            const node = toVisit[depth - 1].node;\n            const visitedInfo = this.getVisitedInfo(node);\n            // this supports the \"ahead-of-time\" creation of the \"visited\" entries, which actually lead to improved benchmarks,\n            // so it might be a default\n            if (visitedInfo && visitedInfo.visitedAt === VISITED_TOPOLOGICALLY && visitedInfo.visitEpoch === this.currentEpoch) {\n                toVisit.pop();\n                continue;\n            }\n            if (visitedInfo && visitedInfo.visitEpoch === this.currentEpoch && visitedInfo.visitedAt !== NOT_VISITED) {\n                // it is valid to find itself \"visited\", but only if visited at the current depth\n                // (which indicates stack unwinding)\n                // if the node has been visited at earlier depth - its a cycle\n                if (visitedInfo.visitedAt < depth) {\n                    // ONLY resume if explicitly returned `Resume`, cancel in all other cases (undefined, etc)\n                    if (this.onCycle(node, toVisit) !== OnCycleAction.Resume)\n                        break;\n                }\n                else {\n                    visitedInfo.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node);\n                }\n                toVisit.pop();\n            }\n            else {\n                // if we break here, we can re-enter the loop later\n                if (this.onNode(node, toVisit[depth - 1]) === false)\n                    break;\n                // first entry to the node\n                const visitedInfo2 = this.setVisitedInfo(node, depth, visitedInfo);\n                const lengthBefore = toVisit.length;\n                this.collectNext(node, toVisit, visitedInfo2);\n                // if there's no outgoing edges, node is at topological position\n                // it would be enough to just continue the `while` loop and the `onTopologicalNode`\n                // would happen on next iteration, but with this \"inlining\" we save one call to `visited.get()`\n                // at the cost of length comparison\n                if (toVisit.length === lengthBefore) {\n                    visitedInfo2.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node);\n                    toVisit.pop();\n                }\n            }\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function cycleInfo(stack) {\n    const length = stack.length;\n    if (length === 0)\n        return [];\n    const cycleSource = stack[length - 1].node;\n    const cycle = [cycleSource];\n    let current = length - 1;\n    let cursor = current;\n    while (current >= 0 && stack[current].from !== cycleSource) {\n        // going backward in steps, skipping the nodes with identical `from`\n        while (current >= 0 && stack[current].from === stack[cursor].from)\n            current--;\n        if (current >= 0) {\n            // the first node with different `from` will be part of the cycle path\n            cycle.push(stack[current].node);\n            cursor = current;\n        }\n    }\n    // no cycle\n    if (current < 0)\n        return [];\n    cycle.push(cycleSource);\n    return cycle.reverse();\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base } from \"../class/Base.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { required, validateRequiredProperties } from \"../class/RequiredProperty.js\";\nimport { CI, concatIterable, map, uniqueOnly } from \"../collection/Iterator.js\";\nimport { DEBUG } from \"../environment/Debug.js\";\nimport { OnCycleAction, WalkContext } from \"../graph/WalkDepth.js\";\nlet FORMULA_ID = 0;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Pre-defined constant formula id. If assigned to some variable, specifies, that this variable should keep the value proposed by user\n * (user input), or, if there's none, its previous value.\n */\nexport const CalculateProposed = FORMULA_ID++;\n// export const CalculatePure : FormulaId          = FORMULA_ID++\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Class, describing a formula, which is part of the cyclic set. Formula just specifies its input variables and output variable,\n * it does not contain actual calculation.\n *\n * It is assumed that formula can only be \"activated\" if all of its inputs has value. It can be either a value from the previous iteration,\n * a value provided by user, or an output value of some other formula. See [[VariableInputState]] and [[CycleResolutionInput]].\n */\nexport class Formula extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * The id of the formula. It is assigned automatically, should not be changed.\n         */\n        this.formulaId = FORMULA_ID++;\n        /**\n         * A set of the input variables for this formula.\n         */\n        this.inputs = new Set();\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class VariableWalkContext extends WalkContext {\n    collectNext(sourceNode, toVisit) {\n        if (sourceNode instanceof Formula) {\n            toVisit.push({ node: sourceNode.output, from: sourceNode, label: undefined });\n        }\n        else {\n            const formulas = this.cache.formulasByInput.get(sourceNode);\n            formulas && formulas.forEach(formula => toVisit.push({ node: formula, from: sourceNode, label: undefined }));\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class FormulasCache extends Mixin([Base], (base) => class FormulasCache extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * A set of variables, which forms cyclic computation\n         */\n        this.variables = new Set();\n        /**\n         * A set of formulas, which forms cyclic computation\n         */\n        this.formulas = new Set();\n        this.$formulasByInput = undefined;\n        this.$formulasByOutput = undefined;\n    }\n    get formulasByInput() {\n        if (this.$formulasByInput !== undefined)\n            return this.$formulasByInput;\n        this.fillCache();\n        return this.$formulasByInput;\n    }\n    get formulasByOutput() {\n        if (this.$formulasByOutput !== undefined)\n            return this.$formulasByOutput;\n        this.fillCache();\n        return this.$formulasByOutput;\n    }\n    add(formula) {\n        this.$formulasByInput = undefined;\n        this.$formulasByOutput = undefined;\n        this.formulas.add(formula);\n    }\n    has(formula) {\n        return this.formulas.has(formula);\n    }\n    fillCache() {\n        this.$formulasByInput = new Map();\n        this.$formulasByOutput = new Map();\n        this.formulas.forEach(formula => {\n            let formulasByOutput = this.$formulasByOutput.get(formula.output);\n            if (!formulasByOutput) {\n                formulasByOutput = new Set();\n                this.$formulasByOutput.set(formula.output, formulasByOutput);\n            }\n            formulasByOutput.add(formula);\n            formula.inputs.forEach(input => {\n                let formulasByInput = this.$formulasByInput.get(input);\n                if (!formulasByInput) {\n                    formulasByInput = new Set();\n                    this.$formulasByInput.set(input, formulasByInput);\n                }\n                formulasByInput.add(formula);\n            });\n        });\n    }\n    allInputVariables() {\n        return uniqueOnly(concatIterable(map(this.formulas, formula => formula.inputs.values())));\n    }\n    isCyclic() {\n        let isCyclic = false;\n        const walkContext = VariableWalkContext.new({ cache: this, onCycle: () => { isCyclic = true; return OnCycleAction.Cancel; } });\n        walkContext.startFrom(Array.from(this.allInputVariables()));\n        return isCyclic;\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Abstract description of the cycle. Does not include the default formula resolution, only variables and formulas. See also [[CycleResolution]].\n */\nexport class CycleDescription extends FormulasCache {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Class describing the cycle resolution process. Requires the abstract cycle [[description]] and a set of default formulas.\n *\n * The resolution is performed with [[CycleResolution.resolve]] method.\n *\n * Resolution are memoized, based on the input. You should generally have a single instance of this class for a single set of default formulas,\n * to accumulate the results and make resolution fast.\n */\nexport class CycleResolution extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Abstract cycle description for this resolution.\n         */\n        this.description = undefined;\n        /**\n         * A set of default formulas for this resolution. Default formulas specifies how the calculation should be performed, if there's no user input\n         * for any variable (or there's input for all of them). Also, default formulas are preferred, if several formulas can be chosen to continue the resolution.\n         */\n        this.defaultResolutionFormulas = new Set();\n        this.resolutionsByInputHash = new Map();\n    }\n    // the caching space is 3^var_num might need to clear the memory at some time\n    clear() {\n        this.resolutionsByInputHash.clear();\n    }\n    /**\n     * This method accepts an input object and returns a cycle resolution.\n     * Resolution are memoized, based on the input.\n     *\n     * @param input\n     */\n    resolve(input) {\n        const cached = this.resolutionsByInputHash.get(input.hash);\n        if (cached !== undefined)\n            return cached;\n        const resolution = this.buildResolution(input);\n        this.resolutionsByInputHash.set(input.hash, resolution);\n        return resolution;\n    }\n    buildResolution(input) {\n        const walkContext = WalkState.new({ context: this, input });\n        const allResolutions = Array.from(walkContext.next()).map(state => {\n            return {\n                resolution: state.asResolution(),\n                nbrOfDefaultFormulas: Array.from(state.activatedFormulas.formulas).reduce((count, formula) => state.formulaIsDefault(formula) ? count + 1 : count, 0),\n                unCoveredInputWeight: state.unCoveredInputWeight()\n            };\n        });\n        allResolutions.sort((res1, res2) => {\n            if (res1.unCoveredInputWeight < res2.unCoveredInputWeight)\n                return -1;\n            if (res1.unCoveredInputWeight > res2.unCoveredInputWeight)\n                return 1;\n            return res2.nbrOfDefaultFormulas - res1.nbrOfDefaultFormulas;\n        });\n        if (allResolutions.length > 0)\n            return allResolutions[0].resolution;\n        else\n            debugger; // return default? or all-proposed?\n    }\n}\n/**\n * Enumeration for various states of the input data for variables in the cycle. Individual members corresponds to binary bits and can be set simultaneously, like:\n *\n * ```ts\n * const input : VariableInputState = VariableInputState.HasPreviousValue | VariableInputState.HasProposedValue\n * ```\n */\nexport var VariableInputState;\n(function (VariableInputState) {\n    VariableInputState[VariableInputState[\"NoInput\"] = 0] = \"NoInput\";\n    /**\n     * This bit indicates that variable has some previous value, when resolution starts. It can be any non-`undefined` value, including `null`.\n     */\n    VariableInputState[VariableInputState[\"HasPreviousValue\"] = 1] = \"HasPreviousValue\";\n    /**\n     * This bit indicates that variable has user input, when resolution starts. It can be any non-`undefined` value, including `null`.\n     */\n    VariableInputState[VariableInputState[\"HasProposedValue\"] = 2] = \"HasProposedValue\";\n    /**\n     * This bit indicates, that user intention is to keep this variable unchanged, if that is possible (does not contradict to other user input).\n     */\n    VariableInputState[VariableInputState[\"KeepIfPossible\"] = 4] = \"KeepIfPossible\";\n})(VariableInputState || (VariableInputState = {}));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Class, describing the input data for a set of variables during cycle resolution.\n */\nexport class CycleResolutionInput extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * A cycle resolution instance this input corresponds to.\n         */\n        this.context = undefined;\n        this.input = undefined;\n        this.$hash = '';\n    }\n    get hash() {\n        if (this.$hash !== '')\n            return this.$hash;\n        return this.$hash = this.buildHash();\n    }\n    get description() { return this.context.description; }\n    /**\n     * Returns the same result as calling [[CycleResolution.resolve]] on this input instance\n     */\n    get resolution() {\n        return this.context.resolve(this);\n    }\n    initialize(...args) {\n        super.initialize(...args);\n        validateRequiredProperties(this);\n        this.input = new Map(CI(this.description.variables).map(variable => [variable, VariableInputState.NoInput]));\n    }\n    buildHash() {\n        return String.fromCharCode(...CI(this.description.variables).inBatchesBySize(5).map(batch => this.batchToCharCode(batch)));\n    }\n    batchToCharCode(batch) {\n        return batch.reduceRight((charCode, variable, index) => charCode | (this.input.get(variable) << index * 3), 0);\n    }\n    //---------------------\n    /**\n     * This method sets the [[HasProposedValue]] flag for the specified variable.\n     *\n     * @param variable\n     */\n    addProposedValueFlag(variable) {\n        if (DEBUG) {\n            if (!this.description.variables.has(variable))\n                throw new Error('Unknown variable');\n            if (this.$hash !== '')\n                throw new Error('Already hashed');\n        }\n        const input = this.input.get(variable);\n        this.input.set(variable, input | VariableInputState.HasProposedValue);\n    }\n    hasProposedValue(variable) {\n        return Boolean(this.input.get(variable) & VariableInputState.HasProposedValue);\n    }\n    hasProposedValueVars() {\n        return CI(this.description.variables).filter(variable => this.hasProposedValue(variable));\n    }\n    //---------------------\n    /**\n     * This method sets the [[HasPreviousValue]] flag for the specified variable.\n     *\n     * @param variable\n     */\n    addPreviousValueFlag(variable) {\n        if (DEBUG) {\n            if (!this.description.variables.has(variable))\n                throw new Error('Unknown variable');\n            if (this.$hash !== '')\n                throw new Error('Already hashed');\n        }\n        const input = this.input.get(variable);\n        this.input.set(variable, input | VariableInputState.HasPreviousValue);\n    }\n    hasPreviousValue(variable) {\n        return Boolean(this.input.get(variable) & VariableInputState.HasPreviousValue);\n    }\n    hasPreviousValueVars() {\n        return CI(this.description.variables).filter(variable => this.hasPreviousValue(variable));\n    }\n    //---------------------\n    /**\n     * This method sets the [[KeepIfPossible]] flag for the specified variable.\n     *\n     * @param variable\n     */\n    addKeepIfPossibleFlag(variable) {\n        if (DEBUG) {\n            if (!this.description.variables.has(variable))\n                throw new Error('Unknown variable');\n            if (this.$hash !== '')\n                throw new Error('Already hashed');\n        }\n        const input = this.input.get(variable);\n        this.input.set(variable, input | VariableInputState.KeepIfPossible);\n    }\n    keepIfPossible(variable) {\n        return Boolean(this.input.get(variable) & VariableInputState.KeepIfPossible);\n    }\n    keepIfPossibleVars() {\n        return CI(this.description.variables).filter(variable => this.keepIfPossible(variable));\n    }\n}\n__decorate([\n    required\n], CycleResolutionInput.prototype, \"context\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\nexport class WalkState extends Base {\n    constructor() {\n        super(...arguments);\n        this.context = undefined;\n        this.input = undefined;\n        this.previous = undefined;\n        this.activatedFormula = undefined;\n        this.$activatedFormulas = undefined;\n    }\n    get activatedFormulas() {\n        if (this.$activatedFormulas !== undefined)\n            return this.$activatedFormulas;\n        const cache = FormulasCache.new({\n            variables: this.description.variables,\n            formulas: CI(this.thisAndPreviousStates()).map(state => state.activatedFormula).toSet()\n        });\n        return this.$activatedFormulas = cache;\n    }\n    get description() { return this.context.description; }\n    *thisAndPreviousStates() {\n        let current = this;\n        while (current && current.activatedFormula) {\n            yield current;\n            current = current.previous;\n        }\n    }\n    formulaHasProposedValueInInput(formula) {\n        return Array.from(formula.inputs).some(variable => this.input.hasProposedValue(variable));\n    }\n    // this method counts\n    unCoveredInputWeight() {\n        const proposedVars = map(this.input.hasProposedValueVars(), variable => { return { variable, isProposed: true }; });\n        const keepIfPossibleVars = map(this.input.keepIfPossibleVars(), variable => { return { variable, isProposed: false }; });\n        const allInputVars = CI([proposedVars, keepIfPossibleVars]).concat().uniqueOnlyBy(el => el.variable);\n        return allInputVars.reduce((totalWeight, { variable, isProposed }) => {\n            let weight = 0;\n            //-----------------\n            const isOverwrittenByFormulas = this.activatedFormulas.formulasByOutput.get(variable);\n            if (isOverwrittenByFormulas) {\n                const formula = isOverwrittenByFormulas.size === 1 ? Array.from(isOverwrittenByFormulas)[0] : null;\n                // the case, when some user input is overwritten with the default formula should be weighted less than\n                // its overwritten with regular formula\n                if (formula && this.formulaIsDefault(formula) && this.formulaHasProposedValueInInput(formula)) {\n                    if (isProposed)\n                        weight += 1e6;\n                    else\n                        weight += 1e4;\n                }\n                else {\n                    if (isProposed)\n                        weight += 1e7;\n                    else\n                        weight += 1e5;\n                }\n            }\n            //-----------------\n            const usedInFormulas = this.activatedFormulas.formulasByInput.get(variable);\n            if (!(usedInFormulas && usedInFormulas.size > 0)) {\n                if (isProposed)\n                    weight += 1e3;\n                else\n                    weight += 1e2;\n            }\n            return totalWeight + weight;\n        }, 0);\n    }\n    preferFormula(formula1, formula2) {\n        const allInputsHasProposed1 = this.formulaAllInputsHasProposed(formula1);\n        const allInputsHasProposed2 = this.formulaAllInputsHasProposed(formula2);\n        if (allInputsHasProposed1 && !allInputsHasProposed2)\n            return -1;\n        if (allInputsHasProposed2 && !allInputsHasProposed1)\n            return 1;\n        const countInputsWithProposedOrKeep1 = this.formulaCountInputsWithProposedOrKeep(formula1);\n        const countInputsWithProposedOrKeep2 = this.formulaCountInputsWithProposedOrKeep(formula2);\n        if (countInputsWithProposedOrKeep1 > countInputsWithProposedOrKeep2)\n            return -1;\n        if (countInputsWithProposedOrKeep1 < countInputsWithProposedOrKeep2)\n            return 1;\n        if (this.formulaIsDefault(formula1) && !this.formulaIsDefault(formula2))\n            return -1;\n        if (this.formulaIsDefault(formula2) && !this.formulaIsDefault(formula1))\n            return 1;\n        return 0;\n    }\n    formulaIsDefault(formula) {\n        return this.context.defaultResolutionFormulas.has(formula);\n    }\n    formulaCountInputsWithProposedOrKeep(formula) {\n        let count = 0;\n        Array.from(formula.inputs).forEach(variable => {\n            if (this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable))\n                count++;\n        });\n        return count;\n    }\n    formulaAllInputsHasProposedOrKeep(formula) {\n        return Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable));\n    }\n    formulaAllInputsHasProposed(formula) {\n        return Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable));\n    }\n    formulaIsApplicable(formula) {\n        const everyFormulaInputHasValue = Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable)\n            || this.input.hasPreviousValue(variable)\n            || this.activatedFormulas.formulasByOutput.has(variable));\n        const cache = FormulasCache.new({ formulas: new Set(this.activatedFormulas.formulas) });\n        cache.add(formula);\n        return everyFormulaInputHasValue && !cache.isCyclic();\n    }\n    // in general the semantic of this method is very similar to `formulaIsApplicable`\n    formulaIsInsignificant(formula) {\n        const outputVariableAlreadyCalculated = this.activatedFormulas.formulasByOutput.has(formula.output);\n        const outputVariableHasPreviousValue = this.input.hasPreviousValue(formula.output);\n        return outputVariableAlreadyCalculated\n            || outputVariableHasPreviousValue && Array.from(formula.inputs).some(variable => {\n                // so we should ignore the formula, if some of its inputs\n                // does not have value provided (neither previous nor proposed)\n                return !this.input.hasPreviousValue(variable) && !this.input.hasProposedValue(variable)\n                    // ..and we haven't planned calculation of that input via another formula\n                    && !this.activatedFormulas.formulasByOutput.has(variable);\n            });\n    }\n    unvisitedFormulas() {\n        return Array.from(this.description.formulas).filter(formula => !this.activatedFormulas.has(formula));\n    }\n    *next() {\n        const unvisitedFormulas = this.unvisitedFormulas();\n        unvisitedFormulas.sort(this.preferFormula.bind(this));\n        let isFinal = true;\n        for (const formula of unvisitedFormulas) {\n            if (!this.formulaIsApplicable(formula) || this.formulaIsInsignificant(formula))\n                continue;\n            const nextState = WalkState.new({\n                previous: this,\n                context: this.context,\n                input: this.input,\n                activatedFormula: formula\n            });\n            yield* nextState.next();\n            isFinal = false;\n        }\n        if (isFinal)\n            yield this;\n    }\n    asResolution() {\n        return new Map(CI(this.description.variables).map(variable => {\n            const formulas = this.activatedFormulas.formulasByOutput.get(variable);\n            if (formulas) {\n                for (const firstFormula of formulas) {\n                    return [variable, firstFormula.formulaId];\n                }\n            }\n            return [variable, CalculateProposed];\n        }));\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base } from \"../class/Base.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const BreakCurrentStackExecution = Symbol('BreakCurrentStackExecution');\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * The base class for effect. Effect is some value, that can be send to the \"outer\" calculation context, using the\n * effect handler function. Effect handler then will process an effect and return some resulting value.\n *\n * ```ts\n * const identifier  = graph.identifier((Y : SyncEffectHandler) : number => {\n *     const proposedValue : number    = Y(ProposedOrPrevious)\n *\n *     const maxValue : number         = Y(max)\n *\n *     return proposedValue <= maxValue ? proposedValue : maxValue\n * })\n * ```\n */\nexport class Effect extends Base {\n}\n__decorate([\n    prototypeValue(true)\n], Effect.prototype, \"sync\", void 0);\n__decorate([\n    prototypeValue(true)\n], Effect.prototype, \"pure\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedOrPreviousSymbol = Symbol('ProposedOrPreviousSymbol');\n/**\n * The constant that represents a request for either user input (proposed value) or previous value of the\n * identifier, currently being calculated.\n *\n * Important note, is that if an identifier yields a `ProposedOrPrevious` effect and its computed value does not match the value of this effect,\n * it will be re-calculated (computation function called) again on the next read. This is because the value of its `ProposedOrPrevious` input changes.\n *\n * ```ts\n * const graph4 = ChronoGraph.new()\n *\n * const max           = graph4.variable(100)\n *\n * const identifier15  = graph4.identifier((Y) : number => {\n *     const proposedValue : number    = Y(ProposedOrPrevious)\n *\n *     const maxValue : number         = Y(max)\n *\n *     return proposedValue <= maxValue ? proposedValue : maxValue\n * })\n *\n * graph4.write(identifier15, 18)\n *\n * const value15_1 = graph4.read(identifier15) // 18\n *\n * graph4.write(identifier15, 180)\n *\n * const value15_2 = graph4.read(identifier15) // 100\n *\n * graph4.write(max, 50)\n *\n * const value15_3 = graph4.read(identifier15) // 50\n * ```\n */\nexport const ProposedOrPrevious = Effect.new({ handler: ProposedOrPreviousSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const RejectSymbol = Symbol('RejectSymbol');\n/**\n * Class for [[Reject]] effect.\n */\nexport class RejectEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = RejectSymbol;\n    }\n}\n__decorate([\n    prototypeValue(false)\n], RejectEffect.prototype, \"pure\", void 0);\n/**\n * This is constructor for `RejectEffect` class. If this effect will be yielded during computation the current transaction\n * will be [[ChronoGraph.reject|rejected]].\n *\n * @param reason\n * @constructor\n */\nexport const Reject = (reason) => RejectEffect.new({ reason });\n//---------------------------------------------------------------------------------------------------------------------\nexport const TransactionSymbol = Symbol('TransactionSymbol');\nexport const GetTransaction = Effect.new({ handler: TransactionSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const OwnQuarkSymbol = Symbol('OwnQuarkSymbol');\nexport const OwnQuark = Effect.new({ handler: OwnQuarkSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const OwnIdentifierSymbol = Symbol('OwnIdentifierSymbol');\nexport const OwnIdentifier = Effect.new({ handler: OwnIdentifierSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const WriteSymbol = Symbol('WriteSymbol');\nexport class WriteEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = WriteSymbol;\n    }\n}\n__decorate([\n    prototypeValue(false)\n], WriteEffect.prototype, \"pure\", void 0);\nexport const Write = (identifier, proposedValue, ...proposedArgs) => WriteEffect.new({ identifier, proposedArgs: [proposedValue, ...proposedArgs] });\nexport const WriteSeveralSymbol = Symbol('WriteSeveralSymbol');\nexport class WriteSeveralEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = WriteSeveralSymbol;\n    }\n}\n__decorate([\n    prototypeValue(false)\n], WriteSeveralEffect.prototype, \"pure\", void 0);\nexport const WriteSeveral = (writes) => WriteSeveralEffect.new({ writes });\n//---------------------------------------------------------------------------------------------------------------------\nexport const PreviousValueOfSymbol = Symbol('PreviousValueOfSymbol');\nexport class PreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = PreviousValueOfSymbol;\n    }\n}\nexport const PreviousValueOf = (identifier) => PreviousValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedValueOfSymbol = Symbol('ProposedValueOfSymbol');\nexport class ProposedValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = ProposedValueOfSymbol;\n    }\n}\nexport const ProposedValueOf = (identifier) => ProposedValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const HasProposedValueSymbol = Symbol('HasProposedValueSymbol');\nexport class HasProposedValueEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = HasProposedValueSymbol;\n    }\n}\nexport const HasProposedValue = (identifier) => HasProposedValueEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const HasProposedNotPreviousValueSymbol = Symbol('HasProposedNotPreviousValueSymbol');\nexport class HasProposedNotPreviousValueEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = HasProposedNotPreviousValueSymbol;\n    }\n}\nexport const HasProposedNotPreviousValue = (identifier) => HasProposedNotPreviousValueEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedOrPreviousValueOfSymbol = Symbol('ProposedOrPreviousValueOfSymbol');\nexport class ProposedOrPreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = ProposedOrPreviousValueOfSymbol;\n    }\n}\nexport const ProposedOrPreviousValueOf = (identifier) => ProposedOrPreviousValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedArgumentsOfSymbol = Symbol('ProposedArgumentsOfSymbol');\nexport class ProposedArgumentsOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = ProposedArgumentsOfSymbol;\n    }\n}\nexport const ProposedArgumentsOf = (identifier) => ProposedArgumentsOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const UnsafeProposedOrPreviousValueOfSymbol = Symbol('UnsafeProposedOrPreviousValueOfSymbol');\nexport class UnsafeProposedOrPreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = UnsafeProposedOrPreviousValueOfSymbol;\n    }\n}\nexport const UnsafeProposedOrPreviousValueOf = (identifier) => UnsafeProposedOrPreviousValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const UnsafePreviousValueOfSymbol = Symbol('UnsafePreviousValueOfSymbol');\nexport class UnsafePreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = UnsafePreviousValueOfSymbol;\n    }\n}\nexport const UnsafePreviousValueOf = (identifier) => UnsafePreviousValueOfEffect.new({ identifier });\n", "import { CycleResolutionInput } from \"../cycle_resolver/CycleResolver.js\";\nimport { HasProposedNotPreviousValue, PreviousValueOf } from \"./Effect.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * A subclass of [[CycleResolutionInput]] with additional convenience method [[collectInfo]].\n */\nexport class CycleResolutionInputChrono extends CycleResolutionInput {\n    /**\n     * This method, given an effect handler, identifier and a variable, will add [[CycleResolutionInput.addPreviousValueFlag|previous value]]\n     * and [[CycleResolutionInput.addProposedValueFlag|proposed value]] flags for that variable.\n     *\n     * @param Y An effect handler function, which is given as a 1st argument of every calculation function\n     * @param identifier\n     * @param symbol\n     */\n    collectInfo(Y, identifier, symbol) {\n        if (Y(PreviousValueOf(identifier)) != null)\n            this.addPreviousValueFlag(symbol);\n        if (Y(HasProposedNotPreviousValue(identifier)))\n            this.addProposedValueFlag(symbol);\n    }\n}\n", "import { Effect, Reject } from \"../chrono/Effect.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { isPromise } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Symbol to denote the synchronous calculation context\n */\nexport const ContextSync = Symbol('ContextSync');\n/**\n * Symbol to denote the generator calculation context\n */\nexport const ContextGen = Symbol('ContextGen');\n//---------------------------------------------------------------------------------------------------------------------\nexport class CalculationGen extends Mixin([], (base) => class CalculationGen extends base {\n    constructor() {\n        super(...arguments);\n        this.iterator = undefined;\n        this.iterationResult = undefined;\n    }\n    isCalculationStarted() {\n        return Boolean(this.iterator || this.iterationResult);\n    }\n    isCalculationCompleted() {\n        return Boolean(this.iterationResult && this.iterationResult.done);\n    }\n    get result() {\n        return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : undefined;\n    }\n    startCalculation(onEffect, ...args) {\n        const iterator = this.iterator = this.calculation.call(this.context || this, onEffect, ...args);\n        return this.iterationResult = iterator.next();\n    }\n    continueCalculation(value) {\n        return this.iterationResult = this.iterator.next(value);\n    }\n    cleanupCalculation() {\n        this.iterationResult = undefined;\n        this.iterator = undefined;\n    }\n    *calculation(onEffect, ...args) {\n        throw new Error(\"Abstract method `calculation` called\");\n    }\n    runSyncWithEffect(onEffect, ...args) {\n        this.startCalculation(onEffect, ...args);\n        while (!this.isCalculationCompleted()) {\n            this.continueCalculation(onEffect(this.iterationResult.value));\n        }\n        // help to garbage collector\n        this.iterator = undefined;\n        return this.result;\n    }\n    async runAsyncWithEffect(onEffect, ...args) {\n        this.startCalculation(onEffect, ...args);\n        while (!this.isCalculationCompleted()) {\n            this.continueCalculation(await onEffect(this.iterationResult.value));\n        }\n        // help to garbage collector\n        this.iterator = undefined;\n        return this.result;\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const SynchronousCalculationStarted = Symbol('SynchronousCalculationStarted');\nconst calculationStartedConstant = { value: SynchronousCalculationStarted };\nexport class CalculationSync extends Mixin([], (base) => class CalculationSync extends base {\n    constructor() {\n        super(...arguments);\n        this.iterationResult = undefined;\n    }\n    isCalculationStarted() {\n        return Boolean(this.iterationResult);\n    }\n    isCalculationCompleted() {\n        return Boolean(this.iterationResult && this.iterationResult.done);\n    }\n    get result() {\n        return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : undefined;\n    }\n    startCalculation(onEffect, ...args) {\n        // this assignment allows other code to observe, that calculation has started\n        this.iterationResult = calculationStartedConstant;\n        return this.iterationResult = {\n            done: true,\n            value: this.calculation.call(this.context || this, onEffect, ...args)\n        };\n    }\n    continueCalculation(value) {\n        throw new Error(\"Can not continue synchronous calculation\");\n    }\n    cleanupCalculation() {\n        this.iterationResult = undefined;\n    }\n    calculation(onEffect, ...args) {\n        throw new Error(\"Abstract method `calculation` called\");\n    }\n    runSyncWithEffect(onEffect, ...args) {\n        this.startCalculation(onEffect, ...args);\n        return this.result;\n    }\n    async runAsyncWithEffect(onEffect, ...args) {\n        throw new Error('Can not run synchronous calculation asynchronously');\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function runGeneratorSyncWithEffect(effect, func, args, scope) {\n    const gen = func.apply(scope || null, args);\n    let iteration = gen.next();\n    while (!iteration.done) {\n        iteration = gen.next(effect(iteration.value));\n    }\n    return iteration.value;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport async function runGeneratorAsyncWithEffect(effect, func, args, scope) {\n    const gen = func.apply(scope || null, args);\n    let iteration = gen.next();\n    while (!iteration.done) {\n        let effectResolution;\n        let repeat = false;\n        do {\n            repeat = false;\n            try {\n                effectResolution = effect(iteration.value);\n            }\n            catch (e) {\n                // this is very bad, or even terrible - the high-level `Effect` class is mentioned in the \"primitives\",\n                // we compare 'resolution' with the magic string 'Cancel' (defined in Engine) and we also use `Reject`\n                // constructor\n                // but, we are trying to shove an async handling in sync computation (impossible by definition)\n                // so we are desperate, and even seems to work...\n                // other piece of this code is in `onComputationCycleHandlerSync` in `Engine/lib/Engine/chrono/Replica.ts`\n                if (e instanceof Effect) {\n                    // @ts-ignore\n                    let resolution = await effect(e);\n                    if (resolution === 'Cancel') {\n                        // @ts-ignore\n                        effect(Reject(e));\n                        return;\n                    }\n                    else {\n                        repeat = true;\n                    }\n                }\n            }\n        } while (repeat);\n        if (isPromise(effectResolution))\n            iteration = gen.next(await effectResolution);\n        else\n            iteration = gen.next(effectResolution);\n    }\n    return iteration.value;\n}\n", "import { MixinAny } from \"../class/Mixin.js\";\nimport { NOT_VISITED } from \"../graph/WalkDepth.js\";\nimport { MAX_SMI, MIN_SMI } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport var EdgeType;\n(function (EdgeType) {\n    EdgeType[EdgeType[\"Normal\"] = 1] = \"Normal\";\n    EdgeType[EdgeType[\"Past\"] = 2] = \"Past\";\n})(EdgeType || (EdgeType = {}));\nlet ORIGIN_ID = 0;\n//---------------------------------------------------------------------------------------------------------------------\nexport class Quark extends MixinAny([Map], (base) => class Quark extends base {\n    constructor() {\n        super(...arguments);\n        // required\n        this.createdAt = undefined;\n        this.identifier = undefined;\n        // quark state\n        this.value = undefined;\n        this.proposedValue = undefined;\n        this.proposedIsPrevious = false;\n        this.proposedArguments = undefined;\n        this.usedProposedOrPrevious = false;\n        // eof quark state\n        this.previous = undefined;\n        this.origin = undefined;\n        this.originId = MIN_SMI;\n        this.needToBuildProposedValue = false;\n        this.edgesFlow = 0;\n        this.visitedAt = NOT_VISITED;\n        this.visitEpoch = 0;\n        this.promise = undefined;\n        this.$outgoingPast = undefined;\n    }\n    static new(props) {\n        const instance = new this();\n        props && Object.assign(instance, props);\n        return instance;\n    }\n    get level() {\n        return this.identifier.level;\n    }\n    get calculation() {\n        return this.identifier.calculation;\n    }\n    get context() {\n        return this.identifier.context || this.identifier;\n    }\n    forceCalculation() {\n        this.edgesFlow = MAX_SMI;\n    }\n    cleanup() {\n        this.cleanupCalculation();\n    }\n    isShadow() {\n        return Boolean(this.origin && this.origin !== this);\n    }\n    resetToEpoch(epoch) {\n        this.visitEpoch = epoch;\n        this.visitedAt = NOT_VISITED;\n        // we were clearing the edgeFlow on epoch change, however see `030_propagation_2.t.ts` for a counter-example\n        \n        if (this.edgesFlow < 0)\n            this.edgesFlow = 0;\n        this.usedProposedOrPrevious = false;\n        this.cleanupCalculation();\n        // if there's no value, then generally should be no outgoing edges\n        // (which indicates that the value has been used somewhere else)\n        // but there might be outgoing \"past\" edges, created if `HasProposedValue`\n        // or similar effect has been used on the identifier\n        // if (this.value !== undefined) this.clearOutgoing()\n        // the `this.value !== undefined` condition above smells very \"monkey-patching\"\n        // it was probably solving some specific problem in Gantt/SchedulerPro\n        // (engine tests seems to pass w/o it)\n        // in general, should always clear the outgoing edges on new epoch\n        this.clearOutgoing();\n        this.promise = undefined;\n        if (this.origin && this.origin === this) {\n            this.proposedArguments = undefined;\n            // only overwrite the proposed value if the actual value has been already calculated\n            // otherwise, keep the proposed value as is\n            if (this.value !== undefined) {\n                this.proposedValue = this.value;\n            }\n            this.value = undefined;\n        }\n        else {\n            this.origin = undefined;\n            this.value = undefined;\n        }\n        if (this.identifier.proposedValueIsBuilt && this.proposedValue !== TombStone) {\n            this.needToBuildProposedValue = true;\n            this.proposedValue = undefined;\n        }\n    }\n    copyFrom(origin) {\n        this.value = origin.value;\n        this.proposedValue = origin.proposedValue;\n        this.proposedArguments = origin.proposedArguments;\n        this.usedProposedOrPrevious = origin.usedProposedOrPrevious;\n    }\n    clearProperties() {\n        this.value = undefined;\n        this.proposedValue = undefined;\n        this.proposedArguments = undefined;\n    }\n    mergePreviousOrigin(latestScope) {\n        const origin = this.origin;\n        if (origin !== this.previous)\n            throw new Error(\"Invalid state\");\n        this.copyFrom(origin);\n        const outgoing = this.getOutgoing();\n        for (const [identifier, quark] of origin.getOutgoing()) {\n            const ownOutgoing = outgoing.get(identifier);\n            if (!ownOutgoing) {\n                const latest = latestScope.get(identifier);\n                if (!latest || latest.originId === quark.originId)\n                    outgoing.set(identifier, latest || quark);\n            }\n        }\n        if (origin.$outgoingPast !== undefined) {\n            const outgoingPast = this.getOutgoingPast();\n            for (const [identifier, quark] of origin.getOutgoingPast()) {\n                const ownOutgoing = outgoingPast.get(identifier);\n                if (!ownOutgoing) {\n                    const latest = latestScope.get(identifier);\n                    if (!latest || latest.originId === quark.originId)\n                        outgoingPast.set(identifier, latest || quark);\n                }\n            }\n        }\n        // changing `origin`, but keeping `originId`\n        this.origin = this;\n        // some help for garbage collector\n        origin.clearProperties();\n        origin.clear();\n    }\n    setOrigin(origin) {\n        this.origin = origin;\n        this.originId = origin.originId;\n    }\n    getOrigin() {\n        if (this.origin)\n            return this.origin;\n        return this.startOrigin();\n    }\n    startOrigin() {\n        this.originId = ORIGIN_ID++;\n        return this.origin = this;\n    }\n    getOutgoing() {\n        return this;\n    }\n    getOutgoingPast() {\n        if (this.$outgoingPast !== undefined)\n            return this.$outgoingPast;\n        return this.$outgoingPast = new Map();\n    }\n    addOutgoingTo(toQuark, type) {\n        const outgoing = type === EdgeType.Normal ? this : this.getOutgoingPast();\n        outgoing.set(toQuark.identifier, toQuark);\n    }\n    clearOutgoing() {\n        this.clear();\n        if (this.$outgoingPast !== undefined)\n            this.$outgoingPast.clear();\n    }\n    getValue() {\n        const origin = this.origin;\n        return origin === this\n            ? this.value\n            : origin\n                ? origin.getValue()\n                : undefined;\n    }\n    setValue(value) {\n        if (this.origin && this.origin !== this)\n            throw new Error('Can not set value to the shadow entry');\n        this.getOrigin().value = value;\n        // // @ts-ignore\n        // if (value !== TombStone) this.identifier.DATA = value\n    }\n    hasValue() {\n        return this.getValue() !== undefined;\n    }\n    hasProposedValue() {\n        if (this.isShadow())\n            return false;\n        return this.hasProposedValueInner();\n    }\n    hasProposedValueInner() {\n        return this.proposedValue !== undefined;\n    }\n    getProposedValue(transaction) {\n        if (this.needToBuildProposedValue) {\n            this.proposedValue = this.identifier.buildProposedValue.call(this.identifier.context || this.identifier, this.identifier, this, transaction);\n            // setting this flag _after_ attempt to build the proposed value, because it might actually throw\n            // (if there's a cycle during sync computation, like during `effectiveDirection`)\n            // in such case, we need to re-enter this block\n            this.needToBuildProposedValue = false;\n        }\n        return this.proposedValue;\n    }\n    outgoingInTheFutureCb(revision, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                if (outgoing.originId === revision.getLatestEntryFor(outgoing.identifier).originId)\n                    forEach(outgoing);\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n    outgoingInTheFutureAndPastCb(revision, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                const latestEntry = revision.getLatestEntryFor(outgoing.identifier);\n                if (latestEntry && outgoing.originId === latestEntry.originId)\n                    forEach(outgoing);\n            }\n            if (current.$outgoingPast !== undefined) {\n                for (const outgoing of current.$outgoingPast.values()) {\n                    const latestEntry = revision.getLatestEntryFor(outgoing.identifier);\n                    if (latestEntry && outgoing.originId === latestEntry.originId)\n                        forEach(outgoing);\n                }\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n    outgoingInTheFutureAndPastTransactionCb(transaction, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                const latestEntry = transaction.getLatestStableEntryFor(outgoing.identifier);\n                if (latestEntry && outgoing.originId === latestEntry.originId)\n                    forEach(outgoing);\n            }\n            if (current.$outgoingPast !== undefined) {\n                for (const outgoing of current.$outgoingPast.values()) {\n                    const latestEntry = transaction.getLatestStableEntryFor(outgoing.identifier);\n                    if (latestEntry && outgoing.originId === latestEntry.originId)\n                        forEach(outgoing);\n                }\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n    // ignores the \"past\" edges by design, as they do not form cycles\n    outgoingInTheFutureTransactionCb(transaction, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                const latestEntry = transaction.getLatestEntryFor(outgoing.identifier);\n                if (latestEntry && outgoing.originId === latestEntry.originId)\n                    forEach(outgoing);\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const TombStone = Symbol('Tombstone');\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base } from \"../class/Base.js\";\nimport { CalculationGen, CalculationSync } from \"../primitives/Calculation.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\nimport { ProposedOrPrevious } from \"./Effect.js\";\nimport { Quark } from \"./Quark.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n\nLevels of the [[Identifier|identifiers]] as simple integers. Defines the order of calculation, enforced by the following rule -\nall lower level identifiers should be already calculated before the calculation of the identifier with the higher level starts.\n\nBecause of this, the lower level identifiers can not depend on higher level identifiers.\n\nThis rule means that effects from all identifiers of the lower levels will be already processed, when calculating\nan identifier of the higher level.\n\nNormally you don't need to specify a level for your identifiers.\n\n*/\nexport var Levels;\n(function (Levels) {\n    // must be sync\n    Levels[Levels[\"UserInput\"] = 0] = \"UserInput\";\n    Levels[Levels[\"DependsOnlyOnUserInput\"] = 1] = \"DependsOnlyOnUserInput\";\n    Levels[Levels[\"DependsOnlyOnDependsOnlyOnUserInput\"] = 2] = \"DependsOnlyOnDependsOnlyOnUserInput\";\n    // asynchronicity starts from here\n    Levels[Levels[\"DependsOnSelfKind\"] = 3] = \"DependsOnSelfKind\";\n})(Levels || (Levels = {}));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * The base class for [[Identifier|identifiers]]. It contains only \"meta\" properties that describes \"abstract\" identifier.\n * The [[Field]] class inherit from this class.\n *\n * To understand the difference between the \"abstract\" identifier and the \"specific\" identifier,\n * imagine a set of instances of the same entity class. Lets say that class has a field \"name\".\n * All of those instances each will have different \"specific\" identifiers for the field \"name\".\n *\n * In the same time, some properties are common for all \"specific\" identifiers, like [[Meta.equality|equality]], [[Meta.lazy|lazy]] etc.\n * Such properties, that does not change between every \"specific\" identifier we will call \"meta\" properties.\n *\n * This class has 2 generic arguments - `ValueT` and `ContextT`. The 1st one defines the type of the identifier's value.\n * The 2nd - the identifier's computation context (synchronous of generator).\n */\nexport class Meta extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the identifiers. Not an id, does not imply uniqueness.\n         */\n        this.name = undefined;\n        /**\n         * Whether this identifier is lazy (`true`) or strict (`false`).\n         *\n         * Lazy identifiers are calculated on-demand (when read from graph or used by another identifiers).\n         *\n         * Strict identifiers will be calculated on read or during the [[ChronoGraph.commit|commit]] call.\n         */\n        this.lazy = false;\n        // no cancels\n        this.total = true;\n        // no \"nested\" writes\n        this.pure = true;\n        this.proposedValueIsBuilt = false;\n    }\n    /**\n     * The calculation function of the identifier. Its returning value has a generic type, that is converted to a specific type,\n     * based on the generic attribute `ContextT`.\n     *\n     * This function will receive a single argument - current calculation context (effects handler).\n     *\n     * When using generators, there's no need to use this handler - one can \"yield\" the value directly, using the `yield` construct.\n     *\n     * Compare:\n     *\n     *     class Author extends Entity.mix(Base) {\n     *         @field()\n     *         firstName       : string\n     *         @field()\n     *         lastName        : string\n     *         @field()\n     *         fullName        : string\n     *\n     *         @calculate('fullName')\n     *         * calculateFullName () : ChronoIterator<string> {\n     *             return (yield this.$.firstName) + ' ' + (yield this.$.lastName)\n     *         }\n     *\n     *         @calculate('fullName')\n     *         calculateFullName (Y) : string {\n     *             return Y(this.$.firstName) + ' ' + Y(this.$.lastName)\n     *         }\n     *     }\n     *\n     * @param Y\n     */\n    calculation(Y) {\n        throw new Error(\"Abstract method `calculation` called\");\n    }\n    /**\n     * The equality check of the identifier. By default is performed with `===`.\n     *\n     * @param v1 First value\n     * @param v2 Second value\n     */\n    equality(v1, v2) {\n        return v1 === v2;\n    }\n}\n__decorate([\n    prototypeValue(Levels.DependsOnSelfKind)\n], Meta.prototype, \"level\", void 0);\n__decorate([\n    prototypeValue(true)\n], Meta.prototype, \"sync\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * The generic \"specific\" identifier class (see [[Meta]] for \"abstract\" properties). This class is generic in the sense that it does not\n * specify the type of the calculation function - it can be either synchronous or generator-based.\n *\n * It is also low-level and generally not supposed to be used directly in the application. Instead, one should\n * declare identifiers as fields (decorated class properties) in the [[Replica|replica]].\n */\nexport class Identifier extends Meta {\n    constructor() {\n        super(...arguments);\n        /**\n         * The scope (`this` value) for the calculation function.\n         */\n        this.context = undefined;\n        // flag to set during the `write` inside the `addIdentifier` call\n        this.isWritingUndefined = false;\n    }\n    newQuark(createdAt) {\n        // micro-optimization - we don't pass a config object to the `new` constructor\n        // but instead assign directly to instance\n        const newQuark = this.quarkClass.new();\n        newQuark.createdAt = createdAt;\n        newQuark.identifier = this;\n        newQuark.needToBuildProposedValue = this.proposedValueIsBuilt;\n        return newQuark;\n    }\n    write(me, transaction, quark, proposedValue, ...args) {\n        quark = quark || transaction.getWriteTarget(me);\n        quark.proposedValue = proposedValue;\n        quark.proposedArguments = args.length > 0 ? args : undefined;\n        quark.proposedIsPrevious = transaction.graph.isWritingPreviousData;\n    }\n    writeToTransaction(transaction, proposedValue, ...args) {\n        transaction.write(this, proposedValue, ...args);\n    }\n    /**\n     * Write a value to this identifier, in the context of `graph`.\n     *\n     * @param graph\n     * @param proposedValue\n     * @param args\n     */\n    writeToGraph(graph, proposedValue, ...args) {\n        graph.write(this, proposedValue, ...args);\n    }\n    /**\n     * Read the value of this identifier, in the context of `graph`, asynchronously\n     * @param graph\n     */\n    readFromGraphAsync(graph) {\n        return graph.readAsync(this);\n    }\n    /**\n     * Read the value of this identifier, in the context of `graph`, synchronously\n     * @param graph\n     */\n    readFromGraph(graph) {\n        return graph.read(this);\n    }\n    readFromTransaction(transaction) {\n        return transaction.read(this);\n    }\n    readFromTransactionAsync(transaction) {\n        return transaction.readAsync(this);\n    }\n    // readFromGraphDirtySync (graph : CheckoutI) : ValueT {\n    //     return graph.readDirty(this)\n    // }\n    buildProposedValue(me, quark, transaction) {\n        return undefined;\n    }\n    /**\n     * Template method, which is called, when this identifier \"enters\" the graph.\n     *\n     * @param graph\n     */\n    enterGraph(graph) {\n    }\n    /**\n     * Template method, which is called, when this identifier \"leaves\" the graph.\n     *\n     * @param graph\n     */\n    leaveGraph(graph) {\n    }\n}\n/**\n * Constructor for the [[Identifier]] class. Used only for typization purposes, to be able to specify the generics arguments.\n */\nexport const IdentifierC = (config) => Identifier.new(config);\n//@ts-ignore\nexport const QuarkSync = Quark.mix(CalculationSync.mix(Map));\n//@ts-ignore\nexport const QuarkGen = Quark.mix(CalculationGen.mix(Map));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Variable is a subclass of [[Identifier]], that does not perform any calculation and instead is always equal to a user-provided value.\n * It is a bit more light-weight\n */\nexport class Variable extends Identifier {\n    calculation(YIELD) {\n        throw new Error(\"The 'calculation' method of the variables should never be called. Instead, the value will be set directly to quark\");\n    }\n    write(me, transaction, quark, proposedValue, ...args) {\n        quark = quark || transaction.getWriteTarget(me);\n        quark.value = proposedValue;\n        quark.proposedArguments = args.length > 0 ? args : undefined;\n    }\n}\n__decorate([\n    prototypeValue(Levels.UserInput)\n], Variable.prototype, \"level\", void 0);\n__decorate([\n    prototypeValue(QuarkSync)\n], Variable.prototype, \"quarkClass\", void 0);\n/**\n * Constructor for the [[Variable]] class. Used only for typization purposes.\n */\nexport function VariableC(...args) {\n    return Variable.new(...args);\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Subclass of the [[Identifier]], representing synchronous computation.\n */\nexport class CalculatedValueSync extends Identifier {\n    calculation(YIELD) {\n        return YIELD(ProposedOrPrevious);\n    }\n}\n__decorate([\n    prototypeValue(QuarkSync)\n], CalculatedValueSync.prototype, \"quarkClass\", void 0);\n/**\n * Constructor for the [[CalculatedValueSync]] class. Used only for typization purposes.\n */\nexport function CalculatedValueSyncC(...args) {\n    return CalculatedValueSync.new(...args);\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Subclass of the [[Identifier]], representing generator-based computation.\n */\nexport class CalculatedValueGen extends Identifier {\n    *calculation(YIELD) {\n        return yield ProposedOrPrevious;\n    }\n}\n__decorate([\n    prototypeValue(QuarkGen)\n], CalculatedValueGen.prototype, \"quarkClass\", void 0);\n/**\n * Constructor for the [[CalculatedValueGen]] class. Used only for typization purposes.\n */\nexport function CalculatedValueGenC(...args) {\n    return CalculatedValueGen.new(...args);\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const throwUnknownIdentifier = (identifier) => { throw new Error(`Unknown identifier ${identifier}`); };\n", "import { Base } from \"../class/Base.js\";\nimport { TombStone } from \"./Quark.js\";\nlet CLOCK = 0;\nexport class Revision extends Base {\n    constructor() {\n        super(...arguments);\n        this.createdAt = CLOCK++;\n        this.name = 'revision-' + this.createdAt;\n        this.previous = undefined;\n        this.scope = new Map();\n        this.reachableCount = 0;\n        this.referenceCount = 0;\n        this.selfDependent = new Set();\n    }\n    getLatestEntryFor(identifier) {\n        let revision = this;\n        while (revision) {\n            const entry = revision.scope.get(identifier);\n            if (entry)\n                return entry;\n            revision = revision.previous;\n        }\n        return null;\n    }\n    hasIdentifier(identifier) {\n        const latestEntry = this.getLatestEntryFor(identifier);\n        return Boolean(latestEntry && latestEntry.getValue() !== TombStone);\n    }\n    *previousAxis() {\n        let revision = this;\n        while (revision) {\n            yield revision;\n            revision = revision.previous;\n        }\n    }\n}\n", "import { MAX_SMI } from \"./Helpers.js\";\n// Leveled LIFO queue\nexport class LeveledQueue {\n    constructor() {\n        this.length = 0;\n        this.levels = [];\n        this.lowestLevel = MAX_SMI;\n    }\n    getLowestLevel() {\n        for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n            if (this.levels[i])\n                return this.lowestLevel = i;\n        }\n        return this.lowestLevel = MAX_SMI;\n    }\n    takeLowestLevel() {\n        for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n            const level = this.levels[i];\n            if (level) {\n                this.length -= level.length;\n                this.levels[i] = null;\n                this.lowestLevel = i + 1;\n                return level;\n            }\n        }\n    }\n    // resetCachedPosition () {\n    //     this.lowestLevel               = MAX_SMI\n    // }\n    // last () {\n    //     for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n    //         const level     = this.levels[ i ]\n    //\n    //         if (level && level.length > 0) {\n    //             this.lowestLevel   = i\n    //\n    //             return level[ level.length - 1 ]\n    //         }\n    //     }\n    // }\n    pop() {\n        for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n            const level = this.levels[i];\n            this.lowestLevel = i;\n            if (level && level.length > 0) {\n                this.length--;\n                return level.pop();\n            }\n        }\n        this.lowestLevel = MAX_SMI;\n    }\n    push(el) {\n        const elLevel = el.level;\n        let level = this.levels[elLevel];\n        if (!level) {\n            // avoid holes in the array\n            for (let i = this.levels.length; i < elLevel; i++)\n                this.levels[i] = null;\n            level = this.levels[elLevel] = [];\n        }\n        level.push(el);\n        this.length++;\n        if (elLevel < this.lowestLevel)\n            this.lowestLevel = elLevel;\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.levels.length; i++) {\n            const level = this.levels[i];\n            if (level)\n                yield* level;\n        }\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { NOT_VISITED, OnCycleAction, WalkContext } from \"../graph/WalkDepth.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport class ComputationCycle extends Base {\n    toString() {\n        const cycleIdentifiers = [];\n        const cycleEvents = [];\n        this.cycle.forEach(({ name, context }) => {\n            cycleIdentifiers.push(name);\n            if (cycleEvents[cycleEvents.length - 1] !== context)\n                cycleEvents.push(context);\n        });\n        return 'events: \\n' +\n            cycleEvents.map(event => '#' + event.id).join(' => ') +\n            '\\n\\nidentifiers: \\n' +\n            cycleIdentifiers.join('\\n');\n        // return this.cycle.map(identifier => {\n        //     return identifier.name\n        //     // //@ts-ignore\n        //     // const sourcePoint : SourceLinePoint      = identifier.SOURCE_POINT\n        //     //\n        //     // if (!sourcePoint) return identifier.name\n        //     //\n        //     // const firstEntry       = sourcePoint.stackEntries[ 0 ]\n        //     //\n        //     // if (firstEntry) {\n        //     //     return `${identifier}\\n    yielded at ${firstEntry.sourceFile}:${firstEntry.sourceLine}:${firstEntry.sourceCharPos || ''}`\n        //     // } else\n        //     //     return identifier.name\n        // }).join(' => \\n')\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class TransactionCycleDetectionWalkContext extends WalkContext {\n    constructor() {\n        // baseRevision    : Revision                  = undefined\n        super(...arguments);\n        this.transaction = undefined;\n    }\n    onCycle(node, stack) {\n        return OnCycleAction.Cancel;\n    }\n    doCollectNext(from, to, toVisit) {\n        let visit = this.visited.get(to);\n        if (!visit) {\n            visit = { visitedAt: NOT_VISITED, visitEpoch: this.currentEpoch };\n            this.visited.set(to, visit);\n        }\n        toVisit.push({ node: to, from, label: undefined });\n    }\n    collectNext(from, toVisit) {\n        const latestEntry = this.transaction.getLatestEntryFor(from);\n        if (latestEntry) {\n            latestEntry.outgoingInTheFutureTransactionCb(this.transaction, outgoingEntry => {\n                this.doCollectNext(from, outgoingEntry.identifier, toVisit);\n            });\n        }\n        // for (const outgoingIdentifier of visitInfo.getOutgoing().keys()) {\n        //     this.doCollectNext(from, outgoingIdentifier, toVisit)\n        // }\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { NOT_VISITED, OnCycleAction, VISITED_TOPOLOGICALLY } from \"../graph/WalkDepth.js\";\nimport { Levels } from \"./Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport class TransactionWalkDepth extends Base {\n    constructor() {\n        super(...arguments);\n        this.visited = new Map();\n        this.transaction = undefined;\n        this.baseRevision = undefined;\n        this.pushTo = undefined;\n        this.toVisit = [];\n        this.currentEpoch = 0;\n    }\n    startFrom(sourceNodes) {\n        this.continueFrom(sourceNodes);\n    }\n    continueFrom(sourceNodes) {\n        this.toVisit.push.apply(this.toVisit, sourceNodes);\n        this.walkDepth();\n    }\n    startNewEpoch() {\n        if (this.toVisit.length)\n            throw new Error(\"Can not start new walk epoch in the middle of the walk\");\n        this.currentEpoch++;\n    }\n    onTopologicalNode(identifier, visitInfo) {\n        if (!identifier.lazy && identifier.level !== Levels.UserInput)\n            this.pushTo.push(visitInfo);\n    }\n    onCycle(node, stack) {\n        return OnCycleAction.Resume;\n    }\n    // it is more efficient (=faster) to create new quarks for yet unvisited identifiers\n    // in batches, using this method, instead of in normal flow in the `walkDepth` method\n    // this is probably because of the CPU context switch between the `this.visited` and `this.baseRevision.getLatestEntryFor`\n    doCollectNext(from, to, toVisit) {\n        let quark = this.visited.get(to);\n        if (!quark) {\n            quark = to.newQuark(this.baseRevision);\n            quark.visitEpoch = this.currentEpoch;\n            this.visited.set(to, quark);\n        }\n        toVisit.push(to);\n    }\n    collectNext(from, toVisit, visitInfo) {\n        const latestEntry = this.baseRevision.getLatestEntryFor(from);\n        if (latestEntry) {\n            // since `collectNext` is called exactly once for every node, all quarks\n            // will have the `previous` property populated\n            visitInfo.previous = latestEntry;\n            latestEntry.outgoingInTheFutureAndPastTransactionCb(this.transaction, outgoingEntry => {\n                this.doCollectNext(from, outgoingEntry.identifier, toVisit);\n            });\n        }\n        for (const outgoingIdentifier of visitInfo.getOutgoing().keys()) {\n            this.doCollectNext(from, outgoingIdentifier, toVisit);\n        }\n        if (visitInfo.$outgoingPast !== undefined)\n            for (const outgoingIdentifier of visitInfo.getOutgoingPast().keys()) {\n                this.doCollectNext(from, outgoingIdentifier, toVisit);\n            }\n    }\n    walkDepth() {\n        const visited = this.visited;\n        const toVisit = this.toVisit;\n        let depth;\n        while (depth = toVisit.length) {\n            const node = toVisit[depth - 1];\n            let visitInfo = visited.get(node);\n            if (visitInfo && visitInfo.visitedAt === VISITED_TOPOLOGICALLY && visitInfo.visitEpoch === this.currentEpoch) {\n                visitInfo.edgesFlow++;\n                toVisit.pop();\n                continue;\n            }\n            if (visitInfo && visitInfo.visitEpoch === this.currentEpoch && visitInfo.visitedAt !== NOT_VISITED) {\n                // it is valid to find itself \"visited\", but only if visited at the current depth\n                // (which indicates stack unwinding)\n                // if the node has been visited at earlier depth - its a cycle\n                if (visitInfo.visitedAt < depth) {\n                    // ONLY resume if explicitly returned `Resume`, cancel in all other cases (undefined, etc)\n                    if (this.onCycle(node, toVisit) !== OnCycleAction.Resume)\n                        break;\n                    visitInfo.edgesFlow++;\n                }\n                else {\n                    visitInfo.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node, visitInfo);\n                }\n                toVisit.pop();\n            }\n            else {\n                const lengthBefore = toVisit.length;\n                if (!visitInfo) {\n                    visitInfo = node.newQuark(this.baseRevision);\n                    visitInfo.visitEpoch = this.currentEpoch;\n                    visited.set(node, visitInfo);\n                }\n                this.collectNext(node, toVisit, visitInfo);\n                if (visitInfo.visitEpoch < this.currentEpoch) {\n                    visitInfo.resetToEpoch(this.currentEpoch);\n                }\n                visitInfo.visitedAt = depth;\n                visitInfo.edgesFlow++;\n                // if there's no outgoing edges, node is at topological position\n                // it would be enough to just continue the `while` loop and the `onTopologicalNode`\n                // would happen on next iteration, but with this \"inlining\" we save one call to `visited.get()`\n                // at the cost of length comparison\n                if (toVisit.length === lengthBefore) {\n                    visitInfo.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node, visitInfo);\n                    toVisit.pop();\n                }\n            }\n        }\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { DEBUG } from \"../environment/Debug.js\";\nimport { cycleInfo, OnCycleAction } from \"../graph/WalkDepth.js\";\nimport { runGeneratorAsyncWithEffect, SynchronousCalculationStarted } from \"../primitives/Calculation.js\";\nimport { delay, isPromise, MAX_SMI } from \"../util/Helpers.js\";\nimport { LeveledQueue } from \"../util/LeveledQueue.js\";\nimport { BreakCurrentStackExecution, RejectEffect } from \"./Effect.js\";\nimport { Identifier, Levels, throwUnknownIdentifier } from \"./Identifier.js\";\nimport { EdgeType, TombStone } from \"./Quark.js\";\nimport { Revision } from \"./Revision.js\";\nimport { ComputationCycle, TransactionCycleDetectionWalkContext } from \"./TransactionCycleDetectionWalkContext.js\";\nimport { TransactionWalkDepth } from \"./TransactionWalkDepth.js\";\n//---------------------------------------------------------------------------------------------------------------------\n// weird stack overflow on 1300 deep benchmark, when using `EdgeType.Normal` w/o aliasing it to constant first\nexport const EdgeTypeNormal = EdgeType.Normal;\nexport const EdgeTypePast = EdgeType.Past;\n//---------------------------------------------------------------------------------------------------------------------\nexport class Transaction extends Base {\n    constructor() {\n        super(...arguments);\n        this.baseRevision = undefined;\n        this.candidateClass = Revision;\n        this.candidate = undefined;\n        this.graph = undefined;\n        this.isClosed = false;\n        this.walkContext = undefined;\n        this.entries = new Map();\n        // // we use 2 different stacks, because they support various effects\n        // stackSync               : LeveledQueue<Quark>  = new LeveledQueue()\n        // the `stackGen` supports async effects notably\n        this.stackGen = new LeveledQueue();\n        // is used for tracking the active quark entry (quark entry being computed)\n        this.activeStack = [];\n        this.onEffectSync = undefined;\n        this.onEffectAsync = undefined;\n        //---------------------\n        this.propagationStartDate = 0;\n        this.lastProgressNotificationDate = 0;\n        this.startProgressNotificationsAfterMs = 500;\n        this.emitProgressNotificationsEveryMs = 200;\n        \n        this.emitProgressNotificationsEveryCalculations = 100;\n        this.plannedTotalIdentifiersToCalculate = 0;\n        // writes                  : WriteInfo[]           = []\n        this.ongoing = Promise.resolve();\n        this.selfDependedMarked = false;\n        this.rejectedWith = undefined;\n        this.stopped = false;\n        this.hasEntryWithProposedValue = false;\n        this.hasVariableEntry = false;\n    }\n    initialize(...args) {\n        super.initialize(...args);\n        this.walkContext = TransactionWalkDepth.new({\n            visited: this.entries,\n            transaction: this,\n            baseRevision: this.baseRevision,\n            pushTo: this.stackGen\n        });\n        if (!this.candidate)\n            this.candidate = this.candidateClass.new({ previous: this.baseRevision });\n        // the `onEffectSync` should be bound to the `yieldSync` of course, and `yieldSync` should look like:\n        //     yieldSync (effect : YieldableValue) : any {\n        //         if (effect instanceof Identifier) return this.read(effect)\n        //     }\n        // however, the latter consumes more stack frames - every read goes through `yieldSync`\n        // since `read` is the most used effect anyway, we bind `onEffectSync` to `read` and\n        // instead inside of `read` delegate to `yieldSync` for non-identifiers\n        this.onEffectSync = /*this.onEffectAsync =*/ this.read.bind(this);\n        this.onEffectAsync = this.readAsync.bind(this);\n    }\n    get dirty() {\n        return this.entries.size > 0;\n    }\n    markSelfDependent() {\n        if (this.selfDependedMarked)\n            return;\n        this.selfDependedMarked = true;\n        for (const selfDependentIden of this.baseRevision.selfDependent) {\n            const existing = this.entries.get(selfDependentIden);\n            if (existing && existing.getValue() === TombStone)\n                continue;\n            this.touch(selfDependentIden);\n        }\n    }\n    // onNewWrite () {\n    //     this.writes.forEach(writeInfo => {\n    //         const identifier    = writeInfo.identifier\n    //\n    //         identifier.write.call(identifier.context || identifier, identifier, this, null, ...writeInfo.proposedArgs)\n    //     })\n    //\n    //     this.writes.length = 0\n    // }\n    getActiveEntry() {\n        return this.activeStack[this.activeStack.length - 1];\n        // // `stackSync` is always empty, except when the synchronous \"batch\" is being processed\n        // const activeStack   = this.stackSync.length > 0 ? this.stackSync : this.stackGen\n        //\n        // return activeStack.last()\n    }\n    yieldAsync(effect) {\n        if (isPromise(effect))\n            return effect;\n        return this.graph[effect.handler](effect, this);\n    }\n    // see the comment for the `onEffectSync`\n    yieldSync(effect) {\n        if (isPromise(effect)) {\n            throw new Error(\"Can not yield a promise in the synchronous context\");\n        }\n        return this.graph[effect.handler](effect, this);\n    }\n    // this seems to be an optimistic version\n    readAsync(identifier) {\n        // see the comment for the `onEffectSync`\n        if (!(identifier instanceof Identifier))\n            return this.yieldAsync(identifier);\n        let entry;\n        const activeEntry = this.getActiveEntry();\n        if (activeEntry) {\n            entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);\n        }\n        else {\n            entry = this.entries.get(identifier);\n            if (!entry) {\n                const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n                if (!previousEntry)\n                    throwUnknownIdentifier(identifier);\n                entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);\n            }\n        }\n        if (entry.hasValue())\n            return entry.getValue();\n        if (entry.promise)\n            return entry.promise;\n        //----------------------\n        \n        // now need to repeat the logic\n        if (!entry.previous || !entry.previous.hasValue())\n            entry.forceCalculation();\n        return this.ongoing = entry.promise = this.ongoing.then(() => {\n            return (async () => {\n                //----------------------\n                while (this.stackGen.lowestLevel < identifier.level) {\n                    await runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, this.stackGen.takeLowestLevel()], this);\n                }\n                this.markSelfDependent();\n                // entry might be already calculated (in the `ongoing` promise), so no need to calculate it\n                if (entry.getValue() === undefined)\n                    return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [entry]], this);\n            })();\n        }).then(() => {\n            if (this.rejectedWith)\n                throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);\n            // we clear the promise in the `resetToEpoch` should be enough?\n            // entry.promise = undefined\n            \n            if (!entry.hasValue())\n                throw new Error('Computation cycle. Sync');\n            return entry.getValue();\n        });\n    }\n    // `ignoreActiveEntry` should be used when the atom needs to be read outside the currently ongoing transaction context\n    // in such case we still might need to calculate the atom, but should ignore any currently active\n    // calculation of the another atom\n    get(identifier) {\n        // see the comment for the `onEffectSync`\n        if (!(identifier instanceof Identifier))\n            return this.yieldSync(identifier);\n        let entry;\n        const activeEntry = this.getActiveEntry();\n        if (activeEntry) {\n            entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);\n        }\n        else {\n            entry = this.entries.get(identifier);\n            if (!entry) {\n                const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n                if (!previousEntry)\n                    throwUnknownIdentifier(identifier);\n                entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);\n            }\n        }\n        const value1 = entry.getValue();\n        if (value1 === TombStone)\n            throwUnknownIdentifier(identifier);\n        // the `&& entry.hasValue()` part was added to allow KEEP_TRYING_TO_RESOLVE feature for references\n        if (value1 !== undefined && entry.hasValue())\n            return value1;\n        if (entry.promise)\n            return entry.promise;\n        //----------------------\n        \n        // now need to repeat the logic\n        if (!entry.previous || !entry.previous.hasValue())\n            entry.forceCalculation();\n        //----------------------\n        while (this.stackGen.getLowestLevel() < identifier.level) {\n            // here we force the computations for lower level identifiers should be sync\n            this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());\n        }\n        this.markSelfDependent();\n        if (identifier.sync) {\n            this.calculateTransitionsStackSync(this.onEffectSync, [entry]);\n            const value = entry.getValue();\n            \n            if (value === undefined)\n                throw new Error('Cycle during synchronous computation');\n            if (value === TombStone)\n                throwUnknownIdentifier(identifier);\n            return value;\n        }\n        else {\n            const promise = this.ongoing = entry.promise = this.ongoing.then(() => {\n                // entry might be already calculated (in the `ongoing` promise), so no need to calculate it\n                if (entry.getValue() === undefined)\n                    return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [entry]], this);\n            }).then(() => {\n                if (this.rejectedWith)\n                    throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);\n                // we clear the promise in the `resetToEpoch` should be enough?\n                // entry.promise   = undefined\n                const value = entry.getValue();\n                \n                if (value === undefined)\n                    throw new Error('Computation cycle. Async get');\n                if (value === TombStone)\n                    throwUnknownIdentifier(identifier);\n                return value;\n                // \n                // if (!entry.hasValue()) throw new Error('Computation cycle. Async get')\n                //\n                // return entry.getValue()\n            });\n            if (DEBUG) {\n                // @ts-ignore\n                promise.quark = entry;\n            }\n            return promise;\n            // return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [ this.onEffectAsync, [ entry ] ], this).then(() => {\n            //     const value     = entry.getValue()\n            //\n            //     \n            //     if (value === undefined) throw new Error('Cycle during synchronous computation')\n            //     if (value === TombStone) throwUnknownIdentifier(identifier)\n            //\n            //     return value\n            // })\n        }\n    }\n    // this seems to be an optimistic version\n    read(identifier) {\n        // see the comment for the `onEffectSync`\n        if (!(identifier instanceof Identifier))\n            return this.yieldSync(identifier);\n        let entry;\n        const activeEntry = this.getActiveEntry();\n        if (activeEntry) {\n            entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);\n        }\n        else {\n            entry = this.entries.get(identifier);\n            if (!entry) {\n                const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n                if (!previousEntry)\n                    throwUnknownIdentifier(identifier);\n                entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);\n            }\n        }\n        const value1 = entry.getValue();\n        if (value1 === TombStone)\n            throwUnknownIdentifier(identifier);\n        if (value1 !== undefined)\n            return value1;\n        // if (!identifier.sync) throw new Error(\"Can not calculate asynchronous identifier synchronously\")\n        \n        // now need to repeat the logic\n        if (!entry.previous || !entry.previous.hasValue())\n            entry.forceCalculation();\n        //----------------------\n        while (this.stackGen.getLowestLevel() < identifier.level) {\n            this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());\n        }\n        //----------------------\n        this.markSelfDependent();\n        this.calculateTransitionsStackSync(this.onEffectSync, [entry]);\n        const value = entry.getValue();\n        \n        if (value === undefined)\n            throw new Error('Cycle during synchronous computation');\n        if (value === TombStone)\n            throwUnknownIdentifier(identifier);\n        return value;\n    }\n    // semantic is actually - read the most-fresh value\n    readCurrentOrProposedOrPrevious(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark) {\n            const value = dirtyQuark.getValue();\n            if (value !== undefined)\n                return value;\n            if (dirtyQuark.proposedValue !== undefined)\n                return dirtyQuark.proposedValue;\n        }\n        return this.readPrevious(identifier);\n    }\n    readCurrentOrProposedOrPreviousAsync(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark) {\n            const value = dirtyQuark.getValue();\n            if (value !== undefined)\n                return value;\n            if (dirtyQuark.proposedValue !== undefined)\n                return dirtyQuark.proposedValue;\n        }\n        return this.readPreviousAsync(identifier);\n    }\n    readPrevious(identifier) {\n        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n        if (!previousEntry)\n            return undefined;\n        const value = previousEntry.getValue();\n        return value !== TombStone ? (value === undefined && identifier.lazy ? this.read(identifier) : value) : undefined;\n    }\n    readPreviousAsync(identifier) {\n        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n        if (!previousEntry)\n            return undefined;\n        const value = previousEntry.getValue();\n        return value !== TombStone ? (value !== undefined ? value : this.readAsync(identifier)) : undefined;\n    }\n    readProposedOrPrevious(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark && dirtyQuark.proposedValue !== undefined) {\n            return dirtyQuark.proposedValue;\n        }\n        else {\n            return this.readPrevious(identifier);\n        }\n    }\n    readProposedOrPreviousAsync(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark && dirtyQuark.proposedValue !== undefined) {\n            return dirtyQuark.proposedValue;\n        }\n        else {\n            return this.readPreviousAsync(identifier);\n        }\n    }\n    write(identifier, proposedValue, ...args) {\n        if (proposedValue === undefined)\n            proposedValue = null;\n        // this.writes.push(WriteEffect.new({\n        //     identifier      : identifier,\n        //     proposedArgs    : [ proposedValue, ...args ]\n        // }))\n        //\n        // this.onNewWrite()\n        identifier.write.call(identifier.context || identifier, identifier, this, null, /*this.getWriteTarget(identifier),*/ proposedValue, ...args);\n        const entry = this.entries.get(identifier);\n        this.hasVariableEntry = this.hasVariableEntry || (!entry.isShadow() && identifier.level === Levels.UserInput);\n        this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || entry.hasProposedValue();\n    }\n    // acquireQuark<T extends Identifier> (identifier : T) : InstanceType<T[ 'quarkClass' ]> {\n    //     return this.touch(identifier).startOrigin() as InstanceType<T[ 'quarkClass' ]>\n    // }\n    getWriteTarget(identifier) {\n        return this.touch(identifier).startOrigin();\n    }\n    // return quark if it exists and is non-shadowing, otherwise undefined\n    acquireQuarkIfExists(identifier) {\n        const entry = this.entries.get(identifier);\n        return entry && entry.origin === entry ? entry.origin : undefined;\n    }\n    touch(identifier) {\n        const existingEntry = this.entries.get(identifier);\n        if (!existingEntry || existingEntry.visitEpoch < this.walkContext.currentEpoch)\n            this.walkContext.continueFrom([identifier]);\n        const entry = existingEntry || this.entries.get(identifier);\n        entry.forceCalculation();\n        return entry;\n    }\n    // touchInvalidate (identifier : Identifier) : Quark {\n    //     const existingEntry         = this.entries.get(identifier)\n    //\n    //     if (existingEntry && existingEntry.hasValue()) {\n    //         this.walkContext.startNewEpoch()\n    //     }\n    //\n    //     if (!existingEntry || existingEntry.visitEpoch < this.walkContext.currentEpoch) this.walkContext.continueFrom([ identifier ])\n    //\n    //     const entry                 = existingEntry || this.entries.get(identifier)\n    //\n    //     entry.forceCalculation()\n    //\n    //     return entry\n    // }\n    hasIdentifier(identifier) {\n        const activeEntry = this.entries.get(identifier);\n        if (activeEntry && activeEntry.getValue() === TombStone)\n            return false;\n        return Boolean(activeEntry || this.baseRevision.getLatestEntryFor(identifier));\n    }\n    // this is actually an optimized version of `write`, which skips the graph walk phase\n    // (since the identifier is assumed to be new, there should be no dependent quarks)\n    addIdentifier(identifier, proposedValue, ...args) {\n        // however, the identifier may be already in the transaction, for example if the `write` method\n        // of some other identifier writes to this identifier\n        let entry = this.entries.get(identifier);\n        const alreadyHadEntry = Boolean(entry);\n        const isVariable = identifier.level === Levels.UserInput;\n        if (!entry) {\n            entry = identifier.newQuark(this.baseRevision);\n            entry.previous = this.baseRevision.getLatestEntryFor(identifier);\n            entry.forceCalculation();\n            this.entries.set(identifier, entry);\n            if (!identifier.lazy && !isVariable)\n                this.stackGen.push(entry);\n            this.hasVariableEntry = this.hasVariableEntry || (!entry.isShadow() && isVariable);\n            this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || entry.hasProposedValue();\n        }\n        if (proposedValue !== undefined || isVariable) {\n            \n            entry.startOrigin();\n            // we should not write if there's already an entry with some values (and we are trying to add it again)\n            // this means there were some other identifier that has written into this one even before it was added\n            // (probably in its `write` method)\n            const shouldNotWrite = alreadyHadEntry && (entry.proposedValue !== undefined || entry.value !== undefined);\n            // however, if that entry contain TombStone marks, we should always write - means we are\n            // actually re-adding the identifier, which has been removed in the same transaction\n            if (!shouldNotWrite || entry.proposedValue === TombStone || entry.value === TombStone) {\n                identifier.isWritingUndefined = proposedValue === undefined;\n                identifier.write.call(identifier.context || identifier, identifier, this, entry, proposedValue === undefined && isVariable ? null : proposedValue, ...args);\n                identifier.isWritingUndefined = false;\n            }\n        }\n        // if we are re-adding the same identifier in the same transaction, clear the TombStone flag\n        if (entry.getValue() === TombStone)\n            entry.value = undefined;\n        if (entry.proposedValue === TombStone)\n            entry.proposedValue = undefined;\n        identifier.enterGraph(this.graph);\n        return entry;\n    }\n    removeIdentifier(identifier) {\n        identifier.leaveGraph(this.graph);\n        const entry = this.touch(identifier).startOrigin();\n        entry.setValue(TombStone);\n        // removing the identifier from self-dependent, otherwise there will be an attempt to evaluate it\n        this.candidate.selfDependent.delete(identifier);\n    }\n    populateCandidateScopeFromTransitions(candidate, scope) {\n        if (candidate.scope.size === 0) {\n            // in this branch we can overwrite the whole map\n            candidate.scope = scope;\n        }\n        else {\n            // in this branch candidate's scope already has some content - this is the case for calculating lazy values\n            // \n            // entries.forEach((entry : QuarkEntry, identifier : Identifier) => {\n            //     candidate.scope.set(identifier, entry)\n            // })\n            for (const [identifier, quark] of scope) {\n                if (quark.isShadow()) {\n                    const latestEntry = candidate.getLatestEntryFor(identifier);\n                    \n                    // and we iterate over the edges from \"origin\" anyway\n                    quark.getOutgoing().forEach((toQuark, toIdentifier) => latestEntry.getOutgoing().set(toIdentifier, toQuark));\n                }\n                else {\n                    candidate.scope.set(identifier, quark);\n                }\n            }\n        }\n    }\n    preCommit(args) {\n        if (this.isClosed)\n            throw new Error('Can not propagate closed revision');\n        this.markSelfDependent();\n        this.isClosed = true;\n        this.propagationStartDate = Date.now();\n        this.plannedTotalIdentifiersToCalculate = this.stackGen.length;\n    }\n    postCommit() {\n        this.populateCandidateScopeFromTransitions(this.candidate, this.entries);\n        // won't be available after next line\n        const entries = this.entries;\n        // for some reason need to cleanup the `walkContext` manually, otherwise the extra revisions hangs in memory\n        this.walkContext = undefined;\n        return { revision: this.candidate, entries, transaction: this };\n    }\n    commit(args) {\n        this.preCommit(args);\n        this.calculateTransitionsSync(this.onEffectSync);\n        // runGeneratorSyncWithEffect(this.onEffectSync, this.calculateTransitionsStackGen, [ this.onEffectSync, stack ], this)\n        return this.postCommit();\n    }\n    reject(rejection = RejectEffect.new()) {\n        this.rejectedWith = rejection;\n        this.walkContext = undefined;\n    }\n    // stops the calculations, but does not reject\n    stop() {\n        this.stopped = true;\n    }\n    clearRejected() {\n        for (const quark of this.entries.values()) {\n            quark.cleanup();\n            // quark.clearOutgoing()\n        }\n        this.entries.clear();\n    }\n    // // propagation that does not use generators at all\n    // propagateSync (args? : PropagateArguments) : TransactionPropagateResult {\n    //     const stack = this.prePropagate(args)\n    //\n    //     this.calculateTransitionsStackSync(this.onEffectSync, stack)\n    //     // runGeneratorSyncWithEffect(this.onEffectSync, this.calculateTransitionsStackGen, [ this.onEffectSync, stack ], this)\n    //\n    //     return this.postPropagate()\n    // }\n    async commitAsync(args) {\n        this.preCommit(args);\n        return this.ongoing = this.ongoing.then(() => {\n            return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitions, [this.onEffectAsync], this);\n        }).then(() => {\n            return this.postCommit();\n        });\n        // await runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitions, [ this.onEffectAsync ], this)\n        //\n        // return this.postCommit()\n    }\n    getLatestEntryFor(identifier) {\n        let entry = this.entries.get(identifier) || this.baseRevision.getLatestEntryFor(identifier);\n        if (entry && entry.getValue() === TombStone)\n            return undefined;\n        return entry;\n    }\n    // check the transaction \"entries\" first, but only return an entry\n    // from that, if it is already calculated, otherwise - take it\n    // from the base revision\n    getLatestStableEntryFor(identifier) {\n        let entry = this.entries.get(identifier);\n        if (entry) {\n            const value = entry.getValue();\n            if (value === TombStone)\n                return undefined;\n            return value === undefined ? this.baseRevision.getLatestEntryFor(identifier) : entry;\n        }\n        else {\n            return this.baseRevision.getLatestEntryFor(identifier);\n        }\n    }\n    addEdge(identifierRead, activeEntry, type) {\n        const identifier = activeEntry.identifier;\n        if (identifier.level < identifierRead.level)\n            throw new Error('Identifier can not read from higher level identifier');\n        let entry = this.entries.get(identifierRead);\n        // creating \"shadowing\" entry, to store the new edges\n        if (!entry) {\n            const previousEntry = this.baseRevision.getLatestEntryFor(identifierRead);\n            if (!previousEntry)\n                throwUnknownIdentifier(identifierRead);\n            entry = identifierRead.newQuark(this.baseRevision);\n            entry.setOrigin(previousEntry);\n            entry.previous = previousEntry;\n            this.entries.set(identifierRead, entry);\n        }\n        entry.addOutgoingTo(activeEntry, type);\n        return entry;\n    }\n    onQuarkCalculationCompleted(entry, value) {\n        // cleanup the iterator\n        entry.cleanup();\n        const identifier = entry.identifier;\n        const previousEntry = entry.previous;\n        //--------------------\n        const sameAsPrevious = Boolean(previousEntry && previousEntry.hasValue() && identifier.equality(value, previousEntry.getValue()));\n        if (sameAsPrevious) {\n            previousEntry.outgoingInTheFutureAndPastTransactionCb(this, previousOutgoingEntry => {\n                const outgoingEntry = this.entries.get(previousOutgoingEntry.identifier);\n                if (outgoingEntry)\n                    outgoingEntry.edgesFlow--;\n            });\n            // this is a \"workaround\" for the following problem:\n            // there might be several copies of the same quark in the calculation stack, this is normal\n            // because if quark is requested by some other quark it is just pushed to the stack,\n            // which may already contain this quark\n            // then when the quark is calculated (this code) it propagates the `edgesFlow` decrease\n            // but next time it will be encountered in the stack, its `edgesFlow` might be decreased by other\n            // identifiers, which will trigger another round of `edgesFlow` decrease propagation\n            // so we set the `edgesFlow` to MAX_SMI after decrease been propagated to prevent repeated such propagation\n            entry.edgesFlow = MAX_SMI;\n            entry.setOrigin(previousEntry.origin);\n            // seems not needed anymore?\n            // this is to indicate that this entry should be recalculated (origin removed)\n            // see `resetToEpoch`\n            entry.value = value;\n        }\n        else {\n            entry.startOrigin();\n            entry.setValue(value);\n        }\n        //--------------------\n        let ignoreSelfDependency = false;\n        if (entry.usedProposedOrPrevious) {\n            if (entry.proposedValue !== undefined) {\n                if (identifier.equality(value, entry.proposedValue))\n                    ignoreSelfDependency = true;\n            }\n            else {\n                // ignore the uninitialized atoms (`proposedValue` === undefined && !previousEntry)\n                // which has been calculated to `null` - we don't consider this as a change\n                if (sameAsPrevious || (!previousEntry && value === null))\n                    ignoreSelfDependency = true;\n            }\n            if (!ignoreSelfDependency)\n                this.candidate.selfDependent.add(identifier);\n        }\n    }\n    onReadIdentifier(identifierRead, activeEntry, stack) {\n        const requestedEntry = this.addEdge(identifierRead, activeEntry, EdgeTypeNormal);\n        // this is a workaround for references with failed resolution problem in gantt\n        // those references return `hasValue() === false` even that they actually have value\n        // (which is `null` and needed to be recalculated)\n        if (requestedEntry.hasValue() || requestedEntry.value !== undefined) {\n            const value = requestedEntry.getValue();\n            if (value === TombStone)\n                throwUnknownIdentifier(identifierRead);\n            return activeEntry.continueCalculation(value);\n        }\n        else if (requestedEntry.isShadow()) {\n            // shadow entry is shadowing a quark w/o value - it is still transitioning or lazy\n            // in both cases start new calculation\n            requestedEntry.startOrigin();\n            requestedEntry.forceCalculation();\n            stack.push(requestedEntry);\n            return undefined;\n        }\n        else {\n            if (!requestedEntry.isCalculationStarted()) {\n                stack.push(requestedEntry);\n                if (!requestedEntry.previous || !requestedEntry.previous.hasValue())\n                    requestedEntry.forceCalculation();\n                return undefined;\n            }\n            else {\n                // cycle - the requested quark has started calculation (means it was encountered in the calculation loop before)\n                // but the calculation did not complete yet (even that requested quark is calculated before the current)\n                let cycle;\n                const walkContext = TransactionCycleDetectionWalkContext.new({\n                    transaction: this,\n                    onCycle(node, stack) {\n                        cycle = ComputationCycle.new({\n                            cycle: cycleInfo(stack),\n                            requestedEntry,\n                            activeEntry,\n                        });\n                        return OnCycleAction.Cancel;\n                    }\n                });\n                walkContext.startFrom([requestedEntry.identifier]);\n                return cycle;\n            }\n        }\n    }\n    *calculateTransitions(context) {\n        const queue = this.stackGen;\n        while (queue.length) {\n            \n            // some identifiers from the queue??\n            yield* this.calculateTransitionsStackGen(context, queue.takeLowestLevel());\n        }\n    }\n    calculateTransitionsSync(context) {\n        const queue = this.stackGen;\n        while (queue.length) {\n            this.calculateTransitionsStackSync(context, queue.takeLowestLevel());\n        }\n    }\n    // this method is not decomposed into smaller ones intentionally, as that makes benchmarks worse\n    // it seems that overhead of calling few more functions in such tight loop as this outweighs the optimization\n    *calculateTransitionsStackGen(context, stack) {\n        if (this.rejectedWith || this.stopped)\n            return;\n        this.walkContext.startNewEpoch();\n        const entries = this.entries;\n        const propagationStartDate = this.propagationStartDate;\n        const enableProgressNotifications = this.graph ? this.graph.enableProgressNotifications : false;\n        let counter = 0;\n        const prevActiveStack = this.activeStack;\n        this.activeStack = stack;\n        while (stack.length && !this.rejectedWith && !this.stopped) {\n            if (enableProgressNotifications && !(counter++ % this.emitProgressNotificationsEveryCalculations)) {\n                const now = Date.now();\n                const elapsed = now - propagationStartDate;\n                if (elapsed > this.startProgressNotificationsAfterMs) {\n                    const lastProgressNotificationDate = this.lastProgressNotificationDate;\n                    if (!lastProgressNotificationDate || (now - lastProgressNotificationDate) > this.emitProgressNotificationsEveryMs) {\n                        this.lastProgressNotificationDate = now;\n                        this.graph.onPropagationProgressNotification({\n                            total: this.plannedTotalIdentifiersToCalculate,\n                            remaining: this.stackGen.length + stack.length,\n                            phase: 'propagating'\n                        });\n                        // need to \"exit\" the context of the current transaction for the time of the following `delay()`\n                        // otherwise, any reads from graph during that time will be recorded as the dependencies\n                        // of the currently active atom\n                        this.activeStack = prevActiveStack;\n                        yield delay(0);\n                        this.activeStack = stack;\n                    }\n                }\n            }\n            if (this.rejectedWith || this.stopped)\n                break;\n            const entry = stack[stack.length - 1];\n            const identifier = entry.identifier;\n            \n            const ownEntry = entries.get(identifier);\n            if (ownEntry !== entry) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if (entry.edgesFlow == 0) {\n                // even if we delete the entry there might be other copies in stack, so reduce the `edgesFlow` to -1\n                // to indicate that those are already processed\n                entry.edgesFlow--;\n                const previousEntry = entry.previous;\n                previousEntry && previousEntry.outgoingInTheFutureAndPastTransactionCb(this, outgoing => {\n                    const outgoingEntry = entries.get(outgoing.identifier);\n                    if (outgoingEntry)\n                        outgoingEntry.edgesFlow--;\n                });\n            }\n            // the \"edgesFlow < 0\" indicates that none of the incoming deps of this quark has changed\n            // thus we don't need to calculate it, moreover, we can remove the quark from the `entries`\n            // to expose the value from the previous revision\n            // however, we only do it, when there is a quark from previous revision and it has \"origin\" (some value)\n            if (entry.edgesFlow < 0 && entry.previous && entry.previous.origin) {\n                // even if the entry will be deleted from the transaction, we set the correct origin for it\n                // this is because there might be other references to this entry in the stack\n                // and also the entry may be referenced as dependency of some other quark\n                // in such case the correct `originId` will preserve dependency during revisions compactification\n                entry.setOrigin(entry.previous.origin);\n                // if there's no outgoing edges we remove the quark\n                if (entry.size === 0) {\n                    entries.delete(identifier);\n                }\n                // reduce garbage collection workload\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if ( /*entry.isShadow() ||*/entry.hasValue() || entry.proposedValue === TombStone) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            const startedAtEpoch = entry.visitEpoch;\n            let iterationResult = entry.isCalculationStarted() ? entry.iterationResult : entry.startCalculation(this.onEffectSync);\n            while (iterationResult && !this.rejectedWith && !this.stopped) {\n                const value = iterationResult.value === undefined ? null : iterationResult.value;\n                if (entry.isCalculationCompleted()) {\n                    if (entry.visitEpoch == startedAtEpoch) {\n                        this.onQuarkCalculationCompleted(entry, value);\n                    }\n                    stack.pop();\n                    break;\n                }\n                else if (value instanceof Identifier) {\n                    const onReadIdentifierResult = this.onReadIdentifier(value, entry, stack);\n                    // handle the cycle\n                    if (onReadIdentifierResult instanceof ComputationCycle) {\n                        this.walkContext.startNewEpoch();\n                        yield* this.graph.onComputationCycleHandler(onReadIdentifierResult);\n                        entry.cleanupCalculation();\n                        iterationResult = undefined;\n                    }\n                    else {\n                        iterationResult = onReadIdentifierResult;\n                    }\n                }\n                else if (value === SynchronousCalculationStarted) {\n                    // the fact, that we've encountered `SynchronousCalculationStarted` constant can mean 2 things:\n                    // 1) there's a cycle during synchronous computation (we throw exception in `read` method)\n                    // 2) some other computation is reading synchronous computation, that has already started\n                    //    in such case its safe to just unwind the stack\n                    stack.pop();\n                    break;\n                }\n                else {\n                    // bypass the unrecognized effect to the outer context\n                    const effectResult = yield value;\n                    // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // in such case we can not continue calculation and just exit the inner loop\n                    if (effectResult === BreakCurrentStackExecution)\n                        break;\n                    // // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // // in such case we can not continue calculation and just exit the inner loop\n                    // if (entry.iterationResult)\n                    if (entry.visitEpoch === startedAtEpoch) {\n                        iterationResult = entry.continueCalculation(effectResult);\n                    }\n                    else {\n                        stack.pop();\n                        break;\n                    }\n                    // else\n                    //     iterationResult         = null\n                }\n            }\n        }\n        this.activeStack = prevActiveStack;\n    }\n    // THIS METHOD HAS TO BE KEPT SYNCED WITH THE `calculateTransitionsStackGen` !!!\n    calculateTransitionsStackSync(context, stack) {\n        if (this.rejectedWith || this.stopped)\n            return;\n        this.walkContext.startNewEpoch();\n        const entries = this.entries;\n        const prevActiveStack = this.activeStack;\n        this.activeStack = stack;\n        while (stack.length && !this.rejectedWith && !this.stopped) {\n            const entry = stack[stack.length - 1];\n            const identifier = entry.identifier;\n            \n            const ownEntry = entries.get(identifier);\n            if (ownEntry !== entry) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if (entry.edgesFlow == 0) {\n                // even if we delete the entry there might be other copies in stack, so reduce the `edgesFlow` to -1\n                // to indicate that those are already processed\n                entry.edgesFlow--;\n                const previousEntry = entry.previous;\n                previousEntry && previousEntry.outgoingInTheFutureAndPastTransactionCb(this, outgoing => {\n                    const outgoingEntry = entries.get(outgoing.identifier);\n                    if (outgoingEntry)\n                        outgoingEntry.edgesFlow--;\n                });\n            }\n            // the \"edgesFlow < 0\" indicates that none of the incoming deps of this quark has changed\n            // thus we don't need to calculate it, moreover, we can remove the quark from the `entries`\n            // to expose the value from the previous revision\n            // however, we only do it, when there is a quark from previous revision and it has \"origin\" (some value)\n            if (entry.edgesFlow < 0 && entry.previous && entry.previous.origin) {\n                // even if the entry will be deleted from the transaction, we set the correct origin for it\n                // this is because there might be other references to this entry in the stack\n                // and also the entry may be referenced as dependency of some other quark\n                // in such case the correct `originId` will preserve dependency during revisions compactification\n                entry.setOrigin(entry.previous.origin);\n                // if there's no outgoing edges we remove the quark\n                if (entry.size === 0) {\n                    entries.delete(identifier);\n                }\n                // reduce garbage collection workload\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if ( /*entry.isShadow() ||*/entry.hasValue() || entry.proposedValue === TombStone) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            const startedAtEpoch = entry.visitEpoch;\n            let iterationResult = entry.isCalculationStarted() ? entry.iterationResult : entry.startCalculation(this.onEffectSync);\n            while (iterationResult && !this.rejectedWith && !this.stopped) {\n                const value = iterationResult.value === undefined ? null : iterationResult.value;\n                if (entry.isCalculationCompleted()) {\n                    if (entry.visitEpoch == startedAtEpoch) {\n                        this.onQuarkCalculationCompleted(entry, value);\n                    }\n                    stack.pop();\n                    break;\n                }\n                else if (value instanceof Identifier) {\n                    const onReadIdentifierResult = this.onReadIdentifier(value, entry, stack);\n                    // handle the cycle\n                    if (onReadIdentifierResult instanceof ComputationCycle) {\n                        this.walkContext.startNewEpoch();\n                        this.graph.onComputationCycleHandlerSync(onReadIdentifierResult, this);\n                        entry.cleanupCalculation();\n                        iterationResult = undefined;\n                    }\n                    else {\n                        iterationResult = onReadIdentifierResult;\n                    }\n                }\n                else if (value === SynchronousCalculationStarted) {\n                    // the fact, that we've encountered `SynchronousCalculationStarted` constant can mean 2 things:\n                    // 1) there's a cycle during synchronous computation (we throw exception in `read` method)\n                    // 2) some other computation is reading synchronous computation, that has already started\n                    //    in such case its safe to just unwind the stack\n                    stack.pop();\n                    break;\n                }\n                else {\n                    // bypass the unrecognized effect to the outer context\n                    const effectResult = context(value);\n                    if (isPromise(effectResult))\n                        throw new Error(\"Effect resolved to promise in the synchronous context, check that you marked the asynchronous calculations accordingly\");\n                    // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // in such case we can not continue calculation and just exit the inner loop\n                    if (effectResult === BreakCurrentStackExecution)\n                        break;\n                    // // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // // in such case we can not continue calculation and just exit the inner loop\n                    // if (entry.iterationResult)\n                    if (entry.visitEpoch === startedAtEpoch) {\n                        iterationResult = entry.continueCalculation(effectResult);\n                    }\n                    else {\n                        stack.pop();\n                        break;\n                    }\n                    // else\n                    //     iterationResult         = null\n                }\n            }\n        }\n        this.activeStack = prevActiveStack;\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { concat } from \"../collection/Iterator.js\";\nimport { warn } from \"../environment/Debug.js\";\nimport { copySetInto, isGeneratorFunction } from \"../util/Helpers.js\";\nimport { BreakCurrentStackExecution, HasProposedNotPreviousValueSymbol, HasProposedValueSymbol, OwnIdentifierSymbol, OwnQuarkSymbol, PreviousValueOfSymbol, ProposedArgumentsOfSymbol, ProposedOrPreviousSymbol, ProposedOrPreviousValueOfSymbol, ProposedValueOfSymbol, RejectEffect, RejectSymbol, TransactionSymbol, UnsafePreviousValueOfSymbol, UnsafeProposedOrPreviousValueOfSymbol, WriteSeveralSymbol, WriteSymbol } from \"./Effect.js\";\nimport { CalculatedValueGen, CalculatedValueGenC, CalculatedValueSyncC, VariableC } from \"./Identifier.js\";\nimport { TombStone } from \"./Quark.js\";\nimport { Revision } from \"./Revision.js\";\nimport { EdgeTypePast, Transaction } from \"./Transaction.js\";\n/**\n * A constant which will be used a commit result, when graph is not available.\n */\nexport const CommitZero = {\n    rejectedWith: null\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport class Listener extends Base {\n    constructor() {\n        super(...arguments);\n        this.handlers = [];\n    }\n    trigger(value) {\n        for (let i = 0; i < this.handlers.length; i++)\n            this.handlers[i](value);\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Generic reactive graph. Consists from [[Identifier]]s, depending on each other. This is a low-level representation\n * of the ChronoGraph dataset, it is not \"aware\" of the entity/relation framework and operates as \"just graph\".\n *\n * For higher-level (and more convenient) representation, please refer to [[Replica]].\n *\n * An example of usage:\n *\n *     const graph      = ChronoGraph.new({ historyLimit : 10 })\n *\n *     const var1       = graph.variable(1)\n *     const var2       = graph.variable(2)\n *     const iden1      = graph.identifier((Y) => Y(var1) + Y(var2))\n *\n *     graph.read(iden1) // 3\n *\n *     graph.commit()\n *\n *     graph.write(var1, 2)\n *\n *     graph.read(iden1) // 4\n *\n *     graph.reject()\n *\n *     graph.read(var1) // 1\n *     graph.read(iden1) // 3\n *\n */\nexport class ChronoGraph extends Base {\n    constructor() {\n        super(...arguments);\n        this.baseRevisionStable = undefined;\n        this.baseRevisionTentative = undefined;\n        this.baseRevision = Revision.new();\n        // the revision to follow to, when performing `redo` operation\n        this.topRevision = undefined;\n        /**\n         * Integer value, indicating how many transactions to keep in memory, to be available for [[undo]] call.\n         * Default value is 0 - previous transaction is cleared immediately.\n         *\n         * Increase this config to opt-in for the [[undo]]/[[redo]] functionality.\n         */\n        this.historyLimit = 0;\n        this.listeners = new Map();\n        // this flag is set when the data being written to the graph is \"undo/redo\" data\n        // in such case, we shouldn't treat it as user input, but instead as a side-effect free\n        // state restoration\n        // this flag is used in the CycleResolverChrono and in general is engine specific\n        this.isWritingPreviousData = false;\n        this.$activeTransaction = undefined;\n        this.isCommitting = false;\n        this.enableProgressNotifications = false;\n        this.ongoing = Promise.resolve();\n        this._isInitialCommit = true;\n        //-------------------------------------\n        // a \"cross-platform\" trick to avoid specifying the type of the `autoCommitTimeoutId` explicitly\n        this.autoCommitTimeoutId = null;\n        /**\n         * If this option is enabled with `true` value, all data modification calls ([[write]], [[addIdentifier]], [[removeIdentifier]]) will trigger\n         * a delayed [[commit]] call (or [[commitAsync]], depending from the [[autoCommitMode]] option).\n         */\n        this.autoCommit = false;\n        /**\n         * Indicates the default commit mode, which is used in [[autoCommit]].\n         */\n        this.autoCommitMode = 'sync';\n        this.autoCommitHandler = null;\n        this.onWriteDuringCommit = 'throw';\n        this.onComputationCycle = 'throw';\n        this.transactionClass = Transaction;\n        this.isJustCleared = false;\n        this.$followingRevision = undefined;\n    }\n    initialize(...args) {\n        super.initialize(...args);\n        if (!this.topRevision)\n            this.topRevision = this.baseRevision;\n        if (this.autoCommit) {\n            this.autoCommitHandler = this.autoCommitMode === 'sync' ? arg => this.commit(arg) : async (arg) => this.commitAsync(arg);\n        }\n        this.markAndSweep();\n    }\n    /**\n     * Returns boolean, indicating whether the auto-commit is pending.\n     */\n    hasPendingAutoCommit() {\n        return this.autoCommitTimeoutId !== null;\n    }\n    get dirty() {\n        return this.activeTransaction.dirty;\n    }\n    clear() {\n        this.reject();\n        this.unScheduleAutoCommit();\n        // some stale state - `clear` called at sensitive time\n        this.baseRevision.scope && this.baseRevision.scope.clear();\n        this.baseRevision.previous = null;\n        this.listeners.clear();\n        this.topRevision = this.baseRevision;\n        this.$followingRevision = undefined;\n        this.$activeTransaction = undefined;\n        this.markAndSweep();\n        this.isJustCleared = true;\n    }\n    *eachReachableRevision() {\n        let isBetweenTopBottom = true;\n        let counter = 0;\n        for (const revision of this.topRevision.previousAxis()) {\n            yield [revision, isBetweenTopBottom || counter < this.historyLimit];\n            if (revision === this.baseRevision) {\n                isBetweenTopBottom = false;\n            }\n            else {\n                if (!isBetweenTopBottom)\n                    counter++;\n            }\n        }\n    }\n    get isInitialCommit() {\n        return this._isInitialCommit;\n    }\n    set isInitialCommit(value) {\n        this._isInitialCommit = value;\n    }\n    markAndSweep() {\n        let lastReferencedRevision;\n        const unreachableRevisions = [];\n        for (const [revision, isReachable] of this.eachReachableRevision()) {\n            if (isReachable) {\n                revision.reachableCount++;\n                lastReferencedRevision = revision;\n            }\n            else\n                unreachableRevisions.push(revision);\n            revision.referenceCount++;\n        }\n        unreachableRevisions.unshift(lastReferencedRevision);\n        for (let i = unreachableRevisions.length - 1; i >= 1 && unreachableRevisions[i].reachableCount === 0; i--) {\n            this.compactRevisions(unreachableRevisions[i - 1], unreachableRevisions[i]);\n        }\n    }\n    compactRevisions(newRev, prevRev) {\n        if (prevRev.reachableCount > 0 || newRev.previous !== prevRev)\n            throw new Error(\"Invalid compact operation\");\n        // we can only shred revision if its being referenced maximum 1 time (from the current Checkout instance)\n        if (prevRev.referenceCount <= 1) {\n            for (const [identifier, entry] of newRev.scope) {\n                if (entry.getValue() === TombStone) {\n                    prevRev.scope.delete(identifier);\n                }\n                else {\n                    const prevQuark = prevRev.scope.get(identifier);\n                    if (entry.origin === entry) {\n                        if (prevQuark) {\n                            prevQuark.clear();\n                            prevQuark.clearProperties();\n                        }\n                    }\n                    else if (prevQuark && entry.origin === prevQuark) {\n                        entry.mergePreviousOrigin(newRev.scope);\n                    }\n                    else if (identifier.lazy && !entry.origin && prevQuark && prevQuark.origin) {\n                        // for lazy quarks, that depends on the `ProposedOrPrevious` effect, we need to save the value or proposed value\n                        // from the previous revision\n                        entry.startOrigin().proposedValue = prevQuark.origin.value !== undefined ? prevQuark.origin.value : prevQuark.origin.proposedValue;\n                    }\n                    entry.previous = undefined;\n                    prevRev.scope.set(identifier, entry);\n                }\n            }\n            copySetInto(newRev.selfDependent, prevRev.selfDependent);\n            // some help for garbage collector\n            // this clears the \"entries\" in the transaction commit result in the \"finalizeCommitAsync\"\n            // newRev.scope.clear()\n            newRev.scope = prevRev.scope;\n            // make sure the previous revision won't be used inconsistently\n            prevRev.scope = null;\n        }\n        // otherwise, we have to copy from it, and keep it intact\n        else {\n            newRev.scope = new Map(concat(prevRev.scope, newRev.scope));\n            newRev.selfDependent = new Set(concat(prevRev.selfDependent, newRev.selfDependent));\n            prevRev.referenceCount--;\n        }\n        // in both cases break the `previous` chain\n        newRev.previous = null;\n    }\n    get followingRevision() {\n        if (this.$followingRevision !== undefined)\n            return this.$followingRevision;\n        const revisions = Array.from(this.topRevision.previousAxis());\n        const entries = [];\n        for (let i = revisions.length - 1; i > 0; i--)\n            entries.push([revisions[i], revisions[i - 1]]);\n        return this.$followingRevision = new Map(entries);\n    }\n    get activeTransaction() {\n        if (this.$activeTransaction)\n            return this.$activeTransaction;\n        return this.$activeTransaction = this.transactionClass.new({\n            baseRevision: this.baseRevisionTentative || this.baseRevision,\n            graph: this\n        });\n    }\n    /**\n     * Creates a new branch of this graph. Only committed data will be \"visible\" in the new branch.\n     *\n     * ```ts\n     * const graph2 = ChronoGraph.new()\n     *\n     * const variable13 : Variable<number> = graph2.variable(5)\n     *\n     * const branch2 = graph2.branch()\n     *\n     * branch2.write(variable13, 10)\n     *\n     * const value13_1 = graph2.read(variable13)  // 5\n     * const value13_2 = branch2.read(variable13) // 10\n     * ```\n     *\n     * When using the branching feature in [[Replica]], you need to reference the field values by yielding their\n     * corresponding identifiers. This is because ChronoGraph need to know in context of which branch\n     * the calculation happens and this information is encoded in the outer context. This may improve in the future.\n     *\n     * ```ts\n     * class Author extends Entity.mix(Base) {\n     *     @calculate('fullName')\n     *     calculateFullName (Y) : string {\n     *         return Y(this.$.firstName) + ' ' + Y(this.$.lastName)\n     *     }\n     *\n     *     @calculate('fullName')\n     *     * calculateFullName (Y) : CalculationIterator<string> {\n     *         return (yield this.$.firstName) + ' ' + (yield this.$.lastName)\n     *     }\n     * }\n     * ```\n     *\n     * @param config Configuration object for the new graph instance.\n     */\n    branch(config) {\n        const Constructor = this.constructor;\n        return Constructor.new(Object.assign({}, config, { baseRevision: this.baseRevision }));\n    }\n    propagate(args) {\n        return this.commit(args);\n    }\n    /**\n     * Rejects the current changes in the graph and revert it to the state of the previous [[commit]].\n     *\n     * See also [[RejectEffect]].\n     *\n     * @param reason Any value, describing why reject has happened\n     */\n    reject(reason) {\n        this.activeTransaction.reject(RejectEffect.new({ reason }));\n        // reject resets the `ongoing` promise (which is possibly rejected because of cycle exception)\n        this.ongoing = Promise.resolve();\n        this.$activeTransaction = undefined;\n        this.baseRevisionTentative = undefined;\n        if (this.baseRevisionStable) {\n            this.baseRevision = this.baseRevisionStable;\n            this.baseRevisionStable = undefined;\n        }\n    }\n    /**\n     * Synchronously commit the state of the graph. All potentially changed [[Identifier.lazy|strict]] identifiers\n     * will be calculated during this call. If any of such identifiers will be [[Identifier.sync|async]], an exception\n     * will be thrown.\n     *\n     * This call marks a \"stable\" state of the graph and a transaction border. Using the [[undo]] call one can revert to the previous\n     * state.\n     *\n     * See also [[reject]].\n     *\n     * @param args\n     */\n    commit(args) {\n        this.isJustCleared = false;\n        \n        this.unScheduleAutoCommit();\n        this.baseRevisionStable = this.baseRevision;\n        const activeTransaction = this.activeTransaction;\n        const transactionCommitResult = activeTransaction.commit(args);\n        this.$activeTransaction = undefined;\n        const result = this.finalizeCommit(transactionCommitResult);\n        this.baseRevisionStable = undefined;\n        this.isInitialCommit = false;\n        return result;\n    }\n    async propagateAsync(args) {\n        return this.commitAsync(args);\n    }\n    /**\n     * Asynchronously commit the state of the replica. All potentially changed strict identifiers (see [[Identifier.lazy]])\n     * will be calculated during this call.\n     *\n     * This call marks a \"stable\" state of the graph and a transaction border. Using the [[undo]] call one can revert to the previous\n     * state.\n     *\n     * See also [[reject]].\n     *\n     * @param args\n     */\n    async commitAsync(args) {\n        if (this.isCommitting)\n            return this.ongoing;\n        this.isJustCleared = false;\n        this.isCommitting = true;\n        this.baseRevisionStable = this.baseRevision;\n        let result;\n        return this.ongoing = this.ongoing.then(() => {\n            return this.doCommitAsync(args);\n        }).then(res => {\n            result = res;\n            return res;\n        }).finally(() => {\n            this.baseRevisionStable = undefined;\n            this.baseRevisionTentative = undefined;\n            this.isInitialCommit = false;\n            this.isCommitting = false;\n        });\n    }\n    async doCommitAsync(args) {\n        this.unScheduleAutoCommit();\n        const activeTransaction = this.activeTransaction;\n        const transactionResult = await activeTransaction.commitAsync(args);\n        const rejectedDuringCommit = Boolean(activeTransaction.rejectedWith);\n        const prevBaseTentative = this.baseRevisionTentative;\n        if (!rejectedDuringCommit)\n            this.baseRevisionTentative = activeTransaction.candidate;\n        this.$activeTransaction = undefined;\n        await this.finalizeCommitAsync(transactionResult);\n        if (this.isJustCleared)\n            return { rejectedWith: RejectEffect.new({ reason: 'Graph cleared' }) };\n        if (activeTransaction.rejectedWith && !rejectedDuringCommit) {\n            this.baseRevisionTentative = prevBaseTentative;\n            this.$activeTransaction = undefined;\n        }\n        const result = this.finalizeCommit(transactionResult);\n        if (activeTransaction.rejectedWith)\n            activeTransaction.clearRejected();\n        if (this.dirty && !activeTransaction.rejectedWith) {\n            await this.doCommitAsync(args);\n        }\n        return result;\n    }\n    finalizeCommit(transactionResult) {\n        const { revision, entries, transaction } = transactionResult;\n        if (!transaction.rejectedWith) {\n            if (revision.previous !== this.baseRevision)\n                throw new Error('Invalid revisions chain');\n            // dereference all revisions\n            for (const [revision, isReachable] of this.eachReachableRevision()) {\n                if (isReachable)\n                    revision.reachableCount--;\n                revision.referenceCount--;\n            }\n            this.baseRevision = this.topRevision = revision;\n            // activating listeners BEFORE the `markAndSweep`, because in that call, `baseRevision`\n            // might be already merged with previous\n            for (const [identifier, quarkEntry] of entries) {\n                quarkEntry.cleanup();\n                // ignore \"shadowing\" and lazy entries\n                if (quarkEntry.isShadow() || !quarkEntry.hasValue())\n                    continue;\n                const listener = this.listeners.get(identifier);\n                if (listener)\n                    listener.trigger(quarkEntry.getValue());\n            }\n            this.$followingRevision = undefined;\n            this.markAndSweep();\n        }\n        else {\n            // `baseRevisionStable` might be already cleared in the `reject` method of the graph\n            if (this.baseRevisionStable)\n                this.baseRevision = this.baseRevisionStable;\n            this.baseRevisionStable = undefined;\n            this.baseRevisionTentative = undefined;\n        }\n        return { rejectedWith: transaction.rejectedWith };\n    }\n    async finalizeCommitAsync(transactionResult) {\n    }\n    *onComputationCycleHandler(cycle) {\n        const exception = new Error(\"Computation cycle:\\n\" + cycle);\n        //@ts-ignore\n        exception.cycle = cycle;\n        switch (this.onComputationCycle) {\n            case 'ignore':\n                console.log(exception.message);\n                const { requestedEntry, activeEntry } = cycle;\n                // if we ignore the cycle we just continue the calculation with the best possible value\n                return activeEntry.continueCalculation(requestedEntry.proposedValue !== undefined ? requestedEntry.proposedValue : requestedEntry.value);\n            case 'throw':\n                throw exception;\n            case 'reject':\n                this.reject(exception);\n                break;\n            case 'warn':\n                warn(exception);\n                break;\n        }\n    }\n    onComputationCycleHandlerSync(cycle, transaction) {\n        const exception = new Error(\"Computation cycle:\\n\" + cycle);\n        //@ts-ignore\n        exception.cycle = cycle;\n        switch (this.onComputationCycle) {\n            case 'ignore':\n                console.log(exception.message);\n                const { requestedEntry, activeEntry } = cycle;\n                // if we ignore the cycle we just continue the calculation with the best possible value\n                return activeEntry.continueCalculation(requestedEntry.proposedValue !== undefined ? requestedEntry.proposedValue : requestedEntry.value);\n            case 'throw':\n                throw exception;\n            case 'reject':\n                this.reject(exception);\n                break;\n            case 'warn':\n                warn(exception);\n                break;\n        }\n    }\n    scheduleAutoCommit() {\n        // the `&& !this.isCommitting` part was added for the conflicts branch\n        // however, it seems to fail several tests\n        // commenting for now, to be reviewed later\n        if (this.autoCommitTimeoutId === null && !this.isCommitting) {\n            this.autoCommitTimeoutId = setTimeout(this.autoCommitHandler, 10);\n        }\n    }\n    unScheduleAutoCommit() {\n        if (this.autoCommitTimeoutId !== null) {\n            clearTimeout(this.autoCommitTimeoutId);\n            this.autoCommitTimeoutId = null;\n        }\n    }\n    /**\n     * Creates a variable identifier with the given initial value and adds it to graph.\n     *\n     * @param value The initial value. The `undefined` value will be converted to `null`\n     */\n    variable(value) {\n        const variable = VariableC();\n        // always initialize variables with `null`\n        return this.addIdentifier(variable, value === undefined ? null : value);\n    }\n    /**\n     * Creates a named variable identifier with the given initial value and adds it to graph.\n     *\n     * @param name The [[Variable.name]] property of the newly created variable\n     * @param value The initial value. The `undefined` value will be converted to `null`\n     */\n    variableNamed(name, value) {\n        const variable = VariableC({ name });\n        // always initialize variables with `null`\n        return this.addIdentifier(variable, value === undefined ? null : value);\n    }\n    /**\n     * Creates an identifier based on the given calculation function and adds it to this graph. Depending form the type of the function\n     * (sync/generator) either [[CalculatedValueGen]] or [[CalculatedValueSync]] will be created.\n     *\n     * To have full control on the identifier creation, instantiate it yourself and add to graph using the [[ChronoGraph.addIdentifier]] call.\n     *\n     * @param calculation The calculation function of the identifier.\n     * @param context The [[Identifier.context|context]] property of the newly created identifier\n     */\n    identifier(calculation, context) {\n        const identifier = isGeneratorFunction(calculation) ?\n            CalculatedValueGenC({ calculation, context })\n            :\n                CalculatedValueSyncC({ calculation, context });\n        return this.addIdentifier(identifier);\n    }\n    /**\n     * Creates a named identifier based on the given calculation function and adds it to this graph. Depending form the type of the function\n     * (sync/generator) either [[CalculatedValueGen]] or [[CalculatedValueSync]] will be created.\n     *\n     * To have full control on the identifier creation, instantiate it yourself and add to graph using the [[ChronoGraph.addIdentifier]] call.\n     *\n     * @param name The [[Identifier.name]] property of the newly created identifier\n     * @param calculation The calculation function of the identifier.\n     * @param context The [[Identifier.context]] property of the newly created identifier\n     */\n    identifierNamed(name, calculation, context) {\n        const identifier = calculation.constructor.name === 'GeneratorFunction' ?\n            CalculatedValueGenC({ name, calculation, context })\n            :\n                CalculatedValueSyncC({ name, calculation, context });\n        return this.addIdentifier(identifier);\n    }\n    /**\n     * Adds an identifier to this graph. Optionally [[write|writes]] the `proposedValue` to it afterwards.\n     *\n     * @param identifier\n     * @param proposedValue\n     * @param args\n     */\n    addIdentifier(identifier, proposedValue, ...args) {\n        if (this.isCommitting) {\n            if (this.onWriteDuringCommit === 'throw')\n                throw new Error('Adding identifier during commit');\n            else if (this.onWriteDuringCommit === 'warn')\n                warn(new Error('Adding identifier during commit'));\n        }\n        this.activeTransaction.addIdentifier(identifier, proposedValue, ...args);\n        if (this.autoCommit)\n            this.scheduleAutoCommit();\n        return identifier;\n    }\n    /**\n     * Removes an identifier from this graph.\n     *\n     * @param identifier\n     */\n    removeIdentifier(identifier) {\n        if (this.isCommitting) {\n            if (this.onWriteDuringCommit === 'throw')\n                throw new Error('Removing identifier during commit');\n            else if (this.onWriteDuringCommit === 'warn')\n                warn(new Error('Removinfg identifier during commit'));\n        }\n        this.activeTransaction.removeIdentifier(identifier);\n        this.listeners.delete(identifier);\n        if (this.autoCommit)\n            this.scheduleAutoCommit();\n    }\n    /**\n     * Tests, whether this graph has given identifier.\n     *\n     * @param identifier\n     */\n    hasIdentifier(identifier) {\n        return this.activeTransaction.hasIdentifier(identifier);\n    }\n    /**\n     * Writes a value to the given `identifier`.\n     *\n     * @param identifier\n     * @param proposedValue\n     * @param args\n     */\n    write(identifier, proposedValue, ...args) {\n        if (this.isCommitting) {\n            if (this.onWriteDuringCommit === 'throw')\n                throw new Error('Write during commit');\n            else if (this.onWriteDuringCommit === 'warn')\n                warn(new Error('Write during commit'));\n        }\n        this.activeTransaction.write(identifier, proposedValue, ...args);\n        if (this.autoCommit)\n            this.scheduleAutoCommit();\n    }\n    // keep if possible?\n    // pin (identifier : Identifier) : Quark {\n    //     return this.activeTransaction.pin(identifier)\n    // }\n    // Synchronously read the \"previous\", \"stable\" value from the graph. If its a lazy entry, it will be calculated\n    // Synchronous read can not calculate lazy asynchronous identifiers and will throw exception\n    // Lazy identifiers supposed to be \"total\" (or accept repeating observes?)\n    readPrevious(identifier) {\n        return this.activeTransaction.readPrevious(identifier);\n    }\n    // Asynchronously read the \"previous\", \"stable\" value from the graph. If its a lazy entry, it will be calculated\n    // Asynchronous read can calculate both synchornous and asynchronous lazy identifiers.\n    // Lazy identifiers supposed to be \"total\" (or accept repeating observes?)\n    readPreviousAsync(identifier) {\n        return this.activeTransaction.readPreviousAsync(identifier);\n    }\n    /**\n     * Synchronously read the value of the given identifier from the graph.\n     *\n     * Synchronous read can not calculate asynchronous identifiers and will throw exception\n     *\n     * @param identifier\n     */\n    read(identifier) {\n        return this.activeTransaction.read(identifier);\n    }\n    /**\n     * Asynchronously read the value of the given identifier from the graph.\n     *\n     * Asynchronous read can calculate both synchronous and asynchronous identifiers\n     *\n     * @param identifier\n     */\n    readAsync(identifier) {\n        return this.activeTransaction.readAsync(identifier);\n    }\n    /**\n     * Read the value of the identifier either synchronously or asynchronously, depending on its type (see [[Identifier.sync]])\n     *\n     * @param identifier\n     */\n    get(identifier) {\n        return this.activeTransaction.get(identifier);\n    }\n    // // read the identifier value, return the proposed value if no \"current\" value is calculated yet\n    // readDirty<T> (identifier : Identifier<T>) : T {\n    //     return this.activeTransaction.readDirty(identifier)\n    // }\n    //\n    //\n    // // read the identifier value, return the proposed value if no \"current\" value is calculated yet\n    // readDirtyAsync<T> (identifier : Identifier<T>) : Promise<T> {\n    //     return this.activeTransaction.readDirtyAsync(identifier)\n    // }\n    observe(observerFunc, onUpdated) {\n        const identifier = this.addIdentifier(CalculatedValueGen.new({\n            // observers are explicitly eager\n            lazy: false,\n            calculation: observerFunc,\n        }));\n        this.addListener(identifier, onUpdated);\n        return identifier;\n    }\n    observeContext(observerFunc, context, onUpdated) {\n        const identifier = this.addIdentifier(CalculatedValueGen.new({\n            // observers are explicitly eager\n            lazy: false,\n            calculation: observerFunc,\n            context: context,\n        }));\n        this.addListener(identifier, onUpdated);\n        return identifier;\n    }\n    addListener(identifier, onUpdated) {\n        let listener = this.listeners.get(identifier);\n        if (!listener) {\n            listener = Listener.new();\n            this.listeners.set(identifier, listener);\n        }\n        listener.handlers.push(onUpdated);\n    }\n    /**\n     * Revert the replica to the state of previous transaction (marked with the [[commit]] call).\n     *\n     * To enable this feature, you need to opt-in using the [[ChronoGraph.historyLimit|historyLimit]] configuration property.\n     *\n     * Returns boolean, indicating whether the state transition actually happened.\n     */\n    undo() {\n        const baseRevision = this.baseRevision;\n        const previous = baseRevision.previous;\n        if (!previous)\n            return false;\n        this.baseRevision = previous;\n        // note: all unpropagated \"writes\" are lost\n        this.$activeTransaction = undefined;\n        return true;\n    }\n    /**\n     * Advance the replica to the state of next transaction (marked with the [[commit]] call). Only meaningful\n     * if a [[ChronoGraph.undo|undo]] call has been made earlier.\n     *\n     * To enable this feature, you need to opt-in using the [[historyLimit]] configuration property.\n     *\n     * Returns boolean, indicating whether the state transition actually happened.\n     */\n    redo() {\n        const baseRevision = this.baseRevision;\n        if (baseRevision === this.topRevision)\n            return false;\n        const nextRevision = this.followingRevision.get(baseRevision);\n        this.baseRevision = nextRevision;\n        // note: all unpropagated \"writes\" are lost\n        this.$activeTransaction = undefined;\n        return true;\n    }\n    onPropagationProgressNotification(notification) {\n    }\n    [ProposedOrPreviousSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        activeEntry.usedProposedOrPrevious = true;\n        const proposedValue = activeEntry.getProposedValue(transaction);\n        if (proposedValue !== undefined)\n            return proposedValue;\n        // newly added identifier\n        if (!activeEntry.previous)\n            return undefined;\n        const identifier = activeEntry.identifier;\n        if (identifier.lazy) {\n            if (activeEntry.previous.hasValue())\n                return activeEntry.previous.getValue();\n            if (activeEntry.previous.hasProposedValue())\n                return activeEntry.previous.getProposedValue(transaction);\n            return null;\n        }\n        return transaction.readPrevious(activeEntry.identifier);\n    }\n    [RejectSymbol](effect, transaction) {\n        this.reject(effect.reason);\n        return BreakCurrentStackExecution;\n    }\n    [TransactionSymbol](effect, transaction) {\n        return transaction;\n    }\n    [OwnQuarkSymbol](effect, transaction) {\n        return transaction.getActiveEntry();\n    }\n    [OwnIdentifierSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        return activeEntry.identifier;\n    }\n    [WriteSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        if (activeEntry.identifier.lazy)\n            throw new Error('Lazy identifiers can not use `Write` effect');\n        const writeToHigherLevel = effect.identifier.level > activeEntry.identifier.level;\n        if (!writeToHigherLevel)\n            transaction.walkContext.startNewEpoch();\n        transaction.write(effect.identifier, ...effect.proposedArgs);\n        // // transaction.writes.push(effect)\n        //\n        // // const writeTo   = effect.identifier\n        // //\n        // // writeTo.write.call(writeTo.context || writeTo, writeTo, transaction, null, ...effect.proposedArgs)\n        //\n        // transaction.onNewWrite()\n        return writeToHigherLevel ? undefined : BreakCurrentStackExecution;\n    }\n    [WriteSeveralSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        if (activeEntry.identifier.lazy)\n            throw new Error('Lazy identifiers can not use `Write` effect');\n        let writeToHigherLevel = true;\n        // effect.writes.forEach(writeInfo => {\n        effect.writes.forEach(writeInfo => {\n            if (writeInfo.identifier.level <= activeEntry.identifier.level && writeToHigherLevel) {\n                transaction.walkContext.startNewEpoch();\n                writeToHigherLevel = false;\n            }\n            transaction.write(writeInfo.identifier, ...writeInfo.proposedArgs);\n        });\n        // const identifier    = writeInfo.identifier\n        //\n        // identifier.write.call(identifier.context || identifier, identifier, transaction, null, ...writeInfo.proposedArgs)\n        // })\n        // transaction.onNewWrite()\n        return writeToHigherLevel ? undefined : BreakCurrentStackExecution;\n    }\n    [PreviousValueOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        return transaction.readPrevious(source);\n    }\n    [ProposedValueOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        const proposedValue = quark && !quark.isShadow() ? quark.getProposedValue(transaction) : undefined;\n        return proposedValue;\n    }\n    [HasProposedValueSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        return quark ? quark.hasProposedValue() : false;\n    }\n    [HasProposedNotPreviousValueSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        return quark ? quark.hasProposedValue() && !quark.proposedIsPrevious : false;\n    }\n    [ProposedOrPreviousValueOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        return transaction.readProposedOrPrevious(source);\n    }\n    [UnsafeProposedOrPreviousValueOfSymbol](effect, transaction) {\n        return transaction.readProposedOrPrevious(effect.identifier);\n    }\n    [UnsafePreviousValueOfSymbol](effect, transaction) {\n        return transaction.readPrevious(effect.identifier);\n    }\n    [ProposedArgumentsOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        return quark && !quark.isShadow() ? quark.proposedArguments : undefined;\n    }\n}\n", "import { Base } from \"../class/Base.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This class describes an entity. Entity is simply a collection of [[Field]]s. Entity also may have a parent entity,\n * from which it inherit the fields.\n */\nexport class EntityMeta extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the entity\n         */\n        this.name = undefined;\n        this.ownFields = new Map();\n        this.schema = undefined;\n        this.$skeleton = {};\n        this.$allFields = undefined;\n    }\n    /**\n     * Checks whether the entity has a field with given name (possibly inherited from parent entity).\n     *\n     * @param name\n     */\n    hasField(name) {\n        return this.getField(name) !== undefined;\n    }\n    /**\n     * Returns a field with given name (possibly inherited) or `undefined` if there's none.\n     *\n     * @param name\n     */\n    getField(name) {\n        return this.allFields.get(name);\n    }\n    /**\n     * Adds a field to this entity.\n     *\n     * @param field\n     */\n    addField(field) {\n        const name = field.name;\n        if (!name)\n            throw new Error(`Field must have a name`);\n        if (this.ownFields.has(name))\n            throw new Error(`Field with name [${name}] already exists`);\n        field.entity = this;\n        this.ownFields.set(name, field);\n        return field;\n    }\n    forEachParent(func) {\n        let entity = this;\n        while (entity) {\n            func(entity);\n            entity = entity.parentEntity;\n        }\n    }\n    get allFields() {\n        if (this.$allFields !== undefined)\n            return this.$allFields;\n        const allFields = new Map();\n        const visited = new Set();\n        this.forEachParent(entity => {\n            entity.ownFields.forEach((field, name) => {\n                if (!visited.has(name)) {\n                    visited.add(name);\n                    allFields.set(name, field);\n                }\n            });\n        });\n        return this.$allFields = allFields;\n    }\n    /**\n     * Iterator for all fields of this entity (including inherited).\n     *\n     * @param func\n     */\n    forEachField(func) {\n        this.allFields.forEach(func);\n    }\n}\n", "import { ChronoGraph } from \"../chrono/Graph.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nexport var ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"Current\"] = 0] = \"Current\";\n    ReadMode[ReadMode[\"Previous\"] = 1] = \"Previous\";\n    ReadMode[ReadMode[\"ProposedOrPrevious\"] = 2] = \"ProposedOrPrevious\";\n    ReadMode[ReadMode[\"CurrentOrProposedOrPrevious\"] = 3] = \"CurrentOrProposedOrPrevious\";\n})(ReadMode || (ReadMode = {}));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Reactive graph, operating on the set of entities (see [[Entity]] and [[EntityMeta]]), each having a set of fields (see [[Field]]).\n *\n * Entities are mapped to JS classes and fields - to their properties, decorated with [[field]].\n *\n * The calculation function for some field can be mapped to the class method, using the [[calculate]] decorator.\n *\n * An example of usage:\n *\n * ```ts\n * class Author extends Entity.mix(Base) {\n *     @field()\n *     firstName       : string\n *     @field()\n *     lastName        : string\n *     @field()\n *     fullName        : string\n *\n *     @calculate('fullName')\n *     calculateFullName () : string {\n *         return this.firstName + ' ' + this.lastName\n *     }\n * }\n * ```\n */\nexport class Replica extends Mixin([ChronoGraph], (base) => class Replica extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Replica re-defines the default value of the `autoCommit` property to `true`.\n         */\n        this.autoCommit = true;\n        this.readMode = ReadMode.Current;\n    }\n    /**\n     * Add entity instance to the replica\n     *\n     * @param entity\n     */\n    addEntity(entity) {\n        entity.enterGraph(this);\n    }\n    /**\n     * Add several entity instances to the replica\n     *\n     * @param entity\n     */\n    addEntities(entities) {\n        entities.forEach(entity => this.addEntity(entity));\n    }\n    /**\n     * Remove entity instance from the replica\n     *\n     * @param entity\n     */\n    removeEntity(entity) {\n        entity.leaveGraph(this);\n    }\n    /**\n     * Remove several entity instances from the replica\n     *\n     * @param entity\n     */\n    removeEntities(entities) {\n        entities.forEach(entity => this.removeEntity(entity));\n    }\n}) {\n}\n", "import { CalculatedValueGen, CalculatedValueSync, Identifier, Variable } from \"../chrono/Identifier.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { ReadMode } from \"./Replica.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent a field of the entity. Requires the [[Identifier]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class FieldIdentifier extends Mixin([Identifier], (base) => class FieldIdentifier extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Reference to the [[Field]] this identifier represents\n         */\n        this.field = undefined;\n        /**\n         * Reference to the [[Entity]] this identifier represents\n         */\n        this.self = undefined;\n        // temp storage for value for the phase, when identifier is created, but has not joined any graph\n        // is cleared during the 1st join to the graph\n        this.DATA = undefined;\n    }\n    // standaloneQuark     : InstanceType<this[ 'quarkClass' ]>\n    // readFromGraphDirtySync (graph : Checkout) {\n    //     if (graph)\n    //         return graph.readDirty(this)\n    //     else\n    //         return this.DATA\n    // }\n    // returns the value itself if there were no affecting writes for it\n    // otherwise - promise\n    getFromGraph(graph) {\n        if (graph) {\n            if (graph.readMode === ReadMode.Current)\n                return graph.get(this);\n            if (graph.readMode === ReadMode.Previous)\n                return graph.activeTransaction.readPrevious(this);\n            if (graph.readMode === ReadMode.ProposedOrPrevious)\n                graph.activeTransaction.readProposedOrPrevious(this);\n            return graph.activeTransaction.readCurrentOrProposedOrPrevious(this);\n        }\n        else\n            return this.DATA;\n    }\n    readFromGraph(graph) {\n        if (graph)\n            return graph.read(this);\n        else\n            return this.DATA;\n    }\n    writeToGraph(graph, proposedValue, ...args) {\n        if (graph)\n            graph.write(this, proposedValue, ...args);\n        else\n            this.DATA = proposedValue;\n    }\n    leaveGraph(graph) {\n        const entry = graph.activeTransaction.getLatestStableEntryFor(this);\n        if (entry)\n            this.DATA = entry.getValue();\n        super.leaveGraph(graph);\n    }\n    toString() {\n        return this.name;\n    }\n}) {\n}\nexport class MinimalFieldIdentifierSync extends FieldIdentifier.mix(CalculatedValueSync) {\n}\nexport class MinimalFieldIdentifierGen extends FieldIdentifier.mix(CalculatedValueGen) {\n}\nexport class MinimalFieldVariable extends FieldIdentifier.mix(Variable) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent an entity as a whole. Requires the [[Identifier]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class EntityIdentifier extends Mixin([Identifier], (base) => class EntityIdentifier extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * [[EntityMeta]] instance of the entity this identifier represents\n         */\n        this.entity = undefined;\n        /**\n         * Reference to the [[Entity]] this identifier represents\n         */\n        this.self = undefined;\n    }\n    // entity atom is considered changed if any of its incoming atoms has changed\n    // this just means if it's calculation method has been called, it should always\n    // assign a new value\n    equality() {\n        return false;\n    }\n    toString() {\n        return `Entity identifier [${this.self}]`;\n    }\n}) {\n}\nexport class MinimalEntityIdentifier extends EntityIdentifier.mix(CalculatedValueGen) {\n}\n", "import { Meta } from \"../chrono/Identifier.js\";\nimport { MinimalFieldIdentifierGen, MinimalFieldIdentifierSync, MinimalFieldVariable } from \"../replica/Identifier.js\";\nimport { isGeneratorFunction } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This class describes a field of some [[EntityMeta]].\n */\nexport class Field extends Meta {\n    constructor() {\n        super(...arguments);\n        /**\n         * Boolean flag, indicating whether this field should be persisted\n         */\n        this.persistent = true;\n    }\n    getIdentifierClass(calculationFunction) {\n        if (this.identifierCls)\n            return this.identifierCls;\n        if (!calculationFunction)\n            return MinimalFieldVariable;\n        return isGeneratorFunction(calculationFunction) ? MinimalFieldIdentifierGen : MinimalFieldIdentifierSync;\n    }\n}\n", "import { CommitZero } from \"../chrono/Graph.js\";\nimport { Identifier } from \"../chrono/Identifier.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { DEBUG, debug, SourceLinePoint } from \"../environment/Debug.js\";\nimport { runGeneratorSyncWithEffect } from \"../primitives/Calculation.js\";\nimport { EntityMeta } from \"../schema/EntityMeta.js\";\nimport { Field } from \"../schema/Field.js\";\nimport { defineProperty, uppercaseFirst } from \"../util/Helpers.js\";\nimport { MinimalEntityIdentifier } from \"./Identifier.js\";\nconst isEntityMarker = Symbol('isEntity');\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Entity [[Mixin|mixin]]. When applied to some base class (recommended one is [[Base]]), turns it into entity.\n * Entity may have several fields, which are properties decorated with [[field]] decorator.\n *\n * To apply this mixin use the `Entity.mix` property, which represents the mixin lambda.\n *\n * Another decorator, [[calculate]], marks the method, that will be used to calculate the value of field.\n *\n * Example:\n *\n * ```ts\n * class Author extends Entity.mix(Base) {\n *     @field()\n *     firstName       : string\n *     @field()\n *     lastName        : string\n *     @field()\n *     fullName        : string\n *\n *     @calculate('fullName')\n *     calculateFullName () : string {\n *         return this.firstName + ' ' + this.lastName\n *     }\n * }\n * ```\n *\n */\nexport class Entity extends Mixin([], (base) => {\n    class Entity extends base {\n        // marker in the prototype to identify whether the parent class is Entity mixin itself\n        // it is not used for `instanceof` purposes and not be confused with the [MixinInstanceOfProperty]\n        // (though it is possible to use MixinInstanceOfProperty for this purpose, that would require to\n        // make it public\n        [isEntityMarker]() { }\n        /**\n         * An [[EntityMeta]] instance, representing the \"meta\" information about the entity class. It is shared among all instances\n         * of the class.\n         */\n        get $entity() {\n            // this will lazily create an EntityData instance in the prototype\n            return createEntityOnPrototype(this.constructor.prototype);\n        }\n        /**\n         * An object, which properties corresponds to the ChronoGraph [[Identifier]]s, created for every field.\n         *\n         * For example:\n         *\n         * ```ts\n         * class Author extends Entity.mix(Base) {\n         *     @field()\n         *     firstName       : string\n         *     @field()\n         *     lastName        : string\n         * }\n         *\n         * const author = Author.new()\n         *\n         * // identifier for the field `firstName`\n         * author.$.firstName\n         *\n         * const firstName = replica.read(author.$.firstName)\n         * ```\n         */\n        get $() {\n            const $ = {};\n            this.$entity.forEachField((field, name) => {\n                $[name] = this.createFieldIdentifier(field);\n            });\n            if (DEBUG) {\n                const proxy = new Proxy($, {\n                    get(entity, property, receiver) {\n                        if (!entity[property])\n                            debug(new Error(`Attempt to read a missing field ${String(property)} on ${entity}`));\n                        entity[property].SOURCE_POINT = SourceLinePoint.fromThisCall();\n                        return entity[property];\n                    }\n                });\n                return defineProperty(this, '$', proxy);\n            }\n            else {\n                return defineProperty(this, '$', $);\n            }\n        }\n        /**\n         * A graph identifier, that represents the whole entity.\n         */\n        get $$() {\n            return defineProperty(this, '$$', MinimalEntityIdentifier.new({\n                name: this.$entityName,\n                entity: this.$entity,\n                calculation: this.calculateSelf,\n                context: this,\n                self: this,\n            }));\n        }\n        get $entityName() {\n            return this.constructor.name || this.$entity.name;\n        }\n        *calculateSelf() {\n            return this;\n        }\n        createFieldIdentifier(field) {\n            const name = field.name;\n            const entity = this.$entity;\n            const constructor = this.constructor;\n            const skeleton = entity.$skeleton;\n            if (!skeleton[name])\n                skeleton[name] = constructor.getIdentifierTemplateClass(this, field);\n            const identifier = new skeleton[name]();\n            identifier.context = this;\n            identifier.self = this;\n            identifier.name = `${this.$$.name}.$.${field.name}`;\n            return identifier;\n        }\n        forEachFieldIdentifier(func) {\n            this.$entity.forEachField((field, name) => func(this.$[name], name, field));\n        }\n        /**\n         * This method is called when entity is added to some replica.\n         *\n         * @param replica\n         */\n        enterGraph(replica) {\n            if (this.graph)\n                throw new Error('Already entered replica');\n            this.graph = replica;\n            replica.addIdentifier(this.$$);\n            this.$entity.forEachField((field, name) => {\n                const identifier = this.$[name];\n                replica.addIdentifier(identifier, identifier.DATA);\n                identifier.DATA = undefined;\n            });\n        }\n        /**\n         * This method is called when entity is removed from the replica it's been added to.\n         */\n        leaveGraph(graph) {\n            const ownGraph = this.graph;\n            const removeFrom = graph || ownGraph;\n            if (!removeFrom)\n                return;\n            this.$entity.forEachField((field, name) => removeFrom.removeIdentifier(this.$[name]));\n            removeFrom.removeIdentifier(this.$$);\n            if (removeFrom === ownGraph)\n                this.graph = undefined;\n        }\n        // isPropagating () {\n        //     return this.getGraph().isPropagating\n        // }\n        propagate(arg) {\n            return this.commit(arg);\n        }\n        /**\n         * This is a convenience method, that just delegates to the [[ChronoGraph.commit]] method of this entity's graph.\n         *\n         * If there's no graph (entity has not been added to any replica) a [[CommitZero]] constant will be returned.\n         */\n        commit(arg) {\n            const graph = this.graph;\n            if (!graph)\n                return CommitZero;\n            return graph.commit(arg);\n        }\n        async propagateAsync() {\n            return this.commitAsync();\n        }\n        /**\n         * This is a convenience method, that just delegates to the [[ChronoGraph.commitAsync]] method of this entity's graph.\n         *\n         * If there's no graph (entity has not been added to any replica) a resolved promise with [[CommitZero]] constant will be returned.\n         */\n        async commitAsync(arg) {\n            const graph = this.graph;\n            if (!graph)\n                return Promise.resolve(CommitZero);\n            return graph.commitAsync(arg);\n        }\n        /**\n         * An [[EntityMeta]] instance, representing the \"meta\" information about the entity class. It is shared among all instances\n         * of the class.\n         */\n        static get $entity() {\n            return ensureEntityOnPrototype(this.prototype);\n        }\n        static getIdentifierTemplateClass(me, field) {\n            const name = field.name;\n            const config = {\n                name: `${me.$$.name}.$.${name}`,\n                field: field\n            };\n            //------------------\n            if (field.hasOwnProperty('sync'))\n                config.sync = field.sync;\n            if (field.hasOwnProperty('lazy'))\n                config.lazy = field.lazy;\n            if (field.hasOwnProperty('equality'))\n                config.equality = field.equality;\n            //------------------\n            const calculationFunction = me.$calculations && me[me.$calculations[name]];\n            if (calculationFunction)\n                config.calculation = calculationFunction;\n            //------------------\n            const writeFunction = me.$writes && me[me.$writes[name]];\n            if (writeFunction)\n                config.write = writeFunction;\n            //------------------\n            const buildProposedFunction = me.$buildProposed && me[me.$buildProposed[name]];\n            if (buildProposedFunction) {\n                config.buildProposedValue = buildProposedFunction;\n                config.proposedValueIsBuilt = true;\n            }\n            //------------------\n            const template = field.getIdentifierClass(calculationFunction).new(config);\n            const TemplateClass = function () { };\n            TemplateClass.prototype = template;\n            return TemplateClass;\n        }\n        // unfortunately, the better typing:\n        // run <Name extends AllowedNames<this, AnyFunction>> (methodName : Name, ...args : Parameters<this[ Name ]>)\n        //     : ReturnType<this[ Name ]> extends CalculationIterator<infer Res> ? Res : ReturnType<this[ Name ]>\n        // yields \"types are exceedingly long and possibly infinite on the application side\n        \n        run(methodName, ...args) {\n            const onEffect = (effect) => {\n                if (effect instanceof Identifier)\n                    return this.graph.read(effect);\n                throw new Error(\"Helper methods can not yield effects during computation\");\n            };\n            const transaction = this.graph.activeTransaction;\n            const prevActiveStack = transaction.activeStack;\n            transaction.activeStack = [];\n            const res = runGeneratorSyncWithEffect(onEffect, this[methodName], args, this);\n            transaction.activeStack = prevActiveStack;\n            return res;\n        }\n        static createPropertyAccessorsFor(fieldName) {\n            // idea is to indicate to the v8, that `propertyKey` is a constant and thus\n            // it can optimize access by it\n            const propertyKey = fieldName;\n            const target = this.prototype;\n            Object.defineProperty(target, propertyKey, {\n                get: function () {\n                    return this.$[propertyKey].getFromGraph(this.graph);\n                },\n                set: function (value) {\n                    this.$[propertyKey].writeToGraph(this.graph, value);\n                }\n            });\n        }\n        static createMethodAccessorsFor(fieldName) {\n            // idea is to indicate to the v8, that `propertyKey` is a constant and thus\n            // it can optimize access by it\n            const propertyKey = fieldName;\n            const target = this.prototype;\n            const getterFnName = `get${uppercaseFirst(propertyKey)}`;\n            const setterFnName = `set${uppercaseFirst(propertyKey)}`;\n            const putterFnName = `put${uppercaseFirst(propertyKey)}`;\n            if (!(getterFnName in target)) {\n                target[getterFnName] = function () {\n                    return this.$[propertyKey].getFromGraph(this.graph);\n                };\n            }\n            if (!(setterFnName in target)) {\n                target[setterFnName] = function (value, ...args) {\n                    this.$[propertyKey].writeToGraph(this.graph, value, ...args);\n                    return this.graph\n                        ?\n                            (this.graph.autoCommitMode === 'sync' ? this.graph.commit() : this.graph.commitAsync())\n                        :\n                            Promise.resolve(CommitZero);\n                };\n            }\n            if (!(putterFnName in target)) {\n                target[putterFnName] = function (value, ...args) {\n                    this.$[propertyKey].writeToGraph(this.graph, value, ...args);\n                };\n            }\n        }\n    }\n    return Entity;\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const createEntityOnPrototype = (proto) => {\n    let parent = Object.getPrototypeOf(proto);\n    // the `hasOwnProperty` condition will be `true` for the `Entity` mixin itself\n    // if the parent is `Entity` mixin, then this is a top-level entity\n    return defineProperty(proto, '$entity', EntityMeta.new({\n        parentEntity: parent.hasOwnProperty(isEntityMarker) ? null : parent.$entity,\n        name: proto.constructor.name\n    }));\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const ensureEntityOnPrototype = (proto) => {\n    if (!proto.hasOwnProperty('$entity'))\n        createEntityOnPrototype(proto);\n    return proto.$entity;\n};\n/*\n * The \"generic\" field decorator, in the sense, that it allows specifying both field config and field class.\n * This means it can create any field instance.\n */\nexport const generic_field = (fieldConfig, fieldCls = Field) => {\n    return function (target, fieldName) {\n        const entity = ensureEntityOnPrototype(target);\n        const field = entity.addField(fieldCls.new(Object.assign(fieldConfig || {}, {\n            name: fieldName\n        })));\n        const cons = target.constructor;\n        cons.createPropertyAccessorsFor(fieldName);\n        cons.createMethodAccessorsFor(fieldName);\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Field decorator. The type signature is:\n *\n * ```ts\n * field : <T extends typeof Field = typeof Field> (fieldConfig? : Partial<InstanceType<T>>, fieldCls : T | typeof Field = Field) => PropertyDecorator\n * ```\n * Its a function, that accepts field config object and optionally a field class (default is [[Field]]) and returns a property decorator.\n *\n * Example:\n *\n * ```ts\n * const ignoreCaseCompare = (a : string, b : string) : boolean => a.toUpperCase() === b.toUpperCase()\n *\n * class MyField extends Field {}\n *\n * class Author extends Entity.mix(Base) {\n *     @field({ equality : ignoreCaseCompare })\n *     firstName       : string\n *\n *     @field({ lazy : true }, MyField)\n *     lastName       : string\n * }\n * ```\n *\n * For every field, there are generated get and set accessors, with which you can read/write the data:\n *\n * ```ts\n * const author     = Author.new({ firstName : 'Mark' })\n *\n * author.firstName // Mark\n * author.lastName  = 'Twain'\n * ```\n *\n * The getters are basically using [[Replica.get]] and setters [[Replica.write]].\n *\n * Note, that if the identifier is asynchronous, reading from it will return a promise. But, immediately after the [[Replica.commit]] call, getter will return\n * plain value. This is a compromise between the convenience and correctness and this behavior may change (or made configurable) in the future.\n *\n * Additionally to the accessors, the getter and setter methods are generated. The getter method's name is formed as `get` followed by the field name\n * with upper-cased first letter. The setter's name is formed in the same way, with `set` prefix.\n *\n * The getter method is an exact equivalent of the get accessor. The setter method, in addition to data write, immediately after that\n * performs a call to [[Replica.commit]] (or [[Replica.commitAsync]], depending from the [[Replica.autoCommitMode]] option)\n * and return its result.\n *\n * ```ts\n * const author     = Author.new({ firstName : 'Mark' })\n *\n * author.getFirstName() // Mark\n * await author.setLastName('Twain') // issues asynchronous commit\n * ```\n */\nexport const field = generic_field;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Decorator for the method, that calculates a value of some field\n *\n * ```ts\n *\n * @entity()\n * class Author extends Entity.mix(Base) {\n *     @field()\n *     firstName       : string\n *     @field()\n *     lastName        : string\n *     @field()\n *     fullName        : string\n *\n *     @calculate('fullName')\n *     calculateFullName () : string {\n *         return this.firstName + ' ' + this.lastName\n *     }\n * }\n * ```\n *\n * @param fieldName The name of the field the decorated method should be \"tied\" to.\n */\nexport const calculate = function (fieldName) {\n    // `target` will be a prototype of the class with Entity mixin\n    return function (target, propertyKey, _descriptor) {\n        ensureEntityOnPrototype(target);\n        let calculations;\n        if (!target.$calculations) {\n            calculations = target.$calculations = {};\n        }\n        else {\n            if (!target.hasOwnProperty('$calculations')) {\n                calculations = target.$calculations = Object.create(target.$calculations);\n            }\n            else\n                calculations = target.$calculations;\n        }\n        calculations[fieldName] = propertyKey;\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const write = function (fieldName) {\n    // `target` will be a prototype of the class with Entity mixin\n    return function (target, propertyKey, _descriptor) {\n        ensureEntityOnPrototype(target);\n        let writes;\n        if (!target.$writes) {\n            writes = target.$writes = {};\n        }\n        else {\n            if (!target.hasOwnProperty('$writes')) {\n                writes = target.$writes = Object.create(target.$writes);\n            }\n            else\n                writes = target.$writes;\n        }\n        writes[fieldName] = propertyKey;\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const build_proposed = function (fieldName) {\n    // `target` will be a prototype of the class with Entity mixin\n    return function (target, propertyKey, _descriptor) {\n        ensureEntityOnPrototype(target);\n        let buildProposed;\n        if (!target.$buildProposed) {\n            buildProposed = target.$buildProposed = {};\n        }\n        else {\n            if (!target.hasOwnProperty('$buildProposed')) {\n                buildProposed = target.$buildProposed = Object.create(target.$buildProposed);\n            }\n            else\n                buildProposed = target.$buildProposed;\n        }\n        buildProposed[fieldName] = propertyKey;\n    };\n};\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { CalculatedValueSync, Levels, QuarkSync } from \"../chrono/Identifier.js\";\nimport { isInstanceOf, Mixin } from \"../class/Mixin.js\";\nimport { Field } from \"../schema/Field.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\nimport { Entity, generic_field } from \"./Entity.js\";\nimport { FieldIdentifier } from \"./Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent a reference field of the entity. Requires the [[Field]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class ReferenceField extends Mixin([Field], (base) => class ReferenceField extends base {\n    constructor() {\n        super(...arguments);\n        this.identifierCls = MinimalReferenceIdentifier;\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Specialized version of the [field](_replica_entity_.html#field) decorator, which should be used to mark the references.\n * All it does is replace the default value of the second argument to the [[ReferenceField]].\n *\n * ```ts\n * class Author extends Person {\n *     @bucket()\n *     books           : Set<Book>\n * }\n *\n * class Book extends Entity.mix(Base) {\n *     @reference({ bucket : 'books' })\n *     writtenBy       : Author\n * }\n * ```\n *\n * @param fieldConfig Object with the configuration properties\n * @param fieldCls Optional. Default value has been changed to [[ReferenceField]]\n */\nexport const reference = (fieldConfig, fieldCls = ReferenceField) => generic_field(fieldConfig, fieldCls);\n//---------------------------------------------------------------------------------------------------------------------\nexport class ReferenceIdentifier extends Mixin([FieldIdentifier], (base) => {\n    class ReferenceIdentifier extends base {\n        constructor() {\n            super(...arguments);\n            this.field = undefined;\n            this.proposedValueIsBuilt = true;\n        }\n        hasBucket() {\n            return Boolean(this.field.bucket);\n        }\n        getBucket(entity) {\n            return entity.$[this.field.bucket];\n        }\n        buildProposedValue(me, quark, transaction) {\n            const proposedValue = quark.proposedValue;\n            if (proposedValue === null)\n                return null;\n            const value = isInstanceOf(proposedValue, Entity) ? proposedValue : me.resolve(proposedValue);\n            if (value && me.hasBucket()) {\n                me.getBucket(value).addToBucket(transaction, me.self);\n            }\n            return value;\n        }\n        resolve(locator) {\n            const resolver = this.field.resolver;\n            return resolver ? resolver.call(this.self, locator) : null;\n        }\n        enterGraph(graph) {\n            if (this.hasBucket()) {\n                const value = graph.activeTransaction.readProposedOrPrevious(this);\n                if (value instanceof Entity) {\n                    // should probably involve `touchInvalidate` here\n                    this.getBucket(value).addToBucket(graph.activeTransaction, this.self);\n                }\n            }\n            super.enterGraph(graph);\n        }\n        leaveGraph(graph) {\n            if (this.hasBucket()) {\n                // here we only need to remove from the \"previous\", \"stable\" bucket, because\n                // the calculation for the removed reference won't be called - the possible `proposedValue` of reference will be ignored\n                const value = graph.activeTransaction.readProposedOrPrevious(this);\n                if (value instanceof Entity) {\n                    this.getBucket(value).removeFromBucket(graph.activeTransaction, this.self);\n                }\n            }\n            super.leaveGraph(graph);\n        }\n        write(me, transaction, q, proposedValue, ...args) {\n            const quark = q || transaction.acquireQuarkIfExists(me);\n            if (me.hasBucket()) {\n                if (quark) {\n                    const prevValue = quark.getValue();\n                    if (prevValue instanceof Entity) {\n                        me.getBucket(prevValue).removeFromBucket(transaction, me.self);\n                    }\n                }\n                else if (transaction.baseRevision.hasIdentifier(me)) {\n                    const value = transaction.readPrevious(me);\n                    if (value instanceof Entity) {\n                        me.getBucket(value).removeFromBucket(transaction, me.self);\n                    }\n                }\n            }\n            // we pass the `q` to super and not `quark`, because we don't do `getWriteTarget` (which increment the epoch)\n            // but only `acquireQuarkIfExists` (which does not)\n            super.write(me, transaction, q, proposedValue);\n        }\n    }\n    __decorate([\n        prototypeValue(Levels.DependsOnlyOnUserInput)\n    ], ReferenceIdentifier.prototype, \"level\", void 0);\n    __decorate([\n        prototypeValue(QuarkSync)\n    ], ReferenceIdentifier.prototype, \"quarkClass\", void 0);\n    return ReferenceIdentifier;\n}) {\n}\nexport class MinimalReferenceIdentifier extends ReferenceIdentifier.mix(FieldIdentifier.mix(CalculatedValueSync)) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { CalculatedValueSync, Levels, QuarkSync } from \"../chrono/Identifier.js\";\nimport { Quark, TombStone } from \"../chrono/Quark.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { Field } from \"../schema/Field.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\nimport { generic_field } from \"./Entity.js\";\nimport { FieldIdentifier } from \"./Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent a reference bucket field of the entity. Requires the [[Field]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class ReferenceBucketField extends Mixin([Field], (base) => class ReferenceBucketField extends base {\n    constructor() {\n        super(...arguments);\n        this.persistent = false;\n        this.identifierCls = MinimalReferenceBucketIdentifier;\n        // see comment for `ReferenceBucketIdentifier` declaration\n        // identifierCls       : FieldIdentifierConstructor    = ReferenceBucketIdentifier\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Specialized version of the [field](_replica_entity_.html#field) decorator, which should be used to mark the reference buckets.\n * All it does is replace the default value of the second argument to the [[ReferenceBucketField]].\n *\n * ```ts\n * class Author extends Person {\n *     @bucket()\n *     books           : Set<Book>\n * }\n *\n * class Book extends Entity.mix(Base) {\n *     @reference({ bucket : 'books' })\n *     writtenBy       : Author\n * }\n * ```\n *\n * @param fieldConfig Object with the field configuration properties\n * @param fieldCls Optional. Default value has been changed to [[ReferenceBucketField]]\n */\nexport const bucket = (fieldConfig, fieldCls = ReferenceBucketField) => generic_field(fieldConfig, fieldCls);\nvar BucketMutationType;\n(function (BucketMutationType) {\n    BucketMutationType[\"Add\"] = \"Add\";\n    BucketMutationType[\"Remove\"] = \"Remove\";\n})(BucketMutationType || (BucketMutationType = {}));\n//---------------------------------------------------------------------------------------------------------------------\nexport class ReferenceBucketQuark extends Mixin([Quark], (base) => class ReferenceBucketQuark extends base {\n    constructor() {\n        super(...arguments);\n        this.mutations = [];\n        this.previousValue = undefined;\n    }\n    hasProposedValueInner() {\n        return this.mutations.length > 0;\n    }\n}) {\n}\nexport const MinimalReferenceBucketQuark = ReferenceBucketQuark.mix(QuarkSync);\n//---------------------------------------------------------------------------------------------------------------------\nexport class ReferenceBucketIdentifier extends Mixin([FieldIdentifier], (base) => {\n    // Base class mismatch - should allow subclasses for base class requirements\n    // [ FieldIdentifier, CalculatedValueSync ],\n    // (base : AnyConstructor<FieldIdentifier & CalculatedValueSync, typeof FieldIdentifier & typeof CalculatedValueSync>) => {\n    class ReferenceBucketIdentifier extends base {\n        constructor() {\n            super(...arguments);\n            this.proposedValueIsBuilt = true;\n        }\n        addToBucket(transaction, entity) {\n            const quark = transaction.getWriteTarget(this);\n            quark.mutations.push({ type: BucketMutationType.Add, entity });\n            const baseRevision = transaction.baseRevision;\n            if (!quark.previousValue && baseRevision.hasIdentifier(this))\n                quark.previousValue = transaction.readPrevious(this);\n        }\n        removeFromBucket(transaction, entity) {\n            const preQuark = transaction.entries.get(this);\n            // if bucket is already removed - no need to remove from it\n            if (preQuark && preQuark.getValue() === TombStone)\n                return;\n            const quark = transaction.getWriteTarget(this);\n            quark.mutations.push({ type: BucketMutationType.Remove, entity });\n            const baseRevision = transaction.baseRevision;\n            if (!quark.previousValue && baseRevision.hasIdentifier(this))\n                quark.previousValue = transaction.readPrevious(this);\n        }\n        buildProposedValue(me, quarkArg, transaction) {\n            const quark = quarkArg;\n            const newValue = new Set(quark.previousValue);\n            for (let i = 0; i < quark.mutations.length; i++) {\n                const { type, entity } = quark.mutations[i];\n                if (type === BucketMutationType.Remove) {\n                    newValue.delete(entity);\n                }\n                else if (type === BucketMutationType.Add) {\n                    newValue.add(entity);\n                }\n            }\n            return newValue;\n        }\n        leaveGraph(graph) {\n            super.leaveGraph(graph);\n            this.DATA = undefined;\n        }\n    }\n    __decorate([\n        prototypeValue(Levels.DependsOnlyOnDependsOnlyOnUserInput)\n    ], ReferenceBucketIdentifier.prototype, \"level\", void 0);\n    __decorate([\n        prototypeValue(MinimalReferenceBucketQuark)\n    ], ReferenceBucketIdentifier.prototype, \"quarkClass\", void 0);\n    return ReferenceBucketIdentifier;\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class MinimalReferenceBucketIdentifier extends ReferenceBucketIdentifier.mix(FieldIdentifier.mix(CalculatedValueSync)) {\n}\n// export class MinimalReferenceBucketIdentifier extends ReferenceBucketIdentifier.derive(CalculatedValueSync) {}\n", "import { Base } from \"../class/Base.js\";\nimport { ensureEntityOnPrototype } from \"../replica/Entity.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This class describes a schema. Schemas are not used yet in ChronoGraph.\n *\n * Schema is just a collection of entities ([[EntityMeta]])\n */\nexport class Schema extends Base {\n    constructor() {\n        super(...arguments);\n        this.entities = new Map();\n    }\n    /**\n     * Checks whether the schema has an entity with the given name.\n     *\n     * @param name\n     */\n    hasEntity(name) {\n        return this.entities.has(name);\n    }\n    /**\n     * Returns an entity with the given name or `undefined` if there's no such in this schema\n     *\n     * @param name\n     */\n    getEntity(name) {\n        return this.entities.get(name);\n    }\n    /**\n     * Adds an entity to the schema.\n     * @param entity\n     */\n    addEntity(entity) {\n        const name = entity.name;\n        if (!name)\n            throw new Error(`Entity must have a name`);\n        if (this.hasEntity(name))\n            throw new Error(`Entity with name [${String(name)}] already exists`);\n        entity.schema = this;\n        this.entities.set(name, entity);\n        return entity;\n    }\n    /**\n     * Returns a class decorator which can be used to decorate classes as entities.\n     */\n    getEntityDecorator() {\n        // @ts-ignore : https://github.com/Microsoft/TypeScript/issues/29828\n        return (target) => {\n            const entity = entityDecoratorBody(target);\n            this.addEntity(entity);\n            return target;\n        };\n    }\n}\nexport const entityDecoratorBody = (target) => {\n    const name = target.name;\n    if (!name)\n        throw new Error(`Can't add entity - the target class has no name`);\n    return ensureEntityOnPrototype(target.prototype);\n};\n/**\n * Entity decorator. It is required to be applied only if entity declares no field.\n * If record declares any field, there no strict need to apply this decorator.\n * Its better to do this anyway, for consistency.\n *\n * ```ts\n * @entity()\n * class Author extends Entity.mix(Base) {\n * }\n *\n * @entity()\n * class SpecialAuthor extends Author {\n * }\n * ```\n */\nexport const entity = () => {\n    // @ts-ignore : https://github.com/Microsoft/TypeScript/issues/29828\n    return (target) => {\n        entityDecoratorBody(target);\n        return target;\n    };\n};\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { TombStone } from \"../../ChronoGraph/chrono/Quark.js\";\nimport { isInstanceOf, Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { Entity, generic_field } from \"../../ChronoGraph/replica/Entity.js\";\nimport { FieldIdentifier, MinimalFieldIdentifierGen, MinimalFieldIdentifierSync, MinimalFieldVariable } from \"../../ChronoGraph/replica/Identifier.js\";\nimport { ReferenceField, ReferenceIdentifier } from \"../../ChronoGraph/replica/Reference.js\";\nimport { ReferenceBucketField, ReferenceBucketIdentifier } from \"../../ChronoGraph/replica/ReferenceBucket.js\";\nimport { ReadMode } from \"../../ChronoGraph/replica/Replica.js\";\nimport { Field } from \"../../ChronoGraph/schema/Field.js\";\nimport { isGeneratorFunction, prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport DateHelper from \"../../Core/helper/DateHelper.js\";\nimport { QuarkSync } from \"../../ChronoGraph/chrono/Identifier.js\";\nexport const isSerializableEqual = function (oldValue, newValue) {\n    return oldValue === newValue ||\n        (newValue?.isBase ? this.serialize(newValue) : newValue) === (oldValue?.isBase ? this.serialize(oldValue) : oldValue);\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport class ModelField extends Field {\n    constructor() {\n        super(...arguments);\n        this.modelFieldConfig = {};\n    }\n    getIdentifierClass(calculationFunction) {\n        if (this.identifierCls)\n            return this.identifierCls;\n        if (!calculationFunction)\n            return MinimalChronoModelFieldVariable;\n        return isGeneratorFunction(calculationFunction) ? MinimalChronoModelFieldIdentifierGen : MinimalChronoModelFieldIdentifierSync;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class ModelReferenceField extends ReferenceField.mix(ModelField) {\n    constructor() {\n        super(...arguments);\n        this.identifierCls = ChronoModelReferenceFieldIdentifier;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n// it seems we don't need the buckets as Core fields, the `ModelBucketField` can be removed completely\nexport class ModelBucketField extends ReferenceBucketField.mix(Field) {\n    constructor() {\n        super(...arguments);\n        this.identifierCls = ChronoModelReferenceBucketFieldIdentifier;\n        // initialize (...args) {\n        //     super.initialize(...args)\n        //\n        //     // the default value is actually shared among all instances (which is ok, since its assumed to be immutable)\n        //     this.modelFieldConfig   = Object.assign({ isEqual : () => false, defaultValue : new Set(), persist : false }, this.modelFieldConfig)\n        // }\n    }\n}\n// eof Fields\n// Atoms\nexport const IsChronoModelSymbol = Symbol('IsChronoModelSymbol');\n//---------------------------------------------------------------------------------------------------------------------\nexport class ChronoModelFieldIdentifier extends Mixin([FieldIdentifier], (base) => {\n    const superProto = base.prototype;\n    class ChronoModelFieldIdentifier extends base {\n        [IsChronoModelSymbol]() { }\n        getFromGraph(graph) {\n            if (graph) {\n                if (graph.readMode === ReadMode.CurrentOrProposedOrPrevious) {\n                    // <remove-on-release>\n                    // TODO: Ask nick to investigate this, it is likely not a proper fix.\n                    //  Remove and run DependencyColumn.t.js in Gantt with throttled CPU to reproduce the issue.\n                    // </remove-on-release>\n                    const higherLevel = graph.isCommitting && this.level > (graph.activeTransaction.getActiveEntry()?.level ?? Number.MAX_SAFE_INTEGER);\n                    if (this.sync && !this.context.project.isDelayingCalculation && !higherLevel)\n                        return graph.get(this);\n                    else\n                        return graph.activeTransaction.readCurrentOrProposedOrPrevious(this);\n                }\n                return superProto.getFromGraph.call(this, graph);\n            }\n            else\n                return this.DATA;\n        }\n        writeToGraph(graph, proposedValue, ...args) {\n            if (graph) {\n                superProto.writeToGraph.call(this, graph, proposedValue, ...args);\n            }\n            else {\n                this.DATA = proposedValue;\n                // Avoid calling set if we are already setting, or if this is the initial assign of data\n                // (in both cases the underlying data will be correct already)\n                //@ts-ignore\n                if (!this.self.inSetting && !this.self.isConstructing) {\n                    //@ts-ignore\n                    this.self.set(this.field.name, proposedValue, false, false, true);\n                }\n            }\n        }\n        write(me, transaction, quark, proposedValue, ...args) {\n            // convert proposed value if needed\n            proposedValue = me.convert(proposedValue);\n            superProto.write.call(this, me, transaction, quark, proposedValue, ...args);\n        }\n        convert(value) {\n            const field = this.field;\n            const fieldDefinition = this.self.getFieldDefinition(field.name);\n            // use field definition provided \"convert\" function\n            if (fieldDefinition?.convert) {\n                value = fieldDefinition.convert(value, this.context.data, this.context);\n                // fallback to atom defined \"converter\"\n            }\n            else if (field.converter) {\n                value = field.converter(value, field);\n            }\n            return value;\n        }\n        equality(v1, v2) {\n            if ((v1 instanceof Date) && (v2 instanceof Date))\n                return v1.getTime() === v2.getTime();\n            return v1 === v2;\n        }\n    }\n    __decorate([\n        prototypeValue(false)\n    ], ChronoModelFieldIdentifier.prototype, \"sync\", void 0);\n    return ChronoModelFieldIdentifier;\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class ChronoModelReferenceFieldQuark extends Mixin([QuarkSync], (base) => {\n    const superProto = base.prototype;\n    class ChronoModelReferenceFieldQuark extends base {\n        setValue(value) {\n            superProto.setValue.call(this, value);\n            // keep the copy of value on the identifier itself, to make it available\n            // after the identifier is removed from the graph\n            //@ts-ignore\n            if (value !== TombStone)\n                this.identifier.DATA = value;\n        }\n    }\n    return ChronoModelReferenceFieldQuark;\n}) {\n}\nexport class ChronoModelReferenceFieldIdentifier extends ReferenceIdentifier.mix(ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync)) {\n    buildProposedValue(me, q, transaction) {\n        const quark = q;\n        const proposedValue = quark.proposedValue;\n        if (proposedValue === null || proposedValue === undefined) {\n            transaction.candidate.failedResolutionReferences.delete(quark.identifier);\n            return null;\n        }\n        // ignore the given Entity, if it's not in the graph\n        // (should be treated as unresolved id)\n        if (isInstanceOf(proposedValue, Entity) && proposedValue.graph) {\n            if (me.hasBucket())\n                me.getBucket(proposedValue).addToBucket(transaction, me.self);\n            transaction.candidate.failedResolutionReferences.delete(quark.identifier);\n            return proposedValue;\n        }\n        const resolved = me.resolve(proposedValue);\n        // ignore the given Entity, if it's not in the graph\n        // (should be treated as unresolved id)\n        if (isInstanceOf(resolved, Entity) && resolved.graph) {\n            if (me.hasBucket())\n                me.getBucket(resolved).addToBucket(transaction, me.self);\n            transaction.candidate.failedResolutionReferences.delete(quark.identifier);\n            return resolved;\n        }\n        else {\n            transaction.candidate.failedResolutionReferences.set(quark.identifier, proposedValue);\n            return null;\n        }\n    }\n}\n__decorate([\n    prototypeValue(true)\n], ChronoModelReferenceFieldIdentifier.prototype, \"sync\", void 0);\n__decorate([\n    prototypeValue(ChronoModelReferenceFieldQuark)\n], ChronoModelReferenceFieldIdentifier.prototype, \"quarkClass\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\nexport class ChronoModelReferenceBucketFieldIdentifier extends ReferenceBucketIdentifier.mix(ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync)) {\n}\n__decorate([\n    prototypeValue(true)\n], ChronoModelReferenceBucketFieldIdentifier.prototype, \"sync\", void 0);\nexport class MinimalChronoModelFieldIdentifierSync extends ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync) {\n}\nexport class MinimalChronoModelFieldIdentifierGen extends ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierGen) {\n}\nexport class MinimalChronoModelFieldVariable extends ChronoModelFieldIdentifier.mix(MinimalFieldVariable) {\n}\n// eof Atoms\nexport const model_field = function (modelFieldConfig = {}, chronoFieldConfig = {}, chronoFieldClass = ModelField) {\n    return function (target, propertyKey) {\n        const decoratorFn = generic_field({ modelFieldConfig, ...chronoFieldConfig }, chronoFieldClass);\n        decoratorFn(target, propertyKey);\n        injectStaticFieldsProperty(target.constructor);\n    };\n};\nexport const injectStaticFieldsProperty = (prototype) => {\n    if (!prototype.hasOwnProperty('fields')) {\n        Object.defineProperty(prototype, 'fields', {\n            get: function () {\n                return getDecoratedModelFields(this);\n            }\n        });\n    }\n};\nexport const getDecoratedModelFields = (constr) => {\n    const proto = constr.prototype;\n    const result = [];\n    if (proto.hasOwnProperty('$entity')) {\n        proto.$entity.ownFields.forEach((field) => {\n            if (field instanceof ModelField) {\n                const config = field.modelFieldConfig || {};\n                if (!config.convert && field.converter && field.converter !== dateConverter) {\n                    config.convert = field.converter;\n                }\n                result.push(Object.assign(config, {\n                    $chrono: field,\n                    name: field.name\n                }));\n            }\n        });\n    }\n    return result;\n};\nexport const dateConverter = (date, field) => {\n    if (date === null) {\n        return null;\n    }\n    if (!(date instanceof Date)) {\n        date = DateHelper.parse(date, field.modelFieldConfig?.format || field.modelFieldConfig?.dateFormat ||\n            DateHelper.defaultParseFormat);\n    }\n    // if parsing has failed, we would like to return `undefined` to indicate the \"absence\" of data\n    // instead of `null` (presence of \"empty\" data)\n    return date || undefined;\n};\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { Entity } from \"../../ChronoGraph/replica/Entity.js\";\nimport Model from \"../../Core/data/Model.js\";\nimport ObjectHelper from \"../../Core/helper/ObjectHelper.js\";\nimport { ProposedOrPrevious } from \"../../ChronoGraph/chrono/Effect.js\";\nimport { ChronoModelReferenceBucketFieldIdentifier, ChronoModelReferenceFieldIdentifier } from \"./ModelFieldAtom.js\";\n/**\n * This is a base mixin, which mixes together the ChronoGraph's [Entity](https://bryntum.com/products/gantt/docs/engine/modules/_lib_chronograph_replica_entity_.html)\n * and the Bryntum Core [Model](https://bryntum.com/products/grid/docs/api/Core/data/Model)\n *\n * It is used as a very base mixin for all other entities in the project.\n */\nexport class ChronoModelMixin extends Mixin([Entity, Model], (base) => {\n    const superProto = base.prototype;\n    class ChronoModelMixin extends base {\n        // This is a marker for Models which have the Engine API available.\n        get isEntity() {\n            return true;\n        }\n        construct(config, ...args) {\n            // this is to force the fields creation, because we need all fields to be created\n            // for the `this.getFieldDefinition()` to return correct result\n            // @ts-ignore\n            this.constructor.exposeProperties();\n            // Cache original data before we recreate the incoming data here.\n            this.originalData = (config = config || {});\n            // Populate record with all data, it will sort the configs out.\n            // By doing this first, we can feed engine the converted values right away. Needed to satisfy tests that\n            // use standalone stores, otherwise they will be getting the unconverted values since there is no graph.\n            superProto.construct.call(this, config, ...args);\n            // assign Chronograph fields that are not Model fields\n            for (const fieldName in this.originalData) {\n                if (this.$[fieldName] && !this.getFieldDefinition(fieldName)) {\n                    this[fieldName] = config[fieldName];\n                }\n            }\n        }\n        /**\n         * Calculation function that simply returns current ([[ProposedOrPrevious|proposed or previous]]) value of\n         * an identifier.\n         */\n        *userProvidedValue() {\n            return yield ProposedOrPrevious;\n        }\n        copy(newId = null, deep = null) {\n            const copy = superProto.copy.call(this, newId, deep);\n            const { creatingOccurrence } = deep ?? {};\n            // If deep is everything but object - use default behavior, which is to invoke accessors\n            // If deep is an object, check if it has certain field disabled\n            if ((ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers) || !ObjectHelper.isObject(deep)) {\n                this.forEachFieldIdentifier((identifier, fieldName, field) => {\n                    if (!field.lazy &&\n                        // @ts-ignore\n                        this.getFieldDefinition(fieldName)?.type !== 'store' && (!creatingOccurrence\n                        // Only include buckets and references for occurrences, they will not be part of graph and\n                        // will handle their own dates etc\n                        || identifier instanceof ChronoModelReferenceBucketFieldIdentifier\n                        || identifier instanceof ChronoModelReferenceFieldIdentifier)) {\n                        copy[fieldName] = this[fieldName];\n                    }\n                });\n            }\n            return copy;\n        }\n        applyValue(useProp, key, value, skipAccessors, field) {\n            // key is the dataSource, we need to check for the field name instead\n            const chronoField = this.$entity.getField(field?.name || key);\n            if (chronoField)\n                useProp = true;\n            if (skipAccessors)\n                useProp = false;\n            superProto.applyValue.call(this, useProp, useProp ? field?.name ?? key : key, value, skipAccessors, field);\n        }\n        get isInActiveTransaction() {\n            // Might not have joined graph when using delayed calculation\n            const activeTransaction = this.graph?.activeTransaction;\n            return Boolean(activeTransaction?.getLatestEntryFor(this.$$));\n        }\n        get data() {\n            return this._data;\n        }\n        set data(data) {\n            this._data = data;\n            // Have to iterate over defined fields and not keys in supplied data, in case nested mappings are used\n            const { fields, $, graph, generation } = this;\n            for (let i = 0; i < fields.length; i++) {\n                const { name, dataSource, complexMapping } = fields[i];\n                const identifier = $[name];\n                if (identifier) {\n                    const value = complexMapping\n                        ? ObjectHelper.getPath(data, dataSource)\n                        : data[dataSource];\n                    // Avoid hitting setter for fields that have no value in supplied data, or are undefined on initial set\n                    if ((complexMapping || dataSource in data) && (generation != null || value !== undefined)) {\n                        // Use the predefined name for engine (name, startDate)\n                        identifier.writeToGraph(graph, value);\n                    }\n                }\n            }\n        }\n        get $entityName() {\n            const className = this.constructor.name || this.$entity.name;\n            const id = this.id;\n            return `${className}${id != null ? '-' + String(id) : ''}`;\n        }\n    }\n    return ChronoModelMixin;\n}) {\n}\n", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nconst locale = {\n    localeName: 'En',\n    localeDesc: 'English (US)',\n    localeCode: 'en-US',\n    RemoveDependencyCycleEffectResolution: {\n        descriptionTpl: 'Remove dependency'\n    },\n    DeactivateDependencyCycleEffectResolution: {\n        descriptionTpl: 'Deactivate dependency'\n    },\n    CycleEffectDescription: {\n        descriptionTpl: 'A cycle has been found, formed by: {0}'\n    },\n    EmptyCalendarEffectDescription: {\n        descriptionTpl: '\"{0}\" calendar does not provide any working time intervals.'\n    },\n    Use24hrsEmptyCalendarEffectResolution: {\n        descriptionTpl: 'Use 24 hours calendar with non-working Saturdays and Sundays.'\n    },\n    Use8hrsEmptyCalendarEffectResolution: {\n        descriptionTpl: 'Use 8 hours calendar (08:00-12:00, 13:00-17:00) with non-working Saturdays and Sundays.'\n    },\n    ConflictEffectDescription: {\n        descriptionTpl: 'A scheduling conflict has been found: {0} is conflicting with {1}'\n    },\n    ConstraintIntervalDescription: {\n        dateFormat: 'LLL'\n    },\n    ProjectConstraintIntervalDescription: {\n        startDateDescriptionTpl: 'Project start date {0}',\n        endDateDescriptionTpl: 'Project end date {0}'\n    },\n    DependencyType: {\n        long: [\n            'Start-to-Start',\n            'Start-to-Finish',\n            'Finish-to-Start',\n            'Finish-to-Finish'\n        ]\n    },\n    ManuallyScheduledParentConstraintIntervalDescription: {\n        startDescriptionTpl: 'Manually scheduled \"{2}\" forces its children to start no earlier than {0}',\n        endDescriptionTpl: 'Manually scheduled \"{2}\" forces its children to finish no later than {1}'\n    },\n    DisableManuallyScheduledConflictResolution: {\n        descriptionTpl: 'Disable manual scheduling for \"{0}\"'\n    },\n    DependencyConstraintIntervalDescription: {\n        descriptionTpl: 'Dependency ({2}) from \"{3}\" to \"{4}\"'\n    },\n    RemoveDependencyResolution: {\n        descriptionTpl: 'Remove dependency from \"{1}\" to \"{2}\"'\n    },\n    DeactivateDependencyResolution: {\n        descriptionTpl: 'Deactivate dependency from \"{1}\" to \"{2}\"'\n    },\n    DateConstraintIntervalDescription: {\n        startDateDescriptionTpl: 'Task \"{2}\" {3} {0} constraint',\n        endDateDescriptionTpl: 'Task \"{2}\" {3} {1} constraint',\n        constraintTypeTpl: {\n            startnoearlierthan: 'Start-No-Earlier-Than',\n            finishnoearlierthan: 'Finish-No-Earlier-Than',\n            muststarton: 'Must-Start-On',\n            mustfinishon: 'Must-Finish-On',\n            startnolaterthan: 'Start-No-Later-Than',\n            finishnolaterthan: 'Finish-No-Later-Than'\n        }\n    },\n    RemoveDateConstraintConflictResolution: {\n        descriptionTpl: 'Remove \"{1}\" constraint of task \"{0}\"'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import { MAX_DATE, MIN_DATE } from '../util/Constants.js';\nimport { EdgeInclusion } from \"../util/Types.js\";\nimport { Base } from '../../ChronoGraph/class/Base.js';\n/**\n * General purpose date interval. Contains just 2 properties - [[startDate]] and [[endDate]].\n */\nexport class DateInterval extends Base {\n    initialize(...args) {\n        super.initialize(...args);\n        if (!this.startDate)\n            this.startDate = MIN_DATE;\n        if (!this.endDate)\n            this.endDate = MAX_DATE;\n    }\n    equalTo(another) {\n        return this.startDate.getTime() === another.startDate.getTime() && this.endDate.getTime() === another.endDate.getTime();\n    }\n    isInfinite() {\n        return this.startDate.getTime() === MIN_DATE.getTime() && this.endDate.getTime() === MAX_DATE.getTime();\n    }\n    startDateIsFinite() {\n        return !this.isIntervalEmpty() && this.startDate.getTime() !== MIN_DATE.getTime();\n    }\n    endDateIsFinite() {\n        return !this.isIntervalEmpty() && this.endDate.getTime() !== MAX_DATE.getTime();\n    }\n    /**\n     * Test whether the given time point is within this interval. By default interval is considered to be\n     * inclusive on the left side and opened on the right (controlled with `edgeInclusion`).\n     *\n     * @param date\n     * @param edgeInclusion\n     */\n    containsDate(date, edgeInclusion = EdgeInclusion.Left) {\n        return ((edgeInclusion === EdgeInclusion.Left && (date >= this.startDate && date < this.endDate))\n            ||\n                (edgeInclusion === EdgeInclusion.Right && (date > this.startDate && date <= this.endDate)));\n    }\n    isIntervalEmpty() {\n        return this.startDate > this.endDate;\n    }\n    /**\n     * Intersect this interval with another in the immutable way - returns a new interval.\n     * @param another\n     */\n    intersect(another) {\n        const anotherStart = another.startDate;\n        const anotherEnd = another.endDate;\n        const start = this.startDate;\n        const end = this.endDate;\n        // No intersection found\n        if ((end < anotherStart) || (start > anotherEnd)) {\n            // return an empty interval\n            return EMPTY_INTERVAL;\n        }\n        const newStart = new Date(Math.max(start.getTime(), anotherStart.getTime()));\n        const newEnd = new Date(Math.min(end.getTime(), anotherEnd.getTime()));\n        return this.constructor.new({ startDate: newStart, endDate: newEnd });\n    }\n    /**\n     * Intersect this interval with another in the mutable way - updates current interval.\n     * @param another\n     */\n    intersectMut(another, collectIntersectionMeta = false) {\n        const anotherStart = another.startDate;\n        const anotherEnd = another.endDate;\n        const start = this.startDate;\n        const end = this.endDate;\n        // If another interval is an intersection result we keep track of the\n        // initial intersected intervals\n        if (collectIntersectionMeta) {\n            if (!this.intersectionOf)\n                this.intersectionOf = new Set();\n            if (another.intersectionOf?.size > 0) {\n                // this.intersectionOf = new Set([ ...this.intersectionOf, ...another.intersectionOf ])\n                another.intersectionOf.forEach(this.intersectionOf.add, this.intersectionOf);\n                this.intersectedAsEmpty = another.intersectedAsEmpty;\n            }\n            // keep track if the intervals we intersect with\n            else {\n                this.intersectionOf.add(another);\n            }\n        }\n        // Bail out if we are an empty interval\n        if (!this.isIntervalEmpty()) {\n            // No intersection found\n            if ((end < anotherStart) || (start > anotherEnd)) {\n                // return an empty interval\n                this.startDate = MAX_DATE;\n                this.endDate = MIN_DATE;\n                // remember the interval resulted an empty intersection\n                if (collectIntersectionMeta) {\n                    this.intersectedAsEmpty = another;\n                }\n                return this;\n            }\n            this.startDate = new Date(Math.max(start.getTime(), anotherStart.getTime()));\n            this.endDate = new Date(Math.min(end.getTime(), anotherEnd.getTime()));\n        }\n        return this;\n    }\n    getCopyProperties(data) {\n        return data;\n    }\n    copyWith(data) {\n        const copyData = this.getCopyProperties(data);\n        // @ts-ignore\n        return this.constructor.new(copyData);\n    }\n}\nexport const EMPTY_INTERVAL = DateInterval.new({ startDate: MAX_DATE, endDate: MIN_DATE });\n/**\n * Intersects the array of intervals. Returns a new interval with result.\n *\n * @param dateIntervals\n */\nexport const intersectIntervals = (dateIntervals, collectIntersectionMeta = false) => {\n    return dateIntervals.reduce((acc, currentInterval) => acc.intersectMut(currentInterval, collectIntersectionMeta), DateInterval.new());\n};\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Effect } from \"../../ChronoGraph/chrono/Effect.js\";\nimport { prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport Base from \"../../Core/Base.js\";\n/**\n * Type for an effect resolution process.\n */\nexport var EffectResolutionResult;\n(function (EffectResolutionResult) {\n    /**\n     * A chosen resolution is \"do nothing\" so changes should be cancelled.\n     */\n    EffectResolutionResult[\"Cancel\"] = \"Cancel\";\n    /**\n     * A resolution is applied and current transaction should be continued.\n     */\n    EffectResolutionResult[\"Resume\"] = \"Resume\";\n})(EffectResolutionResult || (EffectResolutionResult = {}));\n/**\n * Class implementing a [[SchedulingIssueEffect|scheduling issue]] resolution.\n */\nexport class SchedulingIssueEffectResolution extends Base {\n    /**\n     * Returns the resolution description.\n     */\n    getDescription() {\n        throw new Error('Abstract method');\n    }\n    /**\n     * Resolves the [[SchedulingIssueEffect|scheduling issue]].\n     */\n    resolve(...args) {\n        throw new Error('Abstract method');\n    }\n}\n/**\n * Base class for an [[Effect|effect]] signalizing of a scheduling issue\n * that should be resolved by some application logic or the user.\n * The class provides an array of the case possible [[getResolutions|resolutions]]\n * and the case [[getDescription|description]].\n */\nexport class SchedulingIssueEffect extends Effect {\n    /**\n     * Returns the list of possible effect resolutions.\n     */\n    getResolutions() {\n        return this._resolutions;\n    }\n    getDescriptionBuilderClass() {\n        return this._descriptionBuilderClass;\n    }\n    setDescriptionBuilderClass(cls) {\n        this._descriptionBuilderClass = cls;\n    }\n    /**\n     * Returns the effect human readable description.\n     */\n    getDescription() {\n        return this.getDescriptionBuilderClass().getDescription(this);\n    }\n}\n__decorate([\n    prototypeValue('schedulingIssueEffect')\n], SchedulingIssueEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(false)\n], SchedulingIssueEffect.prototype, \"sync\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport Base from \"../../Core/Base.js\";\nimport DateHelper from \"../../Core/helper/DateHelper.js\";\nimport Localizable from \"../../Core/localization/Localizable.js\";\nimport \"../localization/En.js\";\nimport { DateInterval, intersectIntervals } from \"../scheduling/DateInterval.js\";\nimport { format } from \"../util/Functions.js\";\nimport { SchedulingIssueEffect, SchedulingIssueEffectResolution } from \"./SchedulingIssueEffect.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const ConflictSymbol = Symbol('ConflictSymbol');\n/**\n * Description builder for a [[ConflictEffect|scheduling conflict]].\n */\nexport class ConflictEffectDescription extends Localizable(Base) {\n    static get $name() {\n        return 'ConflictEffectDescription';\n    }\n    /**\n     * Returns the scheduling conflict localized description.\n     * @param conflict Scheduling conflict\n     */\n    static getDescription(conflict) {\n        return format(this.L('L{descriptionTpl}'), conflict.intervals[0].getDescription(), conflict.intervals[1].getDescription());\n    }\n}\n/**\n * Special [[Effect|effect]] indicating a _scheduling conflict_ happened.\n */\nexport class ConflictEffect extends SchedulingIssueEffect {\n    constructor() {\n        super(...arguments);\n        this.handler = ConflictSymbol;\n    }\n    initialize(props) {\n        super.initialize(props);\n        // filter the provided intervals to keep only the conflicting ones\n        this.intervals = this.filterConflictingIntervals(this.intervals);\n    }\n    /**\n     * Returns possible resolutions for the _conflict_.\n     */\n    getResolutions() {\n        if (!this._resolutions) {\n            // collect all possible resolutions\n            this._resolutions = [].concat(...this.intervals.map(interval => interval.getResolutions()));\n        }\n        return this._resolutions;\n    }\n    filterConflictingIntervals(intervals) {\n        const result = [];\n        // filter out infinite intervals ..they don't really restrict anything\n        const intervalsArray = [...intervals].filter(interval => !interval.isInfinite());\n        const affectedInterval = intervalsArray.find(interval => interval.isAffectedByTransaction());\n        // If we've managed to detect the interval being changed in this transaction\n        if (affectedInterval) {\n            // Sort intervals so the one we've found go first..\n            const sorted = intervalsArray.sort((a, b) => a === affectedInterval ? -1 : 0);\n            // ..so when intersecting intervals we find another interval resulting an empty intersection\n            const intersection = intersectIntervals(sorted, true);\n            const conflictingInterval = intersection.intersectedAsEmpty;\n            result.push(conflictingInterval, affectedInterval);\n        }\n        else {\n            result.push(intersectIntervals(intervalsArray, true).intersectedAsEmpty, intersectIntervals(intervalsArray.reverse(), true).intersectedAsEmpty);\n        }\n        return result;\n    }\n}\n__decorate([\n    prototypeValue('schedulingConflict')\n], ConflictEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(ConflictEffectDescription)\n], ConflictEffect.prototype, \"_descriptionBuilderClass\", void 0);\n/**\n * An abstract class for implementing a certain way of resolving a scheduling conflict.\n */\nexport class ConflictResolution extends SchedulingIssueEffectResolution {\n    /**\n     * Resolves the scheduling conflict.\n     */\n    resolve() {\n        throw new Error('Abstract method');\n    }\n}\n/**\n * Base class for an interval _description builder_ - s special class that returns\n * a human readable localized description for a provided interval.\n */\nexport class ConstraintIntervalDescription extends Localizable(Base) {\n    static get $name() {\n        return 'ConstraintIntervalDescription';\n    }\n    /**\n     * Returns the provided interval description.\n     * @param interval Interval to get description of\n     */\n    static getDescription(interval) {\n        return format(this.L('L{descriptionTpl}'), ...this.getDescriptionParameters(interval));\n    }\n    /**\n     * Returns additional parameters to put into the description.\n     * @param interval Interval to get description of\n     */\n    static getDescriptionParameters(interval) {\n        return [\n            DateHelper.format(interval.startDate, this.L('L{dateFormat}')),\n            DateHelper.format(interval.endDate, this.L('L{dateFormat}'))\n        ];\n    }\n}\n/**\n * Base class for implementing an interval that applies a certain constraint on event(s).\n */\nexport class ConstraintInterval extends DateInterval {\n    constructor() {\n        super(...arguments);\n        this.owner = undefined;\n        this.reflectionOf = undefined;\n        this.side = undefined;\n        this.resolutions = undefined;\n    }\n    get isConstraintInterval() {\n        return true;\n    }\n    /**\n     * Returns the interval description.\n     */\n    getDescription() {\n        return this.descriptionBuilderClass.getDescription(this);\n    }\n    /**\n     * Returns possible resolution for the interval when it takes part in a _scheduling conflict_.\n     */\n    getResolutions() {\n        return [];\n    }\n    isAffectedByTransaction(transaction) {\n        return false;\n    }\n    getCopyProperties(data) {\n        const { owner, reflectionOf, side } = this;\n        return Object.assign({ owner, reflectionOf, side }, data);\n    }\n}\n__decorate([\n    prototypeValue(ConstraintIntervalDescription)\n], ConstraintInterval.prototype, \"descriptionBuilderClass\", void 0);\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"./AbstractPartOfProjectGenericMixin.js\";\n/**\n * This a base generic mixin for every class, that belongs to a chronograph powered project.\n *\n * It just provides getter/setter for the `project` property, along with some convenience methods\n * to access the project's stores.\n */\nexport class ChronoPartOfProjectGenericMixin extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoPartOfProjectGenericMixin extends base {\n        /**\n         * The method to get the `ChronoGraph` instance, this entity belongs to.\n         */\n        getGraph() {\n            const project = this.getProject();\n            return project?.getGraph();\n        }\n        //region Entity getters\n        /**\n         * Convenience method to get the instance of event by its id.\n         */\n        getEventById(id) {\n            return this.getEventStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of dependency by its id.\n         */\n        getDependencyById(id) {\n            return this.getDependencyStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of resource by its id.\n         */\n        getResourceById(id) {\n            return this.getResourceStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of assignment by its id.\n         */\n        getAssignmentById(id) {\n            return this.getAssignmentStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of calendar by its id.\n         */\n        getCalendarById(id) {\n            return this.getCalendarManagerStore()?.getById(id);\n        }\n    }\n    return ChronoPartOfProjectGenericMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nexport class ChronoStoreMixin extends Mixin([Store], (base) => class ChronoStoreMixin extends base {\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoPartOfProjectGenericMixin } from \"../../ChronoPartOfProjectGenericMixin.js\";\nimport { ChronoStoreMixin } from \"./ChronoStoreMixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./AbstractPartOfProjectStoreMixin.js\";\n/**\n * This a base mixin for every Store, that belongs to a ChronoGraph powered project.\n */\nexport class ChronoPartOfProjectStoreMixin extends Mixin([\n    AbstractPartOfProjectStoreMixin,\n    ChronoPartOfProjectGenericMixin,\n    ChronoStoreMixin\n], (base) => {\n    const superProto = base.prototype;\n    class ChronoPartOfProjectStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 0;\n        }\n        setStoreData(data) {\n            // Inform project that a store is being repopulated, to avoid expensive unjoins.\n            // Should not repopulate when using syncDataOnLoad\n            this.project?.repopulateStore(this);\n            superProto.setStoreData.call(this, data);\n        }\n        register(record) {\n            superProto.register.call(this, record);\n            // NOTE: Remove check for `this.project.graph` if we want records added after the initial calculations to also have\n            //       delayed entry into the replica\n            // @ts-ignore\n            !record.isRoot && !this.project?.graph && this.project?.scheduleDelayedCalculation();\n        }\n        onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n            // 1. call will forward value to the chrono, leaving model.data intact\n            // 2. value was changed, so model.afterChange is called too, triggering `update` event on store\n            // 3. autoCommit is scheduled\n            // 4. autoCommit finalizes, calling endBatch\n            // 5. endBatch calls `set` again, passing argument `skipAccessors = true`, which means data will be set to\n            // the `model.data` now\n            // 6. since value differs in chrono and in model.data, `afterChange` will be called once again\n            // Naturally this leads to two identical events being fired for this call:\n            // `dependency.set('type', 0)\n            //\n            // Idea of the fix is to mute events for the first call IF chrono field is in the `wasSet` object\n            // Covered by DependencyEdit.t.js\n            if (!skipAccessors && !(this.syncDataOnLoad && this.isLoadingData) && Object.keys(wasSet).some(key => key !== 'intervals' && record.$entity.getField(key))) {\n                silent = true;\n            }\n            //@ts-ignore\n            super.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);\n        }\n    }\n    return ChronoPartOfProjectStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoModelMixin } from \"../../../chrono/ChronoModelMixin.js\";\nimport { ChronoPartOfProjectGenericMixin } from \"../../ChronoPartOfProjectGenericMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"../../store/mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractPartOfProjectModelMixin } from \"./AbstractPartOfProjectModelMixin.js\";\nimport { isInstanceOf } from '../../../../ChronoGraph/class/Mixin.js';\n/**\n * This a base mixin for every Model that belongs to a ChronoGraph powered project.\n *\n * The model with this mixin, supposes that it will be \"joining\" a store that is already part of a project,\n * so that such model can take a reference to the project from it.\n *\n * It provides 2 template methods [[joinProject]] and [[leaveProject]], which can be overridden in other mixins\n * (they should always call `super` implementation, because it adds/remove the model to/from the ChronoGraph instance)\n */\nexport class ChronoPartOfProjectModelMixin extends Mixin([\n    AbstractPartOfProjectModelMixin,\n    ChronoPartOfProjectGenericMixin,\n    ChronoModelMixin\n], (base) => {\n    const superProto = base.prototype;\n    class ChronoPartOfProjectModelMixin extends base {\n        /**\n         * Template method, which is called when model is joining the project (through joining some store that\n         * has already joined the project)\n         */\n        joinProject() {\n            if (!this.project?.delayEnteringReplica) {\n                if (this.graph && this.graph != this.getGraph()) {\n                    this.graph = null;\n                }\n                this.getGraph().addEntity(this);\n            }\n        }\n        /**\n         * Template method, which is called when model is leaving the project (through leaving some store usually)\n         */\n        leaveProject(isReplacing = false) {\n            superProto.leaveProject.call(this, isReplacing);\n            const replica = this.getGraph();\n            // Because of delayCalculation it might not have joined the graph at all\n            replica?.removeEntity(this);\n            // @ts-ignore\n            this.graph = null;\n        }\n        /**\n         * Returns a [[SchedulerBasicProjectMixin|project]] instance\n         */\n        getProject() {\n            return superProto.getProject.call(this);\n        }\n        calculateProject() {\n            const store = this.stores.find(s => (isInstanceOf(s, ChronoPartOfProjectStoreMixin)) && !!s.getProject());\n            return store?.getProject();\n        }\n        // Report that there is no graph when delaying calculations, to not let anything enter it on reloads\n        get graph() {\n            return this.project?.delayEnteringReplica ? null : this._graph;\n        }\n        set graph(graph) {\n            this._graph = graph;\n        }\n    }\n    return ChronoPartOfProjectModelMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { ChronoPartOfProjectModelMixin } from \"../mixin/ChronoPartOfProjectModelMixin.js\";\nimport { AbstractCalendarMixin } from \"../AbstractCalendarMixin.js\";\nimport { SchedulingIssueEffect, SchedulingIssueEffectResolution } from \"../../../chrono/SchedulingIssueEffect.js\";\nimport Localizable from \"../../../../Core/localization/Localizable.js\";\nimport Base from \"../../../../Core/Base.js\";\nimport { prototypeValue } from \"../../../../ChronoGraph/util/Helpers.js\";\nimport { format } from \"../../../util/Functions.js\";\nconst hasMixin = Symbol('CalendarMixin');\nexport const EmptyCalendarSymbol = Symbol('EmptyCalendarSymbol');\n/**\n * The calendar for project scheduling, it is used to mark certain time intervals as \"non-working\" and ignore them during scheduling.\n *\n * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.\n */\nexport class BaseCalendarMixin extends Mixin([\n    AbstractCalendarMixin,\n    ChronoPartOfProjectModelMixin\n], (base) => {\n    class BaseCalendarMixin extends base {\n        constructor() {\n            super(...arguments);\n            // this field intentionally made \"model field\", so that its updates are going through\n            // all the Core's fields processing (and fires the appropriate events on the store)\n            this.version = 1;\n        }\n        [hasMixin]() { }\n    }\n    __decorate([\n        model_field({}, { persistent: false })\n    ], BaseCalendarMixin.prototype, \"version\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], BaseCalendarMixin.prototype, \"unspecifiedTimeIsWorking\", void 0);\n    __decorate([\n        model_field()\n    ], BaseCalendarMixin.prototype, \"intervals\", void 0);\n    return BaseCalendarMixin;\n}) {\n}\n/**\n * Class providing a human readable localized description of an [[EmptyCalendarEffect]] instance.\n */\nexport class EmptyCalendarEffectDescription extends Localizable(Base) {\n    static get $name() {\n        return 'EmptyCalendarEffectDescription';\n    }\n    static getDescription(effect) {\n        const calendar = effect.getCalendar();\n        return format(this.L('L{descriptionTpl}'), calendar.name || calendar.id);\n    }\n}\n/**\n * Special effect indicating that some calendar or calendars group is misconfigured\n * and do not provide any working period of time which makes its usage\n * impossible.\n */\nexport class EmptyCalendarEffect extends SchedulingIssueEffect {\n    constructor() {\n        super(...arguments);\n        this.handler = EmptyCalendarSymbol;\n    }\n    getResolutions() {\n        const calendar = this.getCalendar();\n        return this._resolutions || (this._resolutions = [\n            Use24hrsEmptyCalendarEffectResolution.new({ calendar }),\n            Use8hrsEmptyCalendarEffectResolution.new({ calendar })\n        ]);\n    }\n    // <remove-on-release>\n    // TODO: Handle cases when all individual calendars have working periods yet their intersection does not\n    // </remove-on-release>\n    /**\n     * Returns the calendar that does not have any working periods specified.\n     */\n    getCalendar() {\n        const { calendars } = this;\n        if (calendars?.length > 1) {\n            for (const calendar of calendars) {\n                const skippingRes = calendar.skipNonWorkingTime(this.date, this.isForward);\n                if (!(skippingRes instanceof Date)) {\n                    return calendar;\n                }\n            }\n        }\n        return calendars[0];\n    }\n}\n__decorate([\n    prototypeValue('emptyCalendar')\n], EmptyCalendarEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(EmptyCalendarEffectDescription)\n], EmptyCalendarEffect.prototype, \"_descriptionBuilderClass\", void 0);\n/**\n * Base class for [[EmptyCalendarEffect]] resolutions.\n * The class has [[fixCalendarData]] method that pushes preconfigured `calendarData`\n * to the given [[calendar]]. The method is called in [[resolve]] method so for a subclass\n * it's enough just providing [[fixCalendarData|proper data]].\n */\nexport class BaseEmptyCalendarEffectResolution extends Localizable(SchedulingIssueEffectResolution) {\n    static get $name() {\n        return 'BaseEmptyCalendarEffectResolution';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Correct calendar data.\n             * @property calendarData\n             */\n            calendarData: {\n                intervals: [\n                    { isWorking: true }\n                ]\n            }\n        };\n    }\n    getDescription() {\n        const { calendar } = this;\n        return format(this.L('L{descriptionTpl}'), calendar.name || calendar.id);\n    }\n    /**\n     * Fixes the provided calendar data by clearing its intervals\n     * amd then applying data specified in `calendarData` config.\n     * @param calendar\n     */\n    fixCalendarData(calendar) {\n        calendar.clearIntervals(true);\n        // @ts-ignore\n        Object.assign(calendar, this.calendarData);\n        if (calendar.intervals?.length) {\n            calendar.addIntervals(calendar.intervals);\n        }\n    }\n    /**\n     * Resolves the [[calendar]] by removing all its intervals and adding new `calendarData`.\n     */\n    resolve() {\n        const { calendar } = this;\n        this.fixCalendarData(calendar);\n    }\n}\n/**\n * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by\n * replacing its data with standard __24 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.\n */\nexport class Use24hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {\n    static get $name() {\n        return 'Use24hrsEmptyCalendarEffectResolution';\n    }\n    static get configurable() {\n        return {\n            calendarData: {\n                unspecifiedTimeIsWorking: false,\n                intervals: [\n                    {\n                        recurrentStartDate: 'on Mon at 0:00',\n                        recurrentEndDate: 'on Sat at 0:00',\n                        isWorking: true\n                    }\n                ]\n            }\n        };\n    }\n}\n/**\n * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by\n * replacing its data with standard __8 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.\n */\nexport class Use8hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {\n    static get $name() {\n        return 'Use8hrsEmptyCalendarEffectResolution';\n    }\n    static get configurable() {\n        return {\n            calendarData: {\n                unspecifiedTimeIsWorking: false,\n                intervals: [\n                    {\n                        recurrentStartDate: 'every weekday at 08:00',\n                        recurrentEndDate: 'every weekday at 12:00',\n                        isWorking: true\n                    },\n                    {\n                        recurrentStartDate: 'every weekday at 13:00',\n                        recurrentEndDate: 'every weekday at 17:00',\n                        isWorking: true\n                    }\n                ]\n            }\n        };\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Reject, RejectSymbol } from \"../../ChronoGraph/chrono/Effect.js\";\nimport { TombStone } from \"../../ChronoGraph/chrono/Quark.js\";\nimport { Revision } from \"../../ChronoGraph/chrono/Revision.js\";\nimport { Transaction } from \"../../ChronoGraph/chrono/Transaction.js\";\nimport { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { Replica } from \"../../ChronoGraph/replica/Replica.js\";\nimport { prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport Base from \"../../Core/Base.js\";\nimport Localizable from \"../../Core/localization/Localizable.js\";\nimport { EmptyCalendarSymbol } from \"../quark/model/scheduler_basic/BaseCalendarMixin.js\";\nimport { format } from \"../util/Functions.js\";\nimport { ConflictSymbol } from \"./Conflict.js\";\nimport { IsChronoModelSymbol, ModelBucketField } from \"./ModelFieldAtom.js\";\nimport { EffectResolutionResult, SchedulingIssueEffect, SchedulingIssueEffectResolution } from \"./SchedulingIssueEffect.js\";\nexport const CycleSymbol = Symbol('CycleSymbol');\n//---------------------------------------------------------------------------------------------------------------------\nexport class EngineRevision extends Revision {\n    constructor() {\n        super(...arguments);\n        this.failedResolutionReferences = new Map();\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class EngineTransaction extends Transaction {\n    constructor() {\n        super(...arguments);\n        this.candidateClass = EngineRevision;\n    }\n    initialize(props) {\n        // Emit progress earlier and more frequently when using delayCalculation mode, to not lock up UI as much and to\n        // have smoother progress bar updates.\n        // Transactions created to validate deps does not reference project\n        if (props.graph.project?.delayCalculation) {\n            props.startProgressNotificationsAfterMs = 0;\n            props.emitProgressNotificationsEveryMs = 100;\n        }\n        super.initialize(props);\n        this.candidate.failedResolutionReferences = new Map(this.baseRevision.failedResolutionReferences);\n    }\n    addIdentifier(identifier, proposedValue, ...args) {\n        if (this.candidate.failedResolutionReferences.size) {\n            this.candidate.failedResolutionReferences.forEach((failedResolutionValue, identifier) => {\n                this.write(identifier, failedResolutionValue);\n            });\n            this.candidate.failedResolutionReferences.clear();\n        }\n        return super.addIdentifier(identifier, proposedValue, ...args);\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * An extension of [[Replica]], specialized for interaction with [[AbstractProjectMixin|project]].\n */\nexport class EngineReplica extends Mixin([Replica], (base) => {\n    const superProto = base.prototype;\n    class EngineReplica extends base {\n        constructor() {\n            super(...arguments);\n            this.baseRevision = EngineRevision.new();\n            this.transactionClass = EngineTransaction;\n            this.autoCommitMode = 'async';\n            this.onComputationCycle = 'effect';\n            this.cycleEffectClass = CycleEffect;\n            this.silenceInitialCommit = true;\n            this.ignoreInitialCommitComputationCycles = false;\n        }\n        get dirty() {\n            const activeTransaction = this.activeTransaction;\n            return activeTransaction.entries.size > 0 && (activeTransaction.hasVariableEntry || activeTransaction.hasEntryWithProposedValue);\n        }\n        onPropagationProgressNotification(notification) {\n            if (this.enableProgressNotifications && this.project)\n                this.project.trigger?.('progress', notification);\n        }\n        async commitAsync(args) {\n            if (!this.project || this.project.isDestroyed)\n                return;\n            this.project.trigger('beforeCommit');\n            if (this.isInitialCommit && this.ignoreInitialCommitComputationCycles) {\n                // backup onComputationCycle value to restore it after the commit\n                this._onComputationCycle = this._onComputationCycle || this.onComputationCycle;\n                // toggle onComputationCycle to ignore cycles to let the data get into the graph\n                this.onComputationCycle = 'ignore';\n            }\n            const replacedReplicaResult = this.project.beforeCommitAsync();\n            if (replacedReplicaResult)\n                return replacedReplicaResult;\n            return superProto.commitAsync.call(this, args);\n        }\n        get isInitialCommit() {\n            // let the project defined which commit is \"initial\"\n            return this.project.isInitialCommit || super.isInitialCommit;\n        }\n        set isInitialCommit(value) {\n            super.isInitialCommit = value;\n        }\n        write(identifier, proposedValue, ...args) {\n            const fieldName = identifier.field?.name;\n            const record = identifier.self;\n            if (fieldName && record) {\n                // @ts-ignore\n                const beforeHookResult = record.beforeChronoFieldSet?.(fieldName, proposedValue);\n                superProto.write.call(this, identifier, proposedValue, ...args);\n                // @ts-ignore\n                record.afterChronoFieldSet?.(fieldName, proposedValue, beforeHookResult);\n            }\n            else {\n                superProto.write.call(this, identifier, proposedValue, ...args);\n            }\n        }\n        async finalizeCommitAsync(transactionResult) {\n            // the `this.project` may be empty for the branch, where we validate the dependency\n            // because if asyncness project might be destroyed when we get here\n            const { project } = this;\n            if (!project || project.isDestroyed)\n                return;\n            const { entries } = transactionResult;\n            const autoCommitStores = new Set();\n            if (globalThis.DEBUG)\n                console.timeEnd('Time to visible');\n            const { isInitialCommit, silenceInitialCommit } = this;\n            // apply changes silently if this is initial commit and \"silenceInitialCommit\" option is enabled\n            const silenceCommit = isInitialCommit && silenceInitialCommit;\n            if (isInitialCommit) {\n                project.isInitialCommitPerformed = true;\n                // restore onComputationCycle back if we toggled it before committing\n                if (this.ignoreInitialCommitComputationCycles)\n                    this.onComputationCycle = this._onComputationCycle;\n            }\n            project.isWritingData = true;\n            project.hasLoadedDataToCommit = false;\n            // Let progress listeners know we are finalizing\n            if (this.enableProgressNotifications) {\n                project.trigger('progress', {\n                    total: transactionResult.entries.size,\n                    remaining: 0,\n                    phase: 'finalizing'\n                });\n            }\n            const transaction = transactionResult.transaction;\n            // need to reject the data before the `refresh` event, otherwise\n            // the UI will try to refresh the stale data\n            if (transaction.rejectedWith) {\n                project.trigger('commitRejected', { transactionResult, isInitialCommit, silenceCommit });\n            }\n            // It is triggered earlier because on that stage engine is ready and UI can be drawn.\n            // dataReady happens up to like a second later in big datasets. We do not want to wait that long\n            project.trigger('refresh', { isInitialCommit, isCalculated: true });\n            // console.timeEnd('rendered')\n            await new Promise(resolve => {\n                setTimeout(() => {\n                    // <remove-on-release>\n                    // TODO: Should use Delayable\n                    // </remove-on-release>\n                    if (!project.isDestroyed) {\n                        if (!transactionResult.transaction.rejectedWith) {\n                            // @ts-ignore\n                            project.suspendChangesTracking?.();\n                            if (globalThis.DEBUG)\n                                console.time('Finalize propagation');\n                            const records = new Set();\n                            for (const quark of entries.values()) {\n                                const identifier = quark.identifier;\n                                const quarkValue = quark.getValue();\n                                const { field } = identifier;\n                                if (quark.isShadow() || !identifier[IsChronoModelSymbol] || quarkValue === TombStone || field instanceof ModelBucketField)\n                                    continue;\n                                const record = identifier.self;\n                                const store = record.firstStore;\n                                // Begin batch once\n                                if (!records.has(record)) {\n                                    record.beginBatch(true);\n                                    records.add(record);\n                                }\n                                // Avoid committing changes during refresh, commit below instead. Suspend once\n                                if (store?.autoCommit && !autoCommitStores.has(store)) {\n                                    store.suspendAutoCommit();\n                                    autoCommitStores.add(store);\n                                }\n                                // Cheapest possible set\n                                // @ts-ignore\n                                record.meta.batchChanges[field.name] = quarkValue;\n                            }\n                            let prevented = false;\n                            for (const record of records) {\n                                if (!record.triggerBeforeUpdate({ ...record.meta.batchChanges })) {\n                                    prevented = true;\n                                    break;\n                                }\n                            }\n                            if (prevented) {\n                                for (const record of records) {\n                                    record.cancelBatch();\n                                }\n                                transactionResult.transaction.reject();\n                                project.trigger('commitRejected', { transactionResult, isInitialCommit, silenceCommit });\n                                project.trigger('refresh', { isInitialCommit, isCalculated: true });\n                            }\n                            else {\n                                for (const record of records) {\n                                    //@ts-ignore\n                                    record.ignoreBag = silenceCommit || project.ignoreRecordChanges;\n                                    record.generation++;\n                                    record.endBatch(silenceCommit, true, true);\n                                    //@ts-ignore\n                                    record.ignoreBag = false;\n                                }\n                            }\n                            project.ignoreRecordChanges = false;\n                            if (globalThis.DEBUG)\n                                console.timeEnd('Finalize propagation');\n                            // Calendar expects flag to be cleared before dataReady, was mismatch with engine stub\n                            project.isWritingData = false;\n                            if (!prevented) {\n                                project.trigger('dataReady', { records, isInitialCommit });\n                            }\n                            // @ts-ignore\n                            project.resumeChangesTracking?.(silenceCommit);\n                            autoCommitStores.forEach(store => store.resumeAutoCommit());\n                            // clear all changes of the first graph commit\n                            if (silenceCommit) {\n                                project.eventStore.acceptChanges();\n                                project.dependencyStore.acceptChanges();\n                                project.resourceStore.acceptChanges();\n                                project.assignmentStore.acceptChanges();\n                                project.calendarManagerStore.acceptChanges();\n                                project.acceptChanges();\n                            }\n                        }\n                        // transaction rejected\n                        else {\n                            project.isWritingData = false;\n                        }\n                        project.trigger('commitFinalized', { isInitialCommit, transactionResult });\n                    }\n                    resolve();\n                }, 0);\n            });\n        }\n        *onComputationCycleHandler(cycle) {\n            if (this.onComputationCycle === 'effect') {\n                const effect = this.project.cycleEffectClass.new({ cycle });\n                if ((yield effect) === EffectResolutionResult.Cancel) {\n                    yield Reject(effect);\n                }\n            }\n            else {\n                return yield* super.onComputationCycleHandler(cycle);\n            }\n        }\n        async [CycleSymbol](effect, transaction) {\n            // delegate to project\n            return this.project.onCycleSchedulingIssue(effect, transaction);\n        }\n        async [EmptyCalendarSymbol](effect, transaction) {\n            transaction.walkContext.startNewEpoch();\n            // delegate to project\n            return this.project.onEmptyCalendarSchedulingIssue(effect, transaction);\n        }\n        async [ConflictSymbol](effect, transaction) {\n            transaction.walkContext.startNewEpoch();\n            // delegate to project\n            return this.project.onConflictSchedulingIssue(effect, transaction);\n        }\n        [RejectSymbol](effect, transaction) {\n            return super[RejectSymbol](effect, transaction);\n        }\n    }\n    return EngineReplica;\n}) {\n}\n/**\n * A cycle resolution removing one of the [[getDependencies|related dependencies]].\n * The dependency instance should be passed to [[resolve]] method:\n *\n * ```typescript\n * // this call will remove dependencyRecord\n * removalResolution.resolve(dependencyRecord)\n * ```\n */\nexport class RemoveDependencyCycleEffectResolution extends Localizable(SchedulingIssueEffectResolution) {\n    static get $name() {\n        return 'RemoveDependencyCycleEffectResolution';\n    }\n    getDescription() {\n        return this.L('L{descriptionTpl}');\n    }\n    resolve(dependency) {\n        dependency.remove();\n    }\n}\n/**\n * Class providing a human readable localized description ofr a [[CycleEffect]] instance.\n */\nexport class CycleEffectDescription extends Localizable(Base) {\n    static get $name() {\n        return 'CycleEffectDescription';\n    }\n    static getDescription(effect) {\n        return format(this.L('L{descriptionTpl}'), this.getShortDescription(effect));\n    }\n    static getShortDescription(effect) {\n        const events = effect.getEvents().slice();\n        events.push(events[0]);\n        return '\"' + events.map(event => event.name || '#' + event.id).join('\" -> \"') + '\"';\n    }\n}\n/**\n * Class implementing a special effect signalizing of a computation cycle.\n * The class suggests the only [[getResolutions|resolution]] option - removing one of the\n * [[getDependencies|related dependencies]].\n */\nexport class CycleEffect extends SchedulingIssueEffect {\n    constructor() {\n        super(...arguments);\n        this.handler = CycleSymbol;\n    }\n    /**\n     * Returns list of events building the cycle.\n     */\n    getEvents() {\n        if (!this._events) {\n            const result = new Set();\n            this.cycle.cycle.forEach(({ context }) => result.add(context));\n            this._events = [...result];\n        }\n        return this._events;\n    }\n    matchDependencyBySourceAndTargetEvent(dependency, from, to) {\n        return dependency.fromEvent === from && dependency.toEvent === to;\n    }\n    getDependencyForSourceAndTargetEvents(from, to) {\n        const events = this.getEvents();\n        const project = events[0].project;\n        const dependencyStore = project.getDependencyStore();\n        return dependencyStore.find((dependency) => this.matchDependencyBySourceAndTargetEvent(dependency, from, to));\n    }\n    /**\n     * Returns list of dependencies building the cycle.\n     */\n    getDependencies() {\n        if (!this._dependencies) {\n            const result = new Set();\n            const events = this.getEvents();\n            const numberOfEvents = events.length;\n            let prevEvent = events[0], dependency;\n            if (numberOfEvents === 1) {\n                if ((dependency = this.getDependencyForSourceAndTargetEvents(prevEvent, prevEvent))) {\n                    result.add(dependency);\n                }\n            }\n            else {\n                for (const event1 of events) {\n                    for (const event2 of events) {\n                        if ((dependency = this.getDependencyForSourceAndTargetEvents(event1, event2))) {\n                            result.add(dependency);\n                        }\n                        if ((dependency = this.getDependencyForSourceAndTargetEvents(event2, event1))) {\n                            result.add(dependency);\n                        }\n                    }\n                }\n            }\n            this._dependencies = [...result];\n        }\n        return this._dependencies;\n    }\n    /**\n     * Returns list of the cycle possible resolutions.\n     *\n     * The class provides a single parameterized [[RemoveDependencyCycleEffectResolution]] resolution\n     * which implement removal of one of the [[getDependencies|dependencies]].\n     */\n    getResolutions() {\n        if (!this._resolutions) {\n            this._resolutions = [this.removeDependencyCycleEffectResolutionClass.new()];\n        }\n        return this._resolutions;\n    }\n}\n__decorate([\n    prototypeValue('cycle')\n], CycleEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(CycleEffectDescription)\n], CycleEffect.prototype, \"_descriptionBuilderClass\", void 0);\n__decorate([\n    prototypeValue(RemoveDependencyCycleEffectResolution)\n], CycleEffect.prototype, \"removeDependencyCycleEffectResolutionClass\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { generic_field } from '../../../../ChronoGraph/replica/Entity.js';\nimport { ModelReferenceField, injectStaticFieldsProperty, isSerializableEqual } from '../../../chrono/ModelFieldAtom.js';\nimport { ChronoPartOfProjectModelMixin } from '../mixin/ChronoPartOfProjectModelMixin.js';\n/**\n * Base assignment model class. It just contains references to the [[BaseEventMixin|event]] and [[BaseResourceMixin|resource]] being assigned.\n */\nexport class BaseAssignmentMixin extends Mixin([ChronoPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseAssignmentMixin extends base {\n    }\n    __decorate([\n        generic_field({\n            bucket: 'assigned',\n            resolver: function (id) { return this.getEventById(id); },\n            modelFieldConfig: {\n                serialize: event => event?.id,\n                isEqual: isSerializableEqual,\n                persist: false\n            }\n        }, ModelReferenceField)\n    ], BaseAssignmentMixin.prototype, \"event\", void 0);\n    __decorate([\n        generic_field({\n            bucket: 'assigned',\n            resolver: function (id) { return this.getResourceById(id); },\n            modelFieldConfig: {\n                serialize: resource => resource?.id,\n                isEqual: isSerializableEqual,\n                persist: false\n            }\n        }, ModelReferenceField)\n    ], BaseAssignmentMixin.prototype, \"resource\", void 0);\n    // inject \"fields\" getter override to apply \"modelFieldConfig\" to \"event\" & \"resource\" fields\n    injectStaticFieldsProperty(BaseAssignmentMixin);\n    return BaseAssignmentMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { BaseAssignmentMixin } from \"../model/scheduler_basic/BaseAssignmentMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractAssignmentStoreMixin } from \"./AbstractAssignmentStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all assignments in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoAssignmentStoreMixin extends Mixin([AbstractAssignmentStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoAssignmentStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 100;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: BaseAssignmentMixin\n            };\n        }\n        set data(value) {\n            this.allAssignmentsForRemoval = true;\n            super.data = value;\n            this.allAssignmentsForRemoval = false;\n        }\n    }\n    return ChronoAssignmentStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { BaseCalendarMixin } from \"../model/scheduler_basic/BaseCalendarMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractCalendarManagerStoreMixin } from \"./AbstractCalendarManagerStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all calendars in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoCalendarManagerStoreMixin extends Mixin([AbstractCalendarManagerStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoCalendarManagerStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 500;\n        }\n        static get defaultConfig() {\n            return {\n                tree: true,\n                modelClass: BaseCalendarMixin\n            };\n        }\n    }\n    return ChronoCalendarManagerStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractDependencyStoreMixin } from \"./AbstractDependencyStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all dependencies in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoDependencyStoreMixin extends Mixin([AbstractDependencyStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoDependencyStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 200;\n        }\n        set data(value) {\n            this.allDependenciesForRemoval = true;\n            super.data = value;\n            this.allDependenciesForRemoval = false;\n        }\n    }\n    return ChronoDependencyStoreMixin;\n}) {\n}\n", "import { CycleResolutionInputChrono } from \"../../../../ChronoGraph/chrono/CycleResolver.js\";\nimport { CalculatedValueGen } from \"../../../../ChronoGraph/chrono/Identifier.js\";\nimport { CalculateProposed, CycleDescription, CycleResolution, Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { FieldIdentifier } from \"../../../../ChronoGraph/replica/Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport var Instruction;\n(function (Instruction) {\n    Instruction[\"KeepDuration\"] = \"KeepDuration\";\n    Instruction[\"KeepStartDate\"] = \"KeepStartDate\";\n    Instruction[\"KeepEndDate\"] = \"KeepEndDate\";\n})(Instruction || (Instruction = {}));\n//---------------------------------------------------------------------------------------------------------------------\nexport const StartDateVar = Symbol('StartDate');\nexport const EndDateVar = Symbol('EndDate');\nexport const DurationVar = Symbol('Duration');\n//---------------------------------------------------------------------------------------------------------------------\nexport const startDateFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([DurationVar, EndDateVar])\n});\nexport const endDateFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([DurationVar, StartDateVar])\n});\nexport const durationFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartDateVar, EndDateVar])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport const SEDGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar]),\n    formulas: new Set([startDateFormula, endDateFormula, durationFormula])\n});\nexport const SEDForwardCycleResolutionContext = CycleResolution.new({\n    description: SEDGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula])\n});\nexport const SEDBackwardCycleResolutionContext = CycleResolution.new({\n    description: SEDGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDDispatcher extends CycleResolutionInputChrono {\n    addInstruction(instruction) {\n        if (instruction === Instruction.KeepStartDate)\n            this.addKeepIfPossibleFlag(StartDateVar);\n        if (instruction === Instruction.KeepEndDate)\n            this.addKeepIfPossibleFlag(EndDateVar);\n        if (instruction === Instruction.KeepDuration)\n            this.addKeepIfPossibleFlag(DurationVar);\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDDispatcherIdentifier extends FieldIdentifier.mix(CalculatedValueGen) {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        const res = resolution1.get(StartDateVar) === resolution2.get(StartDateVar)\n            && resolution1.get(EndDateVar) === resolution2.get(EndDateVar)\n            && resolution1.get(DurationVar) === resolution2.get(DurationVar)\n            || (\n            // https://github.com/bryntum/support/issues/6262\n            // for the unscheduled tasks (missing all 3 values), resolution of the `v1` will be \"keep all proposed\"\n            // which is always different from the default resolution\n            // this leads to the dispatcher identifiers remaining \"self-dependent\" and re-calculated at every commit\n            // process this case specially\n            // note, that this is more a patch, a proper solution would probably be to change this line:\n            // chronograph/src/chrono/CycleResolver.ts\n            //      if (Y(PreviousValueOf(identifier)) != null) this.addPreviousValueFlag(symbol)\n            // to\n            //      if (Y(PreviousValueOf(identifier)) !== undefined) this.addPreviousValueFlag(symbol)\n            // however this breaks normalization tests\n            resolution1.get(StartDateVar) === CalculateProposed\n                && resolution1.get(EndDateVar) === CalculateProposed\n                && resolution1.get(DurationVar) === CalculateProposed);\n        return res;\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field, generic_field, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { CalendarCacheMultiple } from \"../../../calendar/CalendarCacheMultiple.js\";\nimport { injectStaticFieldsProperty, isSerializableEqual, ModelReferenceField } from '../../../chrono/ModelFieldAtom.js';\nimport { stripDuplicates } from \"../../../util/StripDuplicates.js\";\nimport { ChronoPartOfProjectModelMixin } from \"../mixin/ChronoPartOfProjectModelMixin.js\";\nimport { BaseCalendarMixin } from \"./BaseCalendarMixin.js\";\n/**\n * This mixin provides the calendar to any [[ChronoPartOfProjectModelMixin]] it is mixed in.\n *\n * If user provides no calendar, the calendar is taken from the project.\n */\nexport class HasCalendarMixin extends Mixin([ChronoPartOfProjectModelMixin], (base) => {\n    class HasCalendarMixin extends base {\n        writeCalendar(me, transaction, quark, calendar) {\n            const calendarManagerStore = this.getCalendarManagerStore();\n            const cal = calendar;\n            // add calendar to the calendar manager - if the calendar is not there yet\n            if (calendar && calendarManagerStore && calendar instanceof BaseCalendarMixin && !calendarManagerStore.includes(cal)) {\n                calendarManagerStore.add(calendar);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, calendar);\n        }\n        resolveCalendar(locator) {\n            return this.getCalendarManagerStore()?.getById(locator);\n        }\n        /**\n         * Calculation method of the [[effectiveCalendar]]. Takes the calendar from the project, if not provided to the entity explicitly.\n         */\n        *calculateEffectiveCalendar() {\n            let calendar = yield this.$.calendar;\n            if (!calendar) {\n                const project = this.getProject();\n                calendar = yield project.$.effectiveCalendar;\n            }\n            // this will create an incoming edge from the calendar's version atom, which changes on calendar's data update\n            yield calendar.$.version;\n            return calendar;\n        }\n        //region STM hooks\n        shouldRecordFieldChange(fieldName, oldValue, newValue) {\n            if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {\n                return false;\n            }\n            const { project } = this;\n            // If that's a \"calendar\" field change - make sure it does refer to some other record\n            // and not just reacts to old record idChange\n            if (fieldName === 'calendar' && project) {\n                const { calendarManagerStore } = project;\n                return calendarManagerStore.oldIdMap[oldValue] !== calendarManagerStore.getById(newValue);\n            }\n            return true;\n        }\n    }\n    __decorate([\n        field({\n            equality: () => false\n        })\n    ], HasCalendarMixin.prototype, \"effectiveCalendar\", void 0);\n    __decorate([\n        generic_field({\n            modelFieldConfig: {\n                persist: true,\n                // we don't use calendar?.id here since we need to preserve calendar==null value\n                // while optional chaining will result undefined in this case\n                serialize: calendar => calendar === undefined ? undefined : (calendar?.id || null),\n                isEqual: isSerializableEqual\n            },\n            resolver: function (locator) {\n                return this.resolveCalendar(locator);\n            },\n            sync: true\n        }, ModelReferenceField)\n    ], HasCalendarMixin.prototype, \"calendar\", void 0);\n    __decorate([\n        write('calendar')\n    ], HasCalendarMixin.prototype, \"writeCalendar\", null);\n    __decorate([\n        calculate('effectiveCalendar')\n    ], HasCalendarMixin.prototype, \"calculateEffectiveCalendar\", null);\n    // inject \"fields\" getter override to apply \"modelFieldConfig\" to \"event\" & \"resource\" fields\n    injectStaticFieldsProperty(HasCalendarMixin);\n    return HasCalendarMixin;\n}) {\n}\n// <remove-on-release>\n// TODO: Handle the calendars deletion\n// </remove-on-release>\n/**\n * This mixin provides the consuming class with the [[combineCalendars]] method, which can combine several calendars.\n */\nexport class CanCombineCalendarsMixin extends Mixin([], (base) => {\n    class CanCombineCalendars extends base {\n        constructor() {\n            super(...arguments);\n            this.combinedcalendarscache = new Map();\n        }\n        /**\n         * Combines an array of calendars into a single [[CalendarCacheMultiple]], which provides an API similar (but not exactly the same) to [[BaseCalendarMixin]]\n         *\n         * @param calendars\n         */\n        combineCalendars(calendars) {\n            const uniqueOnly = stripDuplicates(calendars);\n            if (uniqueOnly.length === 0)\n                throw new Error(\"No calendars to combine\");\n            uniqueOnly.sort((calendar1, calendar2) => {\n                if (calendar1.internalId < calendar2.internalId)\n                    return -1;\n                else\n                    return 1;\n            });\n            const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');\n            const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');\n            const cached = this.combinedcalendarscache.get(hash);\n            let res;\n            if (cached && cached.versionsHash === versionsHash)\n                res = cached.cache;\n            else {\n                res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache) });\n                this.combinedcalendarscache.set(hash, {\n                    versionsHash: versionsHash,\n                    cache: res\n                });\n            }\n            return res;\n        }\n    }\n    return CanCombineCalendars;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedArgumentsOf, ProposedOrPrevious, ProposedOrPreviousValueOf, Reject, Write } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalculateProposed } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { build_proposed, calculate, field, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\nimport { dateConverter, model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { Direction, TimeUnit } from \"../../../scheduling/Types.js\";\nimport { isNotNumber } from \"../../../util/Functions.js\";\nimport { EmptyCalendarEffect } from \"./BaseCalendarMixin.js\";\nimport { durationFormula, DurationVar, endDateFormula, EndDateVar, Instruction, SEDBackwardCycleResolutionContext, SEDDispatcher, SEDDispatcherIdentifier, SEDForwardCycleResolutionContext, startDateFormula, StartDateVar } from \"./BaseEventDispatcher.js\";\nimport { HasCalendarMixin } from \"./HasCalendarMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Base event entity mixin type.\n *\n * At this level event is only aware about its calendar (which is inherited from project, if not provided).\n * The functionality, related to the dependencies, constraints etc is provided in other mixins.\n *\n * A time interval will be \"counted\" into the event duration, only if the event's calendar has that interval\n * as working. Otherwise the time is skipped and not counted into event's duration.\n *\n */\nexport class BaseEventMixin extends Mixin([HasCalendarMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseEventMixin extends base {\n        *calculateDispatcher(YIELD) {\n            // this value is not used directly, but it contains a default cycle resolution\n            // if we calculate different resolution, dispatcher will be marked dirty\n            // on next revision\n            const proposed = yield ProposedOrPrevious;\n            const cycleDispatcher = yield* this.prepareDispatcher(YIELD);\n            //--------------\n            const startDateProposedArgs = yield ProposedArgumentsOf(this.$.startDate);\n            const startInstruction = startDateProposedArgs ? (startDateProposedArgs[0] ? Instruction.KeepDuration : Instruction.KeepEndDate) : undefined;\n            if (startInstruction)\n                cycleDispatcher.addInstruction(startInstruction);\n            //--------------\n            const endDateProposedArgs = yield ProposedArgumentsOf(this.$.endDate);\n            const endInstruction = endDateProposedArgs ? (endDateProposedArgs[0] ? Instruction.KeepDuration : Instruction.KeepStartDate) : undefined;\n            if (endInstruction)\n                cycleDispatcher.addInstruction(endInstruction);\n            //--------------\n            const directionValue = yield this.$.direction;\n            const durationProposedArgs = yield ProposedArgumentsOf(this.$.duration);\n            let durationInstruction;\n            if (durationProposedArgs) {\n                switch (durationProposedArgs[0]) {\n                    case true:\n                        durationInstruction = Instruction.KeepStartDate;\n                        break;\n                    case false:\n                        durationInstruction = Instruction.KeepEndDate;\n                        break;\n                }\n            }\n            if (!durationInstruction && cycleDispatcher.hasProposedValue(DurationVar)) {\n                durationInstruction = directionValue === Direction.Forward || directionValue === Direction.None ? Instruction.KeepStartDate : Instruction.KeepEndDate;\n            }\n            if (durationInstruction)\n                cycleDispatcher.addInstruction(durationInstruction);\n            return cycleDispatcher;\n        }\n        *prepareDispatcher(Y) {\n            const dispatcherClass = this.dispatcherClass(Y);\n            const cycleDispatcher = dispatcherClass.new({\n                context: this.cycleResolutionContext(Y)\n            });\n            cycleDispatcher.collectInfo(Y, this.$.startDate, StartDateVar);\n            cycleDispatcher.collectInfo(Y, this.$.endDate, EndDateVar);\n            cycleDispatcher.collectInfo(Y, this.$.duration, DurationVar);\n            return cycleDispatcher;\n        }\n        cycleResolutionContext(Y) {\n            const direction = Y(this.$.direction);\n            return direction === Direction.Forward || direction === Direction.None ? SEDForwardCycleResolutionContext : SEDBackwardCycleResolutionContext;\n        }\n        dispatcherClass(Y) {\n            return SEDDispatcher;\n        }\n        buildProposedDispatcher(me, quark, transaction) {\n            const dispatcher = this.dispatcherClass(transaction.onEffectSync).new({\n                context: this.cycleResolutionContext(transaction.onEffectSync)\n            });\n            dispatcher.addPreviousValueFlag(StartDateVar);\n            dispatcher.addPreviousValueFlag(EndDateVar);\n            dispatcher.addPreviousValueFlag(DurationVar);\n            return dispatcher;\n        }\n        /**\n         * The method skips the event non working time starting from the provided `date` and\n         * going either _forward_ or _backward_ in time.\n         * It uses the event [[effectiveCalendar|effective calendar]] to detect which time is not working.\n         * @param date Date to start skipping from\n         * @param isForward Skip direction (`true` to go forward in time, `false` - backwards)\n         */\n        *skipNonWorkingTime(date, isForward) {\n            const calendar = yield this.$.effectiveCalendar;\n            if (!date)\n                return null;\n            const skippingRes = calendar.skipNonWorkingTime(date, isForward);\n            if (skippingRes instanceof Date) {\n                return skippingRes;\n            }\n            else {\n                const effect = EmptyCalendarEffect.new({\n                    calendars: [calendar],\n                    event: this,\n                    date,\n                    isForward\n                });\n                if ((yield effect) === EffectResolutionResult.Cancel) {\n                    yield Reject(effect);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        /**\n         * The method skips the provided amount of the event _working time_\n         * starting from the `date` and going either _forward_ or _backward_ in time.\n         * It uses the event [[effectiveCalendar|effective calendar]] to detect which time is not working.\n         * @param date Date to start skipping from\n         * @param isForward Skip direction (`true` to go forward in time, `false` - backwards)\n         * @param duration Amount of working time to skip\n         * @param unit Units the `duration` value in (if not provided then duration is considered provided in [[durationUnit]])\n         */\n        *skipWorkingTime(date, isForward, duration, unit) {\n            const durationUnit = yield this.$.durationUnit;\n            // Convert duration to duration unit if needed\n            if (unit && unit !== durationUnit) {\n                duration = yield* this.getProject().$convertDuration(duration, unit, durationUnit);\n            }\n            return yield* this.calculateProjectedXDateWithDuration(date, isForward, duration);\n        }\n        // copied generated method, to avoid compilation error when it is overridden in HasDateConstraintMixin\n        /**\n         * Sets the event [[startDate|start date]]\n         *\n         * @param date The new start date to set\n         * @param keepDuration Whether the intention is to keep the `duration` field (`keepDuration = true`) or `endDate` (`keepDuration = false`)\n         */\n        setStartDate(date, keepDuration = true) {\n            const { graph, project } = this;\n            if (graph) {\n                graph.write(this.$.startDate, date, keepDuration);\n                return graph.commitAsync();\n            }\n            else {\n                this.$.startDate.DATA = date;\n                // Possibly about to enter replica, wait for that\n                return project?.delayedCalculationPromise;\n            }\n        }\n        writeStartDate(me, transaction, quark, date, keepDuration = true) {\n            // we use the approach, that when user sets some atom to `null`\n            // that `null` is propagated as a normal valid value through all calculation formulas\n            // turning the result of all calculations to `null`\n            // this works well, except the initial data load case, when don't want to do such propagation\n            // but instead wants to \"normalize\" the data\n            // because of that we ignore the `null` writes, for the initial data load case\n            if (!transaction.baseRevision.hasIdentifier(me) && date == null)\n                return;\n            if (!this.getProject().isStmRestoring) {\n                // this is basically: this.unscheduled = date == null, however it will work with branches\n                this.$.unscheduled.write(this.$.unscheduled, transaction, undefined, date == null);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);\n        }\n        /**\n         * The main calculation method for the [[startDate]] field. Delegates to either [[calculateStartDateProposed]]\n         * or [[calculateStartDatePure]], depending on the information from [[dispatcher]]\n         */\n        *calculateStartDate() {\n            const dispatch = yield this.$.dispatcher;\n            const formulaId = dispatch.resolution.get(StartDateVar);\n            if (formulaId === CalculateProposed) {\n                return yield* this.calculateStartDateProposed();\n            }\n            else if (formulaId === startDateFormula.formulaId) {\n                return yield* this.calculateStartDatePure();\n            }\n            else {\n                throw new Error(\"Unknown formula for `startDate`\");\n            }\n        }\n        /**\n         * The \"pure\" calculation function of the [[startDate]] field. It should calculate the [[startDate]] as if\n         * there's no user input for it and no previous value - \"purely\" based on the values of other fields.\n         *\n         * At this level it delegates to [[calculateProjectedXDateWithDuration]]\n         *\n         * See also [[calculateStartDateProposed]].\n         */\n        *calculateStartDatePure() {\n            return yield* this.calculateProjectedXDateWithDuration(yield this.$.endDate, false, yield this.$.duration);\n        }\n        /**\n         * The \"proposed\" calculation function of the [[startDate]] field. It should calculate the [[startDate]] as if\n         * there's a user input for it or a previous value. It can also use the values of other fields to \"validate\"\n         * the \"proposed\" value.\n         *\n         * See also [[calculateStartDatePure]]\n         */\n        *calculateStartDateProposed() {\n            const project = this.getProject();\n            const startDate = yield ProposedOrPrevious;\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return (!manuallyScheduled || project.skipNonWorkingTimeWhenSchedulingManually) ? yield* this.skipNonWorkingTime(startDate, true) : startDate;\n        }\n        /**\n         * This method calculates the opposite date of the event.\n         *\n         * @param baseDate The base date of the event (start or end date)\n         * @param isForward Boolean flag, indicating whether the given `baseDate` is start date (`true`) or end date (`false`)\n         * @param duration Duration of the event, in its [[durationUnit|durationUnits]]\n         */\n        *calculateProjectedXDateWithDuration(baseDate, isForward, duration) {\n            const durationUnit = yield this.$.durationUnit;\n            const calendar = yield this.$.effectiveCalendar;\n            const project = this.getProject();\n            if (!baseDate || isNotNumber(duration))\n                return null;\n            // calculate forward by default\n            isForward = isForward === undefined ? true : isForward;\n            if (isForward) {\n                return calendar.calculateEndDate(baseDate, yield* project.$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n            }\n            else {\n                return calendar.calculateStartDate(baseDate, yield* project.$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n            }\n        }\n        // copied generated method, to specify the default value for `keepDuration`\n        // and to avoid compilation error when it is overridden in HasDateConstraintMixin\n        /**\n         * Sets the event [[endDate|end date]].\n         *\n         * @param date The new end date to set\n         * @param keepDuration Whether the intention is to keep the `duration` field (`keepDuration = true`) or `startDate` (`keepDuration = false`)\n         */\n        setEndDate(date, keepDuration = false) {\n            const { graph, project } = this;\n            if (graph) {\n                graph.write(this.$.endDate, date, keepDuration);\n                return graph.commitAsync();\n            }\n            else {\n                this.$.endDate.DATA = date;\n                // Possibly about to enter replica, wait for that\n                return project?.delayedCalculationPromise;\n            }\n        }\n        writeEndDate(me, transaction, quark, date, keepDuration = false) {\n            if (!transaction.baseRevision.hasIdentifier(me) && date == null)\n                return;\n            if (!this.getProject().isStmRestoring) {\n                // this is basically: this.unscheduled = date == null, however it will work with branches\n                this.$.unscheduled.write(this.$.unscheduled, transaction, undefined, date == null);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);\n        }\n        /**\n         * The main calculation method for the [[endDate]] field. Delegates to either [[calculateEndDateProposed]]\n         * or [[calculateEndDatePure]], depending on the information from [[dispatcher]]\n         */\n        *calculateEndDate() {\n            const dispatch = yield this.$.dispatcher;\n            const formulaId = dispatch.resolution.get(EndDateVar);\n            if (formulaId === CalculateProposed) {\n                return yield* this.calculateEndDateProposed();\n            }\n            else if (formulaId === endDateFormula.formulaId) {\n                return yield* this.calculateEndDatePure();\n                // the \"new way\" would be\n                // return yield* this.calculateProjectedEndDateWithDuration(yield this.$.startDate, yield this.$.duration)\n            }\n            else {\n                throw new Error(\"Unknown formula for `endDate`\");\n            }\n        }\n        /**\n         * The \"pure\" calculation function of the [[endDate]] field. It should calculate the [[endDate]] as if\n         * there's no user input for it and no previous value - \"purely\" based on the values of other fields.\n         *\n         * At this level it delegates to [[calculateProjectedXDateWithDuration]]\n         *\n         * See also [[calculateEndDateProposed]].\n         */\n        *calculateEndDatePure() {\n            return yield* this.calculateProjectedXDateWithDuration(yield this.$.startDate, true, yield this.$.duration);\n        }\n        /**\n         * The \"proposed\" calculation function of the [[endDate]] field. It should calculate the [[endDate]] as if\n         * there's a user input for it or a previous value. It can also use the values of other fields to \"validate\"\n         * the \"proposed\" value.\n         *\n         * See also [[calculateEndDatePure]]\n         */\n        *calculateEndDateProposed() {\n            const project = this.getProject();\n            const endDate = yield ProposedOrPrevious;\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return (!manuallyScheduled || project.skipNonWorkingTimeWhenSchedulingManually) ? yield* this.skipNonWorkingTime(endDate, false) : endDate;\n        }\n        //endregion\n        //region duration\n        /**\n         * Duration getter. Returns the duration of the event, in the given unit. If unit is not given, returns duration in [[durationUnit]].\n         *\n         * @param unit\n         */\n        getDuration(unit) {\n            const duration = this.duration;\n            return unit !== undefined ? this.getProject().convertDuration(duration, this.durationUnit, unit) : duration;\n        }\n        /**\n         * Duration setter.\n         *\n         * @param duration The new duration to set.\n         * @param unit The unit for new duration. Optional, if missing the [[durationUnit]] value will be used.\n         * @param keepStart A boolean flag, indicating, whether the intention is to keep the start date (`true`) or end date (`false`)\n         */\n        setDuration(duration, unit, keepStart) {\n            const { graph, project } = this;\n            if (graph) {\n                // this check is performed just because the duration editor tries to apply `undefined` when\n                // an input is invalid (and we want to filter that out)\n                // in the same time, we want to allow input of empty string - (task \"unscheduling\")\n                // so for unscheduling case, the editor will apply a `null` value, for invalid - `undefined`\n                // this is a mess of course (if the value is invalid, editor should not be applying anything at all),\n                // but so is life\n                if (duration !== undefined) {\n                    graph.write(this.$.duration, duration, unit, keepStart);\n                    return graph.commitAsync();\n                }\n            }\n            else {\n                const toSet = { duration };\n                this.$.duration.DATA = duration;\n                if (unit != null)\n                    toSet.durationUnit = this.$.durationUnit.DATA = unit;\n                // Also has to make sure record data is updated in case this detached record is displayed elsewhere\n                this.set(toSet);\n                // Possibly about to enter replica, wait for that\n                return project?.delayedCalculationPromise;\n            }\n        }\n        setDurationUnit(_value) {\n            throw new Error(\"Use `setDuration` instead\");\n        }\n        writeDuration(me, transaction, quark, duration, unit, keepStart = undefined) {\n            if (duration < 0)\n                duration = 0;\n            if (!transaction.baseRevision.hasIdentifier(me) && duration == null)\n                return;\n            if (!this.getProject().isStmRestoring) {\n                // this is basically: this.unscheduled = date == null, however it will work with branches\n                this.$.unscheduled.write(this.$.unscheduled, transaction, undefined, duration == null);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, duration, keepStart);\n            if (unit != null)\n                transaction.write(this.$.durationUnit, unit);\n        }\n        /**\n         * The main calculation method for the [[duration]] field. Delegates to either [[calculateDurationProposed]]\n         * or [[calculateDurationPure]], depending on the information from [[dispatcher]]\n         */\n        *calculateDuration() {\n            const dispatch = yield this.$.dispatcher;\n            const formulaId = dispatch.resolution.get(DurationVar);\n            if (formulaId === CalculateProposed) {\n                return yield* this.calculateDurationProposed();\n            }\n            else if (formulaId === durationFormula.formulaId) {\n                return yield* this.calculateDurationPure();\n                // the \"new way\" would be\n                // return yield* this.calculateProjectedDuration(yield this.$.startDate, yield this.$.endDate)\n            }\n            else {\n                throw new Error(\"Unknown formula for `duration`\");\n            }\n        }\n        /**\n         * The \"pure\" calculation function of the [[duration]] field. It should calculate the [[duration]] as if\n         * there's no user input for it and no previous value - \"purely\" based on the values of other fields.\n         *\n         * If start date of event is less or equal then end date (normal case) it delegates to [[calculateProjectedDuration]].\n         * Otherwise, duration is set to 0.\n         *\n         * See also [[calculateDurationProposed]].\n         */\n        *calculateDurationPure() {\n            const startDate = yield this.$.startDate;\n            const endDate = yield this.$.endDate;\n            if (!startDate || !endDate)\n                return null;\n            if (startDate > endDate) {\n                yield Write(this.$.duration, 0, null);\n            }\n            else {\n                return yield* this.calculateProjectedDuration(startDate, endDate);\n            }\n        }\n        /**\n         * The \"proposed\" calculation function of the [[duration]] field. It should calculate the [[duration]] as if\n         * there's a user input for it or a previous value. It can also use the values of other fields to \"validate\"\n         * the \"proposed\" value.\n         *\n         * See also [[calculateDurationPure]]\n         */\n        *calculateDurationProposed() {\n            return yield ProposedOrPrevious;\n        }\n        /**\n         * This method calculates the duration of the given time span, in the provided `durationUnit` or in the [[durationUnit]].\n         *\n         * @param startDate\n         * @param endDate\n         * @param durationUnit\n         */\n        *calculateProjectedDuration(startDate, endDate, durationUnit) {\n            if (!startDate || !endDate)\n                return null;\n            if (!durationUnit)\n                durationUnit = yield this.$.durationUnit;\n            const calendar = yield this.$.effectiveCalendar;\n            const project = this.getProject();\n            return yield* project.$convertDuration(calendar.calculateDurationMs(startDate, endDate), TimeUnit.Millisecond, durationUnit);\n        }\n        // effective duration is either a \"normal\" duration, or, if the duration itself is being calculated\n        // (so that yielding it will cause a cycle)\n        // an \"estimated\" duration, calculated based on proposed/previous start/end date values\n        *calculateEffectiveDuration() {\n            const dispatch = yield this.$.dispatcher;\n            let effectiveDurationToUse;\n            const durationResolution = dispatch.resolution.get(DurationVar);\n            if (durationResolution === CalculateProposed) {\n                effectiveDurationToUse = yield this.$.duration;\n            }\n            else if (durationResolution === durationFormula.formulaId) {\n                effectiveDurationToUse = yield* this.calculateProjectedDuration(yield ProposedOrPreviousValueOf(this.$.startDate), yield ProposedOrPreviousValueOf(this.$.endDate));\n            }\n            return effectiveDurationToUse;\n        }\n        //endregion\n        *calculateEffectiveCalendar() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const project = this.getProject();\n            return manuallyScheduled && !project.skipNonWorkingTimeInDurationWhenSchedulingManually\n                ? project.defaultCalendar\n                : yield* super.calculateEffectiveCalendar();\n        }\n    }\n    __decorate([\n        model_field({ type: 'date' }, { converter: dateConverter })\n    ], BaseEventMixin.prototype, \"startDate\", void 0);\n    __decorate([\n        model_field({ type: 'date' }, { converter: dateConverter })\n    ], BaseEventMixin.prototype, \"endDate\", void 0);\n    __decorate([\n        model_field({ type: 'number', allowNull: true })\n    ], BaseEventMixin.prototype, \"duration\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: TimeUnit.Day }, { converter: (unit) => DateHelper.normalizeUnit(unit) || TimeUnit.Day })\n    ], BaseEventMixin.prototype, \"durationUnit\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: Direction.Forward }, { sync: true })\n    ], BaseEventMixin.prototype, \"direction\", void 0);\n    __decorate([\n        field({ identifierCls: SEDDispatcherIdentifier })\n    ], BaseEventMixin.prototype, \"dispatcher\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: false })\n    ], BaseEventMixin.prototype, \"manuallyScheduled\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: false })\n    ], BaseEventMixin.prototype, \"unscheduled\", void 0);\n    __decorate([\n        calculate('dispatcher')\n    ], BaseEventMixin.prototype, \"calculateDispatcher\", null);\n    __decorate([\n        build_proposed('dispatcher')\n    ], BaseEventMixin.prototype, \"buildProposedDispatcher\", null);\n    __decorate([\n        write('startDate')\n    ], BaseEventMixin.prototype, \"writeStartDate\", null);\n    __decorate([\n        calculate('startDate')\n    ], BaseEventMixin.prototype, \"calculateStartDate\", null);\n    __decorate([\n        write('endDate')\n    ], BaseEventMixin.prototype, \"writeEndDate\", null);\n    __decorate([\n        calculate('endDate')\n    ], BaseEventMixin.prototype, \"calculateEndDate\", null);\n    __decorate([\n        write('duration')\n    ], BaseEventMixin.prototype, \"writeDuration\", null);\n    __decorate([\n        calculate('duration')\n    ], BaseEventMixin.prototype, \"calculateDuration\", null);\n    return BaseEventMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { generic_field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { ModelBucketField } from \"../../../chrono/ModelFieldAtom.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\nimport { AbstractHasAssignmentsMixin } from '../AbstractHasAssignmentsMixin.js';\n/**\n * This is a mixin, which can be applied to the [[BaseEventMixin]]. It provides the collection of all assignments,\n * which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class BaseHasAssignmentsMixin extends Mixin([BaseEventMixin, AbstractHasAssignmentsMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseHasAssignmentsMixin extends base {\n        get assignments() {\n            return this.assigned ? [...this.assigned] : [];\n        }\n    }\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], BaseHasAssignmentsMixin.prototype, \"assigned\", void 0);\n    return BaseHasAssignmentsMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { generic_field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { ModelBucketField } from \"../../../chrono/ModelFieldAtom.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\n/**\n * This is a mixin, providing dependencies \"awareness\" for the event.\n *\n * Doesn't affect scheduling.\n */\nexport class HasDependenciesMixin extends Mixin([BaseEventMixin], (base) => {\n    const superProto = base.prototype;\n    class HasDependenciesMixin extends base {\n        leaveProject() {\n            // if the model is in the graph, so we are able to read its identifiers\n            if (this.isInActiveTransaction) {\n                const activeTransaction = this.graph.activeTransaction;\n                const dependencyStore = this.getDependencyStore();\n                const toRemove = [];\n                // https://github.com/bryntum/support/issues/6099\n                // use only calculated values, avoid triggering calculations\n                // (if calculation is needed, that probably means, that a dependency from the opposite side\n                // has been removed earlier in this transaction)\n                // trigger calculation will start a new epoch in the graph walker\n                // so large part of the graph will be repeatedly marked as dirty\n                // also filter to only existing, not yet removed records, otherwise STM records those as\n                // valid removes(?) and \"excessive rendering\" appears in the \"examples/advanced.t.js\" Gantt test\n                // (also not clear how that is related)\n                for (const dep of activeTransaction.readCurrentOrProposedOrPrevious(this.$.outgoingDeps) ?? [])\n                    if (dependencyStore.includes(dep))\n                        toRemove.push(dep);\n                for (const dep of activeTransaction.readCurrentOrProposedOrPrevious(this.$.incomingDeps) ?? [])\n                    if (dependencyStore.includes(dep))\n                        toRemove.push(dep);\n                this.project.dependencyStore.remove(toRemove);\n            }\n            superProto.leaveProject.call(this);\n        }\n    }\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], HasDependenciesMixin.prototype, \"outgoingDeps\", void 0);\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], HasDependenciesMixin.prototype, \"incomingDeps\", void 0);\n    return HasDependenciesMixin;\n}) {\n}\n", "import { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { BaseEventMixin } from './BaseEventMixin.js';\nimport { BaseHasAssignmentsMixin } from \"./BaseHasAssignmentsMixin.js\";\nimport { HasDependenciesMixin } from './HasDependenciesMixin.js';\n/**\n * This is an event class, [[SchedulerBasicProjectMixin]] is working with.\n * It is constructed as [[BaseEventMixin]], enhanced with [[BaseHasAssignmentsMixin]] and [[HasDependenciesMixin]]\n */\nexport class SchedulerBasicEvent extends Mixin([\n    BaseEventMixin,\n    BaseHasAssignmentsMixin,\n    HasDependenciesMixin\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerBasicEvent extends base {\n    }\n    return SchedulerBasicEvent;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerBasicEvent } from \"../model/scheduler_basic/SchedulerBasicEvent.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractEventStoreMixin } from \"./AbstractEventStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all events in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoEventStoreMixin extends Mixin([AbstractEventStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    class ChronoEventStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 400;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: SchedulerBasicEvent\n            };\n        }\n        set data(value) {\n            super.data = value;\n            this.afterEventRemoval();\n        }\n    }\n    return ChronoEventStoreMixin;\n}) {\n}\n/**\n * The tree store version of [[ChronoEventStoreMixin]].\n */\nexport class ChronoEventTreeStoreMixin extends Mixin([ChronoEventStoreMixin], (base) => {\n    class ChronoEventTreeStoreMixin extends base {\n        buildRootNode() {\n            return this.getProject() || {};\n        }\n        static get defaultConfig() {\n            return {\n                tree: true\n            };\n        }\n    }\n    return ChronoEventTreeStoreMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { generic_field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { ModelBucketField } from '../../../chrono/ModelFieldAtom.js';\nimport { ChronoPartOfProjectModelMixin } from '../mixin/ChronoPartOfProjectModelMixin.js';\nimport { HasCalendarMixin } from './HasCalendarMixin.js';\n/**\n * This is a base resource entity.\n */\nexport class BaseResourceMixin extends Mixin([HasCalendarMixin, ChronoPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseResourceMixin extends base {\n        get assignments() {\n            return [...this.assigned];\n        }\n        leaveProject(isReplacing = false) {\n            // `this.assigned` will be empty if model is added to project and then removed immediately\n            // w/o any propagations\n            // when replacing a resource, the assignments should be left intact\n            if (!this.isStmRestoring && this.assigned && !isReplacing) {\n                const resourceStore = this.getResourceStore();\n                // to batch the assignments removal, we don't remove the assignments right away, but instead\n                // add them for the batched removal to the `assignmentsForRemoval` property of the event store\n                this.assigned.forEach(assignment => resourceStore.assignmentsForRemoval.add(assignment));\n            }\n            superProto.leaveProject.call(this);\n        }\n        // resource model should support the \"tree mode\" in the same way as event model\n        static get fields() {\n            return [\n                { name: 'parentId' },\n                { name: 'children', persist: false }\n            ];\n        }\n    }\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], BaseResourceMixin.prototype, \"assigned\", void 0);\n    return BaseResourceMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { BaseResourceMixin } from \"../model/scheduler_basic/BaseResourceMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractResourceStoreMixin } from \"./AbstractResourceStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all resources in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoResourceStoreMixin extends Mixin([AbstractResourceStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoResourceStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 300;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: BaseResourceMixin\n            };\n        }\n    }\n    return ChronoResourceStoreMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field } from \"../../ChronoGraph/replica/Entity.js\";\nimport { ChronoModelMixin } from \"../chrono/ChronoModelMixin.js\";\nimport { model_field } from \"../chrono/ModelFieldAtom.js\";\n/**\n * This mixin provides the duration converting functionality - the [[convertDuration]] method. It requires (inherit from) [[ChronoModelMixin]].\n */\nexport class DurationConverterMixin extends Mixin([ChronoModelMixin], (base) => {\n    const superProto = base.prototype;\n    class DurationConverterMixin extends base {\n        *calculateUnitsInMs() {\n            const hoursPerDay = yield this.$.hoursPerDay;\n            const daysPerWeek = yield this.$.daysPerWeek;\n            const daysPerMonth = yield this.$.daysPerMonth;\n            return {\n                millisecond: 1,\n                second: 1000,\n                minute: 60 * 1000,\n                hour: 60 * 60 * 1000,\n                day: hoursPerDay * 60 * 60 * 1000,\n                week: daysPerWeek * hoursPerDay * 60 * 60 * 1000,\n                month: daysPerMonth * hoursPerDay * 60 * 60 * 1000,\n                quarter: 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1000,\n                year: 4 * 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1000\n            };\n        }\n        /**\n         * Converts duration value from one time unit to another\n         * @param duration Duration value\n         * @param fromUnit Duration value time unit\n         * @param toUnit   Target time unit to convert the value to\n         */\n        convertDuration(duration, fromUnit, toUnit) {\n            let result = duration;\n            if (fromUnit !== toUnit) {\n                result = duration * this.unitsInMs[fromUnit] / this.unitsInMs[toUnit];\n            }\n            return result;\n            // <remove-on-release>\n            // TODO: should be just something like:\n            //  return this.run('$convertDuration', duration, fromUnit, toUnit)\n            // </remove-on-release>\n        }\n        *$convertDuration(duration, fromUnit, toUnit) {\n            if (!fromUnit || !toUnit)\n                throw new Error(\"Conversion unit not provided\");\n            const unitsInMs = yield this.$.unitsInMs;\n            let result = duration;\n            if (fromUnit !== toUnit) {\n                result = duration * unitsInMs[fromUnit] / unitsInMs[toUnit];\n            }\n            return result;\n        }\n    }\n    __decorate([\n        field()\n    ], DurationConverterMixin.prototype, \"unitsInMs\", void 0);\n    __decorate([\n        model_field({ type: 'number', defaultValue: 24 })\n    ], DurationConverterMixin.prototype, \"hoursPerDay\", void 0);\n    __decorate([\n        model_field({ type: 'number', defaultValue: 7 })\n    ], DurationConverterMixin.prototype, \"daysPerWeek\", void 0);\n    __decorate([\n        model_field({ type: 'number', defaultValue: 30 })\n    ], DurationConverterMixin.prototype, \"daysPerMonth\", void 0);\n    __decorate([\n        calculate('unitsInMs')\n    ], DurationConverterMixin.prototype, \"calculateUnitsInMs\", null);\n    return DurationConverterMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { generic_field } from '../../../../ChronoGraph/replica/Entity.js';\nimport { model_field, ModelReferenceField, isSerializableEqual } from '../../../chrono/ModelFieldAtom.js';\nimport { DependencyType } from '../../../scheduling/Types.js';\nimport { ChronoPartOfProjectModelMixin } from '../mixin/ChronoPartOfProjectModelMixin.js';\n/**\n * Base dependency entity mixin type\n */\nexport class BaseDependencyMixin extends Mixin([ChronoPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseDependencyMixin extends base {\n        get isValid() {\n            const { $, graph } = this;\n            // In case the dependency is added but causes a conflict, fromEvent/toEvent are not in the graph. Thus\n            // reading them causes an exception which we want to avoid.\n            // This is caught sporadically by 10_handling.t.js in SchedulerPro\n            if (graph && (!graph.hasIdentifier($.fromEvent) || !graph.hasIdentifier($.toEvent))) {\n                return false;\n            }\n            return super.isValid;\n        }\n    }\n    __decorate([\n        generic_field({\n            bucket: 'outgoingDeps',\n            resolver: function (id) { return this.getEventById(id); },\n            modelFieldConfig: {\n                persist: true,\n                serialize: event => event?.id,\n                isEqual: isSerializableEqual\n            },\n        }, ModelReferenceField)\n    ], BaseDependencyMixin.prototype, \"fromEvent\", void 0);\n    __decorate([\n        generic_field({\n            bucket: 'incomingDeps',\n            resolver: function (id) { return this.getEventById(id); },\n            modelFieldConfig: {\n                persist: true,\n                serialize: event => event?.id,\n                isEqual: isSerializableEqual\n            },\n        }, ModelReferenceField)\n    ], BaseDependencyMixin.prototype, \"toEvent\", void 0);\n    __decorate([\n        model_field({ type: 'int', defaultValue: DependencyType.EndToStart })\n    ], BaseDependencyMixin.prototype, \"type\", void 0);\n    __decorate([\n        model_field({ type: 'string' })\n    ], BaseDependencyMixin.prototype, \"fromSide\", void 0);\n    __decorate([\n        model_field({ type: 'string' })\n    ], BaseDependencyMixin.prototype, \"toSide\", void 0);\n    return BaseDependencyMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoModelMixin } from \"../../../chrono/ChronoModelMixin.js\";\nimport { ConflictEffect } from \"../../../chrono/Conflict.js\";\nimport { AbstractProjectMixin } from \"../AbstractProjectMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\n/**\n * This is an abstract project, which just lists the available stores.\n *\n * The actual project classes are [[SchedulerBasicProjectMixin]], [[SchedulerProProjectMixin]], [[GanttProjectMixin]].\n */\nexport class ChronoAbstractProjectMixin extends Mixin([ChronoModelMixin, AbstractProjectMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoAbstractProjectMixin extends base {\n        // External flag, toggled late in finalization when already entered replica\n        get isDelayingCalculation() {\n            return Boolean(this.delayEnteringReplica || this.delayedCalculationPromise);\n        }\n        getGraph() {\n            return this.replica;\n        }\n        beforeCommitAsync() { return null; }\n        enterReplica(enterRecords) { }\n        acceptChanges() { }\n        // If we are delaying calculations, return its promise which will be resolved when calculations are finished.\n        // As part of that process it will commit replica\n        async commitAsync() {\n            return this.delayedCalculationPromise || this.replica?.commitAsync();\n        }\n        getSchedulingIssueEventArguments(schedulingIssue, transaction, resolve, reject) {\n            const result = [\n                schedulingIssue.type,\n                {\n                    continueWithResolutionResult: resolve,\n                    schedulingIssue\n                }\n            ];\n            // For scheduling conflict public API expects to have \"conflict\" property w/ the ConflictEffect instance\n            if (schedulingIssue instanceof ConflictEffect)\n                result[1].conflict = schedulingIssue;\n            return result;\n        }\n        async onSchedulingIssueCall(schedulingIssue, transaction) {\n            // is there is a \"schedulingConflict\" event listener we expect resolution option will be picked there\n            if (schedulingIssue.type && this.hasListener(schedulingIssue.type)) {\n                return new Promise((resolve, reject) => {\n                    this.trigger(...this.getSchedulingIssueEventArguments(schedulingIssue, transaction, resolve, reject));\n                });\n            }\n            // by default we cancel the committed changes\n            return EffectResolutionResult.Cancel;\n        }\n        async onCycleSchedulingIssue(schedulingIssue, transaction) {\n            return this.onSchedulingIssueCall(schedulingIssue, transaction);\n        }\n        async onEmptyCalendarSchedulingIssue(schedulingIssue, transaction) {\n            return this.onSchedulingIssueCall(schedulingIssue, transaction);\n        }\n        async onConflictSchedulingIssue(schedulingIssue, transaction) {\n            return this.onSchedulingIssueCall(schedulingIssue, transaction);\n        }\n        setModelCalculations(model, calculations) {\n            if (!calculations)\n                return;\n            const oldValues = {};\n            // backup current calculations\n            for (const field in calculations) {\n                oldValues[field] = model.prototype.$calculations[field];\n            }\n            // Patch model prototype settings\n            Object.assign(model.prototype.$calculations, calculations);\n            return oldValues;\n        }\n        setRecordCalculations(record, calculations) {\n            const oldValues = this.setModelCalculations(record.constructor, calculations);\n            const skeleton = record.$entity.$skeleton;\n            Object.keys(calculations).forEach(field => {\n                skeleton[field].prototype.calculation = record[calculations[field]];\n            });\n            return oldValues;\n        }\n        setStoreCalculations(store, calculations) {\n            if (!calculations)\n                return;\n            // Rebuild corresponding identifiers\n            const record = store.first;\n            if (record) {\n                return this.setRecordCalculations(record, calculations);\n            }\n            else {\n                return this.setModelCalculations(store.modelClass, calculations);\n            }\n        }\n        /**\n         * Overrides the project owned store identifiers calculation.\n         * @param calculations Object providing new identifier calculation function names.\n         * The object is grouped by store identifiers. For example below code\n         * overrides event `startDate`, `endDate` and `duration` calculation so\n         * the fields will always simply return their current values:\n         *\n         * ```typescript\n         * // event startDate, endDate and duration will use their userProvidedValue method\n         * // which simply returns their current values as-is\n         * const oldCalculations = await project.setCalculations({\n         *     events : {\n         *         startDate : \"userProvidedValue\",\n         *         endDate   : \"userProvidedValue\",\n         *         duration  : \"userProvidedValue\"\n         *     }\n         * })\n         * ```\n         * @returns Promise that resolves with an object having the overridden calculations.\n         * The object can be used to toggle the calculations back in the future:\n         * ```typescript\n         * // override event duration calculation\n         * const oldCalculations = await project.setCalculations({\n         *     events : {\n         *         duration  : \"userProvidedValue\"\n         *     }\n         * })\n         * // revert the duration calculation back\n         * project.setCalculations(oldCalculations)\n         * ```\n         */\n        async setCalculations(calculations) {\n            // Graph might not be created if using delayed calculations\n            this.replica && await this.commitAsync();\n            const oldCalculations = {};\n            const stores = {\n                tasks: this.eventStore,\n                events: this.eventStore,\n                dependencies: this.dependencyStore,\n                resources: this.resourceStore,\n                assignments: this.assignmentStore,\n                calendars: this.calendarManagerStore\n            };\n            Object.keys(stores).forEach(id => {\n                // Apply calculation change to every owned store\n                if (calculations[id]) {\n                    oldCalculations[id] = this.setStoreCalculations(stores[id], calculations[id]);\n                }\n            });\n            // Apply calculation changes to the project if provided\n            let projectCalculations = calculations.project;\n            if (projectCalculations) {\n                oldCalculations.project = this.setRecordCalculations(this, projectCalculations);\n            }\n            // Repopulate replica w/ updated identifiers\n            //@ts-ignore\n            this.replica && this.repopulateReplica.now();\n            this.replica && await this.commitAsync();\n            // return previous calculation settings\n            return oldCalculations;\n        }\n    }\n    return ChronoAbstractProjectMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { MAX_DATE, MIN_DATE } from \"../../../util/Constants.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\n// this mixin can be better named `ScheduledBySubEvents`\n// it can also be defined as \"HasChildrenOnly\" - ie has child events, but does not have parent (not part of the tree structure)\n// then the `HasChildrenMixin` would be `HasParent`\n/**\n * This mixin provides the notion of \"sub events\" for the [[BaseEventMixin]], which is a bit more general concept\n * of the \"child\" events. This special notion is required, because the event store can be a flat store, not providing\n * any tree structuring. In the same time, we treat the project instance as a \"parent\" event for all events in the flat\n * event store - so it accumulates the same aggregation information as other \"regular\" parent events.\n *\n * The event with this mixin is scheduled according to the \"sub events\" information - it starts at the earliest date\n * among all sub events and ends at the latest. If there's no \"sub events\" - it delegates to previous behaviour.\n *\n * Scheduling by children can be disabled by setting [[manuallyScheduled]] flag to `true` which will\n * result [[startDate]] and [[endDate]] fields will keep their provided values.\n */\nexport class HasSubEventsMixin extends Mixin([BaseEventMixin], (base) => {\n    const superProto = base.prototype;\n    class HasSubEventsMixin extends base {\n        static get $name() {\n            return 'HasSubEventsMixin';\n        }\n        /**\n         * The abstract method which should indicate whether this event has sub events\n         */\n        *hasSubEvents() {\n            throw new Error(\"Abstract method `hasSubEvents` has been called\");\n        }\n        /**\n         * The abstract method which should return an Iterable of [[BaseEventMixin]]\n         */\n        *subEventsIterable() {\n            throw new Error(\"Abstract method `subEventsIterable` has been called\");\n        }\n        *calculateStartDatePure() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateMinChildrenStartDate();\n            }\n            else {\n                return yield* superProto.calculateStartDatePure.call(this);\n            }\n        }\n        *calculateEndDatePure() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateMaxChildrenEndDate();\n            }\n            else {\n                return yield* superProto.calculateEndDatePure.call(this);\n            }\n        }\n        *calculateStartDateProposed() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateStartDatePure();\n            }\n            else {\n                return yield* superProto.calculateStartDateProposed.call(this);\n            }\n        }\n        *calculateEndDateProposed() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateEndDatePure();\n            }\n            else {\n                return yield* superProto.calculateEndDateProposed.call(this);\n            }\n        }\n        *calculateDurationProposed() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateDurationPure();\n            }\n            else {\n                return yield* superProto.calculateDurationProposed.call(this);\n            }\n        }\n        /**\n         * The method defines wether the provided child event should be\n         * taken into account when calculating this summary event [[startDate]].\n         * Child events roll up their [[startDate]] values to their summary tasks.\n         * So a summary task [[startDate|start]] date gets equal to\n         * its minimal child [[startDate|start]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default the method returns `true` to include all child events data.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildStartDate(child) {\n            return true;\n        }\n        /**\n         * Calculates the minimal sub-events [[startDate]].\n         * The method is used for calculating the event [[startDate]].\n         */\n        *calculateMinChildrenStartDate() {\n            const children = yield* this.subEventsIterable();\n            let timestamp = MAX_DATE.getTime();\n            for (const child of children) {\n                if (yield* this.shouldRollupChildStartDate(child)) {\n                    let date = yield child.$.startDate;\n                    // if the child has endDate only - use that value\n                    if (!date) {\n                        date = yield child.$.endDate;\n                    }\n                    if (date && date.getTime() < timestamp) {\n                        timestamp = date.getTime();\n                    }\n                }\n            }\n            if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime())\n                return null;\n            return new Date(timestamp);\n        }\n        /**\n         * The method defines wether the provided child event should be\n         * taken into account when calculating this summary event [[endDate]].\n         * Child events roll up their [[endDate]] values to their summary tasks.\n         * So a summary task [[endDate|end]] gets equal to its maximal child [[endDate|end]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default the method returns `true` to include all child events data.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildEndDate(child) {\n            return true;\n        }\n        /**\n         * Calculates the maximum sub-events [[endDate]].\n         * The method is used for calculating the event [[endDate]].\n         */\n        *calculateMaxChildrenEndDate() {\n            const children = yield* this.subEventsIterable();\n            let timestamp = MIN_DATE.getTime();\n            for (const child of children) {\n                if (yield* this.shouldRollupChildEndDate(child)) {\n                    let date = yield child.$.endDate;\n                    if (!date) {\n                        date = yield child.$.startDate;\n                    }\n                    if (date && date.getTime() > timestamp) {\n                        timestamp = date.getTime();\n                    }\n                }\n            }\n            if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime())\n                return null;\n            return new Date(timestamp);\n        }\n    }\n    return HasSubEventsMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { reference } from \"../../../../ChronoGraph/replica/Reference.js\";\nimport { bucket } from \"../../../../ChronoGraph/replica/ReferenceBucket.js\";\nimport { HasSubEventsMixin } from \"./HasSubEventsMixin.js\";\n/**\n * Specialized version of the [[HasSubEventsMixin]]. The event becomes part of the tree structure.\n * It now has reference to the [[parentEvent]] and a collection of [[childEvents]].\n *\n * The abstract methods from the [[HasSubEventsMixin]] are defined to operate on the [[childEvents]] collection.\n */\nexport class HasChildrenMixin extends Mixin([HasSubEventsMixin], (base) => {\n    const superProto = base.prototype;\n    class HasChildrenMixin extends base {\n        /**\n         * Returns `true` if the event has nested sub-events.\n         */\n        *hasSubEvents() {\n            const childEvents = yield this.$.childEvents;\n            return childEvents.size > 0;\n        }\n        /**\n         * Returns iterable object listing the event nested sub-events.\n         * ```typescript\n         * const subEventsIterator : Iterable<HasChildrenMixin> = yield* event.subEventsIterable()\n         *\n         * for (let childEvent of subEventsIterator) {\n         *     // ..do something..\n         * }\n         * ```\n         */\n        *subEventsIterable() {\n            return yield this.$.childEvents;\n        }\n        get parent() {\n            return this._parent;\n        }\n        set parent(value) {\n            this._parent = value;\n            this.parentEvent = value;\n        }\n    }\n    __decorate([\n        reference({ bucket: 'childEvents' })\n    ], HasChildrenMixin.prototype, \"parentEvent\", void 0);\n    __decorate([\n        bucket()\n    ], HasChildrenMixin.prototype, \"childEvents\", void 0);\n    return HasChildrenMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { MixinAny } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ReadMode, Replica } from \"../../../../ChronoGraph/replica/Replica.js\";\nimport { Schema } from \"../../../../ChronoGraph/schema/Schema.js\";\nimport { delay } from \"../../../../ChronoGraph/util/Helpers.js\";\nimport StateTrackingManager from \"../../../../Core/data/stm/StateTrackingManager.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nimport { model_field, ModelReferenceField, IsChronoModelSymbol, ModelBucketField } from \"../../../chrono/ModelFieldAtom.js\";\nimport { EngineReplica, CycleEffect } from \"../../../chrono/Replica.js\";\nimport { DurationConverterMixin } from \"../../../scheduling/DurationConverterMixin.js\";\nimport { ProjectType } from \"../../../scheduling/Types.js\";\nimport { ChronoAssignmentStoreMixin } from \"../../store/ChronoAssignmentStoreMixin.js\";\nimport { ChronoCalendarManagerStoreMixin } from \"../../store/ChronoCalendarManagerStoreMixin.js\";\nimport { ChronoDependencyStoreMixin } from \"../../store/ChronoDependencyStoreMixin.js\";\nimport { ChronoEventStoreMixin } from \"../../store/ChronoEventStoreMixin.js\";\nimport { ChronoResourceStoreMixin } from \"../../store/ChronoResourceStoreMixin.js\";\nimport { ChronoAbstractProjectMixin } from \"./ChronoAbstractProjectMixin.js\";\nimport { BaseAssignmentMixin } from \"./BaseAssignmentMixin.js\";\nimport { BaseCalendarMixin } from \"./BaseCalendarMixin.js\";\nimport { BaseDependencyMixin } from \"./BaseDependencyMixin.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\nimport { BaseResourceMixin } from \"./BaseResourceMixin.js\";\nimport { CanCombineCalendarsMixin, HasCalendarMixin } from \"./HasCalendarMixin.js\";\nimport { HasSubEventsMixin } from \"./HasSubEventsMixin.js\";\nimport { SchedulerBasicEvent } from \"./SchedulerBasicEvent.js\";\nimport ObjectHelper from \"../../../../Core/helper/ObjectHelper.js\";\n/**\n * Basic Scheduler project mixin type. At this level, events have assignments and dependencies, which both are, however,\n * only visual and do not affect the scheduling.\n */\nexport class SchedulerBasicProjectMixin extends MixinAny([\n    ChronoAbstractProjectMixin,\n    BaseEventMixin,\n    HasSubEventsMixin,\n    HasCalendarMixin,\n    DurationConverterMixin,\n    CanCombineCalendarsMixin\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerBasicProjectMixin extends base {\n        construct(config = {}) {\n            this.delayCalculation = config.delayCalculation !== false;\n            this.enableProgressNotifications = config.enableProgressNotifications || config.delayCalculation !== false;\n            // Expand project by default to make getRange to work\n            if (!('expanded' in config)) {\n                // @ts-ignore\n                config.expanded = true;\n            }\n            if (this.delayCalculation) {\n                this.delayEnteringReplica = true;\n            }\n            if (!('skipNonWorkingTimeWhenSchedulingManually' in config)) {\n                config.skipNonWorkingTimeWhenSchedulingManually = false;\n            }\n            superProto.construct.call(this, config);\n            this.repopulateStores = new Set();\n            this.ignoreInitialCommitComputationCycles = ('ignoreInitialCommitComputationCycles' in config) ? config.ignoreInitialCommitComputationCycles : false;\n            if (this.ignoreInitialCommitComputationCycles) {\n                console.warn('Project \"ignoreInitialCommitComputationCycles\" option is deprecated and will be dropped in the next major release');\n            }\n            if (!this.eventModelClass)\n                this.eventModelClass = this.getDefaultEventModelClass();\n            if (!this.eventStoreClass)\n                this.eventStoreClass = this.getDefaultEventStoreClass();\n            if (!this.dependencyModelClass)\n                this.dependencyModelClass = this.getDefaultDependencyModelClass();\n            if (!this.dependencyStoreClass)\n                this.dependencyStoreClass = this.getDefaultDependencyStoreClass();\n            if (!this.resourceModelClass)\n                this.resourceModelClass = this.getDefaultResourceModelClass();\n            if (!this.resourceStoreClass)\n                this.resourceStoreClass = this.getDefaultResourceStoreClass();\n            if (!this.assignmentModelClass)\n                this.assignmentModelClass = this.getDefaultAssignmentModelClass();\n            if (!this.assignmentStoreClass)\n                this.assignmentStoreClass = this.getDefaultAssignmentStoreClass();\n            if (!this.calendarModelClass)\n                this.calendarModelClass = this.getDefaultCalendarModelClass();\n            if (!this.calendarManagerStoreClass)\n                this.calendarManagerStoreClass = this.getDefaultCalendarManagerStoreClass();\n            if (!this.cycleEffectClass)\n                this.cycleEffectClass = this.getDefaultCycleEffectClass();\n            this.initializeStm();\n            // NOTE, default calendar is assumed to be 24/7/365, because it is used for manually scheduled events\n            // not part of the CalendarManagerStore intentionally, not persisted\n            this.defaultCalendar = new this.calendarModelClass({\n                unspecifiedTimeIsWorking: this.unspecifiedTimeIsWorking\n            });\n            this.defaultCalendar.project = this;\n            if (!this.delayEnteringReplica)\n                this.enterReplica(false);\n            this.setCalendarManagerStore(this.calendarManagerStore);\n            this.setEventStore(this.eventStore);\n            this.setDependencyStore(this.dependencyStore);\n            this.setResourceStore(this.resourceStore);\n            this.setAssignmentStore(this.assignmentStore);\n            const hasInlineData = Boolean(this.calendarsData || this.eventsData || this.dependenciesData || this.resourcesData || this.assignmentsData);\n            if (hasInlineData) {\n                // this branch has `scheduleDelayedCalculation` call inside `loadInlineData`\n                this.loadInlineData({\n                    calendarsData: this.calendarsData,\n                    eventsData: this.eventsData,\n                    dependenciesData: this.dependenciesData,\n                    resourcesData: this.resourcesData,\n                    assignmentsData: this.assignmentsData\n                });\n                delete this.calendarsData;\n                delete this.eventsData;\n                delete this.dependenciesData;\n                delete this.resourcesData;\n                delete this.assignmentsData;\n            }\n            else {\n                // on this branch need to call it manually\n                // avoid calling `scheduleDelayedCalculation` unless absolutely necessary\n                // this is to avoid having 2 commits in the project - 1st with empty data\n                // 2nd with real data\n                // we have special behavior tied to the 1st commit, like state restoring (previously selected record)\n                if (this.delayCalculation && this.hasDataInStores)\n                    this.scheduleDelayedCalculation();\n            }\n        }\n        get hasDataInStores() {\n            return [\n                this.calendarManagerStore,\n                this.eventStore,\n                this.dependencyStore,\n                this.resourceStore,\n                this.assignmentStore\n            ].some(store => store.allCount > 0);\n        }\n        enterReplica(enterRecords) {\n            const me = this;\n            if (!me.replica) {\n                me.replica = me.createReplica();\n                me.replica.addEntity(me);\n                me.replica.addEntity(me.defaultCalendar);\n                me.trigger('graphReady');\n            }\n            // In delayCalculation mode no records entered the graph on construction,\n            // instead we enter them now after first draw\n            if (enterRecords && !me.isRepopulatingStores) {\n                // Only enter \"new\" records, we are called when records are added later on\n                me.calendarManagerStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.eventStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.resourceStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.dependencyStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.assignmentStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n            }\n        }\n        resetStmQueue() {\n            const wasDisabled = this.stm.disabled;\n            this.stm.disable();\n            this.stm.resetQueue();\n            if (!wasDisabled) {\n                this.stm.enable();\n            }\n        }\n        doDestroy() {\n            const me = this;\n            me.eventStore?.destroy();\n            me.dependencyStore?.destroy();\n            me.assignmentStore?.destroy();\n            me.resourceStore?.destroy();\n            me.calendarManagerStore?.destroy();\n            me.defaultCalendar?.destroy();\n            me.replica?.clear();\n            me.stm?.destroy();\n            superProto.doDestroy.call(this);\n        }\n        getReplicaConfig() {\n            return {\n                project: this,\n                schema: Schema.new(),\n                enableProgressNotifications: this.enableProgressNotifications,\n                silenceInitialCommit: this.silenceInitialCommit,\n                ignoreInitialCommitComputationCycles: this.ignoreInitialCommitComputationCycles,\n                cycleEffectClass: this.cycleEffectClass,\n                onWriteDuringCommit: 'ignore',\n                readMode: ReadMode.CurrentOrProposedOrPrevious\n            };\n        }\n        // Creates a new Replica, used during construction and when repopulating\n        createReplica() {\n            return EngineReplica.mix(Replica).new(this.getReplicaConfig());\n        }\n        *hasSubEvents() {\n            return this.getEventStore().count > 0;\n        }\n        *subEventsIterable() {\n            return this.getEventStore().getRange();\n        }\n        getType() {\n            return ProjectType.SchedulerBasic;\n        }\n        get enableProgressNotifications() {\n            return this._enableProgressNotifications;\n        }\n        /**\n         * Enables/disables the calculation progress notifications.\n         */\n        set enableProgressNotifications(value) {\n            this._enableProgressNotifications = value;\n            if (this.replica)\n                this.replica.enableProgressNotifications = value;\n        }\n        getDefaultCycleEffectClass() {\n            return CycleEffect;\n        }\n        /**\n         * Returns the default event model class to use\n         */\n        getDefaultEventModelClass() {\n            return SchedulerBasicEvent;\n        }\n        /**\n         * Returns the default event store class to use\n         */\n        getDefaultEventStoreClass() {\n            return ChronoEventStoreMixin;\n        }\n        /**\n         * Returns the default dependency model class to use\n         */\n        getDefaultDependencyModelClass() {\n            return BaseDependencyMixin;\n        }\n        /**\n         * Returns the default dependency store class to use\n         */\n        getDefaultDependencyStoreClass() {\n            return ChronoDependencyStoreMixin;\n        }\n        /**\n         * Returns the default resource model class to use\n         */\n        getDefaultResourceModelClass() {\n            return BaseResourceMixin;\n        }\n        /**\n         * Returns the default resource store class to use\n         */\n        getDefaultResourceStoreClass() {\n            return ChronoResourceStoreMixin;\n        }\n        /**\n         * Returns the default assignment model class to use\n         */\n        getDefaultAssignmentModelClass() {\n            return BaseAssignmentMixin;\n        }\n        /**\n         * Returns the default assignment store class to use\n         */\n        getDefaultAssignmentStoreClass() {\n            return ChronoAssignmentStoreMixin;\n        }\n        /**\n         * Returns the default calendar model class to use\n         */\n        getDefaultCalendarModelClass() {\n            return BaseCalendarMixin;\n        }\n        /**\n         * Returns the default calendar manager store class to use\n         */\n        getDefaultCalendarManagerStoreClass() {\n            return ChronoCalendarManagerStoreMixin;\n        }\n        usingSyncDataOnLoad() {\n            return [this.eventStore, this.resourceStore, this.dependencyStore, this.assignmentStore].some(s => s.syncDataOnLoad);\n        }\n        /**\n         * This method loads the \"raw\" data into the project. The loading is basically happening by\n         * assigning the individual data entries to the `data` property of the corresponding store.\n         *\n         * @param data\n         */\n        async loadInlineData(data) {\n            const { calendarManagerStore, eventStore, dependencyStore, assignmentStore, resourceStore, replica } = this;\n            if (!this.isInitialCommitPerformed) {\n                // Prevent initial commit from happening before inline data is loaded\n                replica?.unScheduleAutoCommit();\n            }\n            else {\n                // We want to be very sure that calculations are complete before we plug new data in.\n                // For a scenario where a client plugged new datasets in on every store change, thus multiple times\n                // during a single commit()\n                while (this.replica.isCommitting) {\n                    await this.commitAsync();\n                }\n            }\n            if (replica?.enableProgressNotifications && !this.delayCalculation) {\n                // First delay needed to allow assignment of Project -> Gantt to happen before carrying on,\n                // to make sure progress listener is in place\n                await delay(0);\n                // wait till the current propagation completes (if any)\n                // otherwise the mask shown due to the next line call will be\n                // destroyed as the propagation gets done\n                await this.commitAsync();\n                replica.onPropagationProgressNotification({ total: 0, remaining: 0, phase: 'storePopulation' });\n                // Second delay needed to allow mask to appear, not clear why delay(0) is not enough, it works in other\n                // places\n                await delay(50);\n            }\n            this.isInitialCommitPerformed = false;\n            this.isLoadingInlineData = true;\n            if (globalThis.DEBUG) {\n                console.log(`%cInitializing project`, 'font-weight:bold;color:darkgreen;text-transform:uppercase;margin-top: 2em');\n                console.time('Time to visible');\n                console.time('Populating project');\n            }\n            // Prevent records from entering replica on reload, schedule delayed entering / calculation\n            if (this.delayCalculation && !this.delayedCalculationPromise && !this.usingSyncDataOnLoad()) {\n                this.scheduleDelayedCalculation();\n            }\n            if (data.calendarsData) {\n                this.repopulateStore(calendarManagerStore);\n                calendarManagerStore.data = data.calendarsData;\n            }\n            if (data.eventsData || data.tasksData) {\n                this.repopulateStore(eventStore);\n                eventStore.data = data.eventsData || data.tasksData;\n            }\n            if (data.dependenciesData) {\n                this.repopulateStore(dependencyStore);\n                dependencyStore.data = data.dependenciesData;\n            }\n            if (data.resourcesData) {\n                this.repopulateStore(resourceStore);\n                resourceStore.data = data.resourcesData;\n            }\n            if (data.assignmentsData) {\n                this.repopulateStore(assignmentStore);\n                assignmentStore.data = data.assignmentsData;\n            }\n            if (data.project) {\n                //@ts-ignore\n                this.applyProjectResponse(data.project);\n            }\n            if (globalThis.DEBUG)\n                console.timeEnd('Populating project');\n            const result = await this.commitLoad();\n            this.isLoadingInlineData = false;\n            return result;\n        }\n        // Called from scheduleDelayedCalculation() & setAssignmentStore to set up indices used to look events and\n        // resources up before calculations has finished\n        setupTemporaryIndices() {\n            const { storage } = this.assignmentStore || {};\n            // First delayed calculation starts before assignmentStore is created => no storage\n            if (storage) {\n                // Set up indices to mimic buckets (removed again in below)\n                storage.addIndex({ property: 'event', unique: false });\n                storage.addIndex({ property: 'resource', unique: false });\n            }\n        }\n        removeTemporaryIndices() {\n            const { storage } = this.assignmentStore;\n            // Indices mimicking buckets are no longer needed now, get rid of them\n            storage.removeIndex('event');\n            storage.removeIndex('resource');\n        }\n        async internalDelayCalculation(resolve) {\n            const me = this;\n            me.delayEnteringReplica = true;\n            me.setupTemporaryIndices();\n            // If listeners are defined on project, we have to wait until after construction before they can\n            // catch any events\n            await delay(0);\n            if (me.isDestroyed) {\n                resolve();\n                return;\n            }\n            me.trigger('delayCalculationStart');\n            // In delayCalculation mode, we trigger refresh before calculating to let UI draw early\n            me.trigger('refresh', { isCalculated: false });\n            await delay(0);\n            if (me.isDestroyed) {\n                resolve();\n                return;\n            }\n            me.delayEnteringReplica = false;\n            // After triggering (and thus drawing) we let everything enter the graph, either by repopulating\n            // a new replica or by entering the existing (or a new from scratch the first time)\n            if (me.isRepopulatingStores) {\n                // @ts-ignore\n                me.repopulateReplica.now();\n            }\n            else {\n                // this triggers the re-application of the `responseData.project`\n                // to the project instance, which might be delayed due to the\n                // `delayEnteringReplica` flag\n                me.trigger('recordsUnlinked');\n                me.enterReplica(true);\n            }\n            const result = await me.replica.commitAsync();\n            if (me.isDestroyed) {\n                resolve();\n                return;\n            }\n            resolve(result);\n            me.delayedCalculationPromise = null;\n            me.trigger('delayCalculationEnd');\n            me.removeTemporaryIndices();\n        }\n        scheduleDelayedCalculation() {\n            if (this.delayedCalculationPromise) {\n                return this.delayedCalculationPromise;\n            }\n            if (this.delayCalculation !== false) {\n                return this.delayedCalculationPromise = new Promise(resolve => \n                // Cannot use async code directly in Promise executor, because it hides errors\n                this.internalDelayCalculation(resolve).then());\n            }\n        }\n        async commitLoad() {\n            // if (globalThis.DEBUG) console.time('Initial propagation')\n            const result = await this.commitAsync();\n            // Might have been destroyed during the async operation above\n            if (!this.isDestroyed)\n                this.trigger('load');\n            return result;\n        }\n        initializeStm() {\n            const stmClass = this.stmClass || StateTrackingManager;\n            // @ts-ignore\n            if (!(this.stm instanceof StateTrackingManager))\n                this.setStm(stmClass.new({ disabled: true }, this.stm));\n            if (this.resetUndoRedoQueuesAfterLoad) {\n                this.ion({\n                    load: this.resetStmQueue,\n                    thisObj: this\n                });\n            }\n            this.ion({\n                beforeCommit: this.onCommitInitialization,\n                commitFinalized: this.onCommitFinalization,\n                commitRejected: this.onCommitRejection,\n                thisObj: this\n            });\n        }\n        removeRejectedRecordsAdd({ transactionResult, silenceCommit }) {\n            const recordsToDrop = new Map();\n            for (const quark of transactionResult.entries.values()) {\n                const identifier = quark.identifier;\n                const { field } = identifier;\n                if (quark.isShadow() || !identifier[IsChronoModelSymbol] || field instanceof ModelBucketField)\n                    continue;\n                const record = identifier.self;\n                const store = record.firstStore;\n                // collect records w/ atoms not having a previous value\n                if (store && !quark.previous && !transactionResult.transaction.getLatestStableEntryFor(record.$$)?.previous) {\n                    if (!recordsToDrop.has(store)) {\n                        recordsToDrop.set(store, new Set([record]));\n                    }\n                    else if (!recordsToDrop.get(store).has(record)) {\n                        recordsToDrop.get(store).add(record);\n                    }\n                }\n            }\n            // @ts-ignore\n            this.suspendChangesTracking?.();\n            const stores = Array.from(recordsToDrop.keys()).sort((a, b) => a.removalOrder - b.removalOrder);\n            // remove the collected records\n            stores.forEach(store => store.remove(recordsToDrop.get(store)));\n            // @ts-ignore\n            this.resumeChangesTracking?.(silenceCommit);\n            if (silenceCommit) {\n                this.eventStore.acceptChanges();\n                this.dependencyStore.acceptChanges();\n                this.resourceStore.acceptChanges();\n                this.assignmentStore.acceptChanges();\n                this.calendarManagerStore.acceptChanges();\n            }\n        }\n        onCommitRejection(event) {\n            // if STM is disabled we're trying to revert changes w/o it\n            if (this._stmDisabled) {\n                // <remove-on-release>\n                // TODO: Reject removals as well\n                // </remove-on-release>\n                this.replica.isWritingPreviousData = true;\n                this.isRestoringData = true;\n                this.removeRejectedRecordsAdd(event);\n                this.isRestoringData = false;\n                this.replica.isWritingPreviousData = false;\n            }\n            // reject last transaction STM has\n            else {\n                this.rejectStmTransaction();\n            }\n        }\n        // https://github.com/bryntum/support/issues/1270\n        onCommitInitialization() {\n            const { stm } = this;\n            this._stmDisabled = stm.disabled;\n            if (stm.isRecording && stm.autoRecord) {\n                this._stmAutoRecord = true;\n                // If auto recording is enabled when we are entering a commit, we need to move autoRecording\n                // state to Recording in order to make sure all changes from the project will become a single\n                // transaction\n                stm.autoRecord = false;\n            }\n        }\n        onCommitFinalization() {\n            if (this._stmAutoRecord) {\n                // This will restore autoRecording state and trigger timer to stop transaction after a delay\n                this.stm.autoRecord = true;\n                this._stmAutoRecord = false;\n            }\n        }\n        onSTMRestoringStart({ source: stm }) {\n            if (this.replica)\n                this.replica.isWritingPreviousData = true;\n        }\n        // Propagate on undo/redo\n        async onSTMRestoringStop({ source }) {\n            if (this.replica)\n                this.replica.isWritingPreviousData = false;\n            const stm = source;\n            // Disable STM meanwhile to not pick it up as a new STM transaction\n            stm.disable();\n            await this.commitAsync();\n            if (!this.isDestroyed) {\n                stm.enable();\n                this.trigger('stateRestoringDone');\n            }\n        }\n        //region Repopulate\n        // defers the call to given function with given arguments until the `repopulateReplica` event\n        // (if replica is scheduled for repopulation, otherwise calls immediately)\n        // between the multiple defers with the same `deferId`, only the latest one is called\n        deferUntilRepopulationIfNeeded(deferId, func, args) {\n            if (this.isRepopulatingStores) {\n                this.detachListeners(deferId);\n                this.ion({\n                    name: deferId,\n                    repopulateReplica: {\n                        fn: async () => {\n                            await this.commitAsync();\n                            if (!this.isDestroyed) {\n                                func(...args);\n                            }\n                        },\n                        once: true\n                    }\n                });\n            }\n            else {\n                func(...args);\n            }\n        }\n        get isRepopulatingStores() {\n            return Boolean(this.repopulateStores?.size);\n        }\n        // Remember which stores are being repopulated, they don't have to care about un-joining the graph later\n        repopulateStore(store) {\n            const me = this;\n            if (me.repopulateOnDataset && store.allCount && !store.syncDataOnLoad) {\n                me.replica?.activeTransaction.stop();\n                if (!me.repopulateStores)\n                    me.repopulateStores = new Set();\n                me.repopulateStores.add(store);\n                // Trigger buffered repopulate of replica\n                me.repopulateReplica();\n            }\n        }\n        // Creates a new replica, populating it with data from the stores\n        repopulateReplica() {\n            const me = this;\n            // Will repopulate as part of scheduled delayed calculations\n            if (me.delayEnteringReplica) {\n                return;\n            }\n            const { calendarManagerStore, eventStore, dependencyStore, assignmentStore, resourceStore, replica: oldReplica } = me;\n            if (oldReplica) {\n                // Unlink all old records that are going to be re-entered into new replica\n                me.unlinkStoreRecords(calendarManagerStore, eventStore, dependencyStore, resourceStore, assignmentStore);\n                me.unlinkRecord(me);\n                me.unlinkRecord(me.defaultCalendar);\n                me.trigger('recordsUnlinked');\n                oldReplica.clear();\n            }\n            else {\n                me.trigger('recordsUnlinked');\n            }\n            const replica = me.replica = me.createReplica();\n            // Now enter all new and old reused records into the new replica\n            replica.addEntity(me);\n            replica.addEntity(me.defaultCalendar);\n            me.joinStoreRecords(calendarManagerStore, true);\n            me.joinStoreRecords(eventStore, true);\n            me.joinStoreRecords(dependencyStore, true);\n            me.joinStoreRecords(resourceStore, true);\n            me.joinStoreRecords(assignmentStore, true);\n            me.repopulateStores.clear();\n            me.trigger('repopulateReplica');\n        }\n        // If there is a commit when we are supposed to replace the replica, we hijack that and commit the new replica\n        beforeCommitAsync() {\n            //@ts-ignore\n            if (this.repopulateReplica.isPending && !this.isDelayingCalculation) {\n                //@ts-ignore\n                this.repopulateReplica.now();\n                return this.replica.commitAsync();\n            }\n            return null;\n        }\n        // Unlinks a single record from the graph, writing back identifiers values from the graph to DATA to allow them\n        // to enter another replica\n        unlinkRecord(record) {\n            // Might not have entered replica yet when using delayed calculation\n            if (record?.graph) {\n                const { activeTransaction } = this.replica;\n                const { $ } = record;\n                const keys = Object.keys($);\n                // Write current values to identifier.DATA, to have correct value entering new replica later\n                for (let i = 0; i < keys.length; i++) {\n                    const key = keys[i];\n                    const identifier = $[key];\n                    const entry = activeTransaction.getLatestEntryFor(identifier);\n                    if (entry) {\n                        let value = entry.getValue();\n                        if (value === undefined)\n                            value = entry.proposedValue;\n                        if (value !== undefined) {\n                            identifier.DATA = identifier.field instanceof ModelReferenceField\n                                ? value?.id ?? value\n                                : value;\n                        }\n                    }\n                }\n                // Cut the link, to enable joining another replica\n                record.graph = null;\n            }\n        }\n        // Unlinks all records from a store, unless the store has been repopulated\n        unlinkStoreRecords(...stores) {\n            stores.forEach(store => {\n                // Unlink records only in stores that are not repopulated\n                // or if store has syncDataOnLoad (in this case records stay in the store so need to unlink them)\n                if (!this.repopulateStores.has(store) || store.syncDataOnLoad) {\n                    store.traverse((record) => {\n                        this.unlinkRecord(record);\n                    }, false, false, {\n                        // Must pass includeFilteredOutRecords and includeCollapsedGroupRecords as true\n                        // so that we work on full, unfiltered dataset\n                        includeFilteredOutRecords: true,\n                        includeCollapsedGroupRecords: true\n                    });\n                }\n            });\n        }\n        //endregion\n        getGraph() {\n            return this.replica;\n        }\n        // keep this private\n        async addEvents(events) {\n            this.eventStore.add(events);\n            return this.commitAsync();\n        }\n        // keep this private\n        async addEvent(event) {\n            this.eventStore.add(event);\n            return this.commitAsync();\n        }\n        // keep this private\n        includeEvent(event) {\n            this.eventStore.add(event);\n        }\n        // keep this private\n        async removeEvents(events) {\n            this.eventStore.remove(events);\n            return this.commitAsync();\n        }\n        // keep this private\n        excludeEvent(event) {\n            this.eventStore.remove(event);\n        }\n        // keep this private\n        async removeEvent(event) {\n            this.eventStore.remove(event);\n            return this.commitAsync();\n        }\n        getStm() {\n            return this.stm;\n        }\n        setStm(stm) {\n            this.stm = stm;\n            this.stm.ion({\n                restoringStart: this.onSTMRestoringStart,\n                restoringStop: this.onSTMRestoringStop,\n                thisObj: this\n            });\n        }\n        calculateProject() {\n            return this;\n        }\n        *calculateEffectiveCalendar() {\n            let calendar = yield this.$.calendar;\n            if (calendar) {\n                // this will create an incoming edge from the calendar's version atom, which changes on calendar's data update\n                yield calendar.$.version;\n            }\n            else {\n                calendar = this.defaultCalendar;\n            }\n            return calendar;\n        }\n        joinStoreRecords(store, skipRoot = false) {\n            const fn = (record) => {\n                record.setProject(this);\n                record.joinProject();\n            };\n            // Both iteration methods must pass includeFilteredOutRecords as true\n            // so that we work on full, unfiltered dataset\n            if (store.rootNode) {\n                store.rootNode.traverse(fn, skipRoot, true);\n            }\n            else {\n                store.forEach(fn, null, {\n                    includeFilteredOutRecords: true,\n                    includeCollapsedGroupRecords: true\n                });\n            }\n        }\n        unjoinStoreRecords(store) {\n            const fn = (record) => {\n                record.leaveProject();\n                record.setProject(this);\n            };\n            // Both iteration methods must pass includeFilteredOutRecords as true\n            // so that we work on full, unfiltered dataset\n            if (store.rootNode) {\n                store.rootNode.traverse(node => {\n                    // do not unjoin/leave project for the root node, which is the project itself\n                    if (node !== store.rootNode)\n                        fn(node);\n                }, false, true);\n            }\n            else {\n                store.forEach(fn, null, {\n                    includeFilteredOutRecords: true,\n                    includeCollapsedGroupRecords: true\n                });\n            }\n        }\n        /**\n         * This method sets the event store instance for the project.\n         * @param store\n         */\n        setEventStore(store) {\n            const oldEventStore = this.eventStore;\n            if (oldEventStore && this.stm.hasStore(oldEventStore)) {\n                this.stm.removeStore(oldEventStore);\n                this.unjoinStoreRecords(oldEventStore);\n                this.detachStore(oldEventStore);\n                const assignmentsForRemoval = oldEventStore.assignmentsForRemoval;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldEvent = assignment.event;\n                    if (oldEvent) {\n                        const newEvent = store.getById(oldEvent.id);\n                        if (newEvent) {\n                            assignment.event = newEvent;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldEventStore.afterEventRemoval();\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.eventStoreClass;\n                this.eventStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.eventModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.eventStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                // we've been given an event store from the outside\n                // need to change its root node to be the project\n                if (store.tree && store.rootNode !== this) {\n                    this.appendChild(store.rootNode.children || []);\n                    // Assigning a new root will make all children join store\n                    store.rootNode = this;\n                }\n                // <remove-on-release>\n                // TODO: Not sure about this, was always performed previously\n                // </remove-on-release>\n                else {\n                    this.joinStoreRecords(store);\n                }\n            }\n            this.attachStore(this.eventStore);\n            this.trigger('eventStoreChange', { store: this.eventStore });\n        }\n        /**\n         * This method sets the dependency store instance for the project.\n         * @param store\n         */\n        setDependencyStore(store) {\n            const oldDependencyStore = this.dependencyStore;\n            if (oldDependencyStore && this.stm.hasStore(oldDependencyStore)) {\n                this.stm.removeStore(oldDependencyStore);\n                this.detachStore(oldDependencyStore);\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.dependencyStoreClass;\n                this.dependencyStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.dependencyModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.dependencyStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                this.joinStoreRecords(store);\n            }\n            this.attachStore(this.dependencyStore);\n            this.trigger('dependencyStoreChange', { store: this.dependencyStore });\n        }\n        /**\n         * This method sets the resource store instance for the project.\n         * @param store\n         */\n        setResourceStore(store) {\n            const oldResourceStore = this.resourceStore;\n            if (oldResourceStore && this.stm.hasStore(oldResourceStore)) {\n                this.stm.removeStore(oldResourceStore);\n                this.unjoinStoreRecords(oldResourceStore);\n                this.detachStore(oldResourceStore);\n                const assignmentsForRemoval = oldResourceStore.assignmentsForRemoval;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldResource = assignment.resource;\n                    if (oldResource) {\n                        const newResource = store.getById(oldResource.id);\n                        if (newResource) {\n                            assignment.resource = newResource;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldResourceStore.afterResourceRemoval();\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.resourceStoreClass;\n                this.resourceStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.resourceModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.resourceStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                this.joinStoreRecords(store);\n            }\n            this.attachStore(this.resourceStore);\n            this.trigger('resourceStoreChange', { store: this.resourceStore });\n        }\n        /**\n         * This method sets the assignment store instance for the project.\n         * @param store\n         */\n        setAssignmentStore(store) {\n            const oldAssignmentStore = this.assignmentStore;\n            if (oldAssignmentStore && this.stm.hasStore(oldAssignmentStore)) {\n                this.stm.removeStore(oldAssignmentStore);\n                this.unjoinStoreRecords(oldAssignmentStore);\n                this.detachStore(oldAssignmentStore);\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.assignmentStoreClass;\n                this.assignmentStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.assignmentModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.assignmentStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                this.joinStoreRecords(store);\n            }\n            this.isDelayingCalculation && this.setupTemporaryIndices();\n            this.attachStore(this.assignmentStore);\n            this.trigger('assignmentStoreChange', { store: this.assignmentStore });\n        }\n        /**\n         * This method sets the calendar manager store instance for the project.\n         * @param store\n         */\n        setCalendarManagerStore(store) {\n            const oldCalendarManagerStore = this.calendarManagerStore;\n            if (oldCalendarManagerStore && this.stm.hasStore(oldCalendarManagerStore)) {\n                this.stm.removeStore(oldCalendarManagerStore);\n                this.detachStore(oldCalendarManagerStore);\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.calendarManagerStoreClass;\n                this.calendarManagerStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.calendarModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.calendarManagerStore = store;\n                if (store) {\n                    store.setProject(this);\n                    this.stm.addStore(store);\n                    this.joinStoreRecords(store);\n                }\n            }\n            this.attachStore(this.calendarManagerStore);\n            this.trigger('calendarManagerStoreChange', { store: this.calendarManagerStore });\n        }\n        // this does not account for possible scheduling conflicts\n        async isValidDependency(...args) {\n            return true;\n        }\n        rejectStmTransaction(stm) {\n            stm = stm || this.stm;\n            if (stm.transaction) {\n                if (stm.transaction.length) {\n                    stm.forEachStore(s => s.beginBatch());\n                    stm.rejectTransaction();\n                    stm.forEachStore(s => s.endBatch());\n                }\n                else {\n                    stm.stopTransaction();\n                }\n            }\n        }\n        async tryPropagateWithChanges(changerFn) {\n            const stm = this.stm, \n            // remember STM initial settings\n            stmInitiallyDisabled = stm.disabled, stmInitiallyAutoRecord = stm.autoRecord;\n            // if STM is disabled we turn it on so we could revert changes later\n            if (stmInitiallyDisabled) {\n                stm.enable();\n            }\n            // if it's enabled\n            else {\n                // if auto-recording is enabled - disable it\n                if (stmInitiallyAutoRecord) {\n                    stm.autoRecord = false;\n                }\n                // stop the current transaction to not mess it\n                if (stm.isRecording) {\n                    stm.stopTransaction();\n                }\n            }\n            // start a new transaction\n            stm.startTransaction();\n            // In case anything in, or called by the changerFn attempts to propagate.\n            // We must only propagate after the changes have been made.\n            // this.suspendPropagate()\n            changerFn();\n            // Resume propagation, but do *not* propagate if any propagate calls were attempted during suspension.\n            // this.resumePropagate(false)\n            let result = true;\n            try {\n                const commitResult = await this.commitAsync();\n                // setting \"result\" to false if the propagation was rejected\n                result = !commitResult.rejectedWith;\n            }\n            catch (e) {\n                // rethrow non-cycle exception\n                if (!/cycle/i.test(e))\n                    throw e;\n                result = false;\n            }\n            // if the transaction succeed\n            if (result) {\n                stm.stopTransaction();\n                // if STM is not used - reset its queue\n                if (stmInitiallyDisabled) {\n                    stm.resetQueue();\n                }\n            }\n            // reject the failed transaction changes\n            else {\n                this.replica.reject();\n                this.rejectStmTransaction(stm);\n            }\n            // restore STM settings\n            stm.disabled = stmInitiallyDisabled;\n            stm.autoRecord = stmInitiallyAutoRecord;\n            return result;\n        }\n        isEngineReady() {\n            const { replica } = this;\n            return this.delayEnteringReplica\n                || (!this.isRepopulatingStores\n                    && (replica\n                        ? !(replica.dirty && (replica.hasPendingAutoCommit() || replica.isCommitting))\n                        : true));\n        }\n        // Needed to separate configs from data, for tests to pass. Normally handled in ProjectModel outside of engine\n        static get defaultConfig() {\n            return {\n                assignmentsData: null,\n                calendarsData: null,\n                dependenciesData: null,\n                eventsData: null,\n                resourcesData: null,\n                // need to distinguish the stores from fields\n                // https://bryntum.com/products/gantt/examples/advanced/\n                // bryntum.gantt.ObjectHelper.isEqual({}, new bryntum.gantt.Store()) // true\n                eventStore: null,\n                resourceStore: null,\n                assignmentStore: null,\n                dependencyStore: null,\n                calendarManagerStore: null,\n                eventModelClass: null,\n                resourceModelClass: null,\n                assignmentModelClass: null,\n                dependencyModelClass: null,\n                calendarModelClass: null,\n                repopulateOnDataset: true\n            };\n        }\n        static get delayable() {\n            return {\n                repopulateReplica: 10\n            };\n        }\n    }\n    SchedulerBasicProjectMixin.applyConfigs = true;\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerBasicProjectMixin.prototype, \"unspecifiedTimeIsWorking\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: false })\n    ], SchedulerBasicProjectMixin.prototype, \"skipNonWorkingTimeWhenSchedulingManually\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerBasicProjectMixin.prototype, \"skipNonWorkingTimeInDurationWhenSchedulingManually\", void 0);\n    return SchedulerBasicProjectMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Reject } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { calculate, field } from '../../../../ChronoGraph/replica/Entity.js';\nimport { ConflictEffect, ConstraintInterval } from \"../../../chrono/Conflict.js\";\nimport { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { intersectIntervals } from '../../../scheduling/DateInterval.js';\nimport { Direction, ConstraintIntervalSide } from '../../../scheduling/Types.js';\nimport { isDateFinite, MAX_DATE, MIN_DATE } from \"../../../util/Constants.js\";\nimport { HasSubEventsMixin } from \"../scheduler_basic/HasSubEventsMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const calculateEffectiveStartDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration, collectIntersectionMeta) {\n    if (endDateIntervalIntersection.isIntervalEmpty())\n        return endDateIntervalIntersection; //EMPTY_INTERVAL\n    // If intersection details collecting is enabled (need this when preparing a scheduling conflict info)\n    if (collectIntersectionMeta && endDateIntervalIntersection.intersectionOf) {\n        const reflectedIntervals = new Set();\n        // Iterate over the intervals that took part in \"endDateIntervalIntersection\" building\n        // and reflect each of them to task \"End\" side.\n        // So we could compare each interval one by one.\n        for (const interval of endDateIntervalIntersection.intersectionOf) {\n            if (interval.isInfinite()) {\n                reflectedIntervals.add(interval);\n            }\n            else {\n                const startDate = interval.startDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.startDate, false, duration)\n                    :\n                        interval.startDate;\n                const endDate = interval.endDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.endDate, false, duration)\n                    :\n                        interval.endDate;\n                const originInterval = interval;\n                reflectedIntervals.add(originInterval.copyWith({\n                    reflectionOf: originInterval,\n                    side: originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,\n                    startDate,\n                    endDate,\n                }));\n            }\n        }\n        // override intersectionOf with reflected intervals\n        endDateIntervalIntersection.intersectionOf = reflectedIntervals;\n    }\n    const startDate = endDateIntervalIntersection.startDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.startDate, false, duration)\n        :\n            null;\n    const endDate = endDateIntervalIntersection.endDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.endDate, false, duration)\n        :\n            null;\n    return intersectIntervals([\n        startDateIntervalIntersection,\n        ConstraintInterval.new({\n            intersectionOf: endDateIntervalIntersection.intersectionOf,\n            startDate,\n            endDate\n        })\n    ], collectIntersectionMeta);\n};\nexport const calculateEffectiveEndDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration, collectIntersectionMeta) {\n    if (startDateIntervalIntersection.isIntervalEmpty())\n        return startDateIntervalIntersection; //EMPTY_INTERVAL\n    // If intersection details collecting is enabled (need this when preparing a scheduling conflict info)\n    if (collectIntersectionMeta) {\n        const reflectedIntervals = new Set();\n        // Iterate over the intervals that took part in \"startDateIntervalIntersection\" building\n        // and reflect each of them to task \"End\" side.\n        // So we could compare each interval one by one.\n        for (const interval of startDateIntervalIntersection.intersectionOf) {\n            // no need to reflect infinite intervals\n            if (interval.isInfinite()) {\n                reflectedIntervals.add(interval);\n            }\n            // reflect finite interval\n            else {\n                const startDate = interval.startDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.startDate, true, duration)\n                    :\n                        interval.startDate;\n                const endDate = interval.endDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.endDate, true, duration)\n                    :\n                        interval.endDate;\n                const originInterval = interval;\n                // Make a reflection of the interval\n                reflectedIntervals.add(originInterval.copyWith({\n                    reflectionOf: originInterval,\n                    side: originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,\n                    startDate,\n                    endDate,\n                }));\n            }\n        }\n        // override intersectionOf with reflected intervals\n        startDateIntervalIntersection.intersectionOf = reflectedIntervals;\n    }\n    const startDate = startDateIntervalIntersection.startDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.startDate, true, duration)\n        :\n            null;\n    const endDate = startDateIntervalIntersection.endDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.endDate, true, duration)\n        :\n            null;\n    return intersectIntervals([\n        endDateIntervalIntersection,\n        ConstraintInterval.new({\n            reflectionOf: startDate || endDate ? startDateIntervalIntersection : undefined,\n            intersectionOf: startDate || endDate ? startDateIntervalIntersection.intersectionOf : undefined,\n            startDate,\n            endDate\n        }),\n    ], collectIntersectionMeta);\n};\nexport const EarlyLateLazyness = true;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin provides the constraint-based scheduling. Event is scheduled according to the set of _constraints_\n * which can be applied to start date or end date.\n *\n * Scheduling by constraints for an event can be disabled by setting its [[manuallyScheduled]] flag to `true`, which will delegate to previous behavior.\n *\n * The constraint is represented with the [[DateInterval]] class, which indicates the \"allowed\" interval for the\n * point being constrained.\n *\n * Scheduling by constraints algorithm\n * ---------------------------------\n *\n * Constraints for start date are accumulated in the [[earlyStartDateConstraintIntervals]] and [[startDateConstraintIntervals]] fields.\n * Constraints for end date are accumulated in the [[earlyEndDateConstraintIntervals]] and [[endDateConstraintIntervals]] fields.\n *\n * This mixin does not define where the constraints for the event comes from. The constraints are calculated in the field\n * calculation methods, (like [[calculateEarlyStartDateConstraintIntervals]]) which just return empty arrays. Some other mixins\n * may override those methods and can generate actual constraints (the [[ScheduledByDependenciesEarlyEventMixin]] is an example).\n\n * The \"early\" fields contains the constraints which are related to scheduling event in the as-soon-as-possible manner.\n * The fields w/o \"early\" prefix contains the constraints which do not related to the ASAP scheduling.\n *\n * \"Early\" and \"normal\" constraints for every date are combined, then intersected, which gives \"combined\" constraining interval.\n *\n * So at this point we have a \"combined\" constraining interval for start date and for end date.\n *\n * Then, the interval for start date is shifted on the event duration to the right and this gives an additional constraint for the\n * end date. The similar operation is done with the interval for the end date.\n *\n * After intersection with those additional intervals we receive the final constraining interval for both dates. Since we\n * are using the ASAP scheduling, we just pick the earliest possible date.\n *\n * If any of intervals is empty then we consider it as scheduling conflict, and [[EngineReplica.reject|reject]] the transaction.\n *\n */\nexport class ConstrainedEarlyEventMixin extends Mixin([HasSubEventsMixin], (base) => {\n    const superProto = base.prototype;\n    class ConstrainedEarlyEventMixin extends base {\n        // Skips non-working time if it's needed to the event\n        *maybeSkipNonWorkingTime(date, isForward = true) {\n            // We don't really need to skip non-working time for a summary task start/end dates.\n            // It just reflects corresponding min/max values of its children\n            if (yield* this.hasSubEvents())\n                return date;\n            let duration = yield* this.calculateEffectiveDuration();\n            return date && duration > 0 ? yield* this.skipNonWorkingTime(date, isForward) : date;\n        }\n        *calculateEffectiveConstraintInterval(isStartDate, startDateConstraintIntervals, endDateConstraintIntervals, collectIntersectionMeta = false) {\n            const effectiveDurationToUse = yield* this.calculateEffectiveDuration();\n            if (effectiveDurationToUse == null) {\n                return null;\n            }\n            const calculateIntervalFn = (isStartDate ? calculateEffectiveStartDateConstraintInterval : calculateEffectiveEndDateConstraintInterval);\n            const effectiveInterval = yield* calculateIntervalFn(this, intersectIntervals(startDateConstraintIntervals, collectIntersectionMeta), intersectIntervals(endDateConstraintIntervals, collectIntersectionMeta), effectiveDurationToUse, collectIntersectionMeta);\n            return effectiveInterval;\n        }\n        /**\n         * Calculation method for the [[startDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the start date.\n         */\n        *calculateStartDateConstraintIntervals() {\n            return [];\n        }\n        /**\n         * Calculation method for the [[endDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the end date.\n         */\n        *calculateEndDateConstraintIntervals() {\n            return [];\n        }\n        /**\n         * Calculation method for the [[earlyStartDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the start date during the ASAP scheduling.\n         */\n        *calculateEarlyStartDateConstraintIntervals() {\n            return [];\n        }\n        /**\n         * Calculation method for the [[earlyEndDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the end date during the ASAP scheduling.\n         */\n        *calculateEarlyEndDateConstraintIntervals() {\n            return [];\n        }\n        *doCalculateEarlyEffectiveStartDateInterval(collectIntersectionMeta = false) {\n            const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;\n            const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;\n            return yield* this.calculateEffectiveConstraintInterval(true, \n            // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is\n            // used as storage for `this.$.earlyStartDateConstraintIntervals`\n            startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals), collectIntersectionMeta);\n        }\n        *calculateEarlyEffectiveStartDateInterval() {\n            return yield* this.doCalculateEarlyEffectiveStartDateInterval();\n        }\n        *doCalculateEarlyEffectiveEndDateInterval(collectIntersectionMeta = false) {\n            const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;\n            const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;\n            return yield* this.calculateEffectiveConstraintInterval(false, \n            // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is\n            // used as storage for `this.$.earlyStartDateConstraintIntervals`\n            startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals), collectIntersectionMeta);\n        }\n        *calculateEarlyEffectiveEndDateInterval() {\n            return yield* this.doCalculateEarlyEffectiveEndDateInterval();\n        }\n        /**\n         * The method defines whether the provided child event should be\n         * taken into account when calculating this summary event [[earlyStartDate]].\n         * Child events roll up their [[earlyStartDate]] values to their summary tasks.\n         * So a summary task [[earlyStartDate]] date gets equal to its minimal child [[earlyStartDate]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default, the method returns `true` to include all child events data.\n         * @param child Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildEarlyStartDate(child) {\n            return true;\n        }\n        *calculateMinChildrenEarlyStartDate() {\n            let result = MAX_DATE;\n            const subEventsIterator = yield* this.subEventsIterable();\n            for (let childEvent of subEventsIterator) {\n                let childDate;\n                if (!(yield* this.shouldRollupChildEarlyStartDate(childEvent)))\n                    continue;\n                if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {\n                    childDate = yield childEvent.$.minChildrenEarlyStartDate;\n                }\n                childDate = childDate || (yield childEvent.$.earlyStartDate);\n                if (childDate && childDate < result)\n                    result = childDate;\n            }\n            return result.getTime() - MAX_DATE.getTime() ? result : null;\n        }\n        /**\n         * The method defines whether the provided child event should be\n         * taken into account when calculating this summary event [[earlyEndDate]].\n         * Child events roll up their [[earlyEndDate]] values to their summary tasks.\n         * So a summary task [[earlyEndDate]] gets equal to its maximal child [[earlyEndDate]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default, the method returns `true` to include all child events data.\n         * @param child Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildEarlyEndDate(child) {\n            return true;\n        }\n        *calculateMaxChildrenEarlyEndDate() {\n            let result = MIN_DATE;\n            const subEventsIterator = yield* this.subEventsIterable();\n            for (let childEvent of subEventsIterator) {\n                let childDate;\n                if (!(yield* this.shouldRollupChildEarlyEndDate(childEvent)))\n                    continue;\n                if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {\n                    childDate = yield childEvent.$.maxChildrenEarlyEndDate;\n                }\n                childDate = childDate || (yield childEvent.$.earlyEndDate);\n                if (childDate && childDate > result)\n                    result = childDate;\n            }\n            return result.getTime() - MIN_DATE.getTime() ? result : null;\n        }\n        *calculateEarlyStartDateRaw() {\n            // Manually scheduled task treat its current start date as its early start date\n            // in case of forward scheduling.\n            // Late dates in that case are calculated the same way it happens for automatic tasks\n            if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === Direction.Forward) {\n                return yield this.$.startDate;\n            }\n            // Parent task calculate its early start date as minimal early start date of its children\n            if (yield* this.hasSubEvents()) {\n                return yield this.$.minChildrenEarlyStartDate;\n            }\n            if (!(yield* this.isConstrainedEarly())) {\n                return yield this.$.startDate;\n            }\n            let effectiveInterval = yield this.$.earlyEffectiveStartDateInterval;\n            if (effectiveInterval === null) {\n                return null;\n            }\n            else if (effectiveInterval.isIntervalEmpty()) {\n                // re-calculate effective resulting interval gathering intersection history\n                effectiveInterval = yield* this.doCalculateEarlyEffectiveStartDateInterval(true);\n                const conflict = ConflictEffect.new({\n                    intervals: [...effectiveInterval.intersectionOf]\n                });\n                if ((yield conflict) === EffectResolutionResult.Cancel) {\n                    yield Reject(conflict);\n                }\n                else {\n                    return null;\n                }\n            }\n            return isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null;\n        }\n        *calculateEarlyStartDate() {\n            const date = yield this.$.earlyStartDateRaw;\n            return yield* this.maybeSkipNonWorkingTime(date, true);\n        }\n        *calculateEarlyEndDateRaw() {\n            // Manually scheduled task treat its current end date as its early end date\n            // in case of forward scheduling.\n            // Late dates in that case are calculated the same way it happens for automatic tasks\n            if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === Direction.Forward) {\n                return yield this.$.endDate;\n            }\n            // Parent task calculate its early end date as maximum early end date of its children\n            if (yield* this.hasSubEvents()) {\n                return yield this.$.maxChildrenEarlyEndDate;\n            }\n            if (!(yield* this.isConstrainedEarly())) {\n                return yield this.$.endDate;\n            }\n            let effectiveInterval = yield this.$.earlyEffectiveEndDateInterval;\n            if (effectiveInterval === null) {\n                return null;\n            }\n            else if (effectiveInterval.isIntervalEmpty()) {\n                // re-calculate effective resulting interval gathering intersection history\n                effectiveInterval = yield* this.doCalculateEarlyEffectiveEndDateInterval(true);\n                const conflict = ConflictEffect.new({\n                    intervals: [...effectiveInterval.intersectionOf]\n                });\n                if ((yield conflict) === EffectResolutionResult.Cancel) {\n                    yield Reject(conflict);\n                }\n                else {\n                    return null;\n                }\n            }\n            return isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null;\n        }\n        *calculateEarlyEndDate() {\n            return yield this.$.earlyEndDateRaw;\n        }\n        *isConstrainedEarly() {\n            const startDateIntervals = yield this.$.startDateConstraintIntervals;\n            const endDateIntervals = yield this.$.endDateConstraintIntervals;\n            const earlyStartDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;\n            const earlyEndDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;\n            return Boolean(startDateIntervals?.length || endDateIntervals?.length || earlyStartDateConstraintIntervals?.length || earlyEndDateConstraintIntervals?.length);\n        }\n        *calculateStartDatePure() {\n            const direction = yield this.$.direction;\n            if (direction === Direction.Forward) {\n                // early exit if this mixin is not applicable, but only after(!) the direction check\n                // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                // depending on the direction\n                if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                    return yield* superProto.calculateStartDatePure.call(this);\n                }\n                return (yield this.$.earlyStartDate) || (yield* superProto.calculateStartDatePure.call(this));\n            }\n            else {\n                return yield* superProto.calculateStartDatePure.call(this);\n            }\n        }\n        *calculateStartDateProposed() {\n            const direction = yield this.$.direction;\n            switch (direction) {\n                case Direction.Forward:\n                    // early exit if this mixin is not applicable, but only after(!) the direction check\n                    // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                    // depending on the direction\n                    if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                        return yield* superProto.calculateStartDateProposed.call(this);\n                    }\n                    const autoStartDate = yield this.$.earlyStartDate;\n                    if (autoStartDate) {\n                        if (isDateFinite(autoStartDate))\n                            return autoStartDate;\n                        const baseSchedulingStartDate = yield* superProto.calculateStartDateProposed.call(this);\n                        const earlyEffectiveStartDateInterval = yield this.$.earlyEffectiveStartDateInterval;\n                        if (earlyEffectiveStartDateInterval.containsDate(baseSchedulingStartDate))\n                            return baseSchedulingStartDate;\n                        return isDateFinite(earlyEffectiveStartDateInterval.endDate) ? earlyEffectiveStartDateInterval.endDate : baseSchedulingStartDate;\n                    }\n                    else {\n                        return yield* superProto.calculateStartDateProposed.call(this);\n                    }\n                default:\n                    return yield* superProto.calculateStartDateProposed.call(this);\n            }\n        }\n        *calculateEndDatePure() {\n            const direction = yield this.$.direction;\n            if (direction === Direction.Forward) {\n                // early exit if this mixin is not applicable, but only after(!) the direction check\n                // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                // depending on the direction\n                if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                    return yield* superProto.calculateEndDatePure.call(this);\n                }\n                return (yield this.$.earlyEndDate) || (yield* superProto.calculateEndDatePure.call(this));\n            }\n            else {\n                return yield* superProto.calculateEndDatePure.call(this);\n            }\n        }\n        *calculateEndDateProposed() {\n            const direction = yield this.$.direction;\n            switch (direction) {\n                case Direction.Forward:\n                    // early exit if this mixin is not applicable, but only after(!) the direction check\n                    // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                    // depending on the direction\n                    if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                        return yield* superProto.calculateEndDateProposed.call(this);\n                    }\n                    const autoEndDate = yield this.$.earlyEndDate;\n                    if (autoEndDate) {\n                        if (isDateFinite(autoEndDate))\n                            return autoEndDate;\n                        const baseSchedulingEndDate = yield* superProto.calculateEndDateProposed.call(this);\n                        const earlyEffectiveEndDateInterval = yield this.$.earlyEffectiveEndDateInterval;\n                        if (earlyEffectiveEndDateInterval.containsDate(baseSchedulingEndDate))\n                            return baseSchedulingEndDate;\n                        return isDateFinite(earlyEffectiveEndDateInterval.endDate) ? earlyEffectiveEndDateInterval.endDate : baseSchedulingEndDate;\n                    }\n                    else {\n                        return yield* superProto.calculateEndDateProposed.call(this);\n                    }\n                default:\n                    return yield* superProto.calculateEndDateProposed.call(this);\n            }\n        }\n        *calculateDirection() {\n            const project = this.getProject();\n            return yield project.$.direction;\n        }\n    }\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"minChildrenEarlyStartDate\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyStartDateRaw\", void 0);\n    __decorate([\n        model_field({ type: 'date', persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyStartDate\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"maxChildrenEarlyEndDate\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEndDateRaw\", void 0);\n    __decorate([\n        model_field({ type: 'date', persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEndDate\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"startDateConstraintIntervals\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"endDateConstraintIntervals\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyStartDateConstraintIntervals\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEndDateConstraintIntervals\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEffectiveStartDateInterval\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEffectiveEndDateInterval\", void 0);\n    __decorate([\n        calculate('startDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateStartDateConstraintIntervals\", null);\n    __decorate([\n        calculate('endDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEndDateConstraintIntervals\", null);\n    __decorate([\n        calculate('earlyStartDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyStartDateConstraintIntervals\", null);\n    __decorate([\n        calculate('earlyEndDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEndDateConstraintIntervals\", null);\n    __decorate([\n        calculate('earlyEffectiveStartDateInterval')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEffectiveStartDateInterval\", null);\n    __decorate([\n        calculate('earlyEffectiveEndDateInterval')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEffectiveEndDateInterval\", null);\n    __decorate([\n        calculate('minChildrenEarlyStartDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateMinChildrenEarlyStartDate\", null);\n    __decorate([\n        calculate('maxChildrenEarlyEndDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateMaxChildrenEarlyEndDate\", null);\n    __decorate([\n        calculate('earlyStartDateRaw')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyStartDateRaw\", null);\n    __decorate([\n        calculate('earlyStartDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyStartDate\", null);\n    __decorate([\n        calculate('earlyEndDateRaw')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEndDateRaw\", null);\n    __decorate([\n        calculate('earlyEndDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEndDate\", null);\n    __decorate([\n        calculate('direction')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateDirection\", null);\n    return ConstrainedEarlyEventMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious, ProposedOrPreviousValueOf } from '../../../../ChronoGraph/chrono/Effect.js';\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { calculate } from '../../../../ChronoGraph/replica/Entity.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Localizable from '../../../../Core/localization/Localizable.js';\nimport { ConflictResolution, ConstraintInterval, ConstraintIntervalDescription } from '../../../chrono/Conflict.js';\nimport { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { ConstraintIntervalSide, ConstraintType, Direction } from '../../../scheduling/Types.js';\nimport { format } from '../../../util/Functions.js';\nimport { HasChildrenMixin } from '../scheduler_basic/HasChildrenMixin.js';\nimport { ConstrainedEarlyEventMixin } from './ConstrainedEarlyEventMixin.js';\nimport \"../../../localization/En.js\";\nimport { prototypeValue } from '../../../../ChronoGraph/util/Helpers.js';\n/**\n * This mixin implements a date-based based constraint for the event.\n * It provides the following constraint types:\n *\n * - _Start no earlier than (SNET)_ - restricts the event to start on or after the specified date.\n * - _Finish no earlier than (FNET)_ - restricts the event to finish on or after the specified date.\n * - _Start no later than (SNLT)_ - restricts the event to start before (or on) the specified date.\n * - _Finish no later than (FNLT)_ - restricts the event to finish before (or on) the specified date.\n * - _Must start on (MSO)_ - restricts the event to start on the specified date.\n * - _Must finish on (MFO)_ - restricts the event to finish on the specified date.\n *\n * The type of constraint is defined by the [[constraintType]] property. Types has self-descriptive names.\n * There's also [[constraintDate]] with a constraint date.\n *\n * **Please note** that [[manuallyScheduled|manually scheduled]] events ignore their constraints.\n */\nexport class HasDateConstraintMixin extends Mixin([ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class HasDateConstraint extends base {\n        constructor() {\n            super(...arguments);\n            // This flag allows to ignore setting pinning constraint when writing start date\n            this.ignorePinningConstraint = false;\n        }\n        writeStartDate(me, transaction, quark, date, keepDuration = true) {\n            // get constraint type that should be used to enforce start date or\n            // null if the change cannot be enforced (happens when the task is manually scheduled so no need for enforcement or\n            // some constraint is already set)\n            const project = this.getProject();\n            // `writeStartDate` will be called for initial write to the `startDate` at the point of adding it to graph\n            // at that time there possibly be no `direction` identifier yet\n            // it seems this line relies on the fact, that `direction` field is declared after the `startDate`\n            if (project?.addConstraintOnDateSet\n                && transaction.graph.hasIdentifier(this.$.direction)\n                && !project?.eventStore.isSyncingDataOnLoad\n                && !this.isReverting\n                && !project?.getStm().isRestoring) {\n                const constrainType = this.getStartDatePinConstraintType();\n                if (constrainType) {\n                    this.constraintType = constrainType;\n                    this.constraintDate = date;\n                }\n            }\n            return superProto.writeStartDate.call(this, me, transaction, quark, date, keepDuration);\n        }\n        writeEndDate(me, transaction, quark, date, keepDuration = false) {\n            // get constraint type that should be used to enforce End date or\n            // null if the change cannot be enforced (happens when the task is manually scheduled so no need for enforcement or\n            // some constraint is already set)\n            const project = this.getProject();\n            if (project?.addConstraintOnDateSet\n                && transaction.graph.hasIdentifier(this.$.direction)\n                && keepDuration\n                && !project?.eventStore.isSyncingDataOnLoad\n                && !project?.getStm().isRestoring) {\n                const constrainType = this.getEndDatePinConstraintType();\n                if (constrainType) {\n                    this.constraintType = constrainType;\n                    this.constraintDate = date;\n                }\n            }\n            return superProto.writeEndDate.call(this, me, transaction, quark, date, keepDuration);\n        }\n        *calculateConstraintType() {\n            let constraintType = yield ProposedOrPrevious;\n            // use proposed constraint type if provided and is applicable to the event\n            if (!(yield* this.isConstraintTypeApplicable(constraintType))) {\n                constraintType = null;\n            }\n            return constraintType;\n        }\n        *calculateConstraintDate(Y) {\n            let constraintDate = yield ProposedOrPrevious;\n            const constraintType = yield this.$.constraintType;\n            if (!constraintType) {\n                constraintDate = null;\n            }\n            // use proposed constraint date if provided\n            else if (!constraintDate) {\n                // fill constraint date based on constraint type provided\n                constraintDate = this.getConstraintTypeDefaultDate(Y, constraintType);\n            }\n            return constraintDate;\n        }\n        getStartDatePinConstraintType() {\n            const { direction } = this;\n            if (!this.isTaskPinnableWithConstraint())\n                return null;\n            switch (direction) {\n                case Direction.Forward: return ConstraintType.StartNoEarlierThan;\n                case Direction.Backward: return ConstraintType.StartNoLaterThan;\n            }\n        }\n        getEndDatePinConstraintType() {\n            const { direction } = this;\n            if (!this.isTaskPinnableWithConstraint())\n                return null;\n            switch (direction) {\n                case Direction.Forward: return ConstraintType.FinishNoEarlierThan;\n                case Direction.Backward: return ConstraintType.FinishNoLaterThan;\n            }\n        }\n        /**\n         * Indicates if the task can be pinned with a constraint\n         * to enforce its start/end date changes.\n         * @private\n         */\n        isTaskPinnableWithConstraint() {\n            const { manuallyScheduled, ignorePinningConstraint, constraintType } = this;\n            let result = false;\n            // we should not pin manually scheduled tasks\n            if (!manuallyScheduled && !ignorePinningConstraint) {\n                if (constraintType) {\n                    switch (constraintType) {\n                        case ConstraintType.StartNoEarlierThan:\n                        case ConstraintType.StartNoLaterThan:\n                        case ConstraintType.FinishNoEarlierThan:\n                        case ConstraintType.FinishNoLaterThan:\n                            result = true;\n                    }\n                }\n                // no constraints -> we can pin\n                else {\n                    result = true;\n                }\n            }\n            return result;\n        }\n        applyChangeset(rawChanges, phantomIdField, remote) {\n            // Raise a flag on the record to avoid engine setting pinning constraint when writing start date. We need to\n            // avoid pinning constraint in case remote dataset only contains start date for the parent record. If local\n            // parent record start date is different, start date will be written to the engine and constraint will be set.\n            // We don't need to do that here, dataset is supposed to complete so parent ends up with the same start date\n            // without unnecessary constraint\n            // https://github.com/bryntum/support/issues/5086\n            this.ignorePinningConstraint = remote;\n            //@ts-ignore\n            const result = super.applyChangeset(rawChanges, phantomIdField, remote);\n            this.ignorePinningConstraint = false;\n            return result;\n        }\n        /**\n         * Returns default constraint date value for the constraint type provided\n         * (either start or end date of the event).\n         */\n        getConstraintTypeDefaultDate(Y, constraintType) {\n            switch (constraintType) {\n                case ConstraintType.StartNoEarlierThan:\n                case ConstraintType.StartNoLaterThan:\n                case ConstraintType.MustStartOn:\n                    return Y(ProposedOrPreviousValueOf(this.$.startDate));\n                case ConstraintType.FinishNoEarlierThan:\n                case ConstraintType.FinishNoLaterThan:\n                case ConstraintType.MustFinishOn:\n                    return Y(ProposedOrPreviousValueOf(this.$.endDate));\n            }\n            return null;\n        }\n        /**\n         * Returns true if the provided constraint type is applicable to the event.\n         *\n         * @param {ConstraintType} constraintType Constraint type.\n         * @returns `True` if the provided constraint type is applicable (`false` otherwise).\n         */\n        *isConstraintTypeApplicable(constraintType) {\n            // Take into account if the event is leaf\n            const hasSubEvents = yield* this.hasSubEvents();\n            switch (constraintType) {\n                // these constraints are applicable to leaves only\n                case ConstraintType.FinishNoEarlierThan:\n                case ConstraintType.StartNoLaterThan:\n                case ConstraintType.MustFinishOn:\n                case ConstraintType.MustStartOn:\n                    return !hasSubEvents;\n            }\n            return true;\n        }\n        /**\n         * Sets the constraint type (if applicable) and constraining date to the task.\n         * @param {ConstraintType}  constraintType   Constraint type.\n         * @param {Date}            [constraintDate] Constraint date.\n         * @returns Promise<PropagateResult>\n         */\n        async setConstraint(constraintType, constraintDate) {\n            this.constraintType = constraintType;\n            if (constraintDate !== undefined) {\n                this.constraintDate = constraintDate;\n            }\n            return this.commitAsync();\n        }\n        *calculateEndDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateEndDateConstraintIntervals.call(this);\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const constraintType = yield this.$.constraintType;\n            const constraintDate = yield this.$.constraintDate;\n            const dateConstraintIntervalClass = this.project.dateConstraintIntervalClass;\n            // manually scheduled task ignores its constraints\n            if (!manuallyScheduled && constraintType && constraintDate) {\n                // if constraint type is\n                switch (constraintType) {\n                    case ConstraintType.MustFinishOn:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.End,\n                            startDate: constraintDate,\n                            endDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.FinishNoEarlierThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.End,\n                            startDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.FinishNoLaterThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.End,\n                            endDate: constraintDate\n                        }));\n                        break;\n                }\n            }\n            return intervals;\n        }\n        *calculateStartDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateStartDateConstraintIntervals.call(this);\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const constraintType = yield this.$.constraintType;\n            const constraintDate = yield this.$.constraintDate;\n            const dateConstraintIntervalClass = this.project.dateConstraintIntervalClass;\n            // manually scheduled task ignores its constraints\n            if (!manuallyScheduled && constraintType && constraintDate) {\n                // if constraint type is\n                switch (constraintType) {\n                    case ConstraintType.MustStartOn:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.Start,\n                            startDate: constraintDate,\n                            endDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.StartNoEarlierThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.Start,\n                            startDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.StartNoLaterThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.Start,\n                            endDate: constraintDate\n                        }));\n                        break;\n                }\n            }\n            return intervals;\n        }\n    }\n    __decorate([\n        model_field({ type: 'string' }, { sync: true })\n    ], HasDateConstraint.prototype, \"constraintType\", void 0);\n    __decorate([\n        model_field({ type: 'date' }, { converter: dateConverter, sync: true })\n    ], HasDateConstraint.prototype, \"constraintDate\", void 0);\n    __decorate([\n        calculate('constraintType')\n    ], HasDateConstraint.prototype, \"calculateConstraintType\", null);\n    __decorate([\n        calculate('constraintDate')\n    ], HasDateConstraint.prototype, \"calculateConstraintDate\", null);\n    return HasDateConstraint;\n}) {\n}\n/**\n * Class implements resolving a scheduling conflict happened due to a task constraint.\n * It resolves the conflict by removing the constraint.\n */\nexport class RemoveDateConstraintConflictResolution extends Localizable(ConflictResolution) {\n    static get $name() {\n        return 'RemoveDateConstraintConflictResolution';\n    }\n    construct() {\n        super.construct(...arguments);\n        this.event = this.interval.owner;\n    }\n    getDescription() {\n        const { event } = this;\n        return format(this.L('L{descriptionTpl}'), event.name || event.id, this.interval.getConstraintName(event.constraintType));\n    }\n    /**\n     * Resolves the conflict by removing the event constraint.\n     */\n    resolve() {\n        this.event.constraintType = null;\n    }\n}\n/**\n * Description builder for an [[DateConstraintInterval|event constraint interval]].\n */\nexport class DateConstraintIntervalDescription extends ConstraintIntervalDescription {\n    static get $name() {\n        return 'DateConstraintIntervalDescription';\n    }\n    /**\n     * Returns description for the provided event constraint interval.\n     * @param interval Constraint interval\n     */\n    static getDescription(interval) {\n        let tpl;\n        switch (interval.owner.constraintType) {\n            case ConstraintType.StartNoEarlierThan:\n            case ConstraintType.FinishNoEarlierThan:\n            case ConstraintType.MustStartOn:\n            case ConstraintType.MustFinishOn:\n                tpl = this.L('L{startDateDescriptionTpl}');\n                break;\n            case ConstraintType.StartNoLaterThan:\n            case ConstraintType.FinishNoLaterThan:\n                tpl = this.L('L{endDateDescriptionTpl}');\n                break;\n        }\n        return format(tpl, ...this.getDescriptionParameters(interval));\n    }\n    /**\n     * Returns localized constraint name.\n     * @param constraintType Type of constraint\n     */\n    static getConstraintName(constraintType) {\n        return this.L('L{constraintTypeTpl}')[constraintType];\n    }\n    static getDescriptionParameters(interval) {\n        const event = interval.owner;\n        return [\n            DateHelper.format(interval.startDate, this.L('L{dateFormat}')),\n            DateHelper.format(interval.endDate, this.L('L{dateFormat}')),\n            event.name || event.id,\n            this.getConstraintName(event.constraintType)\n        ];\n    }\n}\n/**\n * Class implements an interval applied by an event [[constraintType|constraint]].\n * The interval suggests the only resolution option - removing the constraint.\n */\nexport class DateConstraintInterval extends ConstraintInterval {\n    getConstraintName(constraintType) {\n        return this.descriptionBuilderClass.getConstraintName(constraintType || this.owner.constraintType);\n    }\n    getDescription() {\n        return this.descriptionBuilderClass.getDescription(this);\n    }\n    isAffectedByTransaction(transaction) {\n        const event = this.owner;\n        transaction = transaction || event.graph.activeTransaction;\n        const constraintDateQuark = transaction.entries.get(event.$.constraintDate), constraintTypeQuark = transaction.entries.get(event.$.constraintType);\n        // new constrained event or modified constraint\n        return !transaction.baseRevision.hasIdentifier(event.$$) ||\n            constraintDateQuark && !constraintDateQuark.isShadow() ||\n            constraintTypeQuark && !constraintTypeQuark.isShadow();\n    }\n    /**\n     * Returns possible resolution options for cases when\n     * the interval takes part in a conflict.\n     *\n     * The interval suggests the only resolution option - removing the constraint.\n     */\n    getResolutions() {\n        return this.resolutions || (this.resolutions = [\n            this.removeDateConstraintConflictResolutionClass.new({ interval: this })\n        ]);\n    }\n}\n__decorate([\n    prototypeValue(RemoveDateConstraintConflictResolution)\n], DateConstraintInterval.prototype, \"removeDateConstraintConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DateConstraintIntervalDescription)\n], DateConstraintInterval.prototype, \"descriptionBuilderClass\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { isAtomicValue, prototypeValue } from '../../../../ChronoGraph/util/Helpers.js';\nimport { DependencyType, TimeUnit } from '../../../scheduling/Types.js';\nimport { HasDependenciesMixin } from \"../scheduler_basic/HasDependenciesMixin.js\";\nimport { ConstrainedEarlyEventMixin } from './ConstrainedEarlyEventMixin.js';\nimport { ConstraintInterval, ConflictResolution, ConstraintIntervalDescription } from '../../../chrono/Conflict.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport { format } from '../../../util/Functions.js';\nimport Localizable from '../../../../Core/localization/Localizable.js';\nimport \"../../../localization/En.js\";\nimport { model_field } from '../../../chrono/ModelFieldAtom.js';\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin adds support for scheduling event ASAP, by dependencies. All it does is\n * create the constraint interval for every incoming dependency. See [[ConstrainedEarlyEventMixin]] for\n * more details about constraint-based scheduling.\n *\n * The supported dependency types are listed in this enum: [[DependencyType]]\n */\nexport class ScheduledByDependenciesEarlyEventMixin extends Mixin([ConstrainedEarlyEventMixin, HasDependenciesMixin], (base) => {\n    const superProto = base.prototype;\n    class ScheduledByDependenciesEarlyEventMixin extends base {\n        /**\n         * The method defines wether the provided dependency should constrain the successor or not.\n         * If the method returns `true` the dependency constrains the successor and does not do that when `false` returned.\n         * By default the method returns `true` if the dependency is [[SchedulerProDependencyMixin.active|active]]\n         * and if this event is [[inactive|active]] (or both this event and the successor are [[inactive]]).\n         *\n         * This is used when calculating [[earlyStartDateConstraintIntervals]].\n         * @param dependency Dependency to consider.\n         * @returns `true` if the dependency should constrain successor, `false` if not.\n         */\n        *shouldPredecessorAffectScheduling(dependency) {\n            const fromEvent = yield dependency.$.fromEvent;\n            // ignore missing from events and inactive dependencies\n            return fromEvent && !isAtomicValue(fromEvent) && (yield dependency.$.active)\n                // ignore inactive predecessor (unless we both are inactive)\n                && (!(yield fromEvent.$.inactive) || (yield this.$.inactive));\n        }\n        *calculateEarlyStartDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateEarlyStartDateConstraintIntervals.call(this);\n            const project = this.getProject();\n            const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;\n            for (const dependency of (yield this.$.incomingDeps)) {\n                // ignore missing from events and inactive predecessors/dependencies\n                if (!(yield* this.shouldPredecessorAffectScheduling(dependency)))\n                    continue;\n                const predecessor = yield dependency.$.fromEvent;\n                let predecessorDate;\n                switch (yield dependency.$.type) {\n                    case DependencyType.EndToStart:\n                        predecessorDate = yield predecessor.$.earlyEndDateRaw;\n                        break;\n                    case DependencyType.StartToStart:\n                        predecessorDate = yield predecessor.$.earlyStartDateRaw;\n                        break;\n                }\n                if (predecessorDate) {\n                    const lag = yield dependency.$.lag;\n                    const lagUnit = yield dependency.$.lagUnit;\n                    const calendar = yield dependency.$.calendar;\n                    // this \"subscribes\" on the calendar's `version` field (which is incremented\n                    // every time when the intervals of the calendar changes)\n                    yield calendar.$.version;\n                    const interval = dependencyConstraintIntervalClass.new({\n                        owner: dependency,\n                        startDate: calendar.calculateEndDate(predecessorDate, yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond)),\n                        endDate: null\n                    });\n                    intervals.unshift(interval);\n                }\n            }\n            return intervals;\n        }\n        *calculateEarlyEndDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateEarlyEndDateConstraintIntervals.call(this);\n            const project = this.getProject();\n            const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;\n            for (const dependency of (yield this.$.incomingDeps)) {\n                // ignore missing from events and inactive dependencies\n                if (!(yield* this.shouldPredecessorAffectScheduling(dependency)))\n                    continue;\n                const predecessor = yield dependency.$.fromEvent;\n                let predecessorDate;\n                switch (yield dependency.$.type) {\n                    case DependencyType.EndToEnd:\n                        predecessorDate = yield predecessor.$.earlyEndDateRaw;\n                        break;\n                    case DependencyType.StartToEnd:\n                        predecessorDate = yield predecessor.$.earlyStartDateRaw;\n                        break;\n                }\n                if (predecessorDate) {\n                    const lag = yield dependency.$.lag;\n                    const lagUnit = yield dependency.$.lagUnit;\n                    const calendar = yield dependency.$.calendar;\n                    // this \"subscribes\" on the calendar's `version` field (which is incremented\n                    // every time when the intervals of the calendar changes)\n                    yield calendar.$.version;\n                    const interval = dependencyConstraintIntervalClass.new({\n                        owner: dependency,\n                        startDate: calendar.calculateEndDate(predecessorDate, yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond)),\n                        endDate: null\n                    });\n                    intervals.unshift(interval);\n                }\n            }\n            return intervals;\n        }\n    }\n    __decorate([\n        model_field({ type: 'boolean' })\n    ], ScheduledByDependenciesEarlyEventMixin.prototype, \"inactive\", void 0);\n    return ScheduledByDependenciesEarlyEventMixin;\n}) {\n}\n/**\n * Base class for dependency interval resolutions.\n */\nexport class BaseDependencyResolution extends Localizable(ConflictResolution) {\n    static get $name() {\n        return 'BaseDependencyResolution';\n    }\n    getDescription() {\n        const { dependency } = this, { type, fromEvent, toEvent } = dependency;\n        return format(this.L('L{descriptionTpl}'), this.L('L{DependencyType.long}')[type], fromEvent.name || fromEvent.id, toEvent.name || toEvent.id);\n    }\n}\n/**\n * Dependency resolution removing the dependency.\n */\nexport class RemoveDependencyResolution extends BaseDependencyResolution {\n    static get $name() {\n        return 'RemoveDependencyResolution';\n    }\n    /**\n     * Resolves the conflict by removing the dependency.\n     */\n    resolve() {\n        this.dependency.remove();\n    }\n}\n/**\n * Dependency resolution deactivating the dependency.\n */\nexport class DeactivateDependencyResolution extends BaseDependencyResolution {\n    static get $name() {\n        return 'DeactivateDependencyResolution';\n    }\n    /**\n     * Resolves the conflict by deactivating the dependency.\n     */\n    resolve() {\n        this.dependency.active = false;\n    }\n}\n/**\n * Description builder for a [[DependencyConstraintInterval|dependency constraint interval]].\n */\nexport class DependencyConstraintIntervalDescription extends ConstraintIntervalDescription {\n    static get $name() {\n        return 'DependencyConstraintIntervalDescription';\n    }\n    static getDescriptionParameters(interval) {\n        const dependency = interval.owner;\n        return [\n            DateHelper.format(interval.startDate, this.L('L{dateFormat}')),\n            DateHelper.format(interval.endDate, this.L('L{dateFormat}')),\n            this.L('L{DependencyType.long}')[dependency.type],\n            dependency.fromEvent.name,\n            dependency.toEvent.name\n        ];\n    }\n}\n/**\n * Constraint interval applied by a dependency.\n *\n * In case for a conflict the class [[getResolutions|suggests]] two resolution options:\n * either [[RemoveDependencyResolution|removing]] or [[DeactivateDependencyResolution|deactivating]] the dependency.\n */\nexport class DependencyConstraintInterval extends ConstraintInterval {\n    isAffectedByTransaction(transaction) {\n        const dependency = this.owner;\n        transaction = transaction || dependency.graph.activeTransaction;\n        const { entries } = transaction, \n        // dependency identifiers to check\n        { fromEvent, toEvent, lag, lagUnit, type } = dependency.$, fromEventQuark = entries.get(fromEvent), toEventQuark = entries.get(toEvent), lagQuark = entries.get(lag), lagUnitQuark = entries.get(lagUnit), typeQuark = entries.get(type);\n        // new or modified dependency\n        return !transaction.baseRevision.hasIdentifier(dependency.$$) ||\n            fromEventQuark && !fromEventQuark.isShadow() ||\n            toEventQuark && !toEventQuark.isShadow() ||\n            lagQuark && !lagQuark.isShadow() ||\n            lagUnitQuark && !lagUnitQuark.isShadow() ||\n            typeQuark && !typeQuark.isShadow();\n    }\n    /**\n     * Returns the interval resolution options.\n     * There are two resolutions:\n     * - [[RemoveDependencyResolution|removing the dependency]]\n     * - [[DeactivateDependencyResolution|deactivating the dependency]].\n     */\n    getResolutions() {\n        return this.resolutions || (this.resolutions = [\n            this.deactivateDependencyConflictResolutionClass.new({ dependency: this.owner }),\n            this.removeDependencyConflictResolutionClass.new({ dependency: this.owner })\n        ]);\n    }\n}\n__decorate([\n    prototypeValue(RemoveDependencyResolution)\n], DependencyConstraintInterval.prototype, \"removeDependencyConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DeactivateDependencyResolution)\n], DependencyConstraintInterval.prototype, \"deactivateDependencyConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DependencyConstraintIntervalDescription)\n], DependencyConstraintInterval.prototype, \"descriptionBuilderClass\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from '../../../../ChronoGraph/chrono/Effect.js';\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { BaseAssignmentMixin } from '../scheduler_basic/BaseAssignmentMixin.js';\nimport { calculate, field } from '../../../../ChronoGraph/replica/Entity.js';\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * A mixin for the assignment entity at the Scheduler Pro level.\n */\nexport class SchedulerProAssignmentMixin extends Mixin([BaseAssignmentMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProAssignmentMixin extends base {\n        *calculateUnits() {\n            const event = yield this.$.event;\n            // if event of assignment presents - we always delegate to it\n            // (so that various assignment logic can be overridden by single event mixin)\n            if (event)\n                return yield* event.calculateAssignmentUnits(this);\n            // otherwise use proposed or current consistent value\n            return yield ProposedOrPrevious;\n        }\n        *calculateEffort() {\n            const event = yield this.$.event;\n            if (event) {\n                const startDate = yield event.$.startDate;\n                const endDate = yield event.$.endDate;\n                const calendar = yield event.$.effectiveCalendar;\n                if (startDate && endDate) {\n                    const map = new Map();\n                    map.set(calendar, [this]);\n                    return yield* event.calculateProjectedEffort(startDate, endDate, map);\n                }\n            }\n            return null;\n        }\n        *calculateActualDate() {\n            const event = yield this.$.event;\n            if (event) {\n                const startDate = yield event.$.startDate;\n                const duration = yield event.$.duration;\n                const percentDone = yield event.$.percentDone;\n                return yield* event.calculateProjectedXDateWithDuration(startDate, true, duration * 0.01 * percentDone);\n            }\n            return null;\n        }\n        *calculateActualEffort() {\n            const event = yield this.$.event;\n            if (event) {\n                const startDate = yield event.$.startDate;\n                const calendar = yield event.$.effectiveCalendar;\n                const actualDate = yield this.$.actualDate;\n                const assignmentsByCalendar = new Map();\n                assignmentsByCalendar.set(calendar, [this]);\n                return yield* event.calculateProjectedEffort(startDate, actualDate, assignmentsByCalendar);\n            }\n            return null;\n        }\n    }\n    __decorate([\n        model_field({ type: 'number', defaultValue: 100 })\n    ], SchedulerProAssignmentMixin.prototype, \"units\", void 0);\n    __decorate([\n        calculate('units')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateUnits\", null);\n    __decorate([\n        field({ lazy: true })\n    ], SchedulerProAssignmentMixin.prototype, \"effort\", void 0);\n    __decorate([\n        field({ lazy: true })\n    ], SchedulerProAssignmentMixin.prototype, \"actualDate\", void 0);\n    __decorate([\n        field({ lazy: true })\n    ], SchedulerProAssignmentMixin.prototype, \"actualEffort\", void 0);\n    __decorate([\n        calculate('effort')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateEffort\", null);\n    __decorate([\n        calculate('actualDate')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateActualDate\", null);\n    __decorate([\n        calculate('actualEffort')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateActualEffort\", null);\n    return SchedulerProAssignmentMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field, write } from '../../../../ChronoGraph/replica/Entity.js';\nimport { isAtomicValue } from '../../../../ChronoGraph/util/Helpers.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport { model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { DependenciesCalendar, TimeUnit } from '../../../scheduling/Types.js';\nimport { BaseDependencyMixin } from '../scheduler_basic/BaseDependencyMixin.js';\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * A mixin for the dependency entity at the Scheduler Pro level. It adds [[lag]] and [[lagUnit]] fields.\n *\n * The calendar according to which the lag time is calculated is defined with the\n * [[SchedulerProProjectMixin.dependenciesCalendar|dependenciesCalendar]] config of the project.\n */\nexport class SchedulerProDependencyMixin extends Mixin([BaseDependencyMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProDependencyMixin extends base {\n        *calculateCalendar() {\n            const project = this.getProject();\n            const dependenciesCalendar = yield project.$.dependenciesCalendar;\n            let calendar;\n            switch (dependenciesCalendar) {\n                case DependenciesCalendar.Project:\n                    calendar = yield project.$.effectiveCalendar;\n                    break;\n                case DependenciesCalendar.FromEvent:\n                    const fromEvent = yield this.$.fromEvent;\n                    calendar = fromEvent && !isAtomicValue(fromEvent) ? yield fromEvent.$.effectiveCalendar : null;\n                    break;\n                case DependenciesCalendar.ToEvent:\n                    const toEvent = yield this.$.toEvent;\n                    calendar = toEvent && !isAtomicValue(toEvent) ? yield toEvent.$.effectiveCalendar : null;\n                    break;\n            }\n            // the only case when there will be no calendar is when there's no either from/to event\n            // what to return in such case? use project calendar as \"defensive\" approach\n            if (!calendar)\n                calendar = yield project.$.effectiveCalendar;\n            return calendar;\n        }\n        /**\n         * Setter for the [[lag]]. Can also set [[lagUnit]] if second argument is provided.\n         *\n         * @param lag\n         * @param unit\n         */\n        async setLag(lag, unit) {\n            if (this.graph) {\n                this.graph.write(this.$.lag, lag, unit);\n                return this.graph.commitAsync();\n            }\n            else {\n                this.$.lag.DATA = lag;\n                if (unit != null)\n                    this.$.lagUnit.DATA = unit;\n            }\n        }\n        writeLag(me, transaction, quark, lag, unit = undefined) {\n            me.constructor.prototype.write.call(this, me, transaction, quark, lag);\n            if (unit != null)\n                transaction.write(this.$.lagUnit, unit);\n        }\n    }\n    __decorate([\n        model_field({ type: 'number', defaultValue: 0 })\n    ], SchedulerProDependencyMixin.prototype, \"lag\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: TimeUnit.Day }, { converter: DateHelper.normalizeUnit })\n    ], SchedulerProDependencyMixin.prototype, \"lagUnit\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProDependencyMixin.prototype, \"calendar\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true, persist: true })\n    ], SchedulerProDependencyMixin.prototype, \"active\", void 0);\n    __decorate([\n        calculate('calendar')\n    ], SchedulerProDependencyMixin.prototype, \"calculateCalendar\", null);\n    __decorate([\n        write('lag')\n    ], SchedulerProDependencyMixin.prototype, \"writeLag\", null);\n    return SchedulerProDependencyMixin;\n}) {\n}\n// /**\n//  * Dependency entity mixin type\n//  */\n// export type SchedulerProDependencyMixin = Mixin<typeof SchedulerProDependencyMixin>\n//\n// export interface SchedulerProDependencyMixinI extends Mixin<typeof SchedulerProDependencyMixin> {}\n//\n// export const BuildSchedulerProDependency = (base) => SchedulerProDependencyMixin(BuildMinimalBaseDependency(base))\n//\n// export class MinimalSchedulerProDependency extends SchedulerProDependencyMixin(MinimalBaseDependency) {}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { HasChildrenMixin } from \"../scheduler_basic/HasChildrenMixin.js\";\n// <remove-on-release>\n// TODO: The percentdone logic calculation is a bit different from the Ext version, in regard of milestones\n//  In Ext, the parent task with milestones only has 100% if all its child milestones have 100%, and 0% otherwise\n//  In engine, the % for milestones is calculated just as average. There are other small nuances too.\n//  Personally I think engine's behavior is more logical and we can change it to Ext version behavior\n//  because we have all data.\n// </remove-on-release>\n/**\n * This mixin provides [[percentDone]] field for the event and methods for its calculation.\n *\n * For the parent events percent done is calculated based on the child events (ignores user input).\n * This behavior is controlled with the [[SchedulerProProjectMixin.autoCalculatePercentDoneForParentTasks]] config option.\n * The calculation is implemented in [[calculatePercentDone]] method.\n */\nexport class HasPercentDoneMixin extends Mixin([HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class HasPercentDoneMixin extends base {\n        /**\n         * Method calculates the task [[percentDone]] field value.\n         * For a summary task it calculates the value based on the task children if the project\n         * [[SchedulerProProjectMixin.autoCalculatePercentDoneForParentTasks|autoCalculatePercentDoneForParentTasks]] is true (default).\n         * And for a regular (leaf) task it just returns the field provided value as-is.\n         */\n        *calculatePercentDone() {\n            const childEvents = yield this.$.childEvents;\n            const project = this.getProject();\n            const autoCalculatePercentDoneForParentTasks = yield project.$.autoCalculatePercentDoneForParentTasks;\n            if (childEvents.size && autoCalculatePercentDoneForParentTasks) {\n                const summaryData = yield this.$.percentDoneSummaryData;\n                if (summaryData.totalDuration > 0) {\n                    return summaryData.completedDuration / summaryData.totalDuration;\n                }\n                else if (summaryData.milestonesNum > 0) {\n                    return summaryData.milestonesTotalPercentDone / summaryData.milestonesNum;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return yield ProposedOrPrevious;\n            }\n        }\n        /**\n         * The method defines whether the provided child event should be\n         * taken into account when calculating this summary event [[percentDone]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default the method returns `true` to include all child events data.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildPercentDoneSummaryData(childEvent) {\n            return true;\n        }\n        *calculatePercentDoneSummaryData() {\n            const childEvents = yield this.$.childEvents;\n            if (childEvents.size) {\n                let summary = {\n                    totalDuration: 0,\n                    completedDuration: 0,\n                    milestonesNum: 0,\n                    milestonesTotalPercentDone: 0\n                };\n                for (const childEvent of childEvents) {\n                    if (!(yield* this.shouldRollupChildPercentDoneSummaryData(childEvent)))\n                        continue;\n                    const childSummaryData = yield childEvent.$.percentDoneSummaryData;\n                    if (childSummaryData) {\n                        summary.totalDuration += childSummaryData.totalDuration;\n                        summary.completedDuration += childSummaryData.completedDuration;\n                        summary.milestonesNum += childSummaryData.milestonesNum;\n                        summary.milestonesTotalPercentDone += childSummaryData.milestonesTotalPercentDone;\n                    }\n                }\n                return summary;\n            }\n            else {\n                const duration = yield this.$.duration;\n                if (typeof duration == 'number') {\n                    const durationInMs = yield* this.getProject().$convertDuration(duration, yield this.$.durationUnit, TimeUnit.Millisecond);\n                    const percentDone = yield this.$.percentDone;\n                    return {\n                        totalDuration: durationInMs,\n                        completedDuration: durationInMs * percentDone,\n                        milestonesNum: durationInMs === 0 ? 1 : 0,\n                        milestonesTotalPercentDone: durationInMs === 0 ? percentDone : 0,\n                    };\n                    // we can't calculate w/o duration\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    __decorate([\n        model_field({ type: 'number', defaultValue: 0 })\n    ], HasPercentDoneMixin.prototype, \"percentDone\", void 0);\n    __decorate([\n        field()\n    ], HasPercentDoneMixin.prototype, \"percentDoneSummaryData\", void 0);\n    __decorate([\n        calculate('percentDone')\n    ], HasPercentDoneMixin.prototype, \"calculatePercentDone\", null);\n    __decorate([\n        calculate('percentDoneSummaryData')\n    ], HasPercentDoneMixin.prototype, \"calculatePercentDoneSummaryData\", null);\n    return HasPercentDoneMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasProposedValue } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Reject } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { CalendarIteratorResult } from \"../../../calendar/CalendarCache.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { EmptyCalendarEffect } from \"../scheduler_basic/BaseCalendarMixin.js\";\nimport { BaseHasAssignmentsMixin } from \"../scheduler_basic/BaseHasAssignmentsMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixins enhances the purely visual [[BaseHasAssignmentsMixin]] with scheduling according\n * to the calendars of the assigned resources.\n *\n * A time interval will be \"counted\" into the event duration, only if at least one assigned\n * resource has that interval as working time, and the event's own calendar also has that interval\n * as working. Otherwise the time is skipped and not counted into event's duration.\n */\nexport class SchedulerProHasAssignmentsMixin extends Mixin([BaseHasAssignmentsMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProHasAssignmentsMixin extends base {\n        *hasProposedValueForUnits() {\n            const assignments = yield this.$.assigned;\n            for (const assignment of assignments) {\n                const resource = yield assignment.$.resource;\n                if (resource && (yield HasProposedValue(assignment.$.units)))\n                    return true;\n            }\n            return false;\n        }\n        /**\n         * A method which assigns a resource to the current event\n         */\n        async assign(resource, units = 100) {\n            //<debug>\n            // Preconditions:\n            if (this.getAssignmentFor(resource))\n                throw new Error('Resource can\\'t be assigned twice to the same task');\n            //</debug>\n            const assignmentCls = this.getProject().assignmentStore.modelClass;\n            this.addAssignment(new assignmentCls({\n                event: this,\n                resource: resource,\n                units: units\n            }));\n            return this.commitAsync();\n        }\n        *forEachAvailabilityInterval(options, func) {\n            const calendar = yield this.$.effectiveCalendar;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;\n            const ignoreResourceCalendar = (yield this.$.ignoreResourceCalendar) || options.ignoreResourceCalendar || !assignmentsByCalendar.size;\n            const maxRange = this.getProject().maxCalendarRange;\n            if (maxRange) {\n                options = Object.assign({ maxRange }, options);\n            }\n            return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {\n                const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                if (calendarsStatus.get(calendar)\n                    &&\n                        (ignoreResourceCalendar || workCalendars.some((calendar) => assignmentsByCalendar.has(calendar)))) {\n                    return func(startDate, endDate, calendarCacheIntervalMultiple);\n                }\n            });\n        }\n        // <remove-on-release>\n        // TODO: seems this atom is used in single place only - can be merged there\n        // </remove-on-release>\n        *calculateEffectiveCalendarsCombination() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const project = this.getProject();\n            const calendars = [yield this.$.effectiveCalendar];\n            if (!manuallyScheduled || project.skipNonWorkingTimeInDurationWhenSchedulingManually) {\n                const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n                calendars.push(...assignmentsByCalendar.keys());\n            }\n            return this.getProject().combineCalendars(calendars);\n        }\n        *calculateAssignmentsByCalendar() {\n            const assignments = yield this.$.assigned;\n            const result = new Map();\n            for (const assignment of assignments) {\n                const resource = yield assignment.$.resource;\n                if (resource) {\n                    const resourceCalendar = yield resource.$.effectiveCalendar;\n                    let assignments = result.get(resourceCalendar);\n                    if (!assignments) {\n                        assignments = [];\n                        result.set(resourceCalendar, assignments);\n                    }\n                    assignments.push(assignment);\n                }\n            }\n            return result;\n        }\n        *getBaseOptionsForDurationCalculations() {\n            return { ignoreResourceCalendar: false };\n        }\n        *useEventAvailabilityIterator() {\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            return assignmentsByCalendar.size > 0;\n        }\n        *skipNonWorkingTime(date, isForward = true, iteratorOptions) {\n            if (!date)\n                return null;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const ignoreResourceCalendar = yield this.$.ignoreResourceCalendar;\n            if (yield* this.useEventAvailabilityIterator()) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: date, isForward } : { endDate: date, isForward }, iteratorOptions);\n                let workingDate;\n                const skipRes = yield* this.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {\n                    workingDate = isForward ? startDate : endDate;\n                    return false;\n                });\n                if (skipRes === CalendarIteratorResult.MaxRangeReached || skipRes === CalendarIteratorResult.FullRangeIterated) {\n                    const calendars = [yield this.$.effectiveCalendar];\n                    // if we take resource calendars into account collect them\n                    // and provide to EmptyCalendarEffect instance\n                    if (!options.ignoreResourceCalendar && !ignoreResourceCalendar) {\n                        calendars.push(...assignmentsByCalendar.keys());\n                    }\n                    const effect = EmptyCalendarEffect.new({\n                        event: this,\n                        calendars,\n                        date,\n                        isForward\n                    });\n                    if ((yield effect) === EffectResolutionResult.Cancel) {\n                        yield Reject(effect);\n                    }\n                    else {\n                        return null;\n                    }\n                }\n                return new Date(workingDate);\n            }\n            else {\n                return yield* superProto.skipNonWorkingTime.call(this, date, isForward);\n            }\n        }\n        *calculateProjectedDuration(startDate, endDate, durationUnit, iteratorOptions) {\n            if (!startDate || !endDate) {\n                return null;\n            }\n            if (yield* this.useEventAvailabilityIterator()) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), { startDate, endDate, isForward: true }, iteratorOptions);\n                const adjustDurationToDST = this.getProject().adjustDurationToDST;\n                let result = 0;\n                yield* this.forEachAvailabilityInterval(options, (startDate, endDate) => {\n                    result += endDate.getTime() - startDate.getTime();\n                    if (adjustDurationToDST) {\n                        const dstDiff = startDate.getTimezoneOffset() - endDate.getTimezoneOffset();\n                        result += dstDiff * 60 * 1000;\n                    }\n                });\n                if (!durationUnit)\n                    durationUnit = yield this.$.durationUnit;\n                return yield* this.getProject().$convertDuration(result, TimeUnit.Millisecond, durationUnit);\n            }\n            else {\n                return yield* superProto.calculateProjectedDuration.call(this, startDate, endDate, durationUnit);\n            }\n        }\n        *calculateProjectedXDateWithDuration(baseDate, isForward = true, duration, durationUnit, iteratorOptions) {\n            if (duration == null || isNaN(duration) || baseDate == null)\n                return null;\n            if (duration == 0)\n                return baseDate;\n            durationUnit = durationUnit || (yield this.$.durationUnit);\n            const durationMS = yield* this.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond);\n            let resultN = baseDate.getTime();\n            let leftDuration = durationMS;\n            const calendar = yield this.$.effectiveCalendar;\n            if (yield* this.useEventAvailabilityIterator()) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: baseDate, isForward } : { endDate: baseDate, isForward }, iteratorOptions);\n                const adjustDurationToDST = this.getProject().adjustDurationToDST;\n                const iterationRes = yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                    const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                    if (intervalDuration >= leftDuration) {\n                        if (adjustDurationToDST) {\n                            const dstDiff = isForward\n                                ? intervalStart.getTimezoneOffset() - (new Date(intervalStartN + leftDuration)).getTimezoneOffset()\n                                : (new Date(intervalEndN - leftDuration)).getTimezoneOffset() - intervalEnd.getTimezoneOffset();\n                            leftDuration -= dstDiff * 60 * 1000;\n                        }\n                        resultN = isForward ? intervalStartN + leftDuration : intervalEndN - leftDuration;\n                        return false;\n                    }\n                    else {\n                        leftDuration -= intervalDuration;\n                        if (adjustDurationToDST) {\n                            const dstDiff = intervalStart.getTimezoneOffset() - intervalEnd.getTimezoneOffset();\n                            leftDuration -= dstDiff * 60 * 1000;\n                        }\n                    }\n                });\n                // this will cause the method to return `null` if there's some problem with iterator\n                // easier to debug than a wrong number\n                return iterationRes === CalendarIteratorResult.StoppedByIterator ? new Date(resultN) : null;\n            }\n            else {\n                return calendar.accumulateWorkingTime(baseDate, durationMS, isForward).finalDate;\n            }\n        }\n    }\n    __decorate([\n        field()\n    ], SchedulerProHasAssignmentsMixin.prototype, \"effectiveCalendarsCombination\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProHasAssignmentsMixin.prototype, \"assignmentsByCalendar\", void 0);\n    __decorate([\n        model_field({ type: 'boolean' })\n    ], SchedulerProHasAssignmentsMixin.prototype, \"ignoreResourceCalendar\", void 0);\n    __decorate([\n        calculate('effectiveCalendarsCombination')\n    ], SchedulerProHasAssignmentsMixin.prototype, \"calculateEffectiveCalendarsCombination\", null);\n    __decorate([\n        calculate('assignmentsByCalendar')\n    ], SchedulerProHasAssignmentsMixin.prototype, \"calculateAssignmentsByCalendar\", null);\n    return SchedulerProHasAssignmentsMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasProposedValue, PreviousValueOf, ProposedArgumentsOf, ProposedOrPrevious, ProposedOrPreviousValueOf } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { CalculatedValueGen } from \"../../../../ChronoGraph/chrono/Identifier.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalculateProposed, CycleDescription, CycleResolution, Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { calculate, field, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { FieldIdentifier } from \"../../../../ChronoGraph/replica/Identifier.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { DurationVar, EndDateVar, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { BaseEventMixin } from \"../scheduler_basic/BaseEventMixin.js\";\nexport const MasterStartDateVar = Symbol('MasterStartDateVar');\nexport const MasterEndDateVar = Symbol('MasterEndDateVar');\nexport const MasterDurationVar = Symbol('MasterDurationVar');\nexport const MasterTotalDurationVar = Symbol('MasterTotalDurationVar');\nexport const StartOffsetVar = Symbol('StartOffsetVar');\nexport const EndOffsetVar = Symbol('EndOffsetVar');\nexport const durationByOffsetsFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartOffsetVar, EndOffsetVar])\n});\nexport const startDateByMasterStartAndStartOffsetFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([StartOffsetVar, MasterStartDateVar])\n});\nexport const endDateByMasterStartAndEndOffsetFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([EndOffsetVar, MasterStartDateVar])\n});\nexport const startOffsetByMasterStartAndStartDateFormula = Formula.new({\n    output: StartOffsetVar,\n    inputs: new Set([StartDateVar, MasterStartDateVar])\n});\nexport const endOffsetByMasterStartAndEndDateFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([EndDateVar, MasterStartDateVar])\n});\nexport const startOffsetByEndOffsetAndDurationFormula = Formula.new({\n    output: StartOffsetVar,\n    inputs: new Set([EndOffsetVar, DurationVar])\n});\nexport const endOffsetByStartOffsetAndDurationFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([StartOffsetVar, DurationVar])\n});\nexport const endOffsetByMasterTotalDurationAndStartOffsetFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([StartOffsetVar, MasterTotalDurationVar])\n});\nexport const endOffsetByMasterDurationAndStartOffsetFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([StartOffsetVar, MasterDurationVar])\n});\n// export const endOffsetByMasterEndDateAndStartOffsetFormula = Formula.new({\n//     output      : EndOffsetVar,\n//     inputs      : new Set([ StartOffsetVar, MasterEndDateVar ])\n// })\nexport const durationByMasterEndDateFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartOffsetVar, MasterEndDateVar])\n});\nexport const segmentCycleDescription = CycleDescription.new({\n    variables: new Set([\n        StartDateVar,\n        EndDateVar,\n        DurationVar,\n        MasterStartDateVar,\n        MasterEndDateVar,\n        MasterDurationVar,\n        MasterTotalDurationVar,\n        StartOffsetVar,\n        EndOffsetVar\n    ]),\n    formulas: new Set([\n        // the order of formulas is important here - the earlier ones are preferred\n        durationByOffsetsFormula,\n        startDateByMasterStartAndStartOffsetFormula,\n        endDateByMasterStartAndEndOffsetFormula,\n        startOffsetByEndOffsetAndDurationFormula,\n        startOffsetByMasterStartAndStartDateFormula,\n        endOffsetByStartOffsetAndDurationFormula,\n        endOffsetByMasterTotalDurationAndStartOffsetFormula,\n        endOffsetByMasterDurationAndStartOffsetFormula,\n        // endOffsetByMasterEndDateAndStartOffsetFormula,\n        endOffsetByMasterStartAndEndDateFormula,\n        durationByMasterEndDateFormula\n    ])\n});\nexport const segmentCycleResolution = CycleResolution.new({\n    description: segmentCycleDescription,\n    defaultResolutionFormulas: new Set([\n        endDateByMasterStartAndEndOffsetFormula,\n        endOffsetByMasterStartAndEndDateFormula,\n        endOffsetByStartOffsetAndDurationFormula\n    ])\n});\nexport class SegmentSEDDispatcherIdentifier extends FieldIdentifier.mix(CalculatedValueGen) {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        return resolution1.get(StartDateVar) === resolution2.get(StartDateVar)\n            && resolution1.get(EndDateVar) === resolution2.get(EndDateVar)\n            && resolution1.get(DurationVar) === resolution2.get(DurationVar)\n            && resolution1.get(MasterStartDateVar) === resolution2.get(MasterStartDateVar)\n            && resolution1.get(MasterEndDateVar) === resolution2.get(MasterEndDateVar)\n            && resolution1.get(MasterDurationVar) === resolution2.get(MasterDurationVar)\n            && resolution1.get(MasterTotalDurationVar) === resolution2.get(MasterTotalDurationVar)\n            && resolution1.get(StartOffsetVar) === resolution2.get(StartOffsetVar)\n            && resolution1.get(EndOffsetVar) === resolution2.get(EndOffsetVar);\n    }\n}\n/**\n * This is the segment class [[SchedulerProProjectMixin]] works with.\n */\nexport class SchedulerProEventSegment extends Mixin([BaseEventMixin], (base) => {\n    class SchedulerProEventSegment extends base {\n        get isEventSegment() {\n            return true;\n        }\n        get stm() {\n            // use main event StateTrackingManager\n            return this.event?.stm;\n        }\n        set stm(value) {\n        }\n        writeStartDate(me, transaction, quark, date, keepDuration = true) {\n            const event = this.event;\n            const project = this.getProject();\n            // if it's the very first segment and it's not data loading or part of STM undo/redo\n            if (event && !this.previousSegment && transaction.baseRevision.hasIdentifier(me) && !(project && project.getStm().isRestoring)) {\n                event.$.startDate.constructor.prototype.write.call(this, event.$.startDate, transaction, null, date, keepDuration);\n            }\n            else {\n                me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);\n            }\n            // if we have next segment(s) and we have to respect and not overlap them\n            if (keepDuration && this.nextSegment) {\n                const shift = this.endOffset - this.nextSegment.startOffset;\n                if (shift > 0) {\n                    let segment = this;\n                    // push next segments forward by the lag duration\n                    while ((segment = segment.nextSegment)) {\n                        segment.startOffset += shift;\n                        segment.endOffset += shift;\n                    }\n                }\n            }\n        }\n        shouldRecordFieldChange(fieldName, oldValue, newValue) {\n            return (fieldName === 'startOffset' || fieldName === 'endOffset') || super.shouldRecordFieldChange(fieldName, oldValue, newValue);\n        }\n        *calculateStartOffset() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(StartOffsetVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (resolution === CalculateProposed) {\n                result = yield ProposedOrPrevious;\n            }\n            else if (resolution === startOffsetByEndOffsetAndDurationFormula.formulaId) {\n                result = yield* this.calculateStartOffsetByEndOffsetAndDuration();\n            }\n            else if (resolution === startOffsetByMasterStartAndStartDateFormula.formulaId) {\n                const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);\n                const startDate = yield ProposedOrPreviousValueOf(this.$.startDate);\n                result = yield* this.event.calculateProjectedDuration(masterStartDate, startDate, TimeUnit.Millisecond, { ignoreSegments: true });\n            }\n            return result;\n        }\n        *calculateEndOffset() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(EndOffsetVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (resolution === CalculateProposed) {\n                result = yield ProposedOrPrevious;\n            }\n            else if (resolution === endOffsetByStartOffsetAndDurationFormula.formulaId) {\n                result = yield* this.calculateEndOffsetByStartOffsetAndDuration();\n            }\n            else if (resolution === endOffsetByMasterStartAndEndDateFormula.formulaId) {\n                const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);\n                const endDate = yield ProposedOrPreviousValueOf(this.$.endDate);\n                result = yield* this.event.calculateProjectedDuration(masterStartDate, endDate, TimeUnit.Millisecond, { ignoreSegments: true });\n            }\n            else if (resolution === endOffsetByMasterDurationAndStartOffsetFormula.formulaId) {\n                result = yield* this.calculateEndOffsetByMasterDurationAndStartOffset();\n            }\n            else if (resolution === endOffsetByMasterTotalDurationAndStartOffsetFormula.formulaId) {\n                result = yield* this.calculateEndOffsetByMasterTotalDurationAndStartOffset();\n            }\n            return result;\n        }\n        *calculateStartDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const formula = dispatcher.resolution.get(StartDateVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (formula === startDateByMasterStartAndStartOffsetFormula.formulaId) {\n                result = yield* this.calculateStartDateByMasterStartAndStartOffset();\n            }\n            else {\n                result = yield* super.calculateStartDate();\n            }\n            return result;\n        }\n        *calculateEndDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const formula = dispatcher.resolution.get(EndDateVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (formula === endDateByMasterStartAndEndOffsetFormula.formulaId) {\n                result = yield* this.calculateEndDateByMasterStartAndEndOffset();\n            }\n            else {\n                result = yield* super.calculateEndDate();\n            }\n            return result;\n        }\n        *calculateDuration() {\n            const dispatcher = yield this.$.dispatcher;\n            const formula = dispatcher.resolution.get(DurationVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (formula === durationByOffsetsFormula.formulaId) {\n                result = yield* this.calculateDurationByOffsets();\n            }\n            else if (formula === durationByMasterEndDateFormula.formulaId) {\n                result = yield* this.calculateDurationByOffsets();\n            }\n            else {\n                result = yield* super.calculateDuration();\n            }\n            return result;\n        }\n        buildProposedDispatcher(me, quark, transaction) {\n            const dispatcher = super.buildProposedDispatcher(me, quark, transaction);\n            dispatcher.addPreviousValueFlag(MasterStartDateVar);\n            dispatcher.addPreviousValueFlag(StartOffsetVar);\n            dispatcher.addPreviousValueFlag(EndOffsetVar);\n            return dispatcher;\n        }\n        *prepareDispatcher(YIELD) {\n            const dispatcher = yield* super.prepareDispatcher(YIELD);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return dispatcher; //yield ProposedOrPrevious\n            }\n            // ProposedValueOf(this.event.$.startDate)\n            if (YIELD(PreviousValueOf(this.event.$.startDate)) != null)\n                dispatcher.addPreviousValueFlag(MasterStartDateVar);\n            if (YIELD(HasProposedValue(this.event.$.startDate)))\n                dispatcher.addProposedValueFlag(MasterStartDateVar);\n            if (!YIELD(HasProposedValue(this.event.$.segments))) {\n                dispatcher.collectInfo(YIELD, this.event.$.duration, MasterDurationVar);\n                if (YIELD(HasProposedValue(this.event.$.endDate))) {\n                    const masterEndDateArgs = YIELD(ProposedArgumentsOf(this.event.$.endDate));\n                    if (!masterEndDateArgs?.[0]) {\n                        dispatcher.addProposedValueFlag(MasterEndDateVar);\n                    }\n                }\n                const masterDispatcher = YIELD(this.event.$.dispatcher);\n                if (masterDispatcher.resolution.get(StartDateVar) === CalculateProposed &&\n                    masterDispatcher.resolution.get(EndDateVar) === CalculateProposed) {\n                    dispatcher.addProposedValueFlag(MasterTotalDurationVar);\n                }\n            }\n            dispatcher.collectInfo(YIELD, this.$.startOffset, StartOffsetVar);\n            dispatcher.collectInfo(YIELD, this.$.endOffset, EndOffsetVar);\n            return dispatcher;\n        }\n        cycleResolutionContext(Y) {\n            return segmentCycleResolution;\n        }\n        // endOffsetByMasterDurationAndStartOffsetFormula\n        *calculateEndOffsetByMasterDurationAndStartOffset() {\n            const masterDuration = yield ProposedOrPreviousValueOf(this.event.$.duration); //yield this.event.$.duration\n            const masterDurationUnit = yield this.event.$.durationUnit;\n            const startOffset = yield this.$.startOffset;\n            const nextSegment = this.nextSegment;\n            let result;\n            let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);\n            const segments = [];\n            let segment = this;\n            while ((segment = segment.previousSegment)) {\n                segments.push(segment);\n            }\n            for (let i = segments.length - 1; i >= 0; i--) {\n                const segment = segments[i];\n                const segmentStartOffset = yield ProposedOrPreviousValueOf(segment.$.startOffset);\n                const segmentEndOffset = yield ProposedOrPreviousValueOf(segment.$.endOffset);\n                const segmentDurationMs = segmentEndOffset - segmentStartOffset;\n                masterDurationMs -= segmentDurationMs;\n            }\n            if (masterDurationMs > 0) {\n                if (!nextSegment) {\n                    result = startOffset + masterDurationMs;\n                }\n                else {\n                    result = startOffset + Math.min(masterDurationMs, (yield ProposedOrPreviousValueOf(this.$.endOffset)) - startOffset);\n                }\n            }\n            // return start offset in case we have no duration left for this segment\n            // then it will have start offset === end offset\n            else {\n                result = startOffset;\n            }\n            return result;\n        }\n        // endOffsetByMasterDurationAndStartOffsetFormula\n        *calculateEndOffsetByMasterTotalDurationAndStartOffset() {\n            const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);\n            const masterEndDate = yield ProposedOrPreviousValueOf(this.event.$.endDate);\n            const masterTotalDurationMs = yield* this.event.calculateProjectedDuration(masterStartDate, masterEndDate, TimeUnit.Millisecond, { ignoreSegments: true });\n            const startOffset = yield ProposedOrPreviousValueOf(this.$.startOffset);\n            let endOffset = yield ProposedOrPreviousValueOf(this.$.endOffset);\n            let nextSegment = this.nextSegment;\n            if (startOffset <= masterTotalDurationMs) {\n                // if the segment is inside master event time span\n                if (endOffset <= masterTotalDurationMs) {\n                    // if that's the last one (either by index or by the fact the next segment is ouside of the event range)\n                    // make its end === master end\n                    if (!nextSegment || (yield ProposedOrPreviousValueOf(nextSegment.$.startOffset)) >= masterTotalDurationMs) {\n                        return masterTotalDurationMs;\n                    }\n                    // otherwise keep existing value\n                    return endOffset;\n                }\n                // if the segment finishes later than the master event - make its end === master end\n                else {\n                    return masterTotalDurationMs;\n                }\n            }\n            // if the segment is outside of the master event - make its duration zero\n            return yield this.$.startOffset;\n        }\n        // startOffsetByEndOffsetAndDurationFormula\n        *calculateStartOffsetByEndOffsetAndDuration() {\n            const duration = yield this.$.duration;\n            const durationUnit = yield this.$.durationUnit;\n            const endOffset = yield this.$.endOffset;\n            return endOffset - (yield* this.event.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n        }\n        // endOffsetByStartOffsetAndDurationFormula\n        *calculateEndOffsetByStartOffsetAndDuration() {\n            const duration = yield this.$.duration;\n            const durationUnit = yield this.$.durationUnit;\n            const startOffset = yield this.$.startOffset;\n            return startOffset + (yield* this.event.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n        }\n        // endDateByMasterStartAndEndOffsetFormula\n        *calculateEndDateByMasterStartAndEndOffset() {\n            const masterStartDate = yield this.event.$.startDate;\n            const endOffset = yield this.$.endOffset;\n            const rawDate = yield* this.event.calculateProjectedXDateWithDuration(masterStartDate, true, endOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                ? rawDate\n                : yield* this.event.skipNonWorkingTime(rawDate, false);\n        }\n        // startDateByMasterStartAndStartOffsetFormula\n        *calculateStartDateByMasterStartAndStartOffset() {\n            const masterStartDate = yield this.event.$.startDate;\n            const startOffset = yield this.$.startOffset;\n            const rawDate = yield* this.event.calculateProjectedXDateWithDuration(masterStartDate, true, startOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                ? rawDate\n                : yield* this.event.skipNonWorkingTime(rawDate);\n        }\n        // durationByOffsetsFormula\n        *calculateDurationByOffsets() {\n            const startOffset = yield this.$.startOffset;\n            const endOffset = yield this.$.endOffset;\n            const durationUnit = yield this.$.durationUnit;\n            return yield* this.getProject().$convertDuration(endOffset - startOffset, TimeUnit.Millisecond, durationUnit);\n        }\n        *calculatePercentDone() {\n            let result = 0;\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            // <remove-on-release>\n            // TODO: can get rid of this edge if use this.previousSegment\n            // </remove-on-release>\n            const segments = yield this.event.$.segments;\n            if (segments) {\n                const masterPercentDone = yield this.event.$.percentDone;\n                const masterDuration = yield this.event.$.duration;\n                const masterDurationUnit = yield this.event.$.durationUnit;\n                let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);\n                let completeMasterDurationMs = masterPercentDone * 0.01 * masterDurationMs;\n                for (const segment of segments) {\n                    const segmentStartOffset = segment.startOffset;\n                    const segmentEndOffset = segment.endOffset;\n                    const segmentDurationMs = segmentEndOffset - segmentStartOffset;\n                    if (segment === this) {\n                        if (completeMasterDurationMs >= segmentDurationMs)\n                            return 100;\n                        else if (completeMasterDurationMs > 0)\n                            return 100 * completeMasterDurationMs / segmentDurationMs;\n                        else\n                            return 0;\n                    }\n                    completeMasterDurationMs -= segmentDurationMs;\n                }\n            }\n            return result;\n        }\n        *calculateMinPercent() {\n            const previousSegment = this.previousSegment;\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            if (previousSegment) {\n                return yield previousSegment.$.endPercentDone;\n            }\n            return 0;\n        }\n        *calculateMaxPercent() {\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            const masterDuration = yield this.event.$.duration;\n            const masterDurationUnit = yield this.event.$.durationUnit;\n            let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);\n            const startOffset = yield this.$.startOffset;\n            const endOffset = yield this.$.endOffset;\n            const minPercent = yield this.$.startPercentDone;\n            return minPercent + 100 * (endOffset - startOffset) / masterDurationMs;\n        }\n        // @override\n        *calculateProjectedXDateWithDuration(baseDate, isForward, duration, durationUnit) {\n            if (!durationUnit)\n                durationUnit = yield this.$.durationUnit;\n            return yield* this.event.calculateProjectedXDateWithDuration(baseDate, isForward, duration, durationUnit, { ignoreSegments: true });\n        }\n        // @override\n        *calculateProjectedDuration(startDate, endDate, durationUnit) {\n            if (!durationUnit)\n                durationUnit = yield this.$.durationUnit;\n            return yield* this.event.calculateProjectedDuration(startDate, endDate, durationUnit, { ignoreSegments: true });\n        }\n        *calculateManuallyScheduled() {\n            if (this.event) {\n                return yield this.event.$.manuallyScheduled;\n            }\n            else {\n                return yield ProposedOrPrevious;\n            }\n        }\n    }\n    __decorate([\n        field({ identifierCls: SegmentSEDDispatcherIdentifier })\n    ], SchedulerProEventSegment.prototype, \"dispatcher\", void 0);\n    __decorate([\n        model_field({ persist: false })\n    ], SchedulerProEventSegment.prototype, \"startOffset\", void 0);\n    __decorate([\n        model_field({ persist: false })\n    ], SchedulerProEventSegment.prototype, \"endOffset\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProEventSegment.prototype, \"percentDone\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProEventSegment.prototype, \"startPercentDone\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProEventSegment.prototype, \"endPercentDone\", void 0);\n    __decorate([\n        write('startDate')\n    ], SchedulerProEventSegment.prototype, \"writeStartDate\", null);\n    __decorate([\n        calculate('startOffset')\n    ], SchedulerProEventSegment.prototype, \"calculateStartOffset\", null);\n    __decorate([\n        calculate('endOffset')\n    ], SchedulerProEventSegment.prototype, \"calculateEndOffset\", null);\n    __decorate([\n        calculate('percentDone')\n    ], SchedulerProEventSegment.prototype, \"calculatePercentDone\", null);\n    __decorate([\n        calculate('startPercentDone')\n    ], SchedulerProEventSegment.prototype, \"calculateMinPercent\", null);\n    __decorate([\n        calculate('endPercentDone')\n    ], SchedulerProEventSegment.prototype, \"calculateMaxPercent\", null);\n    __decorate([\n        calculate('manuallyScheduled')\n    ], SchedulerProEventSegment.prototype, \"calculateManuallyScheduled\", null);\n    return SchedulerProEventSegment;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasProposedValue, PreviousValueOf, ProposedArgumentsOf, ProposedOrPrevious, ProposedOrPreviousValueOf, ProposedValueOf, WriteSeveral } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { CalculatedValueGen } from \"../../../../ChronoGraph/chrono/Identifier.js\";\nimport { TombStone } from \"../../../../ChronoGraph/chrono/Quark.js\";\nimport { Mixin } from '../../../../ChronoGraph/class/Mixin.js';\nimport { CycleDescription, CycleResolution, Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { calculate, field, write } from '../../../../ChronoGraph/replica/Entity.js';\nimport { FieldIdentifier } from \"../../../../ChronoGraph/replica/Identifier.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { Direction, TimeUnit } from '../../../scheduling/Types.js';\nimport { MAX_DATE } from \"../../../util/Constants.js\";\nimport { durationFormula, DurationVar, endDateFormula, EndDateVar, startDateFormula, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { HasPercentDoneMixin } from \"./HasPercentDoneMixin.js\";\nimport { SchedulerProEventSegment } from './SchedulerProEventSegment.js';\nimport { SchedulerProHasAssignmentsMixin } from \"./SchedulerProHasAssignmentsMixin.js\";\nexport const SegmentsVar = Symbol('SegmentsVar');\nexport const segmentsConverter = (value, data, record) => record.processSegmentsValue(value);\nexport const startDateByEndDateAndSegmentsFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([EndDateVar, SegmentsVar])\n});\nexport const endDateByStartDateAndSegmentsFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([StartDateVar, SegmentsVar])\n});\nexport const durationByStartDateAndEndDateAndSegmentsFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartDateVar, EndDateVar, SegmentsVar])\n});\nexport const SEDSGGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar, SegmentsVar]),\n    formulas: new Set([\n        endDateByStartDateAndSegmentsFormula,\n        startDateByEndDateAndSegmentsFormula,\n        // durationByStartDateAndEndDateAndSegmentsFormula,\n        startDateFormula,\n        endDateFormula,\n        durationFormula\n    ])\n});\nexport const SEDSGForwardCycleResolution = CycleResolution.new({\n    description: SEDSGGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula, endDateByStartDateAndSegmentsFormula])\n});\nexport const SEDSGBackwardCycleResolution = CycleResolution.new({\n    description: SEDSGGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula, startDateByEndDateAndSegmentsFormula])\n});\nexport class SEDSGDispatcherIdentifier extends FieldIdentifier.mix(CalculatedValueGen) {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        return resolution1.get(StartDateVar) === resolution2.get(StartDateVar)\n            && resolution1.get(EndDateVar) === resolution2.get(EndDateVar)\n            && resolution1.get(DurationVar) === resolution2.get(DurationVar)\n            && resolution1.get(SegmentsVar) === resolution2.get(SegmentsVar);\n    }\n}\nexport function compareSegmentsArray(a, b) {\n    if (!a && !b)\n        return true;\n    if (this._skipSegmentsIsEqual)\n        return false;\n    if (!a && b || a && !b)\n        return false;\n    if (a.length !== b.length)\n        return false;\n    return a.every((segment, index) => compareSegments(segment, b[index]));\n}\nexport const compareSegments = (a, b) => {\n    if (a === b)\n        return true;\n    const segmentModel = a.isModel ? a : b;\n    const fieldMap = segmentModel.fieldMap;\n    const aStart = a.startDate instanceof Date ? a.startDate.getTime() : fieldMap.startDate.convert(a.startDate).getTime();\n    const bStart = b.startDate instanceof Date ? b.startDate.getTime() : fieldMap.startDate.convert(b.startDate).getTime();\n    const aEnd = a.endDate instanceof Date ? a.endDate.getTime() : fieldMap.endDate.convert(a.endDate).getTime();\n    const bEnd = b.endDate instanceof Date ? b.endDate.getTime() : fieldMap.endDate.convert(b.endDate).getTime();\n    return aStart === bStart && aEnd === bEnd;\n};\nexport class SplitEventMixin extends Mixin([SchedulerProHasAssignmentsMixin, HasPercentDoneMixin], (base) => {\n    class SplitEventMixin extends base {\n        constructor() {\n            super(...arguments);\n            this._segmentGeneration = {};\n        }\n        static get $name() {\n            return 'SplitEventMixin';\n        }\n        construct() {\n            this.segmentModelClass = this.getDefaultSegmentModelClass();\n            super.construct(...arguments);\n        }\n        get rawModifications() {\n            let data = super.rawModifications;\n            // include segment changes\n            if (this.segments && (!data || !('segments' in data))) {\n                for (const segment of this.segments) {\n                    if (segment.rawModifications) {\n                        data = data || {};\n                        data.segments = this.getFieldPersistentValue('segments');\n                        break;\n                    }\n                }\n            }\n            return data;\n        }\n        clearChanges(includeDescendants, removeFromStoreChanges, changes) {\n            for (const segment of this.segments || []) {\n                segment.clearChanges(includeDescendants, removeFromStoreChanges, null);\n            }\n            super.clearChanges(includeDescendants, removeFromStoreChanges, changes);\n        }\n        getDefaultSegmentModelClass() {\n            return SchedulerProEventSegment;\n        }\n        *prepareDispatcher(YIELD) {\n            const dispatcher = yield* super.prepareDispatcher(YIELD);\n            if (yield* this.hasSegmentChangesProposed()) {\n                dispatcher.addProposedValueFlag(SegmentsVar);\n            }\n            return dispatcher;\n        }\n        cycleResolutionContext(Y) {\n            const direction = Y(this.$.direction);\n            return direction === Direction.Forward || direction === Direction.None ? SEDSGForwardCycleResolution : SEDSGBackwardCycleResolution;\n        }\n        *hasSegmentChangesProposed() {\n            const proposedSegments = yield ProposedValueOf(this.$.segments);\n            let result = false;\n            if (yield HasProposedValue(this.$.segments)) {\n                result = Boolean(proposedSegments);\n            }\n            const segments = yield ProposedOrPreviousValueOf(this.$.segments);\n            if (!segments)\n                return false;\n            for (const segment of segments) {\n                // <remove-on-release>\n                // TODO: Add offsets here\n                // </remove-on-release>\n                const startDateProposed = yield HasProposedValue(segment.$.startDate);\n                const endDateProposed = yield HasProposedValue(segment.$.endDate);\n                const durationProposed = yield HasProposedValue(segment.$.duration);\n                if (startDateProposed || endDateProposed || durationProposed)\n                    result = true;\n            }\n            return result;\n        }\n        writeSegments(me, transaction, quark, value) {\n            // if (!transaction.baseRevision.hasIdentifier(me) && value == null) return\n            const oldSegmentsQuarkValue = transaction.getLatestEntryFor(me)?.getValue();\n            const oldSegments = oldSegmentsQuarkValue !== TombStone ? oldSegmentsQuarkValue ?? [] : [];\n            const oldSegmentsSet = new Set(oldSegments);\n            const newSegments = value ?? [];\n            const newSegmentsSet = new Set(newSegments);\n            this.project.ion({\n                // remove them from the graph, only the ones not listed in the new segments array,\n                // and only after commit finalization, otherwise test fails\n                // we don't know why, possibly because in the `calculateSegments` we use `previousValue` of `segments` atom\n                commitFinalized: () => graph.removeEntities(oldSegments.filter(segment => !newSegmentsSet.has(segment))),\n                once: true\n            });\n            me.constructor.prototype.write.call(this, me, transaction, quark, value);\n            this.$.isSegmented.write.call(this, this.$.isSegmented, transaction, null, Boolean(value?.length));\n            const project = this.project;\n            const graph = project.replica;\n            for (const newSegment of newSegments) {\n                if (!oldSegmentsSet.has(newSegment) && newSegment.graph !== graph) {\n                    newSegment.setProject(project);\n                    graph.addEntity(newSegment);\n                }\n            }\n        }\n        *doWriteSegments(segments, writes) {\n            writes = writes || [];\n            // if one or zero segments left after above merging\n            if (segments.length <= 1) {\n                // calculate the segment duration\n                const duration = segments.length\n                    ? yield* this.getProject().$convertDuration(segments[0].endOffset - segments[0].startOffset, TimeUnit.Millisecond, yield this.$.durationUnit)\n                    : 0;\n                // Apply the event \"duration\" taken from the segment and \"segments\" field as NULL\n                // (w/o pushing the duration value the code will tend to recalculate end date instead\n                // using exiting duration value on the event)\n                writes.push({\n                    identifier: this.$.duration,\n                    proposedArgs: [duration, null]\n                });\n                segments = null;\n            }\n            writes.push({\n                identifier: this.$.segments,\n                proposedArgs: [segments]\n            });\n            yield WriteSeveral(writes);\n        }\n        *calculateSegments() {\n            const dispatcher = yield this.$.dispatcher;\n            const { graph, project } = this;\n            const previousValue = yield PreviousValueOf(this.$.segments);\n            let segments = yield ProposedOrPrevious;\n            const toRemove = [];\n            let hasChanges = false;\n            if (segments) {\n                const result = new Set();\n                let previousSegment = null;\n                let keepDuration = false;\n                const { baseRevision } = graph.$activeTransaction;\n                for (const segment of segments) {\n                    const startOffset = yield segment.$.startOffset;\n                    const endOffset = yield segment.$.endOffset;\n                    // detect segment moving ..but ignore data loading stage\n                    const startDateProposedArgs = baseRevision.hasIdentifier(segment.$.startDate)\n                        && (yield ProposedArgumentsOf(segment.$.startDate));\n                    const endDateProposedArgs = baseRevision.hasIdentifier(segment.$.endDate)\n                        && (yield ProposedArgumentsOf(segment.$.endDate));\n                    keepDuration = keepDuration || startDateProposedArgs?.[0] || endDateProposedArgs?.[0];\n                    // get rid of zero duration segment\n                    if (startOffset === endOffset) {\n                        //<debug>\n                        globalThis['DEBUG'] && console.log(`WARNING: Zero duration segment (#${segment.id}) offsets: ${startOffset}, ${endOffset}`);\n                        //</debug>\n                        toRemove.push(segment);\n                    }\n                    // if a segment overlaps the previous one\n                    else if (previousSegment && startOffset <= (previousSegment.endOffset)) {\n                        const prevEndOffset = previousSegment.endOffset;\n                        // remove the segment we'll make a new one representing the segments union\n                        toRemove.push(segment);\n                        // if previous one is in the graph (not a \"union\" we just made)\n                        if (previousSegment.graph) {\n                            // remove it\n                            toRemove.push(previousSegment);\n                            const previousSegmentStartOffset = previousSegment.startOffset;\n                            const previousSegmentEndOffset = keepDuration\n                                // if moving a segment then move its further neighbours\n                                ? endOffset + prevEndOffset - startOffset\n                                // otherwise just combine intersected segments by building a new [min start, max end] segment\n                                : Math.max(endOffset, prevEndOffset);\n                            // <remove-on-release>\n                            // TODO: Need to copy other values too ..for some reason copy() method usage here doesn't work\n                            // </remove-on-release>\n                            // @ts-ignore\n                            const cls = previousSegment.cls;\n                            // make a new segment\n                            previousSegment = this.segmentModelClass.new({\n                                event: this,\n                                cls: cls,\n                                startOffset: previousSegmentStartOffset,\n                                endOffset: previousSegmentEndOffset\n                            });\n                        }\n                        else {\n                            previousSegment.endOffset = keepDuration\n                                // if moving a segment then move its further neighbours\n                                ? endOffset + previousSegment.endOffset - startOffset\n                                // otherwise just combine intersected segments by building a new [min start, max end] segment\n                                : Math.max(endOffset, previousSegment.endOffset);\n                        }\n                    }\n                    // a valid segment\n                    else {\n                        if (previousSegment) {\n                            result.add(previousSegment);\n                        }\n                        previousSegment = segment;\n                    }\n                }\n                if (previousSegment) {\n                    result.add(previousSegment);\n                }\n                if (result.size === 1) {\n                    toRemove.push(...result);\n                }\n                hasChanges = toRemove.length > 0;\n                if (hasChanges) {\n                    segments = Array.from(result);\n                }\n                // fill previousSegment/nextSegment properties\n                segments.reduce((previousSegment, segment, index) => {\n                    if (previousSegment) {\n                        previousSegment.nextSegment = segment;\n                    }\n                    segment.previousSegment = previousSegment;\n                    segment.segmentIndex = index;\n                    return segment;\n                }, null);\n                if (segments.length) {\n                    segments[segments.length - 1].nextSegment = null;\n                }\n            }\n            // If we used to have segments - need to remove them from the graph\n            else if (previousValue) {\n                toRemove.push(...previousValue);\n            }\n            // if we got segments to cleanup\n            if (toRemove.length) {\n                // detach segments that are meant to get removed from the graph\n                toRemove.forEach(segment => segment.event = null);\n                project.ion({\n                    commitFinalized: () => graph.removeEntities(toRemove),\n                    once: true\n                });\n            }\n            // If we have changed segments\n            if (hasChanges) {\n                yield* this.doWriteSegments(segments);\n            }\n            segments = segments?.length > 1 ? segments : null;\n            return segments;\n        }\n        *calculateAdjustedSegments() {\n            const dispatcher = yield this.$.dispatcher;\n            let segments = yield this.$.segments;\n            const startDate = yield this.$.startDate;\n            const endDate = yield this.$.endDate;\n            const duration = yield this.$.duration;\n            let value = yield ProposedOrPrevious;\n            if (segments) {\n                const project = this.project;\n                const graph = this.graph;\n                const toRemove = [];\n                const toWrite = [];\n                let spliceIndex = -1;\n                // Iterate segments starting from trailing ones\n                for (let i = segments.length - 1; i >= 0; i--) {\n                    const segment = segments[i];\n                    const segmentStartDate = yield segment.$.startDate;\n                    const segmentEndDate = yield segment.$.endDate;\n                    // If the segment starts after the event finishes - cut the segment\n                    if (segmentStartDate > endDate) {\n                        toRemove.push(segment);\n                        spliceIndex = i;\n                    }\n                    else {\n                        // If last segment end is not aligned with the event end - adjust it\n                        if (segmentEndDate.getTime() !== endDate.getTime()) {\n                            const durationMs = segment.endOffset + (endDate.getTime() - segmentEndDate.getTime()) - segment.startOffset;\n                            const duration = yield* project.$convertDuration(durationMs, TimeUnit.Millisecond, yield segment.$.durationUnit);\n                            // write new duration, endDate and endOffset to the segment\n                            toWrite.push({\n                                identifier: segment.$.duration,\n                                proposedArgs: [duration, null]\n                            }, {\n                                identifier: segment.$.endDate,\n                                proposedArgs: [endDate, false]\n                            }, {\n                                identifier: segment.$.endOffset,\n                                proposedArgs: [segment.endOffset + (endDate.getTime() - segmentEndDate.getTime())]\n                            });\n                        }\n                        // stop iteration\n                        break;\n                    }\n                }\n                let hasChanges = false;\n                // if we have trailing segment(s) to cut\n                if (spliceIndex > -1) {\n                    hasChanges = true;\n                    segments.splice(spliceIndex);\n                    if (segments.length) {\n                        segments[segments.length - 1].nextSegment = null;\n                    }\n                    // Will remove the segment(s) from the graph later ..to avoid exceptions\n                    project.ion({\n                        commitFinalized: () => graph.removeEntities(toRemove),\n                        once: true\n                    });\n                }\n                let segmentsSnapshot = '';\n                if (segments) {\n                    segmentsSnapshot = this.getSegmentsSnapshot(segments);\n                }\n                if ( /*this._lastSegmentsSnapshot &&*/segmentsSnapshot !== this._lastSegmentsSnapshot) {\n                    hasChanges = true;\n                    segments = segments ? segments.slice() : segments;\n                    this._lastSegmentsSnapshot = segmentsSnapshot;\n                }\n                // this._lastSegmentsSnapshot  = segmentsSnapshot\n                // If we have changes to write\n                if (hasChanges) {\n                    yield* this.doWriteSegments(segments, toWrite);\n                }\n            }\n            return value;\n        }\n        getSegmentsSnapshot(segments) {\n            segments = segments || this.segments;\n            return segments?.map(segment => '' + segment.startOffset + '-' + segment.startDate?.getTime() + '-' + segment.endOffset + '-' + segment.endDate?.getTime()).join(';');\n        }\n        processSegmentsValue(value) {\n            // by default return the value as is\n            let result = value;\n            // if segments are specified for the task\n            if (value) {\n                // for (let segment of value) {\n                for (let i = 0; i < value.length; i++) {\n                    const segment = value[i];\n                    const record = (segment.isModel ? segment : this.segmentModelClass.new(segment));\n                    // don't overwrite the existing property, because this method\n                    // is called as part of the `copy()` call, where\n                    //     copy['segments'] = this['segments']\n                    // happens and `copy` event is assigned back to segments from the source\n                    if (!record.event)\n                        record.event = this;\n                    value[i] = record;\n                }\n            }\n            return result;\n        }\n        *calculateStartDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(StartDateVar);\n            let result;\n            if (resolution === startDateByEndDateAndSegmentsFormula.formulaId) {\n                result = yield* this.calculateStartDateBySegments();\n            }\n            else {\n                result = yield* super.calculateStartDate();\n            }\n            return result;\n        }\n        *calculateStartDateBySegments() {\n            const dispatcher = yield this.$.dispatcher;\n            const segments = yield this.$.segments;\n            const endDate = yield this.$.endDate;\n            let result;\n            if (segments) {\n                const lastSegment = segments[segments.length - 1];\n                const lastSegmentEndOffset = yield lastSegment.$.endOffset;\n                const rawDate = yield* this.calculateProjectedXDateWithDuration(endDate, false, lastSegmentEndOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n                const manuallyScheduled = yield this.$.manuallyScheduled;\n                result = manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                    ? rawDate\n                    : yield* this.skipNonWorkingTime(rawDate, true);\n            }\n            return result;\n        }\n        *calculateEndDateBySegments() {\n            const dispatcher = yield this.$.dispatcher;\n            const segments = yield this.$.segments;\n            const startDate = yield this.$.startDate;\n            let result;\n            if (segments) {\n                const lastSegment = segments[segments.length - 1];\n                const lastSegmentEndOffset = yield lastSegment.$.endOffset;\n                const rawDate = yield* this.calculateProjectedXDateWithDuration(startDate, true, lastSegmentEndOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n                const manuallyScheduled = yield this.$.manuallyScheduled;\n                result = manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                    ? rawDate\n                    : yield* this.skipNonWorkingTime(rawDate, false);\n            }\n            return result;\n        }\n        *calculateEndDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(EndDateVar);\n            let result;\n            if (resolution === endDateByStartDateAndSegmentsFormula.formulaId) {\n                result = yield* this.calculateEndDateBySegments();\n            }\n            else {\n                result = yield* super.calculateEndDate();\n            }\n            return result;\n        }\n        *calculateDurationProposed() {\n            let result;\n            if (yield* this.hasSegmentChangesProposed()) {\n                result = yield* this.calculateDurationBySegments();\n            }\n            else {\n                result = yield* super.calculateDurationProposed();\n            }\n            return result;\n        }\n        *skipNonWorkingTime(date, isForward = true, iteratorOptions) {\n            if (!date)\n                return null;\n            iteratorOptions = Object.assign({ ignoreSegments: true }, iteratorOptions);\n            return yield* super.skipNonWorkingTime(date, isForward, iteratorOptions);\n        }\n        *calculateDurationBySegments() {\n            let duration;\n            const dispatcher = yield this.$.dispatcher;\n            const durationUnit = yield this.$.durationUnit;\n            const segments = yield this.$.segments;\n            if (segments) {\n                let durationMs = 0;\n                // collect segments duration in milliseconds\n                for (const segment of segments) {\n                    durationMs += segment.endOffset - segment.startOffset;\n                }\n                duration = yield* this.getProject().$convertDuration(durationMs, TimeUnit.Millisecond, durationUnit);\n            }\n            return duration;\n        }\n        *forEachAvailabilityInterval(options, func) {\n            const calendar = yield this.$.effectiveCalendar;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;\n            const isForward = options.isForward !== false;\n            const ignoreResourceCalendar = (yield this.$.ignoreResourceCalendar) || options.ignoreResourceCalendar || !assignmentsByCalendar.size;\n            const maxRange = this.getProject().maxCalendarRange;\n            let ignoreSegments = options.ignoreSegments;\n            let sign = 1;\n            let currentSegment, currentOffsetMs, currentSegmentDurationMs, segments, currentSegmentEndOffset;\n            if (!ignoreSegments) {\n                segments = yield this.$.segments;\n                ignoreSegments = ignoreSegments || !segments;\n                if (!ignoreSegments) {\n                    // clone segment array since we're going to call shift()/pop() on it\n                    segments = segments.slice();\n                    if (isForward) {\n                        currentSegment = segments.shift();\n                        currentOffsetMs = 0;\n                        sign = 1;\n                        // open the last segment end border\n                        currentSegmentEndOffset = currentSegment.nextSegment ? currentSegment.endOffset : MAX_DATE.getTime();\n                    }\n                    else {\n                        currentSegment = segments.pop();\n                        currentOffsetMs = currentSegment.endOffset;\n                        sign = -1;\n                        currentSegmentEndOffset = currentSegment.endOffset;\n                    }\n                    currentSegmentDurationMs = currentSegmentEndOffset - currentSegment.startOffset;\n                }\n            }\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const project = this.getProject();\n            return effectiveCalendarsCombination.forEachAvailabilityInterval(Object.assign({ maxRange }, options), (intervalStartDate, intervalEndDate, calendarCacheIntervalMultiple) => {\n                const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                if (calendarsStatus.get(calendar)\n                    && (ignoreResourceCalendar\n                        || workCalendars.some((calendar) => assignmentsByCalendar.has(calendar))\n                        || (manuallyScheduled && !project.skipNonWorkingTimeInDurationWhenSchedulingManually))) {\n                    if (ignoreSegments) {\n                        return func(intervalStartDate, intervalEndDate, calendarCacheIntervalMultiple);\n                    }\n                    // take segments into account while iterating\n                    else {\n                        const startDateN = intervalStartDate.getTime();\n                        let intervalDuration = intervalEndDate.getTime() - intervalStartDate.getTime();\n                        // <remove-on-release>\n                        // TODO: check if this should be moved down into the segments iteration\n                        // </remove-on-release>\n                        if (this.getProject().adjustDurationToDST) {\n                            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                            intervalDuration += dstDiff * 60 * 1000;\n                        }\n                        let intervalStartOffset, intervalEndOffset;\n                        if (isForward) {\n                            intervalStartOffset = currentOffsetMs;\n                            intervalEndOffset = currentOffsetMs + intervalDuration;\n                        }\n                        else {\n                            intervalStartOffset = currentOffsetMs - intervalDuration;\n                            intervalEndOffset = currentOffsetMs;\n                        }\n                        while (currentSegment && intervalStartOffset <= currentSegmentEndOffset && intervalEndOffset > currentSegment.startOffset) {\n                            // get the intersection of the current segment w/ the current interval\n                            const callStartOffset = Math.max(intervalStartOffset, currentSegment.startOffset);\n                            const callEndOffset = Math.min(intervalEndOffset, currentSegmentEndOffset);\n                            const callStartDate = new Date(startDateN + callStartOffset - intervalStartOffset);\n                            const callEndDate = new Date(startDateN + callEndOffset - intervalStartOffset);\n                            const callResult = func(callStartDate, callEndDate, calendarCacheIntervalMultiple);\n                            if (callResult === false)\n                                return false;\n                            // reduce the segment duration left by the intersection duration\n                            currentSegmentDurationMs -= callEndDate.getTime() - callStartDate.getTime();\n                            // if no segment duration left\n                            if (!currentSegmentDurationMs) {\n                                // get next segment\n                                currentSegment = isForward ? segments.shift() : segments.pop();\n                                if (currentSegment) {\n                                    // the last segment end border should not be taken into account (in forward mode)\n                                    currentSegmentEndOffset = !isForward || currentSegment.nextSegment ? currentSegment.endOffset : MAX_DATE.getTime();\n                                    // get its duration to distribute\n                                    currentSegmentDurationMs = currentSegmentEndOffset - currentSegment.startOffset;\n                                }\n                            }\n                            // if there is undistributed duration left of the current segment => iterate to the next interval\n                            else {\n                                break;\n                            }\n                        }\n                        currentOffsetMs += sign * intervalDuration;\n                    }\n                }\n            });\n        }\n        *useEventAvailabilityIterator() {\n            const isSegmented = yield this.$.isSegmented;\n            if (isSegmented)\n                return true;\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            // always use availability iterator, unless the event is manually scheduled\n            return !manuallyScheduled;\n        }\n        /**\n         * Returns a segment that is ongoing on the provided date.\n         * @param  date Date to find an ongoing segment on\n         * @param  [segments] List of segments to check. When not provided the event segments is used\n         * @return Ongoing segment\n         */\n        getSegmentByDate(date, segments) {\n            segments = segments || this.getSegments();\n            if (segments) {\n                const index = this.getSegmentIndexByDate(date, segments);\n                return segments[index];\n            }\n        }\n        getSegmentIndexByDate(date, segments) {\n            segments = segments || this.getSegments();\n            return segments ? segments.findIndex(segment => date >= segment.startDate && date < segment.endDate) : -1;\n        }\n        /**\n         * The event first segment or null if the event is not segmented.\n         */\n        get firstSegment() {\n            const segments = this.getSegments();\n            return segments ? segments[0] : null;\n        }\n        /**\n         * The event last segment or null if the event is not segmented.\n         */\n        get lastSegment() {\n            const segments = this.getSegments();\n            return segments ? segments[segments.length - 1] : null;\n        }\n        /**\n         * Returns a segment by its index.\n         * @param index The segment index (zero based value).\n         * @return The segment matching the provided index.\n         */\n        getSegment(index) {\n            const segments = this.getSegments();\n            return segments?.[index];\n        }\n        /**\n         * Splits the event.\n         * @param from The date to split this event at.\n         * @param [lag=1] Split duration.\n         * @param [lagUnit] Split duration unit.\n         */\n        async splitToSegments(from, lag = 1, lagUnit) {\n            const project = this.getProject();\n            await project.commitAsync();\n            const me = this;\n            // cannot split:\n            // - if no split date specified\n            // - a summary event\n            // @ts-ignore\n            if (!from || (me.isHasSubEventsMixin && me.childEvents?.size))\n                return;\n            const duration = me.duration;\n            const durationUnit = me.durationUnit;\n            const startDate = me.startDate;\n            const endDate = me.endDate;\n            lagUnit = lagUnit ? DateHelper.normalizeUnit(lagUnit) : durationUnit;\n            // - not scheduled event\n            // - provided date violates the event interval\n            // - a zero duration event\n            if (!startDate || !endDate || (startDate >= from) || (from >= endDate) || !duration)\n                return;\n            const isSegmented = me.isSegmented;\n            let segments = me.segments || [];\n            let segmentToSplit, segmentToSplitIndex;\n            if (isSegmented) {\n                segmentToSplitIndex = me.getSegmentIndexByDate(from, segments);\n                segmentToSplit = segments[segmentToSplitIndex];\n                if (!segmentToSplit)\n                    return;\n            }\n            const splitTarget = segmentToSplit || me;\n            const splitTargetStart = segmentToSplit ? splitTarget.startDate : startDate;\n            const splitTargetDuration = splitTarget.duration;\n            const splitTargetDurationUnit = splitTarget.durationUnit;\n            const prevSegmentDuration = me.run('calculateProjectedDuration', splitTargetStart, from, splitTargetDurationUnit, { ignoreSegments: true });\n            const nextSegmentDuration = splitTargetDuration - prevSegmentDuration;\n            const lagInMs = project.run('$convertDuration', lag, lagUnit, TimeUnit.Millisecond);\n            const nextSegmentStartOffset = lagInMs + me.run('calculateProjectedDuration', startDate, from, TimeUnit.Millisecond, { ignoreSegments: true });\n            // split existing segment\n            if (segmentToSplit) {\n                // adjust its duration\n                segmentToSplit.duration = prevSegmentDuration;\n                const newSegment = this.segmentModelClass.new({\n                    duration: nextSegmentDuration,\n                    durationUnit: splitTargetDurationUnit,\n                    startOffset: nextSegmentStartOffset\n                });\n                segments = segments.slice(0);\n                segments.splice(segmentToSplitIndex + 1, 0, newSegment);\n                me.segments = segments;\n                me.duration = duration;\n                // push next segments forward by the lag duration\n                for (let i = segmentToSplitIndex + 2, l = segments.length; i < l; i++) {\n                    const segment = segments[i];\n                    if (segment) {\n                        segment.startOffset += lagInMs;\n                        segment.endOffset += lagInMs;\n                    }\n                }\n            }\n            // split not segmented event\n            else {\n                const previousSegment = this.segmentModelClass.new({\n                    duration: prevSegmentDuration,\n                    durationUnit: splitTargetDurationUnit,\n                    startOffset: 0\n                });\n                const newSegment = this.segmentModelClass.new({\n                    duration: duration - prevSegmentDuration,\n                    durationUnit: splitTargetDurationUnit,\n                    startOffset: nextSegmentStartOffset\n                });\n                me.duration = duration;\n                me.segments = [previousSegment, newSegment];\n            }\n            return project.commitAsync();\n        }\n        /**\n         * Merges the event segments.\n         * The method merges two provided event segments (and all the segment between them if any).\n         * @param [segment1] First segment to merge.\n         * @param [segment2] Second segment to merge.\n         */\n        async mergeSegments(segment1, segment2) {\n            if (!this.isSegmented)\n                return;\n            segment1 = segment1 || this.firstSegment;\n            segment2 = segment2 || this.lastSegment;\n            if (segment1.startOffset > segment2.startOffset) {\n                let tmp = segment2;\n                segment2 = segment1;\n                segment1 = tmp;\n            }\n            // merging itself will be done automatically inside `calculateSegments`\n            segment1.endDate = segment2.startDate;\n            return this.getProject().commitAsync();\n        }\n        // Override storeFieldChange to support revertChanges for segments field\n        storeFieldChange(key, oldValue) {\n            // if we store segments old value\n            if (key === 'segments' && oldValue) {\n                const result = [];\n                for (const segment of oldValue) {\n                    // get the segment persistable data\n                    const segmentData = segment.toJSON();\n                    // if the segment was changes since the last time we stored segment oldValue\n                    if (!this._segmentGeneration[segment.internalId] || segment.generation > this._segmentGeneration[segment.internalId]) {\n                        // let's use the segment old values\n                        Object.assign(segmentData, segment.meta.modified);\n                    }\n                    result.push(segmentData);\n                    // keep the version of the segment\n                    this._segmentGeneration[segment.internalId] = segment.generation;\n                }\n                oldValue = result;\n            }\n            super.storeFieldChange(key, oldValue);\n        }\n        leaveProject() {\n            const segments = this.segments;\n            if (segments) {\n                this.graph.removeEntities(segments);\n            }\n            super.leaveProject();\n        }\n        endBatch(...args) {\n            this.fieldMap.segments._skipSegmentsIsEqual++;\n            super.endBatch(...args);\n            this.fieldMap.segments._skipSegmentsIsEqual--;\n        }\n        copy(newId = null, deep = null) {\n            const copy = super.copy(newId, deep);\n            // need to clean the `segments` in `data`, otherwise it will be\n            // picked up as \"old value\" by STM during set to `segments`\n            // @ts-ignore\n            copy.data.segments = undefined;\n            if (copy.segments) {\n                copy.segments = copy.segments.map(seg => Object.assign(seg.copy(), { event: copy }));\n            }\n            return copy;\n        }\n    }\n    __decorate([\n        field({ identifierCls: SEDSGDispatcherIdentifier })\n    ], SplitEventMixin.prototype, \"dispatcher\", void 0);\n    __decorate([\n        model_field({\n            type: 'array',\n            isEqual: compareSegmentsArray,\n            convert: segmentsConverter,\n            // @ts-ignore\n            _skipSegmentsIsEqual: 0\n        })\n    ], SplitEventMixin.prototype, \"segments\", void 0);\n    __decorate([\n        field()\n    ], SplitEventMixin.prototype, \"adjustedSegments\", void 0);\n    __decorate([\n        field()\n    ], SplitEventMixin.prototype, \"isSegmented\", void 0);\n    __decorate([\n        write('segments')\n    ], SplitEventMixin.prototype, \"writeSegments\", null);\n    __decorate([\n        calculate('segments')\n    ], SplitEventMixin.prototype, \"calculateSegments\", null);\n    __decorate([\n        calculate('adjustedSegments')\n    ], SplitEventMixin.prototype, \"calculateAdjustedSegments\", null);\n    return SplitEventMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { HasChildrenMixin } from \"../scheduler_basic/HasChildrenMixin.js\";\nimport { SchedulerProHasAssignmentsMixin } from \"./SchedulerProHasAssignmentsMixin.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin provides an `effort` field which does not affect scheduling.\n\n * It also provides various generic methods to schedule task based on effort information. Those are\n * used in other mixins.\n */\nexport class HasEffortMixin extends Mixin([SchedulerProHasAssignmentsMixin, HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class HasEffortMixin extends base {\n        /**\n         * Getter for the effort. Can return effort in given unit, or will use [[effortUnit]].\n         *\n         * @param unit\n         */\n        getEffort(unit) {\n            const effort = this.effort;\n            return unit ? this.getProject().convertDuration(effort, this.effortUnit, unit) : effort;\n        }\n        writeEffort(me, transaction, quark, effort, unit) {\n            if (effort < 0)\n                effort = 0;\n            if (!transaction.baseRevision.hasIdentifier(me) && effort == null)\n                return;\n            if (unit != null && unit !== this.effortUnit) {\n                this.$.effortUnit.write.call(this, this.$.effortUnit, transaction, null, unit);\n            }\n            me.constructor.prototype.write(me, transaction, quark, effort);\n        }\n        setEffortUnit(_value) {\n            throw new Error(\"Use `setEffort` instead\");\n        }\n        /**\n         * The method defines wether the provided child event should roll up its [[effort]] to this summary event or not.\n         * If the method returns `true` the child event [[effort]] is summed up\n         * when calculating this summary event [[effort]].\n         * And if the method returns `false` the child effort is not taken into account.\n         * By default the method returns `true` to include all child event [[effort]] values.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event [[effort]] should be included, `false` if not.\n         */\n        *shouldRollupChildEffort(childEvent) {\n            return true;\n        }\n        /**\n         * Helper method to calculate the total effort of all child events.\n         */\n        *calculateTotalChildrenEffort() {\n            const childEvents = yield this.$.childEvents;\n            const project = this.getProject();\n            let totalEffortMs = 0;\n            for (const childEvent of childEvents) {\n                if (!(yield* this.shouldRollupChildEffort(childEvent)))\n                    continue;\n                const childEventEffortUnit = yield childEvent.$.effortUnit;\n                totalEffortMs += yield* project.$convertDuration(yield childEvent.$.effort, childEventEffortUnit, TimeUnit.Millisecond);\n            }\n            return yield* project.$convertDuration(totalEffortMs, TimeUnit.Millisecond, yield this.$.effortUnit);\n        }\n        *calculateEffort() {\n            const childEvents = yield this.$.childEvents;\n            if (childEvents.size > 0)\n                return yield* this.calculateTotalChildrenEffort();\n            else {\n                const proposed = yield ProposedOrPrevious;\n                return proposed !== undefined ? proposed : yield* this.calculateEffortPure();\n            }\n        }\n        *calculateEffortPure() {\n            const childEvents = yield this.$.childEvents;\n            if (childEvents.size > 0)\n                return yield* this.calculateTotalChildrenEffort();\n            else {\n                return yield* this.calculateProjectedEffort(yield this.$.startDate, yield this.$.endDate);\n            }\n        }\n        *calculateEffortProposed() {\n            return yield ProposedOrPrevious;\n        }\n        *calculateAssignmentUnits(assignment) {\n            return yield* this.calculateAssignmentUnitsProposed(assignment);\n        }\n        *calculateAssignmentUnitsPure(assignment) {\n            return yield* this.calculateUnitsByStartEndAndEffort(assignment);\n        }\n        *calculateAssignmentUnitsProposed(assignment) {\n            return yield ProposedOrPrevious;\n        }\n        *getBaseOptionsForEffortCalculations() {\n            return { ignoreResourceCalendar: false };\n        }\n        *calculateProjectedEffort(startDate, endDate, assignmentsByCalendar) {\n            if (startDate == null || endDate == null || startDate > endDate)\n                return null;\n            if (!assignmentsByCalendar) {\n                assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            }\n            const totalUnitsByCalendar = new Map();\n            for (const [calendar, assignments] of assignmentsByCalendar) {\n                let intervalUnits = 0;\n                for (const assignment of assignments) {\n                    intervalUnits += (yield assignment.$.units);\n                }\n                totalUnitsByCalendar.set(calendar, intervalUnits);\n            }\n            //----------------------\n            let resultN = 0;\n            const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), { startDate, endDate });\n            // if event has no assignments we treat that as it has a special, \"virtual\" assignment with 100 units and\n            // the calendar matching the calendar of the task\n            // we need to ignore resource calendars in this case, since there's no assigned resources\n            if (totalUnitsByCalendar.size === 0) {\n                totalUnitsByCalendar.set(yield this.$.effectiveCalendar, 100);\n                options.ignoreResourceCalendar = true;\n            }\n            yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                let intervalUnits = 0;\n                for (const workingCalendar of workCalendars) {\n                    // the calendar of the event itself will be in the `workCalendars`, but it\n                    // will be missing in the `totalUnitsByCalendar` map, which is fine\n                    intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;\n                }\n                // Effort = Units * Duration\n                resultN += intervalUnits * intervalDuration * 0.01;\n            });\n            return yield* this.getProject().$convertDuration(resultN, TimeUnit.Millisecond, yield this.$.effortUnit);\n        }\n        *calculateUnitsByStartEndAndEffort(_assignment) {\n            const effort = yield this.$.effort, effortUnit = yield this.$.effortUnit, effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);\n            let collectedEffort = 0;\n            const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), { startDate: yield this.$.startDate, endDate: yield this.$.endDate });\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                for (const workingCalendar of workCalendars) {\n                    collectedEffort +=\n                        (assignmentsByCalendar.has(workingCalendar) ? assignmentsByCalendar.get(workingCalendar).length : 0) * intervalDuration;\n                }\n            });\n            return collectedEffort ? 100 * effortMS / collectedEffort : 100;\n        }\n        *calculateProjectedXDateByEffort(baseDate, isForward = true, effort, effortUnit) {\n            effort = effort !== undefined ? effort : yield this.$.effort;\n            effortUnit = effortUnit !== undefined ? effortUnit : yield this.$.effortUnit;\n            const effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);\n            if (baseDate == null || effort == null)\n                return null;\n            let resultN = baseDate.getTime();\n            let leftEffort = effortMS;\n            // early exit if effort is 0\n            if (leftEffort === 0)\n                return new Date(resultN);\n            const calendar = yield this.$.effectiveCalendar;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const totalUnitsByCalendar = new Map();\n            // this flag indicates that there are assignments with non-zero units\n            // if there's no such - event should be scheduled by the simple\n            // `accumulateWorkingTime` call\n            let hasUnits = false;\n            for (const [calendar, assignments] of assignmentsByCalendar) {\n                let intervalUnits = 0;\n                for (const assignment of assignments) {\n                    intervalUnits += yield assignment.$.units;\n                }\n                totalUnitsByCalendar.set(calendar, intervalUnits);\n                if (intervalUnits > 0)\n                    hasUnits = true;\n            }\n            if (hasUnits && (yield* this.useEventAvailabilityIterator())) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: baseDate, isForward } : { endDate: baseDate, isForward });\n                yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                    const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                    const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                    let intervalUnits = 0;\n                    for (const workingCalendar of workCalendars) {\n                        // the calendar of the event itself will be in the `workCalendars`, but it\n                        // will be missing in the `totalUnitsByCalendar` map, which is fine\n                        intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;\n                    }\n                    // Effort = Units * Duration\n                    const intervalEffort = intervalUnits * intervalDuration * 0.01;\n                    if (intervalEffort >= leftEffort) {\n                        // the case where `leftEffort` is 0 initially is covered with the early exit above\n                        // so `leftEffort` is always > 0 here, this means `intervalEffort` has to be > 0 too,\n                        // this in turn means, that to enter the branch `intervalUnits` has to be !== 0,\n                        // so division by it is safe, see below\n                        // resulting date is interval start plus left duration (Duration = Effort / Units)\n                        resultN = isForward\n                            ? intervalStartN + leftEffort / (0.01 * intervalUnits)\n                            : intervalEndN - leftEffort / (0.01 * intervalUnits);\n                        // exit the loop\n                        return false;\n                    }\n                    else {\n                        leftEffort -= intervalEffort;\n                    }\n                });\n                return new Date(resultN);\n            }\n            else {\n                return calendar.accumulateWorkingTime(baseDate, effortMS, isForward).finalDate;\n            }\n        }\n    }\n    __decorate([\n        model_field({ 'type': 'number' /*, defaultValue : 0*/ })\n    ], HasEffortMixin.prototype, \"effort\", void 0);\n    __decorate([\n        model_field({ 'type': 'string', defaultValue: TimeUnit.Hour }, { converter: (unit) => DateHelper.normalizeUnit(unit) || TimeUnit.Hour })\n    ], HasEffortMixin.prototype, \"effortUnit\", void 0);\n    __decorate([\n        write('effort')\n    ], HasEffortMixin.prototype, \"writeEffort\", null);\n    __decorate([\n        calculate('effort')\n    ], HasEffortMixin.prototype, \"calculateEffort\", null);\n    return HasEffortMixin;\n}) {\n}\n", "import { Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { EndDateVar, SEDDispatcher, SEDDispatcherIdentifier, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { TombStone } from \"../../../../ChronoGraph/chrono/Quark.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const EffortVar = Symbol('EffortVar');\nexport const UnitsVar = Symbol('UnitsVar');\n//---------------------------------------------------------------------------------------------------------------------\nexport const effortFormula = Formula.new({\n    output: EffortVar,\n    inputs: new Set([StartDateVar, EndDateVar, UnitsVar])\n});\nexport const unitsFormula = Formula.new({\n    output: UnitsVar,\n    inputs: new Set([StartDateVar, EndDateVar, EffortVar])\n});\nexport const endDateByEffortFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([StartDateVar, EffortVar, UnitsVar])\n});\nexport const startDateByEffortFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([EndDateVar, EffortVar, UnitsVar])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDWUDispatcher extends SEDDispatcher {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDWUDispatcherIdentifier extends SEDDispatcherIdentifier {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        // @ts-ignore\n        return (v1 !== TombStone || v2 === TombStone)\n            // @ts-ignore\n            && (v1 === TombStone || v2 !== TombStone)\n            && resolution1.get(EffortVar) === resolution2.get(EffortVar)\n            && resolution1.get(UnitsVar) === resolution2.get(UnitsVar)\n            && super.equality(v1, v2);\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious, ProposedOrPreviousValueOf } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalculateProposed } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { calculate, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { SchedulingMode } from \"../../../scheduling/Types.js\";\nimport { durationFormula, DurationVar, EndDateVar, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { effortFormula, EffortVar, endDateByEffortFormula, SEDWUDispatcher, SEDWUDispatcherIdentifier, startDateByEffortFormula, unitsFormula, UnitsVar } from \"./HasEffortDispatcher.js\";\nimport { HasEffortMixin } from \"./HasEffortMixin.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin serves as a \"base class\" for the individual scheduling modes mixins: [[FixedDurationMixin]], [[FixedEffortMixin]]\n * and [[FixedUnitsMixin]].\n *\n * Scheduling mode indicates, in which order the duration, effort and assignment units are changed. All these variables\n * are tied together with this invariant (in pseudo-code):\n *\n * ```javascript\n * Effort = Duration * Units\n * ```\n *\n * For example, if we've doubled the effort of the task, we have the choice - we can either double its duration,\n * or double the assignment units, to keep the invariant.\n *\n * We have the same choices for every variable. The scheduling mode\n * basically defines the order in which the \"duration\", \"effort\" and \"units\" variables are updated when one of them changes.\n */\nexport class HasSchedulingModeMixin extends Mixin([HasEffortMixin], (base) => {\n    const superProto = base.prototype;\n    class HasSchedulingModeMixin extends base {\n        *calculateSchedulingMode() {\n            return (yield ProposedOrPrevious) || SchedulingMode.Normal;\n        }\n        *effectiveSchedulingMode() {\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            return assignmentsByCalendar.size > 0 ? yield this.$.schedulingMode : SchedulingMode.Normal;\n        }\n        effectiveSchedulingModeSync(Y) {\n            const assignmentsByCalendar = Y(this.$.assignmentsByCalendar);\n            return assignmentsByCalendar.size > 0 ? Y(this.$.schedulingMode) : SchedulingMode.Normal;\n        }\n        *prepareDispatcher(YIELD) {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);\n                cycleDispatcher.collectInfo(YIELD, this.$.effort, EffortVar);\n                if (yield* this.hasProposedValueForUnits())\n                    cycleDispatcher.addProposedValueFlag(UnitsVar);\n                // units are always available\n                cycleDispatcher.addPreviousValueFlag(UnitsVar);\n                return cycleDispatcher;\n            }\n            else {\n                return yield* superProto.prepareDispatcher.call(this, YIELD);\n            }\n        }\n        dispatcherClass(Y) {\n            const schedulingMode = this.effectiveSchedulingModeSync(Y);\n            if (schedulingMode !== SchedulingMode.Normal) {\n                return SEDWUDispatcher;\n            }\n            else {\n                return superProto.dispatcherClass.call(this, Y);\n            }\n        }\n        buildProposedDispatcher(me, quark, transaction) {\n            const dispatcher = superProto.buildProposedDispatcher.call(this, me, quark, transaction);\n            // <remove-on-release>\n            // TODO: Should check for dispatcher class probably\n            // </remove-on-release>\n            dispatcher.addPreviousValueFlag(EffortVar);\n            dispatcher.addPreviousValueFlag(UnitsVar);\n            return dispatcher;\n        }\n        *calculateAssignmentUnits(assignment) {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(UnitsVar);\n                if (formulaId === CalculateProposed) {\n                    return yield* this.calculateAssignmentUnitsProposed(assignment);\n                }\n                else if (formulaId === unitsFormula.formulaId) {\n                    return yield* this.calculateAssignmentUnitsPure(assignment);\n                }\n                else {\n                    throw new Error(\"Unknown formula for `units`\");\n                }\n            }\n            else {\n                return yield* superProto.calculateAssignmentUnits.call(this, assignment);\n            }\n        }\n        *calculateEffort() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(EffortVar);\n                if (formulaId === CalculateProposed) {\n                    return yield* this.calculateEffortProposed();\n                }\n                else if (formulaId === effortFormula.formulaId) {\n                    return yield* this.calculateEffortPure();\n                }\n                else {\n                    throw new Error(\"Unknown formula for `effort`\");\n                }\n            }\n            else {\n                return yield* superProto.calculateEffort.call(this);\n            }\n        }\n        *calculateStartDate() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(StartDateVar);\n                if (formulaId === startDateByEffortFormula.formulaId) {\n                    return yield* this.calculateProjectedXDateByEffort(yield this.$.endDate, false);\n                }\n                else {\n                    return yield* superProto.calculateStartDate.call(this);\n                }\n            }\n            else {\n                return yield* superProto.calculateStartDate.call(this);\n            }\n        }\n        *calculateEndDate() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(EndDateVar);\n                if (formulaId === endDateByEffortFormula.formulaId) {\n                    return yield* this.calculateProjectedXDateByEffort(yield this.$.startDate, true);\n                }\n                else {\n                    return yield* superProto.calculateEndDate.call(this);\n                }\n            }\n            else {\n                return yield* superProto.calculateEndDate.call(this);\n            }\n        }\n        *calculateEffectiveDuration() {\n            const dispatch = yield this.$.dispatcher;\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            const durationResolution = dispatch.resolution.get(DurationVar);\n            const effortResolution = dispatch.resolution.get(EffortVar);\n            let effectiveDurationToUse;\n            if (durationResolution === durationFormula.formulaId && schedulingMode != SchedulingMode.Normal) {\n                const proposedOrPreviousStartDate = yield ProposedOrPreviousValueOf(this.$.startDate);\n                const proposedOrPreviousEndDate = yield ProposedOrPreviousValueOf(this.$.endDate);\n                const startDateResolution = dispatch.resolution.get(StartDateVar);\n                const endDateResolution = dispatch.resolution.get(EndDateVar);\n                const effortDriven = yield this.$.effortDriven;\n                if (proposedOrPreviousEndDate && startDateResolution === startDateByEffortFormula.formulaId) {\n                    effectiveDurationToUse = yield* this.calculateProjectedDuration(yield* this.calculateProjectedXDateByEffort(proposedOrPreviousEndDate, false), proposedOrPreviousEndDate);\n                }\n                else if (proposedOrPreviousStartDate && endDateResolution === endDateByEffortFormula.formulaId) {\n                    effectiveDurationToUse = yield* this.calculateProjectedDuration(proposedOrPreviousStartDate, yield* this.calculateProjectedXDateByEffort(proposedOrPreviousStartDate, true));\n                }\n                else if (proposedOrPreviousStartDate && proposedOrPreviousEndDate\n                    || !proposedOrPreviousStartDate && !proposedOrPreviousEndDate) {\n                    effectiveDurationToUse = yield* superProto.calculateEffectiveDuration.call(this);\n                }\n            }\n            else\n                effectiveDurationToUse = yield* superProto.calculateEffectiveDuration.call(this);\n            return effectiveDurationToUse;\n        }\n    }\n    __decorate([\n        model_field({ 'type': 'boolean', defaultValue: false })\n    ], HasSchedulingModeMixin.prototype, \"effortDriven\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: SchedulingMode.Normal }, { sync: true })\n    ], HasSchedulingModeMixin.prototype, \"schedulingMode\", void 0);\n    __decorate([\n        field({ identifierCls: SEDWUDispatcherIdentifier })\n    ], HasSchedulingModeMixin.prototype, \"dispatcher\", void 0);\n    __decorate([\n        calculate('schedulingMode')\n    ], HasSchedulingModeMixin.prototype, \"calculateSchedulingMode\", null);\n    __decorate([\n        calculate('effort')\n    ], HasSchedulingModeMixin.prototype, \"calculateEffort\", null);\n    __decorate([\n        calculate('startDate')\n    ], HasSchedulingModeMixin.prototype, \"calculateStartDate\", null);\n    __decorate([\n        calculate('endDate')\n    ], HasSchedulingModeMixin.prototype, \"calculateEndDate\", null);\n    return HasSchedulingModeMixin;\n}) {\n}\n", "import { CycleResolution, CycleDescription } from \"../../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { durationFormula, DurationVar, endDateFormula, EndDateVar, startDateFormula, StartDateVar } from \"../../scheduler_basic/BaseEventDispatcher.js\";\nimport { effortFormula, EffortVar, unitsFormula, UnitsVar } from \"../HasEffortDispatcher.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const fixedDurationSEDWUGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),\n    formulas: new Set([\n        startDateFormula,\n        endDateFormula,\n        durationFormula,\n        unitsFormula,\n        effortFormula,\n    ])\n});\nexport const fixedDurationAndEffortSEDWUGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),\n    formulas: new Set([\n        startDateFormula,\n        endDateFormula,\n        durationFormula,\n        unitsFormula,\n    ])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport const fixedDurationSEDWUForwardNonEffortDriven = CycleResolution.new({\n    description: fixedDurationSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula, effortFormula])\n});\nexport const fixedDurationSEDWUForwardEffortDriven = CycleResolution.new({\n    description: fixedDurationAndEffortSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula, unitsFormula])\n});\nexport const fixedDurationSEDWUBackwardNonEffortDriven = CycleResolution.new({\n    description: fixedDurationSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula, effortFormula])\n});\nexport const fixedDurationSEDWUBackwardEffortDriven = CycleResolution.new({\n    description: fixedDurationAndEffortSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula, unitsFormula])\n});\n", "import { HasProposedValue } from \"../../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../../ChronoGraph/class/BetterMixin.js\";\nimport { Direction, SchedulingMode } from \"../../../../scheduling/Types.js\";\nimport { EffortVar, UnitsVar } from \"../HasEffortDispatcher.js\";\nimport { HasSchedulingModeMixin } from \"../HasSchedulingModeMixin.js\";\nimport { fixedDurationSEDWUBackwardEffortDriven, fixedDurationSEDWUBackwardNonEffortDriven, fixedDurationSEDWUForwardEffortDriven, fixedDurationSEDWUForwardNonEffortDriven } from \"./FixedDurationDispatcher.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin provides the fixed duration scheduling mode facility. The scheduling mode is controlled with the\n * [[HasSchedulingModeMixin.schedulingMode]] field.\n *\n * See [[HasSchedulingModeMixin]] for more details.\n *\n * In this mode, the duration of the task remains \"fixed\" as the name suggest. It is changed only if there's no other options,\n * for example if both \"effort\" and \"units\" has changed. In other cases, some other variable is updated.\n *\n * If the [[HasSchedulingModeMixin.effortDriven]] flag is enabled, effort variable becomes \"fixed\" as well, so normally the \"units\"\n * variable will change. If that flag is disabled, then \"effort\" will be changed.\n */\nexport class FixedDurationMixin extends Mixin([HasSchedulingModeMixin], (base) => {\n    const superProto = base.prototype;\n    class FixedDurationMixin extends base {\n        *prepareDispatcher(YIELD) {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode === SchedulingMode.FixedDuration) {\n                const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);\n                const effortDriven = yield this.$.effortDriven;\n                if (effortDriven)\n                    cycleDispatcher.addKeepIfPossibleFlag(EffortVar);\n                if (yield HasProposedValue(this.$.assigned)) {\n                    // for effort driven case, we treat adding/removing of assignments as changing effort\n                    // instead of units (this will trigger both, but units formula will win in presence of effort change)\n                    if (effortDriven) {\n                        cycleDispatcher.addProposedValueFlag(EffortVar);\n                    }\n                    else {\n                        cycleDispatcher.addProposedValueFlag(UnitsVar);\n                    }\n                }\n                return cycleDispatcher;\n            }\n            else {\n                return yield* superProto.prepareDispatcher.call(this, YIELD);\n            }\n        }\n        cycleResolutionContext(Y) {\n            const schedulingMode = this.effectiveSchedulingModeSync(Y);\n            if (schedulingMode === SchedulingMode.FixedDuration) {\n                const direction = Y(this.$.direction);\n                const effortDriven = Y(this.$.effortDriven);\n                if (direction === Direction.Forward || direction === Direction.None) {\n                    return effortDriven ? fixedDurationSEDWUForwardEffortDriven : fixedDurationSEDWUForwardNonEffortDriven;\n                }\n                else {\n                    return effortDriven ? fixedDurationSEDWUBackwardEffortDriven : fixedDurationSEDWUBackwardNonEffortDriven;\n                }\n            }\n            else {\n                return superProto.cycleResolutionContext.call(this, Y);\n            }\n        }\n        *getBaseOptionsForDurationCalculations() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode === SchedulingMode.FixedDuration) {\n                return { ignoreResourceCalendar: true };\n            }\n            else {\n                return yield* superProto.getBaseOptionsForDurationCalculations.call(this);\n            }\n        }\n    }\n    return FixedDurationMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerBasicEvent } from \"../scheduler_basic/SchedulerBasicEvent.js\";\nimport { ConstrainedEarlyEventMixin } from \"./ConstrainedEarlyEventMixin.js\";\nimport { HasDateConstraintMixin } from \"./HasDateConstraintMixin.js\";\nimport { HasPercentDoneMixin } from \"./HasPercentDoneMixin.js\";\nimport { ScheduledByDependenciesEarlyEventMixin } from \"./ScheduledByDependenciesEarlyEventMixin.js\";\nimport { SchedulerProHasAssignmentsMixin } from \"./SchedulerProHasAssignmentsMixin.js\";\nimport { SplitEventMixin } from \"./SplitEventMixin.js\";\nimport { HasEffortMixin } from \"./HasEffortMixin.js\";\nimport { HasSchedulingModeMixin } from \"./HasSchedulingModeMixin.js\";\nimport { FixedDurationMixin } from \"./scheduling_modes/FixedDurationMixin.js\";\n// import { ConstrainedByParentMixin } from \"../gantt/ConstrainedByParentMixin.js\"\n/**\n * This is an event class, [[SchedulerProProjectMixin]] is working with.\n * It is constructed as [[SchedulerBasicEvent]], enhanced with extra functionality.\n */\nexport class SchedulerProEvent extends Mixin([\n    SchedulerBasicEvent,\n    HasDateConstraintMixin,\n    HasPercentDoneMixin,\n    SchedulerProHasAssignmentsMixin,\n    HasEffortMixin,\n    HasSchedulingModeMixin,\n    FixedDurationMixin,\n    ConstrainedEarlyEventMixin,\n    ScheduledByDependenciesEarlyEventMixin,\n    SplitEventMixin,\n], (base) => {\n    class SchedulerProEvent extends base {\n    }\n    return SchedulerProEvent;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base, Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, Entity, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { CalendarIntervalMixin } from \"../../../calendar/CalendarIntervalMixin.js\";\nimport { CalendarIntervalStore } from \"../../../calendar/CalendarIntervalStore.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { BaseCalendarMixin } from \"../scheduler_basic/BaseCalendarMixin.js\";\nimport { BaseResourceMixin } from \"../scheduler_basic/BaseResourceMixin.js\";\nexport class ResourceAllocationEventRangeCalendarIntervalMixin extends CalendarIntervalMixin {\n    // @model_field({ type : 'boolean', defaultValue : true })\n    // isWorking : boolean\n    // Calendar classes not entering graph, thus not using @model_field\n    static get fields() {\n        return [\n            { name: 'isWorking', type: 'boolean', defaultValue: true }\n        ];\n    }\n}\nexport class ResourceAllocationEventRangeCalendarIntervalStore extends CalendarIntervalStore {\n    static get defaultConfig() {\n        return {\n            modelClass: ResourceAllocationEventRangeCalendarIntervalMixin\n        };\n    }\n}\nexport class ResourceAllocationEventRangeCalendar extends BaseCalendarMixin {\n    get intervalStoreClass() {\n        return ResourceAllocationEventRangeCalendarIntervalStore;\n    }\n}\n__decorate([\n    model_field({ type: 'boolean', defaultValue: false })\n], ResourceAllocationEventRangeCalendar.prototype, \"unspecifiedTimeIsWorking\", void 0);\nexport class BaseAllocationInterval extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Effort in the [[tick|interval]] in milliseconds.\n         */\n        this.effort = 0;\n        /**\n         * Utilization level of the resource (or the assignment if the interval represents the one) in percent.\n         */\n        this.units = 0;\n    }\n}\nexport class AssignmentAllocationInterval extends BaseAllocationInterval {\n}\n/**\n * Resource allocation information for a certain tick.\n */\nexport class ResourceAllocationInterval extends BaseAllocationInterval {\n    constructor() {\n        super(...arguments);\n        /**\n         * Maximum possible effort in the [[tick|interval]] in milliseconds.\n         */\n        this.maxEffort = 0;\n        /**\n         * Indicates that the resource (or the assignment if the interval represents the one) is over-allocated in the [[tick|interval]].\n         * So `true` when [[effort]] is more than [[maxEffort|possible maximum]].\n         */\n        this.isOverallocated = false;\n        /**\n         * Indicates that the resource (or assignment if the interval represents the one) is under-allocated in the [[tick|interval]].\n         * So `true` when [[effort]] is less than [[maxEffort|possible maximum]].\n         */\n        this.isUnderallocated = false;\n        /**\n         * Resource assignments ingoing in the [[tick|interval]].\n         */\n        this.assignments = null;\n        this.assignmentIntervals = null;\n    }\n}\nexport class BaseAllocationInfo extends Entity.mix(Base) {\n    getDefaultAllocationIntervalClass() {\n        return BaseAllocationInterval;\n    }\n    initialize(props) {\n        props = Object.assign({\n            includeInactiveEvents: false,\n            allocationIntervalClass: this.getDefaultAllocationIntervalClass()\n        }, props);\n        super.initialize(props);\n    }\n}\n__decorate([\n    field()\n], BaseAllocationInfo.prototype, \"includeInactiveEvents\", void 0);\n__decorate([\n    field()\n], BaseAllocationInfo.prototype, \"allocation\", void 0);\n/**\n * Class implementing _resource allocation report_ - a data representing the provided [[resource]]\n * utilization in the provided period of time.\n * The data is grouped by the provided [[ticks|time intervals]]\n */\nexport class ResourceAllocationInfo extends BaseAllocationInfo {\n    enterGraph(graph) {\n        super.enterGraph(graph);\n    }\n    leaveGraph(graph) {\n        super.leaveGraph(graph);\n        if (this.resource) {\n            this.resource.entities.delete(this);\n        }\n    }\n    getDefaultAllocationIntervalClass() {\n        return ResourceAllocationInterval;\n    }\n    *shouldIncludeAssignmentInAllocation(assignment) {\n        const event = yield assignment.$.event, units = yield assignment.$.units, includeInactiveEvents = yield this.$.includeInactiveEvents, inactive = event && (yield event.$.inactive), // includeInactiveEvents\n        startDate = event && (yield event.$.startDate), endDate = event && (yield event.$.endDate);\n        return Boolean(event && units && startDate && endDate && (includeInactiveEvents || !inactive));\n    }\n    *calculateAllocation() {\n        const total = [], ticksCalendar = yield this.ticks, resource = yield this.$.resource, includeInactiveEvents = yield this.$.includeInactiveEvents, assignments = yield resource.$.assigned, calendar = yield resource.$.effectiveCalendar, assignmentsByCalendar = new Map(), eventRanges = [], assignmentTicksData = new Map(), byAssignments = new Map();\n        let hasIgnoreResourceCalendarEvent = false;\n        // collect the resource assignments into assignmentsByCalendar map\n        for (const assignment of assignments) {\n            // skip missing or unscheduled event assignments\n            if (!(yield* this.shouldIncludeAssignmentInAllocation(assignment)))\n                continue;\n            // we're going to need up-to-date assignment \"units\" below in this method ..so we yield it here\n            yield assignment.$.units;\n            const event = yield assignment.$.event;\n            const ignoreResourceCalendar = yield event.$.ignoreResourceCalendar;\n            const startDate = yield event.$.startDate;\n            const endDate = yield event.$.endDate;\n            const segments = yield event.$.segments;\n            const eventCalendar = yield event.$.effectiveCalendar;\n            hasIgnoreResourceCalendarEvent = hasIgnoreResourceCalendarEvent || ignoreResourceCalendar;\n            // if the event is segmented collect segment ranges\n            if (segments) {\n                for (const segment of segments) {\n                    const startDate = yield segment.$.startDate;\n                    const endDate = yield segment.$.endDate;\n                    eventRanges.push({ startDate, endDate, assignment });\n                }\n            }\n            else {\n                eventRanges.push({ startDate, endDate, assignment });\n            }\n            let assignments = assignmentsByCalendar.get(eventCalendar);\n            if (!assignments) {\n                assignments = [];\n                assignmentsByCalendar.set(eventCalendar, assignments);\n            }\n            assignmentTicksData.set(assignment, new Map());\n            byAssignments.set(assignment, []);\n            assignments.push(assignment);\n        }\n        const eventRangesCalendar = new ResourceAllocationEventRangeCalendar({ intervals: eventRanges });\n        // Provide extra calendars:\n        // 1) a calendar containing list of ticks to group the resource allocation by\n        // 2) a calendar containing list of assigned event start/end ranges\n        // 3) assigned task calendars\n        const calendars = [ticksCalendar, eventRangesCalendar, ...assignmentsByCalendar.keys()];\n        const ticksData = new Map();\n        // Initialize the resulting array with empty items\n        ticksCalendar.intervalStore.forEach(tick => {\n            const tickData = ResourceAllocationInterval.new({ tick, resource });\n            ticksData.set(tick, tickData);\n            total.push(tickData);\n            assignmentTicksData.forEach((ticksData, assignment) => {\n                const assignmentTickData = AssignmentAllocationInterval.new({ tick, assignment });\n                ticksData.set(tick, assignmentTickData);\n                byAssignments.get(assignment).push(assignmentTickData);\n            });\n        });\n        let weightedUnitsSum, weightsSum;\n        const startDate = total[0].tick.startDate, endDate = total[total.length - 1].tick.endDate, iterationOptions = {\n            startDate,\n            endDate,\n            calendars,\n            includeNonWorkingIntervals: hasIgnoreResourceCalendarEvent,\n        }, ticksTotalDuration = endDate.getTime() - startDate.getTime();\n        // provide extended maxRange if total ticks duration is greater than it\n        if (ticksTotalDuration > resource.getProject().maxCalendarRange) {\n            iterationOptions.maxRange = ticksTotalDuration;\n        }\n        yield* resource.forEachAvailabilityInterval(iterationOptions, (intervalStartDate, intervalEndDate, intervalData) => {\n            const isWorkingCalendar = intervalData.getCalendarsWorkStatus();\n            // We are inside a tick interval and it's a working time according\n            // to a resource calendar\n            if (isWorkingCalendar.get(ticksCalendar)) {\n                const tick = intervalData.intervalsByCalendar.get(ticksCalendar)[0], intervalDuration = intervalEndDate.getTime() - intervalStartDate.getTime(), tickData = ticksData.get(tick), tickAssignments = tickData.assignments || new Set(), tickAssignmentIntervals = tickData.assignmentIntervals || new Map();\n                if (!tickData.assignments) {\n                    weightedUnitsSum = 0;\n                    weightsSum = 0;\n                }\n                let units = 0, intervalHasAssignments = false, duration;\n                // for each event intersecting the interval\n                intervalData.intervalsByCalendar.get(eventRangesCalendar).forEach((interval) => {\n                    const assignment = interval.assignment;\n                    // <remove-on-release>\n                    // TODO: We don't do yield \"assignment.event.*\" expressions since we did it previously\n                    //  while looping the assignments because we cannot yield from the iterator callback\n                    // </remove-on-release>\n                    const event = assignment?.event;\n                    // if event is performing in the interval\n                    if (event &&\n                        isWorkingCalendar.get(event.effectiveCalendar) &&\n                        (!hasIgnoreResourceCalendarEvent || event.ignoreResourceCalendar || isWorkingCalendar.get(calendar))) {\n                        // constrain the event start/end with the tick borders\n                        const workingStartDate = Math.max(intervalStartDate.getTime(), assignment.event.startDate.getTime());\n                        const workingEndDate = Math.min(intervalEndDate.getTime(), assignment.event.endDate.getTime());\n                        intervalHasAssignments = true;\n                        duration = workingEndDate - workingStartDate;\n                        const assignmentInterval = assignmentTicksData.get(assignment).get(tick);\n                        const assignmentEffort = duration * assignment.units / 100;\n                        assignmentInterval.effort += assignmentEffort;\n                        assignmentInterval.units = assignment.units;\n                        tickData.effort += assignmentEffort;\n                        // collect total resource usage percent in the current interval\n                        units += assignment.units;\n                        tickAssignments.add(assignment);\n                        tickAssignmentIntervals.set(assignment, assignmentInterval);\n                    }\n                });\n                // maxEffort represents the resource calendar intervals\n                if (isWorkingCalendar.get(calendar)) {\n                    tickData.maxEffort += intervalDuration;\n                }\n                // if we have assignments running in the interval - calculate average allocation %\n                if (units) {\n                    if (duration) {\n                        // keep weightedUnitsSum & weightsSum since there might be another intervals in the tick\n                        weightedUnitsSum += duration * units;\n                        weightsSum += duration;\n                        // \"units\" weighted arithmetic mean w/ duration values as weights\n                        tickData.units = weightedUnitsSum / weightsSum;\n                    }\n                    else if (!weightedUnitsSum) {\n                        tickData.units = units;\n                    }\n                }\n                if (intervalHasAssignments) {\n                    tickData.assignments = tickAssignments;\n                    tickData.assignmentIntervals = tickAssignmentIntervals;\n                    tickData.isOverallocated = tickData.isOverallocated || tickData.effort > tickData.maxEffort || tickData.units > 100;\n                    tickData.isUnderallocated = tickData.effort < tickData.maxEffort || tickData.units < 100;\n                }\n            }\n        });\n        return {\n            total,\n            byAssignments\n        };\n    }\n}\n__decorate([\n    field()\n], ResourceAllocationInfo.prototype, \"resource\", void 0);\n__decorate([\n    calculate('allocation')\n], ResourceAllocationInfo.prototype, \"calculateAllocation\", null);\n/**\n * A mixin for the resource entity at the Scheduler Pro level.\n */\nexport class SchedulerProResourceMixin extends Mixin([BaseResourceMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProResourceMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.observers = new Set();\n            this.entities = new Set();\n        }\n        addObserver(observer) {\n            this.graph.addIdentifier(observer);\n            this.observers.add(observer);\n        }\n        removeObserver(observer) {\n            if (this.graph) {\n                this.graph.removeIdentifier(observer);\n            }\n            this.observers.delete(observer);\n        }\n        addEntity(entity) {\n            this.graph.addEntity(entity);\n            this.entities.add(entity);\n        }\n        removeEntity(entity) {\n            if (this.graph) {\n                this.graph.removeEntity(entity);\n            }\n            this.entities.delete(entity);\n        }\n        leaveGraph(replica) {\n            const { graph } = this;\n            for (const observer of this.observers) {\n                this.removeObserver(observer);\n            }\n            for (const entity of this.entities) {\n                this.removeEntity(entity);\n            }\n            superProto.leaveGraph.call(this, replica);\n        }\n        *forEachAvailabilityInterval(options, func) {\n            const project = this.getProject();\n            const calendar = yield this.$.effectiveCalendar;\n            const effectiveCalendarsCombination = project.combineCalendars([calendar].concat(options.calendars || []));\n            const maxRange = project.maxCalendarRange;\n            const includeNonWorkingIntervals = options.includeNonWorkingIntervals;\n            if (maxRange) {\n                options = Object.assign({ maxRange }, options);\n            }\n            return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {\n                const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();\n                if (includeNonWorkingIntervals || calendarsStatus.get(calendar)) {\n                    return func(startDate, endDate, calendarCacheIntervalMultiple);\n                }\n            });\n        }\n    }\n    return SchedulerProResourceMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CI } from \"../../../../ChronoGraph/collection/Iterator.js\";\nimport { prototypeValue } from \"../../../../ChronoGraph/util/Helpers.js\";\nimport Localizable from \"../../../../Core/localization/Localizable.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { CycleEffect } from \"../../../chrono/Replica.js\";\nimport { SchedulingIssueEffectResolution } from \"../../../chrono/SchedulingIssueEffect.js\";\nimport { DependenciesCalendar, DependencyValidationResult, ProjectType } from \"../../../scheduling/Types.js\";\nimport { ChronoEventStoreMixin } from \"../../store/ChronoEventStoreMixin.js\";\nimport { HasChildrenMixin } from \"../scheduler_basic/HasChildrenMixin.js\";\nimport { SchedulerBasicProjectMixin } from \"../scheduler_basic/SchedulerBasicProjectMixin.js\";\nimport { ConstrainedEarlyEventMixin } from \"./ConstrainedEarlyEventMixin.js\";\nimport { DateConstraintInterval } from \"./HasDateConstraintMixin.js\";\nimport { DeactivateDependencyResolution, DependencyConstraintInterval, RemoveDependencyResolution } from \"./ScheduledByDependenciesEarlyEventMixin.js\";\nimport { SchedulerProAssignmentMixin } from \"./SchedulerProAssignmentMixin.js\";\nimport { SchedulerProDependencyMixin } from \"./SchedulerProDependencyMixin.js\";\nimport { SchedulerProEvent } from \"./SchedulerProEvent.js\";\nimport { SchedulerProEventSegment } from \"./SchedulerProEventSegment.js\";\nimport { ResourceAllocationInfo, SchedulerProResourceMixin } from \"./SchedulerProResourceMixin.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Scheduler Pro project mixin type. At this level, events are scheduled according to the incoming dependencies\n * and calendars of the assigned resources.\n *\n * The base event class for this level is [[SchedulerProEvent]]. The base dependency class is [[SchedulerProDependencyMixin]]\n */\nexport class SchedulerProProjectMixin extends Mixin([SchedulerBasicProjectMixin, ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProProjectMixin extends base {\n        construct(config = {}) {\n            this.eventSegmentModelClass = config.eventSegmentModelClass || this.getDefaultEventSegmentModelClass();\n            superProto.construct.call(this, config);\n            if (!this.resourceAllocationInfoClass)\n                this.resourceAllocationInfoClass = this.getDefaultResourceAllocationInfoClass();\n        }\n        getDefaultEventStoreClass() {\n            return ChronoEventStoreMixin;\n        }\n        getDefaultEventSegmentModelClass() {\n            return SchedulerProEventSegment;\n        }\n        getDefaultResourceAllocationInfoClass() {\n            return ResourceAllocationInfo;\n        }\n        *calculateDirection() {\n            return yield ProposedOrPrevious;\n        }\n        afterConfigure() {\n            superProto.afterConfigure.apply(this, arguments);\n            this.dateConstraintIntervalClass = this.dateConstraintIntervalClass || DateConstraintInterval;\n            this.dependencyConstraintIntervalClass = this.dependencyConstraintIntervalClass || DependencyConstraintInterval;\n        }\n        getType() {\n            return ProjectType.SchedulerPro;\n        }\n        getDefaultCycleEffectClass() {\n            return SchedulerProCycleEffect;\n        }\n        getDefaultEventModelClass() {\n            return SchedulerProEvent;\n        }\n        getDefaultDependencyModelClass() {\n            return SchedulerProDependencyMixin;\n        }\n        getDefaultAssignmentModelClass() {\n            return SchedulerProAssignmentMixin;\n        }\n        getDefaultResourceModelClass() {\n            return SchedulerProResourceMixin;\n        }\n        /**\n         * Validates a hypothetical dependency with provided parameters.\n         *\n         * ```typescript\n         * // let's check if a EndToStart dependency linking event1 with event2 will be valid\n         * const validationResult = await project.validateDependency(event1, event2, DependencyType.EndToStart);\n         *\n         * switch (validationResult) {\n         *     const DependencyValidationResult.CyclicDependency :\n         *         console.log('Dependency builds a cycle');\n         *         break;\n         *\n         *     const DependencyValidationResult.DuplicatingDependency :\n         *         console.log('Such dependency already exists');\n         *         break;\n         *\n         *     const DependencyValidationResult.NoError :\n         *         console.log('Dependency is valid');\n         * }\n         * ```\n         *\n         * See also [[isValidDependency]] method for more basic usage.\n         *\n         * @param fromEvent The dependency predecessor\n         * @param toEvent The dependency successor\n         * @param type The dependency type\n         * @param ignoreDependency Dependencies to ignore while validating. This parameter can be used for example if one plans to change\n         * an existing dependency properties and wants to know if the change will lead to an error:\n         *\n         * ```typescript\n         * // let's check if changing of the dependency predecessor to newPredecessor will make it invalid\n         * const validationResult = await project.validateDependency(newPredecessor, dependency.toEvent, dependency.type, dependency);\n         *\n         * if (validationResult !== DependencyValidationResult.NoError) console.log(\"The dependency is invalid\");\n         * ```\n         * @return The validation result\n         */\n        async validateDependency(fromEvent, toEvent, type, ignoreDependency) {\n            let ingoredDependencies;\n            if (ignoreDependency) {\n                ingoredDependencies = Array.isArray(ignoreDependency) ? ignoreDependency : [ignoreDependency];\n            }\n            const alreadyLinked = CI(fromEvent.outgoingDeps).some((dependency) => dependency.toEvent === toEvent && !ingoredDependencies?.includes(dependency));\n            if (alreadyLinked)\n                return DependencyValidationResult.DuplicatingDependency;\n            if (await this.isDependencyCyclic(fromEvent, toEvent, type, ingoredDependencies)) {\n                return DependencyValidationResult.CyclicDependency;\n            }\n            return DependencyValidationResult.NoError;\n        }\n        /**\n         * Validates a hypothetical dependency with provided parameters.\n         *\n         * ```typescript\n         * // let's check if a EndToStart dependency linking event1 with event2 will be valid\n         * if (await project.isValidDependency(event1, event2, DependencyType.EndToStart)) {\n         *     console.log('Dependency is valid');\n         * } else {\n         *     console.log('Dependency is invalid');\n         * }\n         * ```\n         *\n         * See also [[validateDependency]] method for more detailed validation results.\n         *\n         * @param fromEvent The dependency predecessor\n         * @param toEvent The dependency successor\n         * @param type The dependency type\n         * @param ignoreDependency Dependencies to ignore while validating. This parameter can be used for example if one plans to change\n         * an existing dependency properties and wants to know if the change will lead to an error:\n         *\n         * ```typescript\n         * // let's check if changing of the dependency predecessor to newPredecessor will make it invalid\n         * if (await project.isValidDependency(newPredecessor, dependency.toEvent, dependency.type, dependency)) console.log(\"The dependency is valid\");\n         * ```\n         * @return The validation result\n         */\n        // this does not account for possible scheduling conflicts\n        async isValidDependency(fromEvent, toEvent, type, ignoreDependency) {\n            const validationResult = await this.validateDependency(fromEvent, toEvent, type, ignoreDependency);\n            return validationResult === DependencyValidationResult.NoError;\n        }\n        getDependencyCycleDetectionIdentifiers(fromEvent, toEvent) {\n            return [\n                // @ts-ignore\n                toEvent.$.earlyStartDateConstraintIntervals,\n                // @ts-ignore\n                toEvent.$.earlyEndDateConstraintIntervals\n            ];\n        }\n        async isDependencyCyclic(fromEvent, toEvent, type, ignoreDependency) {\n            const dependencyClass = this.getDependencyStore().modelClass;\n            const dependency = new dependencyClass({ fromEvent, toEvent, type });\n            const branch = this.replica.branch({ autoCommit: false, onComputationCycle: 'throw' });\n            if (ignoreDependency) {\n                if (!Array.isArray(ignoreDependency)) {\n                    ignoreDependency = [ignoreDependency];\n                }\n                ignoreDependency.forEach(dependency => branch.removeEntity(dependency));\n            }\n            branch.addEntity(dependency);\n            dependency.project = this;\n            // search for identifiers reading of which finds a cycle\n            // for (const i of Object.keys(toEvent.$)) {\n            //     try {\n            //         await branch.readAsync(toEvent.$[i])\n            //     } catch (e) {\n            //         if (/cycle/i.test(e)) {\n            //             // dump found identifier names to console\n            //             console.log(i)\n            //         }\n            //         else\n            //             throw e\n            //     }\n            // }\n            try {\n                await Promise.all(this.getDependencyCycleDetectionIdentifiers(fromEvent, toEvent).map(i => branch.readAsync(i)));\n                return false;\n            }\n            catch (e) {\n                // return true for the cycle exception and re-throw all others\n                if (/cycle/i.test(e))\n                    return true;\n                // We don't throw on conflicts here ..it's supposed to happen when the changes really reach the graph\n                if (!/conflict/i.test(e)) {\n                    throw e;\n                }\n            }\n        }\n        // work in progress\n        // This method validates changes (e.g. type) for existing dependencies (which are already in the store)\n        async isValidDependencyModel(dependency, ignoreDependencies) {\n            return this.isValidDependency(dependency.fromEvent, dependency.toEvent, dependency.type, ignoreDependencies);\n        }\n    }\n    __decorate([\n        model_field({ type: 'string', defaultValue: DependenciesCalendar.ToEvent })\n    ], SchedulerProProjectMixin.prototype, \"dependenciesCalendar\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerProProjectMixin.prototype, \"autoCalculatePercentDoneForParentTasks\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerProProjectMixin.prototype, \"addConstraintOnDateSet\", void 0);\n    return SchedulerProProjectMixin;\n}) {\n}\n/**\n * A cycle resolution deactivating one of the [[getDependencies|related dependencies]].\n * The dependency instance should be passed to [[resolve]] method:\n *\n * ```typescript\n * // this call will deactivate dependencyRecord\n * removalResolution.resolve(dependencyRecord)\n * ```\n */\nexport class DeactivateDependencyCycleEffectResolution extends Localizable(SchedulingIssueEffectResolution) {\n    static get $name() {\n        return 'DeactivateDependencyCycleEffectResolution';\n    }\n    getDescription() {\n        return this.L('L{descriptionTpl}');\n    }\n    resolve(dependency) {\n        dependency.active = false;\n    }\n}\n/**\n * Class implementing a special effect signalizing of a computation cycle.\n * The class suggests two [[getResolutions|resolutions]] - either removing or deactivating one of\n * the [[getDependencies|related dependencies]].\n */\nexport class SchedulerProCycleEffect extends CycleEffect {\n    /**\n     * Returns dependencies taking part in the cycle that are treated as invalid.\n     * For example a \"parent-child\" dependency or a dependency linking a task to itself.\n     */\n    getInvalidDependencies() {\n        if (!this._invalidDependencies) {\n            const dependencies = this.getDependencies();\n            this._invalidDependencies = dependencies.filter(dependency => \n            // @ts-ignore\n            dependency.fromEvent === dependency.toEvent || (dependency.fromEvent.contains(dependency.toEvent) || dependency.toEvent.contains(dependency.fromEvent)));\n        }\n        return this._invalidDependencies;\n    }\n    buildInvalidDependencyResolutions(config) {\n        return [\n            this.removeDependencyConflictResolutionClass.new(config),\n            this.deactivateDependencyConflictResolutionClass.new(config)\n        ];\n    }\n    matchDependencyBySourceAndTargetEvent(dependency, from, to) {\n        return dependency.active && super.matchDependencyBySourceAndTargetEvent(dependency, from, to);\n    }\n    getResolutions() {\n        if (!this._resolutions) {\n            const invalidDependencies = this.getInvalidDependencies();\n            const result = [];\n            for (const dependency of invalidDependencies) {\n                result.push(...this.buildInvalidDependencyResolutions({ dependency }));\n            }\n            // If we have invalid dependencies we do not suggest other dependency resolutions\n            // to force resolving the invalid ones first\n            if (!invalidDependencies.length) {\n                result.push(this.deactivateDependencyCycleEffectResolutionClass.new(), ...super.getResolutions());\n            }\n            this._resolutions = result;\n        }\n        return this._resolutions;\n    }\n}\n__decorate([\n    prototypeValue(DeactivateDependencyCycleEffectResolution)\n], SchedulerProCycleEffect.prototype, \"deactivateDependencyCycleEffectResolutionClass\", void 0);\n__decorate([\n    prototypeValue(RemoveDependencyResolution)\n], SchedulerProCycleEffect.prototype, \"removeDependencyConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DeactivateDependencyResolution)\n], SchedulerProCycleEffect.prototype, \"deactivateDependencyConflictResolutionClass\", void 0);\n", "import Combo from '../../Core/widget/Combo.js';\n\n/**\n * @module SchedulerPro/widget/ModelCombo\n */\n\n/**\n * A special {@link Core.widget.Combo} subclass returning a {@link Core.data.Model} instance from its store as the value\n * @extends Core/widget/Combo\n * @classType modelcombo\n * @inputfield\n */\nexport default class ModelCombo extends Combo {\n\n    //region Config\n\n    static get $name() {\n        return 'ModelCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'modelcombo';\n    }\n\n    //endregion\n\n    //region Internal\n\n    get value() {\n        const\n            superValue = super.value,\n            model      = this.store.getById(superValue);\n\n        return model || superValue;\n    }\n\n    set value(v) {\n        super.value = v;\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nModelCombo.initClass();\n", "import ModelCombo from './ModelCombo.js';\n\n/**\n * @module SchedulerPro/widget/CalendarField\n */\n\n/**\n * A combo used to select the calendar for an event. This field can be seen in the {@link SchedulerPro.widget.taskeditor.AdvancedTab}\n * {@inlineexample SchedulerPro/widget/CalendarField.js}\n * @extends SchedulerPro/widget/ModelCombo\n * @classtype calendarfield\n * @inputfield\n */\nexport default class CalendarField extends ModelCombo {\n\n    //region Config\n\n    static get $name() {\n        return 'CalendarField';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'calendarfield';\n    }\n\n    static get defaultConfig() {\n        return {\n            valueField   : 'id',\n            displayField : 'name',\n            editable     : false,\n\n            /**\n             * The store containing the calendars\n             * @config {SchedulerPro.data.CalendarManagerStore}\n             */\n            store : null,\n\n            listItemTpl : calendar => {\n                return calendar.name || this.L('L{Default calendar}');\n            },\n\n            displayValueRenderer : (calendar, field) => {\n                calendar = calendar || field.store?.project?.effectiveCalendar;\n\n                return calendar?.name || this.L('L{Default calendar}');\n            }\n        };\n    }\n\n    //endregion\n\n    //region Internal\n\n    get value() {\n        return super.value;\n    }\n\n    set value(v) {\n        if (v && v.isDefault && v.isDefault()) {\n            v = null;\n        }\n        super.value = v;\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nCalendarField.initClass();\n", "import Base from '../../../Core/Base.js';\n\n// <remove-on-release>\n// TODO: Compare with Schedulers ProjectModel, make similar\n// </remove-on-release>\n\n/**\n * @module SchedulerPro/data/mixin/PartOfProject\n */\n\nconst throwIfNotTheSameStore = (oldStore, newStore) => {\n    if (oldStore !== newStore) {\n        throw new Error('Store set is prohibited for Scheduler Pro entity!');\n    }\n};\n\n/**\n * This is a mixin, included in all models and stores of the Scheduler Pro project. It provides a common API for accessing\n * all stores of the project.\n *\n * @typings Scheduler/data/mixin/PartOfProject -> Scheduler/data/mixin/SchedulerPartOfProject\n *\n * @mixin\n */\nexport default Target => class PartOfProject extends (Target || Base) {\n    static get $name() {\n        return 'PartOfProject';\n    }\n\n    /**\n     * Returns the project this entity belongs to.\n     *\n     * @member {SchedulerPro.model.ProjectModel} project\n     * @readonly\n     */\n\n    /**\n     * An {@link SchedulerPro.data.EventStore} instance or a config object.\n     * @config {SchedulerPro.data.EventStore|EventStoreConfig} taskStore\n     * @category Project\n     */\n    /**\n     * The {@link SchedulerPro.data.EventStore store} holding data on events.\n     *\n     * @member {SchedulerPro.data.EventStore}\n     * @category Project\n     * @readonly\n     */\n    get taskStore() {\n        return this.eventStore;\n    }\n\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set taskStore(store) {\n        this.eventStore = store;\n    }\n\n    /**\n     * Returns the task store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.EventStore}\n     * @category Project\n     * @readonly\n     * @typings Scheduler/model/mixin/ProjectModelMixin:eventStore -> {Scheduler.data.EventStore||SchedulerPro.data.EventStore}\n     */\n    get eventStore() {\n        return this.project?.eventStore;\n    }\n\n    get leftProjectEventStore() {\n        const project = this.leftProject;\n        return project?.getEventStore() || null;\n    }\n\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set eventStore(store) {\n        throwIfNotTheSameStore(this.eventStore, store);\n    }\n\n    /**\n     * Returns the dependency store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.DependencyStore}\n     * @category Project\n     * @readonly\n     * @typings Scheduler/model/mixin/ProjectModelMixin:dependencyStore -> {Scheduler.data.DependencyStore||SchedulerPro.data.DependencyStore}\n     */\n    get dependencyStore() {\n        return this.project?.dependencyStore;\n    }\n\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set dependencyStore(store) {\n        throwIfNotTheSameStore(this.dependencyStore, store);\n    }\n\n    /**\n     * Returns the assignment store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.AssignmentStore}\n     * @readonly\n     * @category Project\n     * @typings Scheduler/model/mixin/ProjectModelMixin:assignmentStore -> {Scheduler.data.AssignmentStore||SchedulerPro.data.AssignmentStore}\n     */\n    get assignmentStore() {\n        return this.project?.assignmentStore;\n    }\n\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set assignmentStore(store) {\n        throwIfNotTheSameStore(this.assignmentStore, store);\n    }\n\n    /**\n     * Returns the resource store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.ResourceStore}\n     * @readonly\n     * @category Project\n     * @typings Scheduler/model/mixin/ProjectModelMixin:resourceStore -> {Scheduler.data.ResourceStore||SchedulerPro.data.ResourceStore}\n     */\n    get resourceStore() {\n        return this.project?.resourceStore;\n    }\n\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set resourceStore(store) {\n        throwIfNotTheSameStore(this.resourceStore, store);\n    }\n\n    /**\n     * Returns the calendar manager store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.CalendarManagerStore}\n     * @readonly\n     * @category Project\n     */\n    get calendarManagerStore() {\n        return this.project?.calendarManagerStore;\n    }\n\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set calendarManagerStore(store) {\n        throwIfNotTheSameStore(this.calendarManagerStore, store);\n    }\n};\n", "import Model from '../../Core/data/Model.js';\nimport AssignmentModelMixin from '../../Scheduler/model/mixin/AssignmentModelMixin.js';\nimport { SchedulerProAssignmentMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProAssignmentMixin.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n\n/**\n * @module SchedulerPro/model/AssignmentModel\n */\n\n/**\n * This class represent a single assignment of a resource to an event in Scheduler Pro. It has a lot in common with\n * Schedulers AssignmentModel, they are separate models but they share much functionality using the\n * {@link Scheduler.model.mixin.AssignmentModelMixin AssignmentModelMixin} mixin.\n *\n * It is a subclass of {@link Core.data.Model} class. Please refer to the documentation for that class to become\n * familiar with the base interface of this class.\n *\n * ## Fields and references\n *\n * An Assignment has the following fields:\n * - `id` - The id of the assignment\n * - `resourceId` - The id of the resource assigned (optionally replaced with `resource` for load)\n * - `eventId` - The id of the event to which the resource is assigned (optionally replaced with `event` for load)\n *\n * The data source for these fields can be customized by subclassing this class:\n *\n * ```javascript\n * class MyAssignment extends AssignmentModel {\n *   static get fields() {\n *       return [\n *          { name : 'resourceId', dataSource : 'linkedResource' }\n *       ];\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `event` - The linked event record\n * - `resource` - The linked resource record\n *\n * ## Async resolving of references\n *\n * As described above, an assignment links an event to a resource. It holds references to an event record and a resource\n * record. These references are populated async, using the calculation engine of the project that the assignment via\n * its store is a part of. Because of this asyncness, references cannot be used immediately after modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // assignment.resource is not yet available\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // assignment.resource is available\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // assignment.resource is available\n * ```\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/AssignmentModelMixin\n * @uninherit Core/data/mixin/TreeNode\n * @typings Scheduler/model/AssignmentModel -> Scheduler/model/SchedulerAssignmentModel\n */\nexport default class AssignmentModel extends PartOfProject(AssignmentModelMixin(SchedulerProAssignmentMixin.derive(Model))) {\n\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n\n    /**\n     * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after\n     * load it will be populated with the actual event and not its id. This field is not persistable.\n     * @field {SchedulerPro.model.EventModel} event\n     * @accepts {String|Number|SchedulerPro.model.EventModel}\n     * @typings {String||Number||SchedulerPro.model.EventModel||Core.model.Model}\n     * @category Common\n     */\n\n    /**\n     * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after\n     * load it will be populated with the actual resource and not its id. This field is not persistable.\n     * @field {SchedulerPro.model.ResourceModel} resource\n     * @accepts {String|Number|SchedulerPro.model.ResourceModel}\n     * @category Common\n     */\n\n    /**\n     * A numeric, percent-like value, indicating the \"contribution level\"\n     * of the resource availability to the {@link #field-event}.\n     * Number 100 means that the assigned {@link #field-resource} spends all its working time\n     * on the {@link #field-event}.\n     * And number 50 means that the resource spends only half of its available time\n     * on the {@link #field-event}.\n     * Setting the value to 0 will unassign the resource (and remove the assignment)\n     * @field {Number} units\n     * @category Common\n     */\n\n    //region Config\n\n    static $name = 'AssignmentModel';\n\n    static isProAssignmentModel = true;\n\n    //endregion\n\n    //region Early render\n\n    get event() {\n        const\n            { project } = this,\n            event       = super.event;\n\n        // Figure reference out before buckets are created (if part of project)\n        if (project?.isDelayingCalculation) {\n            return project.eventStore.getById(event);\n        }\n\n        return event;\n    }\n\n    set event(event) {\n        super.event = event;\n    }\n\n    get resource() {\n        const\n            { project }  = this;\n\n        let resource     = super.resource;\n\n        // Figure reference out before buckets are created (if part of project)\n        if (project?.isDelayingCalculation) {\n            resource = project.resourceStore.getById(resource);\n        }\n\n        return resource?.$original;\n    }\n\n    set resource(resource) {\n        super.resource = resource;\n    }\n\n    //endregion\n\n    get eventResourceKey() {\n        return this.isInActiveTransaction\n            ? this.buildEventResourceKey(this.event, this.resource)\n            : this.buildEventResourceKey(this.$.event.DATA, this.$.resource.DATA);\n    }\n}\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport AssignmentStoreMixin from '../../Scheduler/data/mixin/AssignmentStoreMixin.js';\nimport AssignmentModel from '../model/AssignmentModel.js';\nimport { ChronoAssignmentStoreMixin } from '../../Engine/quark/store/ChronoAssignmentStoreMixin.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n\n/**\n * @module SchedulerPro/data/AssignmentStore\n */\n\n/**\n * A store representing a collection of assignments between events in the {@link SchedulerPro.data.EventStore} and resources\n * in the {@link SchedulerPro.data.ResourceStore}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.AssignmentModel}.\n *\n * An AssignmentStore is usually connected to a project, which binds it to other related stores (EventStore,\n * ResourceStore and DependencyStore). The project also handles references (event, resource) to related records for the\n * records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * assignmentStore.data = [{ eventId, resourceId }, ...];\n *\n * // references (event, resource) not resolved yet\n *\n * await assignmentStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await assignmentStore.loadDataAsync([{ eventId, resourceId }, ...]);\n *\n * // references (event, resource) are resolved\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/AssignmentStoreMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/AssignmentStore -> Scheduler/data/SchedulerAssignmentStore\n */\nexport default class AssignmentStore extends PartOfProject(AssignmentStoreMixin(ChronoAssignmentStoreMixin.derive(AjaxStore))) {\n\n    static $name = 'AssignmentStore';\n\n    static get defaultConfig() {\n        return {\n            modelClass : AssignmentModel\n        };\n    }\n\n}\n", "import Model from '../../Core/data/Model.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { CalendarIntervalMixin } from '../../Engine/calendar/CalendarIntervalMixin.js';\n\n/**\n * @module SchedulerPro/model/CalendarIntervalModel\n */\n\n/**\n * This is a documentation-only class, representing an interval in the {@link SchedulerPro/model/CalendarModel calendar}\n *\n * Please refer to the [calendars guide](#SchedulerPro/guides/basics/calendars.md) for details\n */\nexport default class CalendarIntervalModel extends PartOfProject(CalendarIntervalMixin.derive(Model)) {\n\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n\n    //region Fields\n\n    /**\n     * The start date of the fixed (not recurrent) time interval.\n     *\n     * @field {Date} startDate\n     */\n\n    /**\n     * The end date of the fixed (not recurrent) time interval.\n     *\n     * @field {Date} endDate\n     */\n\n    /**\n     * The start date of the recurrent time interval. Should be specified as any expression, recognized\n     * by the excellent [later](http://bunkat.github.io/later/) library.\n     *\n     * @field {String} recurrentStartDate\n     */\n\n    /**\n     * The end date of the recurrent time interval. Should be specified as any expression, recognized\n     * by the excellent [later](http://bunkat.github.io/later/) library.\n     *\n     * @field {String} recurrentEndDate\n     */\n\n    /**\n     * The \"is working\" flag, which defines what kind of interval this is - either working or non-working. Default value is `false`,\n     * denoting non-working intervals.\n     *\n     * @field {Boolean} isWorking\n     * @default false\n     */\n\n    /**\n     * A CSS class to add to the element visualizing this interval, when using the NonWorkingTime feature.\n     * <div class=\"note\">Note that only non working intervals are visible.</div>\n     *\n     * @field {String} cls\n     */\n\n    /**\n     * A CSS class used to add an icon to the element visualizing this interval, when using the NonWorkingTime feature.\n     * <div class=\"note\">Note that only non working intervals are visible.</div>\n     *\n     * @field {String} iconCls\n     */\n\n    //endregion\n\n    //region Methods\n\n    /**\n     * Whether this interval is recurrent (both `recurrentStartDate` and `recurrentEndDate` are present and parsed correctly\n     * by the `later` library).\n     *\n     * @method isRecurrent\n     * @returns {Boolean}\n     */\n\n    /**\n     * Whether this interval is static - both `startDate` and `endDate` are present.\n     *\n     * @method isStatic\n     * @returns {Boolean}\n     */\n\n    /**\n     * Returns an internal representation of the recurrent start date from the `later` library.\n     *\n     * @method getStartDateSchedule\n     * @returns {Object}\n     */\n\n    /**\n     * Returns an internal representation of the recurrent end date from the `later` library.\n     *\n     * @method getEndDateSchedule\n     * @returns {Object}\n     */\n\n    //endregion\n\n    //region Config\n\n    static get $name() {\n        return 'CalendarIntervalModel';\n    }\n\n    //endregion\n\n}\n", "import Model from '../../Core/data/Model.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { BaseCalendarMixin } from '../../Engine/quark/model/scheduler_basic/BaseCalendarMixin.js';\nimport CalendarIntervalModel from './CalendarIntervalModel.js';\n\n/**\n * @module SchedulerPro/model/CalendarModel\n */\n\n/**\n * This class represents a calendar in the Scheduler Pro project. It contains a collection of the {@link SchedulerPro.model.CalendarIntervalModel}.\n * Every interval can be either recurrent (regularly repeating in time) or static. These intervals can be visualized\n * by the {@link SchedulerPro.feature.ResourceNonWorkingTime} or {@link Scheduler.feature.NonWorkingTime} features.\n *\n * Please refer to the [calendars guide](#SchedulerPro/guides/basics/calendars.md) for details\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n *\n * @extends Core/data/Model\n */\nexport default class CalendarModel extends PartOfProject(BaseCalendarMixin.derive(Model)) {\n\n    //region Config\n\n    static get $name() {\n        return 'CalendarModel';\n    }\n\n    /**\n     * Returns the earliest point at which a working period of time starts, following the given date.\n     * Can be the date itself, if it occurs during working time.\n     * @method skipNonWorkingTime\n     * @param {Date} date The date after which to skip the non-working time\n     * @param {Boolean} [isForward=true] Whether the \"following\" means forward in time or backward\n     * @returns {Date} The earliest available date\n     */\n\n    /**\n     * This method adds a single {@link SchedulerPro.model.CalendarIntervalModel} to the internal collection of the\n     * calendar\n     * @method addInterval\n     * @param {SchedulerPro.model.CalendarIntervalModel|CalendarIntervalModelConfig} interval record or an object with\n     * data used to create a new record\n     * @returns {SchedulerPro.model.CalendarIntervalModel[]} Added intervals\n     */\n\n    /**\n     * This method adds an array of {@link SchedulerPro.model.CalendarIntervalModel} to the internal collection of the\n     * calendar\n     * @method addIntervals\n     * @param {SchedulerPro.model.CalendarIntervalModel[]|CalendarIntervalModelConfig[]} intervals An array of records\n     * or an array of objects with data used to create new records\n     * @returns {SchedulerPro.model.CalendarIntervalModel[]} Added intervals\n     */\n\n    /**\n     * This method removes all intervals from the internal collection of the calendar\n     * @method clearIntervals\n     * @param {Boolean} [silent] Do not trigger events\n     */\n\n    /**\n     * Calculate the working time duration for specific interval, in milliseconds.\n     * @method calculateDurationMs\n     * @param {Date} startDate Start of the interval\n     * @param {Date} endDate End of the interval\n     * @returns {Number} Returns working time in milliseconds\n     */\n\n    /**\n     * Checks if there is a working time interval in the provided time range\n     * @method isWorkingTime\n     * @param {Date} startDate Start of the interval\n     * @param {Date} endDate End of the interval\n     * @returns {Boolean} Returns `true` if the interval contains working time\n     */\n\n    /**\n     * Calculates the end date of the time interval which starts at `startDate` and has `durationMs` working time\n     * duration (in milliseconds).\n     * @method calculateEndDate\n     * @param {Date} startDate Start date\n     * @param {Number} durationMs Duration in milliseconds\n     * @returns {Date} The end date\n     */\n\n    /**\n     * Calculates the start date of the time interval which ends at `endDate` and has `durationMs` working time\n     * duration (in milliseconds).\n     * @method calculateStartDate\n     * @param {Date} endDate End date\n     * @param {Number} durationMs Duration in milliseconds\n     * @returns {Date} The start date\n     */\n\n    static get fields() {\n        return [\n            /**\n             * The calendar name.\n             * @field {String} name\n             */\n\n            /**\n             * A CSS class to add to calendar interval elements rendered in the UI.\n             * @field {String} cls\n             */\n\n            /**\n             * A CSS class defining an icon to show in non-working time elements rendered in the UI.\n             * @field {String} iconCls\n             */\n\n            /**\n             * The flag, indicating, whether the \"unspecified\" time (time that does not belong to any interval\n             * is working (`true`) or not (`false`).\n             *\n             * @field {Boolean} unspecifiedTimeIsWorking\n             * @default true\n             */\n\n            /**\n             * {@link SchedulerPro.model.CalendarIntervalModel Intervals} collection of the calendar. Accepts an array\n             * as its input, which behind the scenes will be converted to a store containing the intervals. When\n             * serializing it will be converted back to an array.\n             *\n             * @field {Core.data.Store} intervals\n             * @accepts {SchedulerPro.model.CalendarIntervalModel[]|CalendarIntervalModelConfig[]}\n             */\n\n            /**\n             * Start expanded or not\n             * @readonly\n             * @field {Boolean} expanded\n             * @default true\n             * @category Tree\n             */\n            {\n                name         : 'expanded',\n                internal     : true,\n                defaultValue : true\n            }\n        ];\n    }\n\n    //endregion\n\n    toString() {\n        return this.name || '';\n    }\n\n    static get defaultConfig() {\n        return {\n            calendarIntervalModelClass : CalendarIntervalModel\n        };\n    }\n}\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport CalendarModel from '../model/CalendarModel.js';\nimport { ChronoCalendarManagerStoreMixin } from '../../Engine/quark/store/ChronoCalendarManagerStoreMixin.js';\n\n/**\n * @module SchedulerPro/data/CalendarManagerStore\n */\n\n/**\n * A class representing the tree of calendars in the SchedulerPro chart. An individual calendar is represented as an instance of the\n * {@link SchedulerPro.model.CalendarModel} class. The store expects the data loaded to be hierarchical. Each parent node should\n * contain its children in a property called 'children'.\n *\n * Please refer to the [calendars guide](#SchedulerPro/guides/basics/calendars.md) for details\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n *\n * @extends Core/data/AjaxStore\n */\nexport default class CalendarManagerStore extends PartOfProject(ChronoCalendarManagerStoreMixin.derive(AjaxStore)) {\n\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            tree         : true,\n            modelClass   : CalendarModel,\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 100,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 100,\n            storeId      : 'calendars'\n        };\n    }\n\n    //endregion\n\n};\n", "import PartOfProject from '../data/mixin/PartOfProject.js';\nimport DependencyBaseModel from '../../Scheduler/model/DependencyBaseModel.js';\nimport { SchedulerProDependencyMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProDependencyMixin.js';\n\n/**\n * @module SchedulerPro/model/DependencyModel\n */\n\n/**\n * This model represents a dependency between two events, usually added to a {@link SchedulerPro.data.DependencyStore}.\n *\n * It is a subclass of the {@link Scheduler.model.DependencyBaseModel} class, which in its turn subclasses\n * {@link Core.data.Model}. Please refer to documentation of those classes to become familiar with the base interface of\n * this class.\n *\n * ## Fields and references\n *\n * A Dependency has a few predefined fields, see Fields below.  The name of any fields data source can be customized in\n * the subclass, see the example below. Please also refer to {@link Core.data.Model} for details.\n *\n * ```javascript\n * class MyDependency extends DependencyModel {\n *   static get fields() {\n *     return [\n *       { name: 'to', dataSource: 'targetId' },\n *       { name: 'from', dataSource: 'sourceId' }\n *     ]);\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `fromEvent` - The event on the start side of the dependency\n * - `toEvent` - The event on the end side of the dependency\n *\n * ## Async resolving of references\n *\n * As described above, a dependency has links to events. These references are populated async, using the calculation\n * engine of the project that the resource via its store is a part of. Because of this asyncness, references cannot be\n * used immediately after modifications:\n *\n * ```javascript\n * dependency.from = 2;\n * // dependency.fromEvent is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * dependency.from = 2;\n * await dependency.project.commitAsync();\n * // dependency.fromEvent is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await dependency.setAsync({ from : 2});\n * // dependency.fromEvent is up to date\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @extends Scheduler/model/DependencyBaseModel\n *\n * @typings Scheduler/model/DependencyModel -> Scheduler/model/SchedulerDependencyModel\n */\nexport default class DependencyModel extends PartOfProject(SchedulerProDependencyMixin.derive(DependencyBaseModel)) {\n\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n\n    /**\n     * The calendar of the dependency used to take `lag` duration into account.\n     * @field {SchedulerPro.model.CalendarModel} calendar\n     */\n\n    /**\n     * Set to `false` to ignore this dependency in scheduling\n     * @field {Boolean} active\n     * @category Dependency\n     */\n\n    //region Config\n\n    static get $name() {\n        return 'DependencyModel';\n    }\n\n    static get isProDependencyModel() {\n        return true;\n    }\n\n    //endregion\n\n    //region Render early\n\n    // Buckets and references are not set up yet during early render, need to look up on stores\n\n    get fromEvent() {\n        if (this.project?.isDelayingCalculation) {\n            return this.project.eventStore.getById(super.fromEvent);\n        }\n\n        return super.fromEvent;\n    }\n\n    set fromEvent(from) {\n        super.fromEvent = from;\n    }\n\n    get toEvent() {\n        if (this.project?.isDelayingCalculation) {\n            return this.project.eventStore.getById(super.toEvent);\n        }\n\n        return super.toEvent;\n    }\n\n    set toEvent(to) {\n        super.toEvent = to;\n    }\n\n    //endregion\n\n}\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport DependencyStoreMixin from '../../Scheduler/data/mixin/DependencyStoreMixin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport { ChronoDependencyStoreMixin } from '../../Engine/quark/store/ChronoDependencyStoreMixin.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n\n/**\n * @module SchedulerPro/data/DependencyStore\n */\n\n/**\n * A store representing a collection of dependencies between events in the {@link SchedulerPro.data.EventStore}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.DependencyModel}.\n *\n * A DependencyStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and ResourceStore). The project also handles references (fromEvent, toEvent) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * dependencyStore.data = [{ from, to }, ...];\n *\n * // references (fromEvent, toEvent) not resolved yet\n *\n * await dependencyStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await dependencyStore.loadDataAsync([{ from, to }, ...]);\n *\n * // references (fromEvent, toEvent) are resolved\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/DependencyStoreMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/DependencyStore -> Scheduler/data/SchedulerDependencyStore\n */\nexport default class DependencyStore extends PartOfProject(DependencyStoreMixin(ChronoDependencyStoreMixin.derive(AjaxStore))) {\n\n    static get defaultConfig() {\n        return {\n            modelClass : DependencyModel\n        };\n    }\n\n}\n", "/**\n * @module SchedulerPro/model/mixin/PercentDoneMixin\n */\n\n/**\n * PercentDone mixin to get the current status of a task.\n * @mixin\n */\nexport default Target => class PercentDoneMixin extends Target {\n    static get $name() {\n        return 'PercentDoneMixin';\n    }\n\n    /**\n     * The current status of a task, expressed as the percentage completed (integer from 0 to 100)\n     * @field {Number} percentDone\n     * @category Scheduling\n     */\n    // Field defined in Engine\n\n    /**\n     * Indicates if the task is started (its {@link #field-percentDone percent completion} is greater than zero).\n     * @property {Boolean}\n     * @category Progress\n     */\n    get isStarted() {\n        return this.percentDone > 0;\n    }\n\n    /**\n     * Indicates if the task is complete (its {@link #field-percentDone percent completion} is 100% (or greater)).\n     * @property {Boolean}\n     * @category Progress\n     */\n    get isCompleted() {\n        return this.percentDone >= 100;\n    }\n\n    /**\n     * Indicates if the task is in progress (its {@link #field-percentDone percent completion} is greater than zero and less than 100%).\n     * @property {Boolean}\n     * @category Progress\n     */\n    get isInProgress() {\n        return this.isStarted && !this.isCompleted;\n    }\n\n    // Reset % done value when copying a task\n    copy() {\n        const copy = super.copy(...arguments);\n\n        copy.percentDone = 0;\n        copy.clearChanges();\n\n        return copy;\n    }\n\n    /**\n     * Human-friendly rounding. When task is completed < 99%, it rounds the value. It floors value between 99 and 100, to not\n     * show task as completed when it is for example 99.51% done.\n     * @property {Number}\n     * @category Progress\n     */\n    get renderedPercentDone() {\n        const value = typeof this.percentDone === 'number' && !isNaN(this.percentDone) ? this.percentDone : 0;\n\n        return this.getFormattedPercentDone(value);\n    }\n\n    getFormattedPercentDone(value = 0) {\n        if (value <= 99) {\n            return Math.round(value);\n        }\n\n        return Math.floor(value);\n    }\n\n    set renderedPercentDone(value) {\n        this.percentDone = value;\n    }\n};\n", "import { SchedulerProEventSegment } from '../../Engine/quark/model/scheduler_pro/SchedulerProEventSegment.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport EventModelMixin from '../../Scheduler/model/mixin/EventModelMixin.js';\nimport PercentDoneMixin from './mixin/PercentDoneMixin.js';\n\n/**\n * @module SchedulerPro/model/EventSegmentModel\n */\n\n/**\n * This class represents an individual segment of a split event.\n *\n * @extends Scheduler/model/TimeSpan\n * @mixes Scheduler/model/mixin/EventModelMixin\n * @mixes SchedulerPro/model/mixin/PercentDoneMixin\n */\nexport default class EventSegmentModel extends SchedulerProEventSegment.derive(TimeSpan).mixin(\n    EventModelMixin,\n    PercentDoneMixin\n) {\n    static get $name() {\n        return 'EventSegmentModel';\n    }\n\n    /**\n     * Zero-based index of the segment.\n     * @property {Number} segmentIndex\n     */\n\n    /**\n     * The event this segment belongs to.\n     * @member {SchedulerPro.model.EventModel} event\n     * @readonly\n     */\n\n    /**\n     * Alias for `event`, to better match naming in Gantt.\n     * @member {SchedulerPro.model.EventModel} task\n     * @readonly\n     */\n    get task() {\n        return this.event;\n    }\n}\n", "/**\n * @module SchedulerPro/data/stm/action/EventUpdateAction\n */\nimport UpdateAction from '../../../../Core/data/stm/action/UpdateAction.js';\n\n/**\n * Action to record the fact that an event model has been updated.\n * @extends Core/data/stm/action/UpdateAction\n */\nexport default class EventUpdateAction extends UpdateAction {\n\n    get type() {\n        return 'EventUpdateAction';\n    }\n\n    construct(config) {\n        let {\n            model,\n            newData,\n            oldData\n        } = config;\n\n        // If we have \"segments\" represented in both old & new data states\n        if (newData.segments && oldData.segments) {\n            oldData = { ...oldData };\n            newData = { ...newData };\n\n            const\n                oldDataSegments = oldData.segments.slice(),\n                newDataSegments = newData.segments.slice();\n\n            let hasChanges = false;\n\n            // If a segment instance exists in both states\n            // we need to find segments existing in both versions.\n            // They should not be changed when undo/redo the main event\n            // since their model changes are recorded by STM.\n            oldData.segments.forEach((segment, index) => {\n                const newDataIndex = newData.segments.indexOf(segment);\n\n                // If a segment instance exists in both states\n                // we uses it as-is ..since STM is supposed to handle the instance changes\n                if (newDataIndex > -1) {\n                    oldDataSegments[index] = newDataSegments[newDataIndex] = segment;\n                    hasChanges = true;\n                }\n            });\n\n            if (hasChanges) {\n                oldData.segments = oldDataSegments;\n                newData.segments = newDataSegments;\n            }\n        }\n\n        return super.construct({\n            model,\n            newData,\n            oldData\n        });\n    }\n}\n", "import GridRowModel from '../../Grid/data/GridRowModel.js';\nimport ResourceModelMixin from '../../Scheduler/model/mixin/ResourceModelMixin.js';\nimport { SchedulerProResourceMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProResourceMixin.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n\n/**\n * @module SchedulerPro/model/ResourceModel\n */\n\n/**\n * This class represent a single Resource in Scheduler Pro, usually added to a {@link SchedulerPro.data.ResourceStore}.\n *\n * It is a subclass of  {@link Core.data.Model}. Please refer to the documentation for that class to become familiar\n * with the base interface of the resource.\n *\n * ## Fields and references\n *\n * A resource has a few predefined fields, see Fields below. If you want to add more fields with meta data describing\n * your resources then you should subclass this class:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *       // \"id\" and \"name\" fields are already provided by the superclass\n *       { name: 'company', type : 'string' }\n *     ];\n *   }\n * });\n * ```\n *\n * If you want to use other names in your data for the id and name fields you can configure them as seen below:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *        { name: 'name', dataSource: 'userName' }\n *     ];\n *   },\n * });\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `{@link #property-assignments}` - The linked assignment records\n * - `{@link #property-events}` - The linked (through assignments) event records\n *\n * ## Async resolving of references\n *\n * As described above, a resource has links to assignments and events. These references are populated async, using the\n * calculation engine of the project that the resource via its store is a part of. Because of this asyncness, references\n * cannot be used immediately after assignment modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // resource.assignments is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // resource.assignments is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // resource.assignments is up to date\n * ```\n *\n * @extends Grid/data/GridRowModel\n * @mixes Scheduler/model/mixin/ResourceModelMixin\n *\n * @typings Scheduler/model/ResourceModel -> Scheduler/model/SchedulerResourceModel\n */\nexport default class ResourceModel extends PartOfProject(ResourceModelMixin(SchedulerProResourceMixin.derive(GridRowModel))) {\n\n    //region Calendar\n\n    /**\n     * Sets the calendar of the task. Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method setCalendar\n     * @param {SchedulerPro.model.CalendarModel} calendar The new calendar. Provide `null` to use the project calendar.\n     * @async\n     * @propagating\n     */\n\n    /**\n     * Returns the resource calendar.\n     *\n     * @method getCalendar\n     * @returns {SchedulerPro.model.CalendarModel} The resource calendar.\n     */\n\n    /**\n     * The calendar, assigned to the entity. Allows you to set the time when entity can perform the work.\n     *\n     * @field {SchedulerPro.model.CalendarModel} calendar\n     * @accepts {SchedulerPro.model.CalendarModel|String}\n     * @category Scheduling\n     */\n\n    //endregion\n\n    //region Config\n\n    static get $name() {\n        return 'ResourceModel';\n    }\n\n    //endregion\n\n    /**\n     * Get associated events\n     *\n     * @member {SchedulerPro.model.EventModel[]} events\n     * @readonly\n     * @category Common\n     */\n\n    /**\n     * Returns all assignments for the resource\n     *\n     * @member {SchedulerPro.model.AssignmentModel[]} assignments\n     * @category Common\n     */\n\n    //region Early render\n\n    get assigned() {\n        const { project } = this;\n\n        // Figure assigned events out before buckets are created (if part of project)\n        if (project?.assignmentStore.storage._indices?.resource) {\n            return project.assignmentStore.storage.findItem('resource', this) ?? new Set();\n        }\n\n        return super.assigned;\n    }\n\n    set assigned(assigned) {\n        super.assigned = assigned;\n    }\n\n    //endregion\n}\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport ResourceStoreMixin from '../../Scheduler/data/mixin/ResourceStoreMixin.js';\nimport ResourceModel from '../model/ResourceModel.js';\nimport { ChronoResourceStoreMixin } from '../../Engine/quark/store/ChronoResourceStoreMixin.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n\n/**\n * @module SchedulerPro/data/ResourceStore\n */\n\n/**\n * A store holding all the {@link SchedulerPro.model.ResourceModel resources} to be rendered into a\n * {@link SchedulerPro.view.SchedulerPro Scheduler Pro}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.ResourceModel}.\n *\n * A ResourceStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and DependencyStore). The project also handles references (assignments, events) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * resourceStore.data = [{ id }, ...];\n *\n * // references (assignments, events) not resolved yet\n *\n * await resourceStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await resourceStore.loadDataAsync([{ id }, ...]);\n *\n * // references (assignments, events) are resolved\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/ResourceStoreMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/ResourceStore -> Scheduler/data/SchedulerResourceStore\n */\nexport default class ResourceStore extends PartOfProject(ResourceStoreMixin(ChronoResourceStoreMixin.derive(AjaxStore))) {\n\n    static get defaultConfig() {\n        return {\n            modelClass : ResourceModel\n        };\n    }\n\n}\n", "/**\n * @module SchedulerPro/data/stm/StateTrackingManager\n */\nimport EventUpdateAction from './action/EventUpdateAction.js';\nimport CoreStateTrackingManager from '../../../Core/data/stm/StateTrackingManager.js';\nimport UpdateAction from '../../../Core/data/stm/action/UpdateAction.js';\n\nexport const makeModelUpdateAction = (model, newData, oldData) => {\n    // if that's a SplitEventMixin instance\n    if (model.isSplitEventMixin) {\n        return new EventUpdateAction({\n            model,\n            newData,\n            oldData\n        });\n    }\n\n    return new UpdateAction({\n        model,\n        newData,\n        oldData\n    });\n};\n\n/**\n * {@link Core/data/stm/StateTrackingManager} subclass that's aware of the Scheduler Pro data structure specifics,\n * namely supports tracking of event segment changes.\n *\n * There is normally no need to deal with this class manually since it's instantiated automatically by the project\n * and can be reached like this:\n * ```javascript\n * project.stm\n * ```\n *\n * ## Tracking store changes\n *\n * Tracks the state of every store registered via {@link #function-addStore}. It is {@link #config-disabled} by default\n * so remember to call {@link #function-enable} when your stores are registered and initial dataset is loaded.\n * Use {@link #function-undo} / {@link #function-redo} method calls to restore state to a particular\n * point in time\n *\n * ```javascript\n * stm = new StateTrackingManager({\n *     autoRecord : true,\n *     listeners  : {\n *        'recordingstop' : () => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        },\n *        'restoringstop' : ({ stm }) => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        }\n *    },\n *    getTransactionTitle : (transaction) => {\n *        // your custom code to analyze the transaction and return custom transaction title\n *        const lastAction = transaction.queue[transaction.queue.length - 1];\n *\n *        if (lastAction instanceof AddAction) {\n *            let title = 'Add new record';\n *        }\n *\n *        return title;\n *    }\n * });\n *\n * stm.addStore(userStore);\n * stm.addStore(companyStore);\n * stm.addStore(otherStore);\n *\n * stm.enable();\n * ```\n *\n * ## Resetting the queue on data loading\n *\n * When loading data from the server it makes perfect sense to {@link #function-resetQueue reset the queue}.\n *\n * If project (CrudManager protocol) is used for data loading it can be done like this:\n *\n * ```javascript\n * project.on({\n *     load() {\n *         project.stm.resetQueue();\n *     }\n * });\n * ```\n *\n * and in case individual stores are used:\n *\n * ```javascript\n * ajaxStore.on({\n *     load() {\n *         ajaxStore.stm.resetQueue();\n *     }\n * });\n * ```\n *\n * @extends Core/data/stm/StateTrackingManager\n * @typings Core/data/stm/StateTrackingManager -> Core/data/stm/CoreStateTrackingManager\n */\nexport default class StateTrackingManager extends CoreStateTrackingManager {\n\n    static get defaultConfig() {\n        return {\n            makeModelUpdateAction\n        };\n    }\n\n}\n", "import DateHelper from '../../Core/helper/DateHelper.js';\nimport Model from '../../Core/data/Model.js';\nimport Localizable from '../../Core/localization/Localizable.js';\n\n/**\n * @module SchedulerPro/model/VersionModel\n */\n\n/**\n * Represents a snapshot of a {@link SchedulerPro.model.ProjectModel} at a point in time.\n * Each VersionModel has an associated set of {@link SchedulerPro.model.changelog.ChangeLogTransactionModel changes} that describe the\n * user-initiated modifications to the project that happened since the previous version was captured.\n *\n * @extends Core/data/Model\n */\nexport default class VersionModel extends Localizable(Model) {\n    static get $name() {\n        return 'VersionModel';\n    }\n\n    /**\n     * @hidefields id, readOnly, children, parentId, parentIndex\n     */\n\n    static fields = [\n        /**\n         * The name of the version. When an auto-saved version's `name` is `null`, the version description\n         * will return a default text description instead.\n         *\n         * @field {String} name\n         * @category Common\n         */\n        {\n            name : 'name',\n            type : 'string'\n        },\n\n        /**\n         * Whether this version was auto-saved.\n         *\n         * @field {Boolean} isAutosave\n         * @category Common\n         */\n        {\n            name : 'isAutosave',\n            type : 'boolean'\n        },\n\n        /**\n         * A serializable object snapshot of the {@link SchedulerPro.model.ProjectModel} at the point in time when the\n         * version was created.\n         *\n         * Note that this field is not loaded from the backend by default, due to its size. The\n         * {@link SchedulerPro.feature.Versions} feature manages loading the contents of this field on demand.\n         *\n         * @field {Object} content\n         * @category Common\n         */\n        {\n            name : 'content',\n            type : 'object'\n        },\n\n        /**\n         * The timestamp when the version was created.\n         *\n         * @field {Date} savedAt\n         * @category Common\n         */\n        {\n            name : 'savedAt',\n            type : 'date'\n        }\n    ];\n\n    onBeforeSave() { }\n\n    get description() {\n        return this.name ?? this.defaultDescription;\n    }\n\n    get defaultDescription() {\n        return `${this.isAutosave ? 'Auto-saved' : 'Saved'} at ${DateHelper.format(this.savedAt,\n            this.L(`L{Versions.versionDateFormat}`))}`;\n    }\n\n}\n\nVersionModel.exposeProperties();\n", "import PartOfProject from './mixin/PartOfProject.js';\nimport Store from '../../Core/data/Store.js';\nimport VersionModel from '../model/VersionModel.js';\n\n/**\n * @module SchedulerPro/data/VersionStore\n */\n\n/**\n * A {@link Core.data.Store} that contains the list of saved versions of the project,\n * managed by the {@link SchedulerPro.feature.Versions} feature.\n * See also {@link SchedulerPro.data.ChangeLogStore}.\n *\n * You can provide a custom subclass of {@link SchedulerPro.model.VersionModel} using the\n * {@link SchedulerPro.feature.Versions#config-versionModelClass} config.\n *\n * @extends Core/data/Store\n */\nexport default class VersionStore extends Store.mixin(\n    PartOfProject\n) {\n\n    static $name = 'VersionStore';\n\n    static configurable = {\n        modelClass : VersionModel,\n        storeId    : 'versions'\n    };\n}\n", "import ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport Localizable from '../../../Core/localization/Localizable.js';\nimport Model from '../../../Core/data/Model.js';\n\n/**\n * @module SchedulerPro/model/changelog/ChangeLogTransactionModel\n */\n\n/**\n * Represents a set of changes made as a result of a single user action. Changelog transactions may\n * optionally be associated with a single VersionModel.\n *\n * In normal usage, the Versions feature will capture one ChangeLogTransactionModel as a result of\n * a single user action, for example, dragging a task on the timeline. This transaction will contain\n * multiple {@link SchedulerPro.model.changelog.ChangeLogAction}s representing the various effects that\n * dragging a task can have - changes to start and end dates, updates to related dependent tasks, and\n * so on.\n *\n * Changelog transactions can be customized by extending a new model from `ChangeLogTransactionModel`.\n * For an example, see the Gantt versions demo.\n *\n * Individual changes making up a transaction are stored in the {@link #field-actions} field.\n *\n * Refer to {@link SchedulerPro.feature.Versions} for more information about versioning.\n *\n * @extends Core/data/Model\n * @demo Gantt/versions\n */\nexport default class ChangeLogTransactionModel extends Localizable(Model) {\n    static $name = 'ChangeLogTransactionModel';\n\n    /**\n     * @hidefields id, readOnly, children, parentId, parentIndex\n     */\n\n    static fields = [\n        /**\n         * The ID of the version to which this transaction belongs, or null if the transaction\n         * is not yet associated with any version.\n         * @field {String} versionId\n         * @category Common\n         */\n        {\n            name : 'versionId'\n        },\n\n        /**\n         * The {@link SchedulerPro.model.changelog.ChangeLogAction}s that this transaction comprises.\n         * @field {SchedulerPro.model.changelog.ChangeLogAction[]} actions\n         * @category Common\n         */\n        {\n            name : 'actions',\n            type : 'array'\n        },\n\n        /**\n         * The date and time when the transaction started.\n         * @field {Date} occurredAt\n         * @category Common\n         */\n        {\n            name : 'occurredAt',\n            type : 'date'\n        },\n\n        /**\n         * An optional, custom text description of the transaction.\n         * @field {String} description\n         * @category Common\n         */\n        {\n            name : 'description',\n            type : 'string'\n        }\n    ];\n\n    get description() {\n        return this.get('description') ?? this.defaultDescription;\n    }\n\n    get actions() {\n        return this.get('actions') ?? [];\n    }\n\n    get defaultDescription() {\n        if (this.actions.length === 0) {\n            return this.L(`L{Versions.noChanges}`); // Normally shouldn't happen\n        }\n        const\n            me = this,\n            actionTypes = ArrayHelper.unique(me.actions.map(({ actionType }) => {\n                if (actionType.startsWith('add')) {\n                    return 'add';\n                }\n                if (actionType.startsWith('remove')) {\n                    return 'remove';\n                }\n                if (actionType.startsWith('update')) {\n                    return 'update';\n                }\n                return actionType;\n            })),\n            entityTypes = ArrayHelper.unique(me.actions.map(({ entity }) => entity.type)),\n            entityCount = ArrayHelper.unique(me.actions.map(({ entity }) => `${entity.type}.${entity.id}`)).length,\n            transactionDescriptions = me.L(`L{Versions.transactionDescriptions}`),\n            entityNames = me.L(`L{Versions.entityNames}`),\n            entityNamesPlural = me.L(`L{Versions.entityNamesPlural}`),\n            firstEntityType = entityTypes[0],\n            assortedEntityTypes = entityTypes.length > 1;\n\n        return transactionDescriptions[actionTypes.length > 1 ? 'mixed' : actionTypes[0]]\n            .replace('{n}', entityCount)\n            .replace('{entities}', entityCount > 1\n                ? (entityNamesPlural[assortedEntityTypes ? 'other' : firstEntityType] ?? entityNamesPlural.other)\n                : (entityNames[firstEntityType] ?? entityNames.other));\n    }\n\n}\n\nChangeLogTransactionModel.exposeProperties();\n", "import PartOfProject from './mixin/PartOfProject.js';\nimport Store from '../../Core/data/Store.js';\nimport ChangeLogTransactionModel from '../model/changelog/ChangeLogTransactionModel.js';\n\n/**\n * @module SchedulerPro/data/ChangeLogStore\n */\n\n/**\n * A {@link Core.data.Store} that contains the changelog, an append-only record of changes to the project,\n * managed by the {@link SchedulerPro.feature.Versions} feature. See also {@link SchedulerPro.data.VersionStore}.\n *\n * You can provide a custom subclass of {@link SchedulerPro.model.changelog.ChangeLogTransactionModel} using the\n * {@link SchedulerPro.feature.Versions#config-transactionModelClass} configuration.\n *\n * @extends Core/data/Store\n */\nexport default class ChangeLogStore extends Store.mixin(\n    PartOfProject\n) {\n\n    static $name = 'ChangeLogStore';\n\n    static configurable = {\n        modelClass : ChangeLogTransactionModel,\n        storeId    : 'changelogs'\n    };\n}\n", "import SchedulerProjectCrudManager from '../../../Scheduler/data/mixin/ProjectCrudManager.js';\nimport Base from '../../../Core/Base.js';\n\n/**\n * @module SchedulerPro/data/mixin/ProjectCrudManager\n */\n\n// the order of the @mixes tags is important below, as the \"AbstractCrudManagerMixin\"\n// contains the abstract methods, which are then overwritten by the concrete\n// implementation in the AjaxTransport and JsonEncoder\n\n/**\n * This mixin provides Crud manager functionality to a Scheduler Pro project.\n * The mixin turns the provided project model into a Crud manager instance.\n *\n * @mixin\n * @mixes Scheduler/data/mixin/ProjectCrudManager\n * @typings Scheduler/data/mixin/ProjectCrudManager -> Scheduler/data/mixin/SchedulerProjectCrudManager\n */\nexport default Target => class ProjectCrudManager extends (Target || Base).mixin(SchedulerProjectCrudManager) {\n    static get configurable() {\n        return {\n            crudLoadValidationWarningPrefix : 'Project load response error(s):',\n\n            crudSyncValidationWarningPrefix : 'Project sync response error(s):',\n\n            /**\n             * If `true`, project {@link #property-changes} API will also report project model changes: start/end date,\n             * calendar, effort, duration, etc.\n             * @prp {Boolean}\n             * @default\n             */\n            trackProjectModelChanges : false\n        };\n    }\n\n    construct(...args) {\n        const me = this;\n\n        super.construct(...args);\n\n        // add the Engine specific stores to the crud manager\n        me.addPrioritizedStore(me.calendarManagerStore);\n        me.addPrioritizedStore(me.assignmentStore);\n        me.addPrioritizedStore(me.dependencyStore);\n        me.addPrioritizedStore(me.resourceStore);\n        me.addPrioritizedStore(me.eventStore);\n        if (me.timeRangeStore) {\n            me.addPrioritizedStore(me.timeRangeStore);\n        }\n        if (me.resourceTimeRangeStore) {\n            me.addPrioritizedStore(me.resourceTimeRangeStore);\n        }\n    }\n\n    get project() {\n        return this;\n    }\n\n    set project(value) {\n        super.project = value;\n    }\n\n    get crudLoadValidationMandatoryStores() {\n        return [this.getStoreDescriptor(this.eventStore).storeId];\n    }\n\n    loadCrudManagerData(...args) {\n        if (this.delayCalculation && !this.isDelayingCalculation && !this.usingSyncDataOnLoad()) {\n            this.scheduleDelayedCalculation();\n        }\n\n        super.loadCrudManagerData(...args);\n    }\n\n    acceptChanges() {\n        super.acceptChanges();\n\n        // clear project model own field changes\n        this.clearChanges(true, false);\n    }\n\n    revertChanges() {\n        // revertChanges method exists both on the Model and AbstractCrudManagerMixin class\n        // so here we have to couple both of them\n\n        // first invoke Crud Manager logic\n        this.revertCrudStoreChanges();\n\n        // then invoke Model logic - revert project model own field changes\n        this.set(this.meta.modified, undefined, true);\n    }\n\n    // Override to take into account project model own field changes\n    crudStoreHasChanges(storeId) {\n        const store = this.getCrudStore(storeId);\n\n        let result;\n\n        if (store) {\n            result = super.crudStoreHasChanges(store);\n        }\n        else {\n            result = this.hasPersistableChanges || super.crudStoreHasChanges();\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns current changes as an object consisting of added/modified/removed arrays of records for every\n     * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:\n     *\n     * ```javascript\n     * {\n     *     resources : {\n     *         added    : [{ name : 'New guy' }],\n     *         modified : [{ id : 2, name : 'Mike' }],\n     *         removed  : [{ id : 3 }]\n     *     },\n     *     events : {\n     *         modified : [{  id : 12, name : 'Cool task' }]\n     *     },\n     *     ...\n     * }\n     * ```\n     *\n     * To also include changes of the project model itself set {@link #property-trackProjectModelChanges} to `true`:\n     *\n     * ```javascript\n     * {\n     *     project : {\n     *         calendar  : 'custom',\n     *         startDate : '2020-02-02',\n     *         endDate   : '2020-02-10\n     *     },\n     *     resources : {...},\n     *     events    : {...}\n     * }\n     * ```\n     *\n     * @property {Object}\n     * @readonly\n     * @category CRUD\n     */\n    get changes() {\n        let changes = super.changes;\n\n        if (this.trackProjectModelChanges) {\n            const projectChanges = this.modificationDataToWrite;\n\n            // include project changes\n            if (projectChanges) {\n                changes = changes || {};\n                changes.project = projectChanges;\n            }\n        }\n\n        return changes;\n    }\n\n    shouldClearRecordFieldChange(record, field, value) {\n        // If that's a calendar model \"intervals\" field\n        // we just check if the underlying store is actually dirty.\n        if (record.isCalendarModel && field === 'intervals') {\n            return !record.get('intervals').changes;\n        }\n\n        return super.shouldClearRecordFieldChange(...arguments);\n    }\n};\n", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport SchedulerEventResize from '../../Scheduler/feature/EventResize.js';\n\n/**\n * @module SchedulerPro/feature/EventResize\n */\n\n/**\n * Feature that allows resizing an event by dragging its end.\n *\n * By default it displays a tooltip with the new start and end dates, formatted using\n * {@link Scheduler.view.mixin.TimelineViewPresets#config-displayDateFormat}.\n *\n * This feature is **enabled** by default\n *\n * @inlineexample SchedulerPro/feature/EventResize.js\n * @extends Scheduler/feature/EventResize\n * @typings Scheduler/feature/EventResize -> Scheduler/feature/SchedulerEventResize\n * @classtype eventResize\n * @feature\n */\nexport default class EventResize extends SchedulerEventResize {\n    static get $name() {\n        return 'EventResize';\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        super.render(...arguments);\n\n        // Only active when in these items (ignore segments)\n        me.dragSelector = me.dragItemSelector = client.eventSelector + ':not(.b-sch-event-segment)';\n    }\n}\n\nGridFeatureManager.registerFeature(EventResize, true, 'SchedulerPro');\n", "import DateHelper from '../../Core/helper/DateHelper.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventResize from '../../SchedulerPro/feature/EventResize.js';\n\n/**\n * @module SchedulerPro/feature/EventSegmentResize\n */\n\n/**\n * Feature that allows resizing an event segment by dragging its end.\n *\n * {@inlineexample SchedulerPro/feature/EventSegments.js}\n *\n * This feature is **enabled** by default\n *\n * @extends SchedulerPro/feature/EventResize\n * @classtype eventSegmentResize\n * @feature\n */\nexport default class EventSegmentResize extends EventResize {\n\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler Pro before resizing starts. Return `false` to prevent the action.\n     * @event beforeEventSegmentResize\n     * @on-owner\n     * @preventable\n     * @param {SchedulerPro.view.SchedulerPro} source Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} eventRecord Segment being resized\n     * @param {SchedulerPro.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro when segment resizing starts\n     * @event eventSegmentResizeStart\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} eventRecord Segment being resized\n     * @param {SchedulerPro.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro on each segment resize move event\n     * @event eventSegmentPartialResize\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} eventRecord Segment being resized\n     * @param {Date} startDate\n     * @param {Date} endDate\n     * @param {HTMLElement} element\n     */\n\n    /**\n     * Fired on the owning Scheduler Pro to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     * ```javascript\n     *  scheduler.on('beforeEventSegmentResizeFinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     * @event beforeEventSegmentResizeFinalize\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source Scheduler Pro instance\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to handle resize asynchronously (e.g. to wait for user confirmation)\n     * @param {Function} context.finalize Call this method to finalize resize. This method accepts one argument:\n     *                   pass `true` to update records, or `false`, to ignore changes\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro after the resizing gesture has finished.\n     * @event eventSegmentResizeEnd\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source Scheduler Pro instance\n     * @param {Boolean} changed Shows if the record has been changed by the resize action\n     * @param {SchedulerPro.model.EventModel} eventRecord Segment being resized\n     */\n\n    //endregion\n\n    //region Config\n\n    static $name = 'EventSegmentResize';\n\n    static get pluginConfig() {\n        return {\n            chain : [...super.pluginConfig.chain, 'isEventSegmentElementDraggable']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    render() {\n        super.render(...arguments);\n\n        // Only active when in these items\n        this.dragSelector = this.dragItemSelector = '.b-sch-event-segment';\n    }\n\n    // Prevent segment dragging when it starts over resize handles\n    isEventSegmentElementDraggable(eventElement, eventRecord, el, event) {\n        return this.isEventElementDraggable(...arguments);\n    }\n\n    // Prevent event dragging when it starts over resize handles\n    isEventElementDraggable(eventElement, eventRecord, el, event) {\n        const\n            me = this,\n            eventResizable = eventRecord?.resizable;\n\n        // ALLOW event drag:\n        // - if resizing is disabled or event is not resizable\n        // - if it's a milestone Milestones cannot be resized\n        if (me.disabled || !eventResizable || eventRecord.isMilestone) {\n            return true;\n        }\n\n        // not over a segment resize handle\n        if (eventRecord.segments) {\n            const eventName = me.client.scheduledEventName;\n\n            return eventRecord.segments.every((segmentRecord, index) => {\n                const\n                    segmentResizable = segmentRecord.resizable,\n                    segmentElement = DomSync.getChild(eventElement, `${eventName}.segments.${index}`);\n\n                return !segmentResizable ||\n                    (((segmentResizable !== true && segmentResizable !== 'start') ||\n                        !me.isOverStartHandle(event, segmentElement)) &&\n                    ((segmentResizable !== true && segmentResizable !== 'end') ||\n                        !me.isOverEndHandle(event, segmentElement)));\n            });\n        }\n\n        return super.isEventElementDraggable(...arguments);\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-segment-resize-tip`;\n    }\n\n    dragStart(drag) {\n        this._segmentsSlices      = null;\n        this._segmentsSlicesIndex = 0;\n\n        return super.dragStart(...arguments);\n    }\n\n    beginEventRecordBatch(eventRecord) {\n        super.beginEventRecordBatch(eventRecord);\n\n        // when resizing segment we change its master event too\n        if (eventRecord.isEventSegment) {\n            eventRecord.event.beginBatch();\n        }\n    }\n\n    // Subclasses may override this\n    triggerBeforeResize(drag) {\n        const\n            { client }  = this,\n            name        = client.scheduledEventName,\n            eventRecord = client.resolveTimeSpanRecord(drag.itemElement);\n\n        return client.trigger(\n            `before${client.capitalizedEventName}SegmentResize`,\n            {\n                [name + 'Record'] : eventRecord,\n                event             : drag.event,\n                ...this.getBeforeResizeParams({ event : drag.startEvent, element : drag.itemElement })\n            }\n        );\n    }\n\n    // Subclasses may override this\n    triggerEventResizeStart(eventType, event) {\n        const { client } = this;\n\n        client.trigger(`${client.scheduledEventName}SegmentResizeStart`, event);\n    }\n\n    triggerEventResizeEnd(eventType, event) {\n        const { client } = this;\n\n        client.trigger(`${client.scheduledEventName}SegmentResizeEnd`, event);\n    }\n\n    triggerEventPartialResize(eventType, event) {\n        // Trigger eventPartialResize or taskPartialResize depending on product\n        const { client } = this;\n\n        client.trigger(`${client.scheduledEventName}SegmentPartialResize`, event);\n    }\n\n    triggerBeforeEventResizeFinalize(eventType, event) {\n        const { client } = this;\n\n        client.trigger(`before${client.capitalizedEventName}SegmentResizeFinalize`, event);\n    }\n\n    applyDateConstraints(date, eventRecord, context) {\n        let\n            minDate = context.dateConstraints?.start,\n            maxDate = context.dateConstraints?.end;\n\n        // constrain segment resize w/ previous & next segments\n        if (eventRecord.isEventSegment) {\n            const { previousSegment, nextSegment } = eventRecord;\n\n            if (previousSegment) {\n                minDate = minDate ? DateHelper.max(previousSegment.endDate, minDate) : previousSegment.endDate;\n            }\n\n            if (nextSegment) {\n                maxDate = maxDate ? DateHelper.min(nextSegment.startDate, maxDate) : nextSegment.startDate;\n            }\n        }\n\n        // Keep desired date within constraints\n        if (minDate || maxDate) {\n            date = DateHelper.constrain(date, minDate, maxDate);\n            context.snappedDate = DateHelper.constrain(context.snappedDate, minDate, maxDate);\n        }\n\n        return date;\n    }\n\n    resizeEventPartiallyInternal(eventRecord, context) {\n        const\n            { toSet } = context;\n\n        super.resizeEventPartiallyInternal(...arguments);\n\n        // in case that's a segment\n        if (eventRecord.isEventSegment) {\n            const { event } = eventRecord;\n\n            // if that's the last segment and user is dragging its endDate\n            // -> update the event endDate too\n            if (!eventRecord.nextSegment && toSet === 'endDate') {\n                event.set('endDate', context[toSet]);\n            }\n            // if that's the first segment and user is dragging its startDate\n            // -> update the event startDate too\n            else if (!eventRecord.previousSegment && toSet === 'startDate') {\n                event.set('startDate', context[toSet]);\n            }\n            else {\n                const segmentsField = event.fieldMap['segments'];\n\n                // Set a special flag on \"segments\" field forcing changes by making isEqual() result false\n                segmentsField._skipSegmentsIsEqual++;\n                event.set('segments', event.get('segments'));\n                segmentsField._skipSegmentsIsEqual--;\n            }\n        }\n\n    }\n\n    cancelEventRecordBatch(eventRecord) {\n        super.cancelEventRecordBatch(eventRecord);\n\n        // if resizing a segment revert master event changes too\n        if (eventRecord.isEventSegment) {\n            eventRecord.event.cancelBatch();\n        }\n    }\n\n    /**\n     * Highlights handles (applies css that changes cursor).\n     * @private\n     */\n    highlightHandle() {\n        const { overItem } = this;\n\n        // over a handle, add cls to change cursor\n        overItem.classList.add('b-resize-handle', 'b-over-resize-handle');\n    }\n\n    /**\n     * Unhighlight handles (removes css).\n     * @private\n     */\n    unHighlightHandle(item = this.overItem) {\n        item?.classList.remove('b-resize-handle', this.resizingItemInnerCls, 'b-over-resize-handle', this.draggingItemCls);\n    }\n\n    //endregion\n\n}\n\nGridFeatureManager.registerFeature(EventSegmentResize, true, 'SchedulerPro');\nGridFeatureManager.registerFeature(EventSegmentResize, false, 'ResourceHistogram');\n", "import DomClassList from '../../Core/helper/util/DomClassList.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module SchedulerPro/feature/EventSegments\n */\n\n/**\n * This feature provides segmented events support. It implements rendering of such events and also adds a entries to the\n * event context menu allowing to split the selected event and rename segments.\n *\n * {@inlineexample SchedulerPro/feature/EventSegments.js}\n *\n * The feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventSegments\n * @feature\n */\nexport default class EventSegments extends InstancePlugin {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{splitEvent}'\n    ];\n    // endregion\n    // </debug>\n\n    //region Config\n\n    static $name = 'EventSegments';\n\n    static configurable = {\n        /**\n         * The split duration to be used when \"Split event\" menu item is called.\n         * When set to zero (default) the duration is calculated automatically as the clicked tick duration\n         * restricted by {@link #config-minSplitDuration} and {@link #config-maxSplitDuration} values.\n         *\n         * The duration can be provided as {@link Core.data.Duration} instance (or its configuration object) including\n         * both numeric and unit parts.\n         * ```js\n         * ...\n         * features : {\n         *     eventSegments : {\n         *         // split events by 1 day\n         *         splitDuration : {\n         *             magnitude : 1,\n         *             unit      : \"day\"\n         *         }\n         *     }\n         * ...\n         * ```\n         * Or it can be provided as a positive number which means it's expressed in the clicked event\n         * {@link SchedulerPro.model.EventModel#field-durationUnit duration units}.\n         * @config {Core.data.Duration|DurationConfig|Number}\n         * @default\n         */\n        splitDuration : 0,\n\n        /**\n         * Maximum allowed {@link #config-splitDuration split duration}.\n         * The value is used when calculating split duration automatically.\n         *\n         * Setting the config to zero means not limiting {@link #config-splitDuration split duration} max value.\n         *\n         * The duration can be provided as {@link Core.data.Duration} instance (or its configuration object) including\n         * both numeric and unit parts.\n         * ```javascript\n         * ...\n         * features : {\n         *     eventSegments : {\n         *         // split duration is automatic and changes depending on zoom level\n         *         // but we limit its maximum as 1 week\n         *         maxSplitDuration : {\n         *             magnitude : 1,\n         *             unit      : \"week\"\n         *         }\n         *     }\n         * ...\n         * ```\n         * Or it can be provided as a positive number which means it's expressed in the clicked event\n         * {@link SchedulerPro.model.EventModel#field-durationUnit duration units}.\n         *\n         * Defaults to 1 day.\n         *\n         * @config {Core.data.Duration|DurationConfig|Number}\n         */\n        maxSplitDuration : {\n            magnitude : 1,\n            unit      : 'day'\n        },\n\n        /**\n         * Minimum allowed {@link #config-splitDuration split duration}.\n         * The value is used when calculating split duration automatically.\n         *\n         * Setting the config to zero (default) means not limiting {@link #config-splitDuration split duration}\n         * min value.\n         *\n         * The duration can be provided as {@link Core.data.Duration} instance (or its configuration object) including\n         * both numeric and unit parts.\n         * ```js\n         * ...\n         * features : {\n         *     eventSegments : {\n         *         // split duration is automatic and changes depending on zoom level\n         *         // limit its minimum as 1 hour\n         *         minSplitDuration : {\n         *             magnitude : 1,\n         *             unit      : \"hour\"\n         *         }\n         *         // we limit its maximum as 1 day\n         *         maxSplitDuration : {\n         *             magnitude : 1,\n         *             unit      : \"day\"\n         *         }\n         *     }\n         * ...\n         * ```\n         * Or it can be provided as a positive number which means it's expressed in the clicked event\n         * {@link SchedulerPro.model.EventModel#field-durationUnit duration units}.\n         * @config {Core.data.Duration|DurationConfig|Number}\n         * @default\n         */\n        minSplitDuration : 0\n    };\n\n    static pluginConfig = {\n        override : [\n            'getElementsFromEventRecord',\n            'resolveEventRecord',\n            'resolveTaskRecord',\n            'onElementMouseOut'\n        ],\n        chain : [\n            'populateTaskMenu',\n            'populateEventMenu',\n            'onTaskDataGenerated',\n            'onEventDataGenerated'\n        ]\n    };\n\n    //endregion\n\n    onElementMouseOut(event) {\n        const\n            me = this,\n            { client } = me,\n            { target, relatedTarget } = event,\n            eventWrap                 = target.closest(client.eventSelector),\n            timeSpanRecord            = client.resolveTimeSpanRecord(target);\n\n        // We must be over the event bar\n        if (timeSpanRecord?.isEventSegment && eventWrap && client.hoveredEvents.has(eventWrap)) {\n            // out to child shouldn't count...\n            if (relatedTarget && DomHelper.isDescendant(eventWrap, relatedTarget)) {\n                return;\n            }\n        }\n\n        this.overridden.onElementMouseOut(...arguments);\n    }\n\n    //region Segment record <-> DOM resolution\n\n    // Override Scheduler getElementsFromEventRecord so it could handle segment records\n    getElementsFromEventRecord(eventRecord, resourceRecord) {\n        // if that's a segment\n        if (eventRecord?.isEventSegment) {\n            // get the main event element\n            const mainEventElement = this.overridden.getElementsFromEventRecord(eventRecord.event, resourceRecord)[0];\n\n            return [DomSync.getChild(mainEventElement, 'segments.' + eventRecord.segmentIndex)];\n        }\n\n        return this.overridden.getElementsFromEventRecord(...arguments);\n    }\n\n    // Override Scheduler resolveEventRecord so it could get segment record by element\n    resolveEventRecord(elementOrEvent) {\n        const\n            element        = elementOrEvent instanceof Event ? elementOrEvent.target : elementOrEvent,\n            segmentElement = element?.closest('.b-sch-event-segment');\n\n        let result = this.overridden.resolveEventRecord(elementOrEvent);\n\n        if (result?.segments && segmentElement) {\n            result = result.segments[segmentElement.dataset.segment];\n        }\n\n        return result;\n    }\n\n    // Override Gantt resolveTaskRecord so it could get segment record by element\n    resolveTaskRecord(element) {\n        const segmentElement = element?.closest('.b-sch-event-segment');\n\n        let result = this.overridden.resolveTaskRecord(element);\n\n        if (result?.segments && segmentElement) {\n            result = result.segments[segmentElement.dataset.segment];\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    //region Context menu\n\n    populateTaskMenu(data) {\n        data.eventRecord = data.taskRecord;\n\n        // add entry if right clicked a task element\n        if (data.targetElement.closest(data.feature.client.eventSelector)) {\n            this.populateEventMenu(data);\n        }\n    }\n\n    populateEventMenu({ eventRecord, taskRecord, items, domEvent }) {\n        const me = this;\n\n        // add \"Split task\" entry if the component is NOT in readonly mode\n        // and it's not a summary task nor a milestone\n        if (!me.client.readOnly && !eventRecord.isParent && !eventRecord.milestone) {\n            items[`split${taskRecord ? 'Task' : 'Event'}`] = {\n                localeClass : me,\n                text        : `L{split${taskRecord ? 'Task' : 'Event'}}`,\n                icon        : 'b-icon b-icon-cut',\n                disabled    : eventRecord.readOnly,\n                weight      : 650,\n                separator   : true,\n                onItem(context) {\n                    me.splitEvent(context);\n                }\n            };\n\n            const segmentElement = domEvent.target.closest('.b-sch-event-segment');\n            if (segmentElement) {\n                const segmentRecord = me.client.resolveEventRecord(segmentElement);\n                items.renameSegment = {\n                    localeClass : me,\n                    text        : 'L{renameSegment}',\n                    icon        : 'b-icon b-icon-rename',\n                    disabled    : eventRecord.readOnly || segmentRecord.readOnly,\n                    weight      : 660,\n                    onItem() {\n                        me.rename(segmentRecord, segmentElement);\n                    }\n                };\n            }\n        }\n    }\n\n    /**\n     * Returns a date at which to split an event.\n     *\n     * Returns start date of the tick being clicked if the tick duration is less than {@link #config-maxSplitDuration}\n     * or {@link #config-maxSplitDuration} is zero.\n     * When the tick duration is greater than {@link #config-maxSplitDuration} returns `context.date` rounded based on\n     * active time axis resolution unit.\n     *\n     * Override this method if you want to implement another way of calculating the split date.\n     *\n     * See also: {@link #function-getSplitDuration}, {@link #function-getSplitDurationUnit}.\n     *\n     * @param  {Object}                        context             Split function-call context\n     * @param  {SchedulerPro.model.EventModel} context.eventRecord Event being split\n     * @param  {Array}                         context.point       Click position. Array containing [x, y] coordinates\n     * of mouse click.\n     * @param  {Date}                          context.date        Date corresponding to the click position.\n     * @param  {Object}                        context.tick        Time axis tick corresponding to the click position.\n     * @param  {Scheduler.data.TimeAxis}       context.timeAxis    Time axis instance.\n     * @return {Date} Returns a date to be used to split.\n     */\n    getSplitDate(context) {\n        const\n            {\n                eventRecord,\n                date,\n                timeAxis\n            } = context;\n\n        // round clicked datetime relative to event start using active time axis resolution unit\n        return timeAxis.roundDate(date, eventRecord.startDate);\n    }\n\n    /**\n     * Returns the event split duration.\n     *\n     * If {@link #config-splitDuration} value is provided:\n     * - as a `Number`the method returns the value as is\n     * - as an `Object` or {@link Core/data/Duration} instance - the method returns the value `unit` part\n     *\n     * If {@link #config-splitDuration} is **NOT** provided the method returns\n     * the clicked tick duration constrained by {@link #config-minSplitDuration} and\n     * {@link #config-maxSplitDuration} values.\n     *\n     * Override this method if you want to implement another way of the split duration calculating.\n     *\n     * See also: {@link #function-getSplitDate}, {@link #function-getSplitDurationUnit}.\n     *\n     * @param  {Object}                        context             Split call context\n     * @param  {SchedulerPro.model.EventModel} context.eventRecord Event being split\n     * @param  {Array}                         context.point       Click position. Array containing [x, y]\n     * coordinates of mouse click.\n     * @param  {Date}                          context.date        Date corresponding to the click position.\n     * @param  {Object}                        context.tick        Time axis tick corresponding to the click position.\n     * @param  {Scheduler.data.TimeAxis}       context.timeAxis    Time axis instance.\n     * @return {Number} Returns split duration.\n     */\n    getSplitDuration(context) {\n        const {\n            splitDuration,\n            minSplitDuration,\n            maxSplitDuration\n        } = this;\n\n        // if splitDuration is provided\n        if (splitDuration?.magnitude) {\n            return splitDuration.magnitude;\n        }\n\n        const { eventRecord, tick } = context;\n\n        if (tick) {\n            const\n                splitUnit   = this.getSplitDurationUnit(context),\n                { project } = eventRecord;\n\n            // use 1 tick in MS as initial duration\n            let splitDurationMS = tick.endDate - tick.startDate;\n\n            // constrain duration w/ max\n            if (maxSplitDuration) {\n                const maxDurationMs = project.run('$convertDuration',\n                    maxSplitDuration.magnitude,\n                    maxSplitDuration.unit || splitUnit,\n                    'millisecond'\n                );\n\n                splitDurationMS = Math.min(splitDurationMS, maxDurationMs);\n            }\n\n            // constrain duration w/ min\n            if (minSplitDuration) {\n                const minDurationMs = project.run('$convertDuration',\n                    minSplitDuration.magnitude,\n                    minSplitDuration.unit || splitUnit,\n                    'millisecond'\n                );\n\n                splitDurationMS = Math.max(splitDurationMS, minDurationMs);\n            }\n\n            // convert value to proper unit\n            return project.run('$convertDuration', splitDurationMS, 'millisecond', splitUnit);\n        }\n    }\n\n    /**\n     * Returns the duration unit to be used for the event splitting.\n     *\n     * When {@link #config-splitDuration} is provided as {@link Core/data/Duration} instance\n     * or its configuration Object:\n     * ```js\n     * ...\n     * features : {\n     *     eventSegments : {\n     *         // split events by 1 day\n     *         splitDuration : {\n     *             magnitude : 1,\n     *             unit      : \"day\"\n     *         }\n     *     }\n     *     ...\n     * }\n     *\n     * ```\n     * the method returns the value `unit` part otherwise it returns the event\n     * {@link SchedulerPro.model.EventModel#field-durationUnit}.\n     *\n     * Override this method config-if you want to implement another way of the split duration unit defining.\n     *\n     * See also: {@link #function-getSplitDate}, {@link #function-getSplitDuration}.\n     *\n     * @param  {Object}                        context             Split function-call context\n     * @param  {SchedulerPro.model.EventModel} context.eventRecord Event being split\n     * @param  {Array}                         context.point       Click position. Array containing [x, y] coordinates\n     * of mouse click.\n     * @param  {Date}                          context.date        Date corresponding to the click position.\n     * @param  {Object}                        context.tick        Time axis tick corresponding to the click position.\n     * @param  {Scheduler.data.TimeAxis}       context.timeAxis    Time axis instance.\n     * @return {String} Returns split duration unit.\n     */\n    getSplitDurationUnit(context) {\n        const { splitDuration } = this;\n\n        // use provided \"splitDuration\" unit or fallback to the event \"durationUnit\"\n        return splitDuration?.unit || context.eventRecord.durationUnit;\n    }\n\n    /**\n     * Handler for the \"Split event\" menu item\n     * @internal\n     */\n    splitEvent(context) {\n        const\n            { client }   = context.feature,\n            { timeAxis } = client;\n\n        context.date     = client.getDateFromXY(context.point, undefined, false);\n        context.tick     = timeAxis.getAt(Math.floor(timeAxis.getTickFromDate(context.date)));\n        context.timeAxis = timeAxis;\n\n        context.eventRecord.splitToSegments(\n            this.getSplitDate(context),\n            this.getSplitDuration(context),\n            this.getSplitDurationUnit(context)\n        );\n    }\n\n    rename(segmentRecord, element) {\n        const { client } = this;\n\n        const editor = new Editor({\n            owner        : client,\n            appendTo     : client.timeAxisSubGridElement,\n            scrollAction : 'realign',\n            align        : {\n                align : 'c-c'\n            },\n            cls               : 'b-event-segment-renamer',\n            internalListeners : {\n                complete() {\n                    // <remove-on-release>\n                    // TODO: This can be removed when we have change segments to use StoreDataField\n                    // </remove-on-release>\n                    client.refresh();\n                },\n                thisObj : this\n            }\n        });\n\n        editor.startEdit({\n            target : element,\n            record : segmentRecord,\n            field  : 'name'\n        });\n    }\n\n    //endregion\n\n    //region Contents\n\n    doDisable(disable) {\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n\n        super.doDisable(disable);\n    }\n\n    generateSegmentRenderData(segmentRecord, renderData) {\n        let result, segmentRenderData;\n\n        if (this.client.isGantt) {\n            const taskRendering = this.client.currentOrientation;\n\n            const\n                box  = taskRendering.getTaskBox(segmentRecord),\n                data = {\n                    taskRecord : segmentRecord,\n                    // <remove-on-release>\n                    // TODO: Deprecate\n                    // </remove-on-release>\n                    task       : segmentRecord,\n                    row        : renderData.row,\n                    children   : []\n                };\n\n            if (box) {\n                Object.assign(data, {\n                    isTask : true,\n                    top    : box.top,\n                    left   : box.left,\n                    width  : box.width,\n                    height : box.height\n                });\n            }\n\n            taskRendering.internalPopulateTaskRenderData(data, segmentRecord);\n\n            segmentRenderData = data;\n        }\n        else {\n            segmentRenderData = this.client.generateRenderData(segmentRecord, renderData.resourceRecord, true);\n        }\n\n        if (segmentRenderData) {\n            const { eventColor } = segmentRenderData;\n            result = {\n                segmentRecord,\n                eventContent : (segmentRenderData.eventContent || segmentRenderData.taskContent),\n                cls          : segmentRenderData.cls || segmentRecord.cls?.clone() || new DomClassList(),\n                top          : renderData.top,\n                left         : segmentRenderData.left - renderData.left,\n                width        : segmentRenderData.width,\n                height       : renderData.height,\n                style        : ''\n            };\n\n            Object.assign(result.cls,\n                {\n                    'b-sch-event-segment' : true,\n                    'b-first'             : !segmentRecord.previousSegment,\n                    'b-last'              : !segmentRecord.nextSegment\n                },\n                segmentRenderData.cls\n            );\n\n            // Named colors are applied as a class to the wrapper\n            if (DomHelper.isNamedColor(eventColor)) {\n                result.cls[`b-sch-color-${eventColor}`] = eventColor;\n            }\n            else if (eventColor) {\n                result.style = `background-color:${eventColor};` + result.style;\n                result.cls['b-sch-custom-color'] = 1;\n            }\n            else {\n                renderData.wrapperCls['b-sch-color-none'] = 1;\n            }\n        }\n\n        return result;\n    }\n\n    appendDOMConfig(renderData) {\n        const eventRecord = renderData.eventRecord || renderData.taskRecord;\n\n        if (eventRecord.segments && !this.disabled) {\n\n            const\n                eventContent = renderData.eventContent || renderData.taskContent,\n                index = renderData.children.indexOf(eventContent);\n\n            // remove generated event content\n            if (index > -1) {\n                renderData.children.splice(index, 1);\n            }\n\n            delete renderData.eventContent;\n            delete renderData.taskContent;\n\n            renderData.cls['b-segmented'] = true;\n\n            renderData.segments = eventRecord.segments.map(segment => this.generateSegmentRenderData(segment, renderData));\n\n            renderData.segmentsDOMConfig = renderData.segments.map(this.getSegmentDOMConfig.bind(this));\n\n            renderData.children.unshift(\n                {\n                    syncOptions : {\n                        syncIdField      : 'segment',\n                        releaseThreshold : 0\n                    },\n                    className : 'b-sch-event-segments',\n                    dataset   : {\n                        taskBarFeature : 'segments'\n                    },\n                    children : renderData.segmentsDOMConfig\n                }\n            );\n        }\n    }\n\n    getSegmentDOMConfig(segmentData, index) {\n        return {\n            className : segmentData.cls,\n            style     : {\n                style  : segmentData.style,\n                left   : segmentData.left,\n                height : segmentData.height,\n                width  : segmentData.width\n            },\n            dataset : {\n                segment : index\n            },\n            syncOptions : {\n                syncIdField : 'taskBarFeature'\n            },\n            children : [\n                segmentData.eventContent\n            ]\n        };\n    }\n\n    // For Scheduler Pro\n    onEventDataGenerated(eventData) {\n        this.appendDOMConfig(eventData);\n    }\n\n    // For Gantt\n    onTaskDataGenerated(taskData) {\n        this.appendDOMConfig(taskData);\n    }\n\n    //endregion\n\n    // No classname on Scheduler's/Gantt's element\n    get featureClass() {}\n}\n\nGridFeatureManager.registerFeature(EventSegments, true, 'SchedulerPro');\nGridFeatureManager.registerFeature(EventSegments, true, 'Gantt');\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DragHelper from '../../Core/helper/DragHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module SchedulerPro/feature/PercentBar\n */\n\n//region Static\n\nfunction cls(classes) {\n    return `b-task-percent-bar${classes[0] ? `-${classes[0]}` : ''}`;\n}\n\n//endregion\n\n/**\n * This feature visualizes the {@link SchedulerPro.model.mixin.PercentDoneMixin#field-percentDone percentDone} field as a\n * progress bar on the event elements. Each progress bar also optionally has a drag handle which users can drag can\n * change the value.\n *\n * You can customize data source for the feature with {@link #config-valueField} and {@link #config-displayField} configs.\n *\n * {@inlineexample SchedulerPro/feature/PercentBar.js}\n *\n * ## Restricting resizing for certain tasks\n *\n * You can prevent certain tasks from having their percent done value changed by overriding the\n * {@link Scheduler.model.TimeSpan#function-isEditable} method on your EventModel or TaskModel.\n *\n * ```javascript\n * class MyTaskModel extends TaskModel {\n *     isEditable(field) {\n *         // Add any condition here, `this` refers to the a task instance\n *         return this.field !== 'percentDone' && super.isEditable(field);\n *     }\n * };\n *\n * gantt = new Gantt({\n *     project : {\n *         taskModelClass : MyTaskModel\n *     }\n * });\n * ```\n *\n * This feature is **enabled** by default in Gantt, but **off** by default in Scheduler Pro.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype percentBar\n * @feature\n * @demo SchedulerPro/percent-done\n */\nexport default class PercentBar extends InstancePlugin {\n\n    /**\n     * Fired on the owning SchedulerPro when percent bar dragging starts\n     * @event percentBarDragStart\n     * @on-owner\n     * @param {Scheduler.view.TimelineBase} source SchedulerPro or Gantt instance\n     * @param {Core.data.Model} taskRecord The task record\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning SchedulerPro when dragging the percent bar\n     * @event percentBarDrag\n     * @on-owner\n     * @param {Scheduler.view.TimelineBase} source SchedulerPro or Gantt instance\n     * @param {Core.data.Model} taskRecord The task record\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning SchedulerPro when dropping the percent bar\n     * @event percentBarDrop\n     * @on-owner\n     * @param {Scheduler.view.TimelineBase} source SchedulerPro or Gantt instance\n     * @param {Core.data.Model} taskRecord The task record\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning SchedulerPro if a percent bar drag-drop operation is aborted\n     * @event percentBarDragAbort\n     * @on-owner\n     * @param {Scheduler.view.TimelineBase} source SchedulerPro instance\n     * @param {Core.data.Model} taskRecord The task record\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    //region Config\n\n    static get $name() {\n        return 'PercentBar';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * `true` to allow drag drop resizing to set the % done\n             * @config {Boolean}\n             * @default\n             */\n            allowResize : true,\n\n            /**\n             * `true` to show a small % done label within the event while drag changing its value\n             * @config {Boolean}\n             * @default\n             */\n            showPercentage : true,\n\n            /**\n             * By default, the underlying task record is updated live as the user drags the handle. Set to false\n             * to only update the record upon drop.\n             * @config {Boolean}\n             * @default\n             */\n            instantUpdate : true,\n\n            /**\n             * Field name to use as the data source\n             * @config {String}\n             * @default\n             */\n            valueField : 'percentDone',\n\n            /**\n             * Field name to use to display the value\n             * @config {String}\n             * @default\n             */\n            displayField : 'renderedPercentDone'\n        };\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : [\n                'onPaint',\n                {\n                    fn   : 'onTaskDataGenerated',\n                    // make sure the function runs after other onTaskDataGenerated chains\n                    prio : -10000\n                },\n                {\n                    fn   : 'onEventDataGenerated',\n                    // make sure the function runs after other onEventDataGenerated chains\n                    prio : -10000\n                }\n            ]\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    /**\n     * Called when scheduler is painted. Sets up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            const\n                me         = this,\n                { client } = me;\n\n            me.drag = new DragHelper({\n                name              : 'percentBarHandle',\n                lockX             : client.isVertical,\n                lockY             : client.isHorizontal,\n                // Handle is not draggable for parents\n                targetSelector    : `${client.eventSelector} .b-task-percent-bar-handle`,\n                dragThreshold     : 1,\n                outerElement      : client.timeAxisSubGridElement,\n                internalListeners : {\n                    beforeDragStart : 'onBeforeDragStart',\n                    dragStart       : 'onDragStart',\n                    drag            : 'onDrag',\n                    drop            : 'onDrop',\n                    abort           : 'onDragAbort',\n                    thisObj         : me\n                }\n            });\n\n            me.detachListeners('view');\n\n            me.client.ion({\n                name                                       : 'view',\n                [`${client.scheduledEventName}mouseenter`] : 'onTimeSpanMouseEnter',\n                [`${client.scheduledEventName}mouseleave`] : 'onTimeSpanMouseLeave',\n                thisObj                                    : me\n            });\n        }\n    }\n\n    get sizeProp() {\n        return this.client.isVertical ? 'height' : 'width';\n    }\n\n    get offsetSizeProp() {\n        return this.client.isVertical ? 'offsetHeight' : 'offsetWidth';\n    }\n\n    get positionProp() {\n        return this.client.isVertical ? 'top' : (this.client.rtl ? 'right' : 'left');\n    }\n\n    get offsetPositionProp() {\n        return this.client.isVertical ? 'offsetTop' : (this.client.rtl ? 'offsetRight' : 'offsetLeft');\n    }\n\n    updateAllowResize(value) {\n        this.client.element.classList.toggle(cls`drag-disabled`, !value);\n    }\n\n    updateShowPercentage(value) {\n        this.client.element.classList.toggle(cls`show-percentage`, Boolean(value));\n    }\n\n    doDestroy() {\n        this.drag?.destroy();\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        // Redraw to toggle percent bars\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    //region Contents\n\n    reset(context) {\n        const\n            me          = this,\n            { project } = me.client;\n\n        me.client.element.classList.remove(cls`resizing-task`);\n\n        // Remove handle if operation ended outside the event\n        if (!me.isMouseInsideEvent) {\n            me.handle.remove();\n            me.handle = null;\n        }\n\n        // If we were applying percentDone values while dragging\n        if (me.instantUpdate) {\n            const { stm } = project;\n\n            // If we have active STM - restore its state we changed before the dragging\n            if (!stm.disabled) {\n                // If we started a special STM transaction\n                if (me._stmTransactionStarted) {\n                    // finish it or reject depending if the dragging succeeded or was aborted respectively\n                    if (context.valid) {\n                        stm.stopTransaction();\n                    }\n                    else {\n                        stm.rejectTransaction();\n                    }\n                }\n\n                stm.autoRecord = me.oldStmAutoRecord;\n                me._stmTransactionStarted = false;\n            }\n\n            project.resumeAutoSync();\n            me.client.eventStore.resumeAutoCommit();\n        }\n    }\n\n    getPercentBarDOMConfig(taskRecord) {\n        return {\n            className : cls`outer`,\n            dataset   : {\n                taskBarFeature : 'percentBar'\n            },\n            children : [\n                {\n                    className : cls``,\n                    dataset   : {\n                        percent : taskRecord[this.displayField]\n                    },\n                    style : {\n                        [this.sizeProp] : taskRecord[this.valueField] + '%'\n                    }\n                }\n            ]\n        };\n    }\n\n    appendDOMConfig(taskRecord, children, renderData) {\n        if ((taskRecord.isEvent || taskRecord.isTask) && !taskRecord.isMilestone && !this.disabled) {\n            const { eventSegments } = this.client.features;\n            // If the event is segmented and we have segments rendering feature onboard\n            // - draw a percent bar for each segment\n            if (taskRecord.isSegmented && eventSegments?.enabled) {\n                taskRecord.segments.forEach((segmentRecord, index) => {\n                    renderData.segmentsDOMConfig[index].children.unshift(this.getPercentBarDOMConfig(segmentRecord));\n                });\n            }\n            else {\n                children.unshift(this.getPercentBarDOMConfig(taskRecord));\n            }\n        }\n    }\n\n    // For Scheduler Pro\n    onEventDataGenerated(eventData) {\n        this.appendDOMConfig(eventData.eventRecord, eventData.children, eventData);\n    }\n\n    // For Gantt\n    onTaskDataGenerated(taskData) {\n        this.appendDOMConfig(taskData.taskRecord, taskData.children, taskData);\n    }\n\n    //endregion\n\n    //region Events\n\n    getHoverSegment(event) {\n        const segmentElement = (event.toElement || event.target).closest('.b-sch-event-segment');\n\n        if (segmentElement) {\n            const segmentBox = Rectangle.from(segmentElement);\n\n            if (segmentBox?.contains(EventHelper.getPagePoint(event))) {\n                return segmentElement;\n            }\n        }\n    }\n\n    isOverSegment(event) {\n        return Boolean(this.getHoverSegment(event));\n    }\n\n    // Inject handle on mouse over\n    onTimeSpanMouseEnter(event) {\n        const\n            me                   = this,\n            { client, sizeProp } = me,\n            record               = event[`${client.scheduledEventName}Record`];\n\n        if (record.isMilestone || record.readOnly || me.disabled || record.isParent || !record.isEditable(me.valueField)) {\n            return;\n        }\n\n        // No ongoing drag\n        if (!me.drag.context) {\n            const\n                element = event[`${client.scheduledEventName}Element`],\n                parent  = DomSync.getChild(element, client.scheduledEventName);\n\n            // Add handle if not already there\n            if (!me.handle) {\n                const dataset = {\n                    percent : record[me.valueField]\n                };\n\n                let pos = record[me.valueField] + '%';\n\n                const { eventSegments } = client.features;\n\n                if (record.isSegmented && eventSegments?.enabled) {\n\n                    dataset.segment = 0;\n\n                    const parentBox = Rectangle.from(parent);\n\n                    let lastPercentDone, lastPercentBarBox;\n\n                    // iterate segments to find the handle position\n                    record.segments.some((segment, index) => {\n                        // exit - if this segment is not started\n                        // unless previous segment is complete - then we place the handle\n                        // at the start of the next not-started segment\n                        if (!segment[me.valueField] && lastPercentDone !== 100) {\n                            return true;\n                        }\n\n                        lastPercentDone = segment[me.valueField];\n\n                        dataset.segment = index;\n\n                        const segmentPercentBarElement = DomSync.getChild(parent, `segments.${index}.percentBar`).firstChild;\n\n                        lastPercentBarBox = Rectangle.from(segmentPercentBarElement);\n                    });\n\n                    if (client.isVertical) {\n                        pos = lastPercentBarBox ? lastPercentBarBox.top + lastPercentBarBox[sizeProp] - parentBox.top : 0;\n                    }\n                    else if (client.rtl) {\n                        // <remove-on-release>\n                        // TODO: check this in RTL\n                        // </remove-on-release>\n                        pos = lastPercentBarBox ? lastPercentBarBox.right + lastPercentBarBox[sizeProp] - parentBox.right : 0;\n                    }\n                    else {\n                        pos = lastPercentBarBox ? lastPercentBarBox.left + lastPercentBarBox[sizeProp] - parentBox.left : 0;\n                    }\n                }\n\n                me.handle = DomHelper.createElement({\n                    parent,\n                    className : cls`handle`,\n                    style     : {\n                        [me.positionProp] : pos\n                    },\n                    dataset\n                });\n            }\n\n            // Mouse is inside event, used later to not remove handle\n            me.isMouseInsideEvent = true;\n        }\n        // Ongoing drag, mouse coming back into active event\n        else if (record === me.drag.context.taskRecord) {\n            // Mouse is inside event, used later to not remove handle\n            me.isMouseInsideEvent = true;\n        }\n    }\n\n    // Remove handle on mouse leave, if not dragging\n    onTimeSpanMouseLeave(event) {\n        const me = this;\n\n        if (!me.drag.context && me.handle && event.event.toElement !== me.handle) {\n            me.handle.remove();\n            me.handle = null;\n        }\n\n        me.isMouseInsideEvent = false;\n    }\n\n    onBeforeDragStart({ source, context, event }) {\n        const\n            { client, offsetPositionProp, offsetSizeProp } = this,\n            { eventSegments }                              = client.features,\n            { element }                                    = context,\n            taskRecord                                     = client.resolveEventRecord(element);\n\n        let percentBarOuter, percentBar, initialPos, size;\n\n        // if the event is segmented\n        if (taskRecord.isSegmented && eventSegments?.enabled) {\n            const segmentIndex = element.dataset.segment;\n\n            percentBarOuter = DomSync.getChild(element.parentElement, `segments.${segmentIndex}.percentBar`);\n            percentBar      = percentBarOuter.firstElementChild;\n\n            // total size allowed to drag in is defined by the event borders\n            size       = element.parentElement[offsetSizeProp];\n            initialPos = DomSync.getChild(element.parentElement, `segments.${segmentIndex}`)[offsetPositionProp] + percentBar[offsetSizeProp];\n        }\n        else {\n            percentBarOuter = DomSync.getChild(element.parentElement, 'percentBar');\n            percentBar      = percentBarOuter.firstElementChild;\n\n            size       = percentBarOuter[offsetSizeProp];\n            initialPos = percentBar[offsetSizeProp];\n        }\n\n        if (client.isVertical) {\n            source.minY = -initialPos;\n            source.maxY = size - initialPos;\n        }\n        else if (client.rtl) {\n            source.maxX = initialPos;\n            source.minX = -(size - initialPos);\n        }\n        else {\n            source.minX = -initialPos;\n            source.maxX = size - initialPos;\n        }\n\n        Object.assign(context, {\n            percentBar,\n            initialPos,\n            size,\n            taskRecord,\n            initialValue : taskRecord[this.valueField],\n            domEvent     : event\n        });\n    }\n\n    onDragStart({ context, event }) {\n        const\n            { client } = this,\n            { project } = client;\n\n        client.element.classList.add(cls`resizing-task`);\n\n        context.element.retainElement = true;\n        context.domEvent              = event;\n        client.trigger('percentBarDragStart', context);\n\n        if (this.instantUpdate) {\n            project.suspendAutoSync();\n            client.eventStore.suspendAutoCommit();\n\n            // If we have STM enabled - turn its auto recording off\n            if (!project.stm.disabled) {\n                this.oldStmAutoRecord = project.stm.autoRecord;\n                project.stm.autoRecord = false;\n            }\n        }\n    }\n\n    onDrag({ context, event }) {\n        const\n            me                                   = this,\n            { sizeProp, offsetSizeProp, client } = me,\n            percent                              = client.isHorizontal ? Math.round(((context.initialPos + (context.newX * (client.rtl ? -1 : 1))) / context.size) * 100)\n                : Math.round(((context.initialPos + context.newY) / context.size) * 100),\n            { eventSegments }                    = client.features;\n\n        if (me.instantUpdate) {\n            const { stm } = client.project;\n\n            // If STM is active but we have not transaction started\n            if (!stm.disabled && !stm.transaction) {\n                // start a new transaction\n                stm.startTransaction();\n                me._stmTransactionStarted = true;\n            }\n\n            context.taskRecord[me.valueField] = percent;\n        }\n        context.domEvent                  = event;\n\n        context.percent = context.element.dataset.percent = percent;\n\n        if (context.taskRecord.isSegmented && eventSegments?.enabled) {\n            context.taskRecord.segments.forEach((segment, index) => {\n                const\n                    percentBar     = DomSync.getChild(context.element.parentElement, `segments.${index}.percentBar`).firstChild,\n                    segmentElement = DomSync.getChild(context.element.parentElement, `segments.${index}`);\n\n                // complete segment\n                if (context.percent >= segment.endPercentDone) {\n                    percentBar.style[sizeProp] = segmentElement[offsetSizeProp] + 'px';\n                }\n                // not started segment\n                else if (context.percent <= segment.startPercentDone) {\n                    percentBar.style[sizeProp] = '0';\n                }\n                // the segment in progress\n                else if (context.percent >= segment.startPercentDone && context.percent <= segment.endPercentDone) {\n                    const percentsInSegment = segment.endPercentDone - segment.startPercentDone;\n\n                    // new percent bar size is: number_of_percents * pixels_per_percent\n                    percentBar.style[sizeProp] = (percent - segment.startPercentDone) * segmentElement[offsetSizeProp] / percentsInSegment + 'px';\n                }\n            });\n        }\n\n        client.trigger('percentBarDrag', context);\n    }\n\n    onDragAbort({ context, event }) {\n        // Reset percentBar size on abort\n        if (context.taskRecord.isSegmented) {\n            context.percentBar.style[this.sizeProp] = context.taskRecord.segments[context.element.dataset.segment][this.valueField] + '%';\n        }\n\n        context.taskRecord[this.valueField] = context.initialValue;\n        context.domEvent                  = event;\n\n        this.reset(context);\n\n        this.client.trigger('percentBarDragAbort', context);\n    }\n\n    onDrop({ context }) {\n        const\n            me                = this,\n            { taskRecord }    = context,\n            { eventSegments } = me.client.features;\n\n        taskRecord[me.valueField] = context.percent;\n\n        // for segmented task we need to calculate the new position\n        // of the handle\n        if (taskRecord.isSegmented && eventSegments?.enabled) {\n            taskRecord.segments.some((segment, index) => {\n                // find the segment in progress\n                if (context.percent >= segment.startPercentDone && context.percent <= segment.endPercentDone) {\n                    const\n                        percentsInSegment = segment.endPercentDone - segment.startPercentDone,\n                        segmentElement    = DomSync.getChild(context.element.parentElement, `segments.${index}`),\n                        // new coordinate is calculated roughly as:\n                        // segment xy-coordinate + number of percents * pixels per percent\n                        size              = parseInt(segmentElement.style[me.sizeProp]) +\n                            (context.percent - segment.startPercentDone) * segmentElement[me.offsetSizeProp] / percentsInSegment;\n\n                    // Fully overwrite handle style to get rid of translate also\n                    context.element.style.cssText = `${me.positionProp}: ${size}px`;\n\n                    // patch the handle segment index too\n                    context.element.dataset.segment = index;\n\n                    return true;\n                }\n            });\n        }\n        else {\n            // Fully overwrite handle style to get rid of translate also\n            context.element.style.cssText = `${me.positionProp}: ${me.client.rtl ? 100 - context.percent : context.percent}%`;\n        }\n\n        me.reset(context);\n\n        me.client.trigger('percentBarDrop', context);\n    }\n\n    //endregion\n\n    // No classname on Scheduler's/Gantt's element\n    get featureClass() {}\n}\n\nGridFeatureManager.registerFeature(PercentBar, false, 'SchedulerPro');\nGridFeatureManager.registerFeature(PercentBar, true, 'Gantt');\n", "import Base from '../../../../Core/Base.js';\nimport Events from '../../../../Core/mixin/Events.js';\n\nexport default Target => class ReadyStatePropagator extends (Target || Events(Base)) {\n\n    get isReadyStatePropagator() {\n        return true;\n    }\n\n    get canSave() {\n        return true;\n    }\n\n    requestReadyStateChange() {\n        this.trigger('readystatechange', { canSave : this.canSave });\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Engine/localization/En.js';\nimport '../../Scheduler/localization/En.js';\n\nconst locale = {\n\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n\n    ConstraintTypePicker : {\n        none                : 'None',\n        muststarton         : 'Must start on',\n        mustfinishon        : 'Must finish on',\n        startnoearlierthan  : 'Start no earlier than',\n        startnolaterthan    : 'Start no later than',\n        finishnoearlierthan : 'Finish no earlier than',\n        finishnolaterthan   : 'Finish no later than'\n    },\n\n    CalendarField : {\n        'Default calendar' : 'Default calendar'\n    },\n\n    TaskEditorBase : {\n        Information   : 'Information',\n        Save          : 'Save',\n        Cancel        : 'Cancel',\n        Delete        : 'Delete',\n        calculateMask : 'Calculating...',\n        saveError     : \"Can't save, please correct errors first\",\n        repeatingInfo : 'Viewing a repeating event',\n        editRepeating : 'Edit'\n    },\n\n    TaskEdit : {\n        'Edit task'            : 'Edit task',\n        ConfirmDeletionTitle   : 'Confirm deletion',\n        ConfirmDeletionMessage : 'Are you sure you want to delete the event?'\n    },\n\n    GanttTaskEditor : {\n        editorWidth : '44em'\n    },\n\n    SchedulerTaskEditor : {\n        editorWidth : '34em'\n    },\n\n    SchedulerGeneralTab : {\n        labelWidth   : '6em',\n        General      : 'General',\n        Name         : 'Name',\n        Resources    : 'Resources',\n        '% complete' : '% complete',\n        Duration     : 'Duration',\n        Start        : 'Start',\n        Finish       : 'Finish',\n        Effort       : 'Effort',\n        Preamble     : 'Preamble',\n        Postamble    : 'Postamble'\n    },\n\n    GeneralTab : {\n        labelWidth   : '6.5em',\n        General      : 'General',\n        Name         : 'Name',\n        '% complete' : '% complete',\n        Duration     : 'Duration',\n        Start        : 'Start',\n        Finish       : 'Finish',\n        Effort       : 'Effort',\n        Dates        : 'Dates'\n    },\n\n    SchedulerAdvancedTab : {\n        labelWidth                 : '13em',\n        Advanced                   : 'Advanced',\n        Calendar                   : 'Calendar',\n        'Scheduling mode'          : 'Scheduling mode',\n        'Effort driven'            : 'Effort driven',\n        'Manually scheduled'       : 'Manually scheduled',\n        'Constraint type'          : 'Constraint type',\n        'Constraint date'          : 'Constraint date',\n        Inactive                   : 'Inactive',\n        'Ignore resource calendar' : 'Ignore resource calendar'\n    },\n\n    AdvancedTab : {\n        labelWidth                 : '11.5em',\n        Advanced                   : 'Advanced',\n        Calendar                   : 'Calendar',\n        'Scheduling mode'          : 'Scheduling mode',\n        'Effort driven'            : 'Effort driven',\n        'Manually scheduled'       : 'Manually scheduled',\n        'Constraint type'          : 'Constraint type',\n        'Constraint date'          : 'Constraint date',\n        Constraint                 : 'Constraint',\n        Rollup                     : 'Rollup',\n        Inactive                   : 'Inactive',\n        'Ignore resource calendar' : 'Ignore resource calendar'\n    },\n\n    DependencyTab : {\n        Predecessors      : 'Predecessors',\n        Successors        : 'Successors',\n        ID                : 'ID',\n        Name              : 'Name',\n        Type              : 'Type',\n        Lag               : 'Lag',\n        cyclicDependency  : 'Cyclic dependency',\n        invalidDependency : 'Invalid dependency'\n    },\n\n    NotesTab : {\n        Notes : 'Notes'\n    },\n\n    ResourcesTab : {\n        unitsTpl  : ({ value }) => `${value}%`,\n        Resources : 'Resources',\n        Resource  : 'Resource',\n        Units     : 'Units'\n    },\n\n    RecurrenceTab : {\n        title : 'Repeat'\n    },\n\n    SchedulingModePicker : {\n        Normal           : 'Normal',\n        'Fixed Duration' : 'Fixed Duration',\n        'Fixed Units'    : 'Fixed Units',\n        'Fixed Effort'   : 'Fixed Effort'\n    },\n\n    ResourceHistogram : {\n        barTipInRange         : '<b>{resource}</b> {startDate} - {endDate}<br><span class=\"{cls}\">{allocated} of {available}</span> allocated',\n        barTipOnDate          : '<b>{resource}</b> on {startDate}<br><span class=\"{cls}\">{allocated} of {available}</span> allocated',\n        groupBarTipAssignment : '<b>{resource}</b> - <span class=\"{cls}\">{allocated} of {available}</span>',\n        groupBarTipInRange    : '{startDate} - {endDate}<br><span class=\"{cls}\">{allocated} of {available}</span> allocated:<br>{assignments}',\n        groupBarTipOnDate     : 'On {startDate}<br><span class=\"{cls}\">{allocated} of {available}</span> allocated:<br>{assignments}',\n        plusMore              : '+{value} more'\n    },\n\n    ResourceUtilization : {\n        barTipInRange         : '<b>{event}</b> {startDate} - {endDate}<br><span class=\"{cls}\">{allocated}</span> allocated',\n        barTipOnDate          : '<b>{event}</b> on {startDate}<br><span class=\"{cls}\">{allocated}</span> allocated',\n        groupBarTipAssignment : '<b>{event}</b> - <span class=\"{cls}\">{allocated}</span>',\n        groupBarTipInRange    : '{startDate} - {endDate}<br><span class=\"{cls}\">{allocated} of {available}</span> allocated:<br>{assignments}',\n        groupBarTipOnDate     : 'On {startDate}<br><span class=\"{cls}\">{allocated} of {available}</span> allocated:<br>{assignments}',\n        plusMore              : '+{value} more',\n        nameColumnText        : 'Resource / Event'\n    },\n\n    SchedulingIssueResolutionPopup : {\n        'Cancel changes'   : 'Cancel the change and do nothing',\n        schedulingConflict : 'Scheduling conflict',\n        emptyCalendar      : 'Calendar configuration error',\n        cycle              : 'Scheduling cycle',\n        Apply              : 'Apply'\n    },\n\n    CycleResolutionPopup : {\n        dependencyLabel        : 'Please select a dependency:',\n        invalidDependencyLabel : 'There are invalid dependencies involved that need to be addressed:'\n    },\n\n    DependencyEdit : {\n        Active : 'Active'\n    },\n\n    SchedulerProBase : {\n        propagating     : 'Calculating project',\n        storePopulation : 'Loading data',\n        finalizing      : 'Finalizing results'\n    },\n\n    EventSegments : {\n        splitEvent    : 'Split event',\n        renameSegment : 'Rename'\n    },\n\n    NestedEvents : {\n        deNestingNotAllowed : 'De-nesting not allowed',\n        nestingNotAllowed   : 'Nesting not allowed'\n    },\n\n    VersionGrid : {\n        compare       : 'Compare',\n        description   : 'Description',\n        occurredAt    : 'Occurred At',\n        rename        : 'Rename',\n        restore       : 'Restore',\n        stopComparing : 'Stop Comparing'\n    },\n\n    Versions : {\n        entityNames : {\n            TaskModel       : 'task',\n            AssignmentModel : 'assignment',\n            DependencyModel : 'link',\n            ProjectModel    : 'project',\n            ResourceModel   : 'resource',\n            other           : 'object'\n        },\n        entityNamesPlural : {\n            TaskModel       : 'tasks',\n            AssignmentModel : 'assignments',\n            DependencyModel : 'links',\n            ProjectModel    : 'projects',\n            ResourceModel   : 'resources',\n            other           : 'objects'\n        },\n        transactionDescriptions : {\n            update : 'Changed {n} {entities}',\n            add    : 'Added {n} {entities}',\n            remove : 'Removed {n} {entities}',\n            move   : 'Moved {n} {entities}',\n            mixed  : 'Changed {n} {entities}'\n        },\n        addEntity         : 'Added {type} **{name}**',\n        removeEntity      : 'Removed {type} **{name}**',\n        updateEntity      : 'Changed {type} **{name}**',\n        moveEntity        : 'Moved {type} **{name}** from {from} to {to}',\n        addDependency     : 'Added link from **{from}** to **{to}**',\n        removeDependency  : 'Removed link from **{from}** to **{to}**',\n        updateDependency  : 'Edited link from **{from}** to **{to}**',\n        addAssignment     : 'Assigned **{resource}** to **{event}**',\n        removeAssignment  : 'Removed assignment of **{resource}** from **{event}**',\n        updateAssignment  : 'Edited assignment of **{resource}** to **{event}**',\n        noChanges         : 'No changes',\n        nullValue         : 'none',\n        versionDateFormat : 'M/D/YYYY h:mm a',\n        undid             : 'Undid changes',\n        redid             : 'Redid changes',\n        editedTask        : 'Edited task properties',\n        deletedTask       : 'Deleted a task',\n        movedTask         : 'Moved a task',\n        movedTasks        : 'Moved tasks'\n    }\n};\n\nexport default LocaleHelper.publishLocale(locale);\n", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Popup from '../../Core/widget/Popup.js';\nimport Toast from '../../Core/widget/Toast.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport ReadyStatePropagator from '../widget/taskeditor/mixin/ReadyStatePropagator.js';\nimport '../../Core/widget/Label.js';\nimport '../localization/En.js';\n\n/**\n * @module SchedulerPro/widget/TaskEditorBase\n */\n\n/**\n * Abstract base class for Scheduler and Gantt task editors\n *\n * @extends Core/widget/Popup\n * @abstract\n */\nexport default class TaskEditorBase extends Popup.mixin(ReadyStatePropagator) {\n\n    //region Config\n\n    static get $name() {\n        return 'TaskEditorBase';\n    }\n\n    static get type() {\n        return 'taskeditorbase';\n    }\n\n    static get configurable() {\n        return {\n            localizableProperties : ['width'],\n\n            title     : 'L{Information}',\n            cls       : 'b-schedulerpro-taskeditor',\n            closable  : true,\n            layout    : 'fit',\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners\n            },\n\n            items : null, // overridden in subclasses\n\n            bbar : {\n                // When readOnly, child buttons are hidden\n                hideWhenEmpty : true,\n\n                defaults : {\n                    localeClass : this\n                },\n\n                items : {\n                    saveButton : {\n                        text   : 'L{Save}',\n                        color  : 'b-blue',\n                        cls    : 'b-raised',\n                        weight : 100\n                    },\n                    deleteButton : {\n                        text   : 'L{Delete}',\n                        weight : 200\n                    },\n                    cancelButton : {\n                        text   : 'L{Object.Cancel}',\n                        weight : 300\n                    }\n                }\n            },\n\n            strips : {\n                // When editing a recurring event, editor first opens read-only + displays this toolbar with info & edit\n                // button. User then has to click the edit button to unlink the record before editing it.\n                occurrenceInfoToolbar : {\n                    cls                  : 'occurrence-info-toolbar',\n                    hidden               : true,\n                    ignoreParentReadOnly : true,\n                    items                : [\n                        {\n                            type : 'widget',\n                            tag  : 'i',\n                            cls  : 'b-icon b-icon-locked'\n                        },\n                        {\n                            ref         : 'occurrenceInfoText',\n                            type        : 'label',\n                            localeClass : this,\n                            text        : 'L{repeatingInfo}'\n                        },\n                        '->',\n                        {\n                            ref         : 'editOccurrenceButton',\n                            localeClass : this,\n                            text        : 'L{editRepeating}',\n                            onClick     : 'up.onEditOccurrenceClick'\n                        }\n                    ]\n                }\n            },\n\n            width : {\n                $config : {\n                    localeKey : 'L{editorWidth}'\n                }\n            }\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            axisLock   : 'flexible',\n            autoClose  : true,\n            onChange   : null,\n            onCancel   : null,\n            onSave     : null,\n            autoShow   : false,\n            blurAction : 'cancel',\n\n            scrollAction : 'realign',\n\n            /**\n             * The decimal precision to use for Duration field / columns, normally provided by the owning Scheduler´s {@link SchedulerPro.view.SchedulerPro#config-durationDisplayPrecision}\n             * @config {Number}\n             */\n            durationDisplayPrecision : 1,\n\n            tabPanelItems : null,\n\n            defaultTabs : null,\n\n            /**\n             * A message to be shown when Engine is performing task scheduling. Localizable text is 'L{calculateMask}'. Disabled by default.\n             * @config {String|null}\n             * @default\n             */\n            calculateMask : null,\n\n            /**\n             * A delay before the {@link #config-calculateMask mask} becomes visible. This config is needed to avoid UI blinking when calculating is relatively fast.\n             * Note, the mask is applied immediately and blocks the content anyway. However if the delay is set, it will be transparent. If `null`, the mask is visible immediately.\n             * @config {Number|null}\n             * @default\n             */\n            calculateMaskDelay : 100,\n\n            localizableProperties : ['calculateMask'],\n\n            project : null,\n\n            /**\n             * A task field (id, wbsCode, sequenceNumber etc) that will be used when displaying and editing linked tasks. Defaults to Gantt `dependencyIdField`\n             * @config {String} dependencyIdField\n             */\n            dependencyIdField : null\n        };\n    }\n\n    //endregion\n\n    //region Internal\n\n    // This method is called for every child widget in the task editor\n    processWidgetConfig(widgetConfig) {\n        if (widgetConfig.type?.includes('date') && widgetConfig.weekStartDay == null) {\n            widgetConfig.weekStartDay = this.weekStartDay;\n        }\n\n        // Backward compatibility\n        if (widgetConfig.ref === 'tabs' && this.extraItems) {\n            const preparedItems = {};\n\n            for (const key in this.extraItems) {\n                // Lower-cased \"tab\" is not supported anymore\n                const preparedKey = key.replace('tab', 'Tab');\n\n                preparedItems[preparedKey] = {\n                    items : Array.isArray(this.extraItems[key]) ? ObjectHelper.transformArrayToNamedObject(this.extraItems[key]) : this.extraItems[key]\n                };\n            }\n\n            ObjectHelper.merge(widgetConfig.items, preparedItems);\n        }\n\n        return widgetConfig;\n    }\n\n    changeItems(items) {\n        const\n            { tabPanelItems = {} } = this,\n            // Clone to not pollute config\n            clonedItems            = ObjectHelper.clone(items),\n            tabPanel               = clonedItems.find(w => w.ref === 'tabs');\n\n        this.cleanItemsConfig(tabPanelItems);\n        ObjectHelper.merge(tabPanel.items, tabPanelItems);\n\n        return super.changeItems(clonedItems);\n    }\n\n    // Remove any items configured as === true which just means default config options\n    cleanItemsConfig(items) {\n        for (const ref in items) {\n            const itemCfg = items[ref];\n\n            if (itemCfg === true) {\n                delete items[ref];\n            }\n            else if (itemCfg?.items) {\n                this.cleanItemsConfig(itemCfg.items);\n            }\n        }\n    }\n\n    afterConfigure() {\n        const\n            me            = this,\n            { widgetMap } = me,\n            { tabs }      = widgetMap,\n            {\n                cancelButton,\n                deleteButton,\n                saveButton\n            }             = me.bbar?.widgetMap || {};\n\n        saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n        deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n\n        Object.values(widgetMap).forEach(widget => {\n            if (widget.isDurationField) {\n                widget.decimalPrecision = this.durationDisplayPrecision;\n            }\n            else if (widget.ref === 'startDate' || widget.ref === 'endDate') {\n                widget.project = this.project;\n            }\n            else if (widget.ref === 'predecessorsTab' || widget.ref === 'successorsTab') {\n                widget.grid.durationDisplayPrecision = this.durationDisplayPrecision;\n                widget.dependencyIdField = widget.dependencyIdField || me.dependencyIdField;\n            }\n\n            if (widget.isReadyStatePropagator) {\n                widget.ion({ readyStateChange : 'onReadyStateChange', thisObj : me });\n            }\n        });\n\n        // override standard Container's method to pick the right record and make possible\n        // to reflect record update on programmatically field value change\n        // <remove-on-release>\n        // TODO: may be removed after merged https://github.com/bryntum/support/issues/2920\n        // </remove-on-release>\n        tabs.onFieldChange = ({ source }) => {\n            const { name, isValid, value } = source;\n\n            // skip record field setting if we are loading values from the record\n            if (me.loadedRecord && name && isValid && !me.isLoadingEvent && !source.up('recurrenceeditorpanel')) {\n                me.loadedRecord[name] = value;\n\n            }\n        };\n    }\n\n    get canSave() {\n        let canSave = true;\n\n        // If widget report it can't both save and cancel then there's no reason to walk through others\n        Object.values(this.widgetMap).forEach(w => {\n            if (w.isReadyStatePropagator) {\n                canSave = canSave && w.canSave;\n            }\n        });\n\n        return canSave;\n    }\n\n    // Hide, Cancel and clicking outside all lead here\n    async hide() {\n        const me = this;\n\n        me.detachListeners('project');\n        me.detachListeners('eventStore');\n        me._delayedAction = null;\n\n        // Let editing feature know to cancel or save\n        // Triggering blurAction after super.hide() is complete, to avoid changing records too late\n        // https://github.com/bryntum/support/issues/4805\n        // Immediate hide if we lost focus to avoid race conditions\n        const superResponse = await super.hide(this.element.matches(':focus-within'));\n\n        if (!me.isDestroyed) {\n            me.trigger(me.blurAction);\n        }\n\n        return superResponse;\n    }\n\n    // Iterates over contained fields and disables them based on the loaded record isEditable(fielName) result\n    toggleFieldsDisabled(record) {\n        this.eachWidget(widget => {\n            if (widget.isField && widget.name && !widget.up('recurrenceeditorpanel')) {\n                const isFieldEditable = record.isEditable(widget.name);\n                // skip unknown fields\n                if (isFieldEditable !== undefined) {\n                    widget.disabled = !record.isEditable(widget.name);\n                }\n            }\n        });\n    }\n\n    /**\n     * Loads a task model into the editor\n     *\n     * @param {SchedulerPro.model.EventModel} record\n     */\n    loadEvent(record, highlightChanges = false) {\n        const\n            me      = this,\n            // Some tests do not set a project, real code does though...\n            project = me.project ?? record.project;\n\n        me.isLoadingEvent = true;\n\n        // Show recurring event info when editing a recurring event or occurrence thereof. Prevented if this is a reload\n        // after selecting to edit it in the toolbar\n        me.widgetMap.occurrenceInfoToolbar.hidden = (!record.isOccurrence && !record.isRecurring) || me.editingRecurring;\n\n        // iterate over fields and disable them by name\n        me.toggleFieldsDisabled(record);\n\n        me.callWidgetHook('loadEvent', record, highlightChanges);\n\n        me.detachListeners('project');\n\n        // <remove-on-release>\n        // Not using .record to not trigger containers record behaviour\n        // TODO: Why not rely on that?\n        // </remove-on-release>\n        me.loadedRecord = record;\n\n        project.ion({\n            name         : 'project',\n            beforeCommit : 'onProjectBeforeCommit',\n            dataReady    : 'onProjectDataReady',\n            thisObj      : me\n        });\n\n        me.detachListeners('eventStore');\n\n        project.eventStore.ion({\n            name    : 'eventStore',\n            remove  : 'onTaskRemove',\n            thisObj : me\n        });\n\n        me.isLoadingEvent = false;\n\n        me.trigger('loadEvent');\n    }\n\n    callWidgetHook(name, ...args) {\n        this.eachWidget(w => {\n            if (typeof w[name] === 'function') {\n                w[name](...args);\n            }\n        });\n    }\n\n    //endregion\n\n    //region Events\n\n    onDocumentMouseDown(params) {\n        const\n            me                = this,\n            activeCellEditing = Object.values(me.widgetMap).some(w => w._activeCellEdit);\n\n        let action = null;\n\n        if (activeCellEditing) {\n            const\n                { event }       = params,\n                {\n                    saveButton,\n                    cancelButton,\n                    deleteButton\n                }               = me.widgetMap,\n                clickedButtonEl = event.target.closest('button');\n\n            // When there is a grid in a TaskEditor tab, and cell editing of the grid is in progress,\n            // and you click on one of the action buttons below (save/cancel/delete), the cell editing feature catches\n            // 'globaltap' event which is fired on global 'mousedown' and finishes the editing.\n            // When new data is applied to the record, a new propagation begins. The task editor adds calculating mask\n            // to protect the UI. Then 'click' event is fired. At this time the buttons are hovered with\n            // the calculating mask and button's handlers are never called.\n            // So, if tap out happens, and cell editing is in progress, and the target is one of the action buttons,\n            // need to foresee the situation when the mask can block the buttons. Though closing the cell editing\n            // does not guarantee that the propagation will start and the mask will appear. Therefore we clean up\n            // the flags inside the handlers.\n\n            if (clickedButtonEl) {\n                switch (clickedButtonEl) {\n                    case saveButton?.element:\n                        action = me.onSaveClick;\n                        break;\n                    case cancelButton?.element:\n                        action = me.onCancelClick;\n                        break;\n                    case deleteButton?.element:\n                        action = me.onDeleteClick;\n                        break;\n                }\n            }\n        }\n\n        me._delayedAction = action;\n\n        super.onDocumentMouseDown(params);\n    }\n\n    onSaveClick() {\n        const me = this;\n\n        me._delayedAction = null;\n\n        if (me.canSave) {\n            me.trigger('save');\n        }\n        else {\n            Toast.show({\n                rootElement : me.rootElement,\n                html        : me.L('L{saveError}')\n            });\n        }\n    }\n\n    onCancelClick() {\n        this.close();\n    }\n\n    onDeleteClick() {\n        this._delayedAction = null;\n\n        this.trigger('delete');\n    }\n\n    onPropagationRequested() {\n        this.trigger('requestPropagation');\n    }\n\n    onReadyStateChange({ source, canSave }) {\n        this.requestReadyStateChange();\n\n        if (!source.couldSaveTitle) {\n            source.couldSaveTitle = source.title;\n        }\n\n        if (source.parent === this.widgetMap.tabs) {\n            if (canSave) {\n                source.tab.element.classList.remove('b-invalid');\n                source.tab.icon = null;\n                source.title = source.couldSaveTitle;\n                source.couldSaveTitle = null;\n            }\n            else {\n                source.tab.element.classList.add('b-invalid');\n                source.tab.icon = 'b-icon-warning';\n                source.title = source.couldSaveTitle;\n            }\n        }\n    }\n\n    onTaskRemove() {\n        this.afterDelete();\n    }\n\n    onProjectBeforeCommit() {\n        if (this.calculateMask) {\n            this.mask({\n                text      : this.calculateMask,\n                showDelay : this.calculateMaskDelay\n            });\n        }\n    }\n\n    onProjectDataReady({ records }) {\n        const me = this;\n\n        if (me.calculateMask) {\n            me.unmask();\n        }\n\n        if (records.has(me.loadedRecord)) {\n            me.callWidgetHook('afterProjectChange');\n        }\n\n        me._delayedAction?.();\n    }\n\n    beforeSave() {\n        this.callWidgetHook('beforeSave');\n    }\n\n    afterSave() {\n        this.loadedRecord = undefined;\n\n        this.callWidgetHook('afterSave');\n    }\n\n    beforeCancel() {\n\n        this.callWidgetHook('beforeCancel');\n    }\n\n    afterCancel() {\n        this.loadedRecord = undefined;\n\n        this.callWidgetHook('afterCancel');\n    }\n\n    beforeDelete() {\n        this.callWidgetHook('beforeDelete');\n    }\n\n    afterDelete() {\n        this.loadedRecord = undefined;\n\n        this.callWidgetHook('afterDelete');\n    }\n\n    onInternalKeyDown(event) {\n        if (!event.handled && event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            if (event.target.matches('input')) {\n\n                // Since we update data fields on `change` event, we need to flush the changes when saving with Enter (Fix for #166)\n                const field = Widget.fromElement(event.target);\n                if (field?.internalOnChange && !field.isCheckbox && !field.isSlider) {\n                    field.internalOnChange();\n                }\n            }\n\n            // this prevents field events so the new value would not be processed without above call to internalOnChange\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n\n            this.onSaveClick();\n        }\n\n        super.onInternalKeyDown(event);\n    }\n\n    //endregion\n\n    //region Recurrence\n\n    onEditOccurrenceClick() {\n        const\n            me                     = this,\n            recurrenceConfirmation = Widget.create({\n                type  : 'recurrenceconfirmation',\n                owner : me\n                // <remove-on-release>\n                // TODO: configurability?\n                // ...recurrenceConfirmation\n                // </remove-on-release>\n            });\n\n        recurrenceConfirmation.confirm({\n            actionType  : 'update',\n            eventRecord : me.loadedRecord,\n            changerFn   : eventRecord => {\n                const recurringTimeSpan = eventRecord.recurringTimeSpan ?? eventRecord;\n\n                // Store current exceptionDates, to be able to restore them on cancel\n                me.resetRecurrenceData = {\n                    recurringTimeSpan,\n                    originalExceptionDates : { ...recurringTimeSpan.exceptionDates }\n                };\n\n                if (!eventRecord.isRecurring) {\n                    eventRecord.convertToRealEvent({\n                        startDate : eventRecord.startDate\n                    });\n\n                    eventRecord.constraintDate = null;\n                }\n            },\n            finalizerFn : eventRecord => {\n                if (eventRecord.isRecurring) {\n                    me.editingRecurring = true;\n                    me.readOnly = false;\n                }\n\n                me.loadEvent(eventRecord);\n            }\n        });\n    }\n\n    //endregion\n\n    updateReadOnly(readOnly) {\n        const\n            {\n                deleteButton,\n                saveButton,\n                cancelButton,\n                tabs\n            } = this.widgetMap,\n            {\n                items : childTabs\n            } = tabs;\n\n        super.updateReadOnly(readOnly);\n\n        if (deleteButton) {\n            deleteButton.hidden = readOnly;\n        }\n\n        if (saveButton) {\n            saveButton.hidden = readOnly;\n        }\n\n        if (cancelButton) {\n            cancelButton.hidden = readOnly;\n        }\n\n        // All tabs are readOnly if we are readOnly\n        for (let i = 0, { length } = childTabs; i < length; i++) {\n            childTabs[i].readOnly = readOnly;\n        }\n    }\n\n}\n\n// Register this widget type with its Factory\nTaskEditorBase.initClass();\n", "import Container from '../../../../Core/widget/Container.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/mixin/EventLoader\n */\n\n/**\n * Mixin class for task editor widgets which require record loading functionality\n *\n * @mixin\n * @mixinbase Container\n */\nexport default Target => class EventLoader extends (Target || Container) {\n\n    get project() {\n        // Use project set on editor by default, since ocurrences are not part of project.\n        // Fall back to records project for tests that test editor in isolation.\n        return this.up(w => w.isTaskEditorBase)?.project ?? this.record?.project;\n    }\n\n    loadEvent(record, highlightChanges) {\n        this.setRecord(record, highlightChanges);\n    }\n\n    resetData() {\n        this.record = null;\n    }\n\n    beforeSave() {}\n\n    afterSave() {\n        this.resetData();\n    }\n\n    beforeCancel() {}\n\n    afterCancel() {\n        this.resetData();\n    }\n\n    beforeDelete() {}\n\n    afterDelete() {\n        this.resetData();\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Container from '../../../Core/widget/Container.js';\nimport EventLoader from './mixin/EventLoader.js';\nimport ReadyStatePropagator from './mixin/ReadyStatePropagator.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/EditorTab\n */\n\n/**\n * Base class for tabs that **do not contain fields** (non-form tabs) in {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro.widget.GanttTaskEditor gantt task editor}, such as Successors, Predecessors or Resources.\n *\n * @extends Core/widget/Container\n * @mixes SchedulerPro/widget/taskeditor/mixin/EventLoader\n */\nexport default class EditorTab extends Container.mixin(EventLoader, ReadyStatePropagator) {\n    static get $name() {\n        return 'EditorTab';\n    }\n\n    static get type() {\n        return 'editortab';\n    }\n\n    static get configurable() {\n        return {\n            title               : null,\n            strictRecordMapping : true\n        };\n    }\n}\n", "import EditorTab from './EditorTab.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/FormTab\n */\n\n/**\n * Base class for tabs that **contain fields** (form-like tabs) in {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro.widget.GanttTaskEditor gantt task editor}, such as General or Notes.\n *\n * @extends SchedulerPro/widget/taskeditor/EditorTab\n */\nexport default class FormTab extends EditorTab {\n\n    static get $name() {\n        return 'FormTab';\n    }\n\n    static get type() {\n        return 'formtab';\n    }\n\n    static get defaultConfig() {\n        return {\n            layoutStyle : {\n                flexFlow     : 'row wrap',\n                alignItems   : 'flex-start',\n                alignContent : 'flex-start'\n            },\n\n            autoUpdateRecord : true\n        };\n    }\n\n    onFieldChange({ source, valid, userAction }) {\n        if (userAction) {\n            valid = valid !== undefined ? valid : (typeof source.isValid === 'function') ? source.isValid() : source.isValid;\n\n            if (valid) {\n                super.onFieldChange(...arguments);\n            }\n        }\n    }\n}\n\nFormTab.initClass();\n", "import DateField from '../../Core/widget/DateField.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n\n/**\n * @module SchedulerPro/widget/StartDateField\n */\n\nconst year2300 = new Date(2300, 0, 1);\n\n/**\n * Date field widget (text field + date picker) to be used together with Scheduling Engine.\n * This field adjusts time to the earliest possible time of the day based on either:\n *\n * - the event calendars (which is a combination of its own calendar and assigned resources ones) - if\n *   {@link #config-eventRecord} is provided.\n * - the project {@link SchedulerPro.model.ProjectModel#field-calendar calendar} - if {@link #config-project} is\n *   provided. The project start date is used as a default value for the {@link #property-min} property.\n *   Also, the default value of the {@link #property-max} property is set to be 200 years\n *   after the project's end date (or to the year 2300 if no project is provided).\n *\n * **Please note, that either {@link #config-eventRecord} or {@link #config-project} value must be provided.**\n *\n * This field can be used as an editor for the {@link Grid.column.Column Column}.\n * It is used as the default editor for the `StartDateColumn`.\n *\n * {@inlineexample SchedulerPro/widget/StartDateField.js}\n * @extends Core/widget/DateField\n * @classType startdatefield\n * @inputfield\n */\nexport default class StartDateField extends DateField {\n\n    //region Config\n\n    static get $name() {\n        return 'StartDateField';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'startdatefield';\n    }\n\n    // Factoryable type alias\n    static get alias() {\n        return 'startdate';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Project model calendar of which should be used by the field.\n             * @config {SchedulerPro.model.ProjectModel}\n             */\n            project : null,\n\n            /**\n             * Event model calendars of which should be used by the field.\n             * @config {SchedulerPro.model.EventModel}\n             */\n            eventRecord : null,\n\n            strictParsing : true,\n\n            /**\n             * Number of milliseconds to add to the project's start date (should be negative). Then, during editing,\n             * the resulting date is assigned to the {@link #config-min} property of the field,\n             * preventing the user from entering too low values.\n             *\n             * This also prevents freezing, when user enters the incomplete date with one-digit year.\n             *\n             * The value of this config will be passed to {@link Core.helper.DateHelper#function-add-static},\n             * so in addition to number of milliseconds, strings like \"-1 year\" are recognized.\n             *\n             * Default value is '-10 years'\n             *\n             * @config {Number|String}\n             * @default\n             */\n            minDateDelta : '-10 years',\n\n            /**\n             * Number of milliseconds to add to the project's start date. Then, during editing,\n             * the resulting date is assigned to the {@link #config-max} property of the field,\n             * preventing the user from entering too high values.\n             *\n             * This also prevents freezing, when user enters the date with five-digits year.\n             *\n             * The value of this config will be passed to {@link Core.helper.DateHelper#function-add-static},\n             * so in addition to number of milliseconds, strings like \"1 year\" are recognized.\n             *\n             * Default value is '200 years'\n             *\n             * @config {Number|String}\n             * @default\n             */\n            maxDateDelta : '200 years'\n        };\n    }\n\n    //endregion\n\n    //region Internal\n\n    get calendarProvider() {\n        // Occurrences does not have their own calendar, use master events calendar\n        return (this.eventRecord?.recurringEvent ?? this.eventRecord) || this.project;\n    }\n\n    get backShiftDate() {\n        const me = this;\n\n        return me.calendarProvider.run('skipWorkingTime', me.value, false, me._step.magnitude, me._step.unit);\n    }\n\n    get forwardShiftDate() {\n        const me = this;\n\n        let result = me.calendarProvider.run('skipWorkingTime', me.value, true, me._step.magnitude, me._step.unit);\n\n        // Need to skip non-working time\n        // since after the above step \"result\" can be set at 17:00 for example (for business calendar)\n        result = result && me.calendarProvider.run('skipNonWorkingTime', result, true);\n\n        return result;\n    }\n\n    transformTimeValue(value) {\n        const { calendarProvider, keepTime } = this;\n\n        if (calendarProvider && keepTime !== 'entered') {\n            const\n                startOfTheDay = DateHelper.clearTime(value),\n                // search for the earliest available time for this day\n                earliestTime  = calendarProvider.run('skipNonWorkingTime', startOfTheDay);\n\n            // if it's the same day, the earliest time is found, use it\n            if (DateHelper.isValidDate(earliestTime) && DateHelper.isEqual(earliestTime, startOfTheDay, 'day')) {\n                return DateHelper.copyTimeValues(startOfTheDay, earliestTime);\n            }\n        }\n\n        return super.transformTimeValue(value);\n    }\n\n    get min() {\n        return super.min || this.project?.startDate ? DateHelper.add(this.project.startDate, this.minDateDelta) : null;\n    }\n\n    set min(value) {\n        super.min = value;\n    }\n\n    get max() {\n        return super.max || this.project?.startDate ? DateHelper.add(this.project.startDate, this.maxDateDelta) : year2300;\n    }\n\n    set max(value) {\n        super.max = value;\n    }\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nStartDateField.initClass();\n", "import DateField from '../../Core/widget/DateField.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n\n/**\n * @module SchedulerPro/widget/EndDateField\n */\n\nconst year2300 = new Date(2300, 0, 1);\n\n/**\n * Date field widget (text field + date picker) to be used together with Scheduling Engine.\n * This field adjusts time to the latest possible time of the day based on either:\n *\n * - the event calendars (which is a combination of its own calendar and assigned resources ones) - if\n *   {@link #config-eventRecord} is provided.\n * - the project {@link SchedulerPro.model.ProjectModel#field-calendar calendar} - if {@link #config-project} is\n *   provided. The default value of the {@link #property-max} property is set to be 200 years\n *   after the project's end date (or to the year 2300 if no project is provided).\n *\n * **Please note, that either {@link #config-eventRecord} or {@link #config-project} value must be provided.**\n *\n * This field can be used as an editor for a {@link Grid.column.Column Column}.\n * It is used as the default editor for the `EndDateColumn`.\n *\n * {@inlineexample SchedulerPro/widget/EndDateField.js}\n * @extends Core/widget/DateField\n * @classType enddatefield\n * @inputfield\n */\nexport default class EndDateField extends DateField {\n\n    //region Config\n\n    static get $name() {\n        return 'EndDateField';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'enddatefield';\n    }\n\n    // Factoryable alias name\n    static get alias() {\n        return 'enddate';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Project model calendar of which should be used by the field.\n             * @config {SchedulerPro.model.ProjectModel}\n             */\n            project     : null,\n            /**\n             * The Event model defining the calendar to be used by the field.\n             * @config {SchedulerPro.model.EventModel}\n             */\n            eventRecord : null,\n\n            strictParsing : true\n        };\n    }\n\n    //endregion\n\n    //region Internal\n\n    get min() {\n        let min               = this._min;\n        const eventStartDate  = this.eventRecord?.startDate;\n\n        if (eventStartDate) {\n            min = DateHelper.max(min || eventStartDate, eventStartDate);\n        }\n\n        return min;\n    }\n\n    set min(value) {\n        super.min = value;\n    }\n\n    get max() {\n        return super.max || this.project?.startDate ? DateHelper.add(this.project.startDate, 200, 'year') : year2300;\n    }\n\n    set max(value) {\n        super.max = value;\n    }\n\n    get calendarProvider() {\n        // Occurrences does not have their own calendar, use master events calendar\n        return (this.eventRecord?.recurringEvent ?? this.eventRecord) || this.project;\n    }\n\n    get backShiftDate() {\n        const me = this;\n\n        let result = me.calendarProvider.run('skipWorkingTime', me.value, false, me._step.magnitude, me._step.unit);\n\n        // Need to skip non-working time\n        // since after the above step \"result\" can be set at 08:00 for example (for business calendar)\n        result = result && me.calendarProvider.run('skipNonWorkingTime', result, false);\n\n        return result;\n    }\n\n    get forwardShiftDate() {\n        const me = this;\n\n        return me.calendarProvider.run('skipWorkingTime', me.value, true, me._step.magnitude, me._step.unit);\n    }\n\n    transformTimeValue(value) {\n        const { calendarProvider, keepTime } = this;\n\n        if (calendarProvider && keepTime !== 'entered') {\n            const\n                startOfTheDay  = DateHelper.clearTime(value),\n                startOfNextDay = DateHelper.add(startOfTheDay, 1, 'day'),\n                // search for the latest available time for this day\n                latestTime     = calendarProvider.run('skipNonWorkingTime', startOfNextDay, false);\n\n            // if it's the same day, the latest time is found, use it\n            if (DateHelper.isValidDate(latestTime) && DateHelper.isEqual(latestTime, startOfTheDay, 'day')) {\n                return DateHelper.copyTimeValues(startOfTheDay, latestTime);\n            }\n        }\n\n        // if keepTime==false means we reset time info ...make sure we do not violate \"min\" value in that case\n        if (!keepTime && value && this.min && DateHelper.clearTime(value, false) < this.min) {\n            return this.min;\n        }\n\n        return super.transformTimeValue(value);\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nEndDateField.initClass();\n", "import DurationField from '../../Core/widget/DurationField.js';\n\n/**\n * @module SchedulerPro/widget/EffortField\n */\n\n// NOTE: class is created mostly for localization reasons\n//       effort field invalidText might differ from duration field one.\n\n/**\n * A specialized field allowing a user to also specify duration unit when editing the effort value.\n *\n * {@inlineexample SchedulerPro/widget/EffortField.js}\n * @extends Core/widget/DurationField\n * @classType effort\n * @inputfield\n */\nexport default class EffortField extends DurationField {\n\n    static get $name() {\n        return 'EffortField';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'effort';\n    }\n\n    // Factoryable type name\n    static get alias() {\n        return 'effortfield';\n    }\n}\n\n// Register this widget type with its Factory\nEffortField.initClass();\n", "import FormTab from './FormTab.js';\nimport '../../widget/StartDateField.js';\nimport '../../widget/EndDateField.js';\nimport '../../widget/EffortField.js';\nimport '../../../Core/widget/NumberField.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/GeneralTab\n */\n\n/**\n * A tab inside the {@link SchedulerPro/widget/SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro/widget/GanttTaskEditor gantt task editor} showing the general information for a task.\n *\n * | Field ref     | Type                                       | Text       | Weight | Description                                                        |\n * |---------------|--------------------------------------------|------------|--------|--------------------------------------------------------------------|\n * | `name`        | {@link Core/widget/TextField}              | Name       | 100    | Task name                                                          |\n * | `percentDone` | {@link Core/widget/NumberField}            | % Complete | 200    | Shows what part of task is done already in percentage              |\n * | `effort`      | {@link SchedulerPro/widget/EffortField}    | Effort     | 300    | Shows how much working time is required to complete the whole task |\n * | `divider`     | {@link Core/widget/Widget}                 |            | 400    | Visual splitter between 2 groups of fields                         |\n * | `startDate`   | {@link SchedulerPro/widget/StartDateField} | Start      | 500    | Shows when the task begins                                         |\n * | `endDate`     | {@link SchedulerPro/widget/EndDateField}   | Finish     | 600    | Shows when the task ends                                           |\n * | `duration`    | {@link Core/widget/DurationField}          | Duration   | 700    | Shows how long the task is                                         |\n *\n * @extends SchedulerPro/widget/taskeditor/FormTab\n * @classtype generaltab\n */\nexport default class GeneralTab extends FormTab {\n    static get $name() {\n        return 'GeneralTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'generaltab';\n    }\n\n    static get defaultConfig() {\n        return {\n            title : 'L{General}',\n            cls   : 'b-general-tab',\n\n            defaults : {\n                localeClass : this\n            },\n\n            items : {\n                name : {\n                    type      : 'text',\n                    weight    : 100,\n                    required  : true,\n                    label     : 'L{Name}',\n                    clearable : true,\n                    name      : 'name',\n                    cls       : 'b-name'\n                },\n                percentDone : {\n                    type   : 'number',\n                    weight : 200,\n                    label  : 'L{% complete}',\n                    name   : 'renderedPercentDone',\n                    cls    : 'b-percent-done b-inline',\n                    flex   : '1 0 50%',\n                    min    : 0,\n                    max    : 100\n                },\n                effort : {\n                    type   : 'effort',\n                    weight : 300,\n                    label  : 'L{Effort}',\n                    name   : 'fullEffort',\n                    flex   : '1 0 50%'\n                },\n                divider : {\n                    html    : '',\n                    weight  : 400,\n                    dataset : {\n                        text : this.L('L{Dates}')\n                    },\n                    cls  : 'b-divider',\n                    flex : '1 0 100%'\n                },\n                startDate : {\n                    type   : 'startdate',\n                    weight : 500,\n                    label  : 'L{Start}',\n                    name   : 'startDate',\n                    cls    : 'b-start-date b-inline',\n                    flex   : '1 0 50%'\n                },\n                endDate : {\n                    type   : 'enddate',\n                    weight : 600,\n                    label  : 'L{Finish}',\n                    name   : 'endDate',\n                    cls    : 'b-end-date b-last-row',\n                    flex   : '1 0 50%'\n                },\n                duration : {\n                    type   : 'durationfield',\n                    weight : 700,\n                    label  : 'L{Duration}',\n                    name   : 'fullDuration',\n                    flex   : '.5 0',\n                    cls    : 'b-inline'\n                }\n            }\n        };\n    }\n\n    loadEvent(record) {\n        const\n            step         = {\n                unit      : record.durationUnit,\n                magnitude : 1\n            },\n            {\n                startDate,\n                endDate,\n                effort\n            }            = this.widgetMap;\n\n        if (startDate) {\n            startDate.step = step;\n            startDate.eventRecord = record;\n        }\n\n        if (endDate) {\n            endDate.step = step;\n            endDate.eventRecord = record;\n        }\n\n        if (effort) {\n            effort.unit = record.effortUnit;\n        }\n\n        super.loadEvent(record);\n    }\n}\n\n// Register this widget type with its Factory\nGeneralTab.initClass();\n", "import Combo from '../../Core/widget/Combo.js';\nimport LocaleManager from '../../Core/localization/LocaleManager.js';\n\n/**\n * @module SchedulerPro/widget/DependencyTypePicker\n */\n\nconst buildItems = (items) => items.map((item, index) => [index, item]);\n\n/**\n * A combo box field used to select the link type for a {@link SchedulerPro.model.DependencyModel Dependency} between two tasks.\n *\n * {@inlineexample SchedulerPro/widget/DependencyTypePicker.js}\n * @extends Core/widget/Combo\n * @classType dependencytypepicker\n * @inputfield\n */\nexport default class DependencyTypePicker extends Combo {\n\n    //region Config\n\n    static get $name() {\n        return 'DependencyTypePicker';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'dependencytypepicker';\n    }\n\n    //endregion\n\n    //region Constructor\n\n    construct(config) {\n        super.construct(config);\n\n        // Update when changing locale\n        LocaleManager.ion({\n            locale : () => {\n                this.items = buildItems(this.L('L{DependencyType.long}'));\n            },\n            thisObj : this\n        });\n    }\n\n    //endregion\n\n    //region Internal\n\n    get store() {\n        if (!this._items) {\n            this.items = this._items = buildItems(this.L('L{DependencyType.long}'));\n        }\n\n        return super.store;\n    }\n\n    set store(store) {\n        super.store = store;\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nDependencyTypePicker.initClass();\n", "import StringHelper from '../../../Core/helper/StringHelper.js';\nimport EditorTab from './EditorTab.js';\nimport { DependencyValidationResult } from '../../../Engine/scheduling/Types.js';\nimport '../../../Scheduler/column/DurationColumn.js';\nimport '../DependencyTypePicker.js';\nimport '../ModelCombo.js';\nimport '../../../Grid/view/Grid.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/DependencyTab\n */\n\nconst\n    markDependencyValid     = (dep, grid) => {\n        dep.instanceMeta(grid).valid = true;\n    },\n    markDependencyInvalid   = (dep, grid) => {\n        dep.instanceMeta(grid).valid = false;\n    },\n    isDependencyMarkedValid = (dep, grid) => dep.instanceMeta(grid).valid !== false;\n\n/**\n * Abstract base class for SuccessorsTab and PredecessorsTab.\n *\n * @extends SchedulerPro/widget/taskeditor/EditorTab\n * @abstract\n */\nexport default class DependencyTab extends EditorTab {\n\n    //region Config\n\n    static get $name() {\n        return 'DependencyTab';\n    }\n\n    static get type() {\n        return 'dependencytab';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * A task field (`id`, `wbsCode`, `sequenceNumber` etc) that will be used when displaying and editing linked\n             * tasks. Defaults to Gantt `dependencyIdField`.\n             * @config {String} dependencyIdField\n             */\n            dependencyIdField : null,\n\n            layoutStyle : {\n                flexFlow : 'column nowrap'\n            },\n\n            // Documented in subclasses\n            sortField : null,\n\n            /**\n             * A task field (`id`, `wbsCode`, `sequenceNumber` etc) to sort tasks in the task combo by\n             * @config {String}\n             * @default\n             */\n            taskComboSortField : 'name',\n\n            items : {\n                grid : {\n                    type                       : 'grid',\n                    weight                     : 100,\n                    flex                       : '1 1 auto',\n                    emptyText                  : '',\n                    asyncEventSuffix           : 'PreCommit',\n                    disableGridRowModelWarning : true,\n\n                    features : {\n                        group : false\n                    },\n\n                    columns : {\n                        data : {\n                            id : {\n                                localeClass : this,\n                                text        : 'L{ID}',\n                                flex        : 1,\n                                editor      : false,\n                                htmlEncode  : false,\n                                hidden      : true,\n                                sortable(dependency1, dependency2) {\n                                    const\n                                        { dependencyIdField, direction } = this.grid.parent,\n                                        id1                   = dependency1[direction]?.[dependencyIdField],\n                                        id2                   = dependency2[direction]?.[dependencyIdField];\n\n                                    if (id1 === id2) {\n                                        return 0;\n                                    }\n\n                                    return id1 < id2 ? -1 : 1;\n                                },\n                                renderer : ({ record: dependency, row, grid, column }) => {\n                                    let html;\n                                    const\n                                        { direction } = grid.parent,\n                                        linkedEvent   = dependency[direction];\n\n                                    if (linkedEvent && isDependencyMarkedValid(dependency, grid)) {\n                                        const\n                                            idField = grid.parent.dependencyIdField,\n                                            id      = linkedEvent[idField];\n\n                                        if (idField === 'id') {\n                                            html = !linkedEvent || linkedEvent.hasGeneratedId ? '*' : linkedEvent.id;\n                                        }\n                                        else {\n                                            html = id;\n                                        }\n                                    }\n                                    else {\n                                        row.addCls('b-invalid');\n                                        html = '<div class=\"b-icon b-icon-warning\"></div>';\n                                    }\n\n                                    return html;\n                                }\n                            },\n                            name : {\n                                localeClass : this,\n                                text        : 'L{Name}',\n                                flex        : 5,\n                                renderer    : ({ value : event, grid, cellElement }) => {\n                                    if (event) {\n                                        // indicate inactive tasks\n                                        cellElement.classList.toggle('b-inactive', event.inactive);\n\n                                        const id = event[grid.parent.dependencyIdField];\n                                        return event.name + (((id != null) && !event.hasGeneratedId) ? ` (${id})` : '');\n                                    }\n\n                                    return '';\n                                },\n                                finalizeCellEdit : 'up.finalizeLinkedTaskCellEdit',\n                                editor           : {\n                                    type           : 'modelcombo',\n                                    displayField   : 'name',\n                                    valueField     : 'id',\n                                    filterOperator : '*',\n                                    allowInvalid   : true,\n                                    listItemTpl(event) {\n                                        const\n                                            me            = this,\n                                            dependencyTab = me._dependencyTab ||\n                                                           (me._dependencyTab = me.up('dependencytab', true)),\n                                            { dependencyIdField } = dependencyTab,\n                                            id = (event.hasGeneratedId && dependencyIdField === 'id')\n                                                ? null : event[dependencyIdField];\n                                            // only consider hasGeneratedId if dependencyIdField === 'id' because if\n                                            // dependencyIdField === 'wbsCode', we want to show that (and most likely\n                                            // any field other than \"id\")\n\n                                        return StringHelper.xss`${event.name}${(id != null) ? ` (${id})` : ''}`;\n                                    }\n                                }\n                            },\n                            type : {\n                                localeClass : this,\n                                text        : 'L{Type}',\n                                field       : 'type',\n                                flex        : 3,\n                                sortable    : false,\n                                editor      : 'dependencytypepicker',\n                                renderer({ value }) {\n                                    return this.L('L{DependencyType.long}')[value];\n                                }\n                            },\n                            lag : {\n                                localeClass : this,\n                                text        : 'L{Lag}',\n                                type        : 'duration',\n                                field       : 'fullLag',\n                                flex        : 2,\n                                editor      : {\n                                    allowNegative : true\n                                }\n                            }\n                        }\n                    }\n                },\n                toolbar : {\n                    type  : 'toolbar',\n                    dock  : 'bottom',\n                    cls   : 'b-compact-bbar',\n                    items : {\n                        add : {\n                            type     : 'button',\n                            weight   : 210,\n                            cls      : 'b-add-button b-green',\n                            icon     : 'b-icon b-icon-add',\n                            onAction : 'up.onAddClick'\n                        },\n                        remove : {\n                            type     : 'button',\n                            weight   : 220,\n                            cls      : 'b-remove-button b-red',\n                            icon     : 'b-icon b-icon-trash',\n                            disabled : true,\n                            onAction : 'up.onRemoveClick'\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    //endregion\n\n    // Triggered before applying cell editing result to the dependency\n    async finalizeLinkedTaskCellEdit({ grid, value : linkedTask, record : dependency }) {\n        const\n            { project }      = grid.store.masterStore,\n            isSuccessor      = this.direction === 'toEvent',\n            source           = isSuccessor ? dependency.fromEvent : linkedTask,\n            target           = isSuccessor ? linkedTask : dependency.toEvent,\n            validationResult = await project.validateDependency(source, target, dependency.type, dependency);\n\n        switch (validationResult) {\n            // no error\n            case DependencyValidationResult.NoError:\n                return true;\n            // cycle\n            case DependencyValidationResult.CyclicDependency:\n                return 'L{DependencyTab.cyclicDependency}';\n        }\n\n        return 'L{DependencyTab.invalidDependency}';\n    }\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        const grid = this.grid = this.widgetMap.grid;\n\n        grid.ion({\n            selectionChange : 'onGridSelectionChange',\n            startCellEdit   : 'onGridStartCellEdit',\n            finishCellEdit  : 'onGridFinishCellEdit',\n            cancelCellEdit  : 'onGridCancelCellEdit',\n            thisObj         : this\n        });\n    }\n\n    get taskCombo() {\n        const\n            { grid } = this,\n            from     = grid?.columns.get(this.direction);\n\n        return from?.editor;\n    }\n\n    loadEvent(eventRecord) {\n        const\n            me                          = this,\n            { grid, taskCombo, record } = me;\n\n        super.loadEvent(eventRecord);\n\n        const\n            {\n                dependencyStore,\n                eventStore\n            }                   = me.project,\n            storeChange         = grid.store.masterStore !== dependencyStore,\n            recordChange        = !storeChange && (eventRecord !== record);\n\n        // On first load or if project has changed, populate the chained stores.\n        // Our grid store will contain only the direction of dependencies this tab is interested in.\n        // Our taskCombo only contains all events other than our event.\n        // An event can't depend upon itself.\n        if (storeChange) {\n            // Cache the mutation generation of the underlying data collection\n            // so that we know when we need to refill the chained stores.\n            me.depStoreGeneration = dependencyStore.storage.generation;\n            me.eventStoreGeneration = eventStore.storage.generation;\n\n            me.detachListeners('taskCombo');\n\n            grid.store = dependencyStore.chain(\n                d => d[me.negDirection] === me.record,\n                null\n            );\n\n            const comboStore = taskCombo.store = eventStore.chain(\n                // Remove original record from chained store, but keep those records that are already selected in the dependency grid\n                e => e !== me.record,\n                null,\n                {\n                    doRelayToMaster         : [],\n                    // Need to show all records in the combo\n                    excludeCollapsedRecords : false\n                }\n            );\n\n            comboStore.sort(me.taskComboSortField);\n\n            // Post process chained store and exclude records that are already selected in the dependency grid.\n            // It's needed to be a separate filtering because otherwise when cell editor opens combo and sets initial value,\n            // it cannot find it in the storage and adds new record.\n            comboStore.filterBy(e => !grid.store.find(d => {\n                const\n                    dep          = d[me.direction],\n                    activeEdit   = me._activeCellEdit,\n                    isDepEditing = activeEdit && dep === activeEdit.record[me.direction];\n\n                // checking !isDepEditing will keep as combo option the current record\n                return dep === e && !isDepEditing;\n            }));\n\n            taskCombo.ion({\n                name    : 'taskCombo',\n                change  : 'onGridCellEditChange',\n                thisObj : me\n            });\n        }\n        else {\n            //<debug>\n            console.assert(\n                eventRecord.isOccurrence || grid.store.masterStore.project === eventRecord.project,\n                'Loading of a record from another project is not currently supported!'\n            );\n            //</debug>\n\n            // Only repopulate the chained stores if the master stores have changed\n            // or if this is being loaded with a different record.\n            if (recordChange || dependencyStore.storage.generation !== me.depStoreGeneration) {\n                grid.store.fillFromMaster();\n                me.depStoreGeneration = dependencyStore.storage.generation;\n            }\n            // If not changed, the details within the store may have changed\n            // (for example undo on edit cancel), so refresh the grid.\n            else {\n                grid.refreshRows();\n            }\n\n            if (recordChange || eventStore.storage.generation !== me.eventStoreGeneration) {\n                taskCombo.store.fillFromMaster();\n                me.eventStoreGeneration = eventStore.storage.generation;\n            }\n        }\n\n        if (recordChange) {\n            grid.store.sort(me.sortField);\n        }\n\n        me.requestReadyStateChange();\n    }\n\n    async insertNewDependency() {\n        const\n            me       = this,\n            { grid } = me,\n            { cellEdit } = grid.features;\n\n        // Cancel any ongoing editing in an invalid state first\n        if (cellEdit.isEditing && !cellEdit.editor.isValid) {\n            cellEdit.cancelEditing();\n        }\n\n        // This call will be relayed to project dependency store.\n        const [newDep] = grid.store.insert(0, {\n            [me.negDirection] : me.record\n        });\n\n        // Reset the dependency store mutation monitor when we add a dependency\n        me.depStoreGeneration = me.project.dependencyStore.storage.generation;\n\n        await grid.features.cellEdit.startEditing({ field : me.direction, id : newDep.id });\n\n        markDependencyInvalid(newDep, grid);\n\n        return newDep;\n    }\n\n    onAddClick() {\n        this.insertNewDependency();\n    }\n\n    onRemoveClick() {\n        const\n            me           = this,\n            { grid }     = me,\n            toRemove     = grid.selectedRecords;\n\n        grid.features.cellEdit.cancelEditing(true);\n        me.project.dependencyStore.remove(toRemove);\n        grid.selectedRecord = grid.store.getNext(toRemove[0]);\n        me.taskCombo.store.fillFromMaster();\n    }\n\n    onGridSelectionChange({ selection }) {\n        const\n            removeButton = this.widgetMap.remove,\n            disable      = Boolean(!selection?.length || this.up(w => w.readOnly));\n\n        // Rather than allow auto focus reversion which attempts to focus the same element\n        // that focus arrived from, explicitly focus the grid so that the navigation's leniency\n        // will focus the closest remaining cell to the focusedCell.\n        if (removeButton.containsFocus && disable) {\n            // Focus grid header\n            this.grid.focusCell({ rowIndex : -1, columnIndex : 0 });\n        }\n\n        removeButton.disabled = disable;\n    }\n\n    clearActiveEditorErrors() {\n        const activeCellEdit = this._activeCellEdit;\n\n        if (activeCellEdit && activeCellEdit.column.field === this.direction) {\n            activeCellEdit.editor.inputField.clearError();  // clears all errors\n        }\n    }\n\n    onGridCellEditChange() {\n        // Since we deposit some errors on the editor during startEdit (see onGridStartCellEdit), we must also clear\n        // them eventually or the editor will refuse to accept any value. Since validation will still take place, we\n        // don't need to worry about preventing the editor from dismissing nor could we realistically since validation\n        // is async (see onGridFinishCellEdit).\n        this.clearActiveEditorErrors();\n    }\n\n    onGridStartCellEdit({ editorContext }) {\n        const\n            me                  = this,\n            dep                 = me._editingDependency = editorContext.record,\n            { grid, direction } = me;\n\n        me._activeCellEdit = editorContext;\n\n        if (editorContext.column.field === direction) {\n            if (!isDependencyMarkedValid(dep, grid)) {\n                if (!dep[direction]) {\n                    editorContext.editor.inputField.setError('L{DependencyTab.invalidDependency}');\n                }\n                else {\n                    editorContext.editor.inputField.setError('L{DependencyTab.cyclicDependency}');\n                }\n            }\n            else {\n                me.clearActiveEditorErrors();\n            }\n\n            //dep.shadow();\n        }\n    }\n\n    async onGridFinishCellEdit({ editorContext }) {\n        const\n            me                              = this,\n            { record : dependency, column } = editorContext,\n            { grid, direction }             = me;\n\n        // Other dependency end\n        if (column.field === direction) {\n            markDependencyValid(dependency, grid);\n            me.taskCombo.store.fillFromMaster();\n        }\n        // Type and Lag\n        else {\n            me.redrawDependencyRow(dependency);\n        }\n\n        me._activeCellEdit = me._editingDependency = null;\n\n        me.requestReadyStateChange();\n    }\n\n    afterCancel() {\n        // After task editor is closed by clicking \"Cancel\"\n        // let's cancel cell editing if it's in progress (could happen if cell editor has a validation error)\n        if (this._activeCellEdit) {\n            this.grid.features.cellEdit.cancelEditing(true);\n        }\n    }\n\n    onGridCancelCellEdit() {\n        const\n            me         = this,\n            dependency = me._editingDependency;\n\n        if (dependency) {\n            if (!dependency[me.direction]) {\n                markDependencyInvalid(dependency, me.grid);\n                me.redrawDependencyRow(dependency);\n            }\n\n            me._activeCellEdit = me._editingDependency = null;\n        }\n\n        me.requestReadyStateChange();\n    }\n\n    redrawDependencyRow(dependency) {\n        // <remove-on-release>\n        // TODO: Redraw dependency directly instead of row\n        // </remove-on-release>\n        const\n            { grid } = this,\n            row      = grid.rowManager.getRowById(dependency);\n\n        // Might be out of view\n        if (row) {\n            const recordIndex = grid.store.indexOf(dependency);\n\n            // the record could no longer be in the store if we click remove button while cell editing is in progress\n            if (recordIndex >= 0) {\n                row.render(grid.store.indexOf(dependency), dependency);\n            }\n        }\n    }\n\n    get canSave() {\n        const { grid } = this;\n\n        return grid.store.every(d => isDependencyMarkedValid(d, grid));\n    }\n\n    updateReadOnly(readOnly) {\n        const { add, remove } = this.widgetMap;\n\n        super.updateReadOnly(...arguments);\n\n        // Buttons hide when we are readOnly\n        add.hidden = remove.hidden = readOnly;\n    }\n}\n", "import DependencyTab from './DependencyTab.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/SuccessorsTab\n */\n\n/**\n * A tab inside the {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro.widget.GanttTaskEditor gantt task editor} showing the successors of an event or task.\n *\n * The tab has the following contents by default:\n *\n * | Widget ref  | Type                                | Weight | Description                                         |\n * |-------------|-------------------------------------|--------|-----------------------------------------------------|\n * | `grid`      | {@link Grid.view.Grid Grid}         | 100    | Shows successors task name, dependency type and lag |\n * | \\> `id`*    | {@link Grid.column.Column Column}   | -      | Id column                                           |\n * | \\> `name`*  | {@link Grid.column.Column Column}   | -      | Name column, linked task                            |\n * | \\> `type`*  | {@link Grid.column.Column Column}   | -      | Dependency type column                              |\n * | \\> `lag` *  | {@link Scheduler.column.DurationColumn DurationColumn} | - | Duration column                    |\n * | `toolbar`   | {@link Core.widget.Toolbar Toolbar} | -      | Control buttons in a toolbar docked to bottom       |\n * | \\> `add`    | {@link Core.widget.Button Button}   | 210    | Adds a new successor                                |\n * | \\> `remove` | {@link Core.widget.Button Button}   | 220    | Removes selected outgoing dependency                |\n *\n * <sup>*</sup>Columns are kept in the grids column store, they can be customized in a similar manner as other widgets in the\n * editor:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *   features : {\n *     taskEdit : {\n *       items : {\n *         successorsTab : {\n *           items : {\n *             grid : {\n *               columns : {\n *                 // Columns are held in a store, thus it uses `data`\n *                 // instead of `items`\n *                 data : {\n *                   name : {\n *                     // Change header text for the name column\n *                     text : 'Linked to'\n *                   }\n *                 }\n *               }\n *             }\n *           }\n *         }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends SchedulerPro/widget/taskeditor/DependencyTab\n * @classtype successorstab\n */\nexport default class SuccessorsTab extends DependencyTab {\n    static get $name() {\n        return 'SuccessorsTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'successorstab';\n    }\n\n    static get configurable() {\n        return {\n            cls          : 'b-successors-tab',\n            direction    : 'toEvent',\n            negDirection : 'fromEvent',\n            title        : 'L{DependencyTab.Successors}',\n\n            /**\n             * Dependency field to sort successors by\n             * @private\n             * @config {String}\n             * @default\n             */\n            sortField : 'toEventName',\n\n            items : {\n                grid : {\n                    columns : {\n                        data : {\n                            name : {\n                                field : 'toEvent'\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n}\n\n// Register this widget type with its Factory\nSuccessorsTab.initClass();\n", "import DependencyTab from './DependencyTab.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/PredecessorsTab\n */\n\n/**\n * A tab inside the {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro.widget.GanttTaskEditor gantt task editor} showing the predecessors of an event or task.\n *\n * The tab has the following contents by default:\n *\n * | Widget ref  | Type                                | Weight | Description                                       |\n * |-------------|-------------------------------------|--------|---------------------------------------------------|\n * | `grid`      | {@link Grid.view.Grid Grid}         | 100    | Shows predecessors  name, dependency type and lag |\n * | \\> `id`*    | {@link Grid.column.Column Column}   | -      | Id column                                         |\n * | \\> `name`*  | {@link Grid.column.Column Column}   | -      | Name column, linked task                          |\n * | \\> `type`*  | {@link Grid.column.Column Column}   | -      | Dependency type column                            |\n * | \\> `lag`*   | {@link Scheduler.column.DurationColumn DurationColumn} | - | Duration column                  |\n * | `toolbar`   | {@link Core.widget.Toolbar Toolbar} | -      | Control buttons in a toolbar docked to bottom     |\n * | \\> `add`    | {@link Core.widget.Button Button}   | 210    | Adds a new predecessor                            |\n * | \\> `remove` | {@link Core.widget.Button Button}   | 220    | Removes selected incoming dependency              |\n *\n * <sup>*</sup>Columns are kept in the grids column store, they can be customized in a similar manner as other widgets in the\n * editor:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *   features : {\n *     taskEdit : {\n *       items : {\n *          predecessorsTab : {\n *            items : {\n *              grid : {\n *                columns : {\n *                  // Columns are held in a store, thus it uses `data`\n *                  // instead of `items`\n *                  data : {\n *                    name : {\n *                      // Change header text for the name column\n *                      text : 'Linked to'\n *                    }\n *                  }\n *                }\n *              }\n *            }\n *          }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends SchedulerPro/widget/taskeditor/DependencyTab\n * @classtype predecessorstab\n */\nexport default class PredecessorsTab extends DependencyTab {\n    static get $name() {\n        return 'PredecessorsTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'predecessorstab';\n    }\n\n    static get configurable() {\n        return {\n            cls          : 'b-predecessors-tab',\n            direction    : 'fromEvent',\n            negDirection : 'toEvent',\n            title        : 'L{DependencyTab.Predecessors}',\n\n            /**\n             * Dependency field to sort predecessors by\n             * @private\n             * @config {String}\n             * @default\n             */\n            sortField : 'fromEventName',\n\n            items : {\n                grid : {\n                    columns : {\n                        data : {\n                            name : {\n                                field : 'fromEvent'\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n}\n\n// Register this widget type with its Factory\nPredecessorsTab.initClass();\n", "import '../../../Grid/view/Grid.js';\nimport EditorTab from './EditorTab.js';\nimport '../../../Grid/column/NumberColumn.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/ResourcesTab\n */\n\n/**\n * A tab inside the {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro.widget.GanttTaskEditor gantt task editor} showing the assigned resources for an event or task.\n *\n * The tab has the following contents by default:\n *\n * | Widget ref     | Type                             | Weight | Description                            |\n * |----------------|----------------------------------|--------|----------------------------------------|\n * | `grid`         | {@link Grid.view.Grid}           | 100    | Shows resource name and assigned units |\n * | \\> `resource`* | {@link Grid.column.Column}       | -      | Name column, linked task               |\n * | \\> `units`*    | {@link Grid.column.NumberColumn} | -      | Dependency type column                 |\n * | `toolbar`      | {@link Core.widget.Toolbar}      | -      | Toolbar docked to bottom               |\n * | \\> `add`       | {@link Core.widget.Button}       | 210    | Adds a new assignment                  |\n * | \\> `remove`    | {@link Core.widget.Button}       | 220    | Removes selected assignment            |\n *\n * <sup>*</sup>Columns are kept in the grids column store, they can be customized in a similar manner as other widgets\n * in the editor:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *   features : {\n *     taskEdit : {\n *       items : {\n *         resourcesTab : {\n *           items : {\n *             grid : {\n *               columns : {\n *                 // Columns are held in a store, thus it uses `data`\n *                 // instead of `items`\n *                 data : {\n *                   resource : {\n *                     // Change header text for the resource column\n *                     text : 'Machine'\n *                   }\n *                 }\n *               }\n *             }\n *           }\n *         }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends SchedulerPro/widget/taskeditor/EditorTab\n */\nexport default class ResourcesTab extends EditorTab {\n\n    static get $name() {\n        return 'ResourcesTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'resourcestab';\n    }\n\n    static get configurable() {\n        return {\n            title : 'L{Resources}',\n            cls   : 'b-resources-tab',\n\n            layoutStyle : {\n                flexFlow : 'column nowrap'\n            },\n\n            /**\n             * Specify `true` to show the \"Units\" column representing the\n             * {@link SchedulerPro/model/AssignmentModel assignment units} value.\n             * @config {Boolean}\n             */\n            showUnits : null,\n\n            items : {\n                grid : {\n                    type    : 'grid',\n                    weight  : 100,\n                    flex    : '1 1 auto',\n                    columns : {\n                        data : {\n                            resource : {\n                                localeClass : this,\n                                text        : 'L{Resource}',\n                                field       : 'resource',\n                                flex        : 7,\n                                renderer    : ({ value }) => value?.name || '',\n                                editor      : {\n                                    type         : 'modelcombo',\n                                    displayField : 'name',\n                                    valueField   : 'id'\n                                }\n                            },\n                            units : {\n                                type        : 'number',\n                                localeClass : this,\n                                text        : 'L{Units}',\n                                field       : 'units',\n                                flex        : 3,\n                                renderer    : data => this.L('L{unitsTpl}', data),\n                                min         : 0,\n                                max         : 100,\n                                step        : 10\n                            }\n                        }\n                    },\n\n                    disableGridRowModelWarning : true,\n                    asyncEventSuffix           : 'PreCommit'\n                },\n                toolbar : {\n                    type  : 'toolbar',\n                    dock  : 'bottom',\n                    cls   : 'b-compact-bbar',\n                    items : {\n                        add : {\n                            type   : 'button',\n                            weight : 210,\n                            cls    : 'b-add-button b-green',\n                            icon   : 'b-icon b-icon-add'\n                        },\n                        remove : {\n                            type     : 'button',\n                            weight   : 220,\n                            cls      : 'b-remove-button b-red',\n                            icon     : 'b-icon b-icon-trash',\n                            disabled : true\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        const\n            me           = this,\n            addButton    = me.addButton = me.widgetMap.add,\n            removeButton = me.removeButton = me.widgetMap.remove,\n            grid         = me.grid = me.widgetMap.grid;\n\n        addButton?.ion({ click : 'onAddClick', thisObj : me });\n        removeButton?.ion({ click : 'onRemoveClick', thisObj : me });\n\n        grid.ion({\n            selectionChange : 'onGridSelectionChange',\n            startCellEdit   : 'onGridStartCellEdit',\n            finishCellEdit  : 'onGridFinishCellEdit',\n            cancelCellEdit  : 'onGridCancelCellEdit',\n            thisObj         : me\n        });\n    }\n\n    updateReadOnly(readOnly) {\n        const { add, remove } = this.widgetMap;\n\n        super.updateReadOnly(...arguments);\n\n        // Buttons hide when we are readOnly\n        add.hidden = remove.hidden = readOnly;\n    }\n\n    get resourceCombo() {\n        const from = this.grid?.columns.get('resource');\n\n        return from?.editor;\n    }\n\n    updateShowUnits(value) {\n        const\n            column = this.widgetMap.grid.columns.get('units');\n\n        if (column) {\n            column.hidden = !value;\n        }\n    }\n\n    loadEvent(eventRecord) {\n        const\n            me                              = this,\n            { resourceCombo, grid, record } = me;\n\n        super.loadEvent(eventRecord);\n\n        const\n            { assignmentStore, resourceStore } = me.project,\n            storeChange                        = grid.store.masterStore !== assignmentStore,\n            recordChange                       = !storeChange && (eventRecord !== record);\n\n        //<debug>\n        console.assert(\n            storeChange || grid.store.masterStore.project === eventRecord.project,\n            'Loading of a record from another project is not currently supported!'\n        );\n        //</debug>\n\n        // Pro does not use units on assignments by default\n        if (typeof this.showUnits !== 'boolean') {\n            grid.columns.get('units').hidden = !eventRecord.isTask;\n        }\n\n        if (storeChange) {\n            // Cache the mutation generation of the underlying data collection\n            // so that we know when we need to refill the chained stores.\n            me.assignmentStoreGeneration = assignmentStore.storage.generation;\n            me.resourceStoreGeneration = resourceStore.storage.generation;\n\n            grid.store = assignmentStore.chain(a => me.record && a.event === me.record, null);\n\n            resourceCombo.store = resourceStore.chain(resource => {\n                return !resource.isSpecialRow && (me.record && !me.record.isAssignedTo(resource)) ||\n                    !me.activeAssignment || me.activeAssignment.resource === resource;\n            }, null, {\n                groupers : resourceStore.groupers\n            });\n        }\n        else {\n            // Only repopulate the chained stores if the master stores have changed\n            // or if this is being loaded with a different record.\n            if (recordChange || assignmentStore.storage.generation !== me.assignmentStoreGeneration) {\n                grid.store.fillFromMaster();\n            }\n            if (recordChange || resourceStore.storage.generation !== me.resourceStoreGeneration) {\n                resourceCombo.store.fillFromMaster();\n            }\n        }\n    }\n\n    // Returns the assignment row currently being edited\n    get activeAssignment() {\n        return this.grid.features.cellEdit.activeRecord;\n    }\n\n    async insertNewAssignment() {\n        const\n            me                = this,\n            { project, grid } = me,\n            assignmentStore   = project.assignmentStore;\n\n        const [newAssignment] = assignmentStore.insert(0, {\n            event    : me.record,\n            resource : null,\n            units    : 100\n        });\n\n        // Reset the assignment store mutation monitor when we add an assignment\n        me.assignmentStoreGeneration = assignmentStore.storage.generation;\n        await grid.features.cellEdit.startEditing({ field : 'resource', id : newAssignment.id });\n\n        return newAssignment;\n    }\n\n    beforeSave() {\n        this.pruneInvalidAssignments();\n    }\n\n    onAddClick() {\n        this.insertNewAssignment();\n    }\n\n    onRemoveClick() {\n        const\n            me       = this,\n            { grid } = me;\n\n        grid.store.remove(grid.selectedRecords);\n        grid.selectedRecords = null;\n        me.removeButton.disable();\n    }\n\n    onGridSelectionChange({ selection }) {\n        const\n            { removeButton } = this,\n            disable          = !selection?.length || this.up(w => w.readOnly);\n\n        // Rather than allow auto focus reversion which attempts to focus the same element\n        // that focus arrived from, explicitly focus the grid so that the navigation's leniency\n        // will focus the closest remaining cell to the focusedCell.\n        if (removeButton.containsFocus && disable) {\n            this.grid.focus();\n        }\n        removeButton.disabled = disable;\n    }\n\n    onGridStartCellEdit({ editorContext }) {\n        if (editorContext.column.field === 'resource') {\n            this.resourceCombo.store.fillFromMaster();\n            this._editingAssignment = editorContext.record;\n            this._activeCellEdit = editorContext;\n        }\n    }\n\n    onGridFinishCellEdit() {\n        this._activeCellEdit = this._editingAssignment = null;\n    }\n\n    onGridCancelCellEdit() {\n        this._activeCellEdit = this._editingAssignment = null;\n    }\n\n    pruneInvalidAssignments() {\n        const { store } = this.grid;\n\n        store.remove(store.query(a => !a.isValid));\n    }\n}\n\n// Register this widget type with its Factory\nResourcesTab.initClass();\n", "import Combo from '../../Core/widget/Combo.js';\nimport Store from '../../Core/data/Store.js';\n\n/**\n * @module SchedulerPro/widget/ConstraintTypePicker\n */\n\n/**\n * Combo box preconfigured with possible constraint type values.\n * This picker doesn't support {@link Core/widget/Combo#config-multiSelect multiSelect}.\n *\n * This field can be used as an editor for a {@link Grid/column/Column}.\n * It is used as the default editor for the `ConstraintTypeColumn` in the Gantt chart.\n *\n * {@inlineexample SchedulerPro/widget/ConstraintTypePicker.js}\n * @extends Core/widget/Combo\n * @classType constrainttypepicker\n * @inputfield\n */\nexport default class ConstraintTypePicker extends Combo {\n\n    //region Config\n\n    static get $name() {\n        return 'ConstraintTypePicker';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'constrainttypepicker';\n    }\n\n    static get configurable() {\n        return {\n            valueField : 'id'\n        };\n    }\n    //endregion\n\n    //region Localization\n\n    updateLocalization() {\n        super.updateLocalization();\n        // rebuild newly translated options\n        this.store.data = this.buildStoreData();\n    }\n\n    //endregion\n\n    //region Internal\n\n    buildStoreData() {\n        const me = this;\n\n        return [\n            {\n                id   : 'none', // no-sanity\n                text : me.L('L{none}')\n            },\n            {\n                id   : 'muststarton', // no-sanity\n                text : me.L('L{muststarton}')\n            },\n            {\n                id   : 'mustfinishon', // no-sanity\n                text : me.L('L{mustfinishon}')\n            },\n            {\n                id   : 'startnoearlierthan', // no-sanity\n                text : me.L('L{startnoearlierthan}')\n            },\n            {\n                id   : 'startnolaterthan', // no-sanity\n                text : me.L('L{startnolaterthan}')\n            },\n            {\n                id   : 'finishnoearlierthan', // no-sanity\n                text : me.L('L{finishnoearlierthan}')\n            },\n            {\n                id   : 'finishnolaterthan', // no-sanity\n                text : me.L('L{finishnolaterthan}')\n            }\n        ];\n    }\n\n    set value(value) {\n        super.value = value;\n    }\n\n    get value() {\n        const value = super.value;\n\n        return value === 'none' ? null : value;\n    }\n\n    get store() {\n        if (!this._store) {\n            this.store = new Store({\n                data        : this.buildStoreData(),\n                allowNullId : true\n            });\n        }\n\n        return this._store;\n    }\n\n    set store(store) {\n        super.store = store;\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nConstraintTypePicker.initClass();\n", "import Combo from '../../Core/widget/Combo.js';\nimport { SchedulingMode } from '../../Engine/scheduling/Types.js';\n\n/**\n * @module SchedulerPro/widget/SchedulingModePicker\n */\n\n/**\n * Combo box preconfigured with possible scheduling mode values.\n *\n * This field can be used as an editor for the {@link Grid.column.Column Column}.\n * It is used as the default editor for the `SchedulingModeColumn`.\n *\n * {@inlineexample SchedulerPro/widget/SchedulingModePicker.js}\n * @extends Core/widget/Combo\n * @classType schedulingmodecombo\n * @inputfield\n */\nexport default class SchedulingModePicker extends Combo {\n\n    static get $name() {\n        return 'SchedulingModePicker';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'schedulingmodecombo';\n    }\n\n    //region Config\n\n    static get configurable() {\n        return {\n            /**\n             * Specifies a list of allowed scheduling modes to be shown in the picker.\n             * Supports either a string of comma separated values:\n             *\n             * ```javascript\n             * new SchedulingModePicker ({\n             *     allowedModes : 'FixedDuration,Normal'\n             *     ...\n             * })\n             *\n             * or an array of values:\n             *\n             * ```javascript\n             * new SchedulingModePicker ({\n             *     allowedModes : ['FixedDuration', 'Normal']\n             *     ...\n             * })\n             * @config {String|Array}\n             */\n            allowedModes : null,\n            store        : {\n                data : this.defaultStoreData\n            }\n        };\n    }\n\n    static get defaultStoreData() {\n        return [\n            {\n                id   : SchedulingMode.Normal,\n                text : this.L('L{Normal}')\n            },\n            {\n                id   : SchedulingMode.FixedDuration,\n                text : this.L('L{Fixed Duration}')\n            },\n            {\n                id   : SchedulingMode.FixedUnits,\n                text : this.L('L{Fixed Units}')\n            },\n            {\n                id   : SchedulingMode.FixedEffort,\n                text : this.L('L{Fixed Effort}')\n            }\n        ];\n    }\n\n    //endregion\n\n    //region Internal\n\n    changeAllowedModes(value) {\n        if (typeof value === 'string') {\n            return value.split(',');\n        }\n\n        return value;\n    }\n\n    updateAllowedModes(value) {\n        this._allowedModes = value;\n\n        if (value) {\n            this.store.addFilter({\n                id       : 'allowed-mode-filter', // no-sanity\n                filterBy : (record) => this._allowedModes.includes(record.id)\n            });\n        }\n        else {\n            this.store.removeFilter('allowed-mode-filter');\n        }\n    }\n\n    updateLocalization() {\n        super.updateLocalization();\n        // rebuild newly translated options\n        this.store.data = this.constructor.defaultStoreData;\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nSchedulingModePicker.initClass();\n", "import FormTab from './FormTab.js';\nimport '../CalendarField.js';\nimport '../ConstraintTypePicker.js';\nimport '../../../Core/widget/DateField.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../SchedulingModePicker.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/AdvancedTab\n */\n\n/**\n * Advanced task options {@link SchedulerPro/widget/SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro/widget/GanttTaskEditor gantt task editor} tab.\n *\n * | Field ref                     | Type                                             | Weight | Description                                                                                                                  |\n * |-------------------------------|--------------------------------------------------|--------|------------------------------------------------------------------------------------------------------------------------------|\n * | `calendarField`               | {@link Core/widget/Combo}                        | 100    | Shows a list of available calendars for this task                                                                            |\n * | `manuallyScheduledField`      | {@link Core/widget/Checkbox}                     | 200    | If checked, the task is not considered in scheduling                                                                         |\n * | `schedulingModeField`         | {@link SchedulerPro/widget/SchedulingModePicker} | 300    | Shows a list of available scheduling modes for this task                                                                     |\n * | `effortDrivenField`           | {@link Core/widget/Checkbox}                     | 400    | If checked, the effort of the task is kept intact, and the duration is updated. Works when scheduling mode is \"Fixed Units\". |\n * | `divider`                     | {@link Core/widget/Widget}                       | 500    | Visual splitter between 2 groups of fields                                                                                   |\n * | `constraintTypeField`         | {@link SchedulerPro/widget/ConstraintTypePicker} | 600    | Shows a list of available constraints for this task                                                                          |\n * | `constraintDateField`         | {@link Core/widget/DateField}                    | 700    | Shows a date for the selected constraint type                                                                                |\n * | `rollupField`                 | {@link Core/widget/Checkbox}                     | 800    | If checked, shows a bar below the parent task. Works when the \"Rollup\" feature is enabled.                                   |\n * | `inactiveField`               | {@link Core/widget/Checkbox}                     | 900    | Allows to inactivate the task so it won't take part in the scheduling process.                                               |\n * | `ignoreResourceCalendarField` | {@link Core/widget/Checkbox}                     | 1000   | If checked the task ignores the assigned resource calendars when scheduling                                                  |\n *\n * @extends SchedulerPro/widget/taskeditor/FormTab\n * @classtype advancedtab\n */\nexport default class AdvancedTab extends FormTab {\n\n    static get $name() {\n        return 'AdvancedTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'advancedtab';\n    }\n\n    static get defaultConfig() {\n        const\n            col1 = {\n                flex       : '0 0 64%',\n                labelWidth : '30%',\n                cls        : 'b-inline'\n            },\n            col2 = {\n                flex       : '0 0 34%',\n                labelWidth : '80%'\n            };\n\n        return {\n            localeClass : this,\n            title       : 'L{Advanced}',\n            cls         : 'b-advanced-tab',\n\n            defaults : {\n                localeClass : this\n            },\n\n            items : {\n                calendarField : {\n                    type   : 'calendarfield',\n                    weight : 100,\n                    ref    : '',\n                    name   : 'calendar',\n                    label  : 'L{Calendar}',\n                    ...col1\n                },\n                ignoreResourceCalendarField : {\n                    type   : 'checkbox',\n                    weight : 100,\n                    name   : 'ignoreResourceCalendar',\n                    label  : 'L{Ignore resource calendar}',\n                    cls    : 'b-ignore-resource-calendar',\n                    ...col2\n                },\n                schedulingModeField : {\n                    type   : 'schedulingmodecombo',\n                    weight : 300,\n                    name   : 'schedulingMode',\n                    label  : 'L{Scheduling mode}',\n                    ...col1\n                },\n                effortDrivenField : {\n                    type   : 'checkbox',\n                    weight : 400,\n                    name   : 'effortDriven',\n                    label  : 'L{Effort driven}',\n                    ...col2\n                },\n                divider : {\n                    weight  : 500,\n                    html    : '',\n                    dataset : {\n                        text : this.L('L{Constraint}')\n                    },\n                    cls  : 'b-divider',\n                    flex : '1 0 100%'\n                },\n                constraintTypeField : {\n                    type      : 'constrainttypepicker',\n                    weight    : 600,\n                    name      : 'constraintType',\n                    label     : 'L{Constraint type}',\n                    clearable : true,\n                    ...col1\n                },\n                rollupField : {\n                    type   : 'checkbox',\n                    weight : 700,\n                    name   : 'rollup',\n                    label  : 'L{Rollup}',\n                    ...col2\n                },\n                constraintDateField : {\n                    type     : 'date',\n                    weight   : 800,\n                    name     : 'constraintDate',\n                    label    : 'L{Constraint date}',\n                    keepTime : 'entered',\n                    ...col1\n                },\n                inactiveField : {\n                    type   : 'checkbox',\n                    weight : 900,\n                    name   : 'inactive',\n                    label  : 'L{Inactive}',\n                    ...col2\n                },\n                manuallyScheduledField : {\n                    type   : 'checkbox',\n                    weight : 1000,\n                    name   : 'manuallyScheduled',\n                    label  : 'L{Manually scheduled}',\n                    cls    : 'b-last-row',\n                    style  : 'margin-left:auto',\n                    ...col2\n                }\n            }\n        };\n    }\n\n    get calendarField() {\n        return this.widgetMap.calendarField;\n    }\n\n    get constraintTypeField() {\n        return this.widgetMap.constraintTypeField;\n    }\n\n    get constraintDateField() {\n        return this.widgetMap.constraintDateField;\n    }\n\n    get effortDrivenField() {\n        return this.widgetMap.effortDrivenField;\n    }\n\n    get manuallyScheduledField() {\n        return this.widgetMap.manuallyScheduledField;\n    }\n\n    get rollupField() {\n        return this.widgetMap.rollupField;\n    }\n\n    get schedulingModeField() {\n        return this.widgetMap.schedulingModeField;\n    }\n\n    loadEvent(eventRecord) {\n        const\n            me                       = this,\n            {\n                calendarField,\n                constraintTypeField\n            }                        = me,\n            { calendarManagerStore } = eventRecord.project,\n            storeChange              = calendarField?.store !== calendarManagerStore;\n\n        if (calendarField && storeChange) {\n            // Ensure also child calendars of collapsed parents are visible in the Combo list\n            calendarField.store = calendarManagerStore.chain(undefined, undefined, { excludeCollapsedRecords : false });\n        }\n\n        if (constraintTypeField?.isConstraintTypePicker) {\n            const { store : typesStore } = constraintTypeField;\n\n            typesStore.removeFilter('constraintTypeApplicable');\n            typesStore.filter({\n                id       : 'constraintTypeApplicable', // no-sanity\n                filterBy : r => eventRecord.run('isConstraintTypeApplicable', r.id)\n            });\n        }\n\n        //<debug>\n        console.assert(\n            storeChange || !me.record || me.project === eventRecord.project,\n            'Loading of a record from another project is not currently supported!'\n        );\n        //</debug>\n\n        super.loadEvent(eventRecord);\n    }\n\n    afterDelete() {\n        const { constraintTypeField } = this;\n\n        // remove the constraint type combo store filter\n        // otherwise eventRecord.run(...) will cause an exception since the record is no longer in the graph\n        if (constraintTypeField?.isConstraintTypePicker) {\n            constraintTypeField.store.removeFilter('constraintTypeApplicable');\n        }\n\n        super.afterDelete(...arguments);\n    }\n}\n\n// Register this widget type with its Factory\nAdvancedTab.initClass();\n", "import FormTab from './FormTab.js';\nimport '../../../Core/widget/TextAreaField.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/NotesTab\n */\n\n/**\n * A tab inside the {@link SchedulerPro/widget/SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro/widget/GanttTaskEditor gantt task editor} showing the notes for an event or task.\n *\n * | Field ref   | Type                              | Weight | Description                                                                               |\n * |-------------|-----------------------------------|--------|-------------------------------------------------------------------------------------------|\n * | `noteField` | {@link Core/widget/TextField}     | 100    | Shows a text field widget with a textarea as input element, to add text notes to the task |\n *\n * @extends SchedulerPro/widget/taskeditor/FormTab\n * @classtype notestab\n */\nexport default class NotesTab extends FormTab {\n\n    static get $name() {\n        return 'NotesTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'notestab';\n    }\n\n    static get configurable() {\n        return {\n            cls   : 'b-notes-tab',\n            title : this.L('L{Notes}'),\n\n            tab : {\n                icon          : 'b-icon-note',\n                titleProperty : 'tooltip'\n            },\n\n            layoutConfig : {\n                alignItems   : 'flex-start',\n                alignContent : 'stretch'\n            },\n\n            items : {\n                noteField : {\n                    weight          : 100,\n                    type            : 'textfield',\n                    inputAttributes : {\n                        tag : 'textarea'\n                    },\n                    cls  : 'b-taskeditor-notes-field',\n                    name : 'note'\n                }\n            }\n        };\n    }\n}\n\n// Register this widget type with its Factory\nNotesTab.initClass();\n", "/**\n * @module SchedulerPro/widget/GanttTaskEditor\n */\nimport TaskEditorBase from './TaskEditorBase.js';\nimport './taskeditor/GeneralTab.js';\nimport './taskeditor/SuccessorsTab.js';\nimport './taskeditor/PredecessorsTab.js';\nimport './taskeditor/ResourcesTab.js';\nimport './taskeditor/AdvancedTab.js';\nimport './taskeditor/NotesTab.js';\nimport '../../Core/widget/TabPanel.js';\n\n/**\n * A subclass of {@link SchedulerPro.widget.TaskEditorBase} for Gantt projects which SchedulerPro can handle as well.\n *\n * @extends SchedulerPro/widget/TaskEditorBase\n */\nexport default class GanttTaskEditor extends TaskEditorBase {\n    // Factoryable type name\n    static get type() {\n        return 'gantttaskeditor';\n    }\n\n    //region Config\n\n    static get $name() {\n        return 'GanttTaskEditor';\n    }\n\n    static get defaultConfig() {\n        return {\n            items : [\n                {\n                    type        : 'tabpanel',\n                    defaultType : 'formtab',\n                    ref         : 'tabs',\n                    flex        : '1 0 100%',\n                    autoHeight  : true,\n\n                    layoutConfig : {\n                        alignItems   : 'stretch',\n                        alignContent : 'stretch'\n                    },\n\n                    // In case views on small devices maximized and it still needs scrolling\n                    defaults : {\n                        scrollable : {\n                            overflowY : true\n                        }\n                    },\n\n                    items : {\n                        generalTab : {\n                            type   : 'generaltab',\n                            weight : 100\n                        },\n                        predecessorsTab : {\n                            type   : 'predecessorstab',\n                            weight : 200\n                        },\n                        successorsTab : {\n                            type   : 'successorstab',\n                            weight : 300\n                        },\n                        resourcesTab : {\n                            type   : 'resourcestab',\n                            weight : 400\n                        },\n                        advancedTab : {\n                            type   : 'advancedtab',\n                            weight : 500\n                        },\n                        notesTab : {\n                            type   : 'notestab',\n                            weight : 600\n                        }\n                    }\n                }\n            ]\n        };\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nGanttTaskEditor.initClass();\n", "import FormTab from './FormTab.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport '../CalendarField.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../../../Core/widget/DateTimeField.js';\nimport '../StartDateField.js';\nimport '../EndDateField.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/SchedulerGeneralTab\n */\n\n/**\n * A tab inside the {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} showing the general\n * information for an event from a simplified scheduler project.\n *\n * Contains the following fields by default:\n *\n * | Field ref          | Type                                    | Text       | Weight | Description                                                         |\n * |--------------------|-----------------------------------------|------------|--------|---------------------------------------------------------------------|\n * | `nameField`        | {@link Core.widget.TextField}           | Name       | 100    | Task name                                                           |\n * | `resourcesField`   | {@link Core.widget.Combo}               | Resources  | 200    | Shows a list of available resources for this task                   |\n * | `startDateField`   | {@link Core.widget.DateTimeField}       | Start      | 300    | Shows when the task begins                                          |\n * | `endDateField`     | {@link Core.widget.DateTimeField}       | Finish     | 400    | Shows when the task ends                                            |\n * | `durationField`    | {@link Core.widget.DurationField}       | Duration   | 500    | Shows how long the task is                                          |\n * | `percentDoneField` | {@link Core.widget.NumberField}         | % Complete | 600    | Shows what part of task is done already in percentage               |\n * | `effort`           | {@link SchedulerPro.widget.EffortField} | Effort     | 620    | Shows how much working time is required to complete the whole event |\n * | `preambleField`    | {@link Core.widget.DurationField}       | Preamble   | 650    | Shows preamble time (task preparation time)                         |\n * | `postambleField`   | {@link Core.widget.DurationField}       | Postamble  | 660    | Shows postamble time (clean up after the task)                      |\n *\n * To customize the tab or its fields:\n *\n * ```javascript\n * features : {\n *     taskEdit : {\n *         items : {\n *             generalTab : {\n *                 // Custom title\n *                 title: 'Common',\n *                 // Customized items\n *                 items : {\n *                     // Hide the duration field\n *                     durationField : null,\n *                     // Customize the name field\n *                     nameField : {\n *                         label : 'Title'\n *                     },\n *                     // Add a custom field\n *                     colorField : {\n *                         type   : 'text',\n *                         label  : 'Color',\n *                         // name maps to a field on the event record\n *                         name   : 'eventColor',\n *                         // place at top\n *                         weight : 0\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * @extends SchedulerPro/widget/taskeditor/FormTab\n * @classtype schedulergeneraltab\n */\nexport default class SchedulerGeneralTab extends FormTab {\n    static get $name() {\n        return 'SchedulerGeneralTab';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'schedulergeneraltab';\n    }\n\n    static get defaultConfig() {\n        return {\n            title : 'L{General}',\n            cls   : 'b-general-tab',\n\n            defaults : {\n                localeClass : this,\n                // New fields at the end\n                weight      : 10\n            },\n\n            items : {\n                nameField : {\n                    type      : 'text',\n                    required  : true,\n                    label     : 'L{Name}',\n                    clearable : true,\n                    name      : 'name',\n                    cls       : 'b-name',\n                    weight    : 100\n                },\n                // <remove-on-release>\n                // TODO: Prevent removing last, or prevent event from being removed while editing\n                // </remove-on-release>\n                resourcesField : {\n                    type                    : 'combo',\n                    label                   : 'L{Resources}',\n                    name                    : 'resources',\n                    editable                : true,\n                    valueField              : 'id',\n                    displayField            : 'name',\n                    highlightExternalChange : false,\n                    cls                     : 'b-resources',\n                    weight                  : 200\n                },\n                startDateField : {\n                    type      : 'datetime',\n                    label     : 'L{Start}',\n                    name      : 'startDate',\n                    cls       : 'b-start-date',\n                    flex      : '1 0 100%',\n                    weight    : 300,\n                    dateField : {\n                        type : 'startdatefield'\n                    }\n                },\n                endDateField : {\n                    type      : 'datetime',\n                    label     : 'L{Finish}',\n                    name      : 'endDate',\n                    cls       : 'b-end-date',\n                    flex      : '1 0 100%',\n                    weight    : 400,\n                    dateField : {\n                        type : 'enddatefield'\n                    }\n                },\n                durationField : {\n                    type   : 'durationfield',\n                    label  : 'L{Duration}',\n                    name   : 'fullDuration',\n                    flex   : '1 0 50%',\n                    cls    : 'b-inline',\n                    min    : 0,\n                    weight : 500\n                },\n                percentDoneField : {\n                    type   : 'number',\n                    label  : 'L{% complete}',\n                    name   : 'renderedPercentDone',\n                    flex   : '1 0 50%',\n                    min    : 0,\n                    max    : 100,\n                    weight : 600\n                },\n                effortField : {\n                    type   : 'durationfield',\n                    label  : 'L{Effort}',\n                    name   : 'fullEffort',\n                    weight : 620\n                },\n                preambleField : {\n                    type            : 'durationfield',\n                    hidden          : true,\n                    useAbbreviation : true,\n                    weight          : 650,\n                    label           : 'L{SchedulerGeneralTab.Preamble}',\n                    name            : 'preamble',\n                    flex            : '1 0 50%',\n                    cls             : 'b-inline'\n                },\n                postambleField : {\n                    type            : 'durationfield',\n                    hidden          : true,\n                    useAbbreviation : true,\n                    weight          : 660,\n                    label           : 'L{SchedulerGeneralTab.Postamble}',\n                    name            : 'postamble',\n                    flex            : '1 0 50%'\n                }\n            }\n        };\n    }\n\n    loadEvent(record) {\n        const\n            me                    = this,\n            { project }           = me,\n            step                  = {\n                unit      : record.durationUnit,\n                magnitude : 1\n            },\n            { isParent } = record,\n            {\n                durationField,\n                percentDoneField,\n                startDateField,\n                endDateField,\n                resourcesField\n            }                     = me.widgetMap,\n            storeChange           = resourcesField?.store.masterStore !== project.resourceStore;\n\n        //<debug>\n        console.assert(\n            !record.project || record.project === project,\n            'Loading of a record from another project is not supported!'\n        );\n        //</debug>\n\n        // Editing duration, percentDone & endDate disallowed for parent tasks\n        if (durationField) {\n            durationField.disabled = isParent;\n\n            if (!percentDoneField) {\n                durationField.element.classList.remove('b-inline');\n            }\n        }\n\n        if (percentDoneField) {\n            percentDoneField.disabled = isParent;\n        }\n\n        if (startDateField) {\n            startDateField.dateField.eventRecord = record;\n            if (DateHelper.compareUnits(step.unit, 'hour') > 0) {\n                startDateField.dateField.step = step;\n            }\n            else {\n                startDateField.timeField.step = step;\n            }\n        }\n\n        if (endDateField) {\n            endDateField.dateField.eventRecord = record;\n            if (DateHelper.compareUnits(step.unit, 'hour') > 0) {\n                endDateField.dateField.step = step;\n            }\n            else {\n                endDateField.timeField.step = step;\n            }\n            endDateField.disabled = isParent;\n        }\n\n        if (resourcesField) {\n            resourcesField.multiSelect = resourcesField.config.multiSelect ?? !project.eventStore.usesSingleAssignment;\n\n            // <remove-on-release>\n            // TODO: here we should set label based on multiSelect value\n            // https://github.com/bryntum/support/issues/1528\n            // </remove-on-release>\n\n            if (storeChange) {\n                // Can't use store directly since it may be grouped and then contains irrelevant group records\n                resourcesField.store = project.resourceStore.chain(record => !record.isSpecialRow);\n            }\n        }\n\n        super.loadEvent(...arguments);\n    }\n\n    onFieldChange({ source, valid, userAction, value }) {\n        if (userAction && valid) {\n            const\n                { eventStore }     = this.record,\n                resourceUnassigned = source.name === 'resources' && value.length === 0 && this.autoUpdateRecord && eventStore.removeUnassignedEvent;\n\n            if (resourceUnassigned) {\n                // Do not remove unassigned event if all resources are removed, we will do it after\n                eventStore.removeUnassignedEvent = false;\n            }\n            super.onFieldChange(...arguments);\n\n            if (resourceUnassigned) {\n                eventStore.removeUnassignedEvent = true;\n            }\n        }\n    }\n\n    beforeSave() {\n        // We skipped removing event on field change, if resource is still empty before save - remove record\n        if (this.record.resources.length === 0 && this.record.eventStore.removeUnassignedEvent) {\n            this.record.remove();\n        }\n\n        super.beforeSave();\n    }\n}\n\n// Register this widget type with its Factory\nSchedulerGeneralTab.initClass();\n", "import EditorTab from './EditorTab.js';\nimport '../../../Scheduler/view/recurrence/RecurrenceEditorPanel.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/RecurrenceTab\n */\n\n/**\n * Tab for editing an events recurrence rule, only shown when Scheduler Pro is configured to use recurring events\n * (see {@link Scheduler/view/mixin/RecurringEvents#config-enableRecurringEvents}).\n *\n * Does not currently offer any customization options.\n *\n * @extends SchedulerPro/widget/taskeditor/EditorTab\n * @classtype recurrencetab\n */\nexport default class RecurrenceTab extends EditorTab {\n\n    static $name = 'RecurrenceTab';\n\n    static type = 'recurrencetab';\n\n    static configurable = {\n        title      : 'L{title}',\n        cls        : 'b-recurrence-tab',\n        scrollable : true,\n        items      : {\n            recurrenceEditor : {\n                type    : 'recurrenceeditorpanel',\n                addNone : true\n            }\n        }\n\n    };\n\n    get recurrenceEditor() {\n        return this.widgetMap.recurrenceEditor;\n    }\n\n    loadEvent(eventRecord) {\n        if (this.recurrenceEditor) {\n            this.loadingRecord = true;\n            this.recurrenceEditor.record = eventRecord.recurrence ?? null;\n            this.loadingRecord = false;\n        }\n\n        super.loadEvent(eventRecord);\n    }\n\n    onFieldChange({ source, value }) {\n        const me = this;\n\n        if (!me.isConfiguring && !me.recurrenceEditor.assigningValues && !me.loadingRecord) {\n            const { record } = me;\n\n            // Create a new recurrence if event wasn't recurring already\n            if (!record.recurrence) {\n                record.recurrence = new record.recurrenceModel({});\n            }\n            else {\n                // Clear recurrence if picking 'NONE'\n                if (source === me.recurrenceEditor.widgetMap.frequencyField && value === 'NONE') {\n                    record.recurrence = null;\n                }\n                else {\n                    me.recurrenceEditor.syncEventRecord(record.recurrence);\n                }\n            }\n\n            me.up(w => w.isTaskEditorBase).editingRecurring = true;\n        }\n    }\n}\n\n// Register this widget type with its Factory\nRecurrenceTab.initClass();\n", "import FormTab from './FormTab.js';\nimport '../CalendarField.js';\nimport '../ConstraintTypePicker.js';\nimport '../../../Core/widget/DateField.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../SchedulingModePicker.js';\nimport { SchedulingMode } from '../../../Engine/scheduling/Types.js';\n\n/**\n * @module SchedulerPro/widget/taskeditor/SchedulerAdvancedTab\n */\n\n/**\n * Advanced task options for {@link SchedulerPro/widget/SchedulerTaskEditor scheduler task editor} or\n * {@link SchedulerPro/widget/GanttTaskEditor gantt task editor} tab.\n *\n * Contains the following fields by default (with their default weight):\n *\n * | Field ref                    | Type                                             | Weight | Description                                         |\n * |------------------------------|--------------------------------------------------|--------|-----------------------------------------------------|\n * | `calendarField`              | {@link SchedulerPro/widget/CalendarField}        | 100    | List of available calendars, if calendars are used  |\n * | `constraintTypeField`        | {@link SchedulerPro/widget/ConstraintTypePicker} | 200    | Shows a list of available constraints for this task |\n * | `constraintDateField`        | {@link Core/widget/DateField}                    | 300    | Shows a date for the selected constraint type       |\n * | `manuallyScheduledField`     | {@link Core/widget/Checkbox}                     | 400    | When checked, task is not considered in scheduling  |\n * | `schedulingModeField`        | {@link SchedulerPro/widget/SchedulingModePicker} | 450    | Shows a list of available scheduling modes for this event                     |\n * | `effortDrivenField`          | {@link Core/widget/Checkbox}                     | 460    | If checked, the effort of the event is kept intact when duration is provided. Works when scheduling mode is \"Fixed Duration\". |\n * | `inactiveField`              | {@link Core/widget/Checkbox}                     | 500    | Allows inactivating the task so it won't take part in the scheduling process. |\n * | `ignoreResourceCalendarField | {@link Core/widget/Checkbox}                     | 600    | If checked the event ignores the assigned resource calendars when scheduling |\n *\n * @extends SchedulerPro/widget/taskeditor/FormTab\n * @classtype scheduleradvancedtab\n */\nexport default class SchedulerAdvancedTab extends FormTab {\n\n    static get $name() {\n        return 'SchedulerAdvancedTab';\n    }\n\n    static get type() {\n        return 'scheduleradvancedtab';\n    }\n\n    static get configurable() {\n        return {\n            cls : 'b-advanced-tab',\n\n            tab : {\n                icon    : 'b-icon-advanced',\n                tooltip : 'L{SchedulerAdvancedTab.Advanced}'\n            },\n\n            defaults : {\n                localeClass : this\n            },\n\n            items : {\n                calendarField : {\n                    type   : 'calendarfield',\n                    name   : 'calendar',\n                    label  : 'L{Calendar}',\n                    weight : 100\n                },\n                constraintTypeField : {\n                    type      : 'constrainttypepicker',\n                    name      : 'constraintType',\n                    label     : 'L{Constraint type}',\n                    clearable : true,\n                    weight    : 200\n                },\n                constraintDateField : {\n                    type     : 'date',\n                    name     : 'constraintDate',\n                    label    : 'L{Constraint date}',\n                    keepTime : 'entered',\n                    weight   : 300\n                },\n                manuallyScheduledField : {\n                    type   : 'checkbox',\n                    name   : 'manuallyScheduled',\n                    label  : 'L{Manually scheduled}',\n                    weight : 400\n                },\n                schedulingModeField : {\n                    type         : 'schedulingmodecombo',\n                    name         : 'schedulingMode',\n                    label        : 'L{Scheduling mode}',\n                    hidden       : true,\n                    weight       : 450,\n                    allowedModes : `${SchedulingMode.Normal},${SchedulingMode.FixedDuration}`\n                },\n                effortDrivenField : {\n                    type   : 'checkbox',\n                    weight : 460,\n                    name   : 'effortDriven',\n                    label  : 'L{Effort driven}',\n                    hidden : true,\n                    flex   : '1 0 50%'\n                },\n                inactiveField : {\n                    type   : 'checkbox',\n                    weight : 500,\n                    name   : 'inactive',\n                    label  : 'L{Inactive}'\n                },\n                ignoreResourceCalendarField : {\n                    type   : 'checkbox',\n                    weight : 600,\n                    name   : 'ignoreResourceCalendar',\n                    label  : 'L{Ignore resource calendar}',\n                    flex   : '1 0 50%'\n                }\n            }\n        };\n    }\n\n    get calendarField() {\n        return this.widgetMap.calendarField;\n    }\n\n    get constraintTypeField() {\n        return this.widgetMap.constraintTypeField;\n    }\n\n    get constraintDateField() {\n        return this.widgetMap.constraintDateField;\n    }\n\n    get effortDrivenField() {\n        return this.widgetMap.effortDrivenField;\n    }\n\n    get manuallyScheduledField() {\n        return this.widgetMap.manuallyScheduledField;\n    }\n\n    get schedulingModeField() {\n        return this.widgetMap.schedulingModeField;\n    }\n\n    loadEvent(eventRecord) {\n        const\n            me                = this,\n            { project }       = me,\n            firstLoad         = !me.record,\n            { calendarField } = me;\n\n        //<debug>\n        console.assert(\n            firstLoad || me.project === eventRecord.project,\n            'Loading of a record from another project is not currently supported!'\n        );\n        //</debug>\n\n        if (calendarField) {\n            calendarField.store = project.calendarManagerStore;\n            calendarField.hidden = !project.calendarManagerStore.count;\n        }\n\n        super.loadEvent(...arguments);\n    }\n}\n\nSchedulerAdvancedTab.initClass();\n", "/**\n * @module SchedulerPro/widget/SchedulerTaskEditor\n */\nimport TaskEditorBase from './TaskEditorBase.js';\nimport './taskeditor/SchedulerGeneralTab.js';\nimport './taskeditor/SuccessorsTab.js';\nimport './taskeditor/PredecessorsTab.js';\nimport './taskeditor/RecurrenceTab.js';\nimport './taskeditor/ResourcesTab.js';\nimport './taskeditor/SchedulerAdvancedTab.js';\nimport './taskeditor/NotesTab.js';\n\nconst bufferRe = /(pre|post)amble/;\n\n/**\n * {@link SchedulerPro/widget/TaskEditorBase} subclass for SchedulerPro projects. Provides a UI to edit tasks in a\n * dialog.\n *\n * This demo shows how to use TaskEditor as a standalone widget:\n *\n * {@inlineexample SchedulerPro/widget/SchedulerTaskEditor.js}\n *\n * ## Task editor customization\n *\n * To append Widgets to any of the built-in tabs, use the `items` config. The Task editor contains tabs by default.\n * Each tab contains built in widgets: text fields, grids, etc.\n *\n * | Tab ref           | Text                                                        | Weight | Description                                                                          |\n * |-------------------|-------------------------------------------------------------|--------|--------------------------------------------------------------------------------------|\n * | `generalTab`      | {@link SchedulerPro/widget/taskeditor/SchedulerGeneralTab}  | 100    | Shows basic configuration: name, resources, start/end dates, duration, percent done  |\n * | `recurrenceTab`   | {@link SchedulerPro/widget/taskeditor/RecurrenceTab}        | 150    | Options for recurring events, when Scheduler is configured to use them               |\n * | `predecessorsTab` | {@link SchedulerPro/widget/taskeditor/PredecessorsTab}      | 200    | Shows a grid with incoming dependencies                                              |\n * | `successorsTab`   | {@link SchedulerPro/widget/taskeditor/SuccessorsTab}        | 300    | Shows a grid with outgoing dependencies                                              |\n * | `advancedTab`     | {@link SchedulerPro/widget/taskeditor/SchedulerAdvancedTab} | 500    | Shows advanced configuration: constraints and manual scheduling mode                 |\n * | `notesTab`        | {@link SchedulerPro/widget/taskeditor/NotesTab}             | 600    | Shows a text area to add notes to the selected task                                  |\n *\n * This demo shows adding of custom widgets to the task editor, double-click child task bar to start editing:\n *\n * {@inlineexample SchedulerPro/feature/TaskEditExtraItems.js}\n *\n * @extends SchedulerPro/widget/TaskEditorBase\n */\nexport default class SchedulerTaskEditor extends TaskEditorBase {\n    // Factoryable type name\n    static get type() {\n        return 'schedulertaskeditor';\n    }\n\n    //region Config\n\n    static get $name() {\n        return 'SchedulerTaskEditor';\n    }\n\n    static get defaultConfig() {\n        return {\n            enableEventSpanBuffer : false,\n\n            items : [\n                {\n                    type        : 'tabpanel',\n                    defaultType : 'formtab',\n                    ref         : 'tabs',\n                    flex        : '1 0 100%',\n                    autoHeight  : true,\n\n                    layoutConfig : {\n                        alignItems   : 'stretch',\n                        alignContent : 'stretch'\n                    },\n\n                    // In case views on small devices maximized and it still needs scrolling\n                    defaults : {\n                        scrollable : {\n                            overflowY : true\n                        }\n                    },\n\n                    items : {\n                        generalTab : {\n                            type   : 'schedulergeneraltab',\n                            weight : 100\n                        },\n                        recurrenceTab : {\n                            type   : 'recurrencetab',\n                            weight : 150\n                        },\n                        predecessorsTab : {\n                            type   : 'predecessorstab',\n                            weight : 200\n                        },\n                        successorsTab : {\n                            type   : 'successorstab',\n                            weight : 300\n                        },\n                        // Replaced with combo on general tab\n                        //{ type : 'resourcestab', weight : 400 },\n                        advancedTab : {\n                            type   : 'scheduleradvancedtab',\n                            weight : 500\n                        },\n                        notesTab : {\n                            type   : 'notestab',\n                            weight : 600\n                        }\n                    }\n                }\n            ]\n        };\n    }\n\n    processWidgetConfig(widgetConfig) {\n        if (widgetConfig.ref?.match(bufferRe)) {\n            widgetConfig.hidden = !this.enableEventSpanBuffer;\n        }\n\n        if (widgetConfig.ref === 'recurrenceTab') {\n            widgetConfig.hidden = !this.owner?.enableRecurringEvents;\n        }\n\n        return super.processWidgetConfig(widgetConfig);\n    }\n\n    onFocusOut({ relatedTarget }) {\n        const eventRecord = relatedTarget?.closest('.b-sch-event-wrap')?.elementData.eventRecord;\n\n        if (eventRecord && eventRecord === this.loadedRecord) {\n            // Move focus back into the editor, setTimeout to avoid infinite focus bouncing\n            this.setTimeout(() => this.focus(), 100);\n        }\n        else {\n            return super.onFocusOut(...arguments);\n        }\n    }\n\n    //endregion\n\n}\n\n// Register this widget type with its Factory\nSchedulerTaskEditor.initClass();\n", "import Delayable from '../../Core/mixin/Delayable.js';\nimport TaskEditStm from '../../Scheduler/feature/mixin/TaskEditStm.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport MessageDialog from '../../Core/widget/MessageDialog.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport '../widget/GanttTaskEditor.js';\nimport '../widget/SchedulerTaskEditor.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport { ProjectType } from '../../Engine/scheduling/Types.js';\n\n/**\n * @module SchedulerPro/feature/TaskEdit\n */\n\n/**\n * Feature that displays a {@link SchedulerPro.widget.SchedulerTaskEditor Task editor}, allowing users to edit task data.\n * The Task editor is a popup containing tabs with fields for editing task data.\n *\n * This demo shows the task edit feature, double-click child task bar to start editing:\n *\n * {@inlineexample SchedulerPro/feature/TaskEdit.js}\n *\n * ## Customizing tabs and their widgets\n *\n * To customize tabs you can:\n *\n * * Reconfigure built in tabs by providing override configs in the {@link #config-items} config.\n * * Remove existing tabs or add your own in the {@link #config-items} config.\n * * Advanced: Reconfigure the whole editor widget using {@link #config-editorConfig} or replace the whole editor using\n *   {@link #config-editorClass}.\n *\n * To add extra items to a tab you need to specify {@link Core.widget.Container#config-items} for the tab container.\n *\n * This demo shows adding of custom widgets to the task editor, double-click child task bar to start editing:\n *\n * {@inlineexample SchedulerPro/feature/TaskEditExtraItems.js}\n *\n * {@region Expand to see Default tabs and fields}\n *\n * The {@link SchedulerPro.widget.SchedulerTaskEditor Task editor} contains tabs by default. Each tab contains built in\n * widgets: text fields, grids, etc.\n *\n * | Tab ref           | Type                                                        | Text         | Weight | Description                                                            |\n * |-------------------|-------------------------------------------------------------|--------------|--------|------------------------------------------------------------------------|\n * | `generalTab`      | {@link SchedulerPro.widget.taskeditor.SchedulerGeneralTab}  | General      | 100    | Basic fields: name, resources, start/end dates, duration, percent done |\n * | `predecessorsTab` | {@link SchedulerPro.widget.taskeditor.PredecessorsTab}      | Predecessors | 200    | Shows a grid with incoming dependencies                                |\n * | `successorsTab`   | {@link SchedulerPro.widget.taskeditor.SuccessorsTab}        | Successors   | 300    | Shows a grid with outgoing dependencies                                |\n * | `advancedTab`     | {@link SchedulerPro.widget.taskeditor.SchedulerAdvancedTab} | Advanced     | 500    | Shows advanced configuration: constraints and manual scheduling mode   |\n * | `notesTab`        | {@link SchedulerPro.widget.taskeditor.NotesTab}             | Notes        | 600    | Shows a text area to add notes to the selected task                    |\n *\n * ### General tab\n *\n * General tab contains fields for basic configurations\n *\n * | Field ref          | Type                              | Text       | Weight | Description                                           |\n * |--------------------|-----------------------------------|------------|--------|-------------------------------------------------------|\n * | `nameField`        | {@link Core.widget.TextField}     | Name       | 100    | Task name                                             |\n * | `resourcesField`   | {@link Core.widget.Combo}         | Resources  | 200    | Shows a list of available resources for this task     |\n * | `startDateField`   | {@link Core.widget.DateTimeField} | Start      | 300    | Shows when the task begins                            |\n * | `endDateField`     | {@link Core.widget.DateTimeField} | Finish     | 400    | Shows when the task ends                              |\n * | `durationField`    | {@link Core.widget.DurationField} | Duration   | 500    | Shows how long the task is                            |\n * | `percentDoneField` | {@link Core.widget.NumberField}   | % Complete | 600    | Shows what part of task is done already in percentage |\n *\n * ### Predecessors tab\n *\n * Predecessors tab contains a grid with incoming dependencies and controls to remove/add dependencies\n *\n * | Widget ref | Type                        | Weight | Description                                                                        |\n * |------------|-----------------------------|--------|------------------------------------------------------------------------------------|\n * | `grid`     | {@link Grid.view.Grid}      | 100    | Shows predecessors task name, dependency type and lag                              |\n * | `toolbar`  | {@link Core.widget.Toolbar} | 200    | Shows control buttons                                                              |\n * | \\>`add`    | {@link Core.widget.Button}  | 210    | Adds a new predecessor. Then select a task from the list in the name column editor |\n * | \\>`remove` | {@link Core.widget.Button}  | 220    | Removes selected incoming dependency                                               |\n *\n * \\> - nested items\n *\n * ### Successors tab\n *\n * Successors tab contains a grid with outgoing dependencies and controls to remove/add dependencies\n *\n * | Widget ref | Type                        | Weight | Description                                                                      |\n * |------------|-----------------------------|--------|----------------------------------------------------------------------------------|\n * | `grid`     | {@link Grid.view.Grid}      | 100    | Shows successors task name, dependency type and lag                              |\n * | `toolbar`  | {@link Core.widget.Toolbar} | 200    | Shows control buttons                                                            |\n * | \\>`add`    | {@link Core.widget.Button}  | 210    | Adds a new successor. Then select a task from the list in the name column editor |\n * | \\>`remove` | {@link Core.widget.Button}  | 220    | Removes selected outgoing dependency                                             |\n *\n * \\> - nested items\n *\n * ### Advanced tab\n *\n * Advanced tab contains additional task scheduling options\n *\n * | Field ref                     | Type                                             | Weight | Description                                                                    |\n * |-------------------------------|--------------------------------------------------|--------|--------------------------------------------------------------------------------|\n * | `calendarField`               | {@link SchedulerPro.widget.CalendarField}        | 100    | List of available calendars for this task. Shown when calendars are downloaded |\n * | `constraintTypeField`         | {@link SchedulerPro.widget.ConstraintTypePicker} | 200    | Shows a list of available constraints for this task                            |\n * | `constraintDateField`         | {@link Core.widget.DateField}                    | 300    | Shows a date for the selected constraint type                                  |\n * | `manuallyScheduledField`      | {@link Core.widget.Checkbox}                     | 400    | If checked, the task is not considered in scheduling                           |\n * | `inactiveField`               | {@link Core.widget.Checkbox}                     | 500    | Allows inactivating the task so it won't take part in the scheduling process.  |\n * | `ignoreResourceCalendarField` | {@link Core.widget.Checkbox}                     | 600    | If checked the event ignores the assigned resource calendars when scheduling   |\n *\n * ### Notes tab\n *\n * Notes tab contains a text area to show notes\n *\n * | Field ref   | Type                              | Weight | Description                                     |\n * |-------------|-----------------------------------|--------|-------------------------------------------------|\n * | `noteField` | {@link Core.widget.TextAreaField} | 100    | Shows a text area to add text notes to the task |\n *\n * The built in buttons are:\n *\n * | Widget ref             | Type                        | Weight | Description                                                    |\n * |------------------------|-----------------------------|--------|----------------------------------------------------------------|\n * | `saveButton`           | {@link Core.widget.Button}  | 100    | Save event button on the bbar                                  |\n * | `deleteButton`         | {@link Core.widget.Button}  | 200    | Delete event button on the bbar                                |\n * | `cancelButton`         | {@link Core.widget.Button}  | 300    | Cancel event editing button on the bbar                        |\n *\n * {@endregion}\n *\n * ## Removing a built in item or toolbar button\n *\n * To remove a built in toolbar button, tab or field, specify its `ref` as `false` in the `items` config:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     features : {\n *         taskEdit : {\n *             items : {\n *                 generalTab      : {\n *                     items : {\n *                         // Remove \"Duration\" and \"% Complete\" fields in the \"General\" tab\n *                         durationField    : false,\n *                         percentDoneField : false\n *                     }\n *                 },\n *                 // Remove all tabs except the \"General\" tab\n *                 notesTab        : false,\n *                 predecessorsTab : false,\n *                 successorsTab   : false,\n *                 advancedTab     : false\n *             },\n *             editorConfig : {\n *                 bbar : {\n *                     // Remove delete button\n *                     items : {\n *                         deleteButton : false\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * ## Customizing a built in item\n *\n * To customize a built in tab or field, use its `ref` as the key in the `items` config and specify the configs you want\n * to change (they will be merged with the tabs or fields default configs correspondingly):\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     features : {\n *         taskEdit : {\n *             items : {\n *                 generalTab      : {\n *                     // Rename \"General\" tab\n *                     title : 'Main',\n *                     items : {\n *                         // Rename \"% Complete\" field\n *                         percentDoneField : {\n *                             label : 'Status'\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * ## Adding a custom item\n *\n * To add a custom tab or field, add an entry to the `items` config. When you add a field,\n * the `name` property links the input field to a field in the loaded task record:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     features : {\n *         taskEdit : {\n *             items : {\n *                 generalTab : {\n *                     items : {\n *                         // Add new field to the last position\n *                         newGeneralField : {\n *                             type   : 'textfield',\n *                             weight : 610,\n *                             label  : 'New field in General Tab',\n *                             // Name of the field matches data field name, so value is loaded/saved automatically\n *                             name   : 'custom'\n *                         }\n *                     }\n *                 },\n *                 // Add a custom tab to the first position\n *                 newTab     : {\n *                     // Tab is a FormTab by default\n *                     title  : 'New tab',\n *                     weight : 90,\n *                     items  : {\n *                         newTabField : {\n *                             type   : 'textfield',\n *                             weight : 10,\n *                             label  : 'New field in New Tab',\n *                             // Name of the field matches data field name, so value is loaded/saved automatically.\n *                             // In this case it is equal to the Task \"name\" field.\n *                             name   : 'name'\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * To turn off the Task Editor just simple disable the feature.\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     features : {\n *         taskEdit : false\n *     }\n * })\n * ```\n *\n * By default predecessors and successors in successorsTab and predecessorsTab are displayed using task id and a name.\n *  The id part is configurable, any task field may be used instead (for example wbsCode or sequence number)\n * by Gantt `dependencyIdField` property, to set it globally, or using\n *  taskEdit config {@link SchedulerPro/widget/TaskEditorBase#config-dependencyIdField} to set format only for taskEditor.\n * ```javascript\n * const gantt = new Gantt({\n *    dependencyIdField: 'wbsCode', // for global format\n *\n *    project,\n *    columns : [\n *        { type : 'name', width : 250 }\n *    ],\n *    features : {\n *         taskEdit : {\n *             editorConfig : {\n *                 dependencyIdField : 'wbsCode' // set only for taskEditor\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * For more info on customizing the Task Editor, please see Guides/Customization/Customize task editor\n *\n * ## Editing nested events\n *\n * Note that when editing nested events the resource field, the successors tab and the predecessors tab are hidden\n * automatically.\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Scheduler/feature/mixin/TaskEditStm\n * @mixes Core/mixin/Delayable\n * @demo SchedulerPro/taskeditor\n * @classtype taskEdit\n * @feature\n */\nexport default class TaskEdit extends InstancePlugin.mixin(\n    Delayable,\n    TaskEditStm\n) {\n\n    //region Events\n    /**\n     * Fires on the owning Scheduler instance before a task is displayed in the editor.\n     * This may be listened to in order to take over the task editing flow. Returning `false`\n     * stops the default editing UI from being shown.\n     *\n     * Allows async flows by awaiting async listeners. For example:\n     *\n     * ```javascript\n     * new SchedulerPro({\n     *     listeners : {\n     *         async beforeTaskEdit() {\n     *            await asyncCheckOfRightsOnBackend();\n     *         }\n     *     }\n     * });\n     * ```\n     * @event beforeTaskEdit\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.feature.TaskEdit} taskEdit The taskEdit feature\n     * @param {SchedulerPro.model.EventModel} taskRecord The task about to be shown in the editor.\n     * @param {HTMLElement} taskElement The element which represents the task\n     * @preventable\n     * @async\n     */\n\n    /**\n     * Fires on the owning Scheduler when the editor for an event is canceled.\n     * @event taskEditCanceled\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} taskRecord the task about the shown in the editor\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor\n     */\n\n    /**\n     * Fires on the owning Scheduler when the editor for an event is available but before it is shown. Allows\n     * manipulating fields etc.\n     * @event beforeTaskEditShow\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The SchedulerPro instance\n     * @param {SchedulerPro.feature.TaskEdit} taskEdit The taskEdit feature\n     * @param {SchedulerPro.model.EventModel} taskRecord The task about to be shown in the editor.\n     * @param {HTMLElement} eventElement The element which represents the task\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro instance before a task is saved, return `false` to prevent it.\n     *\n     * Allows async flows by awaiting async listeners. For example:\n     *\n     * ```javascript\n     * new SchedulerPro({\n     *     listeners : {\n     *         async beforeTaskSave() {\n     *            await someAsyncConditionLikeAskingForConfirmation();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeTaskSave\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} taskRecord The task about to be saved\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     * @preventable\n     * @async\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro instance after a task is saved\n     * @event afterTaskSave\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} taskRecord The task about to be saved\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro instance after task editing is finished by applying changes, cancelling them\n     * or deleting the task record.\n     * @event afterTaskEdit\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} taskRecord Task record used in the task editor\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro before a task is deleted, return `false` to prevent it.\n     *\n     * Allows async flows by awaiting async listeners. For example:\n     *\n     * ```javascript\n     * new SchedulerPro({\n     *     listeners : {\n     *         async beforeTaskDelete() {\n     *            await someAsyncConditionLikeAskingForConfirmation();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeTaskDelete\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance.\n     * @param {SchedulerPro.model.EventModel} taskRecord The record about to be deleted\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     * @preventable\n     * @async\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro instance before an event record is saved, return `false` to prevent it.\n     *\n     * Allows async flows by awaiting async listeners. For example:\n     *\n     * ```javascript\n     * new SchedulerPro({\n     *     listeners : {\n     *         async beforeEventSave() {\n     *            await someAsyncConditionLikeAskingForConfirmation();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeEventSave\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} eventRecord The event record about to be saved\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     * @preventable\n     * @async\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro instance after an event record is saved\n     * @event afterEventSave\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance\n     * @param {SchedulerPro.model.EventModel} eventRecord The event record about to be saved\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     */\n\n    /**\n     * Fires on the owning Scheduler Pro before an event record is deleted, return `false` to prevent it.\n     *\n     * Allows async flows by awaiting async listeners. For example:\n     *\n     * ```javascript\n     * new SchedulerPro({\n     *     listeners : {\n     *         async beforeEventDelete() {\n     *            await someAsyncConditionLikeAskingForConfirmation();\n     *         }\n     *     }\n     * });\n     * ```\n     * @event beforeEventDelete\n     * @on-owner\n     * @param {SchedulerPro.view.SchedulerPro} source The Scheduler Pro instance.\n     * @param {SchedulerPro.model.EventModel} eventRecord The event record about to be deleted\n     * @param {SchedulerPro.widget.TaskEditorBase} editor The editor widget\n     * @preventable\n     * @async\n     */\n    //endregion\n\n    //region Config\n\n    static get $name() {\n        return 'TaskEdit';\n    }\n\n    static get pluginConfig() {\n        return {\n            chain  : ['populateEventMenu', 'onEventEnterKey'],\n            assign : ['editEvent']\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to\n             * disable editing of existing events.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'eventdblclick',\n\n            /**\n             * Project type to editor class map. Editor will be used depending on project, not on product.\n             *\n             * @config {Object}\n             * @internal\n             * @category Editor\n             */\n            editorClassMap : {\n                [ProjectType.SchedulerBasic] : 'schedulertaskeditor',\n                [ProjectType.SchedulerPro]   : 'schedulertaskeditor',\n                [ProjectType.Gantt]          : 'gantttaskeditor'\n            },\n\n            // <remove-on-release>\n            // TODO: deprecate it in favor of `editorConfig : { type : 'xxx' }`\n            // </remove-on-release>\n            /**\n             * Class to use as the editor. By default it picks editor class depending on the project type.\n             * It can be either {@link SchedulerPro.widget.SchedulerTaskEditor} or\n             * {@link SchedulerPro.widget.GanttTaskEditor}.\n             * By specifying your own `editorClass` you override this.\n             * @config {Core.widget.Widget}\n             * @typings {typeof Widget}\n             * @category Editor\n             */\n            editorClass : null,\n\n            /**\n             * A configuration object applied to the internal {@link SchedulerPro.widget.TaskEditorBase TaskEditor}.\n             * Useful to for example change the title of the editor or to set its dimensions in code:\n             *\n             * ```javascript\n             * features : {\n             *     taskEdit : {\n             *         editorConfig : {\n             *             title : 'My title',\n             *             height : 300\n             *         }\n             *     }\n             * }\n             * ```\n             *\n             * NOTE: The easiest approach to affect editor contents is to use the {@link #config-items items config}.\n             *\n             *  @config {TaskEditorBaseConfig}\n             */\n            editorConfig : null,\n\n            /**\n             * True to show a confirmation dialog before deleting the event\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            confirmDelete : true,\n\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n\n            /**\n             * What action should be taken when you click outside the editor, `cancel` or `save`\n             * @config {'cancel'|'save'}\n             * @default\n             */\n            blurAction : 'cancel',\n\n            /**\n             * The week start day used in all date fields of the feature editor form by default.\n             * 0 means Sunday, 6 means Saturday.\n             * Defaults to the locale's week start day.\n             * @config {Number}\n             */\n            weekStartDay : null,\n\n            /**\n             * Set to false to not scroll event into view when invoking edit action (e.g. if event is only partially visible)\n             * @config {Boolean}\n             * @default\n             */\n            scrollIntoView : true\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * A configuration object used to customize the contents of the task editor. Supply a config object or\n             * boolean per tab (listed below) to either affects its contents or toggle it on/off.\n             *\n             * Supplied config objects will be merged with the tabs predefined configs.\n             *\n             * To remove existing items, set corresponding keys to `null`.\n             *\n             * Built-in tab names are:\n             *  * `generalTab`\n             *  * `predecessorsTab`\n             *  * `successorsTab`\n             *  * `advancedTab`\n             *  * `notesTab`\n             *\n             *  ```\n             *  features : {\n             *      taskEdit : {\n             *          items : {\n             *              // Custom settings and additional items for the general tab\n             *              generalTab : {\n             *                  title : 'Common',\n             *                  items : {\n             *                      durationField : false,\n             *                      myCustomField : {\n             *                          type : 'text',\n             *                          name : 'color'\n             *                      }\n             *                  }\n             *              },\n             *              // Hide the advanced tab\n             *              advancedTab : null\n             *          }\n             *      }\n             *  }\n             *  ```\n             *\n             *  Please see the `taskeditor` demo for a customized editor in action.\n             *  @config {Object}\n             */\n            items : null,\n\n            /**\n             * When field in task editor is changed, project model normally will trigger `hasChanges` event. If you use\n             * this event to handle project changes excessive events might be a problem. Set this flag to true to only\n             * trigger single `hasChanges` event after task changes are applied.\n             * @config {Boolean} suspendHasChangesEvent\n             * @default\n             */\n            suspendHasChangesEvent : false\n        };\n    }\n\n    //endregion\n\n    //region Constructor/Destructor\n\n    construct(scheduler, config) {\n        scheduler.taskEdit = this;\n\n        super.construct(scheduler, ObjectHelper.assign({\n            weekStartDay          : scheduler.weekStartDay,\n            enableEventSpanBuffer : scheduler.features.eventBuffer?.enabled\n        }, config));\n\n        scheduler.ion({\n            [this.triggerEvent] : 'onActivateEditor',\n            readOnly            : 'onClientReadOnlyToggle',\n            dragCreateEnd       : 'onDragCreateEnd',\n            afterEventDrop      : 'onEventDropped',\n            eventResizeEnd      : 'onEventResized',\n            thisObj             : this\n        });\n    }\n\n    doDestroy() {\n        this.detachFromProject();\n\n        this.editor?.destroy();\n\n        if (this.deleteConfirmationPromise) {\n            MessageDialog.hide();\n        }\n\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Internal\n\n    onClientReadOnlyToggle({ readOnly }) {\n        if (this.editor) {\n            this.editor.readOnly = readOnly;\n        }\n    }\n\n    get scheduler() {\n        return this.client;\n    }\n\n    getElementFromTaskRecord(taskRecord, resourceRecord) {\n        return this.client.getElementFromEventRecord(taskRecord, resourceRecord);\n    }\n\n    scrollEventIntoView(eventRecord, resourceRecord) {\n        this.client.scrollResourceEventIntoView(resourceRecord, eventRecord);\n    }\n\n    get isValid() {\n        return this.editor.eachWidget(widget => {\n            if (widget.isValid === true || widget.hidden || widget.disabled || (widget.isField && !widget.name)) {\n                return true;\n            }\n\n            return widget.isValid !== false;\n        }, true);\n    }\n\n    //endregion\n\n    //region Project\n\n    get project() {\n        return this.scheduler.project;\n    }\n\n    attachToProject() {\n        this.detachFromProject();\n\n        this.project.ion({\n            name      : 'project',\n            loadstart : () => this.save(),\n            dataReady : 'onDataReady',\n            thisObj   : this\n        });\n    }\n\n    detachFromProject() {\n        this.detachListeners('project');\n    }\n\n    //endregion\n\n    onDataReady() {\n        const { record } = this;\n\n        // Record could've been removed from project\n        if (record?.project && this.scheduler.taskStore.includes(record)) {\n            this.load(record, true);\n        }\n        else {\n            this.editor.close();\n        }\n    }\n\n    //region Editor\n\n    /**\n     * Returns true if the editor is currently active\n     * @readonly\n     * @property {Boolean}\n     */\n    get isEditing() {\n        return !!this._editing;\n    }\n\n    onActivateEditor({ eventRecord, resourceRecord, eventElement }) {\n        // attempt to re-open already opened editor for the same record - do nothing\n        if (eventRecord === this.record && this.isEditing) {\n            return;\n        }\n\n        this.editEvent(eventRecord, resourceRecord, eventElement);\n    }\n\n    /**\n     * Shows a {@link SchedulerPro.widget.SchedulerTaskEditor scheduler task editor} or {@link SchedulerPro.widget.GanttTaskEditor gantt task editor}\n     * to edit the passed task. This function is exposed on the Scheduler Pro instance and can be called as `scheduler.editTask()`.\n     * @param {SchedulerPro.model.EventModel|Function} taskRecord Task to edit or a function returning a task to edit,\n     * the function will be executed within an STM transaction which will be canceled in case user presses Cancel button\n     * or closes editor w/o hitting Save.\n     * @param {SchedulerPro.model.ResourceModel} [resourceRecord] The Resource record for the event. This parameter is\n     * required if the event is newly created for a resource and has not been assigned, or when using multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @returns {Promise} Promise which resolves after the editor is shown\n     */\n    async editEvent(taskRecord, resourceRecord = null, element = null, stmCapture = null) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        taskRecord = taskRecord.isEventSegment ? taskRecord.event : taskRecord;\n\n        const doEdit = !me.disabled && !taskRecord.readOnly && !scheduler.project.isDelayingCalculation && (taskRecord.project || !scheduler.usesDisplayStore);\n\n        if (doEdit && stmCapture) {\n            // need to set this flag synchronously, to indicate to the outer world,\n            // that we are going to take the ownership of the \"stm capture\"\n            // only setting the flag, actual taking ownership happens later\n            stmCapture.transferred = true;\n        }\n\n        // If we are editing, cancel the edit.\n        if (me.isEditing) {\n            await me.cancel();\n        }\n\n        // We may have just canceled the edit above, or some other user gesture may\n        // have begun cancelling prior to that.\n        // Either way, we must wait for it to cancel before the new edit can begin.\n        await Promise.all([me._cancelling, me._hiding]).catch(() => { /* Do nothing on rejected Promise */ });\n\n        if (!scheduler.isGanttBase && !resourceRecord) {\n            // In case of assignments, take the first resource\n            resourceRecord = taskRecord.resource || taskRecord.resources?.[0];\n        }\n\n        // Record without project might be a transient record in a display store, not meant to be manipulated\n        if (doEdit) {\n            const { taskStore } = scheduler;\n\n            me._editing = true;\n\n            if (stmCapture) {\n                me.stmInitiallyAutoRecord = stmCapture.stmInitiallyAutoRecord;\n                me.stmInitiallyDisabled = stmCapture.stmInitiallyDisabled;\n                me.hasStmCapture = true;\n            }\n            else if (!me.hasStmCapture) {\n                me.captureStm(true);\n            }\n\n            scheduler.project.suspendAutoSync();\n\n            if (typeof taskRecord === 'function') {\n                taskRecord = taskRecord();\n            }\n\n            // Open original record when editing a linked record\n            taskRecord = taskRecord.$original;\n\n            // If this is a new record, add it to the store and assign to a resource only after we have started a transaction\n            // which can be rolled back in case of Cancel button press\n            if (!taskRecord.isOccurrence && !taskStore.includes(taskRecord) && !taskRecord.isCreating) {\n                taskRecord.isCreating = true;\n\n                taskStore.add(taskRecord);\n\n                if (resourceRecord) {\n                    scheduler.assignmentStore.assignEventToResource(taskRecord, resourceRecord);\n                }\n\n                await scheduler.project.commitAsync();\n\n                if (me.isDestroyed) {\n                    return;\n                }\n            }\n\n            // For programmatic edit calls for an event not currently in view, scroll it into view first\n            if (me.scrollIntoView && !scheduler.timeAxisSubGrid.collapsed && !element && taskStore.includes(taskRecord) && (resourceRecord || scheduler.isGantt)) {\n                await me.scrollEventIntoView(taskRecord, resourceRecord);\n\n                if (me.isDestroyed) {\n                    return;\n                }\n            }\n\n            const\n                taskElement = element || DomHelper.down(\n                    me.getElementFromTaskRecord(taskRecord, resourceRecord),\n                    scheduler.eventInnerSelector\n                ),\n                editor      = me.getEditor(taskRecord);\n\n            if (await me.triggerOnClient('beforeTaskEdit', { taskEdit : me, taskRecord, taskElement }) !== false) {\n\n                if (me.suspendHasChangesEvent) {\n                    scheduler.project.suspendChangesTracking();\n                }\n\n                // The Promise being async allows a mouseover to trigger the event tip\n                // unless we add the editing class immediately.\n                scheduler.element.classList.add('b-taskeditor-editing');\n\n                // Wait for any pending commit\n                await scheduler.project.commitAsync();\n\n                if (me.isDestroyed) {\n                    return;\n                }\n\n                me.load(taskRecord);\n\n                me.triggerOnClient('beforeTaskEditShow', {\n                    taskEdit : me,\n                    taskRecord,\n                    taskElement,\n                    editor\n                });\n\n                const\n                    { widgetMap } = editor,\n                    isNestedEvent = taskRecord.parent && !taskRecord.parent.isRoot;\n\n                if (widgetMap.deleteButton) {\n                    widgetMap.deleteButton.hidden = scheduler.readOnly || taskRecord.isCreating || editor.readOnly;\n                }\n\n                if (scheduler.features.nestedEvents) {\n                    // Editing a nested event, disable parts of the editor\n                    if (widgetMap.predecessorsTab) {\n                        widgetMap.predecessorsTab.disabled = isNestedEvent;\n                    }\n\n                    if (widgetMap.successorsTab) {\n                        widgetMap.successorsTab.disabled = isNestedEvent;\n                    }\n\n                    if (widgetMap.resourcesField) {\n                        widgetMap.resourcesField.disabled = isNestedEvent;\n                    }\n                }\n\n                me.attachToProject();\n\n                if (editor.centered) {\n                    await editor.show();\n                }\n                else {\n                    if (\n                        !scheduler.timeAxisSubGrid.collapsed &&\n                        taskElement &&\n                        // In Gantt, ensure task bar is not out of view (if triggering edit from a grid cell)\n                        (!scheduler.isGanttBase || me.scrollIntoView || Rectangle.from(taskElement).intersect(Rectangle.from(scheduler.timeAxisSubGridElement)))\n                    ) {\n                        await editor.showBy({\n                            target : taskElement,\n                            anchor : true,\n                            offset : -5\n                        });\n                    }\n                    else {\n                        // Display the editor centered in the Scheduler\n                        await editor.showBy({\n                            target    : scheduler.element,\n                            anchor    : false,\n                            // For records not part of the store (new ones, or filtered out ones) - center the editor\n                            align     : 'c-c',\n                            clippedBy : null\n                        });\n                    }\n                }\n            }\n            else {\n                scheduler.project.resumeAutoSync();\n                await me.rejectStmTransaction();\n\n                if (me.isDestroyed) {\n                    return;\n                }\n\n                me.disableStm();\n                me.freeStm();\n                me._editing = false;\n            }\n        }\n    }\n\n    getEditor(taskRecord = this.record) {\n        const\n            me         = this,\n            { client } = me;\n\n        let { editor } = me;\n\n        if (!editor) {\n            const config = ObjectHelper.merge({\n                clippedBy                : [client.timeAxisSubGridElement, client.bodyContainer],\n                eventEditFeature         : me,\n                weekStartDay             : me.weekStartDay,\n                enableEventSpanBuffer    : me.enableEventSpanBuffer,\n                saveAndCloseOnEnter      : me.saveAndCloseOnEnter,\n                blurAction               : me.blurAction,\n                owner                    : client,\n                dependencyIdField        : me.editorConfig?.dependencyIdField || client.dependencyIdField,\n                project                  : me.project,\n                durationDisplayPrecision : client.durationDisplayPrecision,\n                tabPanelItems            : me.items,\n                internalListeners        : {\n                    beforeHide : {\n                        fn   : 'onBeforeHide',\n                        // Unreasonable to prevent hide in non-prioritized listener\n                        prio : -1000\n                    },\n                    cancel  : 'onCancel',\n                    delete  : 'onDelete',\n                    save    : 'onSave',\n                    thisObj : me\n                },\n                // For backward compatibility\n                tabsConfig : me.tabsConfig\n            }, me.editorConfig);\n\n            // Configured type should always win\n            if (me.editorClass && !config.type) {\n                editor = me.editor = me.editorClass.new(config);\n            }\n            else {\n                const\n                    // Editor will be used depending on project, not on product\n                    project     = taskRecord?.project || me.project,\n                    projectType = project.getType();\n\n                editor = me.editor = Widget.create(Object.assign({\n                    type : me.editorClassMap[projectType] || 'schedulertaskeditor'\n                }, config));\n            }\n        }\n\n        // Must set *after* construction, otherwise it becomes the default state to reset readOnly back to.\n        // Recurrent events are opened read-only, unless this is a reload after choosing to edit it\n        editor.readOnly = (client.readOnly || taskRecord?.isOccurrence || taskRecord?.isRecurring) && !editor.editingRecurring;\n\n        editor.project = me.project;\n\n        return editor;\n    }\n\n    //endregion\n\n    //region Actions\n\n    load(taskRecord, highlightChanges) {\n        const\n            me     = this,\n            editor = me.getEditor(taskRecord);\n\n        me._loading = true;\n\n        // task editor is not meant to edit a segment model so load its main task instead\n        if (taskRecord.isEventSegment) {\n            taskRecord = taskRecord.event;\n        }\n\n        me.record = taskRecord;\n        editor.loadEvent(taskRecord, highlightChanges);\n\n        me._loading = false;\n    }\n\n    /**\n     * Call this method to close task editor saving changes.\n     * @returns {Promise} A promise which is resolved when the task editor is closed and changes are saved.\n     */\n    async save() {\n        const\n            me                                 = this,\n            { scheduler, record : taskRecord } = me;\n\n        if (me.isEditing) {\n            const editor = me.getEditor();\n\n            if (!me.isValid || await me.triggerOnClient('beforeTaskSave', {\n                taskRecord,\n                editor\n            }) === false) {\n                return;\n            }\n\n            me.detachFromProject();\n\n            editor.beforeSave();\n\n            // Turn a newly created record into a permanent one (no-op for others)\n            taskRecord.isCreating = false;\n\n            // Reset exceptionDate tracking, to not react to it on the following cancel\n            editor.resetRecurrenceData = editor.editingRecurring = null;\n\n            me.freeStm(true);\n\n            me._editing = false;\n\n            // afterSave to happen only after the editor is fully invisible.\n            await editor.close();\n\n            scheduler.project.resumeAutoSync(true);\n\n            scheduler.element.classList.remove('b-taskeditor-editing');\n\n            me.triggerOnClient('afterTaskSave', { taskRecord, editor });\n\n            editor.afterSave();\n\n            if (me.suspendHasChangesEvent) {\n                scheduler.project.resumeChangesTracking();\n            }\n\n            me.triggerOnClient('afterTaskEdit', { taskRecord, editor });\n        }\n    }\n\n    // This is called by the TaskEditor's hide method prior to the super call,\n    // so however it gets hidden, it will signal a cancel.\n    async doCancel() {\n        const\n            me = this,\n            { scheduler, record : taskRecord } = me;\n\n        if (me.isEditing) {\n            // prevent the re-entrance to this method\n            me._editing = false;\n\n            me.detachFromProject();\n\n            const\n                { project } = me,\n                editor      = me.getEditor();\n\n            editor.editingRecurring = null;\n\n            editor.beforeCancel();\n\n            // the feature could get destroyed asynchronously\n            if (me.isDestroyed) {\n                // project could get destroyed at the same time, if configured with\n                project.resumeAutoSync?.(false);\n                return;\n            }\n\n            if (taskRecord?.isCreating) {\n                taskRecord.remove();\n            }\n            else {\n                await me.rejectStmTransaction();\n            }\n\n            // the feature could get destroyed asynchronously\n            if (me.isDestroyed) {\n                // project could get destroyed at the same time, if configured with\n                project.resumeAutoSync?.(false);\n                return;\n            }\n\n            me.disableStm();\n\n            await project.commitAsync();\n\n            // the feature could get destroyed asynchronously\n            if (me.isDestroyed) {\n                // project could get destroyed at the same time, if configured with\n                project.resumeAutoSync?.(false);\n                return;\n            }\n\n            me.freeStm();\n\n            editor.afterCancel();\n\n            project.resumeAutoSync(false);\n\n            scheduler.element.classList.remove('b-taskeditor-editing');\n\n            me.trigger('afterTaskEdit');\n\n            me.triggerOnClient('taskEditCanceled', { taskRecord, editor });\n\n            if (me.suspendHasChangesEvent) {\n                project.resumeChangesTracking();\n            }\n\n            me.triggerOnClient('afterTaskEdit', { taskRecord, editor });\n        }\n    }\n\n    /**\n     * Call this method to close task editor reverting changes.\n     * @returns {Promise} A promise which is resolved when the task editor is closed and changes are reverted.\n     */\n    async cancel() {\n        const\n            me                      = this,\n            { editor }              = me,\n            { resetRecurrenceData } = editor;\n\n        // Reset exceptionDate on cancel, not handled by STM\n        if (resetRecurrenceData) {\n            resetRecurrenceData.recurringTimeSpan.exceptionDates = resetRecurrenceData.originalExceptionDates;\n            editor.resetRecurrenceData = null;\n        }\n\n        return me._cancelling || (me._cancelling = me.doCancel().finally(() => me._cancelling = undefined));\n    }\n\n    async delete() {\n        const\n            me                                         = this,\n            { editor, scheduler, record : taskRecord, project } = me;\n\n        if (!taskRecord.isCreating && await me.triggerOnClient('beforeTaskDelete', { taskRecord, editor }) === false) {\n            return;\n        }\n\n        me.detachFromProject();\n\n        editor.beforeDelete();\n\n        taskRecord.remove();\n\n        me.freeStm();\n\n        await project.commitAsync();\n\n        // Resume and sync, unless we are removing a newly created record (via cancel)\n        project.resumeAutoSync(!taskRecord.isCreating);\n\n        // the feature could get destroyed asynchronously\n        if (me.isDestroyed) {\n            return;\n        }\n\n        me._editing = false;\n\n        editor.close();\n\n        editor.afterDelete();\n\n        scheduler.element.classList.remove('b-taskeditor-editing');\n\n        if (me.suspendHasChangesEvent) {\n            scheduler.project.resumeChangesTracking();\n        }\n\n        me.triggerOnClient('afterTaskEdit', { editor, taskRecord });\n    }\n\n    //endregion\n\n    //region Events\n\n    onSave() {\n        // There's might be propagation requested, so we giving the chance to start propagating\n        // before we're doing save commit procedure.\n        this.requestAnimationFrame(() => this.save());\n    }\n\n    onCancel() {\n        this.cancel().then();\n    }\n\n    async onDelete() {\n        const me = this;\n\n        if (me.confirmDelete) {\n            // <remove-on-release>\n            // TODO: Ask nige about a better solution to prevent popup from closing when showing dialog\n            // </remove-on-release>\n            const\n                { editor } = me,\n                autoClose  = editor.autoClose;\n\n            editor.autoClose = false;\n\n            me.deleteConfirmationPromise = MessageDialog.confirm({\n                title       : 'L{TaskEdit.ConfirmDeletionTitle}',\n                message     : 'L{TaskEdit.ConfirmDeletionMessage}',\n                okButton    : 'L{TaskEditorBase.Delete}',\n                rootElement : me.rootElement\n            });\n\n            const result     = await me.deleteConfirmationPromise;\n\n            editor.autoClose = autoClose;\n\n            me.deleteConfirmationPromise = null;\n\n            if (result === MessageDialog.yesButton) {\n                me.delete();\n            }\n        }\n        else {\n            // There's might be propagation requested, so we giving the chance to start propagating\n            // before we're doing cancel rejection procedure.\n            me.requestAnimationFrame(() => me.delete());\n        }\n    }\n\n    onBeforeHide({ source, animate }) {\n        // It should not matter that we might override previous promise. Any chained promises still are going to be\n        // executed. We only need to make sure that current promise and doCancel promises end at the same time.\n        if (source.hideAnimation && animate !== false) {\n            this._hiding = new Promise(resolve => {\n                source.ion({ hideAnimationEnd : resolve });\n            }).finally(() => this._hiding = undefined);\n        }\n    }\n\n    onDragCreateEnd({ eventRecord, resourceRecord, proxyElement, stmCapture }) {\n        // Only edit if it a real create. If it is a drag to schedule an already existing\n        // event in gantt, then we do not offer the edit UI.\n        if (!this.disabled && eventRecord.isCreating) {\n            this.editEvent(eventRecord, resourceRecord, null, stmCapture);\n        }\n    }\n\n    //endregion\n\n    //region Context menu\n\n    populateEventMenu({ eventRecord, resourceRecord, items }) {\n        if (!this.scheduler.readOnly) {\n            items.editEvent = {\n                text        : 'L{Edit task}',\n                localeClass : this,\n                icon        : 'b-icon b-icon-edit',\n                weight      : -200,\n                disabled    : this.disabled || eventRecord.readOnly,\n                onItem      : () => this.editEvent(eventRecord, resourceRecord)\n            };\n        }\n    }\n\n    // chained from EventNavigation\n    onEventEnterKey({ assignmentRecord, eventRecord }) {\n        if (assignmentRecord) {\n            this.editEvent(eventRecord, assignmentRecord.resource);\n        }\n        else if (eventRecord) {\n            this.editEvent(eventRecord, eventRecord.resource);\n        }\n    }\n\n    //endregion\n\n    // Fire 2 events with param / event name using 'task' + 'event'\n    async triggerOnClient(name, params) {\n        const\n            eventEvent          = name.replace(/task/, 'event').replace(/Task/, 'Event'),\n            returnValTaskRecord = await this.scheduler.trigger(...arguments);\n\n        params.eventRecord = params.taskRecord;\n        // RecurringEvents mixin expects there to be 'eventRecords' in the beforeEventDelete event\n        params.eventRecords = [params.taskRecord];\n\n        const returnValEventRecord = await this.scheduler.trigger(eventEvent, params);\n\n        return returnValTaskRecord && returnValEventRecord;\n    }\n\n    onEventDropped({ eventRecords }) {\n        const eventRecord = this.editor?.loadedRecord && eventRecords.find(rec => rec === this.editor.loadedRecord);\n\n        eventRecord && this.onEventResized({ eventRecord });\n    }\n\n    onEventResized({ eventRecord }) {\n        const { editor } = this;\n        if (editor?.isVisible && eventRecord === editor.loadedRecord) {\n            editor.realign();\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(TaskEdit, true, 'SchedulerPro');//, 'EventEdit');\nGridFeatureManager.registerFeature(TaskEdit, false, 'ResourceHistogram');\n", "/**\n * @module SchedulerPro/model/changelog/ChangeLogEntity\n */\n\n/**\n * An immutable, serializable object that describes an entity instance (for example, a single task).\n * ChangeLogEntity instances appear in change log entries to indicate which entity was affected by\n * a {@link SchedulerPro/model/changelog/ChangeLogAction}.\n */\nexport default class ChangeLogEntity {\n\n    static $name = 'ChangeLogEntity';\n\n    constructor({ model, type }) {\n        Object.assign(this, {\n            /**\n             * @member {String} id The unique id of the entity instance, e.g. 'TaskModel-1'.\n             * @readonly\n             * @category Common\n             */\n            id : model.id ?? model.$entityName,\n\n            /**\n             * @member {String} type The name of the Model type of the entity, e.g. 'TaskModel'.\n             * @readonly\n             * @category Common\n             */\n            type : type?.$$name ?? model.constructor.name,\n\n            /**\n             * @member {String} name A user-friendly name for the entity instance, e.g. 'My important task'.\n             * @readonly\n             * @category Common\n             */\n            name : model.name ?? model.$entityName\n        });\n        if (new.target === ChangeLogEntity) {\n            Object.freeze(this);\n        }\n    }\n}\n", "import ChangeLogEntity from './ChangeLogEntity.js';\nimport DependencyModel from '../DependencyModel.js';\n\n/**\n * @module SchedulerPro/model/changelog/ChangeLogDependencyEntity\n */\n\n/**\n * An immutable, serializable object that describes a dependency entity instance.\n *\n * @extends SchedulerPro/model/changelog/ChangeLogEntity\n */\nexport default class ChangeLogDependencyEntity extends ChangeLogEntity {\n\n    static $name = 'ChangeLogDependencyEntity';\n\n    constructor({ model, fromTask, toTask }) {\n        super({ model, type : DependencyModel });\n        Object.assign(this, {\n            /**\n             * @member {SchedulerPro.model.changelog.ChangeLogEntity} fromTask The 'from' task of the dependency.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            fromTask,\n\n            /**\n             * @member {SchedulerPro.model.changelog.ChangeLogEntity} toTask The 'to' task of the dependency.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            toTask\n        });\n        Object.freeze(this);\n    }\n}\n", "import AssignmentModel from '../AssignmentModel.js';\nimport ChangeLogEntity from './ChangeLogEntity.js';\n\n/**\n * @module SchedulerPro/model/changelog/ChangeLogAssignmentEntity\n */\n\n/**\n * An immutable, serializable object that describes a resource assignment entity instance.\n *\n * @extends SchedulerPro/model/changelog/ChangeLogEntity\n */\nexport default class ChangeLogAssignmentEntity extends ChangeLogEntity {\n\n    static $name = 'ChangeLogAssignmentEntity';\n\n    constructor({ model, event, resource }) {\n        super({ model, type : AssignmentModel });\n        Object.assign(this, {\n            /**\n             * @member {SchedulerPro.model.changelog.ChangeLogEntity} event The event to which the assignment was made.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            event,\n\n            /**\n             * @member {SchedulerPro.model.changelog.ChangeLogEntity} resource The resource that was assigned.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            resource\n        });\n        Object.freeze(this);\n    }\n}\n", "/**\n * @module SchedulerPro/model/changelog/ChangeLogAction\n */\n\n/**\n * An immutable, serializable object that describes an action that affected a single entity.\n */\nexport default class ChangeLogAction {\n\n    static $name = 'ChangeLogAction';\n\n    constructor({ entity, actionType }) {\n        Object.assign(this, {\n            /**\n             * @member {SchedulerPro.model.changelog.ChangeLogEntity} entity A descriptor for the entity (object) affected by this action.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            entity,\n\n            /**\n             * @member {'add'|'remove'|'update'} actionType The type of change.\n             * @readonly\n             * @category Common\n             */\n            actionType\n\n        });\n        if (this.constructor === ChangeLogAction) {\n            Object.freeze(this);\n        }\n    }\n}\n", "import ChangeLogAction from './ChangeLogAction.js';\n\n/**\n * @module SchedulerPro/model/changelog/ChangeLogMoveAction\n */\n\n/**\n * The location of a {@link SchedulerPro.model.changelog.ChangeLogEntity} in a tree.\n * @typedef {Object} ChangeLogEntityLocation\n * @property {SchedulerPro.model.changelog.ChangeLogEntity} parent The parent node of which the target entity is a child, if any\n * @property {Number} index The index of the child within the list of parent's children\n */\n\n/**\n * An immutable, serializable object that describes an action that updated properties on a single entity.\n *\n * @extends SchedulerPro/model/changelog/ChangeLogAction\n */\nexport default class ChangeLogMoveAction extends ChangeLogAction {\n\n    static get $name() {\n        return 'ChangeLogMoveAction';\n    }\n\n    constructor({ entity, from, to }) {\n        super({\n            entity,\n            actionType : 'move'\n        });\n        Object.assign(this, {\n\n            /**\n             * @member {ChangeLogEntityLocation} from The original location from which the entity was moved\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            from,\n\n            /**\n             * @member {ChangeLogEntityLocation} to The new location to which the entity was moved\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            to\n        });\n        Object.freeze(this);\n    }\n}\n", "import ChangeLogAction from './ChangeLogAction.js';\n\n/**\n * @module SchedulerPro/model/changelog/ChangeLogUpdateAction\n */\n\n/**\n * An immutable, serializable object that describes an action that updated properties on a single entity.\n *\n * @extends SchedulerPro/model/changelog/ChangeLogAction\n */\nexport default class ChangeLogUpdateAction extends ChangeLogAction {\n\n    static get $name() {\n        return 'ChangeLogUpdateAction';\n    }\n\n    constructor({ entity, propertyUpdates, isInitialUserAction }) {\n        super({\n            entity,\n            actionType : 'update'\n        });\n        Object.assign(this, {\n            /**\n             * @member {SchedulerPro.model.changelog.ChangeLogPropertyUpdate[]} propertyUpdates The individual property updates, for 'update' type actions.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            propertyUpdates,\n\n            /**\n             * @member {Boolean} isUser Whether the action is part of the initial action taken by the user via the UI, or a follow-on\n             *                          (computed) action.\n             * @readonly\n             * @immutable\n             * @category Common\n             */\n            isUser : isInitialUserAction\n        });\n        Object.freeze(this);\n    }\n}\n", "import ChangeLogTransactionModel from '../model/changelog/ChangeLogTransactionModel.js';\nimport VersionModel from '../model/VersionModel.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport AssignmentModel from '../model/AssignmentModel.js';\nimport ResourceModel from '../model/ResourceModel.js';\nimport ChangeLogEntity from '../model/changelog/ChangeLogEntity.js';\nimport ChangeLogDependencyEntity from '../model/changelog/ChangeLogDependencyEntity.js';\nimport ChangeLogAssignmentEntity from '../model/changelog/ChangeLogAssignmentEntity.js';\nimport ChangeLogAction from '../model/changelog/ChangeLogAction.js';\nimport ChangeLogMoveAction from '../model/changelog/ChangeLogMoveAction.js';\nimport ChangeLogUpdateAction from '../model/changelog/ChangeLogUpdateAction.js';\nimport VersionStore from '../data/VersionStore.js';\nimport ChangeLogStore from '../data/ChangeLogStore.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport WalkHelper from '../../Core/helper/WalkHelper.js';\nimport AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n\n/**\n * @module SchedulerPro/feature/Versions\n */\n\n/**\n * Captures versions (snapshots) of the active project, including a detailed log of the changes new in each version.\n *\n * When active, the feature monitors the project for changes and appends them to the changelog. When a version is captured,\n * the version will consist of a complete snapshot of the project data at the time of the capture, in addition to the list\n * of changes in the changelog that have occurred since the last version was captured.\n *\n * For information about the data structure representing a version and how to persist it, see {@link SchedulerPro.model.VersionModel}.\n *\n * For information about the data structures representing the changelog and how to persist them, see\n * {@link SchedulerPro.model.changelog.ChangeLogTransactionModel}.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     features : {\n *         versions : true\n *     }\n * });\n * ```\n *\n * To display versions and their changes, use a {@link SchedulerPro.widget.VersionGrid} configured with a {@link SchedulerPro.model.ProjectModel}.\n *\n * {@inlineexample SchedulerPro/guides/whats-new/5.3.0/versions.js}\n *\n * See also:\n * - {@link SchedulerPro.model.VersionModel} A stored version of a ProjectModel, captured at a point in time, with change log\n * - {@link SchedulerPro.model.changelog.ChangeLogTransactionModel} The set of add/remove/update actions that occurred in response to a user action\n * - {@link SchedulerPro.widget.VersionGrid} Widget for displaying a project's versions and changes\n *\n * @extends Core/mixin/InstancePlugin\n * @classType versions\n * @feature\n */\nexport default class Versions extends InstancePlugin.mixin(AttachToProjectMixin) {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{addDependency}',\n        'L{updateEntity}',\n        'L{addAssignment}',\n        'L{removeAssignment}',\n        'L{updateAssignment}',\n        'L{addDependency}',\n        'L{removeDependency}',\n        'L{updateDependency}',\n        'L{addEntity}',\n        'L{removeEntity}',\n        'L{updateEntity}',\n        'L{moveEntity}'\n    ];\n    // endregion\n    // </debug>\n\n    static $name = 'Versions';\n\n    static configurable = {\n\n        /**\n         * Optional subclass of {@link SchedulerPro.model.VersionModel} to use instead of {@link SchedulerPro.model.VersionModel}.\n         * Use this to extend VersionModel to add any additional fields your application needs.\n         * @config {SchedulerPro.model.VersionModel}\n         * @typings {typeof VersionModel}\n         */\n        versionModelClass : VersionModel,\n\n        /**\n         * Optional subclass of {@link SchedulerPro.model.changelog.ChangeLogTransactionModel} to use instead of {@link SchedulerPro.model.changelog.ChangeLogTransactionModel}.\n         * Use this to extend ChangeLogTransactionModel to add any additional fields your application needs.\n         * @config {SchedulerPro.model.changelog.ChangeLogTransactionModel}\n         * @typings {typeof ChangeLogTransactionModel}\n         */\n        transactionModelClass : ChangeLogTransactionModel,\n\n        /**\n         * The interval between autosaves, in minutes. To disable autosave, set the interval to zero.\n         * To save on the hour, use 'hourly'.\n         *\n         * @config {'hourly'|Number}\n         * @default\n         */\n        autoSaveInterval : 'hourly',\n\n        /**\n         * The set of Model types whose subtypes should be recorded as the base type in the change log. For example,\n         * by default if a subclassed TaskModelEx exists and an instance of one is updated, it will be recorded in the\n         * changelog as a TaskModel.\n         * @config {Array}\n         * @default [AssignmentModel, DependencyModel, ResourceModel]\n         */\n        knownBaseTypes : [AssignmentModel, DependencyModel, ResourceModel],\n\n        versionContentLoadTimeout : 60000\n    };\n\n    _remoteActionRanges = [];\n    _comparingVersionId;\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n        const me = this;\n\n        me.versionStore = new VersionStore({\n            modelClass        : me.versionModelClass,\n            internalListeners : {\n                change  : me.onStoreChangeExternal,\n                thisObj : me\n            },\n            id : VersionStore.configurable.storeId\n        });\n\n        me.changeStore = new ChangeLogStore({\n            modelClass        : me.transactionModelClass,\n            internalListeners : {\n                change  : me.onStoreChangeExternal,\n                thisObj : me\n            },\n            id : ChangeLogStore.configurable.storeId\n        });\n\n        me._currentChanges = [];\n\n        // Hook UI events from other features to apply default transaction descriptions\n        me.client.ion({\n            beforeTaskDelete          : me.onBeforeTaskDelete,\n            beforeTaskSave            : me.onBeforeTaskSave,\n            gridRowBeforeDropFinalize : me.onGridRowBeforeDropFinalize,\n            thisObj                   : me\n        });\n    }\n\n    //region Project\n\n    attachToProject(project) {\n        const me = this;\n        super.attachToProject(project);\n\n        project.addCrudStore([\n            me.versionStore,\n            me.changeStore\n        ]);\n\n        project.ion({\n            name    : 'project',\n            load    : me.onProjectLoad,\n            once    : true,\n            thisObj : me\n        });\n\n        me.detachProjectListeners();\n        me.attachProjectListeners(project);\n    }\n\n    //endregion\n\n    // From TaskEdit feature - 'delete' via task edit popup\n    onBeforeTaskDelete() {\n        this.transactionDescription = this.L(`L{Versions.deletedTask}`);\n    }\n\n    onBeforeTaskSave() {\n        this.transactionDescription = this.L(`L{Versions.editedTask}`);\n    }\n\n    onGridRowBeforeDropFinalize({ context: { valid, records } }) {\n        if (valid) {\n            this.transactionDescription = records.length === 1 ? this.L(`L{Versions.movedTask}`)\n                : this.L(`L{Versions.movedTasks}`);\n        }\n    }\n\n    attachProjectListeners(project) {\n        const me = this;\n        project?.stm?.ion({\n            recordingStart : me.onStmRecordingStart,\n            recordingStop  : me.handleTransactionStop,\n            restoringStop  : me.onStmRestoringStop,\n            thisObj        : me,\n            name           : 'stmListeners'\n        });\n        project?.ion({\n            wsBeforeReceiveChanges : me.onBeforeApplyRemoteChanges,\n            wsReceiveChanges       : me.onAfterApplyRemoteChanges,\n            thisObj                : me,\n            name                   : 'stmListeners'\n        });\n    }\n\n    detachProjectListeners() {\n        this.detachListeners('stmListeners');\n    }\n\n    updateVersionModelClass(newVersionModelClass) {\n        if (!newVersionModelClass.isVersionModel) {\n            throw new Error(`versionModelClass config must be a subclass of SchedulerPro.model.VersionModel.`);\n        }\n    }\n\n    updateTransactionModelClass(newTransactionModelClass) {\n        if (!newTransactionModelClass.isChangeLogTransactionModel) {\n            throw new Error(`transactionModelClass config must be a subclass of SchedulerPro.model.changelog.ChangeLogTransactionModel.`);\n        }\n    }\n\n    onStoreChangeExternal() {\n        this.triggerVersionChange();\n    }\n\n    tryAutoSave() {\n        const\n            me = this,\n            { project } = me.client;\n        if (me.changeStore.find(({ versionId }) => !versionId)) {\n            if (project?.wsSend) {\n                // When using websockets, ask the server for permission before saving\n                project.wsSend('requestVersionAutoSave', { project : project.wsProjectId });\n                me.detachListeners('autoSave');\n                project.ion({\n                    name                : 'autoSave',\n                    wsVersionAutoSaveOK : me.autoSave,\n                    thisObj             : me,\n                    once                : true\n                });\n            }\n            else {\n                me.saveVersionWithConfig({ isAutosave : true });\n            }\n        }\n    }\n\n    autoSave() {\n        this.saveVersionWithConfig({ isAutosave : true });\n    }\n\n    /**\n     * When autosave is 'hourly', we check the time every 30 seconds and autosave on the hour.\n     */\n    autoSaveHourly() {\n        if (new Date().getMinutes() === 0) {\n            this.tryAutoSave();\n        }\n    }\n\n    updateAutoSaveInterval(newInterval) {\n        const\n            me = this,\n            { client } = me;\n        if (me._autoSaveInterval) {\n            client.clearInterval(me._autosaveInterval);\n        }\n        if (newInterval === 'hourly') {\n            me._autoSaveInterval = client.setInterval(me.autoSaveHourly.bind(me), 10 * 1000);\n        }\n        else if (newInterval) {\n            me._autoSaveInterval = client.setInterval(me.tryAutoSave.bind(me), newInterval * 60 * 1000);\n        }\n    }\n\n    /**\n     * Save a new version containing any unsaved audit log entries, with the given name (optional).\n     * @param {String} [versionName] The name for the version\n     */\n    saveVersion(versionName = null) {\n        return this.saveVersionWithConfig({ name : versionName });\n    }\n\n    /**\n     * @internal\n     */\n    saveVersionWithConfig(versionConfig) {\n        const\n            me = this,\n            content = me.captureVersionContent(),\n            version = new me.versionModelClass({\n                savedAt : new Date(),\n                content,\n                ...versionConfig\n            });\n        version.onBeforeSave();\n        me.versionStore.add(version);\n        me.changeStore.query(changeRecord => changeRecord.versionId == null)\n            .forEach(txn => txn.versionId = version.id);\n        me.triggerVersionChange();\n        me.triggerTransactionChange();\n        return version;\n    }\n\n    /**\n     * Retrieve a single version's content from the backend.\n     * @param {SchedulerPro.model.VersionModel} version Load content into the `content` field of a VersionModel\n     */\n    async loadVersionContent(version) {\n        const\n            me = this,\n            { client } = me,\n            { project } = client,\n            context = {\n                version,\n                content : null\n            };\n        if (await me.trigger('beforeLoadVersionContent', { context })) {\n            if (project?.wsSend) {\n                project.wsSend('loadVersionContent', {\n                    project   : project.wsProjectId,\n                    versionId : version.id\n                });\n                const content = await new Promise((resolve, reject) => {\n                    const start = Date.now();\n                    project.ion({\n                        name : 'loadVersionContent',\n                        loadVersionContent({ project: projectId, versionId, content }) {\n                            if (projectId === project.wsProjectId && versionId === version.id) {\n                                project.detachListeners('loadVersionContent');\n                                return resolve(content);\n                            }\n                        },\n                        thisObj : me,\n                        expires : {\n                            delay : me.versionContentLoadTimeout - (Date.now() - start),\n                            alt   : () => reject(`Failed to receive version content within ${this.versionContentLoadTimeout} ms`)\n                        }\n                    });\n                });\n                if (content) {\n                    me._versionContentCache.set(version.id, content);\n                }\n                return content;\n            }\n        }\n        else if (context.content) {\n            return context.content;\n        }\n    }\n\n    async getVersionContent(version) {\n        return version.content ?? await this.loadVersionContent(version);\n    }\n\n    triggerTransactionChange() {\n        /**\n         * __Note that this event fires on the owning {@link SchedulerPro.view.SchedulerPro}.__\n         *\n         * Fires when the list of observed transactions changes.\n         *\n         * @event transactionChange\n         * @param {Boolean} hasChanges Whether any changes are recorded that are not yet attached to a version.\n         *\n         * @on-owner\n         */\n        this.client.trigger('transactionChange', {\n            hasUnattachedTransactions : this.hasUnattachedTransactions\n        });\n    }\n\n    triggerVersionChange() {\n        this.client.trigger('versionChange', { versions : this.versionStore.records });\n    }\n\n    captureVersionContent() {\n        // See https://github.com/bryntum/bryntum-suite/issues/5645\n        return this.client.project.toJSON();\n    }\n\n    /**\n     * Restores the given version, replacing any {@link SchedulerPro.model.ProjectModel} currently\n     * present in the scheduler.\n     *\n     * @param {SchedulerPro.model.VersionModel} version The version to compare against the current working copy\n     */\n    async restoreVersion(version) {\n        const\n            content = await this.getVersionContent(version),\n            { project } = this.client,\n            stmWasEnabled = project.stm?.enabled;\n        project.stm?.disable();\n        project.json = content;\n        await project.commitAsync();\n        if (stmWasEnabled) {\n            project.stm?.enable();\n        }\n        project.stm?.resetQueue();\n    }\n\n    /**\n     * Loads the given version as a set of baselines into the current project.\n     *\n     * @param {SchedulerPro.model.VersionModel} version The version to compare against the current working copy\n     */\n    async compareVersion(version) {\n        const\n            versionData = await this.getVersionContent(version),\n            baselinesByTaskId = {},\n            { project } = this.client,\n            stmWasEnabled = project.stm?.enabled;\n\n        project.stm?.disable();\n\n        for (const rootTask of versionData.eventsData) {\n            WalkHelper.preWalk(rootTask, task => task.children, ({ id, startDate, endDate }) => {\n                baselinesByTaskId[id] = { startDate, endDate };\n            });\n        }\n\n        project.taskStore.traverse(task => {\n            if (baselinesByTaskId[task.id]) {\n                task.baselines.removeAll();\n                task.baselines.loadData([{ task, ...baselinesByTaskId[task.id] }]);\n            }\n        });\n\n        if (stmWasEnabled) {\n            project.stm?.enable();\n        }\n\n        this._comparingVersionId = version.id;\n    }\n\n    /**\n     * Stops comparing a currently compared version.\n     */\n    stopComparing() {\n        if (!this._comparingVersionId) {\n            return;\n        }\n\n        const\n            { project } = this.client,\n            stmWasEnabled = project.stm?.enabled;\n\n        project.stm?.disable();\n\n        project.taskStore.traverse(task => {\n            task.baselines.removeAll();\n        });\n\n        if (stmWasEnabled) {\n            project.stm?.enable();\n        }\n\n        this._comparingVersionId = null;\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (disable) {\n            this.detachProjectListeners();\n        }\n        else {\n            this.attachProjectListeners(this.client.project);\n        }\n        this.client.refresh();\n    }\n\n    getEntityDescriptor(model) {\n        const recordedType = this.knownBaseTypes.find(knownType => model instanceof knownType) ?? model.constructor;\n        if (model.isDependencyModel) {\n            return new ChangeLogDependencyEntity({\n                model,\n                fromTask : this.getEntityDescriptor(model.fromTask),\n                toTask   : this.getEntityDescriptor(model.toTask)\n            });\n        }\n        else if (model.isAssignmentModel) {\n            return new ChangeLogAssignmentEntity({\n                model,\n                event    : this.getEntityDescriptor(model.event),\n                resource : this.getEntityDescriptor(model.resource)\n            });\n        }\n        return new ChangeLogEntity({ model, type : recordedType });\n    }\n\n    /**\n     * Create a changelog action from a set of STM UpdateActions affecting a single entity (model).\n     * @param {Core.data.stm.action.UpdateAction[]} stmUpdateActions\n     * @returns {SchedulerPro.model.changelog.ChangeLogUpdateAction} A ChangeLogUpdateAction representing the updates to this entity\n     * @private\n     */\n    getUpdateAction(stmUpdateActions) {\n        const\n            entityModel = stmUpdateActions[0].model,\n            // Flatten all property updates for this entity from all actions, as { property, value, oldValue }\n            allPropertyUpdates =\n                stmUpdateActions.flatMap(({ newData, oldData }) =>\n                    Object.entries(newData)\n                        .map(([property, value]) => ({\n                            property,\n                            value,\n                            oldValue : oldData[property]\n                        }))\n                        .filter(({ property, value, oldValue }) =>\n                            !ObjectHelper.isEqual(value, oldValue) &&\n                                entityModel.getFieldDefinition(property)?.persist\n                        )\n                ),\n            // When we have multiple changes for the same property in the same transaction,\n            // drop intermediate values and keep only first 'before' and last 'after'\n            allUpdatesByProperty = ArrayHelper.groupBy(allPropertyUpdates, 'property'),\n            propertyUpdates = Object.entries(allUpdatesByProperty)\n                .map(([property, changes]) => ({\n                    property,\n                    before : changes[0].oldValue,\n                    after  : changes[changes.length - 1].value\n                })),\n            isInitialUserAction = stmUpdateActions.some(({ isInitialUserAction }) => isInitialUserAction);\n\n        return new ChangeLogUpdateAction({\n            actionType : 'update',\n            entity     : this.getEntityDescriptor(entityModel),\n            propertyUpdates,\n            isInitialUserAction\n        });\n    }\n\n    /**\n     * This listener is used to exclude changes that occur during a project's initial load and scheduling.\n     * @private\n     */\n    onProjectLoad() {\n        this._currentStmTransaction = null;\n        // Must early-close the project-load transaction so immediate follow-on changes get put into a new transaction by STM\n        this.stopTransaction();\n    }\n\n    onStmRecordingStart({ transaction }) {\n        this._transactionStart = new Date();\n        this._currentStmTransaction = transaction;\n        this.triggerTransactionChange();\n    }\n\n    /**\n     * Force-stop a transaction immediately.\n     * @private\n     */\n    stopTransaction() {\n        if (this.client.project?.stm.isRecording) {\n            this.client.project?.stm.stopTransaction();\n        }\n        this.handleTransactionStop();\n    }\n\n    async onStmRestoringStop({ cause, transactions }) {\n        const me = this;\n        if (cause === 'undo') {\n            me.transactionDescription = me.L(`L{undid}`);\n        }\n        else if (cause === 'redo') {\n            me.transactionDescription = me.L(`L{redid}`);\n        }\n        await me.client.project.commitAsync();\n        me._transactionStart = new Date();\n        // Synthetic transaction with joined queue\n        me.finalizeTransaction({ queue : transactions.flatMap(txn => txn.queue) });\n    }\n\n    /**\n     * Track ranges of remote actions inside a single transaction, to exclude them from changelog\n     * recording later in finalizeTransaction.\n     * @private\n     */\n    onBeforeApplyRemoteChanges() {\n        if (this._remoteChangesStartPos == null) {\n            this._remoteChangesStartPos = this._currentStmTransaction?.queue.length ?? 0;\n        }\n    }\n\n    async onAfterApplyRemoteChanges() {\n        this.endCurrentRemoteActionRange();\n        await this.client.project.commitAsync();\n    }\n\n    /**\n     * Process the end of a remote-changes subset of a current transaction, adding to the tracked set of\n     * ranges.\n     * @private\n     */\n    endCurrentRemoteActionRange() {\n        const me = this;\n        if (me._remoteChangesStartPos != null) {\n            const currentPos = me._currentStmTransaction?.queue.length ?? 0;\n            if (currentPos !== me._remoteChangesStartPos) {\n                me._remoteActionRanges.push({ start : me._remoteChangesStartPos, end : currentPos });\n            }\n            me._remoteChangesStartPos = null;\n        }\n    }\n\n    /**\n     * @internal\n     */\n    handleTransactionStop() {\n        const me = this;\n        if (me.hasChanges) {\n            me.finalizeTransaction(me._currentStmTransaction);\n        }\n        me._currentTransactionDescription = null;\n        me._currentStmTransaction = null;\n        me._remoteActionRanges = [];\n        me.triggerTransactionChange();\n    }\n\n    /**\n     * @private\n     */\n    excludeRanges(array, ranges) {\n        let keep = [],\n            position = 0;\n        for (const { start, end } of ranges) {\n            keep = keep.concat(array.slice(position, start));\n            position = end;\n        }\n        return keep.concat(array.slice(position));\n    }\n\n    /**\n     * Package the tracked set of project changes into an ChangeLogTransaction.\n     * @private\n     */\n    finalizeTransaction(stmTransaction) {\n        const me = this;\n\n        // In case transaction ends in the middle of tracking remote changes, finalize those ranges here\n        me.endCurrentRemoteActionRange();\n\n        const localActions = me.excludeRanges(stmTransaction.queue, me._remoteActionRanges);\n        if (localActions.length === 0) {\n            return;\n        }\n        const\n            // Group updates by their affected model's ID\n            uniqueRecordId = ({ model }) => model.$entityName,\n            actionsByType = ArrayHelper.groupBy(localActions, 'type'),\n            allChanges = [];\n\n        for (const updateActionType of ['UpdateAction', 'EventUpdateAction']) {\n            const updateActionsByRecordId = ArrayHelper.groupBy(actionsByType[updateActionType] || [], uniqueRecordId);\n            for (const updateActions of Object.values(updateActionsByRecordId)) {\n                allChanges.push(me.getUpdateAction(updateActions));\n            }\n        }\n\n        for (const { modelList, isInitialUserAction } of actionsByType['RemoveAction'] || []) {\n            for (const model of modelList) {\n                allChanges.push(new ChangeLogAction({\n                    actionType : 'remove',\n                    entity     : me.getEntityDescriptor(model),\n                    isInitialUserAction\n                }));\n            }\n        }\n\n        for (const { childModels } of actionsByType['RemoveChildAction'] || []) {\n            for (const childModel of childModels) {\n                allChanges.push(new ChangeLogAction({\n                    actionType : 'remove',\n                    entity     : me.getEntityDescriptor(childModel)\n                }));\n            }\n        }\n\n        // e.g. adding links (dependencies)\n        for (const { modelList } of actionsByType['AddAction'] || []) {\n            for (const model of modelList) {\n                allChanges.push(new ChangeLogAction({\n                    actionType : 'add',\n                    entity     : me.getEntityDescriptor(model)\n                }));\n            }\n        }\n\n        // e.g. adding, moving tasks\n        for (const { childModels, parentModel, context, insertIndex } of actionsByType['InsertChildAction'] || []) {\n            // When moving a task in the tree, we get one InsertChildAction w/ context. Convert this to 'move'\n            for (const childModel of childModels) {\n                const childContext = context.get(childModel);\n                if (childContext != undefined) {\n                    allChanges.push(new ChangeLogMoveAction({\n                        actionType : 'move',\n                        entity     : me.getEntityDescriptor(childModel),\n                        from       : {\n                            parent : me.getEntityDescriptor(childContext.parent),\n                            index  : childContext.index\n                        },\n                        to : {\n                            parent : me.getEntityDescriptor(parentModel),\n                            index  : insertIndex\n                        }\n                    }));\n                }\n                else {\n                    allChanges.push(new ChangeLogAction({\n                        actionType : 'add',\n                        entity     : me.getEntityDescriptor(childModel)\n                    }));\n                }\n            }\n        }\n\n        const transaction = new me.transactionModelClass({\n            description : me._currentTransactionDescription,\n            actions     : allChanges,\n            occurredAt  : me._transactionStart\n        });\n        me.changeStore.add(transaction);\n    }\n\n    /**\n     * Sets the description of the current transaction. This will override the default\n     * transaction description.\n     *\n     * @property {String}\n     * @category Common\n     */\n    set transactionDescription(description) {\n        this._currentTransactionDescription = description;\n    }\n\n    /**\n     * Whether a pending transaction is open with changes not yet added to the changelog.\n     *\n     * @property {Boolean}\n     * @category Common\n     */\n    get hasChanges() {\n        return this._currentStmTransaction?.queue?.length > 0;\n    }\n\n    get hasUnattachedTransactions() {\n        return this.changeStore.find(transaction => transaction.versionId == null);\n    }\n\n    /**\n     * Whether a saved version is currently being compared.\n     *\n     * @property {Boolean}\n     * @category Common\n     */\n    get isComparing() {\n        return this._comparingVersionId != null;\n    }\n}\n\nGridFeatureManager.registerFeature(Versions, false, 'SchedulerPro');\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module SchedulerPro/model/mixin/ProjectChangeHandlerMixin\n */\n\n// Check if assigning a raw value will make the field change\nconst willChange = (fieldName, rawData, record) => {\n    const\n        field          = record.getFieldDefinition(fieldName),\n        { dataSource } = field,\n        newValue       = record.constructor.processField(fieldName, rawData[dataSource], record);\n\n    return dataSource in rawData && !field.isEqual(newValue, record[fieldName]);\n};\n\n/**\n * This mixin allows syncing a changes object between projects. See {@link #function-applyProjectChanges} for usage\n * @mixin\n */\nexport default Target => class ProjectChangeHandlerMixin extends (Target || Base) {\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n\n        super.startConfigure(config);\n    }\n\n    beforeApplyProjectChanges() {\n        const { stm } = this;\n\n        let shouldResume = false;\n\n        this.suspendChangesTracking();\n\n        if (stm.enabled) {\n            shouldResume = true;\n\n            if (stm.isRecording) {\n                stm.stash();\n            }\n\n            if (this.ignoreRemoteChangesInSTM) {\n                stm.disable();\n            }\n            else {\n                stm.startTransaction();\n            }\n        }\n\n        return shouldResume;\n    }\n\n    /**\n     * Allows to apply changes from one project to another. For method to produce correct results, projects should be\n     * isomorphic - they should use same models and store configuration, also data in source and target projects\n     * should be identical before changes to the source project are made and applied to the target project.\n     * This method is meant to apply changes in real time - as source project is changed, changes should be applied to\n     * the target project before it is changed.\n     * When changes are applied all changes are committed and project is recalculated, which means target project\n     * won't have any local changes after.\n     *\n     * Usage:\n     * ```javascript\n     * // Collect changes from first project\n     * const { changes } = projectA;\n     *\n     * // Apply changes to second project\n     * await projectB.applyProjectChanges(changes);\n     * ```\n     *\n     * <div class=\"note\">\n     * This method will apply changes from the incoming object and accept all current project changes. Before\n     * applying changes make sure you've processed current project changes in order not to lose them.\n     * </div>\n     *\n     * @param {Object} changes Project {@link Scheduler/crud/AbstractCrudManagerMixin#property-changes} object\n     * @returns {Promise}\n     */\n    async applyProjectChanges(changes) {\n        const\n            me           = this,\n            shouldResume = me.beforeApplyProjectChanges();\n\n        // Raise a flag to let store know not to stash stm changes\n        me.applyingChangeset = true;\n\n        if (changes.project) {\n            me.applyProjectResponse(changes.project);\n        }\n\n        // Apply changes from other project, except for dates that will lead to changed constraints (engine is not aware\n        // that we want to keep the constraint)\n        // Has to clone to be able to catch the change and clean it up after commit\n        me.applyChangeset(ObjectHelper.clone(changes), (storeChanges, store) => {\n            if ((store.id === 'tasks' || store.id === 'events')) {\n                const\n                    { modelClass } = store,\n                    startDate      = modelClass.getFieldDataSource('startDate'),\n                    endDate        = modelClass.getFieldDataSource('endDate');\n\n                if (storeChanges.updated) {\n                    for (const data of storeChanges.updated) {\n                        const record = store.getById(data[modelClass.idField]);\n                        if (!(\n                            willChange('constraintType', data, record) ||\n                            willChange('constraintDate', data, record)\n                        )) {\n                            delete data[startDate];\n                            delete data[endDate];\n                        }\n                    }\n                }\n            }\n        });\n\n        await me.commitAsync();\n\n        // This will clean up changes in the project model if they match incoming values\n        me.commitRespondedChanges();\n\n        // The call to applyChangeset() clears changes (it might, but not always), but commitAsync() leads to new\n        // changes. If those changes match what we requested, we flag them as not modified\n        for (const storeId in changes) {\n            const storeDescriptor = me.getStoreDescriptor(storeId);\n\n            // if that a Store section\n            if (storeDescriptor) {\n                const\n                    // Due to this issue better to use lookup on the project instance rather than in global registry\n                    // https://github.com/bryntum/support/issues/5238\n                    { store }    = storeDescriptor,\n                    storeChanges = changes[storeId],\n                    changedRows  = [...storeChanges.updated ?? [], ...storeChanges.added ?? []];\n\n                // Store might be destroyed, asyncness...\n                if (store) {\n                    // Iterate updated and added rows\n                    for (const data of changedRows) {\n                        const record = store.getById(data[store.modelClass.idField]);\n\n                        // Record might not have been added e.g. if change was conflicting and got resolved by rejecting\n                        if (record) {\n                            // Compare each change on the matching record with the raw data value, unflag change if they match\n                            for (const fieldName in record.modifications) {\n                                if (!willChange(fieldName, data, record)) {\n                                    delete record.meta.modified[fieldName];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        me.afterApplyProjectChanges(shouldResume);\n\n        me.applyingChangeset = false;\n\n        // Trigger commit async in case non-project related field (e.g. name) was changed to update possibly\n        // opened task editor\n        await me.commitAsync();\n    }\n\n    afterApplyProjectChanges(shouldResume) {\n        if (shouldResume) {\n            const { stm } = this;\n\n            if (this.ignoreRemoteChangesInSTM) {\n                stm.enable();\n            }\n            else {\n                stm.stopTransaction();\n            }\n\n            stm.applyStash();\n        }\n\n        this.resumeChangesTracking();\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport WebSocketManager from '../../../Core/util/WebSocketManager.js';\n\n/**\n * @module SchedulerPro/model/mixin/ProjectWebSocketHandlerMixin\n */\n\n/**\n * This mixin allows project to communicate changes over websocket connection to stay in sync with other clients. By\n * default, project will automatically sync changes, to temporary suspend autoSync call {@link #function-suspendAutoSync}\n * and to resume {@link #function-resumeAutoSync}. These methods use counter, meaning for every suspendAutoSync call\n * there should be resumeAutoSync.\n * @mixin\n * @private\n */\nexport default Target => class ProjectWebSocketHandlerMixin extends (Target || Base) {\n    static configurable = {\n        /**\n         * Address of the websocket server. If configured websocket will be opened during\n         * instantiation.\n         * @config {String}\n         */\n        wsAddress : null,\n\n        /**\n         * User name config for websocket connection\n         * @config {String}\n         */\n        wsUserName : '',\n\n        /**\n         * Set to false to not request dataset automatically\n         * @config {Boolean}\n         * @category Websocket\n         * @default\n         */\n        wsAutoLoad : true,\n\n        /**\n         * Set to false to disable syncing changes automatically\n         * @config {Boolean}\n         * @category Websocket\n         * @default\n         */\n        wsAutoSync : true,\n\n        /**\n         * Websocket connection timeout\n         * @config {Number}\n         * @category Websocket\n         * @default\n         */\n        wsConnectionTimeout : 60000,\n\n        /**\n         * Id of the project to use for load/sync requests. When changed project will load the dataset if\n         * {@link #config-wsAutoLoad} is true. Otherwise you need to call {@link #function-wsLoad} manually.\n         * @config {String|Number}\n         * @category Websocket\n         * @default\n         */\n        wsProjectId : null\n    };\n\n    doDestroy() {\n        this.websocketManager?.destroy();\n\n        super.doDestroy();\n    }\n\n    //#region Config handlers\n\n    updateWsAddress(address) {\n        const me = this;\n\n        me.websocketManager?.destroy();\n\n        if (address) {\n            me.websocketManager = new WebSocketManager({\n                address,\n                userName          : me.wsUserName,\n                internalListeners : {\n                    message : 'handleWebsocketMessage',\n                    close   : 'handleWebsocketClose',\n                    error   : 'handleWebsocketError',\n                    thisObj : me\n                }\n            });\n\n            if (me.wsAutoLoad) {\n                me.wsLoad();\n            }\n        }\n\n        me.toggleAutoSyncListener();\n    }\n\n    toggleAutoSyncListener() {\n        const me = this;\n\n        me.detachListeners('websocketlisteners');\n\n        if (me._wsAutoSync && me._wsAddress) {\n            me.ion({\n                name       : 'websocketlisteners',\n                hasChanges : 'scheduleWebsocketMessage'\n            });\n        }\n    }\n\n    updateWsAutoSync() {\n        this.toggleAutoSyncListener();\n    }\n\n    updateWsProjectId(value) {\n        if (value != null && this.wsAutoLoad) {\n            this.wsLoad();\n        }\n    }\n    //#endregion\n\n    //#region Auto sync\n\n    scheduleWebsocketMessage() {\n        const me = this;\n\n        if (!me.hasTimeout('wsAutoSync') && !me.isAutoSyncSuspended) {\n            me.setTimeout({\n                name : 'wsAutoSync',\n                fn   : () => {\n                    me.wsSync();\n                },\n                delay : me.autoSyncTimeout\n            });\n        }\n    }\n\n    //#endregion\n\n    /**\n     * Suspends automatic sync (via CRUD manager or websocket connection) upon store changes. Can be called multiple\n     * times (it uses an internal counter).\n     * @category CRUD\n     * @method suspendAutoSync\n     */\n\n    /**\n     * Resumes automatic sync upon store changes (via CRUD manager or websocket connection). Will trigger commit if the\n     * internal counter is 0.\n     * @param {Boolean} [doSync=true] Pass `true` to trigger data syncing after resuming (if there are pending\n     * changes) and `false` to not persist the changes.\n     * @category CRUD\n     */\n    resumeAutoSync(doSync = true) {\n        super.resumeAutoSync(doSync);\n\n        // If we have an active websocket connection and\n        if (this.websocketManager && !this.isAutoSyncSuspended && this.changes) {\n            this.wsSync();\n        }\n    }\n\n    /**\n     * Sends message over configured websocket connection. Requires {@link #config-wsAddress} to be configured.\n     * @param {String} command\n     * @param {Object} [data] Data object to send to the websocket\n     * @param {Boolean} silent Pass true to not trigger {@link #event-wsSendMessage} event\n     * @returns {Boolean} Returns true if message was sent\n     */\n    async wsSend(command, data, silent = false) {\n        if (await this.wsOpen()) {\n            this.websocketManager.send(command, data);\n\n            /**\n             * Fires after project has sent a message over websocket connection\n             * @event wsSendMessage\n             * @param {Object} data Data object with mandatory `command` key and arbitrary data keys.\n             * @param {String} data.command Mandatory command to send\n             * @category Websocket\n             */\n            if (!silent) {\n                this.trigger('wsSendMessage', { command, data });\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Template function which might be implemented to process messages from the websocket server\n     * @param {Object} data Data object with mandatory `command` key and arbitrary data keys.\n     * @param {String} data.command Mandatory command to send\n     */\n    wsReceive(data) { }\n\n    handleWebsocketClose() {\n        /**\n         * Fires when websocket connection is closed\n         * @event wsClose\n         * @category Websocket\n         */\n        this.trigger('wsClose');\n    }\n\n    handleWebsocketError({ error }) {\n        /**\n         * Fires when websocket manager throws error onn connection or trying to process the response\n         * @event wsError\n         * @param {Error} error Error event\n         * @category Websocket\n         */\n        this.trigger('wsError', { error });\n    }\n\n    async handleWebsocketMessage({ data }) {\n        const\n            me              = this,\n            { wsProjectId } = me,\n            { project }     = data;\n\n        /**\n         * Fires when project receives message from the websocket server\n         * @event wsMessage\n         * @param {Object} data Data object with mandatory `command` key and arbitrary data keys.\n         * @param {String} data.command Mandatory command to send\n         * @category Websocket\n         */\n        me.trigger('wsMessage', { data });\n\n        if (project === wsProjectId && data.command === 'projectChange') {\n\n            /**\n             * Fires before project has applied project changes from the websocket server\n             * @event wsBeforeReceiveChanges\n             * @category Websocket\n             */\n            me.trigger('wsBeforeReceiveChanges');\n\n            await me.applyProjectChanges(data.changes);\n\n            /**\n             * Fires after project has applied project changes from the websocket server\n             * @event wsReceiveChanges\n             * @category Websocket\n             */\n            me.trigger('wsReceiveChanges');\n        }\n        else if (project === wsProjectId && data.command === 'dataset') {\n            await me.loadInlineData(data.dataset);\n\n            /**\n             * Fires after project has applied dataset from the websocket server\n             * @event wsReceiveDataset\n             * @category Websocket\n             */\n            me.trigger('wsReceiveDataset');\n        }\n        else if (project === wsProjectId && data.command === 'versionAutoSaveOK') {\n            /**\n             * Fires when client receives permission to proceed with a version auto-save.\n             * @event versionAutoSaveOK\n             */\n            me.trigger('wsVersionAutoSaveOK');\n        }\n        else if (project === wsProjectId && data.command === 'loadVersionContent') {\n            /**\n             * Fires when client receives version content.\n             * @event loadVersionContent\n             */\n            const { versionId, project, content } = data;\n            me.trigger('loadVersionContent', { versionId, project, content });\n        }\n        else {\n            me.wsReceive(data);\n        }\n    }\n\n    /**\n     * Open websocket connection\n     * @returns {Boolean}\n     */\n    async wsOpen() {\n        const { websocketManager } = this;\n\n        if (websocketManager) {\n            const trigger = !websocketManager.isOpened && await websocketManager.open();\n\n            if (trigger) {\n                /**\n                 * Fires when websocket is opened\n                 * @event wsOpen\n                 * @category Websocket\n                 */\n                this.trigger('wsOpen');\n            }\n\n            return websocketManager.isOpened;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loads data to the project and calculates it:\n     *\n     * ```javascript\n     * await project.wsLoad();\n     * ```\n     *\n     * @category Websocket\n     */\n    async wsLoad() {\n        const me = this;\n\n        if (me.wsProjectId == null) {\n            return;\n        }\n\n        // Send request for dataset\n        await me.wsSend('dataset', { project : me.wsProjectId });\n\n        // Await for `wsReceiveDataset` event. When such event arrives `inlineData` is set and project committed\n        await new Promise(resolve => {\n            const detacher = me.ion({\n                wsReceiveDataset() {\n                    detacher();\n                    resolve(true);\n                },\n                expires : {\n                    delay : me.wsConnectionTimeout,\n                    alt   : () => {\n                        detacher();\n                        resolve(false);\n                    }\n                }\n            });\n        });\n\n        await me.commitAsync();\n\n        /**\n         * Fires when dataset is loaded\n         * @event wsLoad\n         * @category Websocket\n         */\n        me.trigger('wsLoad');\n    }\n\n    /**\n     * Persists changes made on the registered stores to the server and/or receives changes made on the backend.\n     * Usage:\n     *\n     * ```javascript\n     * // Send changes to the websocket server\n     * await project.wsSync();\n     * ```\n     *\n     * ** Note: ** Please take a look at {@link #config-wsAutoSync} config. This option allows to persist changes\n     * automatically after any data modification.\n     *\n     * @category Websocket\n     */\n    async wsSync() {\n        const\n            me              = this,\n            { wsProjectId } = me;\n\n        if (wsProjectId == null) {\n            return;\n        }\n\n        // When running on a timeout, we might get here when engine is not ready, leading to the changes call below\n        // getting stuck in an infinite loop.\n        await this.commitAsync();\n\n        const { changes } = this;\n\n        if (changes && (me.wsAutoSync && !me.autoSyncSuspendCounter)) {\n            me.acceptChanges();\n\n            const trigger = await me.wsSend('projectChange', { project : wsProjectId, changes });\n\n            if (trigger) {\n                /**\n                 * Fires after project has sent changes over websocket connection\n                 * @event wsSendChanges\n                 * @category Websocket\n                 */\n                me.trigger('wsSendChanges');\n            }\n        }\n    }\n\n    /**\n     * Closes websocket connection\n     */\n    wsClose() {\n        this.websocketManager?.close();\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n\n/**\n * @module SchedulerPro/view/mixin/ProjectProgressMixin\n */\n\n/**\n * This is a mixin that tracks the progress of project calculations, either as a progress bar in the time axis header\n * or in a mask.\n *\n * Defaults to displaying a progress bar for projects that use delayed calculations to enable early rendering and to a\n * mask for those that do not (which requires configuring the project with `enableProgressNotifications : true`).\n * Configurable using the {@link #config-projectProgressReporting} config.\n *\n * @mixin\n */\nexport default Target => class ProjectProgressMixin extends (Target || Base) {\n\n    // <debug>\n    // region Localization\n    // Do not remove. Assertion strings for Localization sanity check\n    'L{SchedulerProBase.storePopulation}';\n    'L{SchedulerProBase.propagating}';\n    'L{SchedulerProBase.finalizing}';\n    // endregion\n    // </debug>\n\n    static get $name() {\n        return 'ProjectProgressMixin';\n    }\n\n    static configurable = {\n        /**\n         * Accepts the following values:\n         *\n         * * 'auto' - Auto selects 'progressbar' or 'mask' depending on projects configuration\n         * * 'progressbar' - Renders a thin progress bar to the time axis header\n         * * 'mask' - Uses a mask to display progress\n         * * null - Do not display progress\n         *\n         * @config {String|null}\n         * @default\n         * @category Data\n         */\n        projectProgressReporting : 'auto',\n\n        projectProgressThreshold : 5000\n    };\n\n    updateProject(project, old) {\n        super.updateProject(project, old);\n\n        this.setupProgressListener();\n\n        this.detachListeners('delayedCalculation');\n\n        if (project?.delayCalculation) {\n            project.ion({\n                name                  : 'delayedCalculation',\n                delayCalculationStart : 'internalOnProjectDelayCalculationStart',\n                delayCalculationEnd   : 'internalOnProjectDelayCalculationEnd',\n                thisObj               : this\n            });\n        }\n    }\n\n    //region Progress\n\n    setupProgressListener() {\n        const me = this;\n\n        me.detachListeners('projectProgress');\n\n        if (me.projectProgressReporting) {\n            me.project?.ion({\n                name     : 'projectProgress',\n                progress : 'onProjectProgress',\n                thisObj  : me\n            });\n        }\n    }\n\n    updateProjectProgressReporting() {\n        if (!this.isConfiguring) {\n            this.setupProgressListener();\n        }\n    }\n\n    onProjectProgress({ total, remaining, phase = 'propagating' }) {\n        const me = this;\n\n        if (!me.isPainted) {\n            return;\n        }\n\n        // Don't display progress for very small changesets\n        if (total < me.projectProgressThreshold) {\n            return;\n        }\n\n        let mode = me.projectProgressReporting;\n\n        if (mode === 'auto') {\n            mode = me.project.delayCalculation ? 'progressbar' : 'mask';\n        }\n\n        if (mode === 'progressbar') {\n            let progressElement = me.calculationProgressElement;\n\n            if (!progressElement) {\n                // Show calculation progress at the bottom of the timeaxis header,\n                // to not be affected by scroll in any direction\n                progressElement = me.calculationProgressElement = DomHelper.createElement({\n                    parent        : me.timeAxisSubGrid.header.element,\n                    retainElement : true,\n                    className     : 'b-calculation-progress-wrap',\n                    children      : [{\n                        className : 'b-calculation-progress'\n                    }]\n                });\n            }\n\n            progressElement.firstElementChild.style.width = `${((total - remaining) / total) * 100}%`;\n\n            if (total > 0 && remaining === 0) {\n                // Want to show full progress, remove in a bit\n                me.calculationProgressTimeout = me.setTimeout(() => {\n                    progressElement?.remove();\n                    me.calculationProgressElement = null;\n                }, 50);\n            }\n            else {\n                me.clearTimeout(me.calculationProgressTimeout);\n            }\n        }\n        else {\n            const\n                str  = me.L(`L{SchedulerProBase.${phase}}`),\n                text = total ? `${str} ${Math.round(100 * (total - remaining) / total)}%` : str;\n\n            if (!me.masked) {\n                me.mask({\n                    maxProgress   : total,\n                    useTransition : false,\n                    text\n                });\n            }\n\n            me.masked.text = text;\n\n            if (total) {\n                // In case total changes...\n                me.masked.maxProgress = total;\n                me.masked.progress = total - remaining;\n            }\n\n            if (total > 0 && remaining === 0) {\n                me.unmask();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Read-only\n\n    // Delayed calculation mode started, set read-only (unless already configured as such) to block user from changing\n    // data while it is in an invalid, un-calculated, state.\n    internalOnProjectDelayCalculationStart() {\n        if (!this.readOnly) {\n            this.$delayCalculationReadOnly = this.readOnly = true;\n        }\n    }\n\n    // Delayed calculation has finished, reset if made readonly by it\n    internalOnProjectDelayCalculationEnd() {\n        if (this.$delayCalculationReadOnly) {\n            this.$delayCalculationReadOnly = this.readOnly = false;\n        }\n    }\n\n    //endregion\n\n    get widgetClass() {}\n};\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Popup from '../../Core/widget/Popup.js';\nimport { EffectResolutionResult } from '../../Engine/chrono/SchedulingIssueEffect.js';\nimport Promissory from '../../Core/helper/util/Promissory.js';\nimport RadioGroup from '../../Core/widget/RadioGroup.js';\n\nimport '../localization/En.js';\n\n/**\n * @module SchedulerPro/widget/SchedulingIssueResolutionPopup\n */\n\n/**\n * A Popup informing user of a scheduling issue that needs manual resolution.\n * Examples of such cases could be an infinite cycle, a scheduling conflict or a calendar misconfiguration.\n * The dialog displays the case description and lets the user pick one of the possible resolutions.\n *\n * {@inlineexample SchedulerPro/widget/SchedulingIssueResolutionPopup.js}\n *\n * @demo SchedulerPro/conflicts\n * @extends Core/widget/Popup\n * @classType schedulingissueresolutionpopup\n */\nexport default class SchedulingIssueResolutionPopup extends Popup {\n\n    // <debug>\n    // region Localization test\n    static localization = [\n        'L{schedulingConflict}',\n        'L{emptyCalendar}',\n        'L{cycle}'\n    ];\n    // endregion\n    // </debug>\n\n    static get $name() {\n        return 'SchedulingIssueResolutionPopup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'schedulingissueresolutionpopup';\n    }\n\n    static get configurable() {\n        return {\n            localizableProperties : [],\n            schedulingIssue       : null,\n            align                 : 'b-t',\n            autoShow              : false,\n            autoClose             : false,\n            closeAction           : 'onCloseButtonClick',\n            modal                 : true,\n            centered              : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            draggable             : false,\n            closable              : true,\n            floating              : true,\n            cls                   : 'b-schedulerpro-issueresolutionpopup',\n            layout                : 'vbox',\n\n            resolutionsGroup : {\n                type : 'radiogroup',\n                name : 'resolutions'\n            },\n\n            items : {\n                description : {\n                    type   : 'widget',\n                    cls    : 'b-error-description',\n                    weight : -100\n                }\n            },\n            bbar : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    applyButton : {\n                        weight   : 100,\n                        color    : 'b-raised b-blue',\n                        text     : 'L{Apply}',\n                        onClick  : 'up.onApplyButtonClick',\n                        disabled : true\n                    },\n                    cancelButton : {\n                        weight  : 200,\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelButtonClick'\n                    }\n                }\n            }\n        };\n    }\n\n    get selectedResolutions() {\n        const\n            selectedResolutions = new Set(),\n            selectedResolution = this.resolutionsGroup?.selected?.resolution;\n\n        if (selectedResolution) {\n            selectedResolutions.add(selectedResolution);\n        }\n\n        return selectedResolutions;\n    }\n\n    changeResolutionsGroup(config, existing) {\n        return RadioGroup.reconfigure(existing, config, /* owner = */this);\n    }\n\n    updateResolutionsGroup(instance) {\n        instance && this.add(instance);\n    }\n\n    /**\n     * Returns parameters for the provided resolution that should be\n     * passed to its `resolve` method.\n     * @param {Object} resolution Scheduling exception resolution\n     * @returns {Array} The resolution arguments\n     */\n    getResolutionParameters(resolution) {\n        return [];\n    }\n\n    onApplyButtonClick() {\n        const\n            me                      = this,\n            { selectedResolutions } = me;\n\n        if (selectedResolutions.size) {\n            // apply selected resolutions\n            selectedResolutions.forEach(resolution => resolution.resolve(...me.getResolutionParameters(resolution)));\n\n            me.continueWithResolutionResult(EffectResolutionResult.Resume);\n\n            me.doResolve(selectedResolutions);\n        }\n        else {\n            me.onCancelButtonClick();\n        }\n    }\n\n    onCancelButtonClick() {\n        this.continueWithResolutionResult(EffectResolutionResult.Cancel);\n\n        this.doResolve();\n    }\n\n    onCloseButtonClick() {\n        if (this.canCancel) {\n            this.onCancelButtonClick();\n        }\n    }\n\n    get isResolving() {\n        return Boolean(this.resolving);\n    }\n\n    /**\n     * Resolves a scheduling conflict happened on the project (a scheduling conflict or a calendar misconfiguration).\n     * @param {Object} event The scheduling exception event data:\n     * @param {SchedulerPro.model.ProjectModel} event.source The project\n     * @param {*} event.schedulingIssue The scheduling exception\n     * @param {Function} event.continueWithResolutionResult The function to be called once the resolution is chosen and\n     * applied (or it was decided to cancel the changes).\n     * @returns {Promise} Promise that gets resolved when user picks a resolution and clicks \"Apply\" (or \"Cancel\") button.\n     */\n    async resolve({ source, schedulingIssue, continueWithResolutionResult }) {\n        const me = this;\n\n        me.project = source;\n        me.schedulingIssue = schedulingIssue;\n        me.continueWithResolutionResult = continueWithResolutionResult;\n\n        me.updatePopupContent(schedulingIssue, continueWithResolutionResult);\n\n        me.onResolutionChange({});\n\n        me.show();\n\n        me.resolving = new Promissory();\n\n        return me.resolving.promise;\n    }\n\n    doResolve(resolutions) {\n        const\n            me            = this,\n            { resolving } = me;\n\n        if (resolving) {\n            me.resolving.resolve(resolutions);\n            me.resolving = null;\n            me.schedulingIssue = null;\n            me.hide();\n        }\n    }\n\n    getResolutionWidgetConfig(resolution) {\n        return {\n            text              : StringHelper.encodeHtml(resolution.getDescription()),\n            cls               : 'b-resolution',\n            checkedValue      : resolution.$$name,\n            localeClass       : this,\n            name              : 'resolutions',\n            internalListeners : {\n                change : 'up.onResolutionChange'\n            },\n            resolution\n        };\n    }\n\n    getResolutions() {\n        return this.schedulingIssue?.getResolutions();\n    }\n\n    updatePopupContent(schedulingIssue, continueWithResolutionResult) {\n        const\n            me = this,\n            { resolutionsGroup } = me;\n\n        if (continueWithResolutionResult) {\n            me.continueWithResolutionResult = continueWithResolutionResult;\n        }\n\n        if (schedulingIssue) {\n            me.schedulingIssue = schedulingIssue;\n        }\n        else {\n            schedulingIssue = me.schedulingIssue;\n        }\n\n        me.title = schedulingIssue?.type ? me.optionalL(schedulingIssue.type) : 'Unknown error';\n\n        me.widgetMap.description.content = schedulingIssue && StringHelper.encodeHtml(schedulingIssue.getDescription());\n\n        const\n            resolutions     = me.getResolutions(),\n            resolutionItems = resolutions?.map(resolution => me.getResolutionWidgetConfig(resolution)) || [],\n            name            = resolutionItems[0]?.name || 'resolutions';\n\n        resolutionsGroup.removeAll();\n        resolutionsGroup.name = name;\n        resolutionsGroup.add(...resolutionItems, {\n            ref               : 'cancelResolution',\n            text              : 'L{Cancel changes}',\n            name,\n            checkedValue      : 'cancel',\n            localeClass       : this,\n            cls               : 'b-resolution',\n            internalListeners : {\n                change : 'up.onResolutionChange'\n            }\n        });\n\n        // toggle ok/cancel controls state\n        me.toggleControlsState();\n    }\n\n    get canApply() {\n        return this.resolutionsGroup.value != null;\n    }\n\n    get canCancel() {\n        // cancel makes no sense for initial transaction\n        return !this.project?.isInitialCommit;\n    }\n\n    get cancelResolution() {\n        return this.resolutionsGroup.widgetMap.cancelResolution;\n    }\n\n    onResolutionChange() {\n        this.toggleControlsState();\n    }\n\n    toggleControlsState() {\n        const\n            me = this,\n            { applyButton, cancelButton } = me.widgetMap;\n\n        applyButton.disabled = !me.canApply;\n        me.cancelResolution.hidden = cancelButton.hidden = !me.canCancel;\n    }\n\n    updateLocalization() {\n        this.updatePopupContent();\n        super.updateLocalization();\n    }\n};\n\n// Register this widget type with its Factory\nSchedulingIssueResolutionPopup.initClass();\n", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport SchedulingIssueResolutionPopup from './SchedulingIssueResolutionPopup.js';\nimport '../../Core/widget/Combo.js';\n\n/**\n * @module SchedulerPro/widget/CycleResolutionPopup\n */\n\n/**\n * Class implementing a dialog informing user of an infinite cycle in the data.\n * The dialog displays tasks and dependencies causing the cycle and allows\n * to pick one of the dependencies and either deactivate or remove it.\n *\n * @demo SchedulerPro/conflicts\n * @extends SchedulerPro/widget/SchedulingIssueResolutionPopup\n * @classType cycleresolutionpopup\n */\nexport default class CycleResolutionPopup extends SchedulingIssueResolutionPopup {\n\n    static get $name() {\n        return 'CycleResolutionPopup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'cycleresolutionpopup';\n    }\n\n    getDependencyTitle(dependency) {\n        return `\"${StringHelper.encodeHtml(dependency.fromEvent.name)}\" -> \"${StringHelper.encodeHtml(dependency.toEvent.name)}\"`;\n    }\n\n    getResolutionWidgetConfig(resolution) {\n        const\n            { dependency }      = resolution,\n            invalidDependencies = this.schedulingIssue.getInvalidDependencies(),\n            result              = super.getResolutionWidgetConfig(resolution);\n\n        if (invalidDependencies.includes(dependency)) {\n            Object.assign(result, {\n                name    : `dependency-resolution`,\n                // if it's the first resolution for that dependency - check it\n                checked : !this._dependencyResolutionsChecked++\n            });\n        }\n\n        return result;\n    }\n\n    getResolutions() {\n        const\n            { schedulingIssue } = this,\n            invalidDependencies = schedulingIssue?.getInvalidDependencies();\n\n        let resolutions = schedulingIssue?.getResolutions();\n\n        // If there are invalid dependencies involved (like parent-child or self-to-self)\n        // let's not suggests other resolutions to simplify the UI\n\n        if (resolutions && invalidDependencies.length) {\n            resolutions = resolutions.filter(r => r.dependency && invalidDependencies.includes(r.dependency));\n        }\n\n        return resolutions;\n    }\n\n    updatePopupContent(schedulingIssue, continueWithResolutionResult) {\n        const\n            me = this,\n            { invalidDependenciesDescription, dependencyField } = me.widgetMap;\n\n        me._dependencyResolutionsChecked = 0;\n\n        super.updatePopupContent(...arguments);\n\n        // hide entries initially\n        invalidDependenciesDescription?.hide();\n        dependencyField?.hide();\n\n        schedulingIssue = me.schedulingIssue;\n\n        if (schedulingIssue) {\n            const\n                dependencies        = schedulingIssue.getDependencies(),\n                invalidDependencies = schedulingIssue.getInvalidDependencies(),\n                validDependencies   = dependencies.filter(dependency => !invalidDependencies.includes(dependency));\n\n            // If we've got invalid dependencies tha MUST be addressed\n            if (invalidDependencies.length) {\n                if (invalidDependenciesDescription) {\n                    invalidDependenciesDescription.show();\n                }\n                else {\n                    me.add({\n                        type   : 'widget',\n                        ref    : 'invalidDependenciesDescription',\n                        weight : -50,\n                        width  : '100%',\n                        cls    : 'b-invalid-dependencies-description',\n                        html   : me.L('L{invalidDependencyLabel}')\n                    });\n                }\n            }\n            // got dependency combo - show there all dependencies building the cycle\n            else {\n                const dependencyItems = validDependencies?.map(dep => ({\n                    value : dep.id,\n                    text  : me.getDependencyTitle(dep)\n                }));\n\n                if (dependencyField) {\n                    dependencyField.value = null;\n                    dependencyField.items = dependencyItems;\n                    dependencyField.show();\n                }\n                // no dependency combo - build it w/ all the dependencies building the cycle\n                else {\n                    me.add({\n                        type              : 'combo',\n                        ref               : 'dependencyField',\n                        weight            : 50,\n                        width             : '100%',\n                        name              : 'dependency',\n                        label             : me.L('L{dependencyLabel}'),\n                        labelPosition     : 'above',\n                        cls               : 'b-dependency-field',\n                        items             : dependencyItems,\n                        internalListeners : {\n                            change : 'up.onDependencyChange'\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    get canApply() {\n        const { widgetMap } = this;\n\n        // can apply if any resolution and dependency is chosen or if cancel is selected\n        return super.canApply &&\n            (widgetMap.cancelResolution.checked || (!widgetMap.dependencyField || widgetMap.dependencyField.value));\n    }\n\n    onDependencyChange() {\n        this.toggleControlsState();\n    }\n\n    getResolutionParameters(resolution) {\n        // These resolution types need a dependency to be passed to resolve() method as an argument\n        if (resolution.isRemoveDependencyCycleEffectResolution || resolution.isDeactivateDependencyCycleEffectResolution) {\n            const\n                dependencyId = this.widgetMap.dependencyField.value,\n                dependency = this.project.dependencyStore.getById(dependencyId);\n\n            // <debug>\n            console.assert(dependency, 'Dependency should be provided to resolve() method');\n            // </debug>\n\n            return [dependency];\n        }\n\n        return super.getResolutionParameters(resolution);\n    }\n};\n\n// Register this widget type with its Factory\nCycleResolutionPopup.initClass();\n", "import CycleResolutionPopup from '../../widget/CycleResolutionPopup.js';\nimport SchedulingIssueResolutionPopup from '../../widget/SchedulingIssueResolutionPopup.js';\nimport Base from '../../../Core/Base.js';\n\n/**\n * @module SchedulerPro/view/mixin/SchedulingIssueResolution\n */\n\n/**\n * This is a mixin, adding ability to track project scheduling issues (scheduling conflicts, cycles and calendar misconfigurations)\n * and displaying a special popup allowing user to handle them.\n *\n * The mixin basically add listeners to the project {@link SchedulerPro/model/ProjectModel#event-schedulingConflict},\n * {@link SchedulerPro/model/ProjectModel#event-cycle} and  {@link SchedulerPro/model/ProjectModel#event-emptyCalendar}\n * events and shows a popup depending on the case:\n *\n * - {@link SchedulerPro/widget/SchedulingIssueResolutionPopup} for _scheduling conflicts_ and _calendar misconfigurations_.\n * - {@link SchedulerPro/widget/CycleResolutionPopup} for _scheduling cycles_.\n *\n * @demo SchedulerPro/conflicts\n * @mixin\n */\nexport default Target => class SchedulingIssueResolution extends (Target || Base) {\n\n    static get $name() {\n        return 'SchedulingIssueResolution';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Class implementing the popup resolving _scheduling conflicts_ and _calendar misconfigurations_.\n             *\n             * Use this to provide a custom popup for the above cases.\n             * @config {Function}\n             * @default\n             * @category Conflict resolution\n             */\n            schedulingIssueResolutionPopupClass : SchedulingIssueResolutionPopup,\n\n            /**\n             * Class implementing the popup resolving _scheduling cycles_.\n             *\n             * Use this to provide a custom popup for that case.\n             * @config {Function}\n             * @default\n             * @category Conflict resolution\n             */\n            cycleResolutionPopupClass : CycleResolutionPopup,\n\n            /**\n             * Set to `true` to display special popups allowing user\n             * to resolve {@link SchedulerPro/widget/SchedulingIssueResolutionPopup scheduling conflicts},\n             * {@link SchedulerPro/widget/CycleResolutionPopup cycles} or calendar misconfigurations.\n             * The popup will suggest user ways to resolve the corresponding case.\n             * @config {Boolean}\n             * @default\n             * @category Conflict resolution\n             */\n            displaySchedulingIssueResolutionPopup : true\n        };\n    }\n\n    updateProject(project, oldProject) {\n        super.updateProject(project, oldProject);\n\n        this.unbindSchedulingIssueResolutionFromProject(oldProject);\n\n        if (this.displaySchedulingIssueResolutionPopup && project) {\n            this.bindSchedulingIssueResolutionToProject(project);\n        }\n    }\n\n    bindSchedulingIssueResolutionToProject(project) {\n        project.ion({\n            name               : 'schedulingIssueResolution',\n            schedulingConflict : 'onProjectSchedulingIssueEvent',\n            emptyCalendar      : 'onProjectSchedulingIssueEvent',\n            cycle              : 'onProjectSchedulingIssueEvent',\n            thisObj            : this\n        });\n    }\n\n    get isResolving() {\n        return this._lastSchedulingIssueResolutionPopup?.isResolving;\n    }\n\n    get activeSchedulingIssueResolutionPopup() {\n        return this.isResolving && this._lastSchedulingIssueResolutionPopup;\n    }\n\n    unbindSchedulingIssueResolutionFromProject(project) {\n        this.detachListeners('schedulingIssueResolution');\n    }\n\n    getSchedulingIssueResolutionPopup(schedulingIssue) {\n        if (schedulingIssue.type === 'cycle') {\n            return this._cycleResolutionPopup || (this._cycleResolutionPopup = new this.cycleResolutionPopupClass({\n                rootElement : this.rootElement\n            }));\n        }\n        else {\n            return this._schedulingIssueResolutionPopup || (this._schedulingIssueResolutionPopup = new this.schedulingIssueResolutionPopupClass({\n                rootElement : this.rootElement\n            }));\n        }\n    }\n\n    onProjectSchedulingIssueEvent({ schedulingIssue }) {\n        const popup = this.getSchedulingIssueResolutionPopup(schedulingIssue);\n\n        this._lastSchedulingIssueResolutionPopup = popup;\n\n        popup.resolve(...arguments);\n    }\n\n    get widgetClass() {}\n};\n"],
  "mappings": "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",
  "names": ["MIN_SMI", "Math", "pow", "MAX_SMI", "uppercaseFirst", "str", "slice", "toUpperCase", "isAtomicValue", "value", "Object", "defineProperty", "target", "property", "enumerable", "configurable", "prototypeValue", "propertyKey", "copySetInto", "sourceSet", "targetSet", "add", "delay", "timeout", "Promise", "resolve", "setTimeout", "isRegeneratorRuntime", "isGeneratorFunction", "func", "regeneratorRuntime", "constructor", "name", "isPromise", "obj", "then", "emptyFn", "args", "DEBUG_ONLY", "required", "validateRequiredProperties", "OnCycleAction", "WalkSource", "Symbol", "NOT_VISITED", "VISITED_TOPOLOGICALLY", "WalkContext", "Base", "arguments", "visited", "Map", "toVisit", "currentEpoch", "startFrom", "sourceNodes", "continueFrom", "push", "apply", "map", "node", "from", "label", "undefined", "walkDepth", "onNode", "walkStep", "onTopologicalNode", "onCycle", "stack", "Cancel", "forEachNext", "Error", "collectNext", "visitInfo", "getVisitedInfo", "get", "setVisitedInfo", "visitedAt", "info", "visitEpoch", "set", "depth", "length", "visitedInfo", "pop", "Resume", "visitedInfo2", "lengthBefore", "cycleInfo", "cycleSource", "cycle", "current", "cursor", "reverse", "__decorate", "decorators", "key", "desc", "c", "r", "getOwnPropertyDescriptor", "d", "Reflect", "decorate", "i", "FORMULA_ID", "CalculateProposed", "Formula", "formulaId", "inputs", "Set", "VariableWalkContext", "sourceNode", "output", "formulas", "cache", "formulasByInput", "forEach", "formula", "FormulasCache", "Mixin", "base", "variables", "$formulasByInput", "$formulasByOutput", "fillCache", "formulasByOutput", "has", "input", "allInputVariables", "uniqueOnly", "concatIterable", "values", "isCyclic", "walkContext", "new", "Array", "CycleDescription", "CycleResolution", "description", "defaultResolutionFormulas", "resolutionsByInputHash", "clear", "cached", "hash", "resolution", "buildResolution", "WalkState", "context", "allResolutions", "next", "state", "asResolution", "nbrOfDefaultFormulas", "activatedFormulas", "reduce", "count", "formulaIsDefault", "unCoveredInputWeight", "sort", "res1", "res2", "VariableInputState", "CycleResolutionInput", "$hash", "buildHash", "initialize", "CI", "variable", "NoInput", "String", "fromCharCode", "inBatchesBySize", "batch", "batchToCharCode", "reduceRight", "charCode", "index", "addProposedValueFlag", "HasProposedValue", "hasProposedValue", "Boolean", "hasProposedValueVars", "filter", "addPreviousValueFlag", "HasPreviousValue", "hasPreviousValue", "hasPreviousValueVars", "addKeepIfPossibleFlag", "KeepIfPossible", "keepIfPossible", "keepIfPossibleVars", "prototype", "previous", "activatedFormula", "$activatedFormulas", "thisAndPreviousStates", "toSet", "formulaHasProposedValueInInput", "some", "proposedVars", "isProposed", "concat", "uniqueOnlyBy", "el", "totalWeight", "weight", "isOverwrittenByFormulas", "size", "usedInFormulas", "preferFormula", "formula1", "formula2", "allInputsHasProposed1", "formulaAllInputsHasProposed", "allInputsHasProposed2", "countInputsWithProposedOrKeep1", "formulaCountInputsWithProposedOrKeep", "countInputsWithProposedOrKeep2", "formulaAllInputsHasProposedOrKeep", "every", "formulaIsApplicable", "everyFormulaInputHasValue", "formulaIsInsignificant", "outputVariableAlreadyCalculated", "outputVariableHasPreviousValue", "unvisitedFormulas", "bind", "isFinal", "firstFormula", "BreakCurrentStackExecution", "Effect", "ProposedOrPreviousSymbol", "ProposedOrPrevious", "handler", "RejectSymbol", "RejectEffect", "Reject", "reason", "TransactionSymbol", "GetTransaction", "OwnQuarkSymbol", "OwnQuark", "OwnIdentifierSymbol", "OwnIdentifier", "WriteSymbol", "WriteEffect", "Write", "identifier", "proposedValue", "proposedArgs", "WriteSeveralSymbol", "WriteSeveralEffect", "WriteSeveral", "writes", "PreviousValueOfSymbol", "PreviousValueOfEffect", "PreviousValueOf", "ProposedValueOfSymbol", "ProposedValueOfEffect", "ProposedValueOf", "HasProposedValueSymbol", "HasProposedValueEffect", "HasProposedNotPreviousValueSymbol", "HasProposedNotPreviousValueEffect", "HasProposedNotPreviousValue", "ProposedOrPreviousValueOfSymbol", "ProposedOrPreviousValueOfEffect", "ProposedOrPreviousValueOf", "ProposedArgumentsOfSymbol", "ProposedArgumentsOfEffect", "ProposedArgumentsOf", "UnsafeProposedOrPreviousValueOfSymbol", "UnsafeProposedOrPreviousValueOfEffect", "UnsafeProposedOrPreviousValueOf", "UnsafePreviousValueOfSymbol", "UnsafePreviousValueOfEffect", "UnsafePreviousValueOf", "CycleResolutionInputChrono", "collectInfo", "Y", "symbol", "ContextSync", "ContextGen", "CalculationGen", "iterator", "iterationResult", "isCalculationStarted", "isCalculationCompleted", "done", "result", "startCalculation", "onEffect", "calculation", "call", "continueCalculation", "cleanupCalculation", "runSyncWithEffect", "runAsyncWithEffect", "SynchronousCalculationStarted", "calculationStartedConstant", "CalculationSync", "runGeneratorSyncWithEffect", "effect", "scope", "gen", "iteration", "runGeneratorAsyncWithEffect", "effectResolution", "repeat", "e", "EdgeType", "ORIGIN_ID", "Quark", "MixinAny", "createdAt", "proposedIsPrevious", "proposedArguments", "usedProposedOrPrevious", "origin", "originId", "needToBuildProposedValue", "edgesFlow", "promise", "$outgoingPast", "props", "instance", "assign", "level", "forceCalculation", "cleanup", "isShadow", "resetToEpoch", "epoch", "clearOutgoing", "proposedValueIsBuilt", "TombStone", "copyFrom", "clearProperties", "mergePreviousOrigin", "latestScope", "outgoing", "getOutgoing", "quark", "latest", "outgoingPast", "getOutgoingPast", "setOrigin", "getOrigin", "startOrigin", "addOutgoingTo", "toQuark", "type", "Normal", "getValue", "setValue", "hasValue", "hasProposedValueInner", "getProposedValue", "transaction", "buildProposedValue", "outgoingInTheFutureCb", "revision", "getLatestEntryFor", "outgoingInTheFutureAndPastCb", "latestEntry", "outgoingInTheFutureAndPastTransactionCb", "getLatestStableEntryFor", "outgoingInTheFutureTransactionCb", "Levels", "Meta", "lazy", "total", "pure", "equality", "v1", "v2", "DependsOnSelfKind", "Identifier", "isWritingUndefined", "newQuark", "quarkClass", "write", "me", "getWriteTarget", "graph", "isWritingPreviousData", "writeToTransaction", "writeToGraph", "readFromGraphAsync", "readAsync", "readFromGraph", "read", "readFromTransaction", "readFromTransactionAsync", "enterGraph", "leaveGraph", "IdentifierC", "config", "QuarkSync", "mix", "QuarkGen", "Variable", "YIELD", "UserInput", "VariableC", "CalculatedValueSync", "CalculatedValueSyncC", "CalculatedValueGen", "CalculatedValueGenC", "throwUnknownIdentifier", "CLOCK", "Revision", "reachableCount", "referenceCount", "selfDependent", "entry", "hasIdentifier", "previousAxis", "LeveledQueue", "levels", "lowestLevel", "getLowestLevel", "takeLowestLevel", "elLevel", "ComputationCycle", "toString", "cycleIdentifiers", "cycleEvents", "event", "id", "join", "TransactionCycleDetectionWalkContext", "doCollectNext", "to", "visit", "outgoingEntry", "TransactionWalkDepth", "baseRevision", "pushTo", "startNewEpoch", "outgoingIdentifier", "keys", "EdgeTypeNormal", "EdgeTypePast", "Past", "Transaction", "candidateClass", "candidate", "isClosed", "entries", "stackGen", "activeStack", "onEffectSync", "onEffectAsync", "propagationStartDate", "lastProgressNotificationDate", "startProgressNotificationsAfterMs", "emitProgressNotificationsEveryMs", "emitProgressNotificationsEveryCalculations", "plannedTotalIdentifiersToCalculate", "ongoing", "selfDependedMarked", "rejectedWith", "stopped", "hasEntryWithProposedValue", "hasVariableEntry", "dirty", "markSelfDependent", "selfDependentIden", "existing", "touch", "getActiveEntry", "yieldAsync", "yieldSync", "activeEntry", "addEdge", "previousEntry", "calculateTransitionsStackGen", "value1", "calculateTransitionsStackSync", "sync", "readCurrentOrProposedOrPrevious", "dirtyQuark", "readPrevious", "readCurrentOrProposedOrPreviousAsync", "readPreviousAsync", "readProposedOrPrevious", "readProposedOrPreviousAsync", "acquireQuarkIfExists", "existingEntry", "addIdentifier", "alreadyHadEntry", "isVariable", "removeIdentifier", "delete", "populateCandidateScopeFromTransitions", "toIdentifier", "preCommit", "Date", "now", "postCommit", "commit", "calculateTransitionsSync", "reject", "rejection", "stop", "clearRejected", "commitAsync", "calculateTransitions", "identifierRead", "onQuarkCalculationCompleted", "sameAsPrevious", "previousOutgoingEntry", "ignoreSelfDependency", "onReadIdentifier", "requestedEntry", "queue", "enableProgressNotifications", "counter", "prevActiveStack", "onPropagationProgressNotification", "remaining", "phase", "startedAtEpoch", "onReadIdentifierResult", "onComputationCycleHandler", "effectResult", "onComputationCycleHandlerSync", "CommitZero", "Listener", "handlers", "trigger", "ChronoGraph", "baseRevisionStable", "baseRevisionTentative", "topRevision", "historyLimit", "listeners", "$activeTransaction", "isCommitting", "_isInitialCommit", "autoCommitTimeoutId", "autoCommit", "autoCommitMode", "autoCommitHandler", "onWriteDuringCommit", "onComputationCycle", "transactionClass", "isJustCleared", "$followingRevision", "arg", "markAndSweep", "hasPendingAutoCommit", "activeTransaction", "unScheduleAutoCommit", "eachReachableRevision", "isBetweenTopBottom", "isInitialCommit", "lastReferencedRevision", "unreachableRevisions", "isReachable", "unshift", "compactRevisions", "newRev", "prevRev", "prevQuark", "followingRevision", "revisions", "branch", "propagate", "transactionCommitResult", "finalizeCommit", "propagateAsync", "doCommitAsync", "res", "finally", "transactionResult", "rejectedDuringCommit", "prevBaseTentative", "finalizeCommitAsync", "quarkEntry", "listener", "exception", "console", "log", "message", "scheduleAutoCommit", "clearTimeout", "variableNamed", "identifierNamed", "observe", "observerFunc", "onUpdated", "addListener", "observeContext", "undo", "redo", "nextRevision", "notification", "writeToHigherLevel", "writeInfo", "source", "EntityMeta", "ownFields", "schema", "$skeleton", "$allFields", "hasField", "getField", "allFields", "addField", "field", "entity", "forEachParent", "parentEntity", "forEachField", "ReadMode", "Replica", "readMode", "Current", "addEntity", "addEntities", "entities", "removeEntity", "removeEntities", "FieldIdentifier", "self", "DATA", "getFromGraph", "Previous", "MinimalFieldIdentifierSync", "MinimalFieldIdentifierGen", "MinimalFieldVariable", "EntityIdentifier", "MinimalEntityIdentifier", "Field", "persistent", "getIdentifierClass", "calculationFunction", "identifierCls", "isEntityMarker", "Entity", "$entity", "createEntityOnPrototype", "$", "createFieldIdentifier", "$$", "$entityName", "calculateSelf", "skeleton", "getIdentifierTemplateClass", "forEachFieldIdentifier", "replica", "ownGraph", "removeFrom", "ensureEntityOnPrototype", "hasOwnProperty", "$calculations", "writeFunction", "$writes", "buildProposedFunction", "$buildProposed", "template", "TemplateClass", "run", "methodName", "createPropertyAccessorsFor", "fieldName", "createMethodAccessorsFor", "getterFnName", "setterFnName", "putterFnName", "proto", "parent", "getPrototypeOf", "generic_field", "fieldConfig", "fieldCls", "cons", "calculate", "_descriptor", "calculations", "create", "build_proposed", "buildProposed", "ReferenceField", "MinimalReferenceIdentifier", "reference", "ReferenceIdentifier", "hasBucket", "bucket", "getBucket", "isInstanceOf", "addToBucket", "locator", "resolver", "removeFromBucket", "q", "prevValue", "DependsOnlyOnUserInput", "ReferenceBucketField", "MinimalReferenceBucketIdentifier", "BucketMutationType", "ReferenceBucketQuark", "mutations", "previousValue", "MinimalReferenceBucketQuark", "ReferenceBucketIdentifier", "Add", "preQuark", "Remove", "quarkArg", "newValue", "DependsOnlyOnDependsOnlyOnUserInput", "Schema", "hasEntity", "getEntity", "getEntityDecorator", "entityDecoratorBody", "isSerializableEqual", "oldValue", "isBase", "serialize", "ModelField", "modelFieldConfig", "MinimalChronoModelFieldIdentifierGen", "MinimalChronoModelFieldIdentifierSync", "MinimalChronoModelFieldVariable", "ModelReferenceField", "ChronoModelReferenceFieldIdentifier", "ModelBucketField", "ChronoModelReferenceBucketFieldIdentifier", "IsChronoModelSymbol", "ChronoModelFieldIdentifier", "superProto", "CurrentOrProposedOrPrevious", "_graph$activeTransact", "higherLevel", "Number", "MAX_SAFE_INTEGER", "project", "isDelayingCalculation", "inSetting", "isConstructing", "convert", "fieldDefinition", "getFieldDefinition", "data", "converter", "getTime", "ChronoModelReferenceFieldQuark", "failedResolutionReferences", "resolved", "model_field", "chronoFieldConfig", "chronoFieldClass", "injectStaticFieldsProperty", "getDecoratedModelFields", "constr", "dateConverter", "$chrono", "date", "_field$modelFieldConf", "_field$modelFieldConf2", "DateHelper", "parse", "format", "dateFormat", "defaultParseFormat", "ChronoModelMixin", "Model", "isEntity", "construct", "exposeProperties", "originalData", "userProvidedValue", "copy", "newId", "deep", "creatingOccurrence", "ObjectHelper", "isObject", "skipFieldIdentifiers", "_this$getFieldDefinit", "applyValue", "useProp", "skipAccessors", "isInActiveTransaction", "_this$graph", "_data", "fields", "generation", "dataSource", "complexMapping", "getPath", "className", "locale", "localeName", "localeDesc", "localeCode", "RemoveDependencyCycleEffectResolution", "descriptionTpl", "DeactivateDependencyCycleEffectResolution", "CycleEffectDescription", "EmptyCalendarEffectDescription", "Use24hrsEmptyCalendarEffectResolution", "Use8hrsEmptyCalendarEffectResolution", "ConflictEffectDescription", "ConstraintIntervalDescription", "ProjectConstraintIntervalDescription", "startDateDescriptionTpl", "endDateDescriptionTpl", "DependencyType", "long", "ManuallyScheduledParentConstraintIntervalDescription", "startDescriptionTpl", "endDescriptionTpl", "DisableManuallyScheduledConflictResolution", "DependencyConstraintIntervalDescription", "RemoveDependencyResolution", "DeactivateDependencyResolution", "DateConstraintIntervalDescription", "constraintTypeTpl", "startnoearlierthan", "finishnoearlierthan", "muststarton", "mustfinishon", "startnolaterthan", "finishnolaterthan", "RemoveDateConstraintConflictResolution", "LocaleHelper", "publishLocale", "DateInterval", "startDate", "MIN_DATE", "endDate", "MAX_DATE", "equalTo", "another", "isInfinite", "startDateIsFinite", "isIntervalEmpty", "endDateIsFinite", "containsDate", "edgeInclusion", "EdgeInclusion", "Left", "Right", "intersect", "anotherStart", "anotherEnd", "start", "end", "EMPTY_INTERVAL", "newStart", "max", "newEnd", "min", "intersectMut", "collectIntersectionMeta", "_another$intersection", "intersectionOf", "intersectedAsEmpty", "getCopyProperties", "copyWith", "copyData", "intersectIntervals", "dateIntervals", "acc", "currentInterval", "EffectResolutionResult", "SchedulingIssueEffectResolution", "getDescription", "SchedulingIssueEffect", "getResolutions", "_resolutions", "getDescriptionBuilderClass", "_descriptionBuilderClass", "setDescriptionBuilderClass", "cls", "ConflictSymbol", "Localizable", "$name", "conflict", "L", "intervals", "ConflictEffect", "filterConflictingIntervals", "interval", "intervalsArray", "affectedInterval", "find", "isAffectedByTransaction", "sorted", "a", "b", "conflictingInterval", "ConflictResolution", "getDescriptionParameters", "ConstraintInterval", "owner", "reflectionOf", "side", "resolutions", "isConstraintInterval", "descriptionBuilderClass", "ChronoPartOfProjectGenericMixin", "AbstractPartOfProjectGenericMixin", "getGraph", "getProject", "getEventById", "_this$getEventStore", "getEventStore", "getById", "getDependencyById", "_this$getDependencySt", "getDependencyStore", "getResourceById", "_this$getResourceStor", "getResourceStore", "getAssignmentById", "_this$getAssignmentSt", "getAssignmentStore", "getCalendarById", "_this$getCalendarMana", "getCalendarManagerStore", "ChronoStoreMixin", "Store", "ChronoPartOfProjectStoreMixin", "AbstractPartOfProjectStoreMixin", "removalOrder", "setStoreData", "_this$project", "repopulateStore", "register", "record", "_this$project2", "_this$project3", "isRoot", "scheduleDelayedCalculation", "onModelChange", "wasSet", "silent", "fromRelationUpdate", "syncDataOnLoad", "isLoadingData", "ChronoPartOfProjectModelMixin", "AbstractPartOfProjectModelMixin", "joinProject", "delayEnteringReplica", "leaveProject", "isReplacing", "calculateProject", "store", "stores", "s", "_graph", "hasMixin", "EmptyCalendarSymbol", "BaseCalendarMixin", "AbstractCalendarMixin", "version", "defaultValue", "calendar", "getCalendar", "EmptyCalendarEffect", "calendars", "skipNonWorkingTime", "isForward", "BaseEmptyCalendarEffectResolution", "calendarData", "isWorking", "fixCalendarData", "_calendar$intervals", "clearIntervals", "addIntervals", "unspecifiedTimeIsWorking", "recurrentStartDate", "recurrentEndDate", "CycleSymbol", "EngineRevision", "EngineTransaction", "_props$graph$project", "delayCalculation", "failedResolutionValue", "EngineReplica", "cycleEffectClass", "CycleEffect", "silenceInitialCommit", "ignoreInitialCommitComputationCycles", "_this$project$trigger", "isDestroyed", "_onComputationCycle", "replacedReplicaResult", "beforeCommitAsync", "_identifier$field", "_record$beforeChronoF", "_record$afterChronoFi", "beforeHookResult", "beforeChronoFieldSet", "afterChronoFieldSet", "autoCommitStores", "globalThis", "DEBUG", "timeEnd", "silenceCommit", "isInitialCommitPerformed", "isWritingData", "hasLoadedDataToCommit", "isCalculated", "_project$suspendChang", "_project$resumeChange", "suspendChangesTracking", "time", "records", "quarkValue", "firstStore", "beginBatch", "suspendAutoCommit", "meta", "batchChanges", "prevented", "triggerBeforeUpdate", "cancelBatch", "ignoreBag", "ignoreRecordChanges", "endBatch", "resumeChangesTracking", "resumeAutoCommit", "eventStore", "acceptChanges", "dependencyStore", "resourceStore", "assignmentStore", "calendarManagerStore", "onCycleSchedulingIssue", "onEmptyCalendarSchedulingIssue", "onConflictSchedulingIssue", "dependency", "remove", "getShortDescription", "events", "getEvents", "_events", "matchDependencyBySourceAndTargetEvent", "fromEvent", "toEvent", "getDependencyForSourceAndTargetEvents", "getDependencies", "_dependencies", "numberOfEvents", "prevEvent", "event1", "event2", "removeDependencyCycleEffectResolutionClass", "BaseAssignmentMixin", "isEqual", "persist", "resource", "ChronoAssignmentStoreMixin", "AbstractAssignmentStoreMixin", "defaultConfig", "modelClass", "allAssignmentsForRemoval", "ChronoCalendarManagerStoreMixin", "AbstractCalendarManagerStoreMixin", "tree", "ChronoDependencyStoreMixin", "AbstractDependencyStoreMixin", "allDependenciesForRemoval", "Instruction", "StartDateVar", "EndDateVar", "DurationVar", "startDateFormula", "endDateFormula", "durationFormula", "SEDGraphDescription", "SEDForwardCycleResolutionContext", "SEDBackwardCycleResolutionContext", "SEDDispatcher", "addInstruction", "instruction", "KeepStartDate", "KeepEndDate", "KeepDuration", "SEDDispatcherIdentifier", "resolution1", "resolution2", "HasCalendarMixin", "writeCalendar", "cal", "includes", "resolveCalendar", "calculateEffectiveCalendar", "effectiveCalendar", "shouldRecordFieldChange", "oldIdMap", "CanCombineCalendarsMixin", "CanCombineCalendars", "combinedcalendarscache", "combineCalendars", "stripDuplicates", "calendar1", "calendar2", "internalId", "versionsHash", "CalendarCacheMultiple", "calendarCaches", "calendarCache", "BaseEventMixin", "calculateDispatcher", "cycleDispatcher", "prepareDispatcher", "startDateProposedArgs", "startInstruction", "endDateProposedArgs", "endInstruction", "directionValue", "direction", "durationProposedArgs", "duration", "durationInstruction", "Direction", "Forward", "None", "dispatcherClass", "cycleResolutionContext", "buildProposedDispatcher", "dispatcher", "skippingRes", "skipWorkingTime", "unit", "durationUnit", "$convertDuration", "calculateProjectedXDateWithDuration", "setStartDate", "keepDuration", "delayedCalculationPromise", "writeStartDate", "isStmRestoring", "unscheduled", "calculateStartDate", "calculateStartDateProposed", "calculateStartDatePure", "manuallyScheduled", "skipNonWorkingTimeWhenSchedulingManually", "baseDate", "isNotNumber", "calculateEndDate", "TimeUnit", "Millisecond", "setEndDate", "writeEndDate", "calculateEndDateProposed", "calculateEndDatePure", "getDuration", "convertDuration", "setDuration", "keepStart", "setDurationUnit", "_value", "writeDuration", "calculateDuration", "calculateDurationProposed", "calculateDurationPure", "calculateProjectedDuration", "calculateDurationMs", "calculateEffectiveDuration", "dispatch", "effectiveDurationToUse", "durationResolution", "skipNonWorkingTimeInDurationWhenSchedulingManually", "defaultCalendar", "allowNull", "Day", "normalizeUnit", "BaseHasAssignmentsMixin", "AbstractHasAssignmentsMixin", "assignments", "assigned", "HasDependenciesMixin", "toRemove", "dep", "outgoingDeps", "incomingDeps", "SchedulerBasicEvent", "ChronoEventStoreMixin", "AbstractEventStoreMixin", "afterEventRemoval", "ChronoEventTreeStoreMixin", "buildRootNode", "BaseResourceMixin", "assignment", "assignmentsForRemoval", "ChronoResourceStoreMixin", "AbstractResourceStoreMixin", "DurationConverterMixin", "calculateUnitsInMs", "hoursPerDay", "daysPerWeek", "daysPerMonth", "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year", "fromUnit", "toUnit", "unitsInMs", "BaseDependencyMixin", "isValid", "EndToStart", "ChronoAbstractProjectMixin", "AbstractProjectMixin", "enterReplica", "enterRecords", "_this$replica", "getSchedulingIssueEventArguments", "schedulingIssue", "continueWithResolutionResult", "onSchedulingIssueCall", "hasListener", "setModelCalculations", "model", "oldValues", "setRecordCalculations", "setStoreCalculations", "first", "setCalculations", "oldCalculations", "tasks", "dependencies", "resources", "projectCalculations", "repopulateReplica", "HasSubEventsMixin", "hasSubEvents", "subEventsIterable", "calculateMinChildrenStartDate", "calculateMaxChildrenEndDate", "shouldRollupChildStartDate", "child", "children", "timestamp", "shouldRollupChildEndDate", "HasChildrenMixin", "childEvents", "_parent", "parentEvent", "SchedulerBasicProjectMixin", "expanded", "repopulateStores", "warn", "eventModelClass", "getDefaultEventModelClass", "eventStoreClass", "getDefaultEventStoreClass", "dependencyModelClass", "getDefaultDependencyModelClass", "dependencyStoreClass", "getDefaultDependencyStoreClass", "resourceModelClass", "getDefaultResourceModelClass", "resourceStoreClass", "getDefaultResourceStoreClass", "assignmentModelClass", "getDefaultAssignmentModelClass", "assignmentStoreClass", "getDefaultAssignmentStoreClass", "calendarModelClass", "getDefaultCalendarModelClass", "calendarManagerStoreClass", "getDefaultCalendarManagerStoreClass", "getDefaultCycleEffectClass", "initializeStm", "setCalendarManagerStore", "setEventStore", "setDependencyStore", "setResourceStore", "setAssignmentStore", "calendarsData", "eventsData", "dependenciesData", "resourcesData", "assignmentsData", "loadInlineData", "hasDataInStores", "allCount", "createReplica", "isRepopulatingStores", "includeFilteredOutRecords", "resetStmQueue", "wasDisabled", "stm", "disabled", "disable", "resetQueue", "enable", "doDestroy", "_me$eventStore", "_me$dependencyStore", "_me$assignmentStore", "_me$resourceStore", "_me$calendarManagerSt", "_me$defaultCalendar", "_me$replica", "_me$stm", "destroy", "getReplicaConfig", "getRange", "getType", "ProjectType", "SchedulerBasic", "_enableProgressNotifications", "usingSyncDataOnLoad", "isLoadingInlineData", "tasksData", "applyProjectResponse", "commitLoad", "setupTemporaryIndices", "storage", "addIndex", "unique", "removeTemporaryIndices", "removeIndex", "internalDelayCalculation", "stmClass", "StateTrackingManager", "setStm", "resetUndoRedoQueuesAfterLoad", "ion", "load", "thisObj", "beforeCommit", "onCommitInitialization", "commitFinalized", "onCommitFinalization", "commitRejected", "onCommitRejection", "removeRejectedRecordsAdd", "_this$suspendChangesT", "_this$resumeChangesTr", "recordsToDrop", "_transactionResult$tr", "_stmDisabled", "isRestoringData", "rejectStmTransaction", "isRecording", "autoRecord", "_stmAutoRecord", "onSTMRestoringStart", "onSTMRestoringStop", "deferUntilRepopulationIfNeeded", "deferId", "detachListeners", "fn", "once", "_this$repopulateStore", "repopulateOnDataset", "_me$replica2", "oldReplica", "unlinkStoreRecords", "unlinkRecord", "joinStoreRecords", "isPending", "traverse", "includeCollapsedGroupRecords", "addEvents", "addEvent", "includeEvent", "removeEvents", "excludeEvent", "removeEvent", "getStm", "restoringStart", "restoringStop", "skipRoot", "setProject", "rootNode", "unjoinStoreRecords", "oldEventStore", "hasStore", "removeStore", "detachStore", "oldEvent", "newEvent", "storeClass", "addStore", "appendChild", "attachStore", "oldDependencyStore", "oldResourceStore", "oldResource", "newResource", "afterResourceRemoval", "oldAssignmentStore", "oldCalendarManagerStore", "isValidDependency", "forEachStore", "rejectTransaction", "stopTransaction", "tryPropagateWithChanges", "changerFn", "stmInitiallyDisabled", "stmInitiallyAutoRecord", "startTransaction", "test", "isEngineReady", "delayable", "applyConfigs", "calculateEffectiveStartDateConstraintInterval", "startDateIntervalIntersection", "endDateIntervalIntersection", "reflectedIntervals", "originInterval", "ConstraintIntervalSide", "Start", "End", "calculateEffectiveEndDateConstraintInterval", "EarlyLateLazyness", "ConstrainedEarlyEventMixin", "maybeSkipNonWorkingTime", "calculateEffectiveConstraintInterval", "isStartDate", "startDateConstraintIntervals", "endDateConstraintIntervals", "calculateStartDateConstraintIntervals", "calculateEndDateConstraintIntervals", "calculateEarlyStartDateConstraintIntervals", "calculateEarlyEndDateConstraintIntervals", "doCalculateEarlyEffectiveStartDateInterval", "earlyStartDateConstraintIntervals", "earlyEndDateConstraintIntervals", "calculateEarlyEffectiveStartDateInterval", "doCalculateEarlyEffectiveEndDateInterval", "calculateEarlyEffectiveEndDateInterval", "shouldRollupChildEarlyStartDate", "calculateMinChildrenEarlyStartDate", "subEventsIterator", "childEvent", "childDate", "minChildrenEarlyStartDate", "earlyStartDate", "shouldRollupChildEarlyEndDate", "calculateMaxChildrenEarlyEndDate", "maxChildrenEarlyEndDate", "earlyEndDate", "calculateEarlyStartDateRaw", "isConstrainedEarly", "effectiveInterval", "earlyEffectiveStartDateInterval", "isDateFinite", "calculateEarlyStartDate", "earlyStartDateRaw", "calculateEarlyEndDateRaw", "earlyEffectiveEndDateInterval", "calculateEarlyEndDate", "earlyEndDateRaw", "startDateIntervals", "endDateIntervals", "autoStartDate", "baseSchedulingStartDate", "autoEndDate", "baseSchedulingEndDate", "calculateDirection", "HasDateConstraintMixin", "HasDateConstraint", "ignorePinningConstraint", "addConstraintOnDateSet", "isSyncingDataOnLoad", "isReverting", "isRestoring", "constrainType", "getStartDatePinConstraintType", "constraintType", "constraintDate", "getEndDatePinConstraintType", "calculateConstraintType", "isConstraintTypeApplicable", "calculateConstraintDate", "getConstraintTypeDefaultDate", "isTaskPinnableWithConstraint", "ConstraintType", "StartNoEarlierThan", "Backward", "StartNoLaterThan", "FinishNoEarlierThan", "FinishNoLaterThan", "applyChangeset", "rawChanges", "phantomIdField", "remote", "MustStartOn", "MustFinishOn", "setConstraint", "dateConstraintIntervalClass", "getConstraintName", "tpl", "DateConstraintInterval", "constraintDateQuark", "constraintTypeQuark", "removeDateConstraintConflictResolutionClass", "ScheduledByDependenciesEarlyEventMixin", "shouldPredecessorAffectScheduling", "active", "inactive", "dependencyConstraintIntervalClass", "predecessor", "predecessorDate", "StartToStart", "lag", "lagUnit", "EndToEnd", "StartToEnd", "BaseDependencyResolution", "DependencyConstraintInterval", "fromEventQuark", "toEventQuark", "lagQuark", "lagUnitQuark", "typeQuark", "deactivateDependencyConflictResolutionClass", "removeDependencyConflictResolutionClass", "SchedulerProAssignmentMixin", "calculateUnits", "calculateAssignmentUnits", "calculateEffort", "calculateProjectedEffort", "calculateActualDate", "percentDone", "calculateActualEffort", "actualDate", "assignmentsByCalendar", "SchedulerProDependencyMixin", "calculateCalendar", "dependenciesCalendar", "DependenciesCalendar", "Project", "FromEvent", "ToEvent", "setLag", "writeLag", "HasPercentDoneMixin", "calculatePercentDone", "autoCalculatePercentDoneForParentTasks", "summaryData", "percentDoneSummaryData", "totalDuration", "completedDuration", "milestonesNum", "milestonesTotalPercentDone", "shouldRollupChildPercentDoneSummaryData", "calculatePercentDoneSummaryData", "summary", "childSummaryData", "durationInMs", "SchedulerProHasAssignmentsMixin", "hasProposedValueForUnits", "units", "assignmentCls", "addAssignment", "forEachAvailabilityInterval", "options", "effectiveCalendarsCombination", "ignoreResourceCalendar", "maxRange", "maxCalendarRange", "calendarCacheIntervalMultiple", "calendarsStatus", "getCalendarsWorkStatus", "workCalendars", "getCalendarsWorking", "calculateEffectiveCalendarsCombination", "calculateAssignmentsByCalendar", "resourceCalendar", "getBaseOptionsForDurationCalculations", "useEventAvailabilityIterator", "iteratorOptions", "workingDate", "skipRes", "CalendarIteratorResult", "MaxRangeReached", "FullRangeIterated", "adjustDurationToDST", "dstDiff", "getTimezoneOffset", "isNaN", "durationMS", "resultN", "leftDuration", "intervalStart", "intervalEnd", "intervalStartN", "intervalEndN", "intervalDuration", "StoppedByIterator", "accumulateWorkingTime", "finalDate", "MasterStartDateVar", "MasterEndDateVar", "MasterDurationVar", "MasterTotalDurationVar", "StartOffsetVar", "EndOffsetVar", "durationByOffsetsFormula", "startDateByMasterStartAndStartOffsetFormula", "endDateByMasterStartAndEndOffsetFormula", "startOffsetByMasterStartAndStartDateFormula", "endOffsetByMasterStartAndEndDateFormula", "startOffsetByEndOffsetAndDurationFormula", "endOffsetByStartOffsetAndDurationFormula", "endOffsetByMasterTotalDurationAndStartOffsetFormula", "endOffsetByMasterDurationAndStartOffsetFormula", "durationByMasterEndDateFormula", "segmentCycleDescription", "segmentCycleResolution", "SegmentSEDDispatcherIdentifier", "SchedulerProEventSegment", "isEventSegment", "_this$event", "previousSegment", "nextSegment", "shift", "endOffset", "startOffset", "segment", "calculateStartOffset", "calculateStartOffsetByEndOffsetAndDuration", "masterStartDate", "ignoreSegments", "calculateEndOffset", "calculateEndOffsetByStartOffsetAndDuration", "calculateEndOffsetByMasterDurationAndStartOffset", "calculateEndOffsetByMasterTotalDurationAndStartOffset", "calculateStartDateByMasterStartAndStartOffset", "calculateEndDateByMasterStartAndEndOffset", "calculateDurationByOffsets", "segments", "masterEndDateArgs", "masterDispatcher", "masterDuration", "masterDurationUnit", "masterDurationMs", "segmentStartOffset", "segmentDurationMs", "masterEndDate", "masterTotalDurationMs", "rawDate", "masterPercentDone", "completeMasterDurationMs", "calculateMinPercent", "endPercentDone", "calculateMaxPercent", "startPercentDone", "calculateManuallyScheduled", "SegmentsVar", "segmentsConverter", "processSegmentsValue", "startDateByEndDateAndSegmentsFormula", "endDateByStartDateAndSegmentsFormula", "SEDSGGraphDescription", "SEDSGForwardCycleResolution", "SEDSGBackwardCycleResolution", "SEDSGDispatcherIdentifier", "compareSegmentsArray", "_skipSegmentsIsEqual", "compareSegments", "fieldMap", "isModel", "aStart", "bStart", "aEnd", "bEnd", "SplitEventMixin", "_segmentGeneration", "segmentModelClass", "getDefaultSegmentModelClass", "rawModifications", "getFieldPersistentValue", "clearChanges", "includeDescendants", "removeFromStoreChanges", "changes", "hasSegmentChangesProposed", "proposedSegments", "startDateProposed", "endDateProposed", "durationProposed", "writeSegments", "_transaction$getLates", "oldSegmentsQuarkValue", "oldSegments", "oldSegmentsSet", "newSegments", "newSegmentsSet", "isSegmented", "newSegment", "doWriteSegments", "calculateSegments", "_segments", "hasChanges", "prevEndOffset", "previousSegmentStartOffset", "previousSegmentEndOffset", "segmentIndex", "calculateAdjustedSegments", "toWrite", "spliceIndex", "segmentStartDate", "segmentEndDate", "durationMs", "splice", "segmentsSnapshot", "getSegmentsSnapshot", "_lastSegmentsSnapshot", "_segments2", "_segment$startDate", "_segment$endDate", "calculateStartDateBySegments", "lastSegmentEndOffset", "calculateEndDateBySegments", "calculateDurationBySegments", "sign", "currentSegment", "currentOffsetMs", "currentSegmentDurationMs", "currentSegmentEndOffset", "intervalStartDate", "intervalEndDate", "startDateN", "intervalStartOffset", "intervalEndOffset", "callStartOffset", "callEndOffset", "callStartDate", "callEndDate", "getSegmentByDate", "getSegments", "getSegmentIndexByDate", "findIndex", "firstSegment", "lastSegment", "getSegment", "splitToSegments", "_me$childEvents", "isHasSubEventsMixin", "segmentToSplit", "segmentToSplitIndex", "splitTarget", "splitTargetStart", "splitTargetDuration", "splitTargetDurationUnit", "prevSegmentDuration", "nextSegmentDuration", "lagInMs", "nextSegmentStartOffset", "l", "mergeSegments", "segment1", "segment2", "tmp", "storeFieldChange", "segmentData", "toJSON", "modified", "seg", "HasEffortMixin", "getEffort", "effort", "effortUnit", "writeEffort", "setEffortUnit", "shouldRollupChildEffort", "calculateTotalChildrenEffort", "totalEffortMs", "childEventEffortUnit", "proposed", "calculateEffortPure", "calculateEffortProposed", "calculateAssignmentUnitsProposed", "calculateAssignmentUnitsPure", "calculateUnitsByStartEndAndEffort", "getBaseOptionsForEffortCalculations", "totalUnitsByCalendar", "intervalUnits", "workingCalendar", "_assignment", "effortMS", "collectedEffort", "calculateProjectedXDateByEffort", "leftEffort", "hasUnits", "intervalEffort", "Hour", "EffortVar", "UnitsVar", "effortFormula", "unitsFormula", "endDateByEffortFormula", "startDateByEffortFormula", "SEDWUDispatcher", "SEDWUDispatcherIdentifier", "HasSchedulingModeMixin", "calculateSchedulingMode", "SchedulingMode", "effectiveSchedulingMode", "schedulingMode", "effectiveSchedulingModeSync", "proposedOrPreviousStartDate", "proposedOrPreviousEndDate", "startDateResolution", "endDateResolution", "effortDriven", "fixedDurationSEDWUGraphDescription", "fixedDurationAndEffortSEDWUGraphDescription", "fixedDurationSEDWUForwardNonEffortDriven", "fixedDurationSEDWUForwardEffortDriven", "fixedDurationSEDWUBackwardNonEffortDriven", "fixedDurationSEDWUBackwardEffortDriven", "FixedDurationMixin", "FixedDuration", "SchedulerProEvent", "ResourceAllocationEventRangeCalendarIntervalMixin", "CalendarIntervalMixin", "ResourceAllocationEventRangeCalendarIntervalStore", "CalendarIntervalStore", "ResourceAllocationEventRangeCalendar", "intervalStoreClass", "BaseAllocationInterval", "AssignmentAllocationInterval", "ResourceAllocationInterval", "maxEffort", "isOverallocated", "isUnderallocated", "assignmentIntervals", "BaseAllocationInfo", "getDefaultAllocationIntervalClass", "includeInactiveEvents", "allocationIntervalClass", "ResourceAllocationInfo", "shouldIncludeAssignmentInAllocation", "calculateAllocation", "ticksCalendar", "ticks", "eventRanges", "assignmentTicksData", "byAssignments", "hasIgnoreResourceCalendarEvent", "eventCalendar", "eventRangesCalendar", "ticksData", "intervalStore", "tick", "tickData", "assignmentTickData", "weightedUnitsSum", "weightsSum", "iterationOptions", "includeNonWorkingIntervals", "ticksTotalDuration", "intervalData", "isWorkingCalendar", "intervalsByCalendar", "tickAssignments", "tickAssignmentIntervals", "intervalHasAssignments", "workingStartDate", "workingEndDate", "assignmentInterval", "assignmentEffort", "SchedulerProResourceMixin", "observers", "addObserver", "observer", "removeObserver", "SchedulerProProjectMixin", "eventSegmentModelClass", "getDefaultEventSegmentModelClass", "resourceAllocationInfoClass", "getDefaultResourceAllocationInfoClass", "afterConfigure", "SchedulerPro", "SchedulerProCycleEffect", "validateDependency", "ignoreDependency", "ingoredDependencies", "isArray", "_ingoredDependencies", "DependencyValidationResult", "DuplicatingDependency", "isDependencyCyclic", "CyclicDependency", "NoError", "getDependencyCycleDetectionIdentifiers", "dependencyClass", "all", "isValidDependencyModel", "ignoreDependencies", "getInvalidDependencies", "_invalidDependencies", "contains", "buildInvalidDependencyResolutions", "invalidDependencies", "deactivateDependencyCycleEffectResolutionClass", "ModelCombo", "Combo", "superValue", "v", "initClass", "_$name", "CalendarField", "valueField", "displayField", "editable", "listItemTpl", "displayValueRenderer", "_field$store", "_field$store$project", "_calendar", "isDefault", "throwIfNotTheSameStore", "oldStore", "newStore", "PartOfProject", "Target", "taskStore", "leftProjectEventStore", "leftProject", "_this$project4", "_this$project5", "AssignmentModel", "AssignmentModelMixin", "derive", "_resource", "$original", "eventResourceKey", "buildEventResourceKey", "__publicField", "isProAssignmentModel", "AssignmentStore", "AssignmentStoreMixin", "AjaxStore", "CalendarIntervalModel", "CalendarModel", "internal", "calendarIntervalModelClass", "CalendarManagerStore", "loadPriority", "syncPriority", "storeId", "DependencyModel", "DependencyBaseModel", "isProDependencyModel", "DependencyStore", "DependencyStoreMixin", "PercentDoneMixin", "isStarted", "isCompleted", "isInProgress", "renderedPercentDone", "getFormattedPercentDone", "round", "floor", "EventSegmentModel", "TimeSpan", "mixin", "EventModelMixin", "task", "EventUpdateAction", "UpdateAction", "newData", "oldData", "oldDataSegments", "newDataSegments", "newDataIndex", "indexOf", "ResourceModel", "ResourceModelMixin", "GridRowModel", "_project$assignmentSt", "_indices", "findItem", "ResourceStore", "ResourceStoreMixin", "makeModelUpdateAction", "isSplitEventMixin", "CoreStateTrackingManager", "VersionModel", "onBeforeSave", "_a", "defaultDescription", "isAutosave", "savedAt", "VersionStore", "ChangeLogTransactionModel", "actions", "actionTypes", "ArrayHelper", "actionType", "startsWith", "entityTypes", "entityCount", "transactionDescriptions", "entityNames", "entityNamesPlural", "firstEntityType", "assortedEntityTypes", "replace", "other", "ChangeLogStore", "ProjectCrudManager", "SchedulerProjectCrudManager", "crudLoadValidationWarningPrefix", "crudSyncValidationWarningPrefix", "trackProjectModelChanges", "addPrioritizedStore", "timeRangeStore", "resourceTimeRangeStore", "crudLoadValidationMandatoryStores", "getStoreDescriptor", "loadCrudManagerData", "revertChanges", "revertCrudStoreChanges", "crudStoreHasChanges", "getCrudStore", "hasPersistableChanges", "projectChanges", "modificationDataToWrite", "shouldClearRecordFieldChange", "isCalendarModel", "EventResize", "SchedulerEventResize", "render", "client", "dragSelector", "dragItemSelector", "eventSelector", "GridFeatureManager", "registerFeature", "EventSegmentResize", "pluginConfig", "chain", "isEventSegmentElementDraggable", "eventElement", "eventRecord", "isEventElementDraggable", "eventResizable", "resizable", "isMilestone", "eventName", "scheduledEventName", "segmentRecord", "segmentResizable", "segmentElement", "DomSync", "getChild", "isOverStartHandle", "isOverEndHandle", "tipId", "dragStart", "drag", "_segmentsSlices", "_segmentsSlicesIndex", "beginEventRecordBatch", "triggerBeforeResize", "resolveTimeSpanRecord", "itemElement", "capitalizedEventName", "getBeforeResizeParams", "startEvent", "element", "triggerEventResizeStart", "eventType", "triggerEventResizeEnd", "triggerEventPartialResize", "triggerBeforeEventResizeFinalize", "applyDateConstraints", "_context$dateConstrai", "_context$dateConstrai2", "minDate", "dateConstraints", "maxDate", "constrain", "snappedDate", "resizeEventPartiallyInternal", "segmentsField", "cancelEventRecordBatch", "highlightHandle", "overItem", "classList", "unHighlightHandle", "item", "resizingItemInnerCls", "draggingItemCls", "EventSegments", "InstancePlugin", "onElementMouseOut", "relatedTarget", "eventWrap", "closest", "timeSpanRecord", "hoveredEvents", "DomHelper", "isDescendant", "overridden", "getElementsFromEventRecord", "resourceRecord", "mainEventElement", "resolveEventRecord", "elementOrEvent", "_result", "Event", "dataset", "resolveTaskRecord", "_result2", "populateTaskMenu", "taskRecord", "targetElement", "feature", "populateEventMenu", "items", "domEvent", "readOnly", "isParent", "milestone", "localeClass", "text", "icon", "separator", "onItem", "splitEvent", "renameSegment", "rename", "getSplitDate", "timeAxis", "roundDate", "getSplitDuration", "splitDuration", "minSplitDuration", "maxSplitDuration", "magnitude", "splitUnit", "getSplitDurationUnit", "splitDurationMS", "maxDurationMs", "minDurationMs", "getDateFromXY", "point", "getAt", "getTickFromDate", "Editor", "appendTo", "timeAxisSubGridElement", "scrollAction", "align", "internalListeners", "complete", "refresh", "startEdit", "doDisable", "isPainted", "generateSegmentRenderData", "renderData", "segmentRenderData", "isGantt", "taskRendering", "currentOrientation", "box", "getTaskBox", "row", "isTask", "top", "left", "width", "height", "internalPopulateTaskRenderData", "generateRenderData", "_segmentRecord$cls", "eventColor", "eventContent", "taskContent", "clone", "DomClassList", "style", "isNamedColor", "wrapperCls", "appendDOMConfig", "segmentsDOMConfig", "getSegmentDOMConfig", "syncOptions", "syncIdField", "releaseThreshold", "taskBarFeature", "onEventDataGenerated", "eventData", "onTaskDataGenerated", "taskData", "featureClass", "override", "classes", "PercentBar", "allowResize", "showPercentage", "instantUpdate", "prio", "onPaint", "firstPaint", "DragHelper", "lockX", "isVertical", "lockY", "isHorizontal", "targetSelector", "dragThreshold", "outerElement", "beforeDragStart", "drop", "abort", "sizeProp", "offsetSizeProp", "positionProp", "rtl", "offsetPositionProp", "updateAllowResize", "toggle", "updateShowPercentage", "_this$drag", "reset", "isMouseInsideEvent", "handle", "_stmTransactionStarted", "valid", "oldStmAutoRecord", "resumeAutoSync", "getPercentBarDOMConfig", "percent", "isEvent", "eventSegments", "features", "enabled", "getHoverSegment", "toElement", "segmentBox", "Rectangle", "EventHelper", "getPagePoint", "isOverSegment", "onTimeSpanMouseEnter", "isEditable", "pos", "parentBox", "lastPercentDone", "lastPercentBarBox", "segmentPercentBarElement", "firstChild", "right", "createElement", "onTimeSpanMouseLeave", "onBeforeDragStart", "percentBarOuter", "percentBar", "initialPos", "parentElement", "firstElementChild", "minY", "maxY", "maxX", "minX", "initialValue", "onDragStart", "retainElement", "suspendAutoSync", "onDrag", "newX", "newY", "percentsInSegment", "onDragAbort", "onDrop", "parseInt", "cssText", "ReadyStatePropagator", "Events", "isReadyStatePropagator", "canSave", "requestReadyStateChange", "widgetClass", "ConstraintTypePicker", "none", "TaskEditorBase", "Information", "Save", "Delete", "calculateMask", "saveError", "repeatingInfo", "editRepeating", "TaskEdit", "ConfirmDeletionTitle", "ConfirmDeletionMessage", "GanttTaskEditor", "editorWidth", "SchedulerTaskEditor", "SchedulerGeneralTab", "labelWidth", "General", "Name", "Resources", "Duration", "Finish", "Effort", "Preamble", "Postamble", "GeneralTab", "Dates", "SchedulerAdvancedTab", "Advanced", "Calendar", "Inactive", "AdvancedTab", "Constraint", "Rollup", "DependencyTab", "Predecessors", "Successors", "ID", "Type", "Lag", "cyclicDependency", "invalidDependency", "NotesTab", "Notes", "ResourcesTab", "unitsTpl", "Resource", "Units", "RecurrenceTab", "title", "SchedulingModePicker", "ResourceHistogram", "barTipInRange", "barTipOnDate", "groupBarTipAssignment", "groupBarTipInRange", "groupBarTipOnDate", "plusMore", "ResourceUtilization", "nameColumnText", "SchedulingIssueResolutionPopup", "schedulingConflict", "emptyCalendar", "Apply", "CycleResolutionPopup", "dependencyLabel", "invalidDependencyLabel", "DependencyEdit", "Active", "SchedulerProBase", "propagating", "storePopulation", "finalizing", "NestedEvents", "deNestingNotAllowed", "nestingNotAllowed", "VersionGrid", "compare", "occurredAt", "restore", "stopComparing", "Versions", "TaskModel", "ProjectModel", "update", "move", "mixed", "updateEntity", "moveEntity", "addDependency", "removeDependency", "updateDependency", "removeAssignment", "updateAssignment", "noChanges", "nullValue", "versionDateFormat", "undid", "redid", "editedTask", "deletedTask", "movedTask", "movedTasks", "Popup", "localizableProperties", "closable", "layout", "draggable", "handleSelector", "bbar", "hideWhenEmpty", "defaults", "saveButton", "color", "deleteButton", "cancelButton", "strips", "occurrenceInfoToolbar", "hidden", "ignoreParentReadOnly", "tag", "ref", "onClick", "$config", "localeKey", "axisLock", "autoClose", "onChange", "onCancel", "onSave", "autoShow", "blurAction", "durationDisplayPrecision", "tabPanelItems", "defaultTabs", "calculateMaskDelay", "dependencyIdField", "processWidgetConfig", "widgetConfig", "_widgetConfig$type", "weekStartDay", "extraItems", "preparedItems", "preparedKey", "transformArrayToNamedObject", "merge", "changeItems", "clonedItems", "tabPanel", "w", "cleanItemsConfig", "itemCfg", "_me$bbar", "widgetMap", "tabs", "click", "widget", "isDurationField", "decimalPrecision", "grid", "readyStateChange", "onFieldChange", "loadedRecord", "isLoadingEvent", "up", "hide", "_delayedAction", "superResponse", "matches", "toggleFieldsDisabled", "eachWidget", "isField", "loadEvent", "highlightChanges", "isOccurrence", "isRecurring", "editingRecurring", "callWidgetHook", "dataReady", "onDocumentMouseDown", "params", "activeCellEditing", "_activeCellEdit", "action", "clickedButtonEl", "onSaveClick", "onCancelClick", "onDeleteClick", "Toast", "show", "rootElement", "html", "close", "onPropagationRequested", "onReadyStateChange", "couldSaveTitle", "tab", "onTaskRemove", "afterDelete", "onProjectBeforeCommit", "mask", "showDelay", "onProjectDataReady", "_me$_delayedAction", "unmask", "beforeSave", "afterSave", "beforeCancel", "afterCancel", "beforeDelete", "onInternalKeyDown", "handled", "saveAndCloseOnEnter", "tagName", "toLowerCase", "Widget", "fromElement", "internalOnChange", "isCheckbox", "isSlider", "preventDefault", "onEditOccurrenceClick", "confirm", "recurringTimeSpan", "resetRecurrenceData", "originalExceptionDates", "exceptionDates", "convertToRealEvent", "finalizerFn", "updateReadOnly", "childTabs", "EventLoader", "Container", "_this$up", "_this$record", "isTaskEditorBase", "setRecord", "resetData", "EditorTab", "strictRecordMapping", "FormTab", "layoutStyle", "flexFlow", "alignItems", "alignContent", "autoUpdateRecord", "userAction", "year2300", "StartDateField", "DateField", "alias", "strictParsing", "minDateDelta", "maxDateDelta", "calendarProvider", "_this$eventRecord", "recurringEvent", "backShiftDate", "_step", "forwardShiftDate", "transformTimeValue", "keepTime", "startOfTheDay", "clearTime", "earliestTime", "isValidDate", "copyTimeValues", "EndDateField", "_min", "eventStartDate", "_this$eventRecord2", "startOfNextDay", "latestTime", "EffortField", "DurationField", "clearable", "flex", "divider", "step", "buildItems", "DependencyTypePicker", "LocaleManager", "_items", "markDependencyValid", "instanceMeta", "markDependencyInvalid", "isDependencyMarkedValid", "sortField", "taskComboSortField", "emptyText", "asyncEventSuffix", "disableGridRowModelWarning", "group", "columns", "editor", "htmlEncode", "sortable", "dependency1", "dependency2", "_dependency1$directio", "_dependency2$directio", "id1", "id2", "renderer", "column", "linkedEvent", "idField", "hasGeneratedId", "addCls", "cellElement", "finalizeCellEdit", "filterOperator", "allowInvalid", "dependencyTab", "_dependencyTab", "StringHelper", "xss", "allowNegative", "toolbar", "dock", "onAction", "finalizeLinkedTaskCellEdit", "linkedTask", "masterStore", "isSuccessor", "afterConstruct", "selectionChange", "startCellEdit", "finishCellEdit", "cancelCellEdit", "taskCombo", "storeChange", "recordChange", "depStoreGeneration", "eventStoreGeneration", "negDirection", "comboStore", "doRelayToMaster", "excludeCollapsedRecords", "filterBy", "activeEdit", "isDepEditing", "change", "fillFromMaster", "refreshRows", "insertNewDependency", "cellEdit", "isEditing", "cancelEditing", "newDep", "insert", "startEditing", "onAddClick", "onRemoveClick", "selectedRecords", "selectedRecord", "getNext", "onGridSelectionChange", "selection", "removeButton", "containsFocus", "focusCell", "rowIndex", "columnIndex", "clearActiveEditorErrors", "activeCellEdit", "inputField", "clearError", "onGridCellEditChange", "onGridStartCellEdit", "editorContext", "_editingDependency", "setError", "onGridFinishCellEdit", "redrawDependencyRow", "onGridCancelCellEdit", "rowManager", "getRowById", "SuccessorsTab", "PredecessorsTab", "showUnits", "addButton", "resourceCombo", "_this$grid", "updateShowUnits", "assignmentStoreGeneration", "resourceStoreGeneration", "isSpecialRow", "isAssignedTo", "activeAssignment", "groupers", "activeRecord", "insertNewAssignment", "newAssignment", "pruneInvalidAssignments", "focus", "_editingAssignment", "query", "updateLocalization", "buildStoreData", "_store", "allowNullId", "allowedModes", "defaultStoreData", "FixedUnits", "FixedEffort", "changeAllowedModes", "split", "updateAllowedModes", "_allowedModes", "addFilter", "removeFilter", "col1", "col2", "calendarField", "ignoreResourceCalendarField", "schedulingModeField", "effortDrivenField", "constraintTypeField", "rollupField", "constraintDateField", "inactiveField", "manuallyScheduledField", "isConstraintTypePicker", "typesStore", "titleProperty", "layoutConfig", "noteField", "inputAttributes", "defaultType", "autoHeight", "scrollable", "overflowY", "generalTab", "predecessorsTab", "successorsTab", "resourcesTab", "advancedTab", "notesTab", "nameField", "resourcesField", "highlightExternalChange", "startDateField", "dateField", "endDateField", "durationField", "percentDoneField", "effortField", "preambleField", "useAbbreviation", "postambleField", "compareUnits", "timeField", "multiSelect", "usesSingleAssignment", "resourceUnassigned", "removeUnassignedEvent", "recurrenceEditor", "loadingRecord", "recurrence", "isConfiguring", "assigningValues", "frequencyField", "syncEventRecord", "recurrenceModel", "addNone", "tooltip", "bufferRe", "enableEventSpanBuffer", "recurrenceTab", "_widgetConfig$ref", "match", "_this$owner", "enableRecurringEvents", "onFocusOut", "_relatedTarget$closes", "elementData", "Delayable", "TaskEditStm", "triggerEvent", "editorClassMap", "Gantt", "editorClass", "editorConfig", "confirmDelete", "scrollIntoView", "suspendHasChangesEvent", "scheduler", "_scheduler$features$e", "taskEdit", "eventBuffer", "dragCreateEnd", "afterEventDrop", "eventResizeEnd", "_this$editor", "detachFromProject", "deleteConfirmationPromise", "MessageDialog", "onClientReadOnlyToggle", "getElementFromTaskRecord", "getElementFromEventRecord", "scrollEventIntoView", "scrollResourceEventIntoView", "attachToProject", "loadstart", "save", "onDataReady", "_editing", "onActivateEditor", "editEvent", "stmCapture", "doEdit", "usesDisplayStore", "transferred", "cancel", "_cancelling", "_hiding", "catch", "isGanttBase", "_taskRecord$resources", "hasStmCapture", "captureStm", "isCreating", "assignEventToResource", "timeAxisSubGrid", "collapsed", "taskElement", "down", "eventInnerSelector", "getEditor", "triggerOnClient", "isNestedEvent", "nestedEvents", "centered", "showBy", "anchor", "offset", "clippedBy", "disableStm", "freeStm", "_me$editorConfig", "bodyContainer", "eventEditFeature", "beforeHide", "tabsConfig", "projectType", "_loading", "doCancel", "_project$resumeAutoSy", "_project$resumeAutoSy2", "_project$resumeAutoSy3", "requestAnimationFrame", "onDelete", "okButton", "yesButton", "onBeforeHide", "animate", "hideAnimation", "hideAnimationEnd", "onDragCreateEnd", "proxyElement", "onEventEnterKey", "assignmentRecord", "eventEvent", "returnValTaskRecord", "eventRecords", "returnValEventRecord", "onEventDropped", "_this$editor2", "rec", "onEventResized", "isVisible", "realign", "ChangeLogEntity", "$$name", "freeze", "_ChangeLogEntity", "ChangeLogDependencyEntity", "fromTask", "toTask", "ChangeLogAssignmentEntity", "ChangeLogAction", "_ChangeLogAction", "ChangeLogMoveAction", "ChangeLogUpdateAction", "propertyUpdates", "isInitialUserAction", "isUser", "AttachToProjectMixin", "_remoteActionRanges", "_comparingVersionId", "versionStore", "versionModelClass", "onStoreChangeExternal", "changeStore", "transactionModelClass", "_currentChanges", "beforeTaskDelete", "onBeforeTaskDelete", "beforeTaskSave", "onBeforeTaskSave", "gridRowBeforeDropFinalize", "onGridRowBeforeDropFinalize", "addCrudStore", "onProjectLoad", "detachProjectListeners", "attachProjectListeners", "transactionDescription", "_project$stm", "recordingStart", "onStmRecordingStart", "recordingStop", "handleTransactionStop", "onStmRestoringStop", "wsBeforeReceiveChanges", "onBeforeApplyRemoteChanges", "wsReceiveChanges", "onAfterApplyRemoteChanges", "updateVersionModelClass", "newVersionModelClass", "isVersionModel", "updateTransactionModelClass", "newTransactionModelClass", "isChangeLogTransactionModel", "triggerVersionChange", "tryAutoSave", "versionId", "wsSend", "wsProjectId", "wsVersionAutoSaveOK", "autoSave", "saveVersionWithConfig", "autoSaveHourly", "getMinutes", "updateAutoSaveInterval", "newInterval", "_autoSaveInterval", "clearInterval", "_autosaveInterval", "setInterval", "saveVersion", "versionName", "versionConfig", "content", "captureVersionContent", "changeRecord", "txn", "triggerTransactionChange", "loadVersionContent", "projectId", "expires", "versionContentLoadTimeout", "alt", "_versionContentCache", "getVersionContent", "hasUnattachedTransactions", "versions", "restoreVersion", "_project$stm2", "_project$stm3", "_project$stm5", "stmWasEnabled", "json", "_project$stm4", "compareVersion", "_project$stm6", "_project$stm7", "versionData", "baselinesByTaskId", "rootTask", "WalkHelper", "preWalk", "baselines", "removeAll", "loadData", "_project$stm8", "_project$stm9", "_project$stm10", "_project$stm11", "getEntityDescriptor", "recordedType", "knownBaseTypes", "knownType", "isDependencyModel", "isAssignmentModel", "getUpdateAction", "stmUpdateActions", "entityModel", "allPropertyUpdates", "flatMap", "_entityModel$getField", "allUpdatesByProperty", "groupBy", "before", "after", "_currentStmTransaction", "_transactionStart", "_this$client$project", "_this$client$project2", "cause", "transactions", "finalizeTransaction", "_remoteChangesStartPos", "_this$_currentStmTran", "endCurrentRemoteActionRange", "_me$_currentStmTransa", "currentPos", "_currentTransactionDescription", "excludeRanges", "array", "ranges", "keep", "position", "stmTransaction", "localActions", "uniqueRecordId", "actionsByType", "allChanges", "updateActionType", "updateActionsByRecordId", "updateActions", "modelList", "childModels", "childModel", "parentModel", "insertIndex", "childContext", "_this$_currentStmTran2", "_this$_currentStmTran3", "isComparing", "autoSaveInterval", "willChange", "rawData", "processField", "ProjectChangeHandlerMixin", "startConfigure", "getConfig", "beforeApplyProjectChanges", "shouldResume", "stash", "ignoreRemoteChangesInSTM", "applyProjectChanges", "applyingChangeset", "storeChanges", "getFieldDataSource", "updated", "commitRespondedChanges", "storeDescriptor", "changedRows", "added", "modifications", "afterApplyProjectChanges", "applyStash", "ProjectWebSocketHandlerMixin", "_this$websocketManage", "websocketManager", "updateWsAddress", "address", "_me$websocketManager", "WebSocketManager", "userName", "wsUserName", "error", "wsAutoLoad", "wsLoad", "toggleAutoSyncListener", "_wsAutoSync", "_wsAddress", "updateWsAutoSync", "updateWsProjectId", "scheduleWebsocketMessage", "hasTimeout", "isAutoSyncSuspended", "wsSync", "autoSyncTimeout", "doSync", "command", "wsOpen", "send", "wsReceive", "handleWebsocketClose", "handleWebsocketError", "handleWebsocketMessage", "isOpened", "open", "detacher", "wsReceiveDataset", "wsConnectionTimeout", "wsAutoSync", "autoSyncSuspendCounter", "wsClose", "_this$websocketManage2", "wsAddress", "ProjectProgressMixin", "updateProject", "old", "setupProgressListener", "delayCalculationStart", "delayCalculationEnd", "projectProgressReporting", "_me$project", "progress", "updateProjectProgressReporting", "onProjectProgress", "projectProgressThreshold", "mode", "progressElement", "calculationProgressElement", "header", "calculationProgressTimeout", "_progressElement", "masked", "maxProgress", "useTransition", "internalOnProjectDelayCalculationStart", "$delayCalculationReadOnly", "internalOnProjectDelayCalculationEnd", "closeAction", "modal", "constrainTo", "floating", "resolutionsGroup", "applyButton", "selectedResolutions", "_this$resolutionsGrou", "_this$resolutionsGrou2", "selectedResolution", "selected", "changeResolutionsGroup", "RadioGroup", "reconfigure", "updateResolutionsGroup", "getResolutionParameters", "onApplyButtonClick", "doResolve", "onCancelButtonClick", "onCloseButtonClick", "canCancel", "isResolving", "resolving", "updatePopupContent", "onResolutionChange", "Promissory", "getResolutionWidgetConfig", "encodeHtml", "checkedValue", "_this$schedulingIssue", "_schedulingIssue", "_resolutionItems$", "optionalL", "resolutionItems", "toggleControlsState", "canApply", "cancelResolution", "getDependencyTitle", "checked", "_dependencyResolutionsChecked", "invalidDependenciesDescription", "dependencyField", "validDependencies", "dependencyItems", "labelPosition", "onDependencyChange", "isRemoveDependencyCycleEffectResolution", "isDeactivateDependencyCycleEffectResolution", "dependencyId", "SchedulingIssueResolution", "schedulingIssueResolutionPopupClass", "cycleResolutionPopupClass", "displaySchedulingIssueResolutionPopup", "oldProject", "unbindSchedulingIssueResolutionFromProject", "bindSchedulingIssueResolutionToProject", "_this$_lastScheduling", "_lastSchedulingIssueResolutionPopup", "activeSchedulingIssueResolutionPopup", "getSchedulingIssueResolutionPopup", "_cycleResolutionPopup", "_schedulingIssueResolutionPopup", "onProjectSchedulingIssueEvent", "popup"]
}
