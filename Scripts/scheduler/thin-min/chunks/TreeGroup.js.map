{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/RowReorder.js", "../../../../Grid/lib/Grid/feature/TreeGroup.js"],
  "sourcesContent": ["/**\n * @module Grid/feature/RowReorder\n */\n\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DragHelper from '../../Core/helper/DragHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * Object with information about a tree position\n * @typedef {Object} RecordPositionContext\n * @property {Core.data.Model} record Tree node\n * @property {Number} parentIndex Index among parents children\n * @property {String|Number} parentId Parent node's id\n */\n\n/**\n * Allows user to reorder rows by dragging them. To get notified about row reorder listen to `change` event\n * on the grid {@link Core.data.Store store}.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n * This feature is **enabled** by default for Gantt.\n *\n * {@inlineexample Grid/feature/RowReorder.js}\n *\n * If the grid is set to {@link Grid.view.Grid#config-readOnly}, reordering is disabled. Inside all event listeners you\n * have access a `context` object which has a `record` property (the dragged record).\n *\n * ## Validation\n * You can validate the drag drop flow by listening to the `gridrowdrag` event. Inside this listener you have access to\n * the `index` property which is the target drop position. For trees you get access to the `parent` record and `index`,\n * where index means the child index inside the parent.\n *\n * You can also have an async finalization step using the {@link #event-gridRowBeforeDropFinalize}, for showing a\n * confirmation dialog or making a network request to decide if drag operation is valid (see code snippet below)\n *\n * ```javascript\n * features : {\n *     rowReorder : {\n *         showGrip : true\n *     },\n *     listeners : {\n *        gridRowDrag : ({ context }) => {\n *           // Here you have access to context.insertBefore, and additionally context.parent for trees\n *        },\n *\n *        gridRowBeforeDropFinalize : async ({ context }) => {\n *           const result = await MessageDialog.confirm({\n *               title   : 'Please confirm',\n *               message : 'Did you want the row here?'\n *           });\n *\n *           // true to accept the drop or false to reject\n *           return result === MessageDialog.yesButton;\n *        }\n *    }\n * }\n * ```\n *\n * Note, that this feature uses the concept of \"insert before\" when choosing a drop point in the data. So the dropped\n * record's position is *before the visual next record's position*.\n *\n * This may look like a pointless distinction, but consider the case when a Store is filtered. The record *above* the\n * drop point may have several filtered out records below it. When unfiltered, the dropped record will be *below* these\n * because of the \"insert before\" behaviour.\n *\n * ## Behavior with multiple subgrids\n *\n * For grids with multiple subgrids, row reordering is only enabled for the first subgrid.\n *\n * NOTE: This feature cannot be used simultaneously with the `enableTextSelection` config.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/rowreordering\n * @classtype rowReorder\n * @feature\n */\nexport default class RowReorder extends Delayable(InstancePlugin) {\n    //region Events\n    /**\n     * Fired before dragging starts, return false to prevent the drag operation.\n     * @preventable\n     * @event gridRowBeforeDragStart\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent|TouchEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired when dragging starts.\n     * @event gridRowDragStart\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent|TouchEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired while the row is being dragged, in the listener function you have access to `context.insertBefore` a grid /\n     * tree record, and additionally `context.parent` (a TreeNode) for trees. You can signal that the drop position is\n     * valid or invalid by setting `context.valid = false;`\n     * @event gridRowDrag\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired before the row drop operation is finalized. You can return false to abort the drop operation, or a\n     * Promise yielding `true` / `false` which allows for asynchronous abort (e.g. first show user a confirmation dialog).\n     * @event gridRowBeforeDropFinalize\n     * @preventable\n     * @async\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.\n     * Objects contain the `record`, and its original `parentIndex` and `parentId` values\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired after the row drop operation has completed, regardless of validity\n     * @event gridRowDrop\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid true or false depending on whether the drop position was valid\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model} context.record [DEPRECATED] The dragged row record\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.\n     * Objects contain the record, and its original `parentIndex` and `parentId` values\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    /**\n     * Fired when a row drag operation is aborted\n     * @event gridRowAbort\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n\n    static get deprecatedEvents() {\n        return {\n            gridRowBeforeDragStart : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowBeforeDragStart` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDragStart : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDragStart` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDrag : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDrag` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowBeforeDropFinalize : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowBeforeDropFinalize` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDrop : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDrop` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowAbort : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowAbort` event is deprecated, listen on this event on the Grid instead.'\n            }\n        };\n    }\n    //endregion\n\n    //region Init\n\n    static $name = 'RowReorder';\n\n    static configurable = {\n        /**\n         * Set to `true` to show a grip icon on the left side of each row.\n         * @config {Boolean}\n         */\n        showGrip : null,\n\n        /**\n         * Set to `true` to only allow reordering by the {@link #config-showGrip} config\n         * @config {Boolean}\n         */\n        gripOnly : null,\n\n        /**\n         * If hovering over a parent node for this period of a time in a tree, the node will expand\n         * @config {Number}\n         */\n        hoverExpandTimeout : 1000,\n\n        /**\n         * The amount of milliseconds to wait after a touchstart, before a drag gesture will be allowed to start.\n         * @config {Number}\n         * @default\n         */\n        touchStartDelay : 300,\n\n        /**\n         * Enables creation of parents by dragging a row and dropping it onto a leaf row. Only works in a Grid with\n         * a tree store.\n         * @config {Boolean}\n         */\n        dropOnLeaf : false,\n\n        /**\n         * An object used to configure the internal {@link Core.helper.DragHelper} class\n         * @config {DragHelperConfig}\n         */\n        dragHelperConfig : null\n    };\n\n    construct(grid, config) {\n        this.grid = grid;\n\n        super.construct(...arguments);\n    }\n\n    doDestroy() {\n        this.dragHelper?.destroy();\n\n        super.doDestroy();\n    }\n\n    /**\n     * Initialize drag & drop (called on first paint)\n     * @private\n     */\n    init() {\n        const\n            me       = this,\n            { grid } = me;\n\n        me.dragHelper = DragHelper.new({\n            name               : 'rowReorder',\n            cloneTarget        : true,\n            dragThreshold      : 10,\n            proxyTopOffset     : 10,\n            targetSelector     : '.b-grid-row',\n            lockX              : true,\n            dragWithin         : grid.bodyContainer,\n            allowDropOutside   : true,\n            scrollManager      : grid.scrollManager,\n            outerElement       : me.targetSubGridElement,\n            touchStartDelay    : me.touchStartDelay,\n            isElementDraggable : me.isElementDraggable.bind(me),\n            monitoringConfig   : {\n                scrollables : [\n                    {\n                        element   : grid.scrollable.element,\n                        direction : 'vertical'\n                    }\n                ]\n            },\n            setXY(element, x, y) {\n                const { context } = this;\n\n                if (!context.started) {\n                    const\n                        elementRect       = Rectangle.from(context.element, this.dragWithin),\n                        pointerDownOffset = context.startPageY - globalThis.pageYOffset - context.element.getBoundingClientRect().top;\n\n                    // manually position the row a bit below the cursor\n                    y = elementRect.top + pointerDownOffset + this.proxyTopOffset;\n                }\n                DomHelper.setTranslateXY(element, x, y);\n            },\n            // Since parent nodes can expand after hovering, meaning original drag start position now refers to a different point in the tree\n            ignoreSamePositionDrop : false,\n            createProxy(element) {\n                const\n                    clone     = element.cloneNode(true),\n                    container = document.createElement('div');\n\n                container.classList.add('b-row-reorder-proxy');\n\n                clone.removeAttribute('id');\n                // The containing element will be positioned instead, and sized using CSS\n                clone.style.transform = '';\n                clone.style.width = '';\n\n                container.appendChild(clone);\n\n                if (grid.selectedRecords.length > 1) {\n                    const clone2 = clone.cloneNode(true);\n\n                    clone2.classList.add('b-row-dragging-multiple');\n\n                    container.appendChild(clone2);\n                }\n\n                DomHelper.removeClsGlobally(container, 'b-selected', 'b-hover', 'b-focused');\n\n                return container;\n            },\n\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                reset           : 'onReset',\n                prio            : 10000, // To ensure our listener is run before the relayed listeners (for the outside world)\n                thisObj         : me\n            }\n        }, me.dragHelperConfig);\n\n        // Remove in 6.0\n        me.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');\n\n        grid.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');\n\n        me.dropIndicator = DomHelper.createElement({\n            className : 'b-row-drop-indicator'\n        });\n\n        me.dropOverTargetCls = ['b-row-reordering-target', 'b-hover'];\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    static pluginConfig = {\n        after : ['onPaint']\n    };\n\n    get targetSubGridElement() {\n        const targetSubGrid = this.grid.regions[0];\n\n        return this.grid.subGrids[targetSubGrid].element;\n    }\n\n    //endregion\n\n    //region Events (drop)\n\n    isElementDraggable(el, event) {\n        if (!el.closest('.b-grid-cell .b-widget')) {\n            if (this.gripOnly) {\n                const firstCell = el.closest('.b-grid-cell:first-child');\n\n                // Event is in the first cell. Now check if it's on the handle\n                if (firstCell) {\n                    const\n                        gripperStyle = getComputedStyle(firstCell, ':before'),\n                        offsetX      = this.grid.rtl ? firstCell.getBoundingClientRect().width - event.borderOffsetX : event.borderOffsetX,\n                        onGrip       = DomHelper.roundPx(offsetX) <= DomHelper.roundPx(parseFloat(gripperStyle.width));\n\n                    // Prevent drag select if mousedown on grip, would collide with reordering\n                    // (reset by GridSelection)\n                    if (onGrip) {\n                        this.client.preventDragSelect = true;\n                    }\n\n                    return onGrip;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n    }\n\n    onBeforeDragStart({ event, source, context }) {\n        const\n            me        = this,\n            { grid }  = me,\n            subGridEl = me.targetSubGridElement;\n\n        // Only dragging enabled in the leftmost grid section\n        if (me.disabled || grid.readOnly || grid.isTreeGrouped || !subGridEl.contains(context.element)) {\n            return false;\n        }\n\n        const startRecord = context.startRecord = grid.getRecordFromElement(context.element);\n\n        // Don't allow starting drag on a readOnly record nor on special rows\n        if (startRecord.readOnly || startRecord.isSpecialRow) {\n            return false;\n        }\n\n        context.originalRowTop = grid.rowManager.getRowFor(startRecord).top;\n\n        // Don't select row if checkboxOnly is set\n        if (!grid.selectionMode.checkboxOnly) {\n            if (source.startEvent.pointerType === 'touch') {\n                // Touchstart doesn't focus/navigate on its own, so we do it at the last moment before drag start\n                if (!grid.isSelected(startRecord)) {\n                    grid.selectRow({\n                        record         : startRecord,\n                        addToSelection : false\n                    });\n                }\n            }\n            else if (!grid.isSelected(startRecord) && !event.shiftKey && !event.ctrlKey) {\n                // If record is not selected and shift/ctrl is not pressed then select single row\n                grid.selectRow({\n                    record : startRecord\n                });\n            }\n        }\n\n        // Read-only records will not be moved\n        const selectedRecords = grid.selectedRecords.filter(r => !r.readOnly);\n        context.records       = [startRecord];\n\n        // If clicked record is selected, move all selected records\n        if (selectedRecords.includes(startRecord)) {\n            context.records.push(...selectedRecords.filter(r => r !== startRecord));\n            context.records.sort((r1, r2) => grid.store.indexOf(r1) - grid.store.indexOf(r2));\n        }\n\n        return true;\n    }\n\n    onDragStart({ context }) {\n        const\n            me                                 = this,\n            { grid }                           = me,\n            { cellEdit, cellMenu, headerMenu } = grid.features;\n\n        if (cellEdit) {\n            me.cellEditDisabledState = cellEdit.disabled;\n            cellEdit.disabled        = true; // prevent editing from being started through keystroke during row reordering\n        }\n\n        cellMenu?.hideContextMenu?.(false);\n        headerMenu?.hideContextMenu?.(false);\n\n        grid.element.classList.add('b-row-reordering');\n\n        const focusedCell = context.element.querySelector('.b-focused');\n        focusedCell?.classList.remove('b-focused');\n\n        context.element.firstElementChild.classList.remove('b-selected', 'b-hover');\n\n        grid.bodyContainer.appendChild(me.dropIndicator);\n    }\n\n    onDrag({ context, event }) {\n        const\n            me                    = this,\n            { grid }              = me,\n            { store, rowManager } = grid,\n            { clientY }           = event;\n\n        let valid = true,\n            row   = rowManager.getRowAt(clientY),\n            overRecord,\n            dataIndex,\n            after,\n            over,\n            insertBefore;\n\n        if (row) {\n            const\n                rowTop        = row.top + grid.scrollable.element.getBoundingClientRect().top - grid.scrollable.y,\n                quarter       = row.height / 4,\n                topQuarter    = rowTop + quarter,\n                middleY       = rowTop + row.height / 2,\n                bottomQuarter = rowTop + quarter * 3;\n\n            dataIndex  = row.dataIndex;\n            overRecord = store.getAt(dataIndex);\n\n            // If Tree and pointer is in quarter 2 and 3, add as child of hovered row\n            if (store.tree) {\n                over = (overRecord.isParent || me.dropOnLeaf) && clientY > topQuarter && clientY < bottomQuarter;\n            }\n            else if (store.isGrouped) {\n                over = overRecord.isGroupHeader && overRecord.meta.collapsed;\n            }\n\n            // Else, drop after row below if mouse is in bottom half of hovered row\n            after = !over && event.clientY >= middleY;\n        }\n        // User dragged below last row or above the top row.\n        else {\n            if (event.pageY < grid._bodyRectangle.y) {\n                dataIndex  = 0;\n                overRecord = store.first;\n                after      = false;\n            }\n            else {\n                dataIndex  = store.count - 1;\n                overRecord = store.last;\n                after      = true;\n            }\n            row = grid.rowManager.getRow(dataIndex);\n        }\n\n        if (overRecord === me.overRecord && me.after === after && me.over === over) {\n            context.valid = me.reorderValid;\n            // nothing's changed\n            return;\n        }\n\n        if (me.overRecord !== overRecord) {\n            rowManager.getRowById(me.overRecord)?.removeCls(me.dropOverTargetCls);\n        }\n\n        me.overRecord = overRecord;\n        me.after      = after;\n        me.over       = over;\n\n        if (\n            // Hovering the dragged record. This is a no-op.\n            // But still gather the contextual data.\n            overRecord === context.startRecord ||\n            // Not allowed to drop above topmost group header or below a collapsed header\n            (!after && !over && dataIndex === 0 && store.isGrouped) ||\n            // Not allowed to drop after last collapsed group\n            (after && overRecord.isGroupHeader && overRecord.meta.collapsed && store.indexOf(overRecord) === store.count - 1)\n        ) {\n            valid = false;\n        }\n\n        if (store.tree) {\n            insertBefore = after ? overRecord.nextSibling : overRecord;\n\n            // For trees, prevent moving a parent into its own hierarchy\n            if (context.records.some(rec => rec.contains(overRecord))) {\n                valid = false;\n            }\n\n            context.parent = valid && over ? overRecord : overRecord.parent;\n\n            me.clearTimeout(me.hoverTimer);\n\n            if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {\n                me.hoverTimer = me.setTimeout(() => grid.expand(overRecord), me.hoverExpandTimeout);\n            }\n        }\n        else {\n            insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;\n        }\n\n        row.toggleCls(me.dropOverTargetCls, valid && over);\n\n        // If hovering results in same dataIndex, regardless of what row is hovered, and parent has not changed\n        if (!over && dataIndex === store.indexOf(context.startRecord) + (after ? -1 : 1) &&\n            context.parent && context.startRecord.parent === context.parent) {\n            valid = false;\n        }\n\n        // Provide visual clue to user of the drop position\n        // In FF (in tests) it might not have had time to redraw rows after scroll before getting here\n        row && DomHelper.setTranslateY(me.dropIndicator, Math.max(row.top + (after ? row.element.getBoundingClientRect().height : 0), 1));\n\n        // Don't show dropIndicator if holding over a row\n        me.dropIndicator.style.visibility = over ? 'hidden' : 'visible';\n        me.dropIndicator.classList.toggle('b-drag-invalid', !valid);\n\n        // Public property used for validation\n        context.insertBefore = insertBefore;\n\n        context.valid = me.reorderValid = valid;\n    }\n\n    /**\n     * Handle drop\n     * @private\n     */\n    async onDrop(event) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = event;\n\n        context.valid = context.valid && me.reorderValid;\n\n        if (context.valid) {\n            context.async = true;\n\n            if (client.store.tree) {\n                // For tree scenario, add context about previous positions of dragged tree nodes\n                context.oldPositionContext = context.records.map((record) => ({\n                    record,\n                    parentId    : record.parent?.id,\n                    parentIndex : record.parentIndex\n                }));\n            }\n\n            // Remove for 6.0\n            let result = await me.trigger('gridRowBeforeDropFinalize', event);\n\n            if (result === false) {\n                context.valid = false;\n            }\n\n            // Outside world provided us one or more Promises to wait for\n            result = await client.trigger('gridRowBeforeDropFinalize', event);\n\n            if (result === false) {\n                context.valid = false;\n            }\n\n            await me.dragHelper.animateProxyTo(me.dropIndicator, { align : 'l0-l0' });\n\n            await me.finalizeReorder(context);\n        }\n\n        // already dropped the node, don't have to expand any node hovered anymore\n        // (cancelling expand action after timeout)\n        me.clearTimeout(me.hoverTimer);\n\n        me.overRecord = me.after = me.over = null;\n\n        me.trigger('gridRowDrop', event);\n        client.trigger('gridRowDrop', event);\n    }\n\n    async finalizeReorder(context) {\n        const\n            me                     = this,\n            { grid }               = me,\n            { store, focusedCell } = grid;\n\n        let { records } = context;\n\n        context.valid = context.valid && !records.some(rec => !store.includes(rec));\n\n        if (context.valid) {\n            let result;\n\n            if (store.tree) {\n                // Remove any selected child records of parent nodes\n                records = records.filter(record => !record.parent || record.bubbleWhile(parent => !records.includes(parent), true));\n\n                result = await context.parent.tryInsertChild(records, me.over ? context.parent.children?.[0] : context.insertBefore);\n                // remove reorder cls from preview parent element dropped\n                grid.rowManager.forEach(r => r.removeCls(me.dropOverTargetCls));\n\n                // If parent wasn't expanded, expand it if it now has children\n                if (!context.parent.isExpanded() && context.parent.children?.length) {\n                    grid.expand(context.parent);\n                }\n\n                context.valid = result !== false;\n            }\n            else if (store.isGrouped && me.over) {\n                store.move(records, store.getAt(store.indexOf(context.insertBefore) + 1));\n            }\n            else {\n                store.move(records, context.insertBefore);\n            }\n\n            if (focusedCell?._rowIndex >= 0) {\n                grid._focusedCell = null;\n                // Refresh focused cell\n                grid.focusCell({\n                    grid,\n                    record   : focusedCell.record,\n                    columnId : focusedCell.columnId\n                });\n            }\n\n            store.clearSorters();\n        }\n\n        context.finalize(context.valid);\n\n        grid.element.classList.remove('b-row-reordering');\n    }\n\n    /**\n     * Clean up on reset\n     * @private\n     */\n    onReset() {\n        const\n            me       = this,\n            { grid } = me,\n            cellEdit = grid.features.cellEdit;\n\n        grid.element.classList.remove('b-row-reordering');\n\n        if (cellEdit) {\n            cellEdit.disabled = me.cellEditDisabledState;\n        }\n\n        me.dropIndicator.remove();\n\n        DomHelper.removeClsGlobally(\n            grid.element,\n            ...me.dropOverTargetCls\n        );\n    }\n\n    //endregion\n\n    //region Render\n\n    onPaint({ firstPaint }) {\n        // columns shown, hidden or reordered\n        if (firstPaint) {\n            this.init();\n        }\n    }\n\n    //endregion\n\n    updateShowGrip(show) {\n        this.grid.element.classList.toggle('b-row-reorder-with-grip', show);\n    }\n}\n\nRowReorder.featureClass = '';\n\nGridFeatureManager.registerFeature(RowReorder, false);\nGridFeatureManager.registerFeature(RowReorder, true, 'Gantt');\n", "import TreeColumn from '../column/TreeColumn.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/TreeGroup\n */\n\n/**\n * A feature that allows transforming a flat dataset (or the leaves of a hierarchical) into a tree by specifying a\n * record field per parent level. Parents are generated based on each leaf's value for those fields.\n *\n * {@inlineexample Grid/feature/TreeGroup.js}\n *\n * This feature can be used to mimic multi grouping or to generate another view for hierarchical data. The actual\n * transformation happens in a new store, that contains links to the original records. The original stores structure is\n * kept intact and will be plugged back in when calling {@link #function-clearGroups}.\n *\n * Any modification of the links is relayed to the original store. So cell editing etc. will work as expected and the\n * original data will be updated.\n *\n * <div class=\"note\">\n * Please note that this feature requires using a {@link Grid.view.TreeGrid} or having the {@link Grid.feature.Tree}\n * feature enabled.\n * </div>\n *\n * This snippet shows how the sample dataset used in the demo above is transformed:\n *\n * ```javascript\n * const grid = new TreeGrid({\n *     // Original data\n *     data : [\n *         { id : 1, name : 'Project 1', children : [\n *             { id : 11, name : 'Task 11', status : 'wip', prio : 'high' },\n *             { id : 12, name : 'Task 12', status : 'done', prio : 'low' },\n *             { id : 13, name : 'Task 13', status : 'done', prio : 'high' }\n *         ]},\n *         { id : 2, name : 'Project 2', children : [\n *             { id : 21, name : 'Task 21', status : 'wip', prio : 'high' },\n *         ]}\n *     ],\n *\n *     features : {\n *         treeGroup : {\n *             // Fields to build a new tree from\n *             levels : [ 'prio', 'status' ]\n *         }\n *     }\n * });\n *\n * // Resulting data\n * [\n *     { name : 'low', children : [\n *         { name : 'done', children : [\n *             { id : 12, name : 'Task 12', status : 'done', prio : 'low' }\n *         ]}\n *     ]},\n *     { name : 'high', children : [\n *         { name : 'done', children : [\n *             { id : 13, name : 'Task 13', status : 'done', prio : 'high' }\n *         ]},\n *         { name : 'wip', children : [\n *             { id : 11, name : 'Task 11', status : 'wip', prio : 'high' },\n *             { id : 21, name : 'Task 21', status : 'wip', prio : 'low' }\n *         ]}\n *     ]}\n * ]\n * ```\n *\n * ## Important information\n *\n * Using the TreeGroup feature comes with some caveats:\n *\n * * Generated parents are read-only, they cannot be edited using the default UI.\n * * Moving nodes manually in the tree is not supported while it is grouped. The linked records have their own\n *   `parentId` fields, not linked to the original records value.\n * * The generated structure is not meant to be persisted.\n *\n * <div class=\"note\">\n * Please note that this feature is not supported in vertical mode in Scheduler.\n * </div>\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @classtype treeGroup\n * @feature\n */\nexport default class TreeGroup extends InstancePlugin {\n    static $name = 'TreeGroup';\n\n    static configurable = {\n        /**\n         * An array of model field names or functions used to determine the levels in the resulting tree.\n         *\n         * When supplying a function, it will be called for each leaf in the original data, and it is expected to return\n         * an atomic value used to determine which parent the leaf will be added to at that level.\n         *\n         * ```javascript\n         * const grid = new TreeGrid({\n         *     features : {\n         *         treeGroup : {\n         *             levels : [\n         *                 // First level is determined by the value of the status field\n         *                 'status',\n         *                 // Second level by the result of this function\n         *                 // (which puts percentdone 0-9 in one group, 10-19 into another and so on)\n         *                 record => (record.percentDone % 10) * 10\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * The function form can also be used as a formatter/renderer of sorts, simply by returning a string:\n         *\n         * ```javascript\n         * const grid = new TreeGrid({\n         *     features : {\n         *         treeGroup : {\n         *             levels : [\n         *                 record => `Status: ${record.status}`\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * Assigning `null` restores data to its original state.\n         *\n         * @prp {Array<String|Function(Core.data.Model) : any>} levels\n         */\n        levels : null,\n\n        /**\n         * CSS class to apply to the generated parents.\n         *\n         * @config {String}\n         * @default\n         */\n        parentCls : 'b-generated-parent'\n    };\n\n    /**\n     * A reference to the original store when a tree grouping has been applied. Use this to modify / load data\n     * while tree grouping is active.\n     * @member {Core.data.Store} originalStore\n     * @readonly\n     */\n\n    static pluginConfig = {\n        assign : ['group', 'clearGroups']\n    };\n\n    static properties = {\n        isApplying    : 0,\n        originalStore : null\n    };\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        if (!grid.hasFeature('tree')) {\n            throw new Error('The TreeGroup feature requires the Tree feature to be enabled');\n        }\n    }\n\n    processParentData(parentData) {\n        // Apply cls to allow custom styling of generated parents\n        if (this.parentCls) {\n            parentData.cls = this.parentCls;\n        }\n    }\n\n    processTransformedData(transformedData) {}\n\n    async waitForReadiness() {\n        // Wait for store to finish loading before transforming the data\n        if (this.originalStore.isLoading) {\n            await this.originalStore.await('load', false);\n\n            if (this.isDestroyed) {\n                return;\n            }\n        }\n\n        // For Scheduler, Pro & Gantt, to not have to implement a TreeGroup in Scheduler just to add this\n        const { crudManager } = this.client;\n\n        if (crudManager) {\n            if (crudManager.isLoadingOrSyncing || crudManager._autoLoadPromise) {\n                await crudManager.await('requestDone');\n\n                if (this.isDestroyed) {\n                    return;\n                }\n            }\n\n            await this.client.project.commitAsync();\n        }\n    }\n\n    async applyLevels(levels) {\n        const\n            me         = this,\n            { client } = me,\n            treeColumn = client.columns.find(col => col instanceof TreeColumn);\n\n        let { store } = client,\n            result    = null;\n\n        me._levels = levels;\n\n        me.isApplying++;\n\n        client.suspendRefresh();\n\n        if (levels && !me.originalStore) {\n            me.originalStore = store;\n            store            = new store.constructor({\n                tree       : true,\n                modelClass : store.modelClass,\n                load       : store.load?.bind(store),\n                commit     : store.commit.bind(store)\n            });\n            client.store     = store;\n\n            me.originalStore.ion({\n                name      : 'originalStore',\n                refresh   : me.onOriginalStoreRefresh,\n                add       : me.onOriginalStoreChanged,\n                remove    : me.onOriginalStoreChanged,\n                removeAll : me.onOriginalStoreChanged,\n                thisObj   : me\n            });\n        }\n\n        await me.waitForReadiness();\n\n        if (me.isDestroyed) {\n            return;\n        }\n\n        // Applying custom levels\n        if (levels) {\n            // Plug links in to allow transforming them below\n            store.data = me.originalStore.allRecords.flatMap(record => record.isLeaf ? [record.link()] : []);\n\n            // Transform it according to levels\n            result = store.treeify(levels, parentData => {\n                // Use group key as tree columns content\n                ObjectHelper.setPath(parentData, store.modelClass.getFieldDataSource(treeColumn.field), parentData.key);\n\n                // Let the outside world manipulate generated parents data before turning it into a record\n                me.processParentData(parentData);\n            });\n\n            me.processTransformedData(result);\n\n            // Load the transformed result into the \"display store\"\n            store.data = result.children;\n        }\n        // Clearing custom levels\n        else {\n            client.store = me.originalStore;\n            me.detachListeners('originalStore');\n            me.originalStore = null;\n        }\n\n        me.isApplying--;\n\n        client.resumeRefresh();\n        client.rowManager.reinitialize();\n\n        return result;\n    }\n\n    onOriginalStoreChanged() {\n        this.applyLevels(this._levels);\n    }\n\n    onOriginalStoreRefresh({ action }) {\n        if (action === 'dataset') {\n            this.applyLevels(this.levels);\n        }\n    }\n\n    updateLevels(levels) {\n        if (levels || !this.isConfiguring) {\n            this.applyLevels(levels);\n        }\n    }\n\n    /**\n     * Transforms the data according to the supplied levels.\n     *\n     * Yields the same result as assigning to {@link #property-levels}.\n     *\n     * ```javascript\n     * // Transform into a tree with two parent levels\n     * grid.group('status', record => (record.percentDone % 10) * 10);\n     * ```\n     *\n     * @param {Array<String|Function(Core.data.Model) : any>} levels Field names or functions use to generate parents in resulting tree.\n     * @on-owner\n     * @category Common\n     */\n    async group(levels) {\n        ObjectHelper.assertArray(levels, 'group()');\n\n        await this.applyLevels(levels);\n    }\n\n    /**\n     * Clears the previously applied transformation, restoring data to its initial state.\n     *\n     * Yields the same result as assigning `null` to {@link #property-levels}.\n     *\n     * ```javascript\n     * // Restore original data\n     * grid.clearGroupers();\n     * ```\n     * @on-owner\n     * @category Common\n     */\n    async clearGroups() {\n        if (this.isGrouped) {\n            await this.applyLevels(null);\n        }\n    }\n\n    get isGrouped() {\n        return Boolean(this._levels);\n    }\n}\n\nGridFeatureManager.registerFeature(TreeGroup);\n"],
  "mappings": "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",
  "names": ["RowReorder", "Delayable", "InstancePlugin", "deprecatedEvents", "gridRowBeforeDragStart", "product", "invalidAsOfVersion", "message", "gridRowDragStart", "gridRowDrag", "gridRowBeforeDropFinalize", "gridRowDrop", "gridRowAbort", "construct", "grid", "config", "arguments", "doDestroy", "_this$dragHelper", "dragHelper", "destroy", "init", "me", "DragHelper", "new", "name", "cloneTarget", "dragThreshold", "proxyTopOffset", "targetSelector", "lockX", "dragWithin", "bodyContainer", "allowDropOutside", "scrollManager", "outerElement", "targetSubGridElement", "touchStartDelay", "isElementDraggable", "bind", "monitoringConfig", "scrollables", "element", "scrollable", "direction", "setXY", "x", "y", "context", "started", "elementRect", "Rectangle", "from", "pointerDownOffset", "startPageY", "globalThis", "pageYOffset", "getBoundingClientRect", "top", "DomHelper", "setTranslateXY", "ignoreSamePositionDrop", "createProxy", "clone", "cloneNode", "container", "document", "createElement", "classList", "add", "removeAttribute", "style", "transform", "width", "appendChild", "selectedRecords", "length", "clone2", "removeClsGlobally", "internalListeners", "beforedragstart", "dragstart", "drag", "drop", "reset", "prio", "thisObj", "dragHelperConfig", "relayEvents", "dropIndicator", "className", "dropOverTargetCls", "targetSubGrid", "regions", "subGrids", "el", "event", "closest", "gripOnly", "firstCell", "gripperStyle", "getComputedStyle", "offsetX", "rtl", "borderOffsetX", "onGrip", "roundPx", "parseFloat", "client", "preventDragSelect", "onBeforeDragStart", "source", "subGridEl", "disabled", "readOnly", "isTreeGrouped", "contains", "startRecord", "getRecordFromElement", "isSpecialRow", "originalRowTop", "rowManager", "getRowFor", "selectionMode", "checkboxOnly", "startEvent", "pointerType", "isSelected", "selectRow", "record", "addToSelection", "shiftKey", "ctrlKey", "filter", "r", "records", "includes", "push", "sort", "r1", "r2", "store", "indexOf", "onDragStart", "_cellMenu$hideContext", "_headerMenu$hideConte", "cellEdit", "cellMenu", "headerMenu", "features", "cellEditDisabledState", "hideContextMenu", "call", "focusedCell", "querySelector", "remove", "firstElementChild", "onDrag", "clientY", "valid", "row", "getRowAt", "overRecord", "dataIndex", "after", "over", "insertBefore", "rowTop", "quarter", "height", "topQuarter", "middleY", "bottomQuarter", "getAt", "tree", "isParent", "dropOnLeaf", "isGrouped", "isGroupHeader", "meta", "collapsed", "pageY", "_bodyRectangle", "first", "count", "last", "getRow", "reorderValid", "_rowManager$getRowByI", "getRowById", "removeCls", "nextSibling", "some", "rec", "parent", "clearTimeout", "hoverTimer", "isExpanded", "setTimeout", "expand", "hoverExpandTimeout", "toggleCls", "setTranslateY", "Math", "max", "visibility", "toggle", "onDrop", "async", "oldPositionContext", "map", "_record$parent", "parentId", "id", "parentIndex", "result", "trigger", "animateProxyTo", "align", "finalizeReorder", "_context$parent$child", "_context$parent$child2", "bubbleWhile", "tryInsertChild", "children", "forEach", "move", "_rowIndex", "_focusedCell", "focusCell", "columnId", "clearSorters", "finalize", "onReset", "onPaint", "firstPaint", "updateShowGrip", "show", "__publicField", "$name", "configurable", "showGrip", "pluginConfig", "featureClass", "_$name", "GridFeatureManager", "registerFeature", "TreeGroup", "hasFeature", "Error", "processParentData", "parentData", "parentCls", "cls", "processTransformedData", "transformedData", "waitForReadiness", "originalStore", "isLoading", "await", "isDestroyed", "crudManager", "isLoadingOrSyncing", "_autoLoadPromise", "project", "commitAsync", "applyLevels", "levels", "treeColumn", "columns", "find", "col", "TreeColumn", "_levels", "isApplying", "suspendRefresh", "_store$load", "constructor", "modelClass", "load", "commit", "ion", "refresh", "onOriginalStoreRefresh", "onOriginalStoreChanged", "removeAll", "data", "allRecords", "flatMap", "isLeaf", "link", "treeify", "ObjectHelper", "setPath", "getFieldDataSource", "field", "key", "detachListeners", "resumeRefresh", "reinitialize", "action", "updateLevels", "isConfiguring", "group", "assertArray", "clearGroups", "Boolean", "assign", "properties"]
}
