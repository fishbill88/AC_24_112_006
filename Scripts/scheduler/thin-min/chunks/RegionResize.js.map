{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/column/NumberColumn.js", "../../../../Grid/lib/Grid/feature/RegionResize.js"],
  "sourcesContent": ["import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport NumberFormat from '../../Core/helper/util/NumberFormat.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/column/NumberColumn\n */\n\n/**\n * A column for showing/editing numbers.\n *\n * Default editor is a {@link Core.widget.NumberField NumberField}.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *     columns : [\n *         { type: 'number', min: 0, max : 100, field: 'score' }\n *     ]\n * });\n * ```\n *\n * Provide a {@link Core/helper/util/NumberFormat} config as {@link #config-format} to be able to show currency. For\n * example:\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *     columns : [\n *         {\n *             type   : 'number',\n *             format : {\n *                style    : 'currency'\n *                currency : 'USD',\n *             }\n *         }\n *     ]\n * });\n * ```\n *\n * @extends Grid/column/Column\n * @classType number\n * @inlineexample Grid/column/NumberColumn.js\n * @column\n */\nexport default class NumberColumn extends Column {\n    //region Config\n\n    static type = 'number';\n\n    // Type to use when auto adding field\n    static fieldType = 'number';\n\n    static fields = [\n        'format',\n\n        /**\n         * The minimum value for the field used during editing.\n         * @config {Number} min\n         * @category Common\n         */\n        'min',\n\n        /**\n         * The maximum value for the field used during editing.\n         * @config {Number} max\n         * @category Common\n         */\n        'max',\n\n        /**\n         * Step size for the field used during editing.\n         * @config {Number} step\n         * @category Common\n         */\n        'step',\n\n        /**\n         * Large step size for the field used during editing. In effect for `SHIFT + click/arrows`\n         * @config {Number} largeStep\n         * @category Common\n         */\n        'largeStep',\n\n        /**\n         * Unit to append to displayed value.\n         * @config {String} unit\n         * @category Common\n         */\n        'unit'\n    ];\n\n    static get defaults() {\n        return {\n            filterType : 'number',\n\n            /**\n             * The format to use for rendering numbers.\n             *\n             * By default, the locale's default number formatter is used. For `en-US`, the\n             * locale default is a maximum of 3 decimal digits, using thousands-based grouping.\n             * This would render the number `1234567.98765` as `'1,234,567.988'`.\n             *\n             * @config {String|NumberFormatConfig}\n             */\n            format : ''\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    get defaultEditor() {\n        const { format, name, max, min, step, largeStep, align } = this;\n\n        // Remove any undefined configs, to allow config system to use default values instead\n        return ObjectHelper.cleanupProperties({\n            type      : 'numberfield',\n            format,\n            name,\n            max,\n            min,\n            step,\n            largeStep,\n            textAlign : align\n        });\n    }\n\n    get formatter() {\n        const\n            me         = this,\n            { format } = me;\n\n        let formatter = me._formatter;\n\n        if (!formatter || me._lastFormat !== format) {\n            me._formatter = formatter = NumberFormat.get(me._lastFormat = format);\n        }\n\n        return formatter;\n    }\n\n    formatValue(value) {\n        if (value != null) {\n            value = this.formatter.format(value);\n\n            if (this.unit) {\n                value = `${value}${this.unit}`;\n            }\n        }\n        return value ?? '';\n    }\n\n    /**\n     * Renderer that displays value + optional unit in the cell\n     * @private\n     */\n    defaultRenderer({ value }) {\n        return this.formatValue(value);\n    }\n}\n\nColumnStore.registerColumnType(NumberColumn, true);\nNumberColumn.exposeProperties();\n", "import EventHelper from '../../Core/helper/EventHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/RegionResize\n */\n\n/**\n * Makes the splitter between grid section draggable so you can resize grid sections.\n *\n * {@inlineexample Grid/feature/RegionResize.js}\n *\n * ```javascript\n * // enable RegionResize\n * const grid = new Grid({\n *   features: {\n *     regionResize: true\n *   }\n * });\n * ```\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/features\n * @classtype regionResize\n * @feature\n */\nexport default class RegionResize extends InstancePlugin {\n    // region Init\n\n    static $name = 'RegionResize';\n\n    static get pluginConfig() {\n        return {\n            chain : ['onElementPointerDown', 'onElementDblClick', 'onElementTouchMove', 'onSubGridCollapse', 'onSubGridExpand', 'render']\n        };\n    }\n\n    //endregion\n\n    onElementDblClick(event) {\n        const\n            me         = this,\n            { client } = me,\n            splitterEl = event.target.closest('.b-grid-splitter-collapsed');\n\n        // If collapsed splitter is dblclicked and region is not expanding\n        // It is unlikely that user might dblclick splitter twice and even if he does, nothing should happen.\n        // But just in case lets not expand twice.\n        if (splitterEl && !me.expanding) {\n            me.expanding = true;\n\n            let region  = splitterEl.dataset.region,\n                subGrid = client.getSubGrid(region);\n\n            // Usually collapsed splitter means corresponding region is collapsed. But in case of last two regions one\n            // splitter can be collapsed in two directions. So, if corresponding region is expanded then last one is collapsed\n            if (!subGrid.collapsed) {\n                region = client.getLastRegions()[1];\n                subGrid = client.getSubGrid(region);\n            }\n\n            subGrid.expand().then(() => me.expanding = false);\n        }\n    }\n\n    //region Move splitter\n\n    /**\n     * Begin moving splitter.\n     * @private\n     * @param splitterElement Splitter element\n     * @param clientX Initial x position from which new width will be calculated on move\n     */\n    startMove(splitterElement, clientX) {\n        const\n            me              = this,\n            { client }      = me,\n            region          = splitterElement.dataset.region,\n            gridEl          = client.element,\n            nextRegion      = client.regions[client.regions.indexOf(region) + 1],\n            nextSubGrid     = client.getSubGrid(nextRegion),\n            splitterSubGrid = client.getSubGrid(region);\n\n        let\n            subGrid = splitterSubGrid,\n            flip    = 1;\n\n        if (subGrid.flex != null) {\n            // If subgrid has flex, check if next one does not\n            if (nextSubGrid.flex == null) {\n                subGrid = nextSubGrid;\n                flip = -1;\n            }\n        }\n\n        if (client.rtl) {\n            flip *= -1;\n        }\n\n        if (splitterElement.classList.contains('b-grid-splitter-collapsed')) {\n            return;\n        }\n\n        const availableWidth = subGrid.element.offsetWidth + nextSubGrid.element.offsetWidth;\n\n        me.dragContext = {\n            element       : splitterElement,\n            headerEl      : subGrid.header.element,\n            subGridEl     : subGrid.element,\n            subGrid,\n            splitterSubGrid,\n            originalWidth : subGrid.element.offsetWidth,\n            originalX     : clientX,\n            minWidth      : subGrid.minWidth || 0,\n            maxWidth      : Math.min(availableWidth, subGrid.maxWidth || availableWidth),\n            flip\n        };\n\n        gridEl.classList.add('b-moving-splitter');\n        splitterSubGrid.toggleSplitterCls('b-moving');\n\n        me.pointerDetacher = EventHelper.on({\n            element     : document,\n            pointermove : 'onPointerMove',\n            pointerup   : 'onPointerUp',\n            thisObj     : me\n        });\n    }\n\n    /**\n     * Stop moving splitter.\n     * @private\n     */\n    endMove() {\n        const\n            me              = this,\n            { dragContext } = me;\n\n        if (dragContext) {\n            me.pointerDetacher();\n            me.client.element.classList.remove('b-moving-splitter');\n            dragContext.splitterSubGrid.toggleSplitterCls('b-moving', false);\n            me.dragContext = null;\n        }\n    }\n\n    onCollapseClick(subGrid, splitterEl, domEvent) {\n        const\n            me         = this,\n            { client } = me,\n            region     = splitterEl.dataset.region,\n            regions    = client.getLastRegions();\n\n        /**\n         * Fired by the Grid when the collapse icon is clicked. Return `false` to prevent the default collapse action,\n         * if you want to implement your own behavior.\n         * @event splitterCollapseClick\n         * @on-owner\n         * @preventable\n         * @param {Grid.view.Grid} source The Grid instance.\n         * @param {Grid.view.SubGrid} subGrid The subgrid\n         * @param {Event} domEvent The native DOM event\n         */\n        if (client.trigger('splitterCollapseClick', { subGrid, domEvent }) === false) {\n            return;\n        }\n        // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the\n        // left one. Check if we are working with last splitter\n        if (regions[0] === region) {\n            const lastSubGrid = client.getSubGrid(regions[1]);\n            if (lastSubGrid.collapsed) {\n                lastSubGrid.expand();\n                return;\n            }\n        }\n\n        subGrid.collapse();\n    }\n\n    onExpandClick(subGrid, splitterEl, domEvent) {\n        const\n            me         = this,\n            { client } = me,\n            region     = splitterEl.dataset.region,\n            regions    = client.getLastRegions();\n\n        /**\n         * Fired by the Grid when the expand icon is clicked. Return `false` to prevent the default expand action,\n         * if you want to implement your own behavior.\n         * @event splitterExpandClick\n         * @preventable\n         * @param {Grid.view.Grid} source The Grid instance.\n         * @param {Grid.view.SubGrid} subGrid The subgrid\n         * @param {Event} domEvent The native DOM event\n         */\n        if (client.trigger('splitterExpandClick', { subGrid, domEvent }) === false) {\n            return;\n        }\n\n        // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the\n        // left one. Check if we are working with last splitter\n        if (regions[0] === region) {\n            if (!subGrid.collapsed) {\n                const lastSubGrid = client.getSubGrid(regions[1]);\n                lastSubGrid.collapse();\n                return;\n            }\n        }\n\n        subGrid.expand();\n    }\n\n    /**\n     * Update splitter position.\n     * @private\n     * @param newClientX\n     */\n    updateMove(newClientX) {\n        const { dragContext } = this;\n\n        if (dragContext) {\n            const\n                difX     = newClientX - dragContext.originalX,\n                newWidth = Math.max(Math.min(dragContext.maxWidth, dragContext.originalWidth + difX * dragContext.flip), 0);\n\n            // SubGrids monitor their own size and keep any splitters synced\n            dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Start moving splitter on mouse down (on splitter).\n     * @private\n     * @param event\n     */\n    onElementPointerDown(event) {\n        const\n            me            = this,\n            { target }    = event,\n            // Only care about left clicks, avoids a bug found by monkeys\n            splitter      = event.button === 0 && target.closest(':not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter'),\n            subGrid       = splitter && me.client.getSubGrid(splitter.dataset.region);\n\n        let toggle;\n\n        if (splitter) {\n            if (target.closest('.b-grid-splitter-button-collapse')) {\n                me.onCollapseClick(subGrid, splitter, event);\n            }\n            else if (target.closest('.b-grid-splitter-button-expand')) {\n                me.onExpandClick(subGrid, splitter, event);\n            }\n            else {\n                me.startMove(splitter, event.clientX);\n                toggle = splitter;\n            }\n        }\n\n        if (event.pointerType === 'touch') {\n            // Touch on splitter makes splitter wider, touch outside or expand/collapse makes it smaller again\n            me.toggleTouchSplitter(toggle);\n        }\n    }\n\n    /**\n     * Move splitter on mouse move.\n     * @private\n     * @param event\n     */\n    onPointerMove(event) {\n        if (this.dragContext) {\n            this.updateMove(event.clientX);\n            event.preventDefault();\n        }\n    }\n\n    onElementTouchMove(event) {\n        if (this.dragContext) {\n            // Needed to prevent scroll in Mobile Safari, preventing pointermove is not enough\n            event.preventDefault();\n        }\n    }\n\n    /**\n     * Stop moving splitter on mouse up.\n     * @private\n     * @param event\n     */\n    onPointerUp(event) {\n        if (this.dragContext) {\n            this.endMove();\n            event.preventDefault();\n        }\n    }\n\n    onSubGridCollapse({ subGrid }) {\n        const\n            splitterEl = this.client.resolveSplitter(subGrid),\n            regions    = this.client.getLastRegions();\n\n        // if last region was collapsed\n        if (regions[1] === subGrid.region) {\n            splitterEl.classList.add('b-grid-splitter-allow-collapse');\n        }\n    }\n\n    onSubGridExpand({ subGrid }) {\n        const splitterEl = this.client.resolveSplitter(subGrid);\n        splitterEl.classList.remove('b-grid-splitter-allow-collapse');\n    }\n\n    //endregion\n\n    /**\n     * Adds b-touching CSS class to splitterElements when touched. Removes when touched outside.\n     * @private\n     * @param splitterElement\n     */\n    toggleTouchSplitter(splitterElement) {\n        const\n            me                  = this,\n            { touchedSplitter } = me;\n\n        // If other splitter is touched, deactivate old one\n        if (splitterElement && touchedSplitter && splitterElement.dataset.region !== touchedSplitter.dataset.region) {\n            me.toggleTouchSplitter();\n        }\n\n        // Either we have touched a splitter (should activate) or touched outside (should deactivate)\n        const splitterSubGrid = me.client.getSubGrid(splitterElement ? splitterElement.dataset.region : touchedSplitter?.dataset.region);\n        if (splitterSubGrid) {\n            splitterSubGrid.toggleSplitterCls('b-touching', Boolean(splitterElement));\n            if (splitterElement) {\n                splitterSubGrid.startSplitterButtonSyncing();\n            }\n            else {\n                splitterSubGrid.stopSplitterButtonSyncing();\n            }\n        }\n\n        me.touchedSplitter = splitterElement;\n    }\n\n    render() {\n        const { regions, subGrids } = this.client;\n\n        // Multiple regions, only allow collapsing to the edges by hiding buttons\n        if (regions.length > 2) {\n            // Only works in a 3 subgrid scenario. To support more subgrids we have to merge splitters or something\n            // on collapse. Not going down that path currently...\n            subGrids[regions[0]].splitterElement.classList.add('b-left-only');\n            subGrids[regions[1]].splitterElement.classList.add('b-right-only');\n        }\n    }\n}\n\nRegionResize.featureClass = 'b-split';\n\nGridFeatureManager.registerFeature(RegionResize);\n"],
  "mappings": "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",
  "names": ["NumberColumn", "Column", "defaults", "filterType", "format", "defaultEditor", "name", "max", "min", "step", "largeStep", "align", "ObjectHelper", "cleanupProperties", "type", "textAlign", "formatter", "me", "_formatter", "_lastFormat", "NumberFormat", "get", "formatValue", "value", "unit", "defaultRenderer", "__publicField", "fieldType", "fields", "ColumnStore", "registerColumnType", "exposeProperties", "_$name", "RegionResize", "InstancePlugin", "pluginConfig", "chain", "onElementDblClick", "event", "client", "splitterEl", "target", "closest", "expanding", "region", "dataset", "subGrid", "getSubGrid", "collapsed", "getLastRegions", "expand", "then", "startMove", "splitterElement", "clientX", "gridEl", "element", "nextRegion", "regions", "indexOf", "nextSubGrid", "splitterSubGrid", "flip", "flex", "rtl", "classList", "contains", "availableWidth", "offsetWidth", "dragContext", "headerEl", "header", "subGridEl", "originalWidth", "originalX", "minWidth", "maxWidth", "Math", "add", "toggleSplitterCls", "pointerDetacher", "EventHelper", "on", "document", "pointermove", "pointerup", "thisObj", "endMove", "remove", "onCollapseClick", "domEvent", "trigger", "lastSubGrid", "collapse", "onExpandClick", "updateMove", "newClientX", "difX", "newWidth", "width", "onElementPointerDown", "splitter", "button", "toggle", "pointerType", "toggleTouchSplitter", "onPointerMove", "preventDefault", "onElementTouchMove", "onPointerUp", "onSubGridCollapse", "resolveSplitter", "onSubGridExpand", "touchedSplitter", "Boolean", "startSplitterButtonSyncing", "stopSplitterButtonSyncing", "render", "subGrids", "length", "$name", "featureClass", "GridFeatureManager", "registerFeature"]
}
