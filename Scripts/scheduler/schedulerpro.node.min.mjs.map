{
  "version": 3,
  "sources": ["../../Engine/lib/Engine/vendor/later/later.js", "../../chronograph/src/collection/Iterator.js", "../../chronograph/src/class/Mixin.js", "../../chronograph/src/class/Base.js", "../../Core/lib/Core/helper/BrowserHelper.js", "../../Core/lib/Core/helper/StringHelper.js", "../../Core/lib/Core/helper/util/Objects.js", "../../Core/lib/Core/helper/VersionHelper.js", "../../Core/lib/Core/Config.js", "../../Core/lib/Core/Base.js", "../../Core/lib/Core/helper/AjaxHelper.js", "../../Core/lib/Core/helper/ArrayHelper.js", "../../Core/lib/Core/helper/FunctionHelper.js", "../../Core/lib/Core/mixin/Events.js", "../../Core/lib/Core/localization/LocaleHelper.js", "../../Core/lib/Core/localization/LocaleManager.js", "../../Core/lib/Core/localization/Localizable.js", "../../Core/lib/Core/localization/En.js", "../../Core/lib/Core/helper/DateHelper.js", "../../Engine/lib/Engine/scheduling/Types.js", "../../Engine/lib/Engine/util/Constants.js", "../../Engine/lib/Engine/util/Types.js", "../../Engine/lib/Engine/calendar/CalendarCache.js", "../../Engine/lib/Engine/util/StripDuplicates.js", "../../Engine/lib/Engine/calendar/CalendarCacheInterval.js", "../../Engine/lib/Engine/calendar/CalendarCacheIntervalMultiple.js", "../../Engine/lib/Engine/util/BinarySearch.js", "../../Engine/lib/Engine/calendar/SortedMap.js", "../../Engine/lib/Engine/calendar/IntervalCache.js", "../../Engine/lib/Engine/calendar/CalendarCacheMultiple.js", "../../Core/lib/Core/helper/TimeZoneHelper.js", "../../Engine/lib/Engine/calendar/CalendarCacheSingle.js", "../../Engine/lib/Engine/quark/AbstractPartOfProjectGenericMixin.js", "../../Core/lib/Core/helper/ObjectHelper.js", "../../Core/lib/Core/mixin/InstancePlugin.js", "../../Core/lib/Core/mixin/Pluggable.js", "../../Core/lib/Core/mixin/Delayable.js", "../../Core/lib/Core/state/StateStorage.js", "../../Core/lib/Core/state/StateProvider.js", "../../Core/lib/Core/mixin/State.js", "../../Core/lib/Core/mixin/Identifiable.js", "../../Core/lib/Core/data/stm/mixin/ModelStm.js", "../../Core/lib/Core/data/mixin/TreeNode.js", "../../Core/lib/Core/data/mixin/ModelLink.js", "../../Core/lib/Core/mixin/Factoryable.js", "../../Core/lib/Core/data/field/DataField.js", "../../Core/lib/Core/data/field/ArrayDataField.js", "../../Core/lib/Core/data/field/BooleanDataField.js", "../../Core/lib/Core/data/field/DateDataField.js", "../../Core/lib/Core/data/field/StringDataField.js", "../../Core/lib/Core/data/field/DurationUnitDataField.js", "../../Core/lib/Core/data/field/IntegerDataField.js", "../../Core/lib/Core/data/field/ModelDataField.js", "../../Core/lib/Core/data/field/NumberDataField.js", "../../Core/lib/Core/data/field/ObjectDataField.js", "../../Core/lib/Core/data/field/StoreDataField.js", "../../Core/lib/Core/data/Model.js", "../../Core/lib/Core/data/Duration.js", "../../Core/lib/Core/util/CollectionFilter.js", "../../Core/lib/Core/helper/IdHelper.js", "../../Core/lib/Core/util/CollectionSorter.js", "../../Core/lib/Core/util/Collection.js", "../../Core/lib/Core/util/Bag.js", "../../Core/lib/Core/data/StoreBag.js", "../../Core/lib/Core/data/mixin/StoreCRUD.js", "../../Core/lib/Core/data/mixin/StoreChanges.js", "../../Core/lib/Core/data/mixin/StoreFilter.js", "../../Core/lib/Core/data/mixin/StoreGroup.js", "../../Core/lib/Core/data/mixin/StoreProxy.js", "../../Core/lib/Core/data/mixin/StoreRelation.js", "../../Core/lib/Core/data/mixin/StoreSum.js", "../../Core/lib/Core/data/mixin/StoreSearch.js", "../../Core/lib/Core/data/mixin/StoreSort.js", "../../Core/lib/Core/data/mixin/StoreChained.js", "../../Core/lib/Core/data/mixin/StoreState.js", "../../Core/lib/Core/data/Wbs.js", "../../Core/lib/Core/data/mixin/StoreTree.js", "../../Core/lib/Core/helper/WalkHelper.js", "../../Core/lib/Core/data/mixin/StoreSync.js", "../../Core/lib/Core/data/stm/mixin/StoreStm.js", "../../Core/lib/Core/data/Store.js", "../../Engine/lib/Engine/quark/store/mixin/AbstractPartOfProjectStoreMixin.js", "../../Engine/lib/Engine/quark/model/mixin/AbstractPartOfProjectModelMixin.js", "../../Engine/lib/Engine/calendar/CalendarIntervalMixin.js", "../../Engine/lib/Engine/calendar/CalendarIntervalStore.js", "../../Engine/lib/Engine/calendar/UnspecifiedTimeIntervalModel.js", "../../Engine/lib/Engine/quark/CorePartOfProjectGenericMixin.js", "../../Engine/lib/Engine/quark/model/AbstractCalendarMixin.js", "../../Engine/lib/Engine/quark/model/AbstractHasAssignmentsMixin.js", "../../Engine/lib/Engine/quark/model/mixin/CorePartOfProjectModelMixin.js", "../../Engine/lib/Engine/util/Functions.js", "../../Engine/lib/Engine/quark/store/AbstractAssignmentStoreMixin.js", "../../Engine/lib/Engine/quark/store/AbstractCalendarManagerStoreMixin.js", "../../Engine/lib/Engine/quark/store/AbstractDependencyStoreMixin.js", "../../Engine/lib/Engine/quark/store/AbstractEventStoreMixin.js", "../../Engine/lib/Engine/quark/store/AbstractResourceStoreMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreEventMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreResourceMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreAssignmentMixin.js", "../../Engine/lib/Engine/quark/store/mixin/CorePartOfProjectStoreMixin.js", "../../Engine/lib/Engine/quark/store/CoreAssignmentStoreMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreCalendarMixin.js", "../../Engine/lib/Engine/quark/store/CoreCalendarManagerStoreMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreDependencyMixin.js", "../../Engine/lib/Engine/quark/store/CoreDependencyStoreMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreHasAssignmentsMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/CoreHasDependenciesMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreEvent.js", "../../Engine/lib/Engine/quark/store/CoreEventStoreMixin.js", "../../Engine/lib/Engine/quark/store/CoreResourceStoreMixin.js", "../../Core/lib/Core/data/stm/state/StateBase.js", "../../Core/lib/Core/data/stm/Props.js", "../../Core/lib/Core/data/stm/state/Registry.js", "../../Core/lib/Core/data/stm/Helpers.js", "../../Core/lib/Core/data/stm/state/DisabledState.js", "../../Core/lib/Core/data/stm/Transaction.js", "../../Core/lib/Core/data/stm/state/ReadyState.js", "../../Core/lib/Core/data/stm/state/RecordingState.js", "../../Core/lib/Core/data/stm/state/RestoringState.js", "../../Core/lib/Core/data/stm/state/AutoReadyState.js", "../../Core/lib/Core/data/stm/state/AutoRecordingState.js", "../../Core/lib/Core/data/stm/action/ActionBase.js", "../../Core/lib/Core/data/stm/action/UpdateAction.js", "../../Core/lib/Core/data/stm/action/InsertChildAction.js", "../../Core/lib/Core/data/stm/action/RemoveChildAction.js", "../../Core/lib/Core/data/stm/action/AddAction.js", "../../Core/lib/Core/data/stm/action/InsertAction.js", "../../Core/lib/Core/data/stm/action/RemoveAction.js", "../../Core/lib/Core/data/stm/action/RemoveAllAction.js", "../../Core/lib/Core/data/stm/StateTrackingManager.js", "../../Engine/lib/Engine/quark/model/AbstractProjectMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreProjectMixin.js", "../../chronograph/src/util/Helpers.js", "../../chronograph/src/environment/Debug.js", "../../chronograph/src/class/RequiredProperty.js", "../../chronograph/src/graph/WalkDepth.js", "../../chronograph/src/cycle_resolver/CycleResolver.js", "../../chronograph/src/chrono/Effect.js", "../../chronograph/src/chrono/CycleResolver.js", "../../chronograph/src/primitives/Calculation.js", "../../chronograph/src/chrono/Quark.js", "../../chronograph/src/chrono/Identifier.js", "../../chronograph/src/chrono/Revision.js", "../../chronograph/src/util/LeveledQueue.js", "../../chronograph/src/chrono/TransactionCycleDetectionWalkContext.js", "../../chronograph/src/chrono/TransactionWalkDepth.js", "../../chronograph/src/chrono/Transaction.js", "../../chronograph/src/chrono/Graph.js", "../../chronograph/src/schema/EntityMeta.js", "../../chronograph/src/replica/Replica.js", "../../chronograph/src/replica/Identifier.js", "../../chronograph/src/schema/Field.js", "../../chronograph/src/replica/Entity.js", "../../chronograph/src/replica/Reference.js", "../../chronograph/src/replica/ReferenceBucket.js", "../../chronograph/src/schema/Schema.js", "../../Engine/lib/Engine/chrono/ModelFieldAtom.js", "../../Engine/lib/Engine/chrono/ChronoModelMixin.js", "../../Engine/lib/Engine/localization/En.js", "../../Engine/lib/Engine/scheduling/DateInterval.js", "../../Engine/lib/Engine/chrono/SchedulingIssueEffect.js", "../../Engine/lib/Engine/chrono/Conflict.js", "../../Engine/lib/Engine/quark/ChronoPartOfProjectGenericMixin.js", "../../Engine/lib/Engine/quark/store/mixin/ChronoStoreMixin.js", "../../Engine/lib/Engine/quark/store/mixin/ChronoPartOfProjectStoreMixin.js", "../../Engine/lib/Engine/quark/model/mixin/ChronoPartOfProjectModelMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseCalendarMixin.js", "../../Engine/lib/Engine/chrono/Replica.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseAssignmentMixin.js", "../../Engine/lib/Engine/quark/store/ChronoAssignmentStoreMixin.js", "../../Engine/lib/Engine/quark/store/ChronoCalendarManagerStoreMixin.js", "../../Engine/lib/Engine/quark/store/ChronoDependencyStoreMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseEventDispatcher.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/HasCalendarMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseEventMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseHasAssignmentsMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/HasDependenciesMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicEvent.js", "../../Engine/lib/Engine/quark/store/ChronoEventStoreMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseResourceMixin.js", "../../Engine/lib/Engine/quark/store/ChronoResourceStoreMixin.js", "../../Engine/lib/Engine/scheduling/DurationConverterMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/BaseDependencyMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/ChronoAbstractProjectMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/HasSubEventsMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/HasChildrenMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicProjectMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/ConstrainedEarlyEventMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/HasDateConstraintMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/ScheduledByDependenciesEarlyEventMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProAssignmentMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProDependencyMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/HasPercentDoneMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProHasAssignmentsMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProEventSegment.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SplitEventMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/HasEffortMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/HasEffortDispatcher.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/HasSchedulingModeMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/scheduling_modes/FixedDurationDispatcher.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/scheduling_modes/FixedDurationMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProEvent.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProResourceMixin.js", "../../Engine/lib/Engine/quark/model/scheduler_pro/SchedulerProProjectMixin.js", "../../Core/lib/Core/helper/util/DomClassList.js", "../../Core/lib/Core/data/AjaxStore.js", "../../Core/lib/Core/data/DomDataStore.js", "../lib/SchedulerPro/model/changelog/ChangeLogEntity.js", "../../Grid/lib/Grid/data/GridRowModel.js", "../../Scheduler/lib/Scheduler/crud/mixin/AbstractCrudManagerValidation.js", "../../Scheduler/lib/Scheduler/crud/AbstractCrudManagerMixin.js", "../../Scheduler/lib/Scheduler/crud/AbstractCrudManager.js", "../../Scheduler/lib/Scheduler/crud/transport/AjaxTransport.js", "../../Scheduler/lib/Scheduler/crud/encoder/JsonEncoder.js", "../../Scheduler/lib/Scheduler/model/mixin/TimeZonedDatesMixin.js", "../../Scheduler/lib/Scheduler/model/TimeSpan.js", "../../Scheduler/lib/Scheduler/data/util/recurrence/RecurrenceDayRuleEncoder.js", "../../Scheduler/lib/Scheduler/data/util/recurrence/AbstractRecurrenceIterator.js", "../../Scheduler/lib/Scheduler/data/util/recurrence/DailyRecurrenceIterator.js", "../../Scheduler/lib/Scheduler/data/util/recurrence/WeeklyRecurrenceIterator.js", "../../Scheduler/lib/Scheduler/data/util/recurrence/MonthlyRecurrenceIterator.js", "../../Scheduler/lib/Scheduler/data/util/recurrence/YearlyRecurrenceIterator.js", "../../Scheduler/lib/Scheduler/model/RecurrenceModel.js", "../../Scheduler/lib/Scheduler/model/mixin/RecurringTimeSpan.js", "../../Scheduler/lib/Scheduler/model/ResourceTimeRangeModel.js", "../../Scheduler/lib/Scheduler/data/mixin/RecurringTimeSpansMixin.js", "../../Scheduler/lib/Scheduler/data/ResourceTimeRangeStore.js", "../../Scheduler/lib/Scheduler/data/mixin/PartOfProject.js", "../../Scheduler/lib/Scheduler/model/mixin/AssignmentModelMixin.js", "../../Scheduler/lib/Scheduler/model/AssignmentModel.js", "../../Scheduler/lib/Scheduler/data/mixin/AssignmentStoreMixin.js", "../../Scheduler/lib/Scheduler/data/AssignmentStore.js", "../../Scheduler/lib/Scheduler/data/mixin/EventStoreMixin.js", "../../Scheduler/lib/Scheduler/data/mixin/GetEventsMixin.js", "../../Core/lib/Core/util/DayTime.js", "../../Scheduler/lib/Scheduler/data/util/EventDayIndex.js", "../../Scheduler/lib/Scheduler/data/mixin/DayIndexMixin.js", "../../Scheduler/lib/Scheduler/data/mixin/SharedEventStoreMixin.js", "../../Scheduler/lib/Scheduler/data/mixin/RecurringEventsMixin.js", "../../Scheduler/lib/Scheduler/model/mixin/EventModelMixin.js", "../../Scheduler/lib/Scheduler/model/EventModel.js", "../../Scheduler/lib/Scheduler/data/EventStore.js", "../../Scheduler/lib/Scheduler/data/mixin/ResourceStoreMixin.js", "../../Scheduler/lib/Scheduler/model/mixin/ResourceModelMixin.js", "../../Scheduler/lib/Scheduler/model/ResourceModel.js", "../../Scheduler/lib/Scheduler/data/ResourceStore.js", "../../Scheduler/lib/Scheduler/model/DependencyBaseModel.js", "../../Scheduler/lib/Scheduler/model/DependencyModel.js", "../../Scheduler/lib/Scheduler/data/mixin/DependencyStoreMixin.js", "../../Scheduler/lib/Scheduler/data/DependencyStore.js", "../../Scheduler/lib/Scheduler/data/mixin/ProjectCrudManager.js", "../../Scheduler/lib/Scheduler/model/mixin/ProjectModelCommon.js", "../../Scheduler/lib/Scheduler/model/mixin/ProjectModelTimeZoneMixin.js", "../../Scheduler/lib/Scheduler/model/mixin/ProjectModelMixin.js", "../../Scheduler/lib/Scheduler/model/mixin/ProjectCurrentConfig.js", "../../Scheduler/lib/Scheduler/data/util/ModelPersistencyManager.js", "../../Scheduler/lib/Scheduler/model/ProjectModel.js", "../lib/SchedulerPro/data/mixin/PartOfProject.js", "../lib/SchedulerPro/model/AssignmentModel.js", "../lib/SchedulerPro/data/AssignmentStore.js", "../lib/SchedulerPro/model/CalendarIntervalModel.js", "../lib/SchedulerPro/model/CalendarModel.js", "../lib/SchedulerPro/data/CalendarManagerStore.js", "../lib/SchedulerPro/model/DependencyModel.js", "../lib/SchedulerPro/data/DependencyStore.js", "../lib/SchedulerPro/model/mixin/PercentDoneMixin.js", "../lib/SchedulerPro/model/EventSegmentModel.js", "../lib/SchedulerPro/model/EventModel.js", "../lib/SchedulerPro/data/EventStore.js", "../lib/SchedulerPro/model/ResourceModel.js", "../lib/SchedulerPro/data/ResourceStore.js", "../lib/SchedulerPro/data/mixin/ProjectCrudManager.js", "../lib/SchedulerPro/model/mixin/ProjectChangeHandlerMixin.js", "../lib/SchedulerPro/data/stm/action/EventUpdateAction.js", "../lib/SchedulerPro/data/stm/StateTrackingManager.js", "../lib/SchedulerPro/model/ProjectModel.js"],
  "sourcesContent": ["// @ts-nocheck\nconst diffSecond = (date, diff) => {\n    return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds() + diff,\n        date.getMilliseconds()\n    );\n};\n/**\n * The code just copy/pasted from pre-built later.js file and made exported\n *\n * @private\n */\nexport const later = (function () {\n    \"use strict\";\n    var later = {\n        version: \"1.2.0\"\n    };\n    if (!Array.prototype.indexOf) {\n        Array.prototype.indexOf = function (searchElement) {\n            \"use strict\";\n            if (this == null) {\n                throw new TypeError();\n            }\n            var t = Object(this);\n            var len = t.length >>> 0;\n            if (len === 0) {\n                return -1;\n            }\n            var n = 0;\n            if (arguments.length > 1) {\n                n = Number(arguments[1]);\n                if (n != n) {\n                    n = 0;\n                }\n                else if (n != 0 && n != Infinity && n != -Infinity) {\n                    n = (n > 0 || -1) * Math.floor(Math.abs(n));\n                }\n            }\n            if (n >= len) {\n                return -1;\n            }\n            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n            for (; k < len; k++) {\n                if (k in t && t[k] === searchElement) {\n                    return k;\n                }\n            }\n            return -1;\n        };\n    }\n    if (!String.prototype.trim) {\n        String.prototype.trim = function () {\n            return this.replace(/^\\s+|\\s+$/g, \"\");\n        };\n    }\n    later.array = {};\n    later.array.sort = function (arr, zeroIsLast) {\n        arr.sort(function (a, b) {\n            return +a - +b;\n        });\n        if (zeroIsLast && arr[0] === 0) {\n            arr.push(arr.shift());\n        }\n    };\n    later.array.next = function (val, values, extent) {\n        var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;\n        for (var i = values.length - 1; i > -1; --i) {\n            cur = values[i];\n            if (cur === val) {\n                return cur;\n            }\n            if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {\n                nextIdx = i;\n                continue;\n            }\n            break;\n        }\n        return values[nextIdx];\n    };\n    later.array.nextInvalid = function (val, values, extent) {\n        var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n        while (next === (values[i] || zeroVal)) {\n            next++;\n            if (next > max) {\n                next = min;\n            }\n            i++;\n            if (i === len) {\n                i = 0;\n            }\n            if (next === start) {\n                return undefined;\n            }\n        }\n        return next;\n    };\n    later.array.prev = function (val, values, extent) {\n        var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;\n        for (var i = 0; i < len; i++) {\n            cur = values[i];\n            if (cur === val) {\n                return cur;\n            }\n            if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {\n                prevIdx = i;\n                continue;\n            }\n            break;\n        }\n        return values[prevIdx];\n    };\n    later.array.prevInvalid = function (val, values, extent) {\n        var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n        while (next === (values[i] || zeroVal)) {\n            next--;\n            if (next < min) {\n                next = max;\n            }\n            i--;\n            if (i === -1) {\n                i = len - 1;\n            }\n            if (next === start) {\n                return undefined;\n            }\n        }\n        return next;\n    };\n    later.day = later.D = {\n        name: \"day\",\n        range: 86400,\n        val: function (d) {\n            return d.D || (d.D = later.date.getDate.call(d));\n        },\n        isValid: function (d, val) {\n            return later.D.val(d) === (val || later.D.extent(d)[1]);\n        },\n        extent: function (d) {\n            if (d.DExtent)\n                return d.DExtent;\n            var month = later.M.val(d), max = later.DAYS_IN_MONTH[month - 1];\n            if (month === 2 && later.dy.extent(d)[1] === 366) {\n                max = max + 1;\n            }\n            return d.DExtent = [1, max];\n        },\n        start: function (d) {\n            return d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d)));\n        },\n        end: function (d) {\n            return d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d)));\n        },\n        next: function (d, val) {\n            val = val > later.D.extent(d)[1] ? 1 : val;\n            var month = later.date.nextRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n            val = val > DMax ? 1 : val || DMax;\n            return later.date.next(later.Y.val(month), later.M.val(month), val);\n        },\n        prev: function (d, val) {\n            var month = later.date.prevRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n            return later.date.prev(later.Y.val(month), later.M.val(month), val > DMax ? DMax : val || DMax);\n        }\n    };\n    later.dayOfWeekCount = later.dc = {\n        name: \"day of week count\",\n        range: 604800,\n        val: function (d) {\n            return d.dc || (d.dc = Math.floor((later.D.val(d) - 1) / 7) + 1);\n        },\n        isValid: function (d, val) {\n            return later.dc.val(d) === val || val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7;\n        },\n        extent: function (d) {\n            return d.dcExtent || (d.dcExtent = [1, Math.ceil(later.D.extent(d)[1] / 7)]);\n        },\n        start: function (d) {\n            return d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, (later.dc.val(d) - 1) * 7 + 1 || 1)));\n        },\n        end: function (d) {\n            return d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));\n        },\n        next: function (d, val) {\n            val = val > later.dc.extent(d)[1] ? 1 : val;\n            var month = later.date.nextRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n            val = val > dcMax ? 1 : val;\n            var next = later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n            if (next.getTime() <= d.getTime()) {\n                month = later.M.next(d, later.M.val(d) + 1);\n                return later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            var month = later.date.prevRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n            val = val > dcMax ? dcMax : val || dcMax;\n            return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), 1 + 7 * (val - 1)));\n        }\n    };\n    later.dayOfWeek = later.dw = later.d = {\n        name: \"day of week\",\n        range: 86400,\n        val: function (d) {\n            return d.dw || (d.dw = later.date.getDay.call(d) + 1);\n        },\n        isValid: function (d, val) {\n            return later.dw.val(d) === (val || 7);\n        },\n        extent: function () {\n            return [1, 7];\n        },\n        start: function (d) {\n            return later.D.start(d);\n        },\n        end: function (d) {\n            return later.D.end(d);\n        },\n        next: function (d, val) {\n            val = val > 7 ? 1 : val || 7;\n            return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));\n        },\n        prev: function (d, val) {\n            val = val > 7 ? 7 : val || 7;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));\n        }\n    };\n    later.dayOfYear = later.dy = {\n        name: \"day of year\",\n        range: 86400,\n        val: function (d) {\n            return d.dy || (d.dy = Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));\n        },\n        isValid: function (d, val) {\n            return later.dy.val(d) === (val || later.dy.extent(d)[1]);\n        },\n        extent: function (d) {\n            var year = later.Y.val(d);\n            return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);\n        },\n        start: function (d) {\n            return later.D.start(d);\n        },\n        end: function (d) {\n            return later.D.end(d);\n        },\n        next: function (d, val) {\n            val = val > later.dy.extent(d)[1] ? 1 : val;\n            var year = later.date.nextRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n            val = val > dyMax ? 1 : val || dyMax;\n            return later.date.next(later.Y.val(year), later.M.val(year), val);\n        },\n        prev: function (d, val) {\n            var year = later.date.prevRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n            val = val > dyMax ? dyMax : val || dyMax;\n            return later.date.prev(later.Y.val(year), later.M.val(year), val);\n        }\n    };\n    later.hour = later.h = {\n        name: \"hour\",\n        range: 3600,\n        val: function (d) {\n            return d.h || (d.h = later.date.getHour.call(d));\n        },\n        isValid: function (d, val) {\n            return later.h.val(d) === val;\n        },\n        extent: function () {\n            return [0, 23];\n        },\n        start: function (d) {\n            return d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n        },\n        end: function (d) {\n            return d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n        },\n        next: function (d, val) {\n            val = val > 23 ? 0 : val;\n            var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.h.val(d) ? 1 : 0), val);\n            if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n                next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), val + 1);\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            val = val > 23 ? 23 : val;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.h.val(d) ? -1 : 0), val);\n        }\n    };\n    later.minute = later.m = {\n        name: \"minute\",\n        range: 60,\n        val: function (d) {\n            return d.m || (d.m = later.date.getMin.call(d));\n        },\n        isValid: function (d, val) {\n            return later.m.val(d) === val;\n        },\n        extent: function (d) {\n            return [0, 59];\n        },\n        start: function (d) {\n            return d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n        },\n        end: function (d) {\n            return d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n        },\n        next: function (d, val) {\n            var m = later.m.val(d), s = later.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later.MIN - s * later.SEC);\n            if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n                next = new Date(d.getTime() + (inc + 120) * later.MIN - s * later.SEC);\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            val = val > 59 ? 59 : val;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d) + (val >= later.m.val(d) ? -1 : 0), val);\n        }\n    };\n    later.month = later.M = {\n        name: \"month\",\n        range: 2629740,\n        val: function (d) {\n            return d.M || (d.M = later.date.getMonth.call(d) + 1);\n        },\n        isValid: function (d, val) {\n            return later.M.val(d) === (val || 12);\n        },\n        extent: function () {\n            return [1, 12];\n        },\n        start: function (d) {\n            return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));\n        },\n        end: function (d) {\n            return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));\n        },\n        next: function (d, val) {\n            val = val > 12 ? 1 : val || 12;\n            return later.date.next(later.Y.val(d) + (val > later.M.val(d) ? 0 : 1), val);\n        },\n        prev: function (d, val) {\n            val = val > 12 ? 12 : val || 12;\n            return later.date.prev(later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0), val);\n        }\n    };\n    later.second = later.s = {\n        name: \"second\",\n        range: 1,\n        val: function (d) {\n            return d.s || (d.s = later.date.getSec.call(d));\n        },\n        isValid: function (d, val) {\n            return later.s.val(d) === val;\n        },\n        extent: function () {\n            return [0, 59];\n        },\n        start: function (d) {\n            return d;\n        },\n        end: function (d) {\n            return d;\n        },\n        next: function (d, val) {\n            var s = later.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later.SEC);\n            if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n                next = new Date(d.getTime() + (inc + 7200) * later.SEC);\n            }\n            return next;\n        },\n        prev: function (d, val, cache) {\n            val = val > 59 ? 59 : val;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d) + (val >= later.s.val(d) ? -1 : 0), val);\n        }\n    };\n    later.time = later.t = {\n        name: \"time\",\n        range: 1,\n        val: function (d) {\n            return d.t || (d.t = later.h.val(d) * 3600 + later.m.val(d) * 60 + later.s.val(d));\n        },\n        isValid: function (d, val) {\n            return later.t.val(d) === val;\n        },\n        extent: function () {\n            return [0, 86399];\n        },\n        start: function (d) {\n            return d;\n        },\n        end: function (d) {\n            return d;\n        },\n        next: function (d, val) {\n            val = val > 86399 ? 0 : val;\n            var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.t.val(d) ? 1 : 0), 0, 0, val);\n            if (!later.date.isUTC && next.getTime() < d.getTime()) {\n                next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), val + 7200);\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            val = val > 86399 ? 86399 : val;\n            return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.t.val(d) ? -1 : 0), 0, 0, val);\n        }\n    };\n    later.weekOfMonth = later.wm = {\n        name: \"week of month\",\n        range: 604800,\n        val: function (d) {\n            return d.wm || (d.wm = (later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);\n        },\n        isValid: function (d, val) {\n            return later.wm.val(d) === (val || later.wm.extent(d)[1]);\n        },\n        extent: function (d) {\n            return d.wmExtent || (d.wmExtent = [1, (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7]);\n        },\n        start: function (d) {\n            return d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));\n        },\n        end: function (d) {\n            return d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));\n        },\n        next: function (d, val) {\n            val = val > later.wm.extent(d)[1] ? 1 : val;\n            var month = later.date.nextRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n            val = val > wmMax ? 1 : val || wmMax;\n            return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2)));\n        },\n        prev: function (d, val) {\n            var month = later.date.prevRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n            val = val > wmMax ? wmMax : val || wmMax;\n            return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2))));\n        }\n    };\n    later.weekOfYear = later.wy = {\n        name: \"week of year (ISO)\",\n        range: 604800,\n        val: function (d) {\n            if (d.wy)\n                return d.wy;\n            var wThur = later.dw.next(later.wy.start(d), 5), YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur) - 1), 5);\n            return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK);\n        },\n        isValid: function (d, val) {\n            return later.wy.val(d) === (val || later.wy.extent(d)[1]);\n        },\n        extent: function (d) {\n            if (d.wyExtent)\n                return d.wyExtent;\n            var year = later.dw.next(later.wy.start(d), 5), dwFirst = later.dw.val(later.Y.start(year)), dwLast = later.dw.val(later.Y.end(year));\n            return d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52];\n        },\n        start: function (d) {\n            return d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)));\n        },\n        end: function (d) {\n            return d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)));\n        },\n        next: function (d, val) {\n            val = val > later.wy.extent(d)[1] ? 1 : val;\n            var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.nextRollover(wyThur, val, later.wy, later.Y);\n            if (later.wy.val(year) !== 1) {\n                year = later.dw.next(year, 2);\n            }\n            var wyMax = later.wy.extent(year)[1], wyStart = later.wy.start(year);\n            val = val > wyMax ? 1 : val || wyMax;\n            return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), later.D.val(wyStart) + 7 * (val - 1));\n        },\n        prev: function (d, val) {\n            var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.prevRollover(wyThur, val, later.wy, later.Y);\n            if (later.wy.val(year) !== 1) {\n                year = later.dw.next(year, 2);\n            }\n            var wyMax = later.wy.extent(year)[1], wyEnd = later.wy.end(year);\n            val = val > wyMax ? wyMax : val || wyMax;\n            return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), later.D.val(wyEnd) + 7 * (val - 1)));\n        }\n    };\n    later.year = later.Y = {\n        name: \"year\",\n        range: 31556900,\n        val: function (d) {\n            return d.Y || (d.Y = later.date.getYear.call(d));\n        },\n        isValid: function (d, val) {\n            return later.Y.val(d) === val;\n        },\n        extent: function () {\n            return [1970, 2099];\n        },\n        start: function (d) {\n            return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));\n        },\n        end: function (d) {\n            return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));\n        },\n        next: function (d, val) {\n            return val > later.Y.val(d) && val <= later.Y.extent()[1] ? later.date.next(val) : later.NEVER;\n        },\n        prev: function (d, val) {\n            return val < later.Y.val(d) && val >= later.Y.extent()[0] ? later.date.prev(val) : later.NEVER;\n        }\n    };\n    later.fullDate = later.fd = {\n        name: \"full date\",\n        range: 1,\n        val: function (d) {\n            return d.fd || (d.fd = d.getTime());\n        },\n        isValid: function (d, val) {\n            return later.fd.val(d) === val;\n        },\n        extent: function () {\n            return [0, 3250368e7];\n        },\n        start: function (d) {\n            return d;\n        },\n        end: function (d) {\n            return d;\n        },\n        next: function (d, val) {\n            return later.fd.val(d) < val ? new Date(val) : later.NEVER;\n        },\n        prev: function (d, val) {\n            return later.fd.val(d) > val ? new Date(val) : later.NEVER;\n        }\n    };\n    later.modifier = {};\n    later.modifier.after = later.modifier.a = function (constraint, values) {\n        var value = values[0];\n        return {\n            name: \"after \" + constraint.name,\n            range: (constraint.extent(new Date())[1] - value) * constraint.range,\n            val: constraint.val,\n            isValid: function (d, val) {\n                return this.val(d) >= value;\n            },\n            extent: constraint.extent,\n            start: constraint.start,\n            end: constraint.end,\n            next: function (startDate, val) {\n                if (val != value)\n                    val = constraint.extent(startDate)[0];\n                return constraint.next(startDate, val);\n            },\n            prev: function (startDate, val) {\n                val = val === value ? constraint.extent(startDate)[1] : value - 1;\n                return constraint.prev(startDate, val);\n            }\n        };\n    };\n    later.modifier.before = later.modifier.b = function (constraint, values) {\n        var value = values[values.length - 1];\n        return {\n            name: \"before \" + constraint.name,\n            range: constraint.range * (value - 1),\n            val: constraint.val,\n            isValid: function (d, val) {\n                return this.val(d) < value;\n            },\n            extent: constraint.extent,\n            start: constraint.start,\n            end: constraint.end,\n            next: function (startDate, val) {\n                val = val === value ? constraint.extent(startDate)[0] : value;\n                return constraint.next(startDate, val);\n            },\n            prev: function (startDate, val) {\n                val = val === value ? value - 1 : constraint.extent(startDate)[1];\n                return constraint.prev(startDate, val);\n            }\n        };\n    };\n    later.compile = function (schedDef) {\n        var constraints = [], constraintsLen = 0, tickConstraint;\n        for (var key in schedDef) {\n            var nameParts = key.split(\"_\"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later.modifier[mod](later[name], vals) : later[name];\n            constraints.push({\n                constraint: constraint,\n                vals: vals\n            });\n            constraintsLen++;\n        }\n        constraints.sort(function (a, b) {\n            var ra = a.constraint.range, rb = b.constraint.range;\n            return rb < ra ? -1 : rb > ra ? 1 : 0;\n        });\n        tickConstraint = constraints[constraintsLen - 1].constraint;\n        function compareFn(dir) {\n            return dir === \"next\" ? function (a, b) {\n                return a.getTime() > b.getTime();\n            } : function (a, b) {\n                return b.getTime() > a.getTime();\n            };\n        }\n        return {\n            start: function (dir, startDate) {\n                var next = startDate, nextVal = later.array[dir], maxAttempts = 1e3, done;\n                while (maxAttempts-- && !done && next) {\n                    done = true;\n                    for (var i = 0; i < constraintsLen; i++) {\n                        var constraint = constraints[i].constraint, curVal = constraint.val(next), extent = constraint.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);\n                        if (!constraint.isValid(next, newVal)) {\n                            next = constraint[dir](next, newVal);\n                            done = false;\n                            break;\n                        }\n                    }\n                }\n                if (next !== later.NEVER) {\n                    next = dir === \"next\" ? tickConstraint.start(next) : tickConstraint.end(next);\n                }\n                return next;\n            },\n            end: function (dir, startDate) {\n                var result, nextVal = later.array[dir + \"Invalid\"], compare = compareFn(dir);\n                for (var i = constraintsLen - 1; i >= 0; i--) {\n                    var constraint = constraints[i].constraint, curVal = constraint.val(startDate), extent = constraint.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;\n                    if (newVal !== undefined) {\n                        next = constraint[dir](startDate, newVal);\n                        if (next && (!result || compare(result, next))) {\n                            result = next;\n                        }\n                    }\n                }\n                return result;\n            },\n            tick: function (dir, date) {\n                return new Date(dir === \"next\" ? tickConstraint.end(date).getTime() + later.SEC : tickConstraint.start(date).getTime() - later.SEC);\n            },\n            // PATCH\n            tickSafe: function (dir, date) {\n                return dir === \"next\"\n                    ? diffSecond(tickConstraint.end(date), 1)\n                    : diffSecond(tickConstraint.start(date), -1)\n                ;\n            },\n            // EOF PATCH\n            tickStart: function (date) {\n                return tickConstraint.start(date);\n            }\n        };\n    };\n    later.schedule = function (sched) {\n        if (!sched)\n            throw new Error(\"Missing schedule definition.\");\n        if (!sched.schedules)\n            throw new Error(\"Definition must include at least one schedule.\");\n        var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;\n        for (var i = 0; i < schedulesLen; i++) {\n            schedules.push(later.compile(sched.schedules[i]));\n        }\n        for (var j = 0; j < exceptionsLen; j++) {\n            exceptions.push(later.compile(sched.exceptions[j]));\n        }\n        function getInstances(dir, count, startDate, endDate, isRange) {\n            var compare = compareFn(dir), loopCount = count, maxAttempts = 1e6, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === \"next\", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;\n            startDate = startDate ? new Date(startDate) : new Date();\n            if (!startDate || !startDate.getTime())\n                throw new Error(\"Invalid start date.\");\n            setNextStarts(dir, schedules, schedStarts, startDate);\n            setRangeStarts(dir, exceptions, exceptStarts, startDate);\n            while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {\n                if (endDate && compare(next, endDate)) {\n                    break;\n                }\n                if (exceptionsLen) {\n                    updateRangeStarts(dir, exceptions, exceptStarts, next);\n                    if (end = calcRangeOverlap(dir, exceptStarts, next)) {\n                        updateNextStarts(dir, schedules, schedStarts, end);\n                        continue;\n                    }\n                }\n                if (isRange) {\n                    var maxEndDate = calcMaxEndDate(exceptStarts, compare);\n                    end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);\n                    var r = isForward ? [new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined] : [end ? new Date(endDate ? Math.max(endDate, end.getTime() + later.SEC) : end.getTime() + later.SEC) : undefined, new Date(Math.min(startDate, next.getTime() + later.SEC))];\n                    if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {\n                        lastResult[rEnd] = r[rEnd];\n                        loopCount++;\n                    }\n                    else {\n                        lastResult = r;\n                        results.push(lastResult);\n                    }\n                    if (!end)\n                        break;\n                    updateNextStarts(dir, schedules, schedStarts, end);\n                }\n                else {\n                    results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));\n                    tickStarts(dir, schedules, schedStarts, next);\n                }\n                loopCount--;\n            }\n            for (var i = 0, len = results.length; i < len; i++) {\n                var result = results[i];\n                results[i] = Object.prototype.toString.call(result) === \"[object Array]\" ? [cleanDate(result[0]), cleanDate(result[1])] : cleanDate(result);\n            }\n            return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;\n        }\n        function cleanDate(d) {\n            if (d instanceof Date && !isNaN(d.valueOf())) {\n                return new Date(d);\n            }\n            return undefined;\n        }\n        function setNextStarts(dir, schedArr, startsArr, startDate) {\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                startsArr[i] = schedArr[i].start(dir, startDate);\n            }\n        }\n        function updateNextStarts(dir, schedArr, startsArr, startDate) {\n            var compare = compareFn(dir);\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                if (startsArr[i] && !compare(startsArr[i], startDate)) {\n                    startsArr[i] = schedArr[i].start(dir, startDate);\n                }\n            }\n        }\n        function setRangeStarts(dir, schedArr, rangesArr, startDate) {\n            var compare = compareFn(dir);\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                var nextStart = schedArr[i].start(dir, startDate);\n                if (!nextStart) {\n                    rangesArr[i] = later.NEVER;\n                }\n                else {\n                    rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];\n                }\n            }\n        }\n        function updateRangeStarts(dir, schedArr, rangesArr, startDate) {\n            var compare = compareFn(dir);\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                if (rangesArr[i] && !compare(rangesArr[i][0], startDate)) {\n                    var nextStart = schedArr[i].start(dir, startDate);\n                    if (!nextStart) {\n                        rangesArr[i] = later.NEVER;\n                    }\n                    else {\n                        rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];\n                    }\n                }\n            }\n        }\n        function tickStarts(dir, schedArr, startsArr, startDate) {\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n                    // PATCH\n                    const newStart = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));\n                    // if the calculated `newStart` is the same as previous, this is probably\n                    // an endless loop caused by the DST shift (the browser won't halt because later.js\n                    // has a limit of 100000 iterations, but the calculated schedules will be all wrong)\n                    if (newStart !== later.NEVER && newStart.getTime() === startsArr[i].getTime()) {\n                        // in such case we use our own \"safe\" implementation of the \"tick\" method\n                        // which performs symbolic date manipulation\n                        // (instead of advancing on milliseconds since epoch timeaxis)\n                        // the former seems to be slower, that's why we only switch to it\n                        // in the case of infinite loop\n                        startsArr[i] = schedArr[i].start(dir, schedArr[i].tickSafe(dir, startDate));\n                    } else {\n                        startsArr[i] = newStart\n                    }\n                    // EOF PATCH\n                }\n            }\n        }\n        function getStart(schedArr, startsArr, startDate, minEndDate) {\n            var result;\n            for (var i = 0, len = startsArr.length; i < len; i++) {\n                if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n                    var start = schedArr[i].tickStart(startDate);\n                    if (minEndDate && start < minEndDate) {\n                        return minEndDate;\n                    }\n                    if (!result || start > result) {\n                        result = start;\n                    }\n                }\n            }\n            return result;\n        }\n        function calcRangeOverlap(dir, rangesArr, startDate) {\n            var compare = compareFn(dir), result;\n            for (var i = 0, len = rangesArr.length; i < len; i++) {\n                var range = rangesArr[i];\n                if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {\n                    if (!result || compare(range[1], result)) {\n                        result = range[1];\n                    }\n                }\n            }\n            return result;\n        }\n        function calcMaxEndDate(exceptsArr, compare) {\n            var result;\n            for (var i = 0, len = exceptsArr.length; i < len; i++) {\n                if (exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {\n                    result = exceptsArr[i][0];\n                }\n            }\n            return result;\n        }\n        function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {\n            var compare = compareFn(dir), result;\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                var start = startsArr[i];\n                if (start && start.getTime() === startDate.getTime()) {\n                    var end = schedArr[i].end(dir, start);\n                    if (maxEndDate && (!end || compare(end, maxEndDate))) {\n                        return maxEndDate;\n                    }\n                    if (!result || compare(end, result)) {\n                        result = end;\n                    }\n                }\n            }\n            return result;\n        }\n        function compareFn(dir) {\n            return dir === \"next\" ? function (a, b) {\n                return !b || a.getTime() > b.getTime();\n            } : function (a, b) {\n                return !a || b.getTime() > a.getTime();\n            };\n        }\n        function findNext(arr, compare) {\n            var next = arr[0];\n            for (var i = 1, len = arr.length; i < len; i++) {\n                if (arr[i] && compare(next, arr[i])) {\n                    next = arr[i];\n                }\n            }\n            return next;\n        }\n        return {\n            isValid: function (d) {\n                return getInstances(\"next\", 1, d, d) !== later.NEVER;\n            },\n            next: function (count, startDate, endDate) {\n                return getInstances(\"next\", count || 1, startDate, endDate);\n            },\n            prev: function (count, startDate, endDate) {\n                return getInstances(\"prev\", count || 1, startDate, endDate);\n            },\n            nextRange: function (count, startDate, endDate) {\n                return getInstances(\"next\", count || 1, startDate, endDate, true);\n            },\n            prevRange: function (count, startDate, endDate) {\n                return getInstances(\"prev\", count || 1, startDate, endDate, true);\n            }\n        };\n    };\n    later.setTimeout = function (fn, sched) {\n        var s = later.schedule(sched), t;\n        if (fn) {\n            scheduleTimeout();\n        }\n        function scheduleTimeout() {\n            var now = Date.now(), next = s.next(2, now);\n            if (!next[0]) {\n                t = undefined;\n                return;\n            }\n            var diff = next[0].getTime() - now;\n            if (diff < 1e3) {\n                diff = next[1] ? next[1].getTime() - now : 1e3;\n            }\n            if (diff < 2147483647) {\n                t = setTimeout(fn, diff);\n            }\n            else {\n                t = setTimeout(scheduleTimeout, 2147483647);\n            }\n        }\n        return {\n            isDone: function () {\n                return !t;\n            },\n            clear: function () {\n                clearTimeout(t);\n            }\n        };\n    };\n    later.setInterval = function (fn, sched) {\n        if (!fn) {\n            return;\n        }\n        var t = later.setTimeout(scheduleTimeout, sched), done = t.isDone();\n        function scheduleTimeout() {\n            if (!done) {\n                fn();\n                t = later.setTimeout(scheduleTimeout, sched);\n            }\n        }\n        return {\n            isDone: function () {\n                return t.isDone();\n            },\n            clear: function () {\n                done = true;\n                t.clear();\n            }\n        };\n    };\n    later.date = {};\n    later.date.timezone = function (useLocalTime) {\n        later.date.build = useLocalTime ? function (Y, M, D, h, m, s) {\n            return new Date(Y, M, D, h, m, s);\n        } : function (Y, M, D, h, m, s) {\n            return new Date(Date.UTC(Y, M, D, h, m, s));\n        };\n        var get = useLocalTime ? \"get\" : \"getUTC\", d = Date.prototype;\n        later.date.getYear = d[get + \"FullYear\"];\n        later.date.getMonth = d[get + \"Month\"];\n        later.date.getDate = d[get + \"Date\"];\n        later.date.getDay = d[get + \"Day\"];\n        later.date.getHour = d[get + \"Hours\"];\n        later.date.getMin = d[get + \"Minutes\"];\n        later.date.getSec = d[get + \"Seconds\"];\n        later.date.isUTC = !useLocalTime;\n    };\n    later.date.UTC = function () {\n        later.date.timezone(false);\n    };\n    later.date.localTime = function () {\n        later.date.timezone(true);\n    };\n    later.date.UTC();\n    later.SEC = 1e3;\n    later.MIN = later.SEC * 60;\n    later.HOUR = later.MIN * 60;\n    later.DAY = later.HOUR * 24;\n    later.WEEK = later.DAY * 7;\n    later.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    later.NEVER = 0;\n    later.date.next = function (Y, M, D, h, m, s) {\n        return later.date.build(Y, M !== undefined ? M - 1 : 0, D !== undefined ? D : 1, h || 0, m || 0, s || 0);\n    };\n    later.date.nextRollover = function (d, val, constraint, period) {\n        var cur = constraint.val(d), max = constraint.extent(d)[1];\n        return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later.SEC) : period.start(d);\n    };\n    later.date.prev = function (Y, M, D, h, m, s) {\n        var len = arguments.length;\n        M = len < 2 ? 11 : M - 1;\n        D = len < 3 ? later.D.extent(later.date.next(Y, M + 1))[1] : D;\n        h = len < 4 ? 23 : h;\n        m = len < 5 ? 59 : m;\n        s = len < 6 ? 59 : s;\n        return later.date.build(Y, M, D, h, m, s);\n    };\n    later.date.prevRollover = function (d, val, constraint, period) {\n        var cur = constraint.val(d);\n        return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);\n    };\n    later.parse = {};\n    later.parse.cron = function (expr, hasSeconds) {\n        var NAMES = {\n            JAN: 1,\n            FEB: 2,\n            MAR: 3,\n            APR: 4,\n            MAY: 5,\n            JUN: 6,\n            JUL: 7,\n            AUG: 8,\n            SEP: 9,\n            OCT: 10,\n            NOV: 11,\n            DEC: 12,\n            SUN: 1,\n            MON: 2,\n            TUE: 3,\n            WED: 4,\n            THU: 5,\n            FRI: 6,\n            SAT: 7\n        };\n        var REPLACEMENTS = {\n            \"* * * * * *\": \"0/1 * * * * *\",\n            \"@YEARLY\": \"0 0 1 1 *\",\n            \"@ANNUALLY\": \"0 0 1 1 *\",\n            \"@MONTHLY\": \"0 0 1 * *\",\n            \"@WEEKLY\": \"0 0 * * 0\",\n            \"@DAILY\": \"0 0 * * *\",\n            \"@HOURLY\": \"0 * * * *\"\n        };\n        var FIELDS = {\n            s: [0, 0, 59],\n            m: [1, 0, 59],\n            h: [2, 0, 23],\n            D: [3, 1, 31],\n            M: [4, 1, 12],\n            Y: [6, 1970, 2099],\n            d: [5, 1, 7, 1]\n        };\n        function getValue(value, offset, max) {\n            return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);\n        }\n        function cloneSchedule(sched) {\n            var clone = {}, field;\n            for (field in sched) {\n                if (field !== \"dc\" && field !== \"d\") {\n                    clone[field] = sched[field].slice(0);\n                }\n            }\n            return clone;\n        }\n        function add(sched, name, min, max, inc) {\n            var i = min;\n            if (!sched[name]) {\n                sched[name] = [];\n            }\n            while (i <= max) {\n                if (sched[name].indexOf(i) < 0) {\n                    sched[name].push(i);\n                }\n                i += inc || 1;\n            }\n            sched[name].sort(function (a, b) {\n                return a - b;\n            });\n        }\n        function addHash(schedules, curSched, value, hash) {\n            if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {\n                schedules.push(cloneSchedule(curSched));\n                curSched = schedules[schedules.length - 1];\n            }\n            add(curSched, \"d\", value, value);\n            add(curSched, \"dc\", hash, hash);\n        }\n        function addWeekday(s, curSched, value) {\n            var except1 = {}, except2 = {};\n            if (value === 1) {\n                add(curSched, \"D\", 1, 3);\n                add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n                add(except1, \"D\", 2, 2);\n                add(except1, \"d\", NAMES.TUE, NAMES.FRI);\n                add(except2, \"D\", 3, 3);\n                add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n            }\n            else {\n                add(curSched, \"D\", value - 1, value + 1);\n                add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n                add(except1, \"D\", value - 1, value - 1);\n                add(except1, \"d\", NAMES.MON, NAMES.THU);\n                add(except2, \"D\", value + 1, value + 1);\n                add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n            }\n            s.exceptions.push(except1);\n            s.exceptions.push(except2);\n        }\n        function addRange(item, curSched, name, min, max, offset) {\n            var incSplit = item.split(\"/\"), inc = +incSplit[1], range = incSplit[0];\n            if (range !== \"*\" && range !== \"0\") {\n                var rangeSplit = range.split(\"-\");\n                min = getValue(rangeSplit[0], offset, max);\n                max = getValue(rangeSplit[1], offset, max) || max;\n            }\n            add(curSched, name, min, max, inc);\n        }\n        function parse(item, s, name, min, max, offset) {\n            var value, split, schedules = s.schedules, curSched = schedules[schedules.length - 1];\n            if (item === \"L\") {\n                item = min - 1;\n            }\n            if ((value = getValue(item, offset, max)) !== null) {\n                add(curSched, name, value, value);\n            }\n            else if ((value = getValue(item.replace(\"W\", \"\"), offset, max)) !== null) {\n                addWeekday(s, curSched, value);\n            }\n            else if ((value = getValue(item.replace(\"L\", \"\"), offset, max)) !== null) {\n                addHash(schedules, curSched, value, min - 1);\n            }\n            else if ((split = item.split(\"#\")).length === 2) {\n                value = getValue(split[0], offset, max);\n                addHash(schedules, curSched, value, getValue(split[1]));\n            }\n            else {\n                addRange(item, curSched, name, min, max, offset);\n            }\n        }\n        function isHash(item) {\n            return item.indexOf(\"#\") > -1 || item.indexOf(\"L\") > 0;\n        }\n        function itemSorter(a, b) {\n            return isHash(a) && !isHash(b) ? 1 : a - b;\n        }\n        function parseExpr(expr) {\n            var schedule = {\n                schedules: [{}],\n                exceptions: []\n            }, components = expr.replace(/(\\s)+/g, \" \").split(\" \"), field, f, component, items;\n            for (field in FIELDS) {\n                f = FIELDS[field];\n                component = components[f[0]];\n                if (component && component !== \"*\" && component !== \"?\") {\n                    items = component.split(\",\").sort(itemSorter);\n                    var i, length = items.length;\n                    for (i = 0; i < length; i++) {\n                        parse(items[i], schedule, field, f[1], f[2], f[3]);\n                    }\n                }\n            }\n            return schedule;\n        }\n        function prepareExpr(expr) {\n            var prepared = expr.toUpperCase();\n            return REPLACEMENTS[prepared] || prepared;\n        }\n        var e = prepareExpr(expr);\n        return parseExpr(hasSeconds ? e : \"0 \" + e);\n    };\n    later.parse.recur = function () {\n        var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every, modifier, applyMin, applyMax, i, last;\n        function add(name, min, max) {\n            name = modifier ? name + \"_\" + modifier : name;\n            if (!cur) {\n                curArr.push({});\n                cur = curArr[0];\n            }\n            if (!cur[name]) {\n                cur[name] = [];\n            }\n            curName = cur[name];\n            if (every) {\n                values = [];\n                for (i = min; i <= max; i += every) {\n                    values.push(i);\n                }\n                last = {\n                    n: name,\n                    x: every,\n                    c: curName.length,\n                    m: max\n                };\n            }\n            values = applyMin ? [min] : applyMax ? [max] : values;\n            var length = values.length;\n            for (i = 0; i < length; i += 1) {\n                var val = values[i];\n                if (curName.indexOf(val) < 0) {\n                    curName.push(val);\n                }\n            }\n            values = every = modifier = applyMin = applyMax = 0;\n        }\n        return {\n            schedules: schedules,\n            exceptions: exceptions,\n            on: function () {\n                values = arguments[0] instanceof Array ? arguments[0] : arguments;\n                return this;\n            },\n            every: function (x) {\n                every = x || 1;\n                return this;\n            },\n            after: function (x) {\n                modifier = \"a\";\n                values = [x];\n                return this;\n            },\n            before: function (x) {\n                modifier = \"b\";\n                values = [x];\n                return this;\n            },\n            first: function () {\n                applyMin = 1;\n                return this;\n            },\n            last: function () {\n                applyMax = 1;\n                return this;\n            },\n            time: function () {\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var split = values[i].split(\":\");\n                    if (split.length < 3)\n                        split.push(0);\n                    values[i] = +split[0] * 3600 + +split[1] * 60 + +split[2];\n                }\n                add(\"t\");\n                return this;\n            },\n            second: function () {\n                add(\"s\", 0, 59);\n                return this;\n            },\n            minute: function () {\n                add(\"m\", 0, 59);\n                return this;\n            },\n            hour: function () {\n                add(\"h\", 0, 23);\n                return this;\n            },\n            dayOfMonth: function () {\n                add(\"D\", 1, applyMax ? 0 : 31);\n                return this;\n            },\n            dayOfWeek: function () {\n                add(\"d\", 1, 7);\n                return this;\n            },\n            onWeekend: function () {\n                values = [1, 7];\n                return this.dayOfWeek();\n            },\n            onWeekday: function () {\n                values = [2, 3, 4, 5, 6];\n                return this.dayOfWeek();\n            },\n            dayOfWeekCount: function () {\n                add(\"dc\", 1, applyMax ? 0 : 5);\n                return this;\n            },\n            dayOfYear: function () {\n                add(\"dy\", 1, applyMax ? 0 : 366);\n                return this;\n            },\n            weekOfMonth: function () {\n                add(\"wm\", 1, applyMax ? 0 : 5);\n                return this;\n            },\n            weekOfYear: function () {\n                add(\"wy\", 1, applyMax ? 0 : 53);\n                return this;\n            },\n            month: function () {\n                add(\"M\", 1, 12);\n                return this;\n            },\n            year: function () {\n                add(\"Y\", 1970, 2450);\n                return this;\n            },\n            fullDate: function () {\n                for (var i = 0, len = values.length; i < len; i++) {\n                    values[i] = values[i].getTime();\n                }\n                add(\"fd\");\n                return this;\n            },\n            customModifier: function (id, vals) {\n                var custom = later.modifier[id];\n                if (!custom)\n                    throw new Error(\"Custom modifier \" + id + \" not recognized!\");\n                modifier = id;\n                values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];\n                return this;\n            },\n            customPeriod: function (id) {\n                var custom = later[id];\n                if (!custom)\n                    throw new Error(\"Custom time period \" + id + \" not recognized!\");\n                add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);\n                return this;\n            },\n            startingOn: function (start) {\n                return this.between(start, last.m);\n            },\n            between: function (start, end) {\n                cur[last.n] = cur[last.n].splice(0, last.c);\n                every = last.x;\n                add(last.n, start, end);\n                return this;\n            },\n            and: function () {\n                cur = curArr[curArr.push({}) - 1];\n                return this;\n            },\n            except: function () {\n                curArr = exceptions;\n                cur = null;\n                return this;\n            }\n        };\n    };\n    later.parse.text = function (str) {\n        var recur = later.parse.recur, pos = 0, input = \"\", error;\n        var TOKENTYPES = {\n            eof: /^$/,\n            fullDate: /^(\\d\\d\\d\\d-\\d\\d-\\d\\dt\\d\\d:\\d\\d:\\d\\d)\\b/,\n            rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,\n            time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,\n            dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,\n            monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,\n            yearIndex: /^(\\d\\d\\d\\d)\\b/,\n            every: /^every\\b/,\n            after: /^after\\b/,\n            before: /^before\\b/,\n            second: /^(s|sec(ond)?(s)?)\\b/,\n            minute: /^(m|min(ute)?(s)?)\\b/,\n            hour: /^(h|hour(s)?)\\b/,\n            day: /^(day(s)?( of the month)?)\\b/,\n            dayInstance: /^day instance\\b/,\n            dayOfWeek: /^day(s)? of the week\\b/,\n            dayOfYear: /^day(s)? of the year\\b/,\n            weekOfYear: /^week(s)?( of the year)?\\b/,\n            weekOfMonth: /^week(s)? of the month\\b/,\n            weekday: /^weekday\\b/,\n            weekend: /^weekend\\b/,\n            month: /^month(s)?\\b/,\n            year: /^year(s)?\\b/,\n            between: /^between (the)?\\b/,\n            start: /^(start(ing)? (at|on( the)?)?)\\b/,\n            at: /^(at|@)\\b/,\n            and: /^(,|and\\b)/,\n            except: /^(except\\b)/,\n            also: /(also)\\b/,\n            first: /^(first)\\b/,\n            last: /^last\\b/,\n            \"in\": /^in\\b/,\n            of: /^of\\b/,\n            onthe: /^on the\\b/,\n            on: /^on\\b/,\n            through: /(-|^(to|through)\\b)/\n        };\n        var NAMES = {\n            jan: 1,\n            feb: 2,\n            mar: 3,\n            apr: 4,\n            may: 5,\n            jun: 6,\n            jul: 7,\n            aug: 8,\n            sep: 9,\n            oct: 10,\n            nov: 11,\n            dec: 12,\n            sun: 1,\n            mon: 2,\n            tue: 3,\n            wed: 4,\n            thu: 5,\n            fri: 6,\n            sat: 7,\n            \"1st\": 1,\n            fir: 1,\n            \"2nd\": 2,\n            sec: 2,\n            \"3rd\": 3,\n            thi: 3,\n            \"4th\": 4,\n            \"for\": 4\n        };\n        function t(start, end, text, type) {\n            return {\n                startPos: start,\n                endPos: end,\n                text: text,\n                type: type\n            };\n        }\n        function peek(expected) {\n            var scanTokens = expected instanceof Array ? expected : [expected], whiteSpace = /\\s+/, token, curInput, m, scanToken, start, len;\n            scanTokens.push(whiteSpace);\n            start = pos;\n            while (!token || token.type === whiteSpace) {\n                len = -1;\n                curInput = input.substring(start);\n                token = t(start, start, input.split(whiteSpace)[0]);\n                var i, length = scanTokens.length;\n                for (i = 0; i < length; i++) {\n                    scanToken = scanTokens[i];\n                    m = scanToken.exec(curInput);\n                    if (m && m.index === 0 && m[0].length > len) {\n                        len = m[0].length;\n                        token = t(start, start + len, curInput.substring(0, len), scanToken);\n                    }\n                }\n                if (token.type === whiteSpace) {\n                    start = token.endPos;\n                }\n            }\n            return token;\n        }\n        function scan(expectedToken) {\n            var token = peek(expectedToken);\n            pos = token.endPos;\n            return token;\n        }\n        function parseThroughExpr(tokenType) {\n            var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];\n            for (var i = start; i <= end; i++) {\n                nums.push(i);\n            }\n            return nums;\n        }\n        function parseRanges(tokenType) {\n            var nums = parseThroughExpr(tokenType);\n            while (checkAndParse(TOKENTYPES.and)) {\n                nums = nums.concat(parseThroughExpr(tokenType));\n            }\n            return nums;\n        }\n        function parseEvery(r) {\n            var num, period, start, end;\n            if (checkAndParse(TOKENTYPES.weekend)) {\n                r.on(NAMES.sun, NAMES.sat).dayOfWeek();\n            }\n            else if (checkAndParse(TOKENTYPES.weekday)) {\n                r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();\n            }\n            else {\n                num = parseTokenValue(TOKENTYPES.rank);\n                r.every(num);\n                period = parseTimePeriod(r);\n                if (checkAndParse(TOKENTYPES.start)) {\n                    num = parseTokenValue(TOKENTYPES.rank);\n                    r.startingOn(num);\n                    parseToken(period.type);\n                }\n                else if (checkAndParse(TOKENTYPES.between)) {\n                    start = parseTokenValue(TOKENTYPES.rank);\n                    if (checkAndParse(TOKENTYPES.and)) {\n                        end = parseTokenValue(TOKENTYPES.rank);\n                        r.between(start, end);\n                    }\n                }\n            }\n        }\n        function parseOnThe(r) {\n            if (checkAndParse(TOKENTYPES.first)) {\n                r.first();\n            }\n            else if (checkAndParse(TOKENTYPES.last)) {\n                r.last();\n            }\n            else {\n                r.on(parseRanges(TOKENTYPES.rank));\n            }\n            parseTimePeriod(r);\n        }\n        function parseScheduleExpr(str) {\n            pos = 0;\n            input = str;\n            error = -1;\n            var r = recur();\n            while (pos < input.length && error < 0) {\n                var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);\n                switch (token.type) {\n                    case TOKENTYPES.every:\n                        parseEvery(r);\n                        break;\n                    case TOKENTYPES.after:\n                        if (peek(TOKENTYPES.time).type !== undefined) {\n                            r.after(parseTokenValue(TOKENTYPES.time));\n                            r.time();\n                        }\n                        else if (peek(TOKENTYPES.fullDate).type !== undefined) {\n                            r.after(parseTokenValue(TOKENTYPES.fullDate));\n                            r.fullDate();\n                        }\n                        else {\n                            r.after(parseTokenValue(TOKENTYPES.rank));\n                            parseTimePeriod(r);\n                        }\n                        break;\n                    case TOKENTYPES.before:\n                        if (peek(TOKENTYPES.time).type !== undefined) {\n                            r.before(parseTokenValue(TOKENTYPES.time));\n                            r.time();\n                        }\n                        else if (peek(TOKENTYPES.fullDate).type !== undefined) {\n                            r.before(parseTokenValue(TOKENTYPES.fullDate));\n                            r.fullDate();\n                        }\n                        else {\n                            r.before(parseTokenValue(TOKENTYPES.rank));\n                            parseTimePeriod(r);\n                        }\n                        break;\n                    case TOKENTYPES.onthe:\n                        parseOnThe(r);\n                        break;\n                    case TOKENTYPES.on:\n                        r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();\n                        break;\n                    case TOKENTYPES.of:\n                        r.on(parseRanges(TOKENTYPES.monthName)).month();\n                        break;\n                    case TOKENTYPES[\"in\"]:\n                        r.on(parseRanges(TOKENTYPES.yearIndex)).year();\n                        break;\n                    case TOKENTYPES.at:\n                        r.on(parseTokenValue(TOKENTYPES.time)).time();\n                        while (checkAndParse(TOKENTYPES.and)) {\n                            r.on(parseTokenValue(TOKENTYPES.time)).time();\n                        }\n                        break;\n                    case TOKENTYPES.and:\n                        break;\n                    case TOKENTYPES.also:\n                        r.and();\n                        break;\n                    case TOKENTYPES.except:\n                        r.except();\n                        break;\n                    default:\n                        error = pos;\n                }\n            }\n            return {\n                schedules: r.schedules,\n                exceptions: r.exceptions,\n                error: error\n            };\n        }\n        function parseTimePeriod(r) {\n            var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);\n            switch (timePeriod.type) {\n                case TOKENTYPES.second:\n                    r.second();\n                    break;\n                case TOKENTYPES.minute:\n                    r.minute();\n                    break;\n                case TOKENTYPES.hour:\n                    r.hour();\n                    break;\n                case TOKENTYPES.dayOfYear:\n                    r.dayOfYear();\n                    break;\n                case TOKENTYPES.dayOfWeek:\n                    r.dayOfWeek();\n                    break;\n                case TOKENTYPES.dayInstance:\n                    r.dayOfWeekCount();\n                    break;\n                case TOKENTYPES.day:\n                    r.dayOfMonth();\n                    break;\n                case TOKENTYPES.weekOfMonth:\n                    r.weekOfMonth();\n                    break;\n                case TOKENTYPES.weekOfYear:\n                    r.weekOfYear();\n                    break;\n                case TOKENTYPES.month:\n                    r.month();\n                    break;\n                case TOKENTYPES.year:\n                    r.year();\n                    break;\n                default:\n                    error = pos;\n            }\n            return timePeriod;\n        }\n        function checkAndParse(tokenType) {\n            var found = peek(tokenType).type === tokenType;\n            if (found) {\n                scan(tokenType);\n            }\n            return found;\n        }\n        function parseToken(tokenType) {\n            var t = scan(tokenType);\n            if (t.type) {\n                t.text = convertString(t.text, tokenType);\n            }\n            else {\n                error = pos;\n            }\n            return t;\n        }\n        function parseTokenValue(tokenType) {\n            return parseToken(tokenType).text;\n        }\n        function convertString(str, tokenType) {\n            var output = str;\n            switch (tokenType) {\n                case TOKENTYPES.time:\n                    var parts = str.split(/(:|am|pm)/), hour = parts[3] === \"pm\" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min = parts[2].trim();\n                    output = (hour.length === 1 ? \"0\" : \"\") + hour + \":\" + min;\n                    break;\n                case TOKENTYPES.rank:\n                    output = parseInt(/^\\d+/.exec(str)[0], 10);\n                    break;\n                case TOKENTYPES.monthName:\n                case TOKENTYPES.dayName:\n                    output = NAMES[str.substring(0, 3)];\n                    break;\n                case TOKENTYPES.fullDate:\n                    output = new Date(str.toUpperCase());\n                    break;\n                }\n            return output;\n        }\n        return parseScheduleExpr(str.toLowerCase());\n    };\n    return later;\n})();\n// Set the local time mode for \"later\" library\nlater.date.localTime();\nexport default later;\n", "//---------------------------------------------------------------------------------------------------------------------\n/**\n * Given a single `Iterable`, returns an array of 2 iterables, mirroring the original one (which should not be used anymore).\n *\n * For example:\n *\n *     const gen = function* () { yield 1; yield 2; yield 3 }\n *\n *     const [ iterable1, iterable2 ] = split(gen())\n *     const [ iter1, iter2 ] = [\n *         iterable1[ Symbol.iterator ](),\n *         iterable2[ Symbol.iterator ]()\n *     ]\n *\n *     iter1.next() // 1\n *     iter2.next() // 1\n *     iter2.next() // 2\n *     iter2.next() // 3\n *     iter1.next() // 2\n *     iter1.next() // 3\n *     iter1.next() // done\n *     iter2.next() // done\n *\n * @param iterable\n */\nexport function split(iterable) {\n    const gen1Pending = [];\n    const gen2Pending = [];\n    let iterator;\n    const gen1 = function* () {\n        if (!iterator)\n            iterator = iterable[Symbol.iterator]();\n        while (true) {\n            if (gen1Pending.length) {\n                yield* gen1Pending;\n                gen1Pending.length = 0;\n            }\n            if (!iterator)\n                break;\n            const { value, done } = iterator.next();\n            if (done) {\n                iterator = null;\n                iterable = null;\n                break;\n            }\n            gen2Pending.push(value);\n            yield value;\n        }\n    };\n    const gen2 = function* () {\n        if (!iterator)\n            iterator = iterable[Symbol.iterator]();\n        while (true) {\n            if (gen2Pending.length) {\n                yield* gen2Pending;\n                gen2Pending.length = 0;\n            }\n            if (!iterator)\n                break;\n            const { value, done } = iterator.next();\n            if (done) {\n                iterator = null;\n                iterable = null;\n                break;\n            }\n            gen1Pending.push(value);\n            yield value;\n        }\n    };\n    return [gen1(), gen2()];\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* inBatchesBySize(iterator, batchSize) {\n    if (batchSize < 0)\n        throw new Error(\"Batch size needs to a natural number\");\n    batchSize = batchSize | 0;\n    const runningBatch = [];\n    for (const el of iterator) {\n        if (runningBatch.length === batchSize) {\n            yield runningBatch;\n            runningBatch.length = 0;\n        }\n        runningBatch.push(el);\n    }\n    if (runningBatch.length > 0)\n        yield runningBatch;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* filter(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            yield el;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* drop(iterator, howMany) {\n    let i = 0;\n    for (const el of iterator) {\n        if (++i > howMany)\n            yield el;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function every(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (!func(el, i++))\n            return false;\n    }\n    return true;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function some(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            return true;\n    }\n    return false;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* map(iterator, func) {\n    let i = 0;\n    for (const el of iterator)\n        yield func(el, i++);\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function reduce(iterator, func, initialAcc) {\n    let i = 0;\n    let acc = initialAcc;\n    for (const el of iterator) {\n        acc = func(acc, el, i++);\n    }\n    return acc;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* uniqueOnly(iterator) {\n    const seen = new Set();\n    for (const el of iterator) {\n        if (!seen.has(el)) {\n            seen.add(el);\n            yield el;\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* uniqueOnlyBy(iterator, func) {\n    const seen = new Set();\n    for (const el of iterator) {\n        const uniqueBy = func(el);\n        if (!seen.has(uniqueBy)) {\n            seen.add(uniqueBy);\n            yield el;\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* reverse(iterator) {\n    const all = Array.from(iterator);\n    for (let i = all.length - 1; i >= 0; i--)\n        yield all[i];\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* takeWhile(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            yield el;\n        else\n            return;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* takeUntilIncluding(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        yield el;\n        if (func(el, i++))\n            return;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* takeUntilExcluding(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            return;\n        yield el;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* concat(...iterators) {\n    for (let i = 0; i < iterators.length; i++)\n        yield* iterators[i];\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* concatIterable(iteratorsProducer) {\n    for (const iterator of iteratorsProducer)\n        yield* iterator;\n}\n//---------------------------------------------------------------------------------------------------------------------\n// just a chained syntax sugar class\n// note, that we either use a combination of `this.derive()` + this.iterable (which will clear the `this.iterable`)\n// or, use just `this` as iterable, which will also clear the iterator\n//\nexport class ChainedIteratorClass {\n    constructor(iterable) {\n        this.iterable = undefined;\n        if (!iterable)\n            throw new Error(\"Require an iterable instance for chaining\");\n        this.iterable = iterable;\n    }\n    derive(iterable) {\n        this.iterable = undefined;\n        return new ChainedIteratorClass(iterable);\n    }\n    copy() {\n        const [iter1, iter2] = split(this.iterable);\n        this.iterable = iter2;\n        return new ChainedIteratorClass(iter1);\n    }\n    split() {\n        const [iter1, iter2] = split(this.iterable);\n        return [new ChainedIteratorClass(iter1), this.derive(iter2)];\n    }\n    inBatchesBySize(batchSize) {\n        return this.derive(inBatchesBySize(this.iterable, batchSize));\n    }\n    filter(func) {\n        return this.derive(filter(this.iterable, func));\n    }\n    drop(howMany) {\n        return this.derive(drop(this.iterable, howMany));\n    }\n    map(func) {\n        return this.derive(map(this.iterable, func));\n    }\n    reduce(func, initialAcc) {\n        return reduce(this, func, initialAcc);\n    }\n    concat() {\n        //@ts-ignore\n        return this.derive(concatIterable(this.iterable));\n    }\n    uniqueOnly() {\n        return this.derive(uniqueOnly(this.iterable));\n    }\n    uniqueOnlyBy(func) {\n        return this.derive(uniqueOnlyBy(this.iterable, func));\n    }\n    every(func) {\n        return every(this, func);\n    }\n    some(func) {\n        return some(this, func);\n    }\n    takeWhile(func) {\n        return this.derive(takeWhile(this.iterable, func));\n    }\n    *[Symbol.iterator]() {\n        let iterable = this.iterable;\n        if (!iterable)\n            throw new Error(\"Chained iterator already exhausted or used to derive the new one\");\n        // practice shows, that cleaning up the iterable after yourself helps garbage collector a lot\n        this.iterable = undefined;\n        yield* iterable;\n        // yes, we really want to avoid memory leaks\n        iterable = undefined;\n    }\n    toArray() {\n        return Array.from(this);\n    }\n    sort(order) {\n        return Array.from(this).sort(order);\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap() {\n        //@ts-ignore\n        return new Map(this);\n    }\n    // toMap<K, V> () : T extends [ K, V ] ? Map<K, V> : never  {\n    //     return new Map<K, V>(this.iterable as (T extends [ K, V ] ? Iterable<T> : never)) as (T extends [ K, V ] ? Map<K, V> : never)\n    // }\n    flush() {\n        for (const element of this) { }\n    }\n    memoize() {\n        return new MemoizedIteratorClass(this);\n    }\n}\nexport const ChainedIterator = (iterator) => new ChainedIteratorClass(iterator);\nexport const CI = ChainedIterator;\n//---------------------------------------------------------------------------------------------------------------------\nexport class MemoizedIteratorClass extends ChainedIteratorClass {\n    constructor() {\n        super(...arguments);\n        this.elements = [];\n        this.$iterator = undefined;\n    }\n    set iterable(iterable) {\n        this.$iterable = iterable;\n    }\n    get iterable() {\n        return this;\n    }\n    derive(iterable) {\n        return new ChainedIteratorClass(iterable);\n    }\n    *[Symbol.iterator]() {\n        const elements = this.elements;\n        if (this.$iterable) {\n            if (!this.$iterator)\n                this.$iterator = this.$iterable[Symbol.iterator]();\n            let iterator = this.$iterator;\n            let alreadyConsumed = elements.length;\n            // yield the 1st batch \"efficiently\"\n            if (alreadyConsumed > 0)\n                yield* elements;\n            while (true) {\n                if (elements.length > alreadyConsumed) {\n                    // wonder if `yield* elements.slice(alreadyConsumed)` is more performant or not\n                    for (let i = alreadyConsumed; i < elements.length; i++)\n                        yield elements[i];\n                    alreadyConsumed = elements.length;\n                }\n                if (!iterator)\n                    break;\n                const { value, done } = iterator.next();\n                if (done) {\n                    iterator = this.$iterator = null;\n                    this.$iterable = null;\n                }\n                else {\n                    elements.push(value);\n                    alreadyConsumed++;\n                    yield value;\n                }\n            }\n        }\n        else {\n            yield* elements;\n        }\n    }\n}\nexport const MemoizedIterator = (iterator) => new MemoizedIteratorClass(iterator);\nexport const MI = MemoizedIterator;\n", "import { CI, MI } from \"../collection/Iterator.js\";\n//---------------------------------------------------------------------------------------------------------------------\nconst MixinInstanceOfProperty = Symbol('MixinIdentity');\nconst MixinStateProperty = Symbol('MixinStateProperty');\n//---------------------------------------------------------------------------------------------------------------------\nclass MixinWalkDepthState {\n    constructor() {\n        this.baseEl = undefined;\n        this.sourceEl = undefined;\n        this.$elementsByTopoLevel = undefined;\n        this.$topoLevels = undefined;\n        this.linearizedByTopoLevelsSource = MI(this.linearizedByTopoLevels());\n    }\n    static new(props) {\n        const me = new this();\n        props && Object.assign(me, props);\n        return me;\n    }\n    get topoLevels() {\n        if (this.$topoLevels !== undefined)\n            return this.$topoLevels;\n        return this.$topoLevels = this.buildTopoLevels();\n    }\n    buildTopoLevels() {\n        return Array.from(this.elementsByTopoLevel.keys()).sort((level1, level2) => level1 - level2);\n    }\n    get elementsByTopoLevel() {\n        if (this.$elementsByTopoLevel !== undefined)\n            return this.$elementsByTopoLevel;\n        return this.$elementsByTopoLevel = this.buildElementsByTopoLevel();\n    }\n    getOrCreateLevel(map, topoLevel) {\n        let elementsAtLevel = map.get(topoLevel);\n        if (!elementsAtLevel) {\n            elementsAtLevel = [];\n            map.set(topoLevel, elementsAtLevel);\n        }\n        return elementsAtLevel;\n    }\n    buildElementsByTopoLevel() {\n        let maxTopoLevel = 0;\n        const baseElements = this.baseEl ? CI(this.baseEl.walkDepthState.elementsByTopoLevel.values()).concat().toSet() : new Set();\n        const map = CI(this.sourceEl.requirements)\n            .map(mixin => mixin.walkDepthState.elementsByTopoLevel)\n            .concat()\n            .reduce((elementsByTopoLevel, [topoLevel, mixins]) => {\n            if (topoLevel > maxTopoLevel)\n                maxTopoLevel = topoLevel;\n            this.getOrCreateLevel(elementsByTopoLevel, topoLevel).push(mixins);\n            return elementsByTopoLevel;\n        }, new Map());\n        this.getOrCreateLevel(map, maxTopoLevel + 1).push([this.sourceEl]);\n        return CI(map).map(([level, elements]) => {\n            return [level, CI(elements).concat().uniqueOnly().filter(mixin => !baseElements.has(mixin)).sort((mixin1, mixin2) => mixin1.id - mixin2.id)];\n        }).toMap();\n    }\n    *linearizedByTopoLevels() {\n        yield* CI(this.topoLevels).map(level => this.elementsByTopoLevel.get(level)).concat();\n    }\n}\n// Note: 65535 mixins only, because of the hashing function implementation (String.fromCharCode)\nlet MIXIN_ID = 1;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * @hidden\n */\nexport const identity = a => class extends a {\n};\n// export type IdentityMixin<Base extends object>         = < T extends AnyConstructor<Base>>(base : T) => T\n//\n// export const IdentityMixin             = <Base extends object>() : IdentityMixin<Base> => identity\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * @hidden\n */\nexport class ZeroBaseClass {\n}\n//---------------------------------------------------------------------------------------------------------------------\nclass MixinState {\n    constructor() {\n        this.id = MIXIN_ID++;\n        this.requirements = [];\n        this.baseClass = ZeroBaseClass;\n        this.identitySymbol = undefined;\n        this.mixinLambda = identity;\n        this.walkDepthState = undefined;\n        // private $hash               : MixinHash             = ''\n        this.$minimalClass = undefined;\n        this.name = '';\n    }\n    static new(props) {\n        const me = new this();\n        props && Object.assign(me, props);\n        me.walkDepthState = MixinWalkDepthState.new({ sourceEl: me, baseEl: getMixinState(me.baseClass) });\n        //------------------\n        const mixinLambda = me.mixinLambda;\n        const symbol = me.identitySymbol = Symbol(mixinLambda.name);\n        const mixinLambdaWrapper = Object.assign(function (base) {\n            const extendedClass = mixinLambda(base);\n            extendedClass.prototype[symbol] = true;\n            return extendedClass;\n        }, {\n            [MixinInstanceOfProperty]: symbol,\n            [MixinStateProperty]: me\n        });\n        Object.defineProperty(mixinLambdaWrapper, Symbol.hasInstance, { value: isInstanceOfStatic });\n        me.mixinLambda = mixinLambdaWrapper;\n        return me;\n    }\n    get minimalClass() {\n        if (this.$minimalClass !== undefined)\n            return this.$minimalClass;\n        return this.$minimalClass = this.buildMinimalClass();\n    }\n    // get hash () : MixinHash {\n    //     if (this.$hash !== '') return this.$hash\n    //\n    //     return this.$hash = this.buildHash()\n    // }\n    // buildHash () : MixinHash {\n    //     return String.fromCharCode(...this.walkDepthState.linearizedByTopoLevelsSource.map(mixin => mixin.id))\n    // }\n    getBaseClassMixinId(baseClass) {\n        const constructor = this.constructor;\n        const mixinId = constructor.baseClassesIds.get(baseClass);\n        if (mixinId !== undefined)\n            return mixinId;\n        const newId = MIXIN_ID++;\n        constructor.baseClassesIds.set(baseClass, newId);\n        return newId;\n    }\n    buildMinimalClass() {\n        const self = this.constructor;\n        let baseCls = this.baseClass;\n        const minimalClassConstructor = this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin) => {\n            const { cls, hash } = acc;\n            const nextHash = hash + String.fromCharCode(mixin.id);\n            let wrapperCls = self.minimalClassesByLinearHash.get(nextHash);\n            if (!wrapperCls) {\n                wrapperCls = mixin.mixinLambda(cls);\n                mixin.name = wrapperCls.name;\n                self.minimalClassesByLinearHash.set(nextHash, wrapperCls);\n            }\n            acc.cls = wrapperCls;\n            acc.hash = nextHash;\n            return acc;\n        }, { cls: baseCls, hash: String.fromCharCode(this.getBaseClassMixinId(baseCls)) }).cls;\n        const minimalClass = Object.assign(minimalClassConstructor, {\n            [MixinInstanceOfProperty]: this.identitySymbol,\n            [MixinStateProperty]: this,\n            mix: this.mixinLambda,\n            derive: (base) => Mixin([minimalClass, base], base => class extends base {\n            }),\n            $: this,\n            toString: this.toString.bind(this)\n        });\n        Object.defineProperty(minimalClass, Symbol.hasInstance, { value: isInstanceOfStatic });\n        return minimalClass;\n    }\n    toString() {\n        return this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin) => `${mixin.name}(${acc})`, this.baseClass.name);\n    }\n}\nMixinState.minimalClassesByLinearHash = new Map();\nMixinState.baseClassesIds = new Map();\n//endregion type helpers\n//---------------------------------------------------------------------------------------------------------------------\nconst isMixinClass = (func) => {\n    return Object.getPrototypeOf(func.prototype).constructor.hasOwnProperty(MixinStateProperty);\n};\nconst getMixinState = (func) => {\n    return Object.getPrototypeOf(func.prototype).constructor[MixinStateProperty];\n};\n//---------------------------------------------------------------------------------------------------------------------\nconst mixin = (required, mixinLambda) => {\n    let baseClass;\n    if (required.length > 0) {\n        const lastRequirement = required[required.length - 1];\n        // absence of `[ MixinStateProperty ]` indicates its a regular class and not a mixin class\n        // avoid assigning ZeroBaseClass - it will be applied as default at the end\n        if (!isMixinClass(lastRequirement) && lastRequirement !== ZeroBaseClass)\n            baseClass = lastRequirement;\n    }\n    const requirements = [];\n    required.forEach((requirement, index) => {\n        const mixinState = requirement[MixinStateProperty];\n        if (mixinState !== undefined) {\n            const currentBaseClass = mixinState.baseClass;\n            // ignore ZeroBaseClass - since those are compatible with any other base class\n            if (currentBaseClass !== ZeroBaseClass) {\n                if (baseClass) {\n                    // already found a base class from requirements earlier\n                    if (baseClass !== currentBaseClass) {\n                        const currentIsSub = currentBaseClass.prototype.isPrototypeOf(baseClass.prototype);\n                        const currentIsSuper = baseClass.prototype.isPrototypeOf(currentBaseClass.prototype);\n                        if (!currentIsSub && !currentIsSuper)\n                            throw new Error(\"Base class mismatch\");\n                        baseClass = currentIsSuper ? currentBaseClass : baseClass;\n                    }\n                }\n                else\n                    // first base class from requirements\n                    baseClass = currentBaseClass;\n            }\n            requirements.push(mixinState);\n        }\n        else {\n            if (index !== required.length - 1)\n                throw new Error(\"Base class should be provided as the last element of the requirements array\");\n        }\n    });\n    //------------------\n    const mixinState = MixinState.new({\n        requirements,\n        mixinLambda: mixinLambda,\n        baseClass: baseClass || ZeroBaseClass\n    });\n    return mixinState.minimalClass;\n};\n//---------------------------------------------------------------------------------------------------------------------\n// this function works both with default mixin class and mixin application function\n// it supplied internally as [Symbol.hasInstance] for the default mixin class and mixin application function\nconst isInstanceOfStatic = function (instance) {\n    return Boolean(instance && instance[this[MixinInstanceOfProperty]]);\n};\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This is the `instanceof` analog for the classes created with [[Mixin]] helper. It also provides [typeguard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).\n *\n * There's no strict need to use it, as the native `instanceof` is also supported for the mixins created with the [[Mixin]] helper and also provides\n * typeguarding.\n *\n * @param instance Any value, normally an instance of the mixin class\n * @param func The constructor function of the class, created with [[Mixin]]\n */\nexport const isInstanceOf = (instance, func) => {\n    return Boolean(instance && instance[func[MixinInstanceOfProperty]]);\n};\n//---------------------------------------------------------------------------------------\n/**\n * This function allows you to create mixin classes. Mixin classes solves the well-known problem with \"classical\" single-class inheritance,\n * in which class hierarchy must form a tree. When using mixins, class hierarchy becomes an arbitrary acyclic graph.\n *\n * Another view on mixins is that, if \"classical\" class is a point (a vertice of the graph), mixin class is an arrow between the points\n * (an edge in the graph, or rather, a description of the edge).\n *\n * Some background information about the mixin pattern can be found [here](https://mariusschulz.com/blog/typescript-2-2-mixin-classes)\n * and [here](https://www.bryntum.com/blog/the-mixin-pattern-in-typescript-all-you-need-to-know/).\n *\n * The pattern, being described here, is the evolution of the previous work, and main advantage is that it solves the compilation error\n * for circular references.\n *\n * Mixin definition. Requirements\n * ------------------------------\n *\n * The pattern looks like:\n *\n *     class Mixin1 extends Mixin(\n *         [],\n *         (base : AnyConstructor) =>\n *\n *         class Mixin1 extends base {\n *             prop1        : string\n *             method1 () : string {\n *                 return this.prop1\n *             }\n *             static static1 : number\n *         }\n *     ){}\n *\n * The core of the definition above is the mixin lambda - a function which receives a base class as its argument and returns a class,\n * extending the base class with additional properties.\n *\n * The example above creates a mixin `Mixin1` which has no requirements. Requirements are the other mixins,\n * which needs to be included in the base class of this mixin.\n *\n * There's also a special type of the requirement,\n * called \"base class requirement\". It is optional and can only appear as the last argument of the requirements\n * array. It does not have to be a mixin, created with the `Mixin` function, but can be any JS class. This requirement\n * specifies, that the base class of this mixin should be a subclass of the given class (or that class itself).\n *\n * The requirements of the mixin needs to be listed 3 times:\n * - as an array of constructor functions, in the 1st argument of the `Mixin` function\n * - as an instance type intersection, in the 1st type argument for the [[AnyConstructor]] type\n * - as an static type intersection, in the 2nd type argument for the [[AnyConstructor]] type\n *\n * For example, `Mixin2` requires `Mixin1`:\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) =>\n *\n *         class Mixin2 extends base {\n *         }\n *     ){}\n *\n * And `Mixin3` requires both `Mixin1` and `Mixin2` (even that its redundant, since `Mixin2` already requires `Mixin1`,\n * but suppose we don't know the implementation details of the `Mixin2`):\n *\n *     class Mixin3 extends Mixin(\n *         [ Mixin1, Mixin2 ],\n *         (base : AnyConstructor<Mixin1 & Mixin2, typeof Mixin1 & typeof Mixin2>) =>\n *\n *         class Mixin3 extends base {\n *         }\n *     ){}\n *\n * Now, `Mixin4` requires `Mixin3`, plus, it requires the base class to be `SomeBaseClass`:\n *\n *     class SomeBaseClass {}\n *\n *     class Mixin4 extends Mixin(\n *         [ Mixin3, SomeBaseClass ],\n *         (base : AnyConstructor<\n *             Mixin3 & SomeBaseClass, typeof Mixin3 & typeof SomeBaseClass\n *         >) =>\n *\n *         class Mixin4 extends base {\n *         }\n *     ){}\n *\n * As already briefly mentioned, the requirements are \"scanned\" deep and included only once. Also all minimal classes are cached -\n * for example the creation of the Mixin3\u00A0will reuse the minimal class of the Mixin2\u00A0instead of creating a new intermediate class.\n * This means that all edges of the mixin dependencies graph are created only once (up to the base class).\n *\n * Requirements can not form cycles - that will generate both compilation error and run-time stack overflow.\n *\n * The typing for the `Mixin` function will provide a compilation error, if the requirements don't match, e.g. some requirement is\n * listed in the array, but missed in the types. This protects you from trivial mistakes. However, the typing is done up to 10 requirements only.\n * If you need more than 10 requirements for the mixin, use the [[MixinAny]] function, which is an exact analog of `Mixin`, but without\n * this type-level protection for requirements mismatch.\n *\n * It is possible to simplify the type of the `base` argument a bit, by using the [[ClassUnion]] helper. However, it seems in certain edge cases\n * it may lead to compilation errors. If your scenarios are not so complex you should give it a try. Using the [[ClassUnion]] helper, the\n * `Mixin3` can be defined as:\n *\n *     class Mixin3 extends Mixin(\n *         [ Mixin1, Mixin2 ],\n *         (base : ClassUnion<typeof Mixin1, typeof Mixin2>) =>\n *\n *         class Mixin3 extends base {\n *         }\n *     ){}\n *\n * Note, that due to this [issue](https://github.com/Microsoft/TypeScript/issues/7342), if you use decorators in your mixin class,\n * the declaration needs to be slightly more verbose (can not use compact notation for the arrow functions):\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) => {\n *             class Mixin2 extends base {\n *                 @decorator\n *                 prop2 : string\n *             }\n *             return Mixin2\n *         }\n *     ){}\n *\n * As you noticed, the repeating listing of the requirements is somewhat verbose. Suggestions how the pattern can be improved\n * are [very welcomed](mailto:nickolay8@gmail.com).\n *\n * Mixin instantiation. Mixin constructor. `instanceof`\n * --------------------------------\n *\n * You can instantiate any mixin class just by using its constructor:\n *\n *     const instance1 = new Mixin1()\n *     const instance2 = new Mixin2()\n *\n * As explained in details [here](https://mariusschulz.com/blog/typescript-2-2-mixin-classes), mixin constructor should accept variable number of arguments\n * with the `any` type. This is simply because the mixin is supposed to be applicable to any other base class, which may have its own type\n * of the constructor arguments.\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) => {\n *             class Mixin2 extends base {\n *                 prop2 : string\n *\n *                 constructor (...args: any[]) {\n *                     super(...args)\n *                     this.prop2 = ''\n *                 }\n *             }\n *             return Mixin2\n *         }\n *     ){}\n *\n * In other words, its not possible to provide any type-safety for mixin instantiation using regular class constructor.\n *\n * However, if we change the way we create class instances a little, we can get the type-safety back. For that,\n * we need to use a \"uniform\" class constructor - a constructor which has the same form for all classes. The [[Base]] class\n * provides such constructor as its static [[Base.new|new]] method. The usage of `Base` class is not required - you can use\n * any other base class.\n *\n * The `instanceof` operator works as expected for instances of the mixin classes. It also takes into account all the requirements.\n * For example:\n *\n *     const instance2 = new Mixin2()\n *\n *     const isMixin2 = instance2 instanceof Mixin2 // true\n *     const isMixin1 = instance2 instanceof Mixin1 // true, since Mixin2 requires Mixin1\n *\n * See also [[isInstanceOf]].\n *\n * \"Manual\" class derivation\n * --------------------------------\n *\n * You have defined a mixin using the `Mixin` function. Now you want to apply it to some base class to get the \"specific\" class to be able\n * to instantiate it. As described above - you don't have to, you can instantiate it directly.\n *\n * Sometimes however, you still want to derive the class \"manually\". For that, you can use static methods `mix` and `derive`, available\n * on all mixins.\n *\n * The `mix` method provides a direct access to the mixin lambda. It does not take requirements into account - that's the implementor's responsibility.\n * The `derive` method is something like \"accumulated\" mixin lambda - mixin lambda with all requirements.\n *\n * Both `mix` and `derive` provide the reasonably typed outcome.\n *\n *     class Mixin1 extends Mixin(\n *         [],\n *         (base : AnyConstructor) =>\n *\n *         class Mixin1 extends base {\n *             prop1        : string\n *         }\n *     ){}\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) =>\n *\n *         class Mixin2 extends base {\n *             prop2        : string\n *         }\n *     ){}\n *\n *     const ManualMixin1 = Mixin1.mix(Object)\n *     const ManualMixin2 = Mixin2.mix(Mixin1.mix(Object))\n *\n *     const AnotherManualMixin1 = Mixin1.derive(Object)\n *     const AnotherManualMixin2 = Mixin2.derive(Object)\n *\n * Generics\n * --------\n *\n * Using generics with mixins is tricky because TypeScript does not have higher-kinded types and type inference for generics. Still some form\n * of generic arguments is possible, using the interface merging trick.\n *\n * Here's the pattern:\n *\n * ```ts\n * class Duplicator<Element> extends Mixin(\n *     [],\n *     (base : AnyConstructor) =>\n *\n *     class Duplicator extends base {\n *         Element                 : any\n *\n *         duplicate (value : this[ 'Element' ]) : this[ 'Element' ][] {\n *             return [ value, value ]\n *         }\n *     }\n * ){}\n *\n * interface Duplicator<Element> {\n *     Element : Element\n * }\n *\n * const dup = new Duplicator<boolean>()\n *\n * dup.duplicate('foo') // TS2345: Argument of type '\"foo\"' is not assignable to parameter of type 'boolean'.\n * ```\n *\n * In the example above, we've defined a generic argument `Element` for the outer mixin class, but in fact, that argument is not used anywhere in the\n * nested class definition in the mixin lambda. Instead, in the nested class, we define a property `Element`, which plays the role of the\n * generic argument.\n *\n * Mixin class methods then can refer to the generic type as `this[ 'Element' ]`.\n *\n * The generic arguments of the outer and nested classes are tied together in the additional interface declaration, which, by TypeScript rules\n * is merged together with the class definition. In this declaration, we specify that property `Element` has type of the `Element` generic argument.\n *\n * Limitations\n * ---------\n *\n * The most important limitation we found (which affect the old pattern as well) is the compilation error, which will be issued for\n * the private/protected methods, when compiling with declarations emitting (*.d.ts files generation).\n *\n * This is a [well-known problem](https://github.com/microsoft/TypeScript/issues/35822) in the TypeScript world \u2013 the *.d.ts files do not represent\n * the internal data structures of the TypeScript compiler well. Instead they use some simplified syntax, optimized for human editing.\n * This is why the compiler may generate false positives in the incremental compilation mode \u2013 it uses *.d.ts files internally.\n *\n * This can be a show-stopper for the people that use declaration files (usually for publishing). Keep in mind though, that you can always\n * publish actual TypeScript sources along with the generated JavaScript files, instead of publishing JavaScript + declarations files.\n *\n */\nexport const Mixin = mixin;\n/**\n * This is an exact analog of the [[Mixin]] function, but without type-level protection for requirements mismatch.\n * It supports unlimited number of requirements.\n */\nexport const MixinAny = mixin;\n", "//---------------------------------------------------------------------------------------------------------------------\n/**\n * This is a base class, providing the type-safe static constructor [[new]]. This is very convenient when using\n * [[Mixin|mixins]], as mixins can not have types in the constructors.\n */\nexport class Base {\n    /**\n     * This method applies its 1st argument (if any) to the current instance using `Object.assign()`.\n     *\n     * Supposed to be overridden in the subclasses to customize the instance creation process.\n     *\n     * @param props\n     */\n    initialize(props) {\n        props && Object.assign(this, props);\n    }\n    /**\n     * This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the\n     * class properties. It will generate a compilation error, if unknown property is provided.\n     *\n     * For example:\n     *\n     * ```ts\n     * class MyClass extends Base {\n     *     prop     : string\n     * }\n     *\n     * const instance : MyClass = MyClass.new({ prop : 'prop', wrong : 11 })\n     * ```\n     *\n     * will produce:\n     *\n     * ```plaintext\n     * TS2345: Argument of type '{ prop: string; wrong: number; }' is not assignable to parameter of type 'Partial<MyClass>'.\n     * Object literal may only specify known properties, and 'wrong' does not exist in type 'Partial<MyClass>'\n     * ```\n     *\n     * The only thing this constructor does is create an instance and call the [[initialize]] method on it, forwarding\n     * the first argument. The customization of instance is supposed to be performed in that method.\n     *\n     * @param props\n     */\n    static new(props) {\n        const instance = new this();\n        instance.initialize(props);\n        return instance;\n    }\n}\n", "/**\n * @module Core/helper/BrowserHelper\n */\n/**\n * Static helper class that does browser or platform detection and provides other helper functions.\n */\nexport default class BrowserHelper {\n    static  supportsPointerEvents = Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent);\n    // Locker Service does not allow to instantiate PointerEvents. LWS apparently does, however.\n    // https://github.com/bryntum/support/issues/5578\n    static supportsPointerEventConstructor = typeof PointerEvent !== 'undefined';\n    static PointerEventConstructor = globalThis.PointerEvent || globalThis.CustomEvent;\n    //region Init\n    static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {\n        const me = this;\n        // os\n        me._isLinux = Boolean(platform.match(/Linux/));\n        me._isMac = Boolean(platform.match(/Mac/));\n        me._isWindows = Boolean(platform.match(/Win32/));\n        // Edge user agent contains webkit too.\n        // This is not a typo. Edge has \"Safari/537.36 Edg/96.0.1054.34\"\n        me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));\n        me._firefoxVersion = me.getVersion(userAgent, /Firefox\\/(\\d+)\\./);\n        me._isFirefox = me._firefoxVersion > 0;\n        me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\\/(\\d+)\\./);\n        me._isChrome = me._chromeVersion > 0;\n        me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;\n        me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));\n        me._safariVersion = me.getVersion(userAgent, /Version\\/(.*).Safari/);\n        me._isAndroid = Boolean(userAgent.match(/Android/g));\n    }\n    //endregion\n    //region Device\n    /**\n     * Yields `true` if the current browser supports CSS style `overflow:clip`.\n     * @property {Boolean}\n     * @readonly\n     * @internal\n     */\n    static get supportsOverflowClip() {\n        if (this._supportsOverflowClip == null) {\n            const div = document.createElement('div');\n            div.style.overflow = 'clip';\n            div.style.display = 'none';\n            // If we're called before DOMContentLoaded, body won't be available.\n            // HTML element works for style calcs.\n            document.documentElement.appendChild(div);\n            this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue('overflow') === 'clip';\n            div.remove();\n        }\n        return this._supportsOverflowClip;\n    }\n    /**\n     * Yields `true` if the current browser supports CSS style `position:sticky`.\n     * @property {Boolean}\n     * @readonly\n     * @internal\n     */\n    static get supportsSticky() {\n        return true;\n    }\n    /**\n     * Returns matched version for userAgent.\n     * @param {String} versionRe version match regular expression\n     * @returns {Number} matched version\n     * @readonly\n     * @internal\n     */\n    static getVersion(userAgent, versionRe) {\n        const match = userAgent.match(versionRe);\n        return match ? parseFloat(match[1]) : 0;\n    }\n    /**\n     * Determines if the user is using a touch device.\n     * @property {Boolean}\n     * @readonly\n     * @internal\n     */\n    static get isTouchDevice() {\n        // Allow tests or client code to set\n        if (this._isTouchDevice === undefined) {\n            this._isTouchDevice = globalThis.matchMedia('(pointer:coarse)').matches;\n        }\n        return this._isTouchDevice;\n    }\n    // Reports true by default for our tests\n    static get isHoverableDevice() {\n        if (this._isHoverableDevice === undefined) {\n            this._isHoverableDevice = globalThis.matchMedia('(any-hover: hover)').matches;\n        }\n        return this._isHoverableDevice;\n    }\n    //endregion\n    //region Platform\n    static get isBrowserEnv() {\n        // This window reference is left on purpose, globalThis is always defined\n        // eslint-disable-next-line bryntum/no-window-in-lib\n        return typeof window !== 'undefined';\n    }\n    /**\n     * Checks if platform is Mac.\n     * @property {Boolean}\n     * @readonly\n     * @category Platform\n     */\n    static get isMac() {\n        return this._isMac;\n    }\n    /**\n     * Checks if platform is Windows.\n     * @property {Boolean}\n     * @readonly\n     * @category Platform\n     */\n    static get isWindows() {\n        return this._isWindows;\n    }\n    /**\n     * Checks if platform is Linux.\n     * @property {Boolean}\n     * @readonly\n     * @category Platform\n     */\n    static get isLinux() {\n        return this._isLinux;\n    }\n    /**\n     * Checks if platform is Android.\n     * @property {Boolean}\n     * @readonly\n     * @category Platform\n     */\n    static get isAndroid() {\n        return this._isAndroid;\n    }\n    //endregion\n    //region Browser\n    /**\n     * Checks if browser is Webkit.\n     * @property {Boolean}\n     * @readonly\n     * @category Browser\n     */\n    static get isWebkit() {\n        return this._isWebkit;\n    }\n    /**\n     * Checks if browser is Chrome or Chromium based browser.\n     * Returns truthy value for Edge Chromium.\n     * @property {Boolean}\n     * @readonly\n     * @category Browser\n     */\n    static get isChrome() {\n        return this._isChrome;\n    }\n    /**\n     * Returns the major Chrome version or 0 for other browsers.\n     * @property {Number}\n     * @readonly\n     * @category Browser\n     */\n    static get chromeVersion() {\n        return this._chromeVersion;\n    }\n    /**\n     * Checks if browser is Firefox.\n     * @property {Boolean}\n     * @readonly\n     * @category Browser\n     */\n    static get isFirefox() {\n        return this._isFirefox;\n    }\n    /**\n     * Returns the major Firefox version or 0 for other browsers.\n     * @property {Number}\n     * @readonly\n     * @category Browser\n     */\n    static get firefoxVersion() {\n        return this._firefoxVersion;\n    }\n    /**\n     * Checks if browser is Safari.\n     * @property {Boolean}\n     * @readonly\n     * @category Browser\n     */\n    static get isSafari() {\n        return this._isSafari;\n    }\n    static get safariVersion() {\n        return this._safariVersion;\n    }\n    /**\n     * Checks if browser is mobile Safari\n     * @property {Boolean}\n     * @readonly\n     * @category Browser\n     */\n    static get isMobileSafari() {\n        return this._isMobileSafari;\n    }\n    static get platform() {\n        const me = this;\n        return me._isLinux ? 'linux'\n            : me._isMac ? 'mac'\n                : me._isWindows ? 'windows'\n                    : me._isAndroid ? 'android'\n                        : me._isMobileSafari ? 'ios'\n                            : null;\n    }\n    /**\n     * Returns `true` if the browser supports passive event listeners.\n     * @property {Boolean}\n     * @internal\n     * @deprecated Since 5.0. All modern browsers now support passive event listeners.\n     * @category Browser\n     */\n    static get supportsPassive() {\n        return true;\n    }\n    // Only works in secure contexts\n    static get supportsRandomUUID() {\n        if (this._supportsRandomUUID === undefined) {\n            try {\n                this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);\n            }\n            catch (e) {\n                this._supportsRandomUUID = false;\n            }\n        }\n        return this._supportsRandomUUID;\n    }\n    //endregion\n    //region Storage\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n    static get storageAvailable() {\n        let storage, x;\n        try {\n            storage = localStorage;\n            x = '__storage_test__';\n            storage.setItem(x, x);\n            storage.removeItem(x);\n            return true;\n        }\n        catch (e) {\n            return e instanceof DOMException && (\n            // everything except Firefox\n                e.code === 22 ||\n                // Firefox\n                e.code === 1014 ||\n                // test name field too, because code might not be present\n                // everything except Firefox\n                e.name === 'QuotaExceededError' ||\n                // Firefox\n                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n                // acknowledge QuotaExceededError only if there's something already stored\n                storage.length !== 0;\n        }\n    }\n    static setLocalStorageItem(key, value) {\n        this.storageAvailable && localStorage.setItem(key, value);\n    }\n    static getLocalStorageItem(key) {\n        return this.storageAvailable && localStorage.getItem(key);\n    }\n    static removeLocalStorageItem(key) {\n        this.storageAvailable && localStorage.removeItem(key);\n    }\n    //endregion\n    //region Helpers\n    /**\n     * Returns parameter value from search string by parameter name.\n     * @param {String} paramName search parameter name\n     * @param {String} [defaultValue] default value if parameter not found\n     * @param {String} [search] search string. Defaults to `document.location.search`\n     * @returns {String} search parameter string value\n     * @category Helper\n     */\n    static searchParam(paramName, defaultValue = null, search = document.location.search) {\n        const\n            re    = new RegExp(`[?&]${paramName}=?([^&]*)`),\n            match = search.match(re);\n        return (match && match[1]) || defaultValue;\n    }\n    /**\n     * Returns cookie by name.\n     * @param {String} name cookie name\n     * @returns {String} cookie string value\n     * @category Helper\n     */\n    static getCookie(name) {\n        const\n            nameEq      = encodeURIComponent(name) + '=',\n            cookieItems = document.cookie.split(';');\n        for (let i = 0; i < cookieItems.length; i++) {\n            let c = cookieItems[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEq) === 0) {\n                return decodeURIComponent(c.substring(nameEq.length, c.length));\n            }\n        }\n        return '';\n    }\n    /**\n     * Triggers a download of a file with the specified name / URL.\n     * @param {String} filename The filename of the file to be downloaded\n     * @param {String} [url] The URL where the file is to be downloaded from\n     * @internal\n     * @category Download\n     */\n    static download(filename, url) {\n        const a = document.createElement('a');\n        a.download = filename;\n        a.href = url || filename;\n        a.style.cssText = 'display:none';\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n    }\n    /**\n     * Triggers a download of a Blob with the specified name.\n     * @param {Blob} blob The Blob to be downloaded\n     * @param {String} filename The filename of the file to be downloaded\n     * @internal\n     * @category Download\n     */\n    static downloadBlob(blob, filename) {\n        const url = globalThis.URL.createObjectURL(blob);\n        this.download(filename, url);\n        globalThis.URL.revokeObjectURL(url);\n    }\n    static get queryString() {\n        // new URLSearchParams throws in salesforce\n        // https://github.com/salesforce/lwc/issues/1812\n        const params = new URL(globalThis.location.href).searchParams;\n        // ?. to be nice to users with Chrome versions < 73\n        return Object.fromEntries?.(params.entries());\n    }\n    static copyToClipboard(code) {\n        let success = true;\n        const textArea = document.createElement('textarea');\n        textArea.value = code;\n        textArea.style.height = textArea.style.width = 0;\n        document.body.appendChild(textArea);\n        textArea.select();\n        try {\n            document.execCommand('copy');\n        }\n        catch (e) {\n            success = false;\n        }\n        textArea.remove();\n        return success;\n    }\n    static isBryntumOnline(searchStrings) {\n        searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];\n        return Boolean(/^(www\\.)?bryntum\\.com/.test(globalThis.location.host) || searchStrings?.some(str => this.queryString[str] != null));\n    }\n    /**\n     * Returns truthy value if page contains Content Security Policy meta tag or globalThis.bryntum.CSP is truthy value\n     * @returns {Boolean}\n     * @internal\n     **/\n    static get isCSP() {\n        const { bryntum, document } =  globalThis;\n        if (bryntum.CSP == null) {\n            bryntum.CSP = Boolean(document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]'));\n        }\n        return bryntum.CSP;\n    }\n    //endregion\n    // region Clipboard\n    /**\n     * This creates a global clipboard object that can be used by multiple Bryntum products on same page.\n     * This function is called each time BrowserHelper.writeToClipboard or BrowserHelper.readFromClipboard is called.\n     * @internal\n     */\n    static async setupClipboard() {\n        if (!globalThis.bryntum.clipboard) {\n            globalThis.bryntum.clipboard = {\n                // Defaults to true, so to\n                hasNativeAccess : true,\n                async writeText(text, allowNative) {\n                    if (allowNative && this.hasNativeAccess) {\n                        try {\n                            await navigator.clipboard.writeText(text);\n                        }\n                        catch (e) {\n                            this.hasNativeAccess = false;\n                        }\n                    }\n                    // Always writes to local clipboard\n                    this._content = text;\n                },\n                async readText(allowNative) {\n                    if (allowNative && this.hasNativeAccess) {\n                        try {\n                            return await navigator.clipboard.readText();\n                        }\n                        catch (e) {\n                            this.hasNativeAccess = false;\n                        }\n                    }\n                    return this._content;\n                }\n            };\n        }\n        return globalThis.bryntum.clipboard;\n    }\n    /**\n     * Will try to detect native clipboard access if not `allowNative` is `false`. If access to native clipboard is\n     * provided, it will try to store the string value there. Otherwise, it will use an internal storage instead.\n     * @param {String} text Only text value is supported\n     * @param {Boolean} allowNative `false` to only use internal clipboard. This is not a global setting, it has to be passed as\n     * an argument to each read/write call.\n     * @internal\n     */\n    static async writeToClipboard(text, allowNative = true) {\n        const clipboard = await this.setupClipboard();\n        return await clipboard.writeText(text, allowNative);\n    }\n    /**\n     * Will try to detect native clipboard access if not `allowNative` is `false`. If access to native clipboard is\n     * provided, it will try to read from there. Otherwise, it will read from an internal storage instead.\n     * @param {Boolean} allowNative `false` to only use internal clipboard. This is not a global setting, it has to be\n     * passed as an argument to each read/write call.\n     * @internal\n     */\n    static async readFromClipboard(allowNative = true) {\n        const clipboard = await this.setupClipboard();\n        return await clipboard.readText(allowNative);\n    }\n    // endregion\n}\nif (BrowserHelper.isBrowserEnv) {\n    BrowserHelper.cacheFlags();\n}\nBrowserHelper._$name = 'BrowserHelper';", "// IMPORTANT - adding imports here can create problems for Base class\nimport Objects from './util/Objects.js';\nimport BrowserHelper from './BrowserHelper.js';\n/**\n * @module Core/helper/StringHelper\n */\nlet charsToEncode, entitiesToDecode, htmlEncodeRe, htmlDecodeRe;\nconst\n    camelLettersRe = /([a-z])([A-Z])/g,\n    crlfRe         = /[\\n\\r]/g,\n    escapeRegExpRe = /[.*+?^${}()|[\\]\\\\]/g, // same as NPM escape-string-regexp\n    htmlRe         = /[&<]/,\n    idRe           = /(^[^a-z]+[^\\w]+)/gi,\n    whiteSpaceRe   = /\\s+/,\n    domIdRe        = /^[^a-z]+|[^\\w:.-]+/gi,\n    htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10)),\n    htmlEncoder = (m, captured) => charsToEncode[captured],\n    hyphenateCamelLetters = (all, g1, g2) => {\n        return `${g1}-${g2.toLowerCase()}`;\n    },\n    separateCamelLetters = (all, g1, g2) => {\n        return `${g1} ${g2.toLowerCase()}`;\n    },\n    replaceNonIdChar    = c => {\n        if (c) {\n            return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join('')}`;\n        }\n        return '__blank__';\n    },\n    hyphenateCache = {},\n    separatedCache = {};\n/**\n * Helper for string manipulation.\n */\nexport default class StringHelper {\n    //region Transform\n    /**\n     * Capitalizes the first letter of a string, \"myString\" -> \"MyString\".\n     * @param {String} string The string to capitalize\n     * @returns {String} The capitalized string or the value of `string` if falsy.\n     * @category String formatting\n     */\n    static capitalize(string) {\n        return string && (string[0].toUpperCase() + string.substr(1));\n    }\n    /**\n     * Makes the first letter of a string lowercase, \"MyString\" -> \"myString\".\n     * @param {String} string The string to un-capitalize.\n     * @returns {String} The un-capitalized string or the value of `string` if falsy.\n     * @category String formatting\n     */\n    static uncapitalize(string) {\n        return string && (string[0].toLowerCase() + string.substr(1));\n    }\n    /**\n     * Converts the passed camelCased string to a hyphen-separated string. eg \"minWidth\" -> \"min-width\"\n     * @param {String} string The string to convert.\n     * @returns {String} The string with adjoining lower and upper case letters\n     * separated by hyphens and converted to lower case.\n     * @category String formatting\n     * @internal\n     */\n    static hyphenate(string) {\n        // Cached since it is used heavily with DomHelper.sync()\n        const cached = hyphenateCache[string];\n        if (cached) {\n            return cached;\n        }\n        return hyphenateCache[string] = string.replace(camelLettersRe, hyphenateCamelLetters);\n    }\n    /**\n     * Converts the passed camelCased string to a capitalized, space-separated string. eg \"startDate\" -> \"Start date\".\n     * @param {String} string The string to convert.\n     * @returns {String} The string with spaces separating words.\n     * @category String formatting\n     * @internal\n     */\n    static separate(string) {\n        // Cached since it may be used heavily\n        const cached = separatedCache[string];\n        if (cached) {\n            return cached;\n        }\n        return separatedCache[string] = this.capitalize(string.replace(camelLettersRe, separateCamelLetters));\n    }\n    /**\n     * Creates an alphanumeric identifier from any passed string. Encodes spaces and non-alpha characters.\n     * @param {String} inString The string from which to strip non-identifier characters.\n     * @returns {String}\n     * @category Misc\n     * @internal\n     */\n    static createId(inString) {\n        return String(inString).replace(idRe, replaceNonIdChar);\n    }\n    static makeValidDomId(id, replaceValue = '') {\n        if (id == null) {\n            return null;\n        }\n        return String(id).replace(domIdRe, replaceValue);\n    }\n    //endregion\n    //region Html\n    static escapeRegExp(string, flags) {\n        // $& means the whole matched string\n        let ret = string.replace(escapeRegExpRe, '\\\\$&');\n        if (flags !== undefined) {\n            ret = new RegExp(ret, flags);\n        }\n        return ret;\n    }\n    /**\n     * This method decodes HTML entities and returns the original HTML.\n     *\n     * See also {@link #function-encodeHtml-static}.\n     * @param {String} str\n     * @returns {String}\n     * @category HTML\n     */\n    static decodeHtml(str) {\n        return str && String(str).replace(htmlDecodeRe, htmlDecoder);\n    }\n    /**\n     * This method encodes HTML entities and returns a string that can be placed in the document and produce the\n     * original text rather than be interpreted as HTML. Using this method with user-entered values prevents those\n     * values from executing as HTML (i.e., a cross-site scripting or \"XSS\" security issue).\n     *\n     * See also {@link #function-decodeHtml-static}.\n     * @param {String} str\n     * @returns {String}\n     * @category HTML\n     */\n    static encodeHtml(str = '') {\n        return str && String(str).replace(htmlEncodeRe, htmlEncoder);\n    }\n    /**\n     * This method is similar to {@link #function-encodeHtml-static} except that `\\n` and `\\r` characters in the\n     * given `str` are replaced by `<br>` tags _after_ first being encoded by {@link #function-encodeHtml-static}.\n     * @param {String} str\n     * @returns {String}\n     * @category HTML\n     * @internal\n     */\n    static encodeHtmlBR(str) {\n        return StringHelper.encodeHtml(str)?.replace(crlfRe, '<br>');\n    }\n    /**\n     * Returns `true` if the provided `text` contains special HTML characters.\n     * @param {String} text\n     * @returns {Boolean}\n     * @category HTML\n     * @internal\n     */\n    static isHtml(text) {\n        return typeof text === 'string' && htmlRe.test(text || '');\n    }\n    /**\n     * Initializes HTML entities used by {@link #function-encodeHtml-static} and {@link #function-decodeHtml-static}.\n     * @param {Object} [mappings] An object whose keys are characters that should be encoded and values are the HTML\n     * entity for the character.\n     * @private\n     */\n    static initHtmlEntities(mappings) {\n        mappings = mappings || {\n            '&' : '&amp;',\n            '>' : '&gt;',\n            '<' : '&lt;',\n            '\"' : '&quot;',\n            \"'\" : '&#39;'\n        };\n        const chars = Object.keys(mappings);\n        // Maps '<' to '&lt;'\n        charsToEncode = mappings;\n        // Inverts the mapping so we can convert '&lt;' to '<'\n        entitiesToDecode = chars.reduce((prev, val) => {\n            prev[mappings[val]] = val;\n            return prev;\n        }, {});\n        // Creates a regex char set like /([<&>])/g to match the characters that need to be encoded (escaping any of\n        // the regex charset special chars '[', ']' and '-'):\n        htmlEncodeRe = new RegExp(`([${chars.map(c => '[-]'.includes(c) ? '\\\\' + c : c).join('')}])`, 'g');\n        // Creates a regex like /(&lt;|&amp;|&gt;)/ig to match encoded entities... good news is that (valid) HTML\n        // entities do not contain any regex special characters:\n        htmlDecodeRe = new RegExp(`(${Object.values(mappings).join('|')}|&#[0-9]+;)`, 'ig');\n    }\n    //endregion\n    //region JSON\n    /**\n     * Parses JSON inside a try-catch block. Returns null if the string could not be parsed.\n     *\n     * @param {String} string String to parse\n     * @returns {Object} Resulting object or `null` if parse failed\n     * @category JSON\n     */\n    static safeJsonParse(string) {\n        let parsed = null;\n        try {\n            parsed = JSON.parse(string);\n        }\n        catch (e) {\n        }\n        return parsed;\n    }\n    /**\n     * Stringifies an object inside a try-catch block. Returns null if an exception is encountered.\n     *\n     * See [JSON.stringify on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n     * for more information on the arguments.\n     *\n     * @param {Object} object The object to stringify\n     * @param {Function|String[]|Number[]} [replacer] A function or array of string/number used to determine properties\n     * to include in the JSON string\n     * @param {String|Number} [space] Number of spaces to indent or string used as whitespace\n     * @returns {String} Resulting object or null if stringify failed\n     * @category JSON\n     */\n    static safeJsonStringify(object, replacer = null, space = null) {\n        let result = null;\n        try {\n            result = JSON.stringify(object, replacer, space);\n        }\n        catch (e) {\n        }\n        return result;\n    }\n    //endregion\n    //region Split & join\n    /**\n     * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.\n     * @param paths {Array} array of paths to join\n     * @param pathSeparator [{String}] path separator. Default value is '/'\n     * @returns {String}\n     * @category Misc\n     * @internal\n     */\n    static joinPaths(paths, pathSeparator = '/') {\n        return paths.join(pathSeparator).replace(new RegExp('\\\\' + pathSeparator + '+', 'g'), pathSeparator);\n    }\n    /**\n     * Returns the provided string split on whitespace. If the string is empty or consists of only whitespace, the\n     * returned array will be empty. If `str` is not a string, it is simply returned. This allows `null` or already\n     * split strings (arrays) to be passed through.\n     *\n     * For example:\n     * ```\n     *  console.log(StringHelper.split(' abc def xyz   '));\n     *  > ['abc', 'def', 'xyz']\n     *  console.log(StringHelper.split(''));\n     *  > []\n     * ```\n     * Compare to the standard `split()` method:\n     * ```\n     *  console.log(' abc def xyz   '.split(/\\s+/));\n     *  > ['', 'abc', 'def', 'xyz', '']\n     *  console.log(''.split(/\\s+/));\n     *  > ['']\n     * ```\n     * @param {String} str\n     * @param {String|RegExp} delimiter\n     * @returns {String[]}\n     * @category Misc\n     * @internal\n     */\n    static split(str, delimiter = whiteSpaceRe) {\n        let ret = str;\n        if (typeof ret === 'string') {\n            ret = str.trim();  // w/o trim() whitespace on the ends will give us '' in the array\n            ret = ret ? ret.split(delimiter) : []; // also ''.split() = ['']\n        }\n        return ret;\n    }\n    //endregion\n    //region XSS\n    /**\n     * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site\n     * Scripting) attacks.\n     *\n     * For example:\n     *\n     * ```javascript\n     *  eventRenderer(eventRecord) {\n     *      return StringHelper.xss`<span class=\"${eventRecord.attrib}\">${eventRecord.name}</span>`;\n     *  }\n     * ```\n     *\n     * @param {TemplateStringsArray} strings The template string array\n     * @param {...any} values The interpolated values in the template string\n     * @returns {String} The encoded string\n     * See {@link Core.helper.StringHelper#function-encodeHtml-static}.\n     */\n    static xss(strings, ...values) {\n        const buf = [];\n        let i = values.length;\n        buf[i] = strings[i];\n        while (i-- > 0) {\n            buf[i] = strings[i] + StringHelper.encodeHtml(values[i]);\n        }\n        return buf.join('');\n    }\n    /**\n     * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site\n     * Scripting) attacks. Unlike {@link Core.helper.StringHelper#function-xss-static}, this method converts `\\n` and\n     * `\\r` characters into `<br>` tags.\n     *\n     * For example:\n     *\n     * ```javascript\n     *  eventRenderer(eventRecord) {\n     *      return StringHelper.xssBR`<span class=\"${eventRecord.attrib}\">${eventRecord.name}</span>`;\n     *  }\n     * ```\n     *\n     * See {@link Core.helper.StringHelper#function-encodeHtmlBR-static}.\n     * @internal\n     */\n    static xssBR(strings, ...values) {\n        const buf = [];\n        let i = values.length;\n        buf[i] = strings[i];\n        while (i-- > 0) {\n            buf[i] = strings[i] + StringHelper.encodeHtmlBR(values[i]);\n        }\n        return buf.join('');\n    }\n    //endregion\n    //region JavaScript string\n    /**\n     * Converts a value to a JavaScript string (not JSON).\n     *\n     * For example a date to `\"new Date(y, m, d)\"`, an array to `\"[...]\"` etc.\n     *\n     * @param {*} value\n     * @param {Object} [options]\n     * @returns {String}\n     * @internal\n     */\n    static toJavaScriptValue(value, options) {\n        const type = Objects.typeOf(value);\n        if (type === 'boolean' || type === 'string' || type === 'number' || value === null) {\n            return StringHelper.safeJsonStringify(value);\n        }\n        if (value === globalThis) {\n            return 'window';\n        }\n        if (type === 'date') {\n            return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;\n        }\n        if (type === 'array') {\n            return `[${value.map(v => StringHelper.toJavaScriptValue(v, options))}]`;\n        }\n        if (type === 'object' || type === 'instance') {\n            return this.toJavaScriptString(value, options);\n        }\n        if (type === 'function') {\n            let contents = value.toString();\n            // async myFunction() {} => async function() {}\n            if (contents.match(/^async (\\w+?)\\(/)) {\n                contents = contents.replace(/^async (\\w+?)\\(/, 'async function(');\n            }\n            // Not an arrow fn? Replace name with function since we always add prop name prior to getting here\n            // eventRenderer() {} -> function() {}\n            else if (!contents.startsWith('async(') && contents.match(/^(\\w+?)\\(/)) {\n                contents = contents.replace(/^(\\w+?)\\(/, 'function(');\n            }\n            return contents;\n        }\n        if (type === 'class') {\n            if (value.toJavaScriptValue) {\n                return value.toJavaScriptValue(options);\n            }\n            return Object.prototype.hasOwnProperty.call(value, '$name') ? value.$name : value.name;\n        }\n    }\n    /**\n     * Converts an object into a JavaScript string (not JSON).\n     *\n     * For example `{ a: 1, b: [2, 3] }` -> `\"'{ a: 1, b: [2, 3] }'\"`\n     *\n     * @param {Object} obj\n     * @param {Object} [options]\n     * @returns {String}\n     * @internal\n     */\n    static toJavaScriptString(obj, options = {}) {\n        const\n            level      = options.level ?? 0,\n            intendSize = 2;\n        // Not using template strings to have control over indentation\n        return '{\\n' +\n            Object.keys(obj).map(key =>\n                // All properties in an object are indented one step further than the object itself\n                ' '.repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `\"${key}\"` : key) + `: ${StringHelper.toJavaScriptValue(obj[key], { ...options, level : level + 1 })}`\n            ).join(',\\n') +\n            // Closing brace is indented to same level as the object\n            '\\n' + ' '.repeat((level) * intendSize) + '}';\n    }\n    /**\n     * Escapes \" and \\ in CSS attribute selectors, e.g. [data-id=\"somevalue\"]\n     *\n     * Usage:\n     * ```javascript\n     * document.querySelector(StringHelper.cssAttributeQuery('data-id', 'id with & \\\\ chars'))\n     * ```\n     *\n     * @param {String} attr\n     * @param {String|Number} value\n     * @returns {String}\n     */\n    static encodeAttributeSelector(attr, value) {\n        return `[${attr}=\"${String(value).replace(/[\"\\\\]/g, '\\\\$&')}\"]`;\n    }\n    //endregion\n    //region UUID\n    static fakeNodeUUIDIndex = 0;\n    /**\n     * Generates a UUID. Uses `Crypto.randomUUID()` if available, otherwise generates a random UUID using\n     * `Crypto.getRandomValues()`.\n     *\n     * @returns {String}\n     */\n    static generateUUID() {\n        if (BrowserHelper.supportsRandomUUID) {\n            return globalThis.crypto.randomUUID();\n        }\n        // Node does not have crypto built in\n        if (globalThis.crypto?.getRandomValues) {\n            // https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid\n            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n                (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n            );\n        }\n        // Node specific code, should never get here outside of node. Not actually a UUID, but should still be unique\n        // enough for our purposes, as long as value is not serialized\n        return `${Date.now()}-${++StringHelper.fakeNodeUUIDIndex}`;\n    }\n    //endregion\n}\nStringHelper.initHtmlEntities();\nStringHelper._$name = 'StringHelper';", "// IMPORTANT - adding imports here can create problems for Base class\n//  That is why this file was split from ObjectHelper\nimport StringHelper from '../StringHelper.js';\n/**\n * @module Core/helper/util/Objects\n */\nconst\n    { hasOwnProperty, toString } = Object.prototype,\n    { isFrozen } = Object,\n    afterRe      = /\\s*<\\s*/,\n    beforeRe     = /\\s*>\\s*/,\n    blendOptions = {},\n    typeCache    = {},\n    emptyObject  = Object.freeze({});\n// Static methods are not displayed in derived class documentation. Therefore, since this is an internal class, the\n// workaround is to copy method documentation to ObjectHelper (the public interface). Also tried making ObjectHelper\n// a singleton.\n/**\n * Helper for low-level Object manipulation.\n *\n * While documented on {@link Core.helper.ObjectHelper}, the following static methods are implemented by this class:\n *\n * - `{@link Core.helper.ObjectHelper#function-assign-static}`\n * - `{@link Core.helper.ObjectHelper#function-assignIf-static}`\n * - `{@link Core.helper.ObjectHelper#function-clone-static}`\n * - `{@link Core.helper.ObjectHelper#function-createTruthyKeys-static}`\n * - `{@link Core.helper.ObjectHelper#function-getPath-static}`\n * - `{@link Core.helper.ObjectHelper#function-getTruthyKeys-static}`\n * - `{@link Core.helper.ObjectHelper#function-getTruthyValues-static}`\n * - `{@link Core.helper.ObjectHelper#function-isEmpty-static}`\n * - `{@link Core.helper.ObjectHelper#function-isObject-static}`\n * - `{@link Core.helper.ObjectHelper#function-merge-static}`\n * - `{@link Core.helper.ObjectHelper#function-setPath-static}`\n * - `{@link Core.helper.ObjectHelper#function-typeOf-static}`\n * @internal\n */\nexport default class Objects {\n    static assign(dest, ...sources) {\n        for (let source, key, i = 0; i < sources.length; i++) {\n            source = sources[i];\n            if (source) {\n                for (key in source) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n        return dest;\n    }\n    static assignIf(dest, ...sources) {\n        for (let source, key, i = 0; i < sources.length; i++) {\n            source = sources[i];\n            if (source) {\n                for (key in source) {\n                    if (!(key in dest) || dest[key] === undefined) {\n                        dest[key] = source[key];\n                    }\n                }\n            }\n        }\n        return dest;\n    }\n    static blend(dest, source, options) {\n        options = options || blendOptions;\n        dest = dest || {};\n        const { clone = Objects.clone, merge = Objects.blend } = options;\n        if (Array.isArray(source)) {\n            if (source.length > 1) {\n                source.forEach(s => {\n                    dest = Objects.blend(dest, s, options);\n                });\n                return dest;\n            }\n            source = source[0];\n        }\n        if (source) {\n            let destValue, key, value;\n            for (key in source) {\n                value = source[key];\n                if (value && Objects.isObject(value)) {\n                    destValue = dest[key];\n                    options.key = key;\n                    if (destValue && Objects.isObject(destValue)) {\n                        if (isFrozen(destValue)) {\n                            dest[key] = destValue = clone(destValue, options);\n                        }\n                        value = merge(destValue, value, options);\n                    }\n                    else {\n                        // We don't need to clone frozen objects, but we do clone mutable objects as they get\n                        // applied to the dest.\n                        value = isFrozen(value) ? value : clone(value, options);\n                    }\n                }\n                dest[key] = value;\n            }\n        }\n        return dest;\n    }\n    static clone(value, handler) {\n        let cloned = value,\n            key;\n        if (value && typeof value === 'object') {\n            const options = handler && typeof handler === 'object' && handler;\n            if (options) {\n                // When using blend(), the 2nd argument is the options object, so ignore that case\n                handler = null;\n            }\n            if (Objects.isObject(value)) {\n                // When using DomSync, DomConfigs are usually recreated from scratch on each sync, we allow opting out\n                // of cloning them (costly for many elements)\n                if (value.skipClone) {\n                    cloned = value;\n                }\n                else {\n                    cloned = {};\n                    for (key in value) {\n                        cloned[key] = Objects.clone(value[key]);\n                    }\n                }\n            }\n            else if (Array.isArray(value)) {\n                cloned = [];\n                // Loop backwards to:\n                //  1. read source.length once\n                //  2. get result array sized on first pass (avoid growing)\n                for (key = value.length; key-- > 0; /* empty */) {\n                    cloned[key] = Objects.clone(value[key]);\n                }\n            }\n            else if (Objects.isDate(value)) {\n                cloned = new Date(value.getTime());\n            }\n            else if (handler) {\n                // Allow other types to be handled (e.g., DOM nodes).\n                cloned = handler(value);\n            }\n        }\n        return cloned;\n    }\n    static createTruthyKeys(source) {\n        const\n            keys = StringHelper.split(source),\n            result = keys && {};\n        if (keys) {\n            for (const key of keys) {\n                // StringHelper.split won't return empty keys if passed a string, but we\n                // could have been passed a String[]\n                if (key) {\n                    result[key] = true;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns value for a given path in the object\n     * @param {Object} object Object to check path on\n     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'\n     * @returns {*} Value associated with passed key\n     */\n    static getPath(object, path) {\n        return path.split('.').reduce((result, key) => {\n            return (result || emptyObject)[key];\n        }, object);\n    }\n    /**\n     * Returns value for a given path in the object, placing a passed default value in at the\n     * leaf property and filling in undefined properties all the way down.\n     * @param {Object} object Object to get path value for.\n     * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',\n     * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].\n     * @param {*} [defaultValue] Optionally the value to put in as the `someKey` property.\n     * @returns {*} Value at the leaf position of the path.\n     */\n    static getPathDefault(object, path, defaultValue) {\n        const\n            keys   = Array.isArray(path) ? path : typeof path === 'string' ? path.split('.') : [path],\n            length = keys.length - 1;\n        return keys.reduce((result, key, index) => {\n            if (defaultValue && !(key in result)) {\n                // Can't use emptyObject here, we are creating a node in the object tree\n                result[key] = index === length ? defaultValue : {};\n            }\n            return (result || emptyObject)[key];\n        }, object);\n    }\n    /**\n     * Determines if the specified path exists\n     * @param {Object} object Object to check path on\n     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'\n     * @returns {Boolean}\n     */\n    static hasPath(object, path) {\n        return path.split('.').every(key => {\n            if (key in object) {\n                object = object[key];\n                return true;\n            }\n            return false;\n        });\n    }\n    static getTruthyKeys(source) {\n        const keys = [];\n        for (const key in source) {\n            if (source[key]) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    }\n    static getTruthyValues(source) {\n        const values = [];\n        for (const key in source) {\n            if (source[key]) {\n                values.push(source[key]);\n            }\n        }\n        return values;\n    }\n    static isClass(object) {\n        if (typeof object === 'function' && object.prototype?.constructor === object) {\n            return true;\n        }\n        return false;\n    }\n    static isDate(object) {\n        // A couple quick rejections but only sure way is typeOf:\n        return Boolean(object?.getUTCDate) && Objects.typeOf(object) === 'date';\n    }\n    /**\n     * Check if passed object is a Promise or contains `then` method.\n     * Used to fix problems with detecting promises in code with `instance of Promise` when\n     * Promise class is replaced with any other implementation like `ZoneAwarePromise` in Angular.\n     * Related to these issues:\n     * https://github.com/bryntum/support/issues/791\n     * https://github.com/bryntum/support/issues/2990\n     *\n     * @param {Object} object object to check\n     * @returns {Boolean} truthy value if object is a Promise\n     * @internal\n     */\n    static isPromise(object) {\n        if (Promise && Promise.resolve) {\n            return Promise.resolve(object) === object || typeof object?.then === 'function';\n        }\n        throw new Error('Promise not supported in your environment');\n    }\n    static isEmpty(object) {\n        if (object && typeof object === 'object') {\n            // noinspection LoopStatementThatDoesntLoopJS\n            for (const p in object) { // eslint-disable-line no-unused-vars,no-unreachable-loop\n                return false;\n            }\n        }\n        return true;\n    }\n    static isObject(value) {\n        const C = value?.constructor;\n        return Boolean(C\n            // Most things have a .constructor property\n            ? (\n                // An in-frame instance of Object\n                C === Object ||\n                // Detect cross-frame objects, but exclude instance of custom classes named Object. typeOf(value) is\n                // \"object\" even for instances of a class and typeOf(C) is \"function\" for all constructors. We'll have\n                // to settle for relying on the fact that getPrototypeOf(Object.prototype) === null.\n                // NOTE: this issue does come up in Scheduler unit tests at least.\n                (C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype))\n            )\n            // Since all classes have a constructor property, an object w/o one is likely from Object.create(null). Of\n            // course, primitive types do not have \".constructor\"\n            : (value && typeof value === 'object')\n        );\n    }\n    static isInstantiated(object) {\n        return object ? typeof object === 'object' && !Objects.isObject(object) : false;\n    }\n    static merge(dest, ...sources) {\n        return Objects.blend(dest, sources);\n    }\n    /**\n     * Merges two \"items\" objects. An items object is a simple object whose keys act as identifiers and whose values\n     * are \"item\" objects. An item can be any object type. This method is used to merge such objects while maintaining\n     * their property order. Special key syntax is used to allow a source object to insert a key before or after a key\n     * in the `dest` object.\n     *\n     * For example:\n     * ```javascript\n     *  let dest = {\n     *      foo : {},\n     *      bar : {},\n     *      fiz : {}\n     *  }\n     *\n     *  console.log(Object.keys(dest));\n     *  > [\"foo\", \"bar\", \"fiz\"]\n     *\n     *  dest = mergeItems(dest, {\n     *      'zip > bar' : {}    // insert \"zip\" before \"bar\"\n     *      'bar < zap' : {}    // insert \"zap\" after \"bar\"\n     *  });\n     *\n     *  console.log(Object.keys(dest));\n     *  > [\"foo\", \"zip\", \"bar\", \"zap\", \"fiz\"]\n     * ```\n     *\n     * @param {Object} dest The destination object.\n     * @param {Object|Object[]} src The source object or array of source objects to merge into `dest`.\n     * @param {Object} [options] The function to use to merge items.\n     * @param {Function} [options.merge] The function to use to merge items.\n     * @returns {Object} The merged object. This will be the `dest` object.\n     * @internal\n     */\n    static mergeItems(dest, src, options) {\n        options = options || blendOptions;\n        let anchor, delta, index, indexMap, key, shuffle, srcVal;\n        const { merge = Objects.blend } = options;\n        dest = dest || {};\n        if (Array.isArray(src)) {\n            src.forEach(s => {\n                dest = Objects.mergeItems(dest, s, options);\n            });\n        }\n        else if (src) {\n            // https://2ality.com/2015/10/property-traversal-order-es6.html\n            // Bottom line: Object keys are iterated in declared/insertion order... unless the key is an integer or\n            // Symbol, but we don't care about those generally.\n            for (key in src) {\n                srcVal = src[key];\n                anchor = null;\n                // Allow a key to be added before or after another:\n                //\n                //  {\n                //      'foo > bar' : {\n                //          ...\n                //      },\n                //      'bar < derp' : {\n                //          ...\n                //      }\n                //  }\n                //\n                // The goal above is to add a 'foo' key before the existing 'bar' key while adding a 'derp' key after\n                // 'bar'.\n                if (key.includes('>')) {\n                    [key, anchor] = key.split(beforeRe);\n                    delta = 0;\n                }\n                else if (key.includes('<')) {\n                    [anchor, key] = key.split(afterRe);\n                    delta = 1;\n                }\n                if (key in dest) {\n                    // Changing the value of a key does not change its iteration order. Since \"key in dest\" we can do\n                    // what we need directly.\n                    if (srcVal && dest[key] && merge) {\n                        options.key = key;\n                        srcVal = merge(dest[key], srcVal, options);\n                    }\n                    dest[key] = srcVal;\n                }\n                else if (!anchor) {\n                    dest[key] = srcVal;\n                    indexMap?.set(key, indexMap.size);\n                }\n                else {\n                    // Lazily sprout the item index map. When we first merge an item into an items object, we create this\n                    // Map to control the ordering. This is because any keys we add would necessarily be iterated after\n                    // the original properties.\n                    if (!indexMap) {\n                        indexMap = new Map();\n                        index = 0;\n                        for (const k in dest) {\n                            indexMap.set(k, index++);\n                        }\n                    }\n                    index = indexMap.get(anchor);\n                    dest[key] = srcVal;\n                    if (index == null && delta) {\n                        index = indexMap.size;\n                    }\n                    else {\n                        shuffle = shuffle || [];\n                        index = (index || 0) + delta;\n                        // Adjust all key indices >= index up by 1 to maintain integer indices (required by the above\n                        // use case).\n                        for (const item of indexMap) {\n                            const [k, v] = item;\n                            if (index <= v) {\n                                /*\n                                Consider object w/the following order:\n                                    {\n                                        foo : {}',\n                                        bar : {},\n                                        baz : {},\n                                        zip : {},\n                                        goo : {},\n                                        fiz : {}\n                                    }\n                                The indexMap is:\n                                    foo : 0\n                                    bar : 1\n                                    baz : 2\n                                    zip : 3\n                                    goo : 4\n                                    fiz : 5\n                                To insert before goo, we populate shuffle thusly (to set up for popping):\n                                    +-----+-----+\n                                    | fiz | goo |\n                                    +-----+-----+\n                                      0        1\n                                      =6-5-1   =6-4-1\n                                */\n                                shuffle && (shuffle[indexMap.size - v - 1] = k);\n                                indexMap.set(k, v + 1);\n                            }\n                        }\n                        // Delete and re-add the keys that should follow the new key to establish the iteration order\n                        // we need:\n                        if (shuffle) {\n                            while (shuffle.length) {\n                                const\n                                    k = shuffle.pop(),\n                                    v = dest[k];\n                                delete dest[k];\n                                dest[k] = v;\n                            }\n                        }\n                    }\n                    indexMap.set(key, index);\n                }\n            }\n        }\n        return dest;\n    }\n    /**\n     * Sets value for a given path in the object\n     * @param {Object} object Target object\n     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'\n     * @param {*} value Value for a given path\n     * @returns {Object} Returns passed object\n     */\n    static setPath(object, path, value) {\n        path.split('.').reduce((result, key, index, array) => {\n            const isLast = index === array.length - 1;\n            if (isLast) {\n                return result[key] = value;\n            }\n            else if (!(result[key] instanceof Object)) {\n                result[key] = {};\n            }\n            return result[key];\n        }, object);\n        return object;\n    }\n    static typeOf(value) {\n        let trueType, type;\n        if (value === null) {\n            type = 'null';\n        }\n        // NaN is the only value that is !== to itself\n        else if (value !== value) { // eslint-disable-line no-self-compare\n            type = 'nan';\n        }\n        else {\n            type = typeof value;\n            if (type === 'object') {\n                if (value.isBase) {\n                    type = 'instance';\n                }\n                else if (Array.isArray(value)) {\n                    type = 'array';\n                }\n                else if (!(type = typeCache[trueType = toString.call(value)])) {\n                    typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();  // '[object Date]' => 'date'\n                }\n            }\n            else if (type === 'function' && value.isBase) {\n                type = 'class';\n            }\n        }\n        return type;\n    }\n}\nObject.defineProperty(Objects, 'hasOwn', {\n    // When available, this avoids an extra layer of function call around it:\n    value : Object.hasOwn || ((object, property) => hasOwnProperty.call(object, property))\n});\nObjects._$name = 'Objects';", "import BrowserHelper from './BrowserHelper.js';\nimport StringHelper from './StringHelper.js';\n/**\n * @module Core/helper/VersionHelper\n */\n/**\n * Helper for version handling\n * @private\n * @example\n *\n * VersionHelper.setVersion('grid', '1.5');\n *\n * if (VersionHelper.getVersion('grid').isNewerThan('1.0')) {\n *   ...\n * }\n */\nexport default class VersionHelper {\n    /**\n     * Set version for specified product\n     * @private\n     * @param {String} product\n     * @param {String} version\n     */\n    static setVersion(product, version) {\n        product = product.toLowerCase();\n        VH[product] = {\n            version,\n            isNewerThan(otherVersion) {\n                return VersionHelper.semanticCompareVersion(otherVersion, version, '<');\n            },\n            isOlderThan(otherVersion) {\n                return VersionHelper.semanticCompareVersion(otherVersion, version, '>');\n            }\n        };\n        let bundleFor = '';\n        // Var productName is only defined in bundles, it is internal to bundle so not available on window. Used to\n        // tell importing combinations of grid/scheduler/gantt bundles apart from loading same bundle twice\n        if (typeof productName !== 'undefined') {\n            // eslint-disable-next-line no-undef\n            bundleFor = productName;\n        }\n        // Set \"global\" flag to detect bundle being loaded twice\n        const globalKey = `${bundleFor}.${product}${version.replace(/\\./g, '-')}`;\n        if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {\n            if (globalThis.bryntum[globalKey] === true) {\n                if (this.isTestEnv) {\n                    globalThis.BUNDLE_EXCEPTION = true;\n                }\n                else {\n                    let errorProduct = bundleFor || product;\n                    if (errorProduct === 'core') {\n                        errorProduct = 'grid';\n                    }\n                    let capitalized  = StringHelper.capitalize(errorProduct);\n                    if (errorProduct === 'schedulerpro') {\n                        capitalized = 'SchedulerPro';\n                    }\n                    throw new Error(\n                        `The Bryntum ${capitalized} bundle was loaded multiple times by the application.\\n\\n` +\n                        `Common reasons you are getting this error includes:\\n\\n` +\n                        `* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)\\n` +\n                        `* Imports point to both sources and bundle\\n` +\n                        `* Imports do not use the shortest relative path, JS treats them as different files\\n` +\n                        `* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files\\n` +\n                        `* Imports missing file type, verify they all end in .js\\n\\n` +\n                        `See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information\\n\\n`\n                    );\n                }\n            }\n            else {\n                globalThis.bryntum[globalKey] = true;\n            }\n        }\n    }\n    /**\n     * Get (previously set) version for specified product\n     * @private\n     * @param {String} product\n     */\n    static getVersion(product) {\n        product = product.toLowerCase();\n        if (!VH[product]) {\n            throw new Error('No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.');\n        }\n        return VH[product].version;\n    }\n    /**\n     * Checks the version1 against the passed version2 using the comparison operator.\n     * Supports `rc`, `beta`, `alpha` release states. Eg. `1.2.3-alpha-1`.\n     * State which is not listed above means some version below `alpha`.\n     * @param {String} version1 The version to test against\n     * @param {String} version2 The version to test against\n     * @param {String} [comparison] The comparison operator, `<=`, `<`, `=`, `>` or `>=`.\n     * @returns {Boolean} `true` if the test passes.\n     * @internal\n     */\n    static semanticCompareVersion(version1, version2, comparison = '=') {\n        version1 = version1 || '';\n        version2 = version2 || '';\n        const\n            version1Arr  = version1.split(/[-.]/),\n            version2Arr  = version2.split(/[-.]/),\n            isLower      = comparison.includes('<'),\n            normalizeArr = (arr, maxLength) => {\n                const\n                    states = ['rc', 'beta', 'alpha'],\n                    result = arr.map(v => {\n                        if (states.includes(v)) {\n                            return -states.indexOf(v) - 2;\n                        }\n                        const res = Number.parseInt(v);\n                        return Number.isNaN(res) ? -states.length : res;\n                    });\n                while (result.length < maxLength) {\n                    result.push(-1);\n                }\n                return result;\n            },\n            compareArr   = () => {\n                const\n                    maxLength = Math.max(version1Arr.length, version2Arr.length),\n                    arr1      = normalizeArr(version1Arr, maxLength),\n                    arr2      = normalizeArr(version2Arr, maxLength);\n                for (let i = 0; i < maxLength; i++) {\n                    if (arr1[i] !== arr2[i]) {\n                        return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];\n                    }\n                }\n                return true;\n            };\n        switch (comparison) {\n            case '=':\n                return version1 === version2;\n            case '<=':\n            case '>=':\n                return (version1 === version2) || compareArr();\n            case '<':\n            case '>':\n                return (version1 !== version2) && compareArr();\n        }\n        return false;\n    }\n    /**\n     * Checks the passed product against the passed version using the passed test.\n     * @param {String} product The name of the product to test the version of\n     * @param {String} version The version to test against\n     * @param {String} operator The test operator, `<=`, `<`, `=`, `>` or `>=`.\n     * @returns {Boolean} `true` if the test passes.\n     * @internal\n     */\n    static checkVersion(product, version, operator) {\n        return VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);\n    }\n    /**\n     * Based on a comparison of current product version and the passed version this method either outputs a console.warn\n     * or throws an error.\n     * @param {String} product The name of the product\n     * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer\n     * is actually removed).\n     * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.\n     * @internal\n     */\n    static deprecate(product, invalidAsOfVersion, message) {\n        const justWarn = VH.checkVersion(product, invalidAsOfVersion, '<');\n        if (justWarn) {\n            // During the grace period (until the next major release following the deprecated code), just show a console warning\n            console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);\n        }\n        else {\n            throw new Error(`Deprecated API use. ${message}`);\n        }\n    }\n    /**\n     * Returns truthy value if environment is in testing mode\n     * @returns {Boolean}\n     * @internal\n     **/\n    static get isTestEnv() {\n        const isTestEnv = Boolean(globalThis.bryntum?.isTestEnv);\n        try {\n            return isTestEnv || Boolean(globalThis.parent?.bryntum?.isTestEnv);\n        }\n        catch (e) {\n            // Accessing parent may cause CORS violation\n            return isTestEnv;\n        }\n    }\n    static get isDebug() {\n        let result = false;\n        return result;\n    }\n}\nconst VH = VersionHelper;\nif (BrowserHelper.isBrowserEnv) {\n    if (VH.isTestEnv) {\n        BrowserHelper._isHoverableDevice = true;\n    }\n    globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {\n        getVersion   : VH.getVersion.bind(VH),\n        checkVersion : VH.checkVersion.bind(VH),\n        deprecate    : VH.deprecate.bind(VH),\n        license      : '%LICENSE%'\n    });\n}\nVersionHelper._$name = 'VersionHelper';", "import Objects from './helper/util/Objects.js';\n// We cannot import ObjectHelper because of the import cycle:\n//  ObjectHelper -> DateHelper -> LocaleManager -> Base -> us\n/**\n * @module Core/Config\n */\nconst\n    { defineProperty, getOwnPropertyDescriptor } = Reflect,\n    { hasOwnProperty, toString } = Object.prototype,\n    instancePropertiesSymbol     = Symbol('instanceProperties'),\n    configuringSymbol            = Symbol('configuring'),\n    lazyConfigValues             = Symbol('lazyConfigValues'),\n    DATE_TYPE                    = toString.call(new Date()),\n    whitespace                   = /\\s+/,\n    createClsProps               = (result, cls) => {\n        result[cls] = 1;\n        return result;\n    };\n/**\n * This class holds the description of a config property. Only one instance of this class is needed for each config\n * name (e.g., \"text\"). If config options are supplied, however, they also contribute to the cached instance.\n *\n * Instances should always be retrieved by calling `Config.get()`.\n *\n * The **Configs** of this class correspond to `options` that can be supplied to the `get()` method. These affect the\n * behavior of the config property in some way, as descried by their respective documentation.\n *\n * This class is not used directly.\n *\n * ## The Setter\n * The primary functionality provided by `Config` is its standard setter. This setter function ensures consistent\n * behavior when modifying config properties.\n *\n * The standard setter algorithm is as follows (using the `'text'` config for illustration):\n *\n *  - If the class defines a `changeText()` method, call it passing the new value and the current value:\n *    `changeText(newText, oldText)`.<br>\n *    Then:\n *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing further. The\n *      assumption is that the changer method has done all that is required.\n *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.\n *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:\n *    * Update the stored config value in `this._text`.\n *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.\n *      `updateText(newText, oldText)`\n *    * If the class defines an `onConfigChange()` method, call it passing an object with the following properties:\n *        - `name` - The config's name\n *        - `value` - The new value\n *        - `was` - The previous value\n *        - `config` - The `Config` instance.\n *\n * NOTE: unlike `changeText()` and `updateText()`, the name of the `onConfigChange()` method is unaffected by the\n * config's name.\n *\n * @internal\n */\nexport default class Config {\n    /**\n     * Returns the `Config` instance for the given `name` and `options`.\n     * @param {String} name The name of the config (e.g., 'text' for the text config).\n     * @param {Object} [options] Config behavior options.\n     * @returns {Core.Config}\n     * @internal\n     */\n    static get(name, options) {\n        const\n            { cache } = this,\n            baseCfg = cache[name] || (cache[name] = new Config(name));\n        let cfg = baseCfg,\n            key;\n        if (options) {\n            key = Config.makeCacheKey(name, options);\n            if (!(cfg = key && cache[key])) {\n                cfg = baseCfg.extend(options);\n                if (key) {\n                    cache[key] = cfg;\n                }\n            }\n        }\n        return cfg;\n    }\n    constructor(name) {\n        const\n            me = this,\n            cap = name[0].toUpperCase() + name.substr(1);\n        me.base = me;  // so extend()ed configs have a link to the base definition\n        me.name = name;\n        me.field = '_' + name;\n        me.capName = cap;\n        me.changer = 'change' + cap;\n        me.initializing = 'initializing' + cap;\n        me.updater = 'update' + cap;\n    }\n    /**\n     * The descriptor to use with `Reflect.defineProperty()` for defining this config's getter and setter.\n     * @property {Object}\n     * @private\n     */\n    get descriptor() {\n        let descriptor = this._descriptor;\n        if (!descriptor || !hasOwnProperty.call(this, '_descriptor')) {\n            // lazily make the descriptor\n            this._descriptor = descriptor = this.makeDescriptor();\n        }\n        return descriptor;\n    }\n    /**\n     * The descriptor to use with `Reflect.defineProperty()` for defining this config's initter.\n     * @property {Object}\n     * @private\n     */\n    get initDescriptor() {\n        let descriptor = this._initDescriptor;\n        if (!descriptor || !hasOwnProperty.call(this, '_initDescriptor')) {\n            // lazily make the descriptor\n            this._initDescriptor = descriptor = this.makeInitter();\n        }\n        return descriptor;\n    }\n    /**\n     * This method compares two values for semantic equality. By default, this is based on the `===` operator. This\n     * is often overridden for configs that accept `Date` or array values.\n     * @param {*} value1\n     * @param {*} value2\n     * @returns {Boolean}\n     * @internal\n     */\n    equal(value1, value2) {\n        return value1 === value2;\n    }\n    /**\n     * Extends this config with a given additional set of options. These objects are just prototype extensions of this\n     * instance.\n     * @param {Object} options\n     * @returns {Core.Config}\n     * @internal\n     */\n    extend(options) {\n        const\n            cfg = Object.assign(Object.create(this), options),\n            { equal, merge } = options,\n            { equalityMethods } = Config;\n        if (typeof equal === 'string') {\n            if (equal.endsWith('[]')) {\n                cfg.equal = Config.makeArrayEquals(equalityMethods[equal.substr(0, equal.length - 2)]);\n            }\n            else {\n                cfg.equal = equalityMethods[equal];\n            }\n        }\n        if (typeof merge === 'string') {\n            // Base uses { merge : 'replace' } for defaultConfig properties\n            cfg.merge = Config.mergeMethods[merge];\n        }\n        return cfg;\n    }\n    /**\n     * Defines the property on a given target object via `Reflect.defineProperty()`. If the object has its own getter,\n     * it will be preserved. It is invalid to define a setter.\n     * @param {Object} target\n     * @internal\n     */\n    define(target) {\n        const existing = getOwnPropertyDescriptor(target, this.name);\n        let descriptor = this.descriptor;\n        if (existing && existing.get) {\n            descriptor = Object.assign({}, descriptor);\n            descriptor.get = existing.get;\n        }\n        defineProperty(target, this.name, descriptor);\n    }\n    /**\n     * Defines the property initter on the `target`. This is a property getter/setter that propagates the configured\n     * value when the property is read.\n     * @param {Object} target\n     * @param {*} value\n     * @internal\n     */\n    defineInitter(target, value) {\n        const\n            { name } = this,\n            properties = target[instancePropertiesSymbol];\n        let lazyValues, prop;\n        // If there is an existing property with a getter/setter, *not* a value\n        // defined on the object for this config we must call it in our injected getter/setter.\n        if (!properties[name] && (/* assign */prop = getOwnPropertyDescriptor(target, name)) && !('value' in prop)) {\n            properties[name] = prop;\n        }\n        // Set up a temporary instance property which will pull in the value from the initialConfig if the getter\n        // is called first.\n        defineProperty(target, name, this.initDescriptor);\n        if (this.lazy) {\n            lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = new Map());\n            lazyValues.set(name, value);\n        }\n    }\n    /**\n     * Returns an equality function for arrays of a base type, for example `'date'`.\n     * @param {Function} [fn] The function to use to compare array elements. By default, operator `===` is used.\n     * @returns {Function}\n     * @private\n     */\n    static makeArrayEquals(fn) {\n        return (value1, value2) => {\n            let i,\n                equal = value1 && value2 && value1.length === (i = value2.length);\n            if (equal && Array.isArray(value1) && Array.isArray(value2)) {\n                if (fn) {\n                    while (equal && i-- > 0) {\n                        equal = fn(value1[i], value2[i]);\n                    }\n                }\n                else {\n                    while (equal && i-- > 0) {\n                        equal = value1[i] === value2[i];\n                    }\n                }\n            }\n            else {\n                equal = fn ? fn(value1, value2) : (value1 === value2);\n            }\n            return equal;\n        };\n    }\n    /**\n     * Returns the key to use in the Config `cache`.\n     * @param {String} name The name of the config property.\n     * @param {Object} options The config property options.\n     * @returns {String}\n     * @private\n     */\n    static makeCacheKey(name, options) {\n        const keys = Object.keys(options).sort();\n        for (let key, type, value, i = keys.length; i-- > 0; /* empty */) {\n            value = options[key = keys[i]];\n            if (value == null && value === false) {\n                keys.splice(i, 1);\n            }\n            else {\n                type = typeof value;\n                if (type === 'function') {\n                    return null;\n                }\n                if (type === 'string') {\n                    keys[i] = `${key}:\"${value}\"`;\n                }\n                else if (type === 'number') {\n                    keys[i] = `${key}:${value}`;\n                }\n                // that leaves bool and object, but there are no (valid) config options that are objects... so ignore\n            }\n        }\n        return keys.length ? `${name}>${keys.join('|')}` : name;  // eg: 'text>render|merge:v => v|bar'\n    }\n    /**\n     * Creates and returns a property descriptor for this config suitable to be passed to `Reflect.defineProperty()`.\n     * @returns {Object}\n     * @private\n     */\n    makeDescriptor() {\n        const\n            config = this,\n            { base, field, changer, updater, name } = config;\n        if (base !== config && base.equal === config.equal) {\n            // At present only the equal option affects the setter, so all configs can share the\n            // descriptor of the base-most config definition unless their equality test fns differ.\n            return base.descriptor;\n        }\n        return {\n            get() {\n                // Allow folks like Widget.compose() to monitor getter calls\n                this.configObserver?.get(name, this);\n                return this[field];\n            },\n            set(value) {\n                const me = this;\n                let was = me[field],\n                    applied, newValue;\n                // Resolve values starting with 'up.' by traversing owners to find it\n                if (typeof value === 'string') {\n                    let resolvedValue = value;\n                    if (value.startsWith('up.')) {\n                        resolvedValue = me.owner?.resolveProperty(value.substr(3));\n                    }\n                    else if (value.startsWith('this.')) {\n                        resolvedValue = me.resolveProperty(value.substr(5));\n                    }\n                    if (resolvedValue !== undefined && typeof resolvedValue !== 'function') {\n                        value = resolvedValue;\n                    }\n                }\n                // If the \"changeTitle()\" fellow falls off the end, it must have changed all the needful things.\n                // Otherwise, it returned the final config value (it may have changed it instead, for example, making\n                // an instance from a config object).\n                if (me[changer]) {\n                    applied = (newValue = me[changer](value, was)) === undefined;\n                    if (!applied) {\n                        value = newValue;\n                        was = me[field];  // in case it was modified by the changer fn...\n                    }\n                }\n                // inline the default equal() for better perf:\n                if (!applied && !((config.equal === equal) ? was === value : config.equal(was, value))) {\n                    me[field] = value;\n                    applied = true;\n                    // Check for a \"updateTitle()\" method and call it if present.\n                    me[updater]?.(value, was);\n                }\n                // Trigger config change if the value changed, and updater did not lead to our destruction\n                if (applied && !me.isDestroyed && !me.onConfigChange.$nullFn) {\n                    me.onConfigChange({ name, value, was, config });\n                }\n            }\n        };\n    }\n    /**\n     * Creates and returns a property descriptor for this config's initter suitable to pass to\n     * `Reflect.defineProperty()`.\n     * @returns {Object}\n     * @private\n     */\n    makeInitter() {\n        const config = this;\n        if (config !== config.base) {\n            if (config.lazy) {\n                return config.makeLazyInitter();\n            }\n            // At present no other options affect the setter, so all configs can share the descriptor of the base-most\n            // config definition.\n            return config.base.initDescriptor;\n        }\n        return config.makeBasicInitter();\n    }\n    makeBasicInitter() {\n        const\n            config = this,\n            { initializing, name } = config;\n        return {\n            configurable : true,\n            get() {\n                const me = this;\n                config.removeInitter(me);\n                // Set the value from the configuration.\n                me[initializing] = true;\n                me[name] = me[configuringSymbol][name];\n                me[initializing] = false;\n                // The property has been *pulled* from the configuration.\n                // Prevent the setting loop in configure from setting it again.\n                me.configDone[name] = true;\n                // Finally, allow the prototype getter to return the value.\n                return me[name];\n            },\n            set(value) {\n                config.removeInitter(this);\n                // The config has been set (some internal code may have called the setter)\n                // so prevent it from being called again and overwritten with data from initialConfig.\n                this.configDone[name] = true;\n                // Set the property normally (Any prototype setter will be invoked)\n                this[name] = value;\n            }\n        };\n    }\n    makeLazyInitter() {\n        const\n            config = this,\n            { initializing, name } = config;\n        return {\n            configurable : true,\n            get() {\n                const\n                    me    = this,\n                    value = me[lazyConfigValues].get(name);\n                config.removeInitter(me);\n                if (!me.isDestroying) {\n                    // Set the value from the lazy config object.\n                    me[initializing] = true;\n                    me[name] = value;\n                    me[initializing] = false;\n                }\n                // Finally, allow the prototype getter to return the value.\n                return me[name];\n            },\n            set(value) {\n                config.removeInitter(this);\n                // Set the property normally (Any prototype setter will be invoked)\n                this[name] = value;\n            }\n        };\n    }\n    /**\n     * Removes the property initter and restores the instance to its original form.\n     * @param {Object} instance\n     * @private\n     */\n    removeInitter(instance) {\n        const\n            { name } = this,\n            instanceProperty = instance[instancePropertiesSymbol][name],\n            lazyValues = instance[lazyConfigValues];\n        // If we took over from an instance property, replace it\n        if (instanceProperty) {\n            defineProperty(instance, name, instanceProperty);\n        }\n        // Otherwise just delete the instance property who's getter we are in.\n        else {\n            delete instance[name];\n        }\n        if (lazyValues?.delete(name) && !lazyValues.size) {\n            // we delete the keys so that we can tell if this particular lazy config has been initialized\n            delete instance[lazyConfigValues];\n        }\n    }\n    setDefault(cls, value) {\n        defineProperty(cls.prototype, this.field, {\n            configurable : true,\n            writable     : true,   // or else \"this._value = x\" will fail\n            value\n        });\n    }\n    /**\n     * This method combines (merges) two config values. This is called in two cases:\n     *\n     *  - When a derived class specifies the value of a config defined in a super class.\n     *  - When a value is specified in the instance config object.\n     *\n     * @param {*} newValue In the case of derived classes, this is the config value of the derived class. In the case\n     * of the instance config, this is the instance config value.\n     * @param {*} currentValue In the case of derived classes, this is the config value of the super class. In the case\n     * of the instance config, this is the class config value.\n     * @param {Object} metaNew The class meta object from which the `newValue` is coming. This parameter is `null` if\n     * the `newValue` is from an instance configuration.\n     * @param {Object} metaCurrent The class meta object from which the `currentValue` is coming. This parameter is\n     * `null` if the `currentValue` is not from a class configuration.\n     * @returns {*}\n     * @internal\n     */\n    merge(newValue, currentValue) {\n        if (currentValue && newValue && Objects.isObject(newValue)) {\n            // If existing value is a class instance, clone and merge won't work. Set the configs.\n            if (currentValue.isBase) {\n                return currentValue.setConfig(newValue);\n            }\n            if (Objects.isObject(currentValue)) {\n                newValue = Objects.merge(Objects.clone(currentValue), newValue);\n            }\n        }\n        return newValue;\n    }\n}\nconst\n    { prototype } = Config,\n    { equal } = prototype;\nConfig.symbols = {\n    configuring        : configuringSymbol,\n    instanceProperties : instancePropertiesSymbol,\n    lazyConfigs        : lazyConfigValues\n};\n/**\n * This object holds `Config` instances keyed by their name. For example:\n *\n * ```javascript\n *  Config.cache = {\n *      disabled : Config.get('disabled'),\n *      text     : Config.get('text'),\n *      title    : Config.get('title')\n *  };\n * ```\n *\n * @member {Object} cache\n * @static\n * @private\n */\nConfig.cache = Object.create(null);  // object w/no properties not even inherited ones\n/**\n * This object holds config value equality methods. By default, the `===` operator is used to compare config values for\n * semantic equality. When an `equal` option is specified as a string, that string is used as a key into this object.\n *\n * All equality methods in this object have the same signature as the {@link #function-equal equal()} method.\n *\n * This object has the following equality methods:\n *\n * - `array` : Compares arrays of values using `===` on each element.\n * - `date` : Compares values of `Date` type.\n * - `strict` : The default equal algorithm based on `===` operator.\n * @member {Object} equalityMethods\n * @static\n * @private\n */\nConfig.equalityMethods = {\n    array : Config.makeArrayEquals(),\n    date(value1, value2) {\n        if (value1 === value2) {\n            return true;\n        }\n        // see DateHelper.isDate() but cannot import due to circularity\n        if (value1 && value2 && toString.call(value1) === DATE_TYPE && toString.call(value2) === DATE_TYPE) {\n            // https://jsbench.me/ltkb3vk0ji/1 - getTime is >2x faster vs valueOf/Number/op+\n            return value1.getTime() === value2.getTime();\n        }\n        return false;\n    },\n    strict : Config.equal = equal\n};\n/**\n * This object holds config value merge methods. By default, {@link Core.helper.ObjectHelper#function-merge-static} is\n * used to merge object's by their properties. Config merge methods are used to combine config values from derived\n * classes with config values from super classes, as well as instance config values with those of the class.\n *\n * All merge methods in this object have the same signature as the {@link #function-merge merge()} method.\n *\n * This object has the following merge methods:\n *\n * - `distinct`   : Combines arrays of values ensuring that no value is duplicated. When given an object, its truthy\n *   keys are included, while its falsy keys are removed from the result.\n * - `merge`      : The default merge algorithm for `configurable()` properties, based on\n *   {@link Core.helper.ObjectHelper#function-merge-static}.\n * - `items`      : Similar to `merge`, but allows reordering (see `Objects.mergeItems`).\n * - `objects`    : The same as to `merge` except this method promotes `true` to an empty object.\n * - 'classList'  : Incoming strings are converted to an object where the string is a property name with a truthy value.\n * - `replace`    : Always returns `newValue` to replace the super class value with the derived class value, or the\n *   class value with the instance value.\n * @member {Object} mergeMethods\n * @static\n * @internal\n */\nConfig.mergeMethods = {\n    distinct(newValue, oldValue) {\n        let ret = oldValue ? oldValue.slice() : [];\n        if (newValue != null) {\n            if (Objects.isObject(newValue)) {\n                if (oldValue === undefined) {\n                    ret = newValue;\n                }\n                else {\n                    let key, index;\n                    for (key in newValue) {\n                        index = ret.indexOf(key);\n                        if (newValue[key]) {\n                            if (index < 0) {\n                                ret.push(key);\n                            }\n                        }\n                        else if (index > -1) {\n                            ret.splice(index, 1);\n                        }\n                    }\n                }\n            }\n            else if (Array.isArray(newValue)) {\n                newValue.forEach(v => !ret.includes(v) && ret.push(v));\n            }\n            else if (!ret.includes(newValue)) {\n                ret.push(newValue);\n            }\n        }\n        return ret;\n    },\n    merge : Config.merge = prototype.merge,\n    classList(newValue, oldValue) {\n        // 'foo bar' -> { foo : 1, bar : 1 }\n        if (typeof newValue === 'string') {\n            if (!newValue.length) {\n                return oldValue;\n            }\n            newValue = newValue.split(whitespace);\n        }\n        if (Array.isArray(newValue)) {\n            newValue = newValue.reduce(createClsProps, {});\n        }\n        return Config.merge(newValue, oldValue);\n    },\n    objects(newValue, oldValue) {\n        return (newValue === true) ? oldValue || {} : Config.merge(newValue, oldValue);\n    },\n    replace(newValue) {\n        return newValue;\n    },\n    items(newValue, oldValue, metaNew, metaCurrent) {\n        if (metaCurrent) {\n            // When we have metaCurrent, we are merging with a class config object, so we apply the smart merge algo\n            // only in that case. Merging instance configs would lose the 'clever > syntax' info needed when the\n            // time comes to actually configure an instance.\n            return Objects.mergeItems(oldValue, newValue, {\n                merge : (oldValue, newValue) => prototype.merge(newValue, oldValue)\n            });\n        }\n        return prototype.merge(newValue, oldValue);\n    }\n};\nObject.assign(prototype, {\n    _descriptor     : null,\n    _initDescriptor : null,\n    /**\n     * A function that compares values for equality. This test is used to determine if the `update` method should be\n     * called when the setter is invoked.\n     *\n     * To handle `Date` values:\n     * ```\n     *  class Foo extends Base {\n     *      static get configurable() {\n     *          return {\n     *              date : {\n     *                  $config : {\n     *                      equal : 'date'\n     *                  },\n     *\n     *                  value : null\n     *              }\n     *          }\n     *      }\n     *\n     *      updateDate(date) {\n     *          // date has changed\n     *      }\n     *  }\n     * ```\n     *\n     * Also useful for some configs:\n     * ```\n     *  class Foo extends Base {\n     *      static get configurable() {\n     *          return {\n     *              bar : {\n     *                  $config : {\n     *                      equal : ObjectHelper.isEqual\n     *                  },\n     *\n     *                  value : null\n     *              }\n     *          }\n     *      }\n     *\n     *      updateBar(value) {\n     *          // value has changed\n     *      }\n     *  }\n     * ```\n     * @config {Function} equal\n     * @internal\n     */\n    /**\n     * Indicates that this config property should not automatically initialize during construction. When this property\n     * is set to `true`, initialization is triggered by the first use of the config property's getter.\n     *\n     * This property can alternatively be set to a string, in which case it can be initialized as a group using the\n     * {@link Core.Base#function-triggerConfigs} method which will initialize all lazy configs with the same value for\n     * this property. Note: the config will still initialize on first use if that occurs prior to the call to\n     * `triggerConfigs`.\n     * @config {Boolean|String}\n     * @default\n     * @internal\n     */\n    lazy : false,\n    /**\n     * Indicates that this config property should automatically be set to `null` on destroy.\n     * @config {Boolean}\n     * @default\n     * @internal\n     */\n    nullify : false,\n    /**\n     * Indicates that this config participates in rendering. This has does not affect the behavior of the property\n     * directly, but allows classes that perform rendering to detect which config changes will affect the rendered\n     * result.\n     * @config {Boolean}\n     * @default\n     * @internal\n     */\n    render : false\n});\nConfig._$name = 'Config';", "/**\n * @module Core/Base\n */\nimport Objects from './helper/util/Objects.js';\nimport StringHelper from './helper/StringHelper.js';\nimport VersionHelper from './helper/VersionHelper.js';\nimport BrowserHelper from './helper/BrowserHelper.js';\nimport Config from './Config.js';\nclass MetaClass {\n    constructor(options) {\n        options && Object.assign(this, options);\n    }\n    getInherited(name, create = true) {\n        let ret = this[name];\n        // We use \"in this\" to allow the object to be set to null\n        if (!(name in this)) {\n            // If there is no object on this metaclass, but there may be one on a super class. If create=false, the\n            // idea is that a super class object will be \"properly\" inherited but otherwise no object will be created.\n            ret = this.super?.getInherited(name, create);\n            if (ret || create) {\n                this[name] = ret = Object.create(ret || null);\n            }\n        }\n        return ret;\n    }\n}\nconst\n    // Using Object.getPrototypeOf instead of Reflect.getPrototypeOf because:\n    // 1. They are almost the same, according to the MDN difference is handling getPrototypeOf('string')\n    // 2. It allows us to pass security check in SalesForce environment\n    { getPrototypeOf }       = Object,\n    { hasOwn }               = Objects,\n    { defineProperty }       = Reflect,\n    metaSymbol               = Symbol('classMetaData'),\n    mixinTagSymbol           = Symbol('mixinTag'),\n    originalConfigSymbol     = Symbol('originalConfig'),\n    createdAtSymbol          = Symbol('createdAt'),\n    configuringSymbol        = Config.symbols.configuring,\n    instancePropertiesSymbol = Config.symbols.instanceProperties,\n    lazyConfigsSymbol        = Config.symbols.lazyConfigs,\n    defaultConfigOptions     = { merge : 'replace', simple : true },\n    emptyFn                  = () => {},\n    newMeta                  = o => new MetaClass(o),\n    setupNames               = { /* foo : 'setupFoo' */ },\n    emptyObject              = Object.freeze({}),\n    emptyArray               = Object.freeze([]);\n/**\n * Base class for all configurable classes.\n *\n * Subclasses do not have to implement a constructor with its restriction of having to call super()\n * before there is a `this` reference. Subclasses instead implement a `construct` method which is\n * called by the `Base` constructor. This may call its `super` implementation at any time.\n *\n * The `Base` constructor applies all configs to properties of the new instance. The instance\n * will have been configured after the `super.construct(config)` is called.\n *\n * See the Class System documentation in the guides for more information.\n *\n * @abstract\n */\nexport default class Base {\n    static get isBase() {\n        return true;\n    }\n    get isBase() {\n        return true;\n    }\n    // defaultConfig & properties made private to not spam all other classes\n    /**\n     * A class property getter to add additional, special class properties.\n     *\n     * For example, a class adds a `declarable` class property like so:\n     * ```\n     *  class Something extends Base {\n     *      static get declarable() {\n     *          return ['extra'];\n     *      }\n     *\n     *      static setupExtra(cls, meta) {\n     *          // use cls.extra\n     *      }\n     *  }\n     * ```\n     * A derived class can then specify this property like so:\n     * ```\n     *  class Derived extends Something {\n     *      static get extra() {\n     *          // return extra information\n     *      }\n     *  }\n     * ```\n     * When the `Derived` class is initialized, the `setupExtra()` method is called and `Derived` is passed as the\n     * argument. It is also the `this` pointer, but the parameter is minifiable. The second argument passed is the\n     * `$meta` object for the class.\n     *\n     * Classes are initialized at the first occurrence of the following:\n     *\n     * - An instance is created\n     * - The class `$meta` property is accessed\n     *\n     * @member {String[]} declarable\n     * @static\n     * @category Configuration\n     * @internal\n     */\n    static get declarable() {\n        return [\n            'declarable',\n            /**\n             * A class property getter for the configuration properties of the class, which can be overridden by\n             * configurations passed at construction time.\n             *\n             * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,\n             * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs\n             * individually and then combine them with those of derived classes.\n             *\n             * For example, a `Label` might declare a `text` config like so:\n             * ```javascript\n             *  class Label extends Base {\n             *      static get configurable() {\n             *          return {\n             *              text : null\n             *          };\n             *      }\n             *  }\n             * ```\n             * The `text` config is automatically inherited by classes derived from Label. By implementing\n             * `get configurable()`, derived classes can change the default value of inherited configs, or define new\n             * configs, or both.\n             *\n             * When a config property is declared in this way, the class author can also implement either of two\n             * special methods that will be called when the config property is assigned a new value:\n             *\n             *  - `changeText()`\n             *  - `updateText()`\n             *\n             * In the example above, the `Label` class could implement a `changeText()` method, an `updateText()`\n             * method, or both. The generated property setter ensures these methods will be called when the `text`\n             * property is assigned.\n             *\n             * The generated setter (for `text` in this example) performs the following steps:\n             *\n             *  - If the class defines a `changeText()` method, call it passing the new value and the current value:\n             *    `changeText(newText, oldText)`.<br>\n             *    Then:\n             *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing\n             *      further. The assumption is that the changer method has done all that is required.\n             *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.\n             *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:\n             *    * Update the stored config value in `this._text`.\n             *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.\n             *      `updateText(newText, oldText)`\n             *\n             * #### Resolving a value from an owner\n             * By specifying a value starting with `'up.'` for a config, the config system will resolve that value by\n             * examining the ownership hierarchy. It will walk up the hierarchy looking for a property matching the name\n             * (or dot separated path) after 'up.'. If one is found, the value will be read and used as the initial\n             * value.\n             *\n             * ```javascript\n             * class Parent extends Base {\n             *     static get configurable() {\n             *         return [\n             *           'importantValue'\n             *         ]\n             *     }\n             * }\n             *\n             * class Child extends Base {\n             *     static get configurable() {\n             *         return [\n             *           'value'\n             *         ]\n             *     }\n             * }\n             *\n             * const parent = new Parent({\n             *     importantValue : 123\n             * });\n             *\n             * const child = new Child({\n             *     owner : parent,\n             *     // Will be resolved from the owner\n             *     value : 'up.importantValue'\n             * });\n             *\n             * console.log(child.value); // logs 123\n             * ```\n             * Please note that this is for now a one way one time binding, the value will only be read initially and\n             * not kept up to date on later changes.\n             *\n             * #### Value Merging\n             * When a config property value is an object, the value declared by the base class is merged with values\n             * declared by derived classes and the value passed to the constructor.\n             * ```javascript\n             *  class Example extends Base {\n             *      static get configurable() {\n             *          return {\n             *              config : {\n             *                  foo : 1,\n             *                  bar : 2\n             *              }\n             *          };\n             *      }\n             *  }\n             *\n             *  class Example2 extends Example {\n             *      static get configurable() {\n             *          return {\n             *              config : {\n             *                  bar : 42,\n             *                  zip : 'abc'\n             *              }\n             *          };\n             *      }\n             *  }\n             *\n             *  let ex = new Example2({\n             *      config : {\n             *          zip : 'xyz'\n             *      }\n             *  });\n             * ```\n             * The result of the merge would set `config` to:\n             * ```javascript\n             *  ex.foo = {\n             *      foo : 1,    // from Example\n             *      bar : 42,   // from Example2\n             *      zip : 'xyz' // from constructor\n             *  }\n             * ```\n             *\n             * #### Config Options\n             * Some config properties require additional options such as declarative information about the config that\n             * may be useful to automate some operation. Consider a `Button`. It could declare that its `text` config\n             * affects the rendered HTML by applying a `render` property to the config definition. Its base class could\n             * then examine the config definition to find this property.\n             *\n             * To support this, config options ca be declared like so:\n             * ```javascript\n             *  class Button extends Widget {\n             *      static get configurable() {\n             *          return {\n             *              text : {\n             *                  value   : null,\n             *                  $config : {\n             *                      render : true\n             *                  }\n             *              }\n             *          };\n             *      }\n             *  }\n             * ```\n             * The `$config` property can alternatively be just the names of the options that should be enabled (set\n             * to `true`).\n             *\n             * For example, the following is equivalent to the above:\n             * ```javascript\n             *  class Button extends Widget {\n             *      static get configurable() {\n             *          return {\n             *              text : {\n             *                  value   : null,\n             *                  $config : 'render'\n             *              }\n             *          };\n             *  }\n             * ```\n             *\n             * #### Default Value\n             * It is common to set a config to a `null` value to take advantage of internal optimizations for `null`\n             * values. In most cases the fact that this produces `undefined` as the actual initial value of the config\n             * is acceptable. When this is not acceptable, a config can be declared like so:\n             * ```javascript\n             *  class Widget {\n             *      static get configurable() {\n             *          return {\n             *              disabled : {\n             *                  $config : null,\n             *                  value   : null,\n             *                  default : false\n             *              }\n             *          };\n             *  }\n             * ```\n             * The `default` property above determines the value of the config while still gaining the benefits of\n             * minimal processing due to the `null` value of the `value` property.\n             * @member {Object} configurable\n             * @static\n             * @category Configuration\n             * @internal\n             */\n            'configurable',\n            /**\n             * A class property getter for the default configuration of the class, which can be overridden by\n             * configurations passed at construction time.\n             *\n             * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,\n             * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs\n             * individually and then combine them with those of derived classes.\n             *\n             * For example, a `Store` might declare its `url` config like so:\n             * ```\n             *  class Store extends Base {\n             *      static get defaultConfig() {\n             *          return {\n             *              url : null\n             *          };\n             *      }\n             *  }\n             * ```\n             * The `url` config is automatically inherited by classes derived from Store. By implementing\n             * `get defaultConfig()`, derived classes can change the default value of inherited configs, or define new\n             * configs, or both. When defining new configs, however, `configurable` is preferred.\n             *\n             * Config properties introduced to a class by this declaration do not participate in value merging and do\n             * not get a generated setter. Config properties introduced by a base class using `configurable` can be\n             * set to a different value using `defaultConfig` and in doing so, the values will be merged as appropriate\n             * for `configurable`.\n             *\n             * @member {Object} defaultConfig\n             * @static\n             * @category Configuration\n             * @internal\n             */\n            'defaultConfig',\n            /**\n             * A class property getter for the default values of internal properties for this class.\n             * @member {Object} properties\n             * @static\n             * @category Configuration\n             * @internal\n             */\n            'properties',\n            /**\n             * A class property getter for properties that will be applied to the class prototype.\n             * @member {Object} prototypeProperties\n             * @static\n             * @category Configuration\n             * @internal\n             */\n            'prototypeProperties'\n        ];\n    }\n    /**\n     * Base constructor, passes arguments to {@link #function-construct}.\n     * @param {...Object} [args] Usually called with a config object, but accepts any params\n     * @function constructor\n     * @category Lifecycle\n     */\n    constructor(...args) {\n        const\n            me = this,\n            C  = me.constructor;\n        if (me.$meta.class !== C) {\n            // This will happen only once for each class. We need to call the C.$meta getter which puts $meta on our\n            // prototype. Since that alone would be optimized away (and would generate IDE and lint warnings), we call\n            // emptyFn and simply pass the value.\n            emptyFn(C.$meta);\n        }\n        // Allow subclasses to have a pseudo constructor with \"this\" already set:\n        me.construct(...args);\n        me.afterConstruct();\n        me.isConstructing = false;\n    }\n    /**\n     * Factory version of the Base constructor. Merges all arguments to create a config object that is passed along to\n     * the constructor.\n     * @param {...Object} [configs] Allows passing multiple config objects\n     * @returns {Core.Base} New instance\n     * @private\n     */\n    static new(...configs) {\n        configs = configs.filter(c => c);\n        return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);\n    }\n    /**\n     * Base implementation applies configuration.\n     *\n     * Subclasses need only implement this if they have to initialize instance specific\n     * properties required by the class. Often a `construct` method is\n     * unnecessary. All initialization of incoming configuration properties can be\n     * done in a `set propName` implementation.\n     * @param {...Object} [args] Usually called with a config object, but accepts any params\n     * @category Lifecycle\n     */\n    construct(...args) {\n        // Passing null to base construct means bypass the config system and stack creation (to gain performance)\n        if (args[0] !== null) {\n            this.configure(...args);\n        }\n        this.afterConfigure();\n    }\n    /**\n     * Destroys the provided objects by calling their {@link #function-destroy} method.\n     * Skips empty values or objects that are already destroyed.\n     *\n     * ```javascript\n     * Base.destroy(myButton, toolbar1, helloWorldMessageBox);\n     * ```\n     * @param {...Object} [args] Objects to be destroyed\n     * @category Lifecycle\n     */\n    static destroy(...args) {\n        const shredder = object => {\n            if (object?.destroy) {\n                object.destroy();\n            }\n            else if (Array.isArray(object)) {\n                object.forEach(shredder);\n            }\n        };\n        shredder(args);\n    }\n    /**\n     * Destroys this object. This is primarily accomplished by calling {@link #function-doDestroy}, however, prior to\n     * calling `doDestroy`, {@link #property-isDestroying} is set to `true`. After {@link #function-doDestroy} returns,\n     * {@link #property-isDestroyed} is set to `true`.\n     *\n     * Do not override this method in subclasses. To provide class-specific cleanup, implement {@link #function-doDestroy}\n     * instead.\n     * @category Lifecycle\n     */\n    destroy() {\n        const\n            me = this,\n            { id } = me;\n        // Let everyone know the object is going inert:\n        me.isDestroying = true;\n        // Make calling destroy() harmless:\n        me.destroy = emptyFn;\n        me.doDestroy();\n        Object.setPrototypeOf(me, null);\n        // Clear all remaining instance properties.\n        for (const key in me) {\n            if (key !== 'destroy' && key !== 'isDestroying') {\n                delete me[key];\n            }\n        }\n        delete me[originalConfigSymbol];\n        // Let everyone know the object is inert:\n        me.isDestroyed = true;\n        me.id = id;  // for diagnostic reasons\n    }\n    /**\n     * This method is required to help `unused` getters to survive production build process. Some tools, like angular,\n     * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.\n     * @internal\n     * @param getter Getter to evaluate\n     */\n    _thisIsAUsedExpression(getter) {}\n    static get $$name() {\n        return hasOwn(this, '$name') && this.$name ||\n            // _$name is filled by webpack for every class (cls._$name = '...')\n            hasOwn(this, '_$name') && this._$name ||\n            this.name;\n    }\n    get $$name() {\n        return this.constructor.$$name;\n    }\n    /**\n     * Base implementation so that all subclasses and mixins may safely call super.startConfigure.\n     *\n     * This is called by the Base class before setting configuration properties, but after\n     * the active initial getters have been set, so all configurations are available.\n     *\n     * This method allows all classes in the hierarchy to force some configs to be evaluated before others.\n     * @internal\n     * @category Lifecycle\n     * @params {Object} config The configuration object use to set the initial state.\n     */\n    startConfigure(config) {\n    }\n    /**\n     * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.\n     *\n     * This is called by the Base class before exiting the {@link #function-configure} method.\n     *\n     * At this point, all configs have been applied, but the `isConfiguring` property is still set.\n     *\n     * This method allows all classes in the hierarchy to inject functionality\n     * into the config phase.\n     * @internal\n     * @category Lifecycle\n     * @params {Object} config The configuration object use to set the initial state.\n     */\n    finishConfigure(config) {\n    }\n    /**\n     * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been\n     * called. At this point, all configs have been applied.\n     *\n     * This method allows all classes in the hierarchy to inject functionality\n     * either before or after the super.afterConstruct();\n     * @internal\n     * @category Lifecycle\n     */\n    afterConfigure() {\n    }\n    /**\n     * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.\n     *\n     * This is called by the Base class after the {@link #function-construct} method has been\n     * called.\n     *\n     * At this point, all configs have been applied.\n     *\n     * This method allows all classes in the hierarchy to inject functionality\n     * either before or after the super.afterConstruct();\n     * @internal\n     * @function afterConstructor\n     * @category Lifecycle\n     */\n    afterConstruct() {\n    }\n    /**\n     * Provides a way of calling callbacks which may have been specified as the _name_ of a function\n     * and optionally adds scope resolution.\n     *\n     * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`\n     * then the function is resolved in this object. This is useful when configuring listeners\n     * at the class level.\n     *\n     * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried\n     * using the `owner` property until an object with the named function is present, then the\n     * named function is called upon that object.\n     *\n     * If a named function is not found, an error is thrown. If the function should be only called when present,\n     * and may not be present, add a `?` as a suffix.\n     *\n     * @param {String|Function} fn The function to call, or the name of the function to call.\n     * @param {Object} thisObject The `this` object of the function.\n     * @param {Object[]} args The argument list to pass.\n     * @category Misc\n     */\n    callback(fn, thisObject, args = emptyArray) { // Maintainer: do not make args ...args. This method may acquire more arguments\n        const { handler, thisObj } = this.resolveCallback(fn, thisObject === 'this' ? this : thisObject) || emptyObject;\n        return handler?.apply(thisObj, args);\n    }\n    resolveProperty(propertyPath) {\n        let thisObj = this;\n        while (thisObj) {\n            if (Objects.hasPath(thisObj, propertyPath)) {\n                return Objects.getPath(thisObj, propertyPath);\n            }\n            thisObj = thisObj.owner;\n        }\n        return undefined;\n    }\n    /**\n     * Provides a way of locating callbacks which may have been specified as the _name_ of a function\n     * and optionally adds scope resolution.\n     *\n     * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`\n     * then the function is resolved in this object. This is useful when configuring listeners\n     * at the class level.\n     *\n     * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried\n     * using the `owner` property until an object with the named function is present, then the\n     * named function is called upon that object.\n     * @param {String|Function} handler The function to call, or the name of the function to call.\n     * @param {Object} thisObj The `this` object of the function.\n     * @param {Boolean} [enforceCallability = true] Pass `false` if the function may not exist, and a null return value is acceptable.\n     * @returns {Object} `{ handler, thisObj }`\n     * @category Misc\n     */\n    resolveCallback(handler, thisObj = this, enforceCallability = true) {\n        // It's a string, we find it in its own thisObj\n        if (handler?.substring) {\n            if (handler.endsWith('?')) {\n                enforceCallability = false;\n                handler = handler.substring(0, handler.length - 1);\n            }\n            if (handler.startsWith('up.')) {\n                handler = handler.substring(3);\n                // Empty loop until we find the function owner\n                for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner);\n                if (!thisObj) {\n                    return;\n                }\n            }\n            else if (handler.startsWith('this.')) {\n                handler = handler.substring(5);\n                thisObj = this;\n            }\n            if (!thisObj || !(thisObj instanceof Object)) {\n                return;\n            }\n            handler = thisObj[handler];\n        }\n        // Any other type than string or function results in unresolved callback\n        if (typeof handler === 'function') {\n            return { handler, thisObj };\n        }\n        if (enforceCallability) {\n            throw new Error(`No method named ${handler} on ${thisObj.$$name || 'thisObj object'}`);\n        }\n    }\n    bindCallback(inHandler, inThisObj = this) {\n        if (inHandler) {\n            const { handler, thisObj } = this.resolveCallback(inHandler, inThisObj);\n            if (handler) {\n                return handler.bind(thisObj);\n            }\n        }\n    }\n    /**\n     * Delays the execution of the passed function by the passed time quantum, or if the time is omitted\n     * or not a number, delays until the next animation frame. Note that this will use\n     * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}\n     * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will\n     * be called using `this` object as its execution scope.\n     * @param {Function} fn The function to call on a delay.\n     * @param {Number} [delay] The number of milliseconds to delay.\n     * @param {String} [name] The name of delay\n     * @returns {Number} The created timeout id.\n     * @private\n     */\n    delay(fn, delay, name = fn.name || fn) {\n        // Force scope on the fn if we are not a Delayable\n        fn = this.setTimeout ? fn : fn.bind(this);\n        const invoker = this.setTimeout ? this : globalThis;\n        return invoker[typeof delay === 'number' ? 'setTimeout' : 'requestAnimationFrame'](fn, delay, name);\n    }\n    /**\n     * Classes implement this method to provide custom cleanup logic before calling `super.doDestroy()`. The general\n     * pattern is as follows:\n     *\n     * ```javascript\n     *  class Foo extends Base {\n     *      doDestroy() {\n     *          // perform custom cleanup\n     *\n     *          super.doDestroy();\n     *      }\n     *  }\n     * ```\n     *\n     * This method is called by {@link #function-destroy} which also prevents multiple calls from reaching `doDestroy`.\n     * Prior to calling `doDestroy`, {@link #property-isDestroying} is set to `true`. Upon return, the object is fully\n     * destructed and {@link #property-isDestroyed} is set to `true`.\n     *\n     * Do not call this method directly. Instead call {@link #function-destroy}.\n     * @category Lifecycle\n     */\n    doDestroy() {\n        const\n            me = this,\n            { nullify } = me.$meta;\n        if (nullify) {\n            for (let i = 0; i < nullify.length; ++i) {\n                if (me[nullify[i].field] != null) {     // if backing property is null/undefined then skip\n                    me[nullify[i].name] = null;         // else, call setter to run through change/update\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the named properties if they have been initialized, and if they have a `destroy` method.\n     * Deletes the property from this object. For example:\n     *\n     *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');\n     *\n     * @param {String} properties The names of the properties to destroy.\n     * @internal\n     * @category Lifecycle\n     */\n    destroyProperties(...properties) {\n        const me = this;\n        let key;\n        for (key of properties) {\n            // If the value has *not* been pulled in from the configuration object yet\n            // we must not try to access it, as that will cause the property to be initialized.\n            if (key in me && (!me[configuringSymbol] || !me[configuringSymbol][key])) {\n                me[key]?.destroy?.();\n                delete me[key];\n            }\n        }\n    }\n    /**\n     * Called by the Base constructor to apply configs to this instance. This must not be called.\n     * @param {Object} config The configuration object from which instance properties are initialized.\n     * @private\n     * @category Lifecycle\n     */\n    configure(config = {}) {\n        const\n            me                  = this,\n            meta                = me.$meta,\n            { beforeConfigure } = config,\n            configs             = meta.configs,\n            fullConfig          = me.getDefaultConfiguration();\n        let cfg, key, value;\n        me.initialConfig = config;\n        // Important flag for setters to know whether they are being called during\n        // configuration when this object is not fully alive, or whether it's being reconfigured.\n        me.isConfiguring = true;\n        // Assign any instance properties declared by the class.\n        Object.assign(me, me.getProperties());\n        // Apply configuration to default from class definition. This is safe because it's either chained from or a\n        // fork of the class values.\n        for (key in config) {\n            value = config[key];\n            cfg   = configs[key];\n            fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;\n        }\n        if (beforeConfigure) {\n            delete fullConfig.beforeConfigure;\n            // noinspection JSValidateTypes\n            beforeConfigure(me, fullConfig);\n        }\n        // Cache me.config for use by get config.\n        me.setConfig(me[originalConfigSymbol] = fullConfig, true);\n        me.isConfiguring = false;\n    }\n    /**\n     * Returns the value of the specified config property. This is a method to allow\n     * property getters to be explicitly called in a way that does not get optimized out.\n     *\n     * The following triggers the getter call, but optimizers will remove it:\n     *\n     *      inst.foo;   // also raises \"expression has no side-effects\" warning\n     *\n     * Instead, do the following to trigger a getter:\n     *\n     *      inst.getConfig('foo');\n     *\n     * @param {String} name\n     * @internal\n     * @category Configuration\n     */\n    getConfig(name) {\n        return this[name];\n    }\n    /**\n     * Sets configuration options this object with all the properties passed in the parameter object.\n     * Timing is taken care of. If the setter of one config is called first, and references\n     * the value of another config which has not yet been set, that config will be set just\n     * in time, and the *new* value will be used.\n     * @param {Object} config An object containing configurations to change.\n     * @category Lifecycle\n     */\n    setConfig(config, isConstructing) {\n        const\n            me             = this,\n            wasConfiguring = me[configuringSymbol],\n            configDone     = wasConfiguring ? me.configDone : (me.configDone = {}),\n            configs        = me.$meta.configs;\n        let cfg, key;\n        me[instancePropertiesSymbol] = {};\n        // Cache configuration for use by injected property initializers.\n        me[configuringSymbol] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;\n        // For each incoming non-null configuration, create a temporary getter which will\n        // pull the value in from the initialConfig so that it doesn't matter in\n        // which order properties are set. You can access any property at any time.\n        for (key in config) {\n            // Don't default null configs in unless it's a direct property of the\n            // the passed configuration. When used at construct time, defaultConfigs\n            // will be prototype-chained onto the config.\n            if (config[key] != null || hasOwn(config, key)) {\n                cfg = configs[key] || Config.get(key);\n                cfg.defineInitter(me, config[key]);\n                if (!isConstructing) {\n                    configDone[key] = false;\n                }\n                // else if (cfg.lazy) {\n                //     // This was done originally to prevent our for-loop below from poking the value on the instance\n                //     // at this stage. It was removed since it confused triggerConfig, and it just isn't true that the\n                //     // lazy config is done...\n                //     configDone[key] = true;\n                // }\n            }\n            else {\n                configDone[key] = true;\n            }\n        }\n        if (isConstructing) {\n            me.startConfigure(config);\n        }\n        // Set all our properties from the config object.\n        // If one of the properties needs to access a property that has not\n        // yet been set, the above temporary property will pull it through.\n        // Can't use Object.assign because that only uses own properties.\n        // config value blocks are prototype chained subclass->superclass\n        for (key in config) {\n            // Only push the value through if the property initializer is still present.\n            // If it gets triggered to pull the configuration value in, it deleted itself.\n            if (!configDone[key] && !configs[key]?.lazy) {\n                me[key] = config[key];\n            }\n        }\n        if (wasConfiguring) {\n            me[configuringSymbol] = wasConfiguring;\n        }\n        else {\n            delete me[configuringSymbol];\n        }\n        if (isConstructing) {\n            me.finishConfigure(config);\n        }\n        return me;\n    }\n    /**\n     * Returns `true` if this instance has a non-null value for the specified config. This will not activate a lazy\n     * config.\n     *\n     * @param {String} name The name of the config property.\n     * @returns {Boolean}\n     * @internal\n     */\n    hasConfig(name) {\n        const\n            me     = this,\n            config = me[configuringSymbol];\n        return Boolean(\n            (me['_' + name] != null)                 ||     // value has been assigned to backing property\n            me[lazyConfigsSymbol]?.get(name) != null ||     // a lazy value is pending\n            (\n                // config value has not been assigned but will be\n                !me.configDone[name] &&\n                config && (config[name] != null || hasOwn(config, name))\n            )\n        );\n    }\n    /**\n     * Returns the value of an uningested config *without* ingesting the config or transforming\n     * it from its raw value using its `changeXxxxx` method.\n     *\n     * @param {String} name The name of the config property.\n     * @returns {*} The raw incoming config value.\n     * @internal\n     */\n    peekConfig(name) {\n        const\n            me             = this,\n            lazyConfig     = me[lazyConfigsSymbol],\n            config         = me[configuringSymbol];\n        // It's waiting in the lazy configs\n        if (lazyConfig?.has(name)) {\n            return lazyConfig.get(name);\n        }\n        if (config && (name in config)) {\n            // It's been read in, so use the current value\n            if (me.configDone[name]) {\n                return me[name];\n            }\n            if (config[name] != null || hasOwn(config, name)) {\n                return config[name];\n            }\n        }\n    }\n    /**\n     * Ensures that the specified config is initialized if it is needed. If there is a config value specified, and it\n     * was initialized by this call, this method returns `true`. If there was a config value specified, and it was\n     * already initialized, this method returns `false`. If there was no value specified for the given config, this\n     * method returns `null`.\n     *\n     * This is not the same as just reading the property, because some property getters exist that do not actually just\n     * read the config value back, but instead produce some result. Reading such properties to incidentally trigger a\n     * possible config initializer can lead to incorrect results. For example, the Combo items config.\n     *\n     * @param {String} name The name of the config property.\n     * @returns {Boolean}\n     * @internal\n     */\n    triggerConfig(name) {\n        const\n            me             = this,\n            { configDone } = me,\n            lazyConfig     = me[lazyConfigsSymbol],\n            config         = me[configuringSymbol],\n            triggered      = (lazyConfig?.has(name) || (config && (config[name] != null || hasOwn(config, name))))\n                ? !configDone[name] : null;\n        if (triggered) {\n            me.getConfig(name);\n        }\n        return triggered;\n    }\n    /**\n     * This call will activate any pending {@link Core.Config#config-lazy} configs that were assigned a string value\n     * equal to the `group` parameter.\n     *\n     * @param {String} group The config property group as defined by a matching {@link Core.Config#config-lazy} value.\n     * @returns {String[]} The names of any configs triggered by this call or `null` if no configs were triggered.\n     * @internal\n     */\n    triggerConfigs(group) {\n        const\n            me          = this,\n            configs     = me.$meta.configs,\n            lazyConfigs = me[lazyConfigsSymbol],\n            triggered   = lazyConfigs ? [...lazyConfigs.keys()].filter(k => configs[k].lazy === group) : emptyArray;\n        for (const key of triggered) {\n            me.triggerConfig(key);\n        }\n        return triggered.length ? triggered : null;\n    }\n    onConfigChange() {} // declared above because lint/IDE get angry about not declaring the args...\n    /**\n     * This method is called when any config changes.\n     * @param {Object} info Object containing information regarding the config change.\n     * @param {String} info.name The name of the config that changed.\n     * @param {*} info.value The new value of the config.\n     * @param {*} info.was The previous value of the config.\n     * @param {Core.Config} info.config The `Config` object for the changed config property.\n     * @method onConfigChange\n     * @internal\n     * @category Configuration\n     */\n    /**\n     * Returns a *copy* of the full configuration which was used to configure this object.\n     * @property {Object}\n     * @category Lifecycle\n     * @readonly\n     */\n    get config() {\n        const\n            result   = {},\n            myConfig = this[originalConfigSymbol];\n        // The configuration was created as a prototype chain of the class hierarchy's\n        // defaultConfig values hanging off a copy of the initialConfig object, so\n        // we must loop and copy since Object.assign only copies own properties.\n        for (const key in myConfig) {\n            result[key] = myConfig[key];\n        }\n        return result;\n    }\n    // region Extract config\n    static processConfigValue(currentValue, options) {\n        if (currentValue === globalThis) {\n            return globalThis;\n        }\n        else if (Array.isArray(currentValue)) {\n            return currentValue.map(v => Base.processConfigValue(v, options));\n        }\n        // Not using isBase to avoid classes (modelClass for example)\n        else if (currentValue instanceof Base) {\n            if (options.visited.has(currentValue)) {\n                return;\n            }\n            return currentValue.getCurrentConfig(options);\n        }\n        // appendTo, floatRoot etc\n        else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {\n            return null;\n        }\n        // Go deeply into objects, might have instances of our classes in them\n        else if (Objects.isObject(currentValue)) {\n            const result = {};\n            for (const key in currentValue) {\n                // Only step \"down\", not \"up\"\n                if (key !== 'owner') {\n                    result[key] = Base.processConfigValue(currentValue[key], options);\n                }\n            }\n            return result;\n        }\n        return currentValue;\n    };\n    // Recursively get the value of a config. Only intended to be called by getCurrentConfig()\n    getConfigValue(name, options) {\n        const\n            me = this,\n            lazyConfigs = me[lazyConfigsSymbol];\n        // Do not trigger lazy configs\n        if (!me.$meta.configs[name]?.lazy) {\n            return Base.processConfigValue(me[name], options);\n        }\n        // Instead pull their initial config in\n        if (lazyConfigs?.has(name)) {\n            return Base.processConfigValue(lazyConfigs.get(name), options);\n        }\n    }\n    // Allows removing / adding configs before values are extracted\n    preProcessCurrentConfigs() {}\n    // Extract the current values for all initially used configs, in a format that can be used to create a new instance.\n    // Not intended to be called by any other code than getConfigString()\n    getCurrentConfig(options = { }) {\n        const\n            me      = this,\n            configs = options.configs === 'all' ? me.config : Objects.clone(me.initialConfig),\n            visited = options.visited || (options.visited = new Set()),\n            depth   = options.depth || (options.depth = 0),\n            result  = {};\n        if (visited.has(me)) {\n            return undefined;\n        }\n        visited.add(me);\n        this.preProcessCurrentConfigs(configs);\n        for (const name in configs) {\n            const value = me.getConfigValue(name, { ...options, depth : depth + 1 });\n            if (value !== undefined) {\n                result[name] = value;\n            }\n        }\n        return result;\n    }\n    // Extract the current values for all initially used configs and convert them to a JavaScript string\n    getConfigString(options = {}) {\n        return StringHelper.toJavaScriptString(this.getCurrentConfig(options));\n    }\n    // Experimental helper function, extracts the currently used configs and wraps them as an app, returning code as a\n    // string.\n    //\n    // This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.\n    //\n    getTestCase(options = {}) {\n        //<remove-on-lwc-release>\n        const Product = this.isGantt ? 'Gantt' : this.isSchedulerPro ? 'SchedulerPro' : this.isCalendar ? 'Calendar' : this.isScheduler ? 'Scheduler' : this.isGrid ? 'Grid' : this.isTaskBoard ? 'TaskBoard' : null;\n        if (Product) {\n            const\n                product    = Product.toLowerCase(),\n                // bundlePath = `https://bryntum.com/dist/${product}/build/${product}.module.js`,\n                bundlePath = `../../build/${product}.module.js`;\n            let preamble, postamble;\n            if (options.import === 'static') {\n                preamble =\n                    `import * as module from \"${bundlePath}\";` +\n                    'Object.assign(window, module);'; // for (const c in module) window[c] = module[c];\n                postamble = '';\n            }\n            else {\n                preamble = `import(\"${bundlePath}\").then(module => { Object.assign(window, module);\\n`;\n                postamble = '});';\n            }\n            const version = VersionHelper.getVersion(product);\n            if (version) {\n                preamble += `\\nconsole.log('${Product} ${version}');\\n`;\n            }\n            // De-indented on purpose\n            return `${preamble}      \\nconst ${product} = new ${Product}(${this.getConfigString(options)});\\n${postamble}`;\n        }\n        //</remove-on-lwc-release>\n    }\n    /**\n     * Experimental helper function, extracts the currently used configs and wraps them as an app, downloading the\n     * resulting JS file.\n     *\n     * This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.\n     * @category Misc\n     */\n    downloadTestCase(options = {}) {\n        options.output = 'return';\n        const app = this.getTestCase(options);\n        BrowserHelper.download(`app.js`, 'data:application/javascript;charset=utf-8,' + escape(app));\n    }\n    //endregion\n    /**\n     * Registers this class type with its Factory\n     * @category Misc\n     */\n    static initClass() {\n        return this.$meta.class;\n    }\n    /**\n     * The class's {@link #property-$meta-static meta} object.\n     * @member {Object} $meta\n     * @internal\n     * @category Misc\n     */\n    /**\n     * An object owned by this class that does not share properties with its super class.\n     *\n     * This object may contain other properties which are added as needed and are not documented here.\n     *\n     * @property {Object} $meta The class meta object.\n     * @property {Function} $meta.class The class constructor that owns the meta object.\n     * @property {Object} $meta.super The `$meta` object for the super class. This is `null` for `Base`.\n     * @property {Object} $meta.config The object holding the default configuration values for this class.\n     * @property {Object} $meta.configs An object keyed by config name that holds the defined configs for the class.\n     * The value of each property is a {@link Core/Config} instance.\n     * @property {Boolean} $meta.forkConfigs This will be `true` if the default configuration values for this class\n     * (in the `config` property of the meta object) must be forked to avoid object sharing, or if the object can be\n     * passed to `Object.create()` for efficiency.\n     * @property {Function[]} $meta.hierarchy The array of classes in the ancestry of this class. This will start with\n     * `Base` at index 0 and ends with this class.\n     * @property {Function[]} $meta.properties The array of classes that define a \"static get properties()\" getter.\n     * @internal\n     * @static\n     * @category Misc\n     */\n    static get $meta() {\n        const me = this;\n        let meta = me[metaSymbol];\n        if (!hasOwn(me, metaSymbol)) {\n            me[metaSymbol] = meta = newMeta();\n            meta.class = me;\n            me.setupClass(meta);\n        }\n        return meta;\n    }\n    /**\n     * This optional class method is called when a class is mixed in using the {@link #function-mixin-static mixin()}\n     * method.\n     * @internal\n     */\n    static onClassMixedIn() {\n        // empty\n    }\n    /**\n     * Returns the merge of the `baseConfig` and `config` config objects based on the configs defined by this class.\n     * @param {Object} baseConfig The base config or defaults.\n     * @param {...Object} configs One or more config objects that takes priority over `baseConfig`.\n     * @returns {Object}\n     * @internal\n     */\n    static mergeConfigs(baseConfig, ...configs) {\n        const\n            classConfigs = this.$meta.configs,\n            result       = Objects.clone(baseConfig) || {};\n        let config, i, key, value;\n        for (i = 0; i < configs.length; ++i) {\n            config = configs[i];\n            if (config) {\n                for (key in config) {\n                    value = config[key];\n                    if (classConfigs[key]) {\n                        value = classConfigs[key].merge(value, result[key]);\n                    }\n                    else if (result[key] && value) {\n                        value = Config.merge(value, result[key]);\n                    }\n                    result[key] = value;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Applies one or more `mixins` to this class and returns the produced class constructor.\n     *\n     * For example, instead of writing this:\n     * ```\n     *  class A extends Delayable(Events(Localizable(Base))) {\n     *      // ...\n     *  }\n     * ```\n     *\n     * Using this method, one would write this:\n     * ```\n     *  class A extends Base.mixin(Localizable, Events, Delayable) {\n     *      // ...\n     *  }\n     * ```\n     * If one of the mixins specified has already been mixed into the class, it will be ignored and not mixed in a\n     * second time.\n     * @param {...Function} mixins\n     * @returns {Function}\n     * @category Misc\n     */\n    static mixin(...mixins) {\n        // Starting w/the first class C = this\n        let C = this,\n            i;\n        // wrap each class C using mixins[i] to produce the next class\n        for (i = 0; i < mixins.length; ++i) {\n            const\n                mixin = mixins[i],\n                // Grab or create a unique Symbol for this mixin so we can tell if we've already mixed it in\n                tag   = mixin[mixinTagSymbol] || (mixin[mixinTagSymbol] = Symbol('mixinTag'));\n            if (C[tag]) {\n                continue;\n            }\n            C      = mixin(C);\n            C[tag] = true;  // properties on the constructor are inherited to subclass constructors...\n            if (hasOwn(C, 'onClassMixedIn')) {\n                C.onClassMixedIn();\n            }\n        }\n        return C;\n    }\n    /**\n     * This method is called only once for any class. This can occur when the first instance is created or when the\n     * `$meta` object is first requested.\n     * @param {Object} meta The `$meta` object for the class.\n     * @internal\n     * @category Misc\n     */\n    static setupClass(meta) {\n        const\n            cls   = meta.class,\n            // Trigger setupClass on the super class (if it has yet to happen):\n            base  = getPrototypeOf(cls).$meta,\n            name  = cls.$$name,\n            names = base.names,\n            proto = cls.prototype;\n        defineProperty(proto, '$meta', {\n            value : meta\n        });\n        Object.assign(meta, {\n            super       : base,\n            config      : Object.create(base.config),\n            configs     : Object.create(base.configs),\n            declarables : base.declarables,\n            forkConfigs : base.forkConfigs,\n            hierarchy   : Object.freeze([...base.hierarchy, cls]),\n            names       : names.includes(name) ? names : Object.freeze([...names, name]),\n            properties  : base.properties,\n            nullify     : base.nullify?.slice()\n        });\n        if (names !== meta.names) {\n            const\n                isName = `is${name}`,\n                defineIsProperty = obj => {\n                    if (!hasOwn(obj, isName)) {\n                        defineProperty(obj, isName,  {\n                            get() {\n                                // This check is intended to verify correct class name for minified packages\n                                if (!hasOwn(typeof obj === 'object' ? obj.constructor : obj, '$name')) {\n                                    console.warn(\n                                        `$name static property or getter required for class ${name} to provide class name for minified sources.` +\n                                        (VersionHelper.isTestEnv ? '' : '\\nhttps://bryntum.com/products/grid/docs/api/Core/widget/Widget#property-$name-static')\n                                    );\n                                }\n                                return true;\n                            }\n                        });\n                    }\n                };\n            defineIsProperty(proto);\n            defineIsProperty(cls);\n        }\n        // NOTE: we always use meta.declarables because setupDeclarable() can replace the array on the meta object\n        // when new declarable properties are added...\n        for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {\n            decl = meta.declarables[i];\n            if (hasOwn(cls, decl)) {\n                setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);\n                cls[setupName](cls, meta);\n            }\n        }\n        /*  Add slash to the front of this line to enable the diagnostic block:\n        /**/\n    }\n    /**\n     * This method is called as part of `setupClass()`. It will process the `configurable()` return object and the\n     * `defaultConfig` return object.\n     * @param {Object} meta The `meta` object for this class.\n     * @param {Object} configs The config definition object.\n     * @param {Boolean} simple `true` when processing `defaultConfig` and `false` when processing `configurable`.\n     * @private\n     * @category Configuration\n     */\n    static setupConfigs(meta, configs, simple) {\n        const\n            classConfigValues = meta.config,\n            classConfigs      = meta.configs,\n            cls               = meta.class,\n            superMeta         = meta.super;\n        let { nullify } = meta,\n            cfg, defaultValue, options, setDefault, value, wasNullify;\n        for (const name in configs) {\n            value = configs[name];\n            if (simple) {\n                // Using \"defaultConfig\"\n                if (!(cfg = classConfigs[name])) {\n                    cfg = Config.get(name, defaultConfigOptions);\n                }\n                else {\n                    // The property may be declared in a base class using configurable(), so it may have special\n                    // merge processing:\n                    value = cfg.merge(value, classConfigValues[name], meta, superMeta);\n                }\n                /*  Add slash to the front of this line to enable the diagnostic block:\n                /**/\n            }\n            else {\n                // Using \"configurable\"\n                defaultValue = options = setDefault = undefined;\n                if (value && typeof value === 'object' && '$config' in value) {\n                    options = value.$config;\n                    if (options && !Objects.isObject(options)) {\n                        options = Objects.createTruthyKeys(options);\n                    }\n                    setDefault = 'default' in value;\n                    defaultValue = setDefault ? value.default : defaultValue;\n                    value = value.value;\n                }\n                if (!(cfg = classConfigs[name])) {\n                    cfg = Config.get(name, options);\n                    cfg.define(cls.prototype);\n                    setDefault = !(cfg.field in cls.prototype);  // reduce object shape changes (helps JIT)\n                    wasNullify = false;\n                }\n                else {\n                    wasNullify = cfg.nullify;\n                    if (options) {\n                        // Defined by a base class, but maybe being adjusted by derived.\n                        cfg = cfg.extend(options);\n                        // In the future, we may need to redefine the property here if options affect the descriptor (such\n                        // as event firing)\n                    }\n                    value = cfg.merge(value, classConfigValues[name], meta, superMeta);\n                }\n                if (setDefault) {\n                    cfg.setDefault(cls, defaultValue);\n                }\n                if (cfg.nullify && !wasNullify) {\n                    (nullify || (nullify = (meta.nullify || (meta.nullify = [])))).push(cfg);\n                }\n            }\n            // If any default properties are *mutable* Objects or Array we need to clone them.\n            // so that instances do not share configured values.\n            if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {\n                meta.forkConfigs = true;\n            }\n            classConfigs[name]      = cfg;\n            classConfigValues[name] = value;\n        }\n    }\n    static setupConfigurable(cls, meta) {\n        cls.setupConfigs(meta, cls.configurable, false);\n    }\n    static setupDefaultConfig(cls, meta) {\n        cls.setupConfigs(meta, cls.defaultConfig, true);\n    }\n    static setupDeclarable(cls, meta) {\n        const declarable = cls.declarable;\n        let all = meta.declarables,\n            forked, i;\n        for (i = 0; i < declarable.length; ++i) {\n            if (!all.includes(declarable[i])) {\n                if (!forked) {\n                    meta.declarables = forked = all = all.slice();\n                }\n                all.push(declarable[i]);\n            }\n        }\n    }\n    static setupProperties(cls, meta) {\n        meta.properties = meta.super.properties.slice();\n        meta.properties.push(cls);\n        Object.freeze(meta.properties);\n    }\n    static setupPrototypeProperties(cls) {\n        Object.assign(cls.prototype, cls.prototypeProperties);\n    }\n    /**\n     * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain\n     * all the way up to but not including {@link Core.Base}\n     * @returns {Object} All default config values for this class.\n     * @private\n     * @category Configuration\n     */\n    getDefaultConfiguration() {\n        return this.constructor.getDefaultConfiguration();\n    }\n    /**\n     * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class\n     * all the way up to but not including {@link Core.Base}\n     * @returns {Object} All default config values for this class.\n     * @private\n     * @category Configuration\n     */\n    static getDefaultConfiguration() {\n        const\n            meta   = this.$meta,\n            config = meta.forkConfigs ? Base.fork(meta.config) : Object.create(meta.config);\n        if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv &&\n            config.testConfig && globalThis.__applyTestConfigs) {\n            for (const o in config.testConfig) {\n                config[o] = config.testConfig[o];\n            }\n        }\n        return config;\n    }\n    static fork(obj) {\n        let ret = obj,\n            key, value;\n        if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {\n            ret = Object.create(obj);\n            for (key in obj) {\n                value = obj[key];\n                if (value) {\n                    if (Objects.isObject(value)) {\n                        ret[key] = Base.fork(value);\n                    }\n                    else if (Array.isArray(value)) {\n                        ret[key] = value.slice();\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain\n     * all the way up to but not including {@link Core.Base}\n     * @returns {Object} All default config values for this class.\n     * @private\n     * @category Configuration\n     */\n    getProperties() {\n        const\n            // The meta.properties array is an array of classes that define \"static get properties()\"\n            hierarchy = this.$meta.properties,\n            result    = {};\n        for (let i = 0; i < hierarchy.length; i++) {\n            // Gather the class result in top-down order so that subclass properties override superclass properties\n            Object.assign(result, hierarchy[i].properties);\n        }\n        return result;\n    }\n    static get superclass() {\n        return getPrototypeOf(this);\n    }\n    /**\n     * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object\n     * starting from the `topClass` class (which defaults to `Base`).\n     *\n     * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`\n     * @param {Function} [topClass] The topmost class constructor to start from.\n     * @returns {Function[]} The class hierarchy of this instance.\n     * @private\n     * @category Configuration\n     */\n    classHierarchy(topClass) {\n        const\n            hierarchy = this.$meta.hierarchy,\n            index     = topClass ? hierarchy.indexOf(topClass) : 0;\n        return (index > 0) ? hierarchy.slice(index) : hierarchy;\n    }\n    /**\n     * Checks if an obj is of type using object's $$name property and doing string comparison of the property with the\n     * type parameter.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     * @category Misc\n     */\n    static isOfTypeName(type) {\n        return this.$meta.names.includes(type);\n    }\n    /**\n     * Removes all event listeners that were registered with the given `name`.\n     * @param {String|Symbol} name The name of the event listeners to be removed.\n     * @category Events\n     */\n    detachListeners(name) {\n        let detachers = this.$detachers;\n        detachers = detachers?.[name];\n        if (detachers) {\n            while (detachers.length) {\n                detachers.pop()();\n            }\n        }\n    }\n    /**\n     * Tracks a detacher function for the specified listener name.\n     * @param {String} name The name assigned to the associated listeners.\n     * @param {Function} detacher The detacher function.\n     * @private\n     */\n    trackDetacher(name, detacher) {\n        const\n            detachers = this.$detachers || (this.$detachers = {}),\n            bucket    = detachers[name] || (detachers[name] = []);\n        bucket.push(detacher);\n    }\n    /**\n     * Removes all detacher functions for the specified `Events` object. This is called\n     * by the `removeAllListeners` method on that object which is typically called by its\n     * `destroy` invocation.\n     * @param {Core.mixin.Events} eventer The `Events` instance to untrack.\n     * @private\n     */\n    untrackDetachers(eventer) {\n        const detachers = this.$detachers;\n        if (detachers) {\n            for (const name in detachers) {\n                const bucket = detachers[name];\n                for (let i = bucket.length; i-- > 0; /* empty */) {\n                    if (bucket[i].eventer === eventer) {\n                        bucket.splice(i, 1);\n                    }\n                }\n            }\n        }\n    }\n}\nconst proto = Base.prototype;\n// Informs the standard config setter there is no need to call this fn:\nproto.onConfigChange.$nullFn = emptyFn.$nullFn = true;\nBase[metaSymbol] = proto.$meta = newMeta({\n    class       : Base,\n    config      : Object.freeze({}),\n    configs     : Object.create(null),\n    declarables : Base.declarable,\n    forkConfigs : false,\n    hierarchy   : Object.freeze([Base]),\n    names       : Object.freeze(['Base']),\n    nullify     : null,\n    properties  : Object.freeze([]),\n    super       : null\n});\n// Avoid some object shape changes:\nObject.assign(proto, {\n    $detachers : null,\n    configObserver : null,\n    /**\n     * This property is set to `true` before the `constructor` returns.\n     * @member {Boolean}\n     * @readonly\n     * @category Lifecycle\n     */\n    isConstructing : true,\n    /**\n     * This property is set to `true` by {@link #function-destroy} after the {@link #function-doDestroy} method returns.\n     * It is also one of the few properties that remains on the object after returning from `destroy()`. This property\n     * is often checked in code paths that may encounter a destroyed object (like some event handlers) or in the\n     * destruction path during cleanup.\n     * @member {Boolean}\n     * @readonly\n     * @category Lifecycle\n     */\n    isDestroyed : false,\n    /**\n     * This property is set to `true` on entry to the {@link #function-destroy} method. It remains on the objects after\n     * returning from `destroy()`. If {@link #property-isDestroyed} is `true`, this property will also be `true`, so\n     * there is no need to test for both (for example, `comp.isDestroying || comp.isDestroyed`).\n     * @member {Boolean}\n     * @readonly\n     * @category Lifecycle\n     */\n    isDestroying : false\n});\nBase.emptyFn = emptyFn;\nVersionHelper.setVersion('core', '5.3.7');\nBase._$name = 'Base';", "/**\n * @module Core/helper/AjaxHelper\n */\nimport Objects from './util/Objects.js';\n/**\n * Options for the requests. Please see\n * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details\n *\n * To set default values for the options please use {@link #property-DEFAULT_FETCH_OPTIONS-static} property:\n *\n * ```javascript\n * // enable passing parameters in request body by default\n * AjaxHelper.DEFAULT_FETCH_OPTIONS = { addQueryParamsToBody : true };\n * ```\n *\n * @typedef {Object} FetchOptions\n * @property {'GET'|'POST'|'PUT'|'PATCH'|'DELETE'} [method] The request method, e.g., `GET`, `POST`\n * @property {Object} [queryParams] A key-value pair Object containing the params to add to the query string\n * @property {Object} [headers] Any headers you want to add to your request, contained within a `Headers` object or an\n * object literal with ByteString values\n * @property {Object} [body] Any body that you want to add to your request: this can be a `Blob`, `BufferSource`,\n * `FormData`, `URLSearchParams`, or `USVString` object. Note that a request using the `GET` or `HEAD` method cannot have a body.\n * @property {Boolean} [addQueryParamsToBody=false] Indicates whether `queryParams` should be passed in the request\n * body. Adding them to the body applies for `application/x-www-form-urlencoded` and `multipart/form-data`\n * content types only, so make sure to pass corresponding `Content-Type` header to `headers`.\n *\n * When the argument is `true` and:\n * - if `application/x-www-form-urlencoded` content-type header is passed\n *   the method will make a `URLSearchParams` instance with `queryParams` and set it as the request body.\n *   And if `body` already has a `URLSearchParams` instance provided the parameters will be set there.\n * - if `multipart/form-data` content-type header is passed\n *   the method will make a `FormData` instance with `queryParams` and set it as the request body.\n *   And if `body` already has a `FormData` instance provided the parameters will be set there.\n *\n * Otherwise, `queryParams` are added to the query string.\n * @property {'cors'|'no-cors'|'same-origin'} [mode] The mode you want to use for the request, e.g., `'cors'`, `'no-cors'`, or `'same-origin'`.\n * @property {'omit'|'same-origin'|'include'} [credentials] The request credentials you want to use for the request: `'omit'`, `'same-origin'`, or\n * `'include'`. To automatically send cookies for the current domain, this option must be provided\n * @property {Boolean} [parseJson] Specify `true` to parses the response and attach the resulting object to the\n * `Response` object as `parsedJson`\n */\nconst\n    paramValueRegExp = /^(\\w+)=(.*)$/,\n    parseParams      = function(paramString) {\n        const\n            result = {},\n            params = paramString.split('&');\n        // loop through each 'filter={\"field\":\"name\",\"operator\":\"=\",\"value\":\"Sweden\",\"caseSensitive\":true}' string\n        // So we cannot use .split('=')\n        for (const nameValuePair of params) {\n            const\n                [match, name, value] = paramValueRegExp.exec(nameValuePair),\n                decodedName          = decodeURIComponent(name),\n                decodedValue         = decodeURIComponent(value);\n            if (match) {\n                let paramValue = result[decodedName];\n                if (paramValue) {\n                    if (!Array.isArray(paramValue)) {\n                        paramValue = result[decodedName] = [paramValue];\n                    }\n                    paramValue.push(decodedValue);\n                }\n                else {\n                    result[decodedName] = decodedValue;\n                }\n            }\n        }\n        return result;\n    };\n/**\n * Simplifies Ajax requests. Uses fetch & promises.\n *\n * ```javascript\n * AjaxHelper.get('some-url').then(response => {\n *     // process request response here\n * });\n * ```\n *\n * Uploading file to server via FormData interface.\n * Please visit [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) for details.\n *\n * ```javascript\n * const formData = new FormData();\n * formData.append('file', 'fileNameToUpload');\n * AjaxHelper.post('file-upload-url', formData).then(response => {\n *     // process request response here\n * });\n * ```\n *\n */\nexport default class AjaxHelper {\n    /**\n     * Sets default options for {@link #function-fetch-static AjaxHelper#fetch()} calls. Please see\n     * {@link #typedef-FetchOptions} and\n     * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details.\n     *\n     * ```javascript\n     * // default content-type for all requests will be \"application/json\"\n     * AjaxHelper.DEFAULT_FETCH_OPTIONS = {\n     *     headers : {\n     *         'content-type' : 'application/json'\n     *     }\n     * };\n     * ```\n     * @member {FetchOptions} DEFAULT_FETCH_OPTIONS\n     * @static\n     */\n    static DEFAULT_FETCH_OPTIONS = {};\n    /**\n     * Make a request (using GET) to the specified url.\n     * @param {String} url URL to `GET` from\n     * @param {FetchOptions} [options] The options for the `fetch` API\n     * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method\n     * @async\n     */\n    static get(url, options) {\n        return this.fetch(url, options);\n    }\n    /**\n     * POST data to the specified URL.\n     * @param {String} url URL to `POST` to\n     * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified\n     * @param {FetchOptions} [options] The options for the `fetch` API\n     * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method\n     * @async\n     */\n    static post(url, payload, options = {}) {\n        if (!(payload instanceof FormData) && !(typeof payload === 'string')) {\n            payload = JSON.stringify(payload);\n            options.headers = options.headers || {};\n            options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n        }\n        return this.fetch(url, Object.assign({\n            method : 'POST',\n            body   : payload\n        }, options));\n    }\n    /**\n     * Fetch the specified resource using the `fetch` API.\n     * @param {String} url URL to fetch from\n     * @param {FetchOptions} [options] The options for the `fetch` API\n     * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method\n     * @async\n     */\n    static fetch(url, options) {\n        let controller;\n        // inherit global options\n        options = Objects.merge({}, AjaxHelper.DEFAULT_FETCH_OPTIONS, options);\n        // AbortController is not supported by LockerService\n        // https://github.com/bryntum/support/issues/3689\n        if (typeof AbortController !== 'undefined') {\n            controller = options.abortController = new AbortController();\n            options.signal = controller.signal;\n        }\n        if (!('credentials' in options)) {\n            options.credentials = 'include';\n        }\n        if (options.queryParams) {\n            const params = Object.entries(options.queryParams);\n            if (params.length) {\n                let paramsAdded = false;\n                // for some content types we are going to add parameters to body (if that's not disabled)\n                if (options.headers && options.addQueryParamsToBody === true) {\n                    const contentType = new Headers(options.headers).get('Content-Type');\n                    let bodyClass;\n                    switch (contentType) {\n                        case 'application/x-www-form-urlencoded':\n                            bodyClass = URLSearchParams;\n                            break;\n                        case 'multipart/form-data':\n                            bodyClass = FormData;\n                            break;\n                    }\n                    // if that's one of supported content types\n                    if (bodyClass) {\n                        const body = options.body || (options.body = new bodyClass());\n                        // put parameters to body if it's of supported type\n                        if (body instanceof bodyClass) {\n                            params.forEach(([key, value]) => body.set(key, value));\n                            // remember parameters are already added\n                            paramsAdded = true;\n                        }\n                    }\n                }\n                // if parameters are not added yet append them to the query string\n                if (!paramsAdded) {\n                    url += (url.includes('?') ? '&' : '?') + params.map(([param, value]) =>\n                        `${param}=${encodeURIComponent(value)}`\n                    ).join('&');\n                }\n            }\n        }\n        // Promise that will be resolved either when network request is finished or when json is parsed\n        const promise = new Promise((resolve, reject) => {\n            fetch(url, options).then(\n                response => {\n                    if (options.parseJson) {\n                        response.json().then(json => {\n                            response.parsedJson = json;\n                            resolve(response);\n                        }).catch(error => {\n                            response.parsedJson = null;\n                            response.error = error;\n                            reject(response);\n                        });\n                    }\n                    else {\n                        resolve(response);\n                    }\n                }\n            ).catch(error => {\n                error.stack = promise.stack;\n                reject(error);\n            });\n        });\n        promise.stack = new Error().stack;\n        promise.abort = function() {\n            controller?.abort();\n        };\n        return promise;\n    }\n    /**\n     * Registers the passed URL to return the passed mocked up Fetch Response object to the\n     * AjaxHelper's promise resolve function.\n     * @param {String} url The url to return mock data for\n     * @param {Object|Function} response A mocked up Fetch Response object which must contain\n     * at least a `responseText` property, or a function to which the `url` and a `params` object\n     * and the `Fetch` `options` object is passed which returns that.\n     * @param {String} response.responseText The data to return.\n     * @param {Boolean} [response.synchronous] resolve the Promise immediately\n     * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.\n     */\n    static mockUrl(url, response) {\n        const me = this;\n        (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;\n        // Inject the override into the AjaxHelper instance\n        if (!AjaxHelper.originalFetch) {\n            AjaxHelper.originalFetch = AjaxHelper.fetch;\n            AjaxHelper.fetch = me.mockAjaxFetch.bind(me);\n        }\n    }\n    static async mockAjaxFetch(url, options) {\n        const urlAndParams = url.split('?');\n        let result     = this.mockAjaxMap[urlAndParams[0]],\n            parsedJson = null;\n        if (result) {\n            if (typeof result === 'function') {\n                result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);\n            }\n            try {\n                parsedJson = options?.parseJson && JSON.parse(result.responseText);\n            }\n            catch (error) {\n                parsedJson   = null;\n                result.error = error;\n            }\n            result = Object.assign({\n                status     : 200,\n                ok         : true,\n                headers    : new Headers(),\n                statusText : 'OK',\n                url,\n                parsedJson,\n                text       : () => new Promise((resolve) => {\n                    resolve(result.responseText);\n                }),\n                json : () => new Promise((resolve) => {\n                    resolve(parsedJson);\n                })\n            }, result);\n            return new Promise(function(resolve, reject) {\n                if (result.synchronous) {\n                    resolve(result);\n                }\n                else {\n                    setTimeout(function() {\n                        resolve(result);\n                    }, ('delay' in result ? result.delay : 100));\n                }\n            });\n        }\n        else {\n            return AjaxHelper.originalFetch(url, options);\n        }\n    }\n}\nAjaxHelper._$name = 'AjaxHelper';", "/**\n * @module Core/helper/ArrayHelper\n */\n/**\n * Helper with useful functions for handling Arrays\n * @internal\n */\nexport default class ArrayHelper {\n    static clean(array) {\n        return array.reduce((res, item) => {\n            if (item !== null && item !== undefined && !(Array.isArray(item) && item.length === 0) && item !== '') res.push(item);\n            return res;\n        }, []);\n    }\n    /**\n     * Similar to [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n     * this method creates an array from an `iterable` object. Where `Array.from()` accepts a mapper function as the\n     * second argument, this method accepts a `filter` function as its second argument. If a mapper function is also\n     * needed, it can be passed as the third argument. Unlike `Array.from()`, if this method is passed `null`, it will\n     * return an empty array.\n     * @param {Array} iterable The iterable object to convert (must support `for-of` loop iteration).\n     * @param {Function} [filter] A function to apply to each item of the `iterable` which must return a truthy value\n     * to include that item in the resulting array.\n     * @param {Function} [map] A function to apply to each item of the `iterable` that returns the actual value to put\n     * into the returned array. If a `filter` is also supplied, this method is only called for those items that pass\n     * the filter test.\n     * @returns {Array}\n     */\n    static from(iterable, filter, map) {\n        const array = [];\n        if (iterable) {\n            for (const it of iterable) {\n                if (!filter || filter(it)) {\n                    array.push(map ? map(it) : it);\n                }\n            }\n        }\n        return array;\n    }\n    /**\n     * Remove one or more items from an array\n     * @param {Array} array Array to remove from\n     * @param {Object[]|Set} items One or more items to remove, or one Set containing items to remove\n     * @returns {Boolean} Returns true if any item was removed\n     */\n    static remove(array, ...items) {\n        let index,\n            item,\n            removed = false;\n        items = items[0] instanceof Set ? [...items[0]] : items;\n        for (let i = 0; i < items.length; i++) {\n            item = items[i];\n            if ((index = array.indexOf(item)) !== -1) {\n                array.splice(index, 1);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    /**\n     * Calculates the insertion index of a passed object into the passed Array according\n     * to the passed comparator function. Note that the passed Array *MUST* already be ordered.\n     * @param {Object} item The item to calculate the insertion index for.\n     * @param {Array} The array into which the item is to be inserted.\n     * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.\n     * @param {Object} comparatorFn.lhs The left object to compare.\n     * @param {Object} comparatorFn.rhs The right object to compare.\n     * @param {Number} index The possible correct index to try first before a binary\n     * search is instigated.\n     * @internal\n     */\n    static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {\n        const len = array.length;\n        let beforeCheck, afterCheck;\n        if (index < len) {\n            beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;\n            afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;\n            if (beforeCheck < 1 && afterCheck < 1) {\n                return index;\n            }\n        }\n        return this.binarySearch(array, item, comparatorFn);\n    }\n    /**\n     * Similar to the native `Array.find()` call, but this finds the *last* element in the array for which\n     * the passed function returns a truthy value.\n     * @param {Object[]} array The array to find in.\n     * @param {Function} fn The testing function.\n     * @param {Object} [thisObj] The scope (`this` reference) in which to call the function.\n     */\n    static findLast(array, fn, thisObj) {\n        for (let { length } = array, i = length - 1; i >= 0; i--) {\n            if (fn.call(thisObj, array[i], i, array)) {\n                return array[i];\n            }\n        }\n    }\n    /**\n     * This method returns the index that a given item would be inserted into the\n     * given (sorted) `array`. Note that the given `item` may or may not be in the\n     * array. This method will return the index of where the item *should* be.\n     *\n     * For example:\n     *\n     *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];\n     *      var index = ArrayHelper.binarySearch(array, 'E');\n     *\n     *      console.log('index: ' + index);\n     *      // logs \"index: 2\"\n     *\n     *      array.splice(index, 0, 'E');\n     *\n     *      console.log('array : ' + array.join(''));\n     *      // logs \"array: ADEGKORX\"\n     *\n     * @param {Object[]} array The array to search.\n     * @param {Object} item The item that you want to insert into the `array`.\n     * @param {Number} [begin=0] The first index in the `array` to consider.\n     * @param {Number} [end=array.length] The index that marks the end of the range\n     * to consider. The item at this index is *not* considered.\n     * @param {Function} [compareFn] The comparison function that matches the sort\n     * order of the `array`. The default `compareFn` compares items using less-than\n     * and greater-than operators.\n     * @returns {Number} The index for the given item in the given array based on\n     * the passed `compareFn`.\n     */\n    static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {\n        const length = array.length;\n        let middle, comparison;\n        if (begin instanceof Function) {\n            compareFn = begin;\n            begin = 0;\n        }\n        else if (end instanceof Function) {\n            compareFn = end;\n            end = length;\n        }\n        --end;\n        while (begin <= end) {\n            middle = (begin + end) >> 1;\n            comparison = compareFn(item, array[middle]);\n            if (comparison >= 0) {\n                begin = middle + 1;\n            }\n            else if (comparison < 0) {\n                end = middle - 1;\n            }\n        }\n        return begin;\n    }\n    magnitudeCompare(lhs, rhs) {\n        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);\n    }\n    lexicalCompare(lhs, rhs) {\n        lhs = String(lhs);\n        rhs = String(rhs);\n        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);\n    }\n    /**\n     * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with\n     * clones of the supplied item.\n     * @param {Number} count Number of entries to create\n     * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)\n     * @param {Function} [fn] An optional function that is called for each item added, to allow processing\n     * @returns {Array} A new populated array\n     */\n    static fill(count, itemOrArray = {}, fn = null) {\n        const\n            result = [],\n            items  = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];\n        for (let i = 0; i < count; i++) {\n            for (const item of items) {\n                // Using object spread here forces us to use more babel plugins and will make\n                // react_typescript demo very difficult to setup\n                const processedItem = Object.assign({}, item);\n                if (fn) {\n                    fn(processedItem, i);\n                }\n                result.push(processedItem);\n            }\n        }\n        return result;\n    }\n    /**\n     * Populates an array with the return value from `fn`.\n     * @param {Number} count Number of entries to create\n     * @param {Function} fn A function that is called `count` times, return value is added to array\n     * @param {Number} fn.index Current index in the array\n     * @privateparam {Boolean} [oneBased] Add 1 to the index before calling the fn (making it 1 based)\n     * @returns {Array} A new populated array\n     */\n    static populate(count, fn, oneBased = false) {\n        const items = [];\n        for (let i = 0; i < count; i++) {\n            items.push(fn(i + (oneBased ? 1 : 0)));\n        }\n        return items;\n    }\n    /**\n     * Pushes `item` on to the `array` if not already included\n     * @param {Array}  array Array to push to\n     * @param {...Object} items Item(s) to push if not already included\n     */\n    static include(array, ...items) {\n        for (const item of items) {\n            if (!array.includes(item)) {\n                array.push(item);\n            }\n        }\n    }\n    /**\n     * Returns a new array with the unique items from the supplied array.\n     * @param {Array} array Input array\n     * @returns {Array} New array with unique items\n     */\n    static unique(array) {\n        return [...new Set(array)];\n    }\n    // Kept for future reference : Wanted to create an indexer on Stores.\n    static allowNegative(array) {\n        // From https://github.com/sindresorhus/negative-array\n        return new Proxy(array, {\n            get(target, name, receiver) {\n                if (typeof name !== 'string') {\n                    return Reflect.get(target, name, receiver);\n                }\n                const index = Number(name);\n                if (Number.isNaN(index)) {\n                    return Reflect.get(target, name, receiver);\n                }\n                return target[index < 0 ? target.length + index : index];\n            },\n            set(target, name, value, receiver) {\n                if (typeof name !== 'string') {\n                    return Reflect.set(target, name, value, receiver);\n                }\n                const index = Number(name);\n                if (Number.isNaN(index)) {\n                    return Reflect.set(target, name, value, receiver);\n                }\n                target[index < 0 ? target.length + index : index] = value;\n                return true;\n            }\n        });\n    }\n    static delta(a, b, useRelativeNaming = false) {\n        // Nicer syntax but about 40% slower (an extra iteration)\n        // const\n        //     onlyInA = a.filter(item => !b.includes(item)),\n        //     onlyInB = b.filter(item => !a.includes(item)),\n        //     inBoth  = a.filter(item => b.includes(item));\n        // Quick bailout for nonexisting target array\n        if (!b) {\n            return useRelativeNaming\n                ? { toAdd : a, toRemove : [], toKeep : [] }\n                : { onlyInA : a, onlyInB : [], inBoth : [] };\n        }\n        const\n            onlyInA = [],\n            onlyInB = [],\n            inBoth  = new Set(),\n            bSet    = new Set(b);\n        for (let i = 0; i < a.length; i++) {\n            const item = a[i];\n            if (bSet.has(item)) {\n                inBoth.add(item);\n            }\n            else {\n                onlyInA.push(item);\n            }\n        }\n        for (let i = 0; i < b.length; i++) {\n            const item = b[i];\n            if (!inBoth.has(item)) {\n                onlyInB.push(item);\n            }\n        }\n        if (useRelativeNaming) {\n            return { toAdd : onlyInA, toRemove : onlyInB, toKeep : inBoth };\n        }\n        return { onlyInA, onlyInB, inBoth : [...inBoth] };\n    }\n    /**\n     * Returns the passed object wrapped in an array. Special handling of the following cases:\n     * * Passing an array returns it as is\n     * * Passing a `Set` returns it converted to an Array\n     * * Passing `null`/`undefined` returns the passed value\n     *\n     * ```javascript\n     * const records = ArrayHelper.asArray(record);\n     *\n     * // { id : 1 } -> [{ id : 1 }]\n     * // [{ id : 1 }] -> [{ id : 1 }]\n     * ```\n     *\n     * @param {*} arrayOrObject\n     * @returns {Array|null}\n     * @internal\n     */\n    static asArray(arrayOrObject) {\n        if (arrayOrObject == null) {\n            return arrayOrObject;\n        }\n        if (arrayOrObject instanceof Set) {\n            return Array.from(arrayOrObject);\n        }\n        return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];\n    }\n    /**\n     * Identity function that returns its input.\n     * @param {*} Any value\n     * @returns {*} The input value\n     * @internal\n     */\n    static identity(x) {\n        return x;\n    }\n    /**\n     * Transform an array into a key:value dictionary using the specified\n     * key and value getters. Does not group values, so only one result will\n     * appear in the output for a given key.\n     *\n     * ```javascript\n     * const input = [{\n     *   id: '1',\n     *   other: 'one'\n     * },{\n     *   id: '2',\n     *   other: 'two'\n     * }];\n     *\n     * keyBy(input, rec => rec.id)\n     *\n     * // {\n     * //    '1': { id: '1', other: 'one' },\n     * //    '2': { id: '2', other: 'two' }\n     * // }\n     * ```\n     *\n     * @param {Array} array Array from which to build dictionary\n     * @param {Function|String} getKey Function to produce the key for a given array entry, or a string property name to read\n     * @param {Function} getValue Optional function to transform array elements. Defaults to returning the element itself\n     * @returns {Object} A key->value dictionary with keys as returned by `getKey` and values returned by `getValue`\n     * @internal\n     */\n    static keyBy(array, keyGetter, valueGetter = ArrayHelper.identity) {\n        const\n            getKey = typeof keyGetter === 'string' ? o => o?.[keyGetter] : keyGetter,\n            getValue = typeof valueGetter === 'string' ? o => o?.[valueGetter] : valueGetter;\n        return array.reduce((dict, next) => {\n            dict[getKey(next)] = getValue(next);\n            return dict;\n        }, {});\n    }\n    /**\n     * Group an array by keys (either the values in a specified property name, or the results of a string-generating function accepting\n     * an array entry as input), returning an Object with those keys, whose values are arrays containing the array entries that\n     * produced that key.\n     *\n     * ```javascript\n     * const input = [{\n     *   id: 1,\n     *   color: 'red'\n     * },{\n     *   id: 2,\n     *   color: 'green'\n     * },{\n     *   id: 3,\n     *   color: 'green'\n     * }];\n     *\n     * groupBy(input, 'color')\n     *\n     * // {\n     * //    'red': [ { id: '1', color: 'red' } ],\n     * //    'green': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]\n     * // }\n     *\n     * groupBy(input, rec => rec.color?.substr(0, 1))\n     *\n     * // {\n     * //    'r': [ { id: '1', color: 'red' } ],\n     * //    'g': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]\n     * // }\n     * ```\n     *\n     * @param {Object} array Array from which to build dictionary\n     * @param {Function|String} getGroupKey Function to produce the key for a given array entry, or a string property name to read\n     * @returns {Object} A key->value[] dictionary with keys as returned by `getKey` and arrays of matching items in original order as values\n     * @internal\n     */\n    static groupBy(array, groupKeyGetter) {\n        const getKey = typeof groupKeyGetter === 'string' ? o => o?.[groupKeyGetter] : groupKeyGetter;\n        return array.reduce((grouped, value) => {\n            const key = getKey(value);\n            (grouped[key] = grouped[key] || []).push(value);\n            return grouped;\n        }, {});\n    }\n}\nArrayHelper._$name = 'ArrayHelper';", "/**\n * @module Core/helper/FunctionHelper\n */\nconst\n    commaSepRe = /,\\s*/,\n    decompiledSym = Symbol('decompiled'),\n    // [async] p => ...\n    fnRe1 = /^\\s*(async\\s+)?([a-z_]\\w*)\\s*=>([\\s\\S]+)$/i,\n    // [async] (p1?[, px]*) => ...\n    fnRe2 = /^\\s*(async\\s*)?\\s*\\(((?:[a-z_]\\w*(?:, [a-z_]\\w*)*)?)\\)\\s+=>([\\s\\S]+)$/i,\n    // [async] [function] [name] (p1?[, px]*) ...\n    fnRe3 = /^(\\s*async)?(?:\\s*function)?(?:\\s*([a-z_]\\w*))?\\s*\\(((?:[a-z_]\\w*(?:, [a-z_]\\w*)*)?)\\)([\\s\\S]+)$/i,\n    { hasOwnProperty } = Object.prototype;\n/**\n * Provides functionality for working with functions\n * @internal\n */\nexport default class FunctionHelper {\n    /**\n     * Inserts a function after the specified `method` is called on an `object`. To remove this hook, invoke the\n     * function returned by this method.\n     * ```\n     *  class A {\n     *      method() {\n     *          console.log('method');\n     *      }\n     *  }\n     *\n     *  let instance = new A();\n     *\n     *  let detach = FunctionHelper.after(instance, 'method', () => { console.log('after') });\n     *\n     *  instance.method();\n     *  > method\n     *  > after\n     *\n     *  detach();\n     *  instance.method();\n     *  > method\n     * ```\n     * The value returned by the original method is passed as the first argument to `fn` followed by all the arguments\n     * passed by the caller.\n     *\n     * If `fn` returns a value (not `undefined`), that value is returned from the method call instead of the value\n     * returned by the original method.\n     * ```\n     *  class A {\n     *      method(x) {\n     *          console.log('method', x);\n     *          return x * 2\n     *      }\n     *  }\n     *\n     *  let instance = new A();\n     *\n     *  let detach = FunctionHelper.after(instance, 'method', (ret, x) => {\n     *      console.log('after', ret, x);\n     *      return x / 2;\n     *  });\n     *\n     *  console.log(instance.method(50));\n     *  > method 50\n     *  > after 100 50\n     *  > 25\n     *\n     *  detach();\n     *  console.log(instance.method(50));\n     *  > method 50\n     *  > 100\n     * ```\n     *\n     * @param {Object} object The object to hook.\n     * @param {String} method The name of the method on `object` to hook.\n     * @param {Function|String} fn The function or method name (on `thisObj`) to call after `method`.\n     * @param {Object} [thisObj] The `this` pointer value for calling `fn`.\n     * @param {Object} [options] Additional options\n     * @param {Boolean} [options.return=true] Specify `false` to not include the return value of the hooked method as\n     * the first argument to `fn`.\n     * @returns {Function} The function to call to remove the hook.\n     */\n    static after(object, method, fn, thisObj, options) {\n        const\n            named = typeof fn === 'string',\n            withReturn = options?.return !== false,\n            hook = (...args) => {\n                const\n                    // if object.destroy() occurs, our hook will be removed, so this fn won't be called in that case\n                    origResult = hook.$nextHook.call(object, ...args),\n                    hookResult = thisObj?.isDestroyed ? undefined : (withReturn\n                        ? (named ? thisObj[fn](origResult, ...args) : fn.call(thisObj, origResult, ...args))\n                        : (named ? thisObj[fn](...args) : fn.call(thisObj, ...args))\n                    );\n                return (hookResult === undefined) ? origResult : hookResult;\n            };\n        return FunctionHelper.hookMethod(object, method, hook);\n    }\n    /**\n     * Inserts a function before the specified `method` is called on an `object`. To remove this hook, invoke the\n     * function returned by this method.\n     * ```\n     *  class A {\n     *      method() {\n     *          console.log('method');\n     *      }\n     *  }\n     *\n     *  let instance = new A();\n     *\n     *  let detach = FunctionHelper.before(instance, 'method', () => { console.log('before') });\n     *\n     *  instance.method();\n     *  > before\n     *  > method\n     *\n     *  detach();\n     *  instance.method();\n     *  > method\n     * ```\n     * If `fn` returns `false`, the original method is not invoked and `false` is returned to the caller.\n     * ```\n     *  class A {\n     *      method(x) {\n     *          console.log('method', x);\n     *          return x * 2;\n     *      }\n     *  }\n     *\n     *  let instance = new A();\n     *\n     *  let detach = FunctionHelper.before(instance, 'method', x => {\n     *      console.log('before', x);\n     *      return false;\n     *  });\n     *\n     *  console.log(instance.method(50));\n     *  > before 50\n     *  > false\n     *\n     *  detach();\n     *  console.log(instance.method(50));\n     *  > method 50\n     *  > 100\n     * ```\n     *\n     * @param {Object} object The object to hook.\n     * @param {String} method The name of the method on `object` to hook.\n     * @param {Function|String} fn The function or method name (on `thisObj`) to call before `method`.\n     * @param {Object} [thisObj] The `this` pointer value for calling `fn`.\n     * @returns {Function} The function to call to remove the hook.\n     */\n    static before(object, method, fn, thisObj) {\n        const\n            named = typeof fn === 'string',\n            hook = (...args) => {\n                const ret = (thisObj?.isDestroyed\n                    ? 0\n                    : (named ? thisObj[fn](...args) : fn.call(thisObj, ...args))\n                );\n                return (ret === false) ? ret : hook.$nextHook.call(object, ...args);\n            };\n        return FunctionHelper.hookMethod(object, method, hook);\n    }\n    static curry(func) {\n        return function curried(...args) {\n            if (args.length >= func.length) {\n                return func.apply(this, args);\n            }\n            else {\n                return function(...args2) {\n                    return curried.apply(this, args.concat(args2));\n                };\n            }\n        };\n    }\n    static bindAll(obj) {\n        for (const key in obj) {\n            if (typeof obj[key] === 'function') {\n                obj[key] = obj[key].bind(obj);\n            }\n        }\n    }\n    /**\n     * Returns a function which calls the passed `interceptor` function first, and the passed `original` after\n     * as long as the `interceptor` does not return `false`.\n     * @param {Function} original The function to call second.\n     * @param {Function} interceptor The function to call first.\n     * @param {Object} [thisObj] The `this` reference when the functions are called.\n     * @returns {Function} A function which yields the return value from the `original` function **if it was called**, else `false`.\n     */\n    static createInterceptor(original, interceptor, thisObj) {\n        return function(...args) {\n            const theThis = thisObj || this;\n            if (interceptor.call(theThis, ...args) !== false) {\n                return original.call(theThis, ...args);\n            }\n            return false;\n        };\n    }\n    /**\n     * Returns a function which calls the passed `sequence` function after calling\n     * the passed `original`.\n     * @param {Function} original The function to call first.\n     * @param {Function} sequence The function to call second.\n     * @param {Object} [thisObj] The `this` reference when the functions are called.\n     * @returns {Function} A function which yields the value returned from the sequence if it returned a value, else the return\n     * value from the original function.\n     */\n    static createSequence(original, sequence, thisObj) {\n        return (...args) => {\n            const origResult = original.call(thisObj, ...args),\n                sequenceResult = sequence.call(thisObj, ...args);\n            return (sequenceResult === undefined) ? origResult : sequenceResult;\n        };\n    }\n    /**\n     * Create a \"debounced\" function which will call on the \"leading edge\" of a timer period.\n     * When first invoked will call immediately, but invocations after that inside its buffer\n     * period will be rejected, and *one* invocation will be made after the buffer period has expired.\n     *\n     * This is useful for responding immediately to a first mousemove, but from then on, only\n     * calling the action function on a regular timer while the mouse continues to move.\n     *\n     * @param {Function} fn The function to call.\n     * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.\n     * @param {Object} [thisObj] `this` reference for the function.\n     * @param {Array} [extraArgs] The argument list to append to those passed to the function.\n     * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.\n     * @returns {Function} A function which calls the passed `fn` only if at least the passed `buffer`\n     * milliseconds has elapsed since its last invocation.\n     */\n    static createThrottled(fn, buffer, thisObj, extraArgs, alt) {\n        let lastCallTime = -Number.MAX_VALUE,\n            callArgs,\n            timerId;\n        const\n            invoke = () => {\n                timerId = 0;\n                lastCallTime = performance.now();\n                callArgs.push.apply(callArgs, extraArgs);\n                fn.apply(thisObj, callArgs);\n            },\n            result = function(...args) {\n                const elapsed = performance.now() - lastCallTime;\n                callArgs = args;\n                // If it's been more then the buffer period since we invoked, we can call it now\n                if (elapsed >= buffer) {\n                    clearTimeout(timerId);\n                    invoke();\n                }\n                // Otherwise, kick off a timer for the requested period.\n                else {\n                    if (!timerId) {\n                        timerId = setTimeout(invoke, buffer - elapsed);\n                    }\n                    if (alt) {\n                        callArgs.push.apply(callArgs, extraArgs);\n                        alt.apply(thisObj, callArgs);\n                    }\n                }\n            };\n        result.cancel = () => clearTimeout(timerId);\n        return result;\n    }\n    /**\n     * Create a \"debounced\" function which will call on the \"trailing edge\" of a timer period.\n     * When first invoked will wait until the buffer period has expired to call the function, and\n     * more calls within that time will restart the timer.\n     *\n     * This is useful for responding to keystrokes, but deferring action until the user pauses typing.\n     *\n     * @param {Function} fn The function to call.\n     * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.\n     * @param {Object} [thisObj] `this` reference for the function.\n     * @param {Array} [args] The argument list to append to those passed to the function.\n     * @returns {Function} A function which calls the passed `fn` when at least the passed `buffer`\n     * milliseconds has elapsed since its last invocation.\n     */\n    static createBuffered(fn, buffer, thisObj, args) {\n        let callArgs,\n            timerId;\n        const\n            invoke = () => {\n                timerId = 0;\n                result.isPending = false;\n                callArgs.push.apply(callArgs, args);\n                fn.apply(thisObj, callArgs);\n            },\n            result = function(...args) {\n                callArgs = args;\n                // Cancel any impending invocation. It's pushed out for <buffer> ms from each call\n                if (timerId) {\n                    clearTimeout(timerId);\n                }\n                result.isPending = true;\n                timerId = setTimeout(invoke, buffer);\n            };\n        result.cancel = () => {\n            result.isPending = false;\n            clearTimeout(timerId);\n        };\n        return result;\n    }\n    static decompile(fn) {\n        if (!(decompiledSym in fn)) {\n            const code = fn.toString();\n            let m = fnRe1.exec(code),\n                args, body, name, decompiled, t;\n            if (m) {\n                // [async] p => ...\n                //   [1]   [2]  [3]\n                args = [m[2]];\n                body = m[3];\n            }\n            else if ((m /* assignment */ = fnRe2.exec(code))) {\n                // [async] (p1?[, px]*) => ...\n                //   [1]   [2]             [3]\n                t = m[2].trim();\n                args = t ? t.split(commaSepRe) : [];\n                body = m[3];\n            }\n            else if ((m /* assignment */ = fnRe3.exec(code))) {\n                // [async] [function] [name] (p1?[, px]*) ...\n                //   [1]              [2]     [3]         [4]\n                name = m[2];\n                t = m[3].trim();\n                args = t ? t.split(commaSepRe) : [];\n                body = m[4];\n            }\n            body = body?.trim();\n            fn[decompiledSym] = decompiled = m && {\n                args,\n                async : Boolean(m[1]),\n                body  : body?.startsWith('{') ? body.substring(1, body.length - 1).trim() : body\n            };\n            if (name) {\n                decompiled.name = name;\n            }\n        }\n        return fn[decompiledSym];\n    }\n    static hookMethod(object, method, hook) {\n        hook.$nextHook = object[method];\n        object[method] = hook;\n        return () => {\n            // Object will have no hooks on the instance if it is destroyed (perhaps other reasons too)\n            if (hasOwnProperty.call(object, method)) {\n                let f = object[method],\n                    next;\n                if (f === hook) {\n                    // When this is the outermost hook, we may be the last hook. If $nextHook is found on the object's\n                    // prototype, simply delete the slot to expose it. Otherwise, there's another hook, so make it the\n                    // outermost.\n                    if (Object.getPrototypeOf(object)?.[method] === hook.$nextHook) {\n                        delete object[method];\n                    }\n                    else {\n                        object[method] = hook.$nextHook;\n                    }\n                }\n                else {\n                    // Not being the outermost hook means we have outer hooks that should chain to the one we want to\n                    // remove. Be cautious because the object could be destroyed.\n                    for (; (next = f?.$nextHook); f = next) {\n                        if (next === hook) {\n                            f.$nextHook = hook.$nextHook;\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Protects the specified `method` on a given `object` such that calling it will not throw exceptions.\n     * @param {Object} object The object whose method is to be protected.\n     * @param {String} method The name of the method to protect.\n     * @param {Function} [handler] An optional function to call for any thrown exceptions.\n     * @internal\n     */\n    static noThrow(object, method, handler) {\n        const fn = object[method];\n        object[method] = (...args) => {\n            try {\n                return fn.apply(object, args);\n            }\n            catch (e) {\n                return handler?.(e);\n            }\n        };\n    }\n    static returnTrue() {\n        return true;\n    }\n    static animate(duration, fn, thisObj, easing = 'linear') {\n        let cancel = false;\n        const result = new Promise(resolve => {\n            const start = performance.now(),\n                iterate = () => {\n                    const progress = Math.min((performance.now() - start) / duration, 1),\n                        delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;\n                    if (!cancel) {\n                        if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {\n                            resolve();\n                        }\n                    }\n                    if (cancel || progress === 1) {\n                        // Push resolution into the next animation frame so that\n                        // this frame completes before the resolution handler runs.\n                        delayable.requestAnimationFrame(() => resolve());\n                    }\n                    else {\n                        delayable.requestAnimationFrame(iterate);\n                    }\n                };\n            iterate();\n        });\n        result.cancel = () => {\n            cancel = true;\n            return false;\n        };\n        return result;\n    }\n}\nconst\n    half = 0.5,\n    e1 = 1.70158,\n    e2 = 7.5625,\n    e3 = 1.525,\n    e4 = 2 / 2.75,\n    e5 = 2.25 / 2.75,\n    e6 = 1 / 2.75,\n    e7 = 1.5 / 2.75,\n    e8 = 2.5 / 2.75,\n    e9 = 2.625 / 2.75,\n    e10 = 0.75,\n    e11 = 0.9375,\n    e12 = 0.984375,\n    s1 = 1.70158,\n    s2 = 1.70158;\nFunctionHelper.easingFunctions = {\n    linear         : t => t,\n    easeInQuad     : t => Math.pow(t, 2),\n    easeOutQuad    : t => -(Math.pow((t - 1), 2) - 1),\n    easeInOutQuad  : t => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),\n    easeInCubic    : t => Math.pow(t, 3),\n    easeOutCubic   : t => Math.pow((t - 1), 3) + 1,\n    easeInOutCubic : t => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow((t - 2), 3) + 2),\n    easeInQuart    : t => Math.pow(t, 4),\n    easeOutQuart   : t => -(Math.pow((t - 1), 4) - 1),\n    easeInOutQuart : t => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),\n    easeInQuint    : t => Math.pow(t, 5),\n    easeOutQuint   : t => (Math.pow((t - 1), 5) + 1),\n    easeInOutQuint : t => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow((t - 2), 5) + 2),\n    easeInSine     : t => -Math.cos(t * (Math.PI / 2)) + 1,\n    easeOutSine    : t => Math.sin(t * (Math.PI / 2)),\n    easeInOutSine  : t => -half * (Math.cos(Math.PI * t) - 1),\n    easeInExpo     : t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo    : t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo  : t => (t === 0) ? 0 : (t === 1) ? 1 : ((t /= half) < 1) ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),\n    easeInCirc     : t => -(Math.sqrt(1 - (t * t)) - 1),\n    easeOutCirc    : t => Math.sqrt(1 - Math.pow((t - 1), 2)),\n    easeInOutCirc  : t => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeOutBounce  : t => ((t) < e6) ? (e2 * t * t) : (t < e4) ? (e2 * (t -= e7) * t + e10) : (t < e8) ? (e2 * (t -= e5) * t + e11) : (e2 * (t -= e9) * t + e12),\n    easeInBack     : t => (t) * t * ((e1 + 1) * t - e1),\n    easeOutBack    : t => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,\n    easeInOutBack  : t => {\n        let v1 = s1;\n        return ((t /= half) < 1) ? half * (t * t * (((v1 *= (e3)) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= (e3)) + 1) * t + v1) + 2);\n    },\n    elastic     : t => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,\n    swingFromTo : t => {\n        let v2 = s2;\n        return ((t /= half) < 1) ? half * (t * t * (((v2 *= (e3)) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= (e3)) + 1) * t + v2) + 2);\n    },\n    swingFrom  : t => t * t * ((e1 + 1) * t - e1),\n    swingTo    : t => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,\n    bounce     : t => (t < e6) ? (e2 * t * t) : (t < e4) ? (e2 * (t -= e7) * t + e10) : (t < e8) ? (e2 * (t -= e5) * t + e11) : (e2 * (t -= e9) * t + e12),\n    bouncePast : t => (t < e6) ? (e2 * t * t) : (t < e4) ? 2 - (e2 * (t -= e7) * t + e10) : (t < e8) ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),\n    easeFromTo : t => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),\n    easeFrom   : t => Math.pow(t, 4),\n    easeTo     : t => Math.pow(t, 0.25)\n};\nFunctionHelper._$name = 'FunctionHelper';", "/* eslint-disable bryntum/no-listeners-in-lib,bryntum/no-on-in-lib */\nimport Base from '../Base.js';\nimport ArrayHelper from '../helper/ArrayHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport VersionHelper from '../helper/VersionHelper.js';\nimport BrowserHelper from '../helper/BrowserHelper.js';\nimport FunctionHelper from '../helper/FunctionHelper.js';\nimport Objects from '../helper/util/Objects.js';\n/**\n * @module Core/mixin/Events\n */\n/**\n * @typedef {Object.<String,Function|Boolean|Object|Object[]|Number|String>} BryntumListenerConfig\n * @property {Object} [thisObj] The `this` reference for all listeners. May be overridden if a handler is specified in object form.\n * @property {Boolean} [once] Specify as `true` to remove the listener as soon as it is invoked.\n * @property {Number|Object} [expires] The listener only waits for a specified time before\n * being removed. The value may be a number or an object containing an expiry handler.\n * @property {Number} [expires.delay] How long to wait for the event for.\n * @property {String|Function} [expires.alt] The function to call when the listener expires **without having been triggered**.\n * @property {Object[]} [args] An array of arguments to be passed to the handler before the event object.\n * @property {Number} [prio] The priority for all listeners; higher priority listeners are called before lower.\n * @property {Number} [buffer] A buffer time in milliseconds to wait after last event trigger to call the handler, to reduce the amount of handler calls for frequent events.\n * @property {Number} [throttle] A millisecond timeout value to throttle event triggering. With it specified a handler\n * will be called once immediately and then all following calls during the timeout period will be grouped together into one call once per throttle period.\n */\nconst\n    // Used by the config system to flatten configs from the class hierarchy.\n    // In this case, a pure merge is not wanted. Listener definitions from\n    // every class level are collected up into an array.\n    // addListener iterates any passed array, adding each element.\n    { isArray }        = Array,\n    { hasOwnProperty } = Object.prototype,\n    // Used to distinguish event names from listener options in addListener object config.\n    specialProperties  = {\n        thisObj    : 1,\n        detachable : 1,\n        once       : 1,\n        detacher   : 1,\n        prio       : 1,\n        args       : 1,\n        expires    : 1,\n        buffer     : 1,\n        throttle   : 1,\n        name       : 1,\n        $internal  : 1\n    },\n    priorityComparator = (a, b) => b.prio - a.prio;\n/**\n * Mix this into another class to enable event handling.\n *\n * ## Basic usage\n * Listeners can be added either through config:\n *\n * ```javascript\n * let button = new Button({\n *   listeners: {\n *     click: () => {},\n *     press: () => {},\n *     ...\n *   }\n * });\n * ```\n *\n * *NOTE*: Do not reuse listeners config object, use new every time:\n * ```javascript\n * // wrong\n * let config = { click : () => {} }\n * new Button({\n *     listeners : config\n * })\n * new Button({\n *     listeners : config\n * })\n * // right\n * new Button({\n *     listeners : { click : () => {} }\n * })\n * new Button({\n *     listeners : { click : () => {} }\n * })\n * ```\n *\n * Or by calling on()/addListener():\n *\n * ```javascript\n * let button = new Button();\n *\n * button.addListener('press', () => {});\n * // on is an alias for addListener\n * button.on('click', () => {});\n * ```\n *\n * This style also accepts multiple listeners in same way as when using config:\n *\n * ```javascript\n * button.on({\n *   click: () => {},\n *   press: () => {},\n *   ...\n * });\n * ```\n *\n * ### Handlers as function name\n *\n * Event handlers may be specified as a function __name__. If a string is specified, it is the name\n * of the function in the `thisObj` object.\n *\n * If the string begins with `up.`, the owning object's ownership hierarchy\n * (if present) is scanned for an object which implements that function name:\n *\n * ```javascript\n * new Popup({\n *     tbar : {\n *         items : {\n *             myCombo : {\n *                 type      : 'combo',\n *                 editable  : false,\n *                 label     : 'Type',\n *                 listeners : {\n *                     // Look in owner chain for this function name\n *                     change : 'up.onFilterChange'\n *                 },\n *                 items     : [\n *                     'Event',\n *                     'Task',\n *                     'Appointment'\n *                 ]\n *             }\n *         }\n *     },\n *     items : {\n *         ...\n *     },\n *     onFilterChange({ value }) {\n *         // Handle event type selection here\n *     }\n * });\n *```\n *\n * ## Listener options\n * ### Once\n * Listeners can be configured to automatically deregister after first trigger by specifying config option `once`:\n *\n * ```javascript\n * button.on({\n *   click: () => {},\n *   once: true\n * });\n * ```\n *\n * ### Priority\n * Specifying priority affects the order in which listeners are called when triggering an event. Higher priorities will be\n * called before lower. Default value is 0.\n *\n * ```javascript\n * button.on({\n *   click: this.onClick,\n *   prio: 1\n * });\n * ```\n *\n * ### This reference\n * If desired, you can specify thisObj when configuring listeners. There is no need if you are using arrow functions as\n * listeners, but might be handy in other cases. Of course, you can also use bind to set `this` reference.\n *\n * ```javascript\n * button.on({\n *   click: this.onClick,\n *   thisObj: this\n * });\n *\n * // or\n *\n * button.on({\n *   click: this.onClick.bind(this)\n * });\n * ```\n *\n * ### Buffering\n * By specifying a `buffer` events that fire frequently can be grouped together and delayed. A handler for the event will be called once only, when no new event has been fired during the specified buffer time:\n *\n * ```javascript\n * button.on({\n *   click  : this.onClick,\n *   buffer : 200 // in milliseconds\n * });\n * ```\n *\n * In this example, if a user clicked the button 6 times very fast (<200ms between each click),\n * the `this.onClick` handler would be called only once 200 milliseconds after the last click.\n *\n * ### Throttling\n * Create a \"debounced\" function which will call on the \"leading edge\" of a timer period.\n * When first invoked will call immediately, but invocations after that inside its buffer\n * period will be rejected, and *one* invocation will be made after the buffer period has expired.\n *\n * This is useful for responding immediately to a first mousemove, but from then on, only\n * calling the action function on a regular timer while the mouse continues to move.\n * ```javascript\n * button.on({\n *   click    : this.onClick,\n *   throttle : 200 // in milliseconds\n * });\n * ```\n *\n * In this example, if a user clicked the button 6 times very fast, the `this.onClick` handler would be called once immediately on the first click and a second time 200 milliseconds after the **first** click.\n * So in reality the `click` event handler will be called every 200ms independent of amount of click in a middle, if the event was triggered at least once during the `throttle` timeout.\n *\n * ### Detacher\n * A convenient way of unregistering events is to use a detacher, a function returned when adding listeners that you\n * call later to deregister them. As of version 1.0, detachable defaults to true.\n *\n * ```javascript\n * let detacher = button.on({\n *   click: () => {},\n *   press: () => {},\n *   detachable: true\n * });\n *\n * // when you want to detach, for example in destroy()\n * detacher();\n * ```\n *\n * ### Auto detaching\n * When listeners are bound to a class instance using `thisObj`, the `thisObj`'s `doDestroy` method\n * is overridden to remove the listeners before calling the overridden doDestroy.\n *\n * ```javascript\n * class MyClass extends Base {\n *   construct() {\n *     let button = new Button({\n *       listeners: {\n *         click: () => {},\n *         thisObj: this\n *       }\n *     });\n *   }\n *\n *   doDestroy() {\n *     // clean up stuff\n *   }\n * }\n *\n * let myObj = new MyClass();\n * // clean up, also removes listeners\n * myObj.destroy();\n * ```\n *\n * ### On-functions\n * When mixing Events into another class it can be configured to call on-functions when events are triggered.\n * On-functions are functions named 'onEventName', for example 'onClick', 'onPress' declared on the class triggering\n * the event.\n *\n * ```javascript\n * // mix Events in with on-functions activated\n * let button = new Button({\n *   callOnFunctions: true,\n *\n *   onClick: () => {}\n * });\n *\n * // or add a getter in class declaration\n * ```\n *\n * Returning `false` from an on-function will prevent triggering listeners for the event.\n *\n * ### Catching all events\n * By specifying a listener for {@link #event-catchAll catchAll} a function can be notified when any event is triggered:\n *\n * ```javascript\n * const button = new Button({\n *    listeners : {\n *        catchAll(event) {\n *            // All events on the button will pass through here\n *        }\n *    }\n * });\n * ```\n *\n * ## Preventable events\n *\n * By returning `false` from a listener for an event documented as `preventable` the action that would otherwise be\n * executed after the event is prevented. These events are usually named `beforeXX`, for example `beforeRemove`,\n * `beforeDragStart` etc.\n *\n * <div class=\"note\">Note that Angular does not support return values from listeners. Instead, assign to\n * <code>event.returnValue</code> as shown in the Angular snippet below</div>\n *\n * {@frameworktabs}\n * {@js}\n * ```javascript\n * taskBoard.on({\n *     beforeColumnDrag({ columnRecord }) {\n *         if (columnRecord.locked) {\n *             return false;\n *         }\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     function onBeforeColumnDrag({ columnRecord }) {\n *         if (columnRecord.locked) {\n *             return false;\n *         }\n *     }\n *\n *     return (\n *         <>\n *             <BryntumTaskBoard onBeforeColumnDrag={onBeforeColumnDrag} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-task-board @beforeColumnDrag=\"onBeforeColumnDrag\" />\n * ```\n *\n * ```javascript\n * export default {\n *     methods : {\n *         onBeforeColumnDrag({ columnRecord }) {\n *             if (columnRecord.locked) {\n *                 return false;\n *             }\n *         }\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-task-board (onBeforeColumnDrag)=\"onBeforeColumnDrag({event : $event})\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     onBeforeColumnDrag({ event }: { event: any }): void {\n *         event.returnValue = !event.columnRecord.locked;\n *     }\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * @mixin\n */\nexport default Target => class Events extends (Target || Base) {\n    eventsSuspended = null;\n    static get $name() {\n        return 'Events';\n    }\n    //region Events\n    /**\n     * Fires before an object is destroyed.\n     * @event beforeDestroy\n     * @param {Core.Base} source The Object that is being destroyed.\n     */\n    /**\n     * Fires when an object is destroyed.\n     * @event destroy\n     * @param {Core.Base} source The Object that is being destroyed.\n     */\n    /**\n     * Fires when any other event is fired from the object.\n     *\n     * **Note**: `catchAll` is fired for both public and private events. Please rely on the public events only.\n     * @event catchAll\n     * @param {Object} event The Object that contains event details\n     * @param {String} event.type The type of the event which is caught by the listener\n     */\n    //endregion\n    static get declarable() {\n        return [\n            /**\n             * The list of deprecated events as an object, where `key` is an event name which is deprecated and\n             * `value` is an object which contains values for\n             * {@link Core.helper.VersionHelper#function-deprecate-static VersionHelper}:\n             * - product {String} The name of the product;\n             * - invalidAsOfVersion {String} The version where the offending code is invalid (when any compatibility\n             *   layer is actually removed);\n             * - message {String} Warning message to show to the developer using a deprecated API;\n             *\n             * For example:\n             *\n             * ```javascript\n             * return {\n             *     click : {\n             *         product            : 'Grid',\n             *         invalidAsOfVersion : '1.0.0',\n             *         message            : 'click is deprecated!'\n             *     }\n             * }\n             * ```\n             *\n             * @name deprecatedEvents\n             * @returns {Object}\n             * @static\n             * @internal\n             */\n            'deprecatedEvents'\n        ];\n    }\n    static setupDeprecatedEvents(cls, meta) {\n        const\n            all = meta.getInherited('deprecatedEvents'),\n            add = cls.deprecatedEvents;\n        for (const eventName in add) {\n            // Event names are case-insensitive so build our map using toLowerCased names (but keep true case too):\n            all[eventName.toLowerCase()] = all[eventName] = add[eventName];\n        }\n    }\n    //region Config\n    static get configurable() {\n        return {\n            /**\n             * Set to true to call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.\n             *\n             * ```javascript\n             * const container = new Container({\n             *     callOnFunctions : true\n             *\n             *     onHide() {\n             *          // Do something when the 'hide' event is fired\n             *     }\n             * });\n             * ```\n             *\n             * @config {Boolean} callOnFunctions\n             * @category Misc\n             * @default false\n             */\n            /**\n             * The listener set for this object.\n             *\n             * An object whose property names are the names of events to handle, or options which modifiy\n             * __how__ the handlers are called.\n             *\n             * See {@link #function-addListener} for details about the options.\n             *\n             * Listeners can be specified in target class config and they will be merged with any listeners specified in\n             * the instantiation config. Class listeners will be fired first:\n             *\n             * ```javascript\n             * class MyStore extends Store({\n             *     static get configurable() {\n             *         return {\n             *             listeners : {\n             *                 myCustomEvent() {\n             *                 },\n             *                 load : {\n             *                     prio : 10000,\n             *                     fn() { // this load listener handles things first }\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             *\n             * let store = new MyStore({\n             *   listeners: {\n             *     load: () => { // This load listener runs after the class's },\n             *     ...\n             *   }\n             * });\n             * ```\n             *\n             * ### Handlers as function name\n             *\n             * Object event handlers may be specified as a function __name__. If a string is specified, it is the name\n             * of the function in the `thisObj` object.\n             *\n             * If the string begins with `up.`, this object's ownership hierarchy\n             * (if present) is scanned for an object which implements that function name:\n             *\n             * ```javascript\n             * new Popup({\n             *     tbar : {\n             *         items : {\n             *             myCombo : {\n             *                 type      : 'combo',\n             *                 editable  : false,\n             *                 label     : 'Type',\n             *                 listeners : {\n             *                     // Look in owner chain for this function name\n             *                     change : 'up.onFilterChange'\n             *                 },\n             *                 items     : [\n             *                     'Event',\n             *                     'Task',\n             *                     'Appointment'\n             *                 ]\n             *             }\n             *         }\n             *     },\n             *     items : {\n             *         ...\n             *     },\n             *     onFilterChange({ value }) {\n             *         // Handle event type selection here\n             *     }\n             * });\n             *```\n             *\n             * @config {Object}\n             * @category Common\n             */\n            listeners : {\n                value : null,\n                $config : {\n                    merge(newValue, currentValue) {\n                        if (newValue !== null) {\n                            if (!newValue) {\n                                return currentValue;\n                            }\n                            if (currentValue) {\n                                newValue = newValue ? [newValue] : [];\n                                newValue.push[isArray(currentValue) ? 'apply' : 'call'](newValue, currentValue);\n                            }\n                        }\n                        return newValue;\n                    }\n                }\n            },\n            /**\n             * Internal listeners, that cannot be removed by the user.\n             * @config {Object}\n             * @internal\n             */\n            internalListeners : null,\n            /**\n             * An object where property names with a truthy value indicate which events should bubble up the ownership\n             * hierarchy when triggered.\n             *\n             * ```javascript\n             * const container = new Container({\n             *     items : [\n             *        { type : 'text', bubbleEvents : { change : true }}\n             *     ],\n             *\n             *     listeners : {\n             *         change() {\n             *             // Will catch change event from the text field\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Object}\n             * @category Misc\n             */\n            bubbleEvents : null\n        };\n    }\n    destroy() {\n        this.trigger('beforeDestroy');\n        super.destroy();\n    }\n    //endregion\n    //region Init\n    construct(config, ...args) {\n        // Configured listeners use this as the thisObj\n        if ((this.configuredListeners /* assignment */ = config?.listeners)) {\n            // We have to copy in case listeners have been forked\n            config = Objects.assign({}, config);\n            delete config.listeners;\n        }\n        super.construct(config, ...args);\n        // Apply configured listeners after construction.\n        // Note that some classes invoke this during parts of their construction.\n        // Store invokes this prior to setting data so that observers are notified of data load.\n        this.processConfiguredListeners();\n    }\n    processConfiguredListeners() {\n        // This can only happen once\n        if (this.configuredListeners) {\n            const\n                me                = this,\n                { isConfiguring } = me;\n            // If called from config ingestion during configuration, listeners must be added\n            // so temporarily clear the isConfiguring flag.\n            me.isConfiguring = false;\n            me.listeners = me.configuredListeners;\n            me.configuredListeners = null;\n            me.isConfiguring = isConfiguring;\n        }\n    }\n    /**\n     * Auto detaches listeners registered from start, if set as detachable\n     * @internal\n     */\n    doDestroy() {\n        this.trigger('destroy');\n        this.removeAllListeners(false);\n        super.doDestroy();\n    }\n    static setupClass(meta) {\n        super.setupClass(meta);\n        Events.prototype.onListen.$nullFn = true;\n        Events.prototype.onUnlisten.$nullFn = true;\n    }\n    //endregion\n    //region Listeners\n    /**\n     * Adds an event listener. This method accepts parameters in the following format:\n     *\n     * ```javascript\n     *  myObject.addListener({\n     *      thisObj    : this,          // The this reference for the handlers\n     *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,\n     *      otherevent : {\n     *          fn      : 'handlerFnName',\n     *          once    : true          // Just this handler is auto-removed on fire\n     *      },\n     *      yetanother  : {\n     *          fn      : 'yetAnotherHandler',\n     *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler\n     *      },\n     *      prio        : 100           // Higher prio listeners are called before lower\n     *  });\n     * ```\n     *\n     * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.\n     * When it is destroyed, those listeners are removed.\n     *\n     * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.\n     *\n     * A simpler signature may be used when only adding a listener for one event and no extra options\n     * (such as `once` or `delay`) are required:\n     *\n     * ```javascript\n     * myObject.addListener('click', myController.handleClicks, myController);\n     * ```\n     *\n     * The args in this simple case are `eventName`, `handler` and `thisObj`\n     *\n     * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for\n     * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler\n     * function to call if providing a string as the first arg.\n     * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..\n     * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners\n     */\n    addListener(config, thisObj, oldThisObj) {\n        if (isArray(config)) {\n            for (let i = 0, { length } = config; i < length; i++) {\n                this.addListener(config[i], thisObj);\n            }\n            return;\n        }\n        const\n            me               = this,\n            deprecatedEvents = me.$meta.getInherited('deprecatedEvents');\n        if (typeof config === 'string') {\n            // arguments[2] is thisObj if (eventname, handler, thisObj) form called.\n            // Note that the other side of the if compares to undefined, so this will work.\n            return me.addListener({\n                [config]   : thisObj,\n                detachable : thisObj.detachable !== false,\n                thisObj    : oldThisObj\n            });\n        }\n        else {\n            // Capture the default thisObj.\n            thisObj = config.thisObj = config.thisObj !== undefined ? config.thisObj : thisObj;\n            for (const key in config) {\n                // Skip special properties or events without handlers (convenient syntax with optional handlers)\n                if (!specialProperties[key] && config[key] != null) {\n                    // comparing should be case insensitive\n                    const\n                        // comparing should be case insensitive\n                        eventName       = key.toLowerCase(),\n                        deprecatedEvent = deprecatedEvents?.[eventName],\n                        events          = me.eventListeners || (me.eventListeners = {}),\n                        listenerSpec    = config[key],\n                        expires         = listenerSpec.expires || config.expires,\n                        listener        = {\n                            fn        : typeof listenerSpec === 'object' ? listenerSpec.fn : listenerSpec,\n                            thisObj   : listenerSpec.thisObj !== undefined ? listenerSpec.thisObj : thisObj,\n                            args      : listenerSpec.args || config.args,\n                            prio      : listenerSpec.prio !== undefined ? listenerSpec.prio : config.prio !== undefined ? config.prio : 0,\n                            once      : listenerSpec.once !== undefined ? listenerSpec.once : config.once !== undefined ? config.once : false,\n                            buffer    : listenerSpec.buffer || config.buffer,\n                            throttle  : listenerSpec.throttle || config.throttle,\n                            $internal : config.$internal,\n                            catchAll  : key === 'catchAll'\n                        };\n                    if (deprecatedEvent) {\n                        const { product, invalidAsOfVersion, message } = deprecatedEvent;\n                        VersionHelper.deprecate(product, invalidAsOfVersion, message);\n                    }\n                    if (expires) {\n                        // Extract expires : { delay : 100, alt : 'onExpireFn' }\n                        const\n                            { alt } = expires,\n                            delay   = alt ? expires.delay : expires,\n                            name    = config.name || key,\n                            fn      = () => {\n                                me.un(eventName, listener);\n                                // If we make it here and the handler has not been called, invoke the alt handler\n                                if (alt && !listener.called) {\n                                    me.callback(alt, thisObj);\n                                }\n                            };\n                        if (me.isDelayable) {\n                            me.setTimeout({ fn, name, cancelOutstanding : true, delay });\n                        }\n                        else {\n                            globalThis.setTimeout(fn, delay);\n                        }\n                    }\n                    let listeners = events[eventName] || (events[eventName] = []);\n                    if (listeners.$firing) {\n                        events[eventName] = listeners = listeners.slice();\n                    }\n                    // Insert listener directly in prio order\n                    listeners.splice(\n                        ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length),\n                        0, listener);\n                    if (!me.onListen.$nullFn && listeners.length < 2) {\n                        me.onListen(eventName);\n                    }\n                }\n            }\n            if (config.relayAll) {\n                me.relayAll(config.relayAll);\n            }\n            // Hook into the thisObj's destruction sequence to remove these listeners.\n            // Pass the default thisObj in for use when it comes to destruction time.\n            if (thisObj && thisObj !== me) {\n                me.attachAutoDetacher(config, thisObj);\n            }\n            const\n                detachable = config.detachable !== false,\n                name       = config.name,\n                destroy    = (config.expires || detachable || name) ? () => {\n                    // drop listeners if not destroyed yet\n                    if (!me.isDestroyed) {\n                        me.removeListener(config, thisObj);\n                    }\n                } : null;\n            if (destroy) {\n                destroy.eventer = me;\n                destroy.listenerName = name;\n                if (name && thisObj?.trackDetacher) {\n                    thisObj.trackDetacher(name, destroy);\n                }\n                if (config.expires) {\n                    // handle expires : { alt : timeoutHandler, delay : 2000 }\n                    me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);\n                }\n                if (detachable) {\n                    return destroy;\n                }\n            }\n        }\n    }\n    /**\n     * Alias for {@link #function-addListener}. Adds an event listener. This method accepts parameters in the following format:\n     *\n     * ```javascript\n     *  myObject.on({\n     *      thisObj    : this,          // The this reference for the handlers\n     *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,\n     *      otherevent : {\n     *          fn      : 'handlerFnName',\n     *          once    : true          // Just this handler is auto-removed on fire\n     *      },\n     *      yetanother  : {\n     *          fn      : 'yetAnotherHandler',\n     *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler\n     *      },\n     *      prio        : 100           // Higher prio listeners are called before lower\n     *  });\n     * ```\n     *\n     * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.\n     * When it is destroyed, those listeners are removed.\n     *\n     * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.\n     *\n     * A simpler signature may be used when only adding a listener for one event and no extra options\n     * (such as `once` or `delay`) are required:\n     *\n     * ```javascript\n     * myObject.on('click', myController.handleClicks, myController);\n     * ```\n     *\n     * The args in this simple case are `eventName`, `handler` and `thisObj`\n     *\n     * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for\n     * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler\n     * function to call if providing a string as the first arg.\n     * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..\n     * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners\n     */\n    on(config, thisObj, oldThisObj) {\n        return this.addListener(config, thisObj, oldThisObj);\n    }\n    /**\n     * Internal convenience method for adding an internal listener, that cannot be removed by the user.\n     *\n     * Alias for `on({ $internal : true, ... })`. Only supports single argument form.\n     *\n     * @internal\n     */\n    ion(config) {\n        config.$internal = true;\n        return this.on(config);\n    }\n    /**\n     * Shorthand for {@link #function-removeListener}\n     * @param {Object|String} config A config object or the event name\n     * @param {Object|Function} [thisObj] `this` reference for all listeners, or the listener function\n     * @param {Object} [oldThisObj] `this` The `this` object for the legacy way of adding listeners\n     */\n    un(...args) {\n        this.removeListener(...args);\n    }\n    updateInternalListeners(internalListeners, oldInternalListeners) {\n        oldInternalListeners?.detach();\n        if (internalListeners) {\n            internalListeners.detach = this.ion(internalListeners);\n        }\n    }\n    get listeners() {\n        return this.eventListeners;\n    }\n    changeListeners(listeners) {\n        // If we are receiving class listeners, add them early, and they do not become\n        // the configured listeners, and are not removed by setting listeners during the lifecycle.\n        if (this.isConfiguring) {\n            // Pull in internal listeners first\n            this.getConfig('internalListeners');\n            if (listeners) {\n                this.on(listeners, this);\n            }\n        }\n        // Setting listeners after config time clears the old set and adds the new.\n        // This will initially happen at the tail end of the constructor when config\n        // listeners are set.\n        else {\n            // Configured listeners use this as the thisObj by default.\n            // Flatten using Objects.assign because it may have been part of\n            // a prototype chained default configuration of another object.\n            // eg: the tooltip config of a Widget.\n            // listener object blocks from multiple configuration levels are pushed\n            // onto an array (see listeners merge function in configurable block above).\n            // If this has happened, each entry must be processed like this.\n            if (Array.isArray(listeners)) {\n                for (let i = 0, l = listeners[0], { length } = listeners; i < length; l = listeners[++i]) {\n                    if (!('thisObj' in l)) {\n                        listeners[i] = Objects.assign({ thisObj : this }, l);\n                    }\n                }\n            }\n            else if (listeners && !('thisObj' in listeners)) {\n                listeners = Objects.assign({ thisObj : this }, listeners);\n            }\n            return listeners;\n        }\n    }\n    updateListeners(listeners, oldListeners) {\n        // Only configured listeners get here. Class listeners are added by changeListeners.\n        oldListeners && this.un(oldListeners);\n        listeners && this.on(listeners);\n    }\n    /**\n     * Removes an event listener. Same API signature as {@link #function-addListener}\n     * @param {Object|String} config A config object or the event name\n     * @param {Object|Function} thisObj `this` reference for all listeners, or the listener function\n     * @param {Object} oldThisObj `this` The `this` object for the legacy way of adding listeners\n     */\n    removeListener(config, thisObj = config.thisObj, oldThisObj) {\n        const me = this;\n        if (typeof config === 'string') {\n            return me.removeListener({ [config] : thisObj }, oldThisObj);\n        }\n        Object.entries(config).forEach(([eventName, listenerToRemove]) => {\n            if (!specialProperties[eventName] && listenerToRemove != null) {\n                eventName = eventName.toLowerCase();\n                const\n                    eventListeners = me.eventListeners,\n                    index = me.findListener(eventName, listenerToRemove, thisObj);\n                if (index >= 0) {\n                    let listeners = eventListeners[eventName];\n                    if (listeners.length > 1) {\n                        if (listeners.$firing) {\n                            eventListeners[eventName] = listeners = listeners.slice();\n                        }\n                        // NOTE: we cannot untrack any detachers here because we may only be\n                        // removing some of its listeners\n                        listeners.splice(index, 1);\n                    }\n                    else {\n                        delete eventListeners[eventName];\n                        if (!me.onUnlisten.$nullFn) {\n                            me.onUnlisten(eventName);\n                        }\n                    }\n                }\n            }\n        });\n        if (config.thisObj && !config.thisObj.isDestroyed) {\n            me.detachAutoDetacher(config);\n        }\n    }\n    /**\n     * Finds the index of a particular listener to the named event. Returns `-1` if the passed\n     * function/thisObj listener is not present.\n     * @param {String} eventName The name of an event to find a listener for.\n     * @param {String|Function} listenerToFind The handler function to find.\n     * @param {Object} defaultThisObj The `thisObj` for the required listener.\n     * @internal\n     */\n    findListener(eventName, listenerToFind, defaultThisObj) {\n        const\n            eventListeners = this.eventListeners?.[eventName],\n            fn             = listenerToFind.fn || listenerToFind,\n            thisObj        = listenerToFind.thisObj || defaultThisObj;\n        if (eventListeners) {\n            for (let listenerEntry, i = 0, { length } = eventListeners; i < length; i++) {\n                listenerEntry = eventListeners[i];\n                if (listenerEntry.fn === fn && listenerEntry.thisObj === thisObj) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * Check if any listener is registered for the specified eventName\n     * @param {String} eventName\n     * @returns {Boolean} `true` if listener is registered, otherwise `false`\n     */\n    hasListener(eventName) {\n        return Boolean(this.eventListeners?.[eventName?.toLowerCase()]);\n    }\n    /**\n     * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name\n     * before relaying, for example add -> storeAdd\n     * ```\n     * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:\n     * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.\n     * store.relayAll(grid, 'store');\n     *\n     * grid.on('storeLoad', () => console.log('Store loaded');\n     * ```\n     * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in\n     * @param {String} prefix Prefix to add to event name\n     * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase\n     */\n    relayAll(through, prefix, transformCase = true) {\n        if (!this.relayAllTargets) {\n            this.relayAllTargets = [];\n        }\n        const relayAllTargets = this.relayAllTargets;\n        through.on({\n            beforeDestroy : ({ source }) => {\n                if (source === through) {\n                    const configs = relayAllTargets.filter(r => r.through === through);\n                    configs.forEach(config => ArrayHelper.remove(relayAllTargets, config));\n                }\n            }\n        });\n        relayAllTargets.push({ through, prefix, transformCase });\n    }\n    /**\n     * Removes all listeners registered to this object by the application.\n     */\n    removeAllListeners(preserveInternal = true) {\n        const listeners = this.eventListeners;\n        let i, thisObj;\n        for (const event in listeners) {\n            const bucket = listeners[event];\n            // We iterate backwards since we call removeListener which will splice out of\n            // this array as we go...\n            for (i = bucket.length; i-- > 0; /* empty */) {\n                const cfg = bucket[i];\n                if (!cfg.$internal || !preserveInternal) {\n                    this.removeListener(event, cfg);\n                    thisObj = cfg.thisObj;\n                    thisObj?.untrackDetachers?.(this);\n                }\n            }\n        }\n    }\n    relayEvents(source, eventNames, prefix = '') {\n        const listenerConfig = { detachable : true, thisObj : this };\n        eventNames.forEach(eventName => {\n            listenerConfig[eventName] = (event, ...params) => {\n                return this.trigger(prefix + eventName, event, ...params);\n            };\n        });\n        return source.on(listenerConfig);\n    }\n    /**\n     * This method is called when the first listener for an event is added.\n     * @param {String} eventName\n     * @internal\n     */\n    onListen() {}\n    /**\n     * This method is called when the last listener for an event is removed.\n     * @param {String} eventName\n     * @internal\n     */\n    onUnlisten() {}\n    destructorInterceptor() {\n        const { autoDetachers, target, oldDestructor } = this;\n        // Remove listeners first, so that they do not fire during destruction.\n        // The observable being listened to by the thisObj may already have\n        // been destroyed in a clean up sequence\n        for (let i = 0; i < autoDetachers.length; i++) {\n            const { dispatcher, config } = autoDetachers[i];\n            if (!dispatcher.isDestroyed) {\n                dispatcher.removeListener(config, target);\n            }\n        }\n        oldDestructor.call(target);\n    }\n    /**\n     * Internal function used to hook destroy() calls when using thisObj\n     * @private\n     */\n    attachAutoDetacher(config, thisObj) {\n        const\n            target         = config.thisObj || thisObj,\n            // If it's a Bryntum Base subclass, hook doDestroy, otherwise, destroy\n            destructorName = ('doDestroy' in target) ? 'doDestroy' : 'destroy';\n        if (destructorName in target) {\n            let { $autoDetachers } = target;\n            if (!$autoDetachers) {\n                target.$autoDetachers = $autoDetachers = [];\n            }\n            if (!target.$oldDestructor) {\n                target.$oldDestructor = target[destructorName];\n                // Binding instead of using closure (used to use FunctionHelper.createInterceptor) to not retain target\n                // when detaching manually\n                target[destructorName] = this.destructorInterceptor.bind({\n                    autoDetachers : $autoDetachers,\n                    oldDestructor : target.$oldDestructor,\n                    target\n                });\n            }\n            $autoDetachers.push({ config, dispatcher : this });\n        }\n        else {\n            target[destructorName] = () => {\n                this.removeListener(config);\n            };\n        }\n    }\n    /**\n     * Internal function used restore hooked destroy() calls when using thisObj\n     * @private\n     */\n    detachAutoDetacher(config) {\n        const target = config.thisObj;\n        // Restore old destructor and remove from auto detachers only if we are not called as part of destruction.\n        // (Altering $autoDetachers affects destruction iterating over them, breaking it. It is pointless to clean up\n        // during destruction anyway, since everything gets removed)\n        if (target.$oldDestructor && !target.isDestroying) {\n            ArrayHelper.remove(\n                target.$autoDetachers,\n                target.$autoDetachers.find(detacher => detacher.config === config && detacher.dispatcher === this)\n            );\n            if (!target.$autoDetachers.length) {\n                target['doDestroy' in target ? 'doDestroy' : 'destroy'] = target.$oldDestructor;\n                target.$oldDestructor = null;\n            }\n        }\n    }\n    //endregion\n    //region Promise based workflow\n    // experimental, used in tests to support async/await workflow\n    await(eventName, options = { checkLog : true, resetLog : true, args : null }) {\n        const me = this;\n        if (options === false) {\n            options = { checkLog : false };\n        }\n        const { args } = options;\n        return new Promise(resolve => {\n            // check if previously triggered?\n            if (options.checkLog && me._triggered?.[eventName]) {\n                // resolve immediately, no params though...\n                resolve();\n                // reset log to be able to await again\n                if (options.resetLog) {\n                    me.clearLog(eventName);\n                }\n            }\n            // This branch will listen for events until catches one with specific arguments\n            if (args) {\n                const detacher = me.on({\n                    [eventName] : (...params) => {\n                        const argsOk = Object.keys(args).every(key => {\n                            return key in params[0] && params[0][key] === args[key];\n                        });\n                        if (argsOk) {\n                            // resolve when event is fired with required arguments\n                            resolve(...params);\n                            // reset log to be able to await again\n                            if (options.resetLog) {\n                                me.clearLog(eventName);\n                            }\n                            detacher();\n                        }\n                    },\n                    prio : -10000 // Let others do their stuff first\n                });\n            }\n            else {\n                me.on({\n                    [eventName] : (...params) => {\n                        // resolve when event is caught\n                        resolve(...params);\n                        // reset log to be able to await again\n                        if (options.resetLog) {\n                            me.clearLog(eventName);\n                        }\n                    },\n                    prio : -10000, // Let others do their stuff first\n                    once : true // promises can only be resolved once anyway\n                });\n            }\n        });\n    }\n    clearLog(eventName) {\n        if (this._triggered) {\n            if (eventName) {\n                delete this._triggered[eventName];\n            }\n            else {\n                this._triggered = {};\n            }\n        }\n    }\n    //endregion\n    //region Trigger\n    /**\n     * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener\n     * makes function return false.\n     * @param {String} eventName Event name for which to trigger listeners\n     * @param {Object} [param] Single parameter passed on to listeners, source property will be added to it (this)\n     * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget\n     * ownership hierarchy. For example up a `Menu`->`parent` Menu tree, or a `Field`->`Container` tree.\n     * @typings param -> {{bubbles?: boolean, [key: string]: any}}\n     * @returns {Boolean|Promise} Returns false if any listener returned `false`, or a `Promise` yielding\n     * `true` / `false` based on what is returned from the async listener functions, otherwise `true`\n     * @async\n     */\n    trigger(eventName, param) {\n        const\n            me   = this,\n            name = eventName.toLowerCase(),\n            {\n                eventsSuspended,\n                relayAllTargets,\n                callOnFunctions\n            }   = me;\n        let listeners = me.eventListeners?.[name],\n            handlerPromises;\n        // log trigger, used by experimental promise support to resolve immediately when needed\n        if (!me._triggered) {\n            me._triggered = {};\n        }\n        me._triggered[eventName] = true;\n        if (eventsSuspended) {\n            if (eventsSuspended.shouldQueue) {\n                eventsSuspended.queue.push(arguments);\n            }\n            return true;\n        }\n        // Include catchall listener for all events.\n        // Do not push the catchAll listeners onto the events own listener array.\n        if (me.eventListeners?.catchall) {\n            (listeners = (listeners ? listeners.slice() : [])).push(...me.eventListeners.catchall);\n            // The catchAll listeners must honour their prio settings.\n            listeners.sort(priorityComparator);\n        }\n        if (!listeners && !relayAllTargets && !callOnFunctions) {\n            return true;\n        }\n        // default to include source : this in param\n        if (param) {\n            if (!('source' in param)) {\n                if (Object.isExtensible(param)) {\n                    param.source = me;\n                }\n                else {\n                    param = Object.setPrototypeOf({\n                        source : me\n                    }, param);\n                }\n            }\n        }\n        else {\n            param = {\n                source : me\n            };\n        }\n        // Lowercased event name should be the \"type\" property in keeping with DOM events.\n        if (param.type !== name) {\n            // Create instance property because \"type\" is read only\n            if (param.constructor !== Object) {\n                Reflect.defineProperty(param, 'type', { get : () => name });\n            }\n            else {\n                param.type = name;\n            }\n        }\n        param.eventName = eventName;\n        // Bubble according to `bubbleEvents` config if `bubbles` is not explicitly set\n        if (!('bubbles' in param) && me.bubbleEvents?.[eventName]) {\n            param.bubbles = me.bubbleEvents[eventName];\n        }\n        if (callOnFunctions) {\n            const fnName = 'on' + StringHelper.capitalize(eventName);\n            if (fnName in me) {\n                // Return true if the on[fnName] is not set to keep default behavior\n                const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;\n                let inhibit;\n                if (Objects.isPromise(result)) {\n                    (handlerPromises || (handlerPromises = [])).push(result);\n                }\n                else {\n                    inhibit = result === false || inhibit;\n                }\n                // See if the called function was injected into the instance\n                // masking an implementation in the prototype.\n                // we must call the class's implementation after the injected one.\n                // unless it's an injected chained function, in which case it will have been called above.\n                // Note: The handler may have resulted in destruction.\n                if (!me.isDestroyed && hasOwnProperty.call(me, fnName) && !me.pluginFunctionChain?.[fnName]) {\n                    const myProto = Object.getPrototypeOf(me);\n                    if (fnName in myProto) {\n                        const result = myProto[fnName].call(me, param);\n                        if (Objects.isPromise(result)) {\n                            (handlerPromises || (handlerPromises = [])).push(result);\n                        }\n                        else {\n                            inhibit = result === false || inhibit;\n                        }\n                        // A handler may have resulted in destruction.\n                        if (me.isDestroyed) {\n                            return;\n                        }\n                    }\n                }\n                // Returning false from an on-function prevents further triggering\n                if (inhibit) {\n                    return false;\n                }\n            }\n        }\n        let ret;\n        if (listeners) {\n            let i = 0, internalAbort = false;\n            // Let add/removeListener know that we're using the array to protect against a situation where an event\n            // listener changes the listeners when triggering the event.\n            listeners.$firing = true;\n            // If any listener resulted in our destruction, abort.\n            for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {\n                const listener = listeners[i];\n                // Previously, returning false would abort all further listeners. But now internal listeners\n                // are allowed to run anyway\n                if (ret === false && !listener.$internal) {\n                    continue;\n                }\n                let handler,\n                    thisObj = listener.thisObj;\n                // Listeners that have thisObj are auto removed when thisObj is destroyed. If thisObj is destroyed from\n                // a listener we might still end up here, since listeners are sliced and not affected by the removal\n                if (!thisObj || !thisObj.isDestroyed) {\n                    // Flag for the expiry timer\n                    listener.called = true;\n                    if (listener.once) {\n                        me.removeListener(name, listener);\n                    }\n                    // prepare handler function\n                    if (typeof listener.fn === 'string') {\n                        if (thisObj) {\n                            handler = thisObj[listener.fn];\n                        }\n                        // keep looking for the callback in the hierarchy\n                        if (!handler) {\n                            const result = me.resolveCallback(listener.fn);\n                            handler = result.handler;\n                            thisObj = result.thisObj;\n                        }\n                    }\n                    else {\n                        handler = listener.fn;\n                    }\n                    // if `buffer` option is provided, the handler will be wrapped into buffer function,\n                    // but only once on the first call\n                    if (listener.buffer) {\n                        if (!listener.bufferFn) {\n                            const buffer = Number(listener.buffer);\n                            if (typeof buffer !== 'number' || isNaN(buffer)) {\n                                throw new Error(`Incorrect type for buffer, got \"${buffer}\" (expected a Number)`);\n                            }\n                            listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);\n                        }\n                        handler = listener.bufferFn;\n                    }\n                    // if `throttle` option is provided, the handler will be called immediately, but all the rest calls\n                    // that happened during time specified in `throttle`, will be delayed and glued into 1 call\n                    if (listener.throttle) {\n                        const throttle = Number(listener.throttle);\n                        if (typeof throttle !== 'number' || isNaN(throttle)) {\n                            throw new Error(`Incorrect type for throttle, got \"${throttle}\" (expected a Number)`);\n                        }\n                        if (!listener.throttledFn) {\n                            listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);\n                        }\n                        handler = listener.throttledFn;\n                    }\n                    const result = handler.call(thisObj || me, ...(listener.args || []), param);\n                    // Store result until we get a false return value, to mimic the old behavior from before we carried\n                    // on with calling internal listeners\n                    if (ret !== false) {\n                        ret = result;\n                    }\n                    if (listener.$internal && result === false) {\n                        internalAbort = true;\n                    }\n                    if (Objects.isPromise(result)) {\n                        result.$internal = listener.$internal;\n                        // If a handler is async (returns a Promise), then collect all Promises.\n                        // At the end we return a Promise which encapsulates all returned Promises\n                        // or, if only one handler was async, *the* Promise.\n                        // Don't allocate an Array until we have to.\n                        (handlerPromises || (handlerPromises = [])).push(result);\n                    }\n                }\n            }\n            listeners.$firing = false;\n            // An internal listener returned `false`, abort before relaying events etc.\n            if (internalAbort) {\n                return false;\n            }\n        }\n        // relay all?\n        relayAllTargets?.forEach(config => {\n            let name = eventName;\n            if (config.transformCase) {\n                name = StringHelper.capitalize(name);\n            }\n            if (config.prefix) {\n                name = config.prefix + name;\n            }\n            if (config.through.trigger(name, param) === false) {\n                return false;\n            }\n        });\n        // Use DOM standard event property name to indicate that the event\n        // bubbles up the owner axis.\n        // False from any handler cancels the bubble.\n        // Must also avoid owner if any handlers destroyed the owner.\n        if (param.bubbles && me.owner && !me.owner.isDestroyed) {\n            return me.owner.trigger(eventName, param);\n        }\n        // Run internal promises even if external listener returned false\n        handlerPromises = handlerPromises?.filter(p => ret !== false || p.$internal);\n        // If any handlers were async functions (returned a Promise), then return a Promise\n        // which resolves when they all resolve.\n        if (handlerPromises?.length) {\n            return new Promise(resolve => {\n                Promise.all(handlerPromises).then(promiseResults => {\n                    const finalResult = !promiseResults.some(result => result === false);\n                    resolve(finalResult);\n                });\n            });\n        }\n        return ret !== false;\n    }\n    /**\n     * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while\n     * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.\n     * @param {Boolean} queue Specify true to queue events triggered while suspended\n     */\n    suspendEvents(queue = false) {\n        const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = { shouldQueue : queue, queue : [], count : 0 });\n        eventsSuspended.count++;\n    }\n    /**\n     * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.\n     * @returns {Boolean} `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).\n     */\n    resumeEvents() {\n        const suspended = this.eventsSuspended;\n        if (suspended) {\n            if (--suspended.count === 0) {\n                this.eventsSuspended = null;\n                if (suspended.shouldQueue) {\n                    for (const queued of suspended.queue) {\n                        this.trigger(...queued);\n                    }\n                }\n            }\n        }\n        return !Boolean(this.eventsSuspended);\n    }\n    //endregion\n};\n", "/**\n * @module Core/localization/LocaleHelper\n */\n/**\n * @typedef {Object} LocaleKeys\n * Object which contains `key: value` localization pairs.\n * Key value may have `String`, `Function`, `LocaleKeys` or `Object` type.\n *\n * Example:\n *\n * ```javascript\n * {\n *     title   : 'Title',\n *     count   : number => `Count is ${number}`,\n *     MyClass : {\n *        foo : 'bar'\n *     }\n * }\n * ```\n *\n * @property {String|Function|LocaleKeys|Object} key localization key\n * @typings {[key: string]}:{string|number|Function|LocaleKeys|object}\n */\n/**\n * @typedef {LocaleKeys} Locale\n * Locale configuration object which contains locale properties alongside with localization pairs.\n *\n * Example:\n *\n * ```javascript\n {\n *     localeName : 'En',\n *     localeDesc : 'English (US)',\n *     localeCode : 'en-US',\n *     ... (localization key:value pairs)\n * }\n * ```\n *\n * @property {String} localeName Locale name. For example: \"En\"\n * @property {String} localeDesc Locale description to be shown in locale picker list. For example: \"English (US)\"\n * @property {String} localeCode Locale code. Two letter locale code or two letter locale and two letter country code.\n * For example: \"en\" or 'en_US'\n * @property {String} [localePath] Locale path for asynchronous loading using\n * AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request\n */\n/**\n * @typedef {Object} Locales\n * Object which contains locales. Each object key represents published locale by its `localeName`.\n *\n * Example:\n *\n * ```javascript\n * // This returns English locale.\n * const englishLocale = LocaleHelper.locales.En;\n * ```\n *\n * @property {Locale} key localization object\n * @typings {[key: string]}:{Locale}\n */\n/**\n * Thin class which provides locale management methods.\n * Class doesn't import other API classes and can be used separately for publishing locales before importing product classes.\n *\n * Locale should be published with {@link ##function-publishLocale-static} method before it is available for localizing of Bryntum API classes and widgets.\n *\n * Example:\n *\n * ```javascript\n * LocaleHelper.publishLocale({\n *     localeName : 'En',\n *     localeDesc : 'English (US)',\n *     localeCode : 'en-US',\n *     ... (localization key:value pairs)\n * });\n * ```\n *\n * or for asynchronous loading from remote path on applying locale\n *\n * ```javascript\n *LocaleHelper.publishLocale({\n *     localeName : 'En',\n *     localeDesc : 'English (US)',\n *     localeCode : 'en-US',\n *     localePath : 'https://my-server/localization/en.js'\n * });\n * ```\n */\nexport default class LocaleHelper {\n    static skipLocaleIntegrityCheck = false;\n    /**\n     * Merges all properties of provided locale objects into new locale object.\n     * Locales are merged in order they provided and locales which go later replace\n     * same properties of previous locales.\n     * @param {...Object} locales Locales to merge\n     * @returns {Object} Merged locale\n     */\n    static mergeLocales(...locales) {\n        const result = {};\n        locales.forEach(locale => {\n            Object.keys(locale).forEach(key => {\n                if (typeof locale[key] === 'object') {\n                    result[key] = { ...result[key], ...locale[key] };\n                }\n                else {\n                    result[key] = locale[key];\n                }\n            });\n        });\n        return result;\n    }\n    /**\n     * Removes all properties from `locale` that are present in the provided `toTrim`.\n     * @param {Object} locale Locale to process\n     * @param {Object} toTrim Object enumerating properties that should be removed.\n     * When `false` throws exceptions in such cases.\n     */\n    static trimLocale(locale, toTrim) {\n        const remove = (key, subKey) => {\n            if (locale[key]) {\n                if (subKey) {\n                    if (locale[key][subKey]) {\n                        delete locale[key][subKey];\n                    }\n                }\n                else {\n                    delete locale[key];\n                }\n            }\n        };\n        Object.keys(toTrim).forEach(key => {\n            if (Object.keys(toTrim[key]).length > 0) {\n                Object.keys(toTrim[key]).forEach(subKey => remove(key, subKey));\n            }\n            else {\n                remove(key);\n            }\n        });\n    }\n    /**\n     * Normalizes locale object to {@link Locale} type.\n     *\n     * Supported configs:\n     *\n     * ```javascript\n     * LocaleHelper.normalizeLocale({\n     *     localeName : 'En',\n     *     localeDesc : 'English (US)',\n     *     localeCode : 'en-US',\n     *     ... (localization key:value pairs)\n     * });\n     * ```\n     *\n     * and for backward compatibility\n     *\n     * ```javascript\n     * LocaleHelper.normalizeLocale('En', {\n     *     name : 'En',\n     *     desc : 'English (US)',\n     *     code : 'en-US',\n     *     locale : {\n     *         ... (localization key:value pairs)\n     *     }\n     * });\n     * ```\n     * @param {String|Object} nameOrConfig String name of locale or locale object\n     * @param {Object} [config] Locale object\n     * @returns {Locale} Locale object\n     * @internal\n     */\n    static normalizeLocale(nameOrConfig, config) {\n        if (!nameOrConfig) {\n            throw new Error(`\"nameOrConfig\" parameter can not be empty`);\n        }\n        if (typeof nameOrConfig === 'string') {\n            if (!config) {\n                throw new Error(`\"config\" parameter can not be empty`);\n            }\n            if (config.locale) {\n                // Matches legacy locale type\n                config.name = nameOrConfig || config.name;\n            }\n            else {\n                config.localeName = nameOrConfig;\n            }\n        }\n        else {\n            config = nameOrConfig;\n        }\n        let locale = {};\n        if (config.name || config.locale) {\n            // Matches legacy locale type\n            locale = Object.assign({\n                localeName : config.name\n            }, config.locale);\n            config.desc && (locale.localeDesc = config.desc);\n            config.code && (locale.localeCode = config.code);\n            config.path && (locale.localePath = config.path);\n        }\n        else {\n            if (!config.localeName) {\n                throw new Error(`\"config\" parameter doesn't have \"localeName\" property`);\n            }\n            // Extract locale config from name object\n            locale = Object.assign({}, config);\n        }\n        // Cleanup result\n        for (const key of ['name', 'desc', 'code', 'path']) {\n            if (locale[key]) {\n                delete locale[key];\n            }\n        }\n        if (!locale.localeName) {\n            throw new Error(`Locale name can not be empty`);\n        }\n        return locale;\n    }\n    /**\n     * Get/set currently published locales.\n     * Returns an object with locales.\n     *\n     * Example:\n     *\n     * ```javascript\n     * const englishLocale = LocaleHelper.locales.En;\n     * ```\n     *\n     * `englishLocale` contains {@link Locale} object.\n     *\n     * @readonly\n     * @member {Locales} locales\n     * @static\n     */\n    static get locales() {\n        return globalThis.bryntum.locales || {};\n    }\n    static set locales(locales) {\n        globalThis.bryntum.locales = locales;\n    }\n    /**\n     * Get/set current locale name. Defaults to \"En\"\n     * @member {String} localeName\n     * @static\n     */\n    static get localeName() {\n        return globalThis.bryntum.locale || 'En';\n    }\n    static set localeName(localeName) {\n        globalThis.bryntum.locale = localeName || LocaleHelper.localeName;\n    }\n    /**\n     * Get current locale config specified by {@link ##property-localeName-static}.\n     * If no current locale specified, returns default `En` locale or first published locale\n     * or empty locale object if no published locales found.\n     * @readonly\n     * @member {Locales} locale\n     * @static\n     */\n    static get locale() {\n        return LocaleHelper.localeName && this.locales[LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || { localeName : '', localeDesc : '', localeCoode : '' };\n    }\n    /**\n     * Publishes a locale to make it available for applying.\n     * Published locales are available in {@link ##property-locales-static}.\n     *\n     * Recommended usage:\n     *\n     * ```javascript\n     * LocaleHelper.publishLocale({\n     *     localeName : 'En',\n     *     localeDesc : 'English (US)',\n     *     localeCode : 'en-US',\n     *     ... (localization key:value pairs)\n     * });\n     * ```\n     *\n     * for backward compatibility (prior to `5.3.0` version):\n     *\n     * ```javascript\n     * LocaleHelper.publishLocale('En', {\n     *     name : 'En',\n     *     desc : 'English (US)',\n     *     code : 'en-US',\n     *     locale : {\n     *         ... (localization key:value pairs)\n     *     }\n     * });\n     * ```\n     *\n     * Publishing a locale will automatically merge it's localization keys with existing locale matching by locale name,\n     * replacing existing one with new. To replace existing locale entirely pass `true` to optional `config` parameter.\n     *\n     * Example:\n     *\n     * ```javascript\n     * LocaleHelper.publishLocale({\n     *     localeName : 'En',\n     *     localeDesc : 'English (US)',\n     *     localeCode : 'en-US',\n     *     ... (localization key:value pairs)\n     * }, true);\n     * ```\n     *\n     * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object\n     * @param {Locale|Boolean} [config] Locale object.\n     * Not used if locale object is passed as first method parameter.\n     * Path `true` value and locale object as first method parameter to publish locale without merging with existing one.\n     * @returns {Locale} Locale object\n     */\n    static publishLocale(nameOrConfig, config) {\n        const\n            { locales }    = globalThis.bryntum,\n            locale         = LocaleHelper.normalizeLocale(nameOrConfig, config),\n            { localeName } = locale;\n        if (!locales[localeName] || config === true) {\n            locales[localeName] = locale;\n        }\n        else {\n            locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale || {});\n        }\n        return locales[localeName];\n    }\n}\nglobalThis.bryntum = globalThis.bryntum || {};\nglobalThis.bryntum.locales = globalThis.bryntum.locales || {};\nLocaleHelper._$name = 'LocaleHelper';", "import Base from '../Base.js';\nimport AjaxHelper from '../helper/AjaxHelper.js';\nimport Events from '../mixin/Events.js';\nimport BrowserHelper from '../helper/BrowserHelper.js';\nimport LocaleHelper from '../localization/LocaleHelper.js';\nimport VersionHelper from '../helper/VersionHelper.js';\n/**\n * @module Core/localization/LocaleManager\n */\n// Documented at the export below, to work for singleton\nclass LocaleManager extends Events(Base) {\n    static get defaultConfig() {\n        return {\n            // Enable strict locale checking by default for tests\n            throwOnMissingLocale : VersionHelper.isTestEnv\n        };\n    }\n    construct(...args) {\n        const me = this;\n        super.construct(...args);\n        if (BrowserHelper.isBrowserEnv) {\n            // Try get locale name from script's `default-locale` tag\n            const scriptTag = document.querySelector('script[data-default-locale]');\n            if (scriptTag) {\n                me.applyLocale(scriptTag.dataset.defaultLocale);\n            }\n            else if (me.locale?.localeName) {\n                me.applyLocale(me.locale.localeName);\n            }\n        }\n    }\n    /**\n     * Get/set currently registered locales.\n     * Alias for {@link Core.localization.LocaleHelper#property-locales-static LocaleHelper.locales}.\n     * @readonly\n     * @member {Locales} locales\n     */\n    get locales() {\n        return LocaleHelper.locales;\n    }\n    set locales(locales) {\n        LocaleHelper.locales = locales;\n    }\n    /**\n     * Get/set currently used locale.\n     * Setter calls {@link #function-applyLocale}.\n     * @member {Locales} locale\n     * @accepts {String|Locale}\n     */\n    set locale(nameOrConfig) {\n        this.applyLocale(nameOrConfig);\n    }\n    get locale() {\n        return LocaleHelper.locale;\n    }\n    /**\n     * Publishes a locale to make it available for applying.\n     * @deprecated Since 5.3.0. Use {@link Core.localization.LocaleHelper#function-publishLocale-static LocaleHelper.publishLocale} instead.\n     *\n     * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object.\n     * @param {Locale} [config] Locale object. Not used if object is passed as first method parameter\n     * @returns {Locale} published locale object is passed as first method parameter\n     * @function registerLocale\n     */\n    registerLocale(nameOrConfig, config) {\n        VersionHelper.deprecate('Core', '6.0.0', 'LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead');\n        LocaleHelper.publishLocale(nameOrConfig, config);\n    }\n    /**\n     * Extends locale specified by name to add additional translations and applies it.\n     * @deprecated Since 5.3.0. Use {@link ##function-applyLocale} instead.\n     *\n     * @param {String} name Name of locale (for example `En` or `SvSE`).\n     * @param {Locale} config Locale object\n     * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded\n     * @function extendLocale\n     */\n    extendLocale(name, config) {\n        VersionHelper.deprecate('Core', '6.0.0', 'LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead');\n        const locale = LocaleHelper.publishLocale(name, config);\n        return this.applyLocale(locale, true);\n    }\n    /**\n     * Applies a locale by string name or publishes new locale configuration with\n     * {@link Core.localization.LocaleHelper#function-publishLocale-static} and applies it.\n     * If locale is specified by string name, like 'En', it must be published before applying it.\n     *\n     * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object\n     * @param {Locale|Boolean} [config] Locale object. Pass `true` to reapply locale which is passed as first method parameter.\n     * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded\n     * @fires locale\n     * @async\n     * @function applyLocale\n     */\n    applyLocale(nameOrConfig, config, ignoreError = false) {\n        const me = this;\n        let localeConfig;\n        if (typeof nameOrConfig === 'string') {\n            if (typeof config !== 'object') {\n                localeConfig = me.locales[nameOrConfig];\n                if (!localeConfig) {\n                    if (ignoreError) {\n                        return true;\n                    }\n                    throw new Error(`Locale \"${nameOrConfig}\" is not published. Publish with LocaleHelper.publishLocale() before applying.`);\n                }\n            }\n            else {\n                localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);\n            }\n        }\n        else {\n            localeConfig = LocaleHelper.publishLocale(nameOrConfig);\n        }\n        if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {\n            // no need to apply same locale again\n            return me.locale;\n        }\n        // Set current locale name\n        LocaleHelper.localeName = localeConfig.localeName;\n        const triggerLocaleEvent = () => {\n            /**\n             * Fires when a locale is applied\n             * @event locale\n             * @param {Core.localization.LocaleManager} source The Locale manager instance.\n             * @param {Locale} locale Locale configuration\n             */\n            me.trigger('locale', localeConfig);\n        };\n        if (localeConfig.localePath) {\n            return new Promise((resolve, reject) => {\n                me.loadLocale(localeConfig.localePath).then(response => {\n                    response.text().then(text => {\n                        const parseLocale = new Function(text);\n                        parseLocale();\n                        if (BrowserHelper.isBrowserEnv) {\n                            localeConfig = me.locales[localeConfig.localeName];\n                            // Avoid loading next time\n                            if (localeConfig) {\n                                delete localeConfig.localePath;\n                            }\n                        }\n                        triggerLocaleEvent();\n                        resolve(localeConfig);\n                    });\n                }).catch(response => reject(response));\n            });\n        }\n        triggerLocaleEvent();\n        return localeConfig;\n    }\n    /**\n     * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.\n     * @private\n     * @param {String} path Path to locale file\n     * @async\n     */\n    loadLocale(path) {\n        return AjaxHelper.get(path);\n    }\n    /**\n     * Specifies if {@link Core.localization.Localizable#function-L-static Localizable.L()} function would throw error if no localization found at runtime.\n     *\n     * @member {Boolean} throwOnMissingLocale\n     * @default false\n     */\n    set throwOnMissingLocale(value) {\n        this._throwOnMissingLocale = value;\n    }\n    get throwOnMissingLocale() {\n        return this._throwOnMissingLocale;\n    }\n}\nconst LocaleManagerSingleton = new LocaleManager();\n/**\n * Singleton that handles switching locale.\n * Locales can be included on page with `<script>` tags or loaded using ajax.\n * When using script tags the first locale loaded is used per default, if another should be used as\n * default specify it on any `<script>` tag with `data-default-locale=\"En\"`.\n *\n * Example for Grid (to use for other products replace grid with product name):\n *\n * index.html:\n *\n * ```html\n * // Using Ecma 6 modules and source\n * <script type=\"module\" src=\"lib/Core/localization/SvSE.js\">\n *\n * // Specify default locale when using bundled locales\n * <script data-default-locale=\"En\" src=\"build/locales/grid.locale.En.js\">\n * <script src=\"build/locales/grid.locale.SvSE.js\">\n * ```\n *\n * app.js:\n *\n * ```javascript\n * // Import using sources\n * import LocaleManager from 'lib/Core/localization/LocaleManager.js';\n * // Or using module bundle\n * import { LocaleManager } from 'build/grid.module.js';\n *\n * // Set locale using method\n * LocaleManager.applyLocale('SvSE');\n *\n * // Or set locale using string property\n * LocaleManager.locale = 'SvSE';\n *\n * // Or set locale using locale object property\n * LocaleManager.locale = LocaleManager.locales.SvSE;\n * ```\n *\n * @demo Grid/localization\n * @class\n * @singleton\n */\nexport default LocaleManagerSingleton;\n", "import Base from '../Base.js';\nimport LocaleManager from './LocaleManager.js';\nimport LocaleHelper from './LocaleHelper.js';\nimport Objects from '../helper/util/Objects.js';\n/**\n * @module Core/localization/Localizable\n */\nconst\n    ObjectProto     = Object.getPrototypeOf(Object),\n    localeRe        = /L{.*?}/g,\n    capturelocaleRe = /L{(.*?)}/g,\n    classMatchRe    = /((.*?)\\.)?(.+)/g,\n    escape          = (txt) => txt.replace(/{(\\d+)}/gm, '[[$1]]'),\n    unescape        = (txt) => txt.replace(/\\[\\[(\\d+)]]/gm, '{$1}'),\n    emptyObject     = Object.freeze(Object.create(null));\n/**\n * Mixin that provides localization functionality to a class.\n *\n * ```javascript\n * // Get localized string\n * grid.L('foo');\n * grid.L('L{foo}');\n * ```\n *\n * @mixin\n */\nexport default Target => class Localizable extends (Target || Base) {\n    static get $name() {\n        return 'Localizable';\n    }\n    static get configurable() {\n        return {\n            /**\n             * A class translations of which are used for translating this entity.\n             * This is often used when translations of an item are defined on its container class.\n             * For example:\n             *\n             * ```js\n             * // Toolbar class that has some predefined items\n             * class MyToolbar extends Toolbar {\n             *\n             *     static get $name() {\n             *         return 'MyToolbar';\n             *     }\n             *\n             *     static get defaultConfig() {\n             *         return {\n             *             // this specifies default configs for the items\n             *             defaults : {\n             *                 // will tell items to use the toolbar locale\n             *                 localeClass : this\n             *             },\n             *\n             *             items : [\n             *                 // The toolbar has 2 buttons and translation for their texts will be searched in\n             *                 // the toolbar locales\n             *                 { text : 'Agree' },\n             *                 { text : 'Disagree' }\n             *             ]\n             *         };\n             *     }\n             *\n             *    ...\n             * }\n             * ```\n             * So if one makes a locale for the `MyToolbar` class that will include `Agree` and `Disagree` string translations:\n             * ```js\n             *     ...\n             *     MyToolbar : {\n             *         Agree    : 'Yes, I agree',\n             *         Disagree : 'No, I do not agree'\n             *     }\n             * ```\n             * They will be used for the toolbar buttons and the button captions will say `Yes, I agree` and `No, I do not agree`.\n             *\n             * @config {Core.Base}\n             * @typings {typeof Base}\n             * @category Misc\n             */\n            localeClass : null,\n            /**\n             * Set to `false` to disable localization of this object.\n             * @config {Boolean}\n             * @default true\n             * @category Misc\n             */\n            localizable : null,\n            /**\n             * List of properties which values should be translated automatically upon a locale applying.\n             * In case there is a need to localize not typical value (not a String value or a field with re-defined setter/getter),\n             * you could use 'localeKey' meta configuration.\n             * Example:\n             * ```js\n             *  static get configurable() {\n             *     return {\n             *          localizableProperties : ['width'],\n             *\n             *          width : {\n             *              value   : '54em', // default value here\n             *              $config : {\n             *                  localeKey : 'L{editorWidth}' // name of the property that will be used in localization file\n             *              }\n             *          }\n             *      };\n             *  }\n             * ```\n             * @config {String[]}\n             * @category Misc\n             */\n            localizableProperties : {\n                value : [],\n                $config : {\n                    merge : 'distinct'\n                }\n            }\n        };\n    }\n    static clsName(cls) {\n        return typeof cls === 'string' ? cls : cls === ObjectProto ? 'Object' : cls.$$name || cls.name || cls.prototype?.$$name || cls.prototype?.name;\n    }\n    static parseLocaleString(text) {\n        const matches = [];\n        let m;\n        // Parse locale text in case it's wrapped with L{foo}\n        if (text?.includes('L{')) {\n            // Escape fix for {1}, {2} etc. in locale str\n            text = escape(text);\n            capturelocaleRe.lastIndex = 0;\n            while ((m = capturelocaleRe.exec(text)) != null) {\n                classMatchRe.lastIndex = 0;\n                // Support for parsing class namespace L{Class.foo}\n                const classMatch = classMatchRe.exec(m[1]);\n                matches.push({\n                    match       : unescape(m[0]),\n                    localeKey   : unescape(classMatch[3]),\n                    localeClass : classMatch[2]\n                });\n            }\n        }\n        return matches.length > 0\n            ? matches\n            : [{\n                match       : text,\n                localeKey   : text,\n                localeClass : undefined\n            }];\n    }\n    construct(config = {}, ...args) {\n        // Base class applies configs.\n        super.construct(config, ...args);\n        LocaleManager.ion({ locale : 'updateLocalization', thisObj : this });\n        this.updateLocalization();\n    }\n    get localeClass() {\n        return this._localeClass || null;\n    }\n    localizeProperty(property) {\n        const\n            me           = this,\n            currentValue = Objects.getPath(me, property),\n            // Grid.column.Column is Localizable too. It uses fields, not configs\n            localeKey    = me.$meta.configs[property]?.localeKey || me.fieldMap?.[property]?.defaultValue;\n        let localizedValue;\n        // check if localeKey is defined and try to translate it\n        if (localeKey) {\n            localizedValue = Localizable.localize(localeKey, me, me.localeClass || me);\n            // if a user set value directly in class definition, his value has a prio\n            if (localizedValue && !(property in (me.initialConfig || emptyObject))) {\n                Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);\n            }\n        }\n        else if (typeof currentValue === 'string') {\n            me.originalLocales = me.originalLocales || {};\n            localizedValue = Objects.getPath(me.originalLocales, property);\n            // If we haven't saved original values yet let's do that\n            if (localizedValue === undefined) {\n                Objects.setPath(me.originalLocales, property, currentValue);\n                localizedValue = currentValue;\n            }\n            // Doing localization from the original values\n            if (localizedValue) {\n                Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));\n            }\n        }\n        return localizedValue || currentValue;\n    }\n    /**\n     * Method that is triggered when applying a locale to the instance\n     * (happens on the instance construction steps and when switching to another locale).\n     *\n     * The method can be overridden to dynamically translate the instance when locale is switched.\n     * When overriding the method please make sure you call `super.updateLocalization()`.\n     * @category Misc\n     */\n    updateLocalization() {\n        if (this.localizable !== false) {\n            this.localizableProperties?.forEach(this.localizeProperty, this);\n            this.trigger?.('localized');\n        }\n    }\n    static getTranslation(text, templateData, localeCls) {\n        const locale = LocaleManager.locale;\n        let result = null,\n            clsName,\n            cls;\n        if (locale) {\n            // Iterate over all found localization entries\n            for (const { match, localeKey, localeClass } of this.parseLocaleString(text)) {\n                const translate = (clsName) => {\n                    const translation = locale[clsName]?.[localeKey];\n                    if (translation) {\n                        if (typeof translation === 'function') {\n                            result = templateData != null ? translation(templateData) : translation;\n                        }\n                        else if (typeof translation === 'object' || text === match) {\n                            result = translation;\n                        }\n                        // Likely string\n                        else {\n                            result = (result || text).replace(match, translation);\n                        }\n                        // Might have nested L{, recurse\n                        if (typeof translation === 'string' && translation.includes('L{')) {\n                            result = this.getTranslation(translation, templateData, localeCls);\n                        }\n                    }\n                    return translation;\n                };\n                // Translate order\n                // 1. Try to translate for current class\n                // 2. Try to translate by Class hierarchy traversing prototypes\n                // 3. Try to translate if Class is in {Class.foo} format\n                let success = false;\n                for (cls = localeCls; cls && (clsName = Localizable.clsName(cls)); cls = Object.getPrototypeOf(cls)) {\n                    if ((success = translate(clsName))) {\n                        break;\n                    }\n                    else if (typeof cls === 'string') {\n                        break;\n                    }\n                }\n                if (!success && localeClass) {\n                    translate(localeClass);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Get localized string, returns `null` if no localized string found.\n     * @param {String} text String key\n     * @param {Object} [templateData] Data to supply to template if localized string is a function\n     * @returns {String}\n     * @internal\n     */\n    static localize(text, templateData = undefined, ...localeClasses) {\n        // In case this static method is called directly third argument is not provided\n        // just fallback to searching locales for the class itself\n        if (localeClasses?.length === 0) {\n            localeClasses = [this];\n        }\n        let translation = null;\n        localeClasses.some(cls => {\n            translation = Localizable.getTranslation(text, templateData, cls);\n            return translation != null;\n        });\n        return translation;\n    }\n    /**\n     * Get localized string, returns value of `text` if no localized string found.\n     *\n     * If {@link Core.localization.LocaleManager#property-throwOnMissingLocale LocaleManager.throwOnMissingLocale}\n     * is `true` then calls to `L()` will throw `Localization is not found for 'text' in 'ClassName'` exception when no\n     * localization is found.\n     *\n     * @param {String} text String key\n     * @param {Object} [templateData] Data to supply to template if localized string is a function\n     * @static\n     * @returns {String}\n     */\n    static L(text, templateData = undefined, ...localeClasses) {\n        // In case this static method is called directly third argument is not provided\n        // just fallback to searching locales for the class itself\n        if (localeClasses?.length === 0) {\n            localeClasses = [this];\n        }\n        const translation = this.localize(text, templateData, ...localeClasses);\n        // Throw error if not localized and text matches `L{foo}`\n        if (\n            translation == null &&\n            LocaleManager.throwOnMissingLocale &&\n            text.includes('L{')\n        ) {\n            throw new Error(`Localization is not found for '${text}' in '${localeClasses.map(cls => Localizable.clsName(cls)).join(', ')}'. ${LocaleManager.locale.localeName ? `Locale : ${LocaleManager.locale.localeName}` : ''}`);\n        }\n        return translation ?? text;\n    }\n    /**\n     * Convenience function that can be called directly on the class that mixes Localizable in\n     *\n     * ```javascript\n     * button.text = grid.L('L{group}');\n     * ```\n     *\n     * @param {String} text String key\n     * @param {Object} [templateData] Data to supply to template if localized string is a function\n     * @returns {String}\n     * @category Misc\n     */\n    L(text, templateData) {\n        const { localeClass, constructor } = this;\n        // If we have a different class set as translations provider\n        // pass it first and use the class being translated as a fallback provider\n        if (localeClass && Localizable.clsName(localeClass) !== Localizable.clsName(constructor)) {\n            return Localizable.L(text, templateData, localeClass, constructor);\n        }\n        else {\n            return Localizable.L(text, templateData, constructor);\n        }\n    }\n    /**\n     * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw\n     * an error when the translation is missing even if configured with `throwOnMissingLocale`\n     *\n     * ```javascript\n     * button.text = grid.optionalL('L{group}');\n     * ```\n     *\n     * @param {String} text String key\n     * @param {Object} [templateData] Data to supply to template if localized string is a function\n     * @returns {String}\n     * @static\n     * @category Misc\n     */\n    static optionalL(text, templateData = undefined, ...localeClasses) {\n        const shouldThrow = LocaleManager.throwOnMissingLocale;\n        LocaleManager.throwOnMissingLocale = shouldThrow && localeRe.test(text);\n        // In case this static method is called directly third argument is not provided\n        // just fallback to searching locales for the class itself\n        if (localeClasses?.length === 0) {\n            localeClasses = [this];\n        }\n        const result = Localizable.L(text, templateData, ...localeClasses);\n        LocaleManager.throwOnMissingLocale = shouldThrow;\n        return result;\n    }\n    /**\n     * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw\n     * an error when the translation is missing even if configured with `throwOnMissingLocale`\n     *\n     * ```javascript\n     * button.text = grid.optionalL('L{group}');\n     * ```\n     *\n     * @param {String} text String key\n     * @param {Object} [templateData] Data to supply to template if localized string is a function\n     * @param {Boolean} [preventThrow] Prevent throwing error even if localized text matches `L{foo}`\n     * @returns {String}\n     * @category Misc\n     * @internal\n     */\n    optionalL(text, templateData = this, preventThrow = false) {\n        const shouldThrow = LocaleManager.throwOnMissingLocale;\n        // Optional locale text should not include L{}\n        LocaleManager.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;\n        const result = this.L(text, templateData);\n        LocaleManager.throwOnMissingLocale = shouldThrow;\n        return result;\n    }\n    /**\n     * Get the global LocaleManager\n     * @property {Core.localization.LocaleManager}\n     * @typings {typeof LocaleManager}\n     * @category Misc\n     * @readonly\n     */\n    get localeManager() {\n        return LocaleManager;\n    }\n    /**\n     * Get the global LocaleHelper\n     * @property {Core.localization.LocaleHelper}\n     * @typings {typeof LocaleHelper}\n     * @category Misc\n     * @readonly\n     */\n    get localeHelper() {\n        return LocaleHelper;\n    }\n};\n", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nconst locale = {\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n    Object : {\n        Yes    : 'Yes',\n        No     : 'No',\n        Cancel : 'Cancel',\n        Ok     : 'OK',\n        Week   : 'Week'\n    },\n    Combo : {\n        noResults          : 'No results',\n        recordNotCommitted : 'Record could not be added',\n        addNewValue        : value => `Add ${value}`\n    },\n    FilePicker : {\n        file : 'File'\n    },\n    Field : {\n        badInput              : 'Invalid field value',\n        patternMismatch       : 'Value should match a specific pattern',\n        rangeOverflow         : value => `Value must be less than or equal to ${value.max}`,\n        rangeUnderflow        : value => `Value must be greater than or equal to ${value.min}`,\n        stepMismatch          : 'Value should fit the step',\n        tooLong               : 'Value should be shorter',\n        tooShort              : 'Value should be longer',\n        typeMismatch          : 'Value is required to be in a special format',\n        valueMissing          : 'This field is required',\n        invalidValue          : 'Invalid field value',\n        minimumValueViolation : 'Minimum value violation',\n        maximumValueViolation : 'Maximum value violation',\n        fieldRequired         : 'This field is required',\n        validateFilter        : 'Value must be selected from the list'\n    },\n    DateField : {\n        invalidDate : 'Invalid date input'\n    },\n    DatePicker : {\n        gotoPrevYear  : 'Go to previous year',\n        gotoPrevMonth : 'Go to previous month',\n        gotoNextMonth : 'Go to next month',\n        gotoNextYear  : 'Go to next year'\n    },\n    NumberFormat : {\n        locale   : 'en-US',\n        currency : 'USD'\n    },\n    DurationField : {\n        invalidUnit : 'Invalid unit'\n    },\n    TimeField : {\n        invalidTime : 'Invalid time input'\n    },\n    TimePicker : {\n        hour   : 'Hour',\n        minute : 'Minute',\n        second : 'Second'\n    },\n    List : {\n        loading : 'Loading...'\n    },\n    GridBase : {\n        loadMask : 'Loading...',\n        syncMask : 'Saving changes, please wait...'\n    },\n    PagingToolbar : {\n        firstPage         : 'Go to first page',\n        prevPage          : 'Go to previous page',\n        page              : 'Page',\n        nextPage          : 'Go to next page',\n        lastPage          : 'Go to last page',\n        reload            : 'Reload current page',\n        noRecords         : 'No records to display',\n        pageCountTemplate : data => `of ${data.lastPage}`,\n        summaryTemplate   : data => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`\n    },\n    PanelCollapser : {\n        Collapse : 'Collapse',\n        Expand   : 'Expand'\n    },\n    Popup : {\n        close : 'Close'\n    },\n    UndoRedo : {\n        Undo           : 'Undo',\n        Redo           : 'Redo',\n        UndoLastAction : 'Undo last action',\n        RedoLastAction : 'Redo last undone action',\n        NoActions      : 'No items in the undo queue'\n    },\n    FieldFilterPicker : {\n        equals                 : 'equals',\n        doesNotEqual           : 'does not equal',\n        isEmpty                : 'is empty',\n        isNotEmpty             : 'is not empty',\n        contains               : 'contains',\n        doesNotContain         : 'does not contain',\n        startsWith             : 'starts with',\n        endsWith               : 'ends with',\n        isOneOf                : 'is one of',\n        isNotOneOf             : 'is not one of',\n        isGreaterThan          : 'is greater than',\n        isLessThan             : 'is less than',\n        isGreaterThanOrEqualTo : 'is greater than or equal to',\n        isLessThanOrEqualTo    : 'is less than or equal to',\n        isBetween              : 'is between',\n        isNotBetween           : 'is not between',\n        isBefore               : 'is before',\n        isAfter                : 'is after',\n        isToday                : 'is today',\n        isTomorrow             : 'is tomorrow',\n        isYesterday            : 'is yesterday',\n        isThisWeek             : 'is this week',\n        isNextWeek             : 'is next week',\n        isLastWeek             : 'is last week',\n        isThisMonth            : 'is this month',\n        isNextMonth            : 'is next month',\n        isLastMonth            : 'is last month',\n        isThisYear             : 'is this year',\n        isNextYear             : 'is next year',\n        isLastYear             : 'is last year',\n        isYearToDate           : 'is year to date',\n        isTrue                 : 'is true',\n        isFalse                : 'is false',\n        selectAProperty        : 'Select a property',\n        selectAnOperator       : 'Select an operator',\n        caseSensitive          : 'Case-sensitive',\n        and                    : 'and',\n        dateFormat             : 'D/M/YY',\n        selectOneOrMoreValues  : 'Select one or more values',\n        enterAValue            : 'Enter a value',\n        enterANumber           : 'Enter a number',\n        selectADate            : 'Select a date'\n    },\n    FieldFilterPickerGroup : {\n        addFilter : 'Add filter'\n    },\n    DateHelper : {\n        locale         : 'en-US',\n        weekStartDay   : 0,\n        nonWorkingDays : {\n            0 : true,\n            6 : true\n        },\n        weekends : {\n            0 : true,\n            6 : true\n        },\n        unitNames : [\n            { single : 'millisecond', plural : 'ms', abbrev : 'ms' },\n            { single : 'second', plural : 'seconds', abbrev : 's' },\n            { single : 'minute', plural : 'minutes', abbrev : 'min' },\n            { single : 'hour', plural : 'hours', abbrev : 'h' },\n            { single : 'day', plural : 'days', abbrev : 'd' },\n            { single : 'week', plural : 'weeks', abbrev : 'w' },\n            { single : 'month', plural : 'months', abbrev : 'mon' },\n            { single : 'quarter', plural : 'quarters', abbrev : 'q' },\n            { single : 'year', plural : 'years', abbrev : 'yr' },\n            { single : 'decade', plural : 'decades', abbrev : 'dec' }\n        ],\n        unitAbbreviations : [\n            ['mil'],\n            ['s', 'sec'],\n            ['m', 'min'],\n            ['h', 'hr'],\n            ['d'],\n            ['w', 'wk'],\n            ['mo', 'mon', 'mnt'],\n            ['q', 'quar', 'qrt'],\n            ['y', 'yr'],\n            ['dec']\n        ],\n        parsers : {\n            L   : 'MM/DD/YYYY',\n            LT  : 'HH:mm A',\n            LTS : 'HH:mm:ss A'\n        },\n        ordinalSuffix : number => {\n            const hasSpecialCase = ['11', '12', '13'].find((n) => number.endsWith(n));\n            let suffix = 'th';\n            if (!hasSpecialCase) {\n                const lastDigit = number[number.length - 1];\n                suffix = { 1 : 'st', 2 : 'nd', 3 : 'rd' }[lastDigit] || 'th';\n            }\n            return number + suffix;\n        }\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import Localizable from '../localization/Localizable.js';\nimport LocaleManager from '../localization/LocaleManager.js';\nimport '../localization/En.js';\nimport StringHelper from './StringHelper.js';\nimport Objects from './util/Objects.js';\nconst\n    { toString }        = Object.prototype,\n    DATE_TYPE           = toString.call(new Date()),\n    tempDate            = new Date(),\n    MS_PER_HOUR         = 1000 * 60 * 60,\n    defaultValue        = (value, defValue) => isNaN(value) || value == null ? defValue : value,\n    rangeFormatPartRe   = /([ES]){([^}]+)}/g,\n    enOrdinalSuffix     = number => {\n        const hasSpecialCase = ['11', '12', '13'].find((n) => number.endsWith(n));\n        let suffix = 'th';\n        if (!hasSpecialCase) {\n            const lastDigit = number[number.length - 1];\n            suffix          = { 1 : 'st', 2 : 'nd', 3 : 'rd' }[lastDigit] || 'th';\n        }\n        return number + suffix;\n    },\n    useIntlFormat       = (name, options, date) => {\n        const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale, options));\n        return formatter.format(date);\n    },\n    formatTime          = (name, options, date, isShort = false) => {\n        let strTime = useIntlFormat(name, options, date);\n        // remove '0' from time when has AM/PM (from 01:00 PM to 1:00 PM): https://github.com/bryntum/support/issues/1483\n        if (/am|pm/i.test(strTime)) {\n            // remove first character only if is 0\n            strTime = strTime.replace(/^0/, '');\n            // if isShort is true, remove minutes if is :00\n            if (isShort) {\n                strTime = strTime.replace(/:00/, '');\n            }\n        }\n        return strTime;\n    },\n    getDayDiff   = (end, start) => Math.floor((end.getTime() - start.getTime() -\n        (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1,\n    normalizeDay = day => day >= 0 ? day : day + 7,\n    msRegExp     = /([^\\w])(S+)/gm,\n    msReplacer   = (match, g1) => g1 + 'SSS',\n    splitRegExp  = /[:.\\-/\\s]/;\n// These vars are set when changing locale\nlet locale             = 'en-US',\n    ordinalSuffix      = enOrdinalSuffix,\n    // Used to cache used formats, to not have to parse format string each time\n    formatCache        = {},\n    formatRedirects    = {},\n    intlFormatterCache = {},\n    parserCache        = {};\nconst redirectFormat = (format) => {\n    const intlConfig = intlFormatConfigs[format];\n    if (!intlConfig) {\n        throw new Error('Only international formats should be used here');\n    }\n    if (formatRedirects[format] !== undefined) {\n        return formatRedirects[format];\n    }\n    const\n        intl = new Intl.DateTimeFormat(locale, intlConfig),\n        fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map(part => {\n            const\n                type = part.type,\n                intlCfg = intlConfig[type];\n            if (type === 'literal') {\n                // here we cheat again, because our parser can not skip unknown separators\n                return part.value.replace(/,/g, '');\n            }\n            else if (type === 'day') {\n                return intlCfg === 'numeric' ? 'D' : 'DD';\n            }\n            else if (type === 'month') {\n                return intlCfg === 'short'\n                    ? 'MMM'\n                    : intlCfg === 'long'\n                        ? 'MMMM'\n                        : intlCfg === 'numeric'\n                            ? 'M'\n                            : 'MM';\n            }\n            else if (type === 'year') {\n                // here we cheat a little, using `YYYY` for numeric year in `ll`\n                // this is to simplify the fix for https://github.com/bryntum/support/issues/5179\n                // to be fixed if anyone complains\n                return intlCfg === 'numeric' ? 'YYYY' : 'YY';\n            }\n        }).join('');\n    return formatRedirects[format] = fmt;\n};\nconst\n    DEFAULT_YEAR               = 2020, // 2020 is the year that has no issues in Safari, see: https://github.com/bryntum/support/issues/554\n    DEFAULT_MONTH              = 0,\n    DEFAULT_DAY                = 1,\n    intlFormatConfigs          = {\n        l  : { year : 'numeric', month : 'numeric', day : 'numeric' },\n        ll : { year : 'numeric', month : 'short', day : 'numeric' }\n    },\n    formats                    = {\n        // 1, 2, ... 11, 12\n        M    : date => date.getMonth() + 1, //date.toLocaleDateString(locale, { month : 'numeric' }),\n        // 1st, 2nd, 3rd, 4th, ... 11th, 12th\n        Mo   : date => ordinalSuffix(formats.M(date).toString()),\n        // 01, 02, ...\n        MM   : date => (date.getMonth() + 1).toString().padStart(2, '0'), //date.toLocaleDateString(locale, { month : '2-digit' }),\n        // Jan, Feb, ...\n        MMM  : date => useIntlFormat('MMM', { month : 'short' }, date),\n        // January, February, ...\n        MMMM : date => useIntlFormat('MMMM', { month : 'long' }, date),\n        // 1, 2, ...\n        Q  : date => Math.ceil((date.getMonth() + 1) / 3),\n        // 1st, 2nd, ...\n        Qo : date => ordinalSuffix(formats.Q(date).toString()),\n        // 1, 2, ...\n        D  : date => date.getDate(), //date.toLocaleDateString(locale, { day : 'numeric' }),\n        // 1st, 2nd, ...\n        Do : date => ordinalSuffix(formats.D(date).toString()),\n        // 01, 02, ...\n        DD : date => date.getDate().toString().padStart(2, '0'), //date.toLocaleDateString(locale, { day : '2-digit' }),\n        // 1, 2, ..., 365, 365\n        DDD : date => Math.ceil(\n            (\n                new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) -\n                new Date(date.getFullYear(), 0, 0, 12, 0, 0)\n            ) / validConversions.day.millisecond),\n        // 1st, 2nd, ...\n        DDDo : date => ordinalSuffix(formats.DDD(date).toString()),\n        // 001, 002, ...\n        DDDD : date => formats.DDD(date).toString().padStart(3, '0'),\n        // 0, 1, ..., 6\n        d    : date => date.getDay(),\n        // 0th, 1st, ...\n        do   : date => ordinalSuffix(date.getDay().toString()),\n        // S, M, ...\n        d1   : date => useIntlFormat('d1', { weekday : 'narrow' }, date).substr(0, 1),\n        // Su, Mo, ...\n        dd   : date => formats.ddd(date).substring(0, 2),\n        // Sun, Mon, ...\n        ddd  : date => useIntlFormat('ddd', { weekday : 'short' }, date),\n        // Sunday, Monday, ...\n        dddd : date => useIntlFormat('dddd', { weekday : 'long' }, date),\n        u : date => {\n            const\n                formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat('en-GB', {\n                    timeZone : 'UTC',\n                    year     : 'numeric',\n                    month    : '2-digit',\n                    day      : '2-digit'\n                })),\n                parts = formatter.formatToParts(date);\n            return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;\n        },\n        uu : date => {\n            const\n                formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat('en-GB', {\n                    timeZone : 'UTC',\n                    hour12   : false,\n                    year     : 'numeric',\n                    month    : '2-digit',\n                    day      : '2-digit',\n                    hour     : '2-digit',\n                    minute   : '2-digit',\n                    second   : '2-digit'\n                })),\n                parts = formatter.formatToParts(date);\n            return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;\n        },\n        e : date => date.getDay(),\n        E : date => date.getDay() + 1,\n        // ISO week, 1, 2, ...\n        W  : date => DateHelper.getWeekNumber(date)[1],\n        Wo : date => ordinalSuffix(formats.W(date).toString()),\n        WW : date => formats.W(date).toString().padStart(2, '0'),\n        // ISO week, 1, 2, ... with localized 'Week ' prefix\n        Wp   : date => `${DateHelper.localize('L{Week}')} ${formats.W(date)}`,\n        WWp  : date => `${DateHelper.localize('L{Week}')} ${formats.WW(date)}`,\n        Wp0  : date => `${DateHelper.localize('L{Week}')[0]}${formats.W(date)}`,\n        WWp0 : date => `${DateHelper.localize('L{Week}')[0]}${formats.WW(date)}`,\n        // 1979, 2018\n        Y    : date => date.getFullYear(), //date.toLocaleDateString(locale, { year : 'numeric' }),\n        // 79, 18\n        YY   : date => date.getFullYear() % 100, //date.toLocaleDateString(locale, { year : '2-digit' }),\n        // 1979, 2018\n        YYYY : date => date.getFullYear(), //date.toLocaleDateString(locale, { year : 'numeric' }),\n        // AM, PM\n        A : date => date.getHours() < 12 ? 'AM' : 'PM',\n        a : date => date.getHours() < 12 ? 'am' : 'pm',\n        // 0, 1, ... 23\n        H  : date => date.getHours(),\n        // 00, 01, ...\n        HH : date => date.getHours().toString().padStart(2, '0'),\n        // 1, 2, ... 12\n        h  : date => (date.getHours() % 12) || 12,\n        // 01, 02, ...\n        hh : date => formats.h(date).toString().padStart(2, '0'),\n        // 1, 2, ... 24\n        k  : date => date.getHours() || 24,\n        // 01, 02, ...\n        kk : date => formats.k(date).toString().padStart(2, '0'),\n        // Locale specific (0 -> 24 or 1 AM -> 12 PM)\n        K  : date => formatTime('K', { hour : 'numeric' }, date),\n        // Locale specific (00 -> 24 or 1 AM -> 12 PM)\n        KK : date => formatTime('KK', { hour : '2-digit' }, date),\n        // 0, 1, ... 59\n        m  : date => date.getMinutes(), //date.toLocaleTimeString(locale, { minute : 'numeric' }),\n        // 00, 01, ...\n        mm : date => formats.m(date).toString().padStart(2, '0'),\n        // 0, 1, ... 59\n        s  : date => date.getSeconds(), //date.toLocaleTimeString(locale, { second : 'numeric' }),\n        // 00, 01, ...\n        ss : date => formats.s(date).toString().padStart(2, '0'),\n        // 0, 1, ... 9 which are 000, 100, 200 ... 900 in milliseconds\n        S   : date => Math.floor(date.getMilliseconds() / 100).toString(),\n        // 00, 01, ... 99 which are 000, 010, 020 ... 990 in milliseconds\n        SS  : date => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, '0'),\n        // 000, 001, ... 999 in milliseconds\n        SSS : date => date.getMilliseconds().toString().padStart(3, '0'),\n        z  : date => useIntlFormat('z', { timeZoneName : 'short' }, date),\n        zz : date => useIntlFormat('zz', { timeZoneName : 'long' }, date),\n        Z  : date => DH.getGMTOffset(date),\n        LT  : date => formatTime('LT', { hour : '2-digit', minute : '2-digit' }, date),\n        // if minutes is 0, doesn't show it\n        LST : date => formatTime('LST', { hour : 'numeric', minute : '2-digit' }, date, true),\n        LTS : date => formatTime('LTS', { hour : '2-digit', minute : '2-digit', second : '2-digit' }, date),\n        L   : date => useIntlFormat('L', { year : 'numeric', month : '2-digit', day : '2-digit' }, date),\n        l   : date => useIntlFormat('l', intlFormatConfigs.l, date),\n        LL  : date => useIntlFormat('LL', { year : 'numeric', month : 'long', day : 'numeric' }, date),\n        ll  : date => useIntlFormat('ll', intlFormatConfigs.ll, date),\n        LLL : date => useIntlFormat('LLL', {\n            year   : 'numeric',\n            month  : 'long',\n            day    : 'numeric',\n            hour   : 'numeric',\n            minute : '2-digit'\n        }, date),\n        lll : date => useIntlFormat('lll', {\n            year   : 'numeric',\n            month  : 'short',\n            day    : 'numeric',\n            hour   : 'numeric',\n            minute : '2-digit'\n        }, date),\n        LLLL : date => useIntlFormat('LLLL', {\n            year    : 'numeric',\n            month   : 'long',\n            day     : 'numeric',\n            hour    : 'numeric',\n            minute  : '2-digit',\n            weekday : 'long'\n        }, date),\n        llll : date => useIntlFormat('llll', {\n            year    : 'numeric',\n            month   : 'short',\n            day     : 'numeric',\n            hour    : 'numeric',\n            minute  : '2-digit',\n            weekday : 'short'\n        }, date)\n    },\n    // Want longest keys first, to not stop match at L of LTS etc.\n    formatKeys                 = Object.keys(formats).sort((a, b) => b.length - a.length),\n    formatRegexp               = `^(?:${formatKeys.join('|')})`,\n    // return empty object, meaning value cannot be processed to a valuable date part\n    emptyFn                    = () => ({}),\n    isNumber                   = (str) => numberRegex.test(str),\n    parseMilliseconds          = (str) => isNumber(str) && { milliseconds : parseInt(str.padEnd(3, '0').substring(0, 3)) },\n    parsers                    = {\n        YYYY : str => {\n            const year = parseInt(str);\n            return { year : year >= 1000 && year <= 9999 ? year : NaN };\n        },\n        Y  : str => ({ year : parseInt(str) }),\n        YY : str => {\n            const year = parseInt(str);\n            return { year : year + (year > 1968 ? 1900 : 2000) };\n        },\n        M   : str => ({ month : parseInt(str) - 1 }),\n        MM  : str => ({ month : parseInt(str) - 1 }),\n        Mo  : str => ({ month : parseInt(str) - 1 }),\n        MMM : str => {\n            const month = (str || '').toLowerCase();\n            for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {\n                if (month.startsWith(name)) {\n                    return { month : entry.value };\n                }\n            }\n        },\n        MMMM : str => {\n            const month = (str || '').toLowerCase();\n            for (const [name, entry] of Object.entries(DateHelper._monthNamesIndex)) {\n                if (month.startsWith(name)) {\n                    return { month : entry.value };\n                }\n            }\n        },\n        DD   : str => ({ date : parseInt(str) }),\n        D    : str => ({ date : parseInt(str) }),\n        Do   : str => ({ date : parseInt(str) }),\n        DDD  : emptyFn,\n        DDDo : emptyFn,\n        DDDD : emptyFn,\n        d    : emptyFn,\n        do   : emptyFn,\n        d1   : emptyFn,\n        dd   : emptyFn,\n        ddd  : emptyFn,\n        dddd : emptyFn,\n        Q    : emptyFn,\n        Qo   : emptyFn,\n        W    : emptyFn,\n        Wo   : emptyFn,\n        WW   : emptyFn,\n        e    : emptyFn,\n        E    : emptyFn,\n        HH   : str => ({ hours : parseInt(str) }),\n        hh   : str => ({ hours : parseInt(str) }),\n        mm   : str => ({ minutes : parseInt(str) }),\n        H    : str => ({ hours : parseInt(str) }),\n        m    : str => ({ minutes : parseInt(str) }),\n        ss   : str => ({ seconds : parseInt(str) }),\n        s    : str => ({ seconds : parseInt(str) }),\n        S    : parseMilliseconds,\n        SS   : parseMilliseconds,\n        SSS  : parseMilliseconds,\n        A : str => ({ amPm : str.toLowerCase() }),\n        a : str => ({ amPm : str.toLowerCase() }),\n        L   : 'MM/DD/YYYY',\n        LT  : 'HH:mm A',\n        LTS : 'HH:mm:ss A',\n        l  : { type : 'dynamic', parser : () => redirectFormat('l') },\n        ll : { type : 'dynamic', parser : () => redirectFormat('ll') },\n        // Can either be Z (=UTC, 0) or +-HH:MM\n        Z : str => {\n            if (!str || (!timeZoneRegEx.test(str) && str !== 'Z')) {\n                return null;\n            }\n            let timeZone = 0;\n            // If string being parsed is more detailed than the format specified we can have more chars left,\n            // thus check the last (for example HH:mmZ with input HH:mm:ssZ -> ssZ)\n            if (str !== 'Z') {\n                const matches = timeZoneRegEx.exec(str);\n                // If timezone regexp matches, sting has time zone offset like '+02:00'\n                if (matches) {\n                    const\n                        sign    = matches[1] === '+' ? 1 : -1,\n                        hours   = parseInt(matches[2]) || 0,\n                        minutes = parseInt(matches[3]) || 0;\n                    timeZone = sign * (hours * 60 + minutes);\n                }\n                // otherwise we just return current time zone, because there's a Z key in the input\n                else {\n                    timeZone = -1 * new Date().getTimezoneOffset();\n                }\n            }\n            return { timeZone };\n        }\n    },\n    parserKeys                 = Object.keys(parsers).sort((a, b) => b.length - a.length),\n    parserRegexp               = new RegExp(`(${parserKeys.join('|')})`),\n    // Following regexp includes all formats that should be handled by Date class\n    // !!! except `l|ll`, plus made all-string capturing, otherwise the left-most `l` pattern\n    // matches all `l*` formats\n    // localeStrRegExp            = new RegExp('(l|LL|ll|LLL|lll|LLLL|llll)'),\n    localeStrRegExp            = new RegExp('^(LL|LLL|lll|LLLL|llll)$'),\n    //    ISODateRegExp             = new RegExp('YYYY-MM-DD[T ]HH:mm:ss(.s+)?Z'),\n    // Some validConversions are negative to show that it's not an exact conversion, just an estimate.\n    validConversions           = {\n        // The units below assume:\n        // 30 days in a month, 91 days for a quarter and 365 for a year\n        // 52 weeks per year, 4 per month, 13 per quarter\n        // 3652 days per decade (assuming two of the years will be leap with 366 days)\n        decade : {\n            decade      : 1,\n            year        : 10,\n            quarter     : 40,\n            month       : 120,\n            week        : 520,\n            day         : 3652,\n            hour        : 24 * 3652,\n            minute      : 1440 * 3652,\n            second      : 86400 * 3652,\n            millisecond : 86400000 * 3652\n        },\n        year : {\n            decade      : 0.1,\n            year        : 1,\n            quarter     : 4,\n            month       : 12,\n            week        : 52,\n            day         : 365,\n            hour        : 24 * 365,\n            minute      : 1440 * 365,\n            second      : 86400 * 365,\n            millisecond : 86400000 * 365\n        },\n        quarter : {\n            decade      : 1 / 40,\n            year        : 1 / 4,\n            quarter     : 1,\n            month       : 3,\n            week        : 4,\n            day         : 91,\n            hour        : 24 * 91,\n            minute      : 1440 * 91,\n            second      : 86400 * 91,\n            millisecond : 86400000 * 91\n        },\n        month : {\n            decade      : 1 / 120,\n            year        : 1 / 12,\n            quarter     : 1 / 3,\n            month       : 1,\n            week        : 4,\n            day         : -30,\n            hour        : -24 * 30,\n            minute      : -1440 * 30,\n            second      : -86400 * 30,\n            millisecond : -86400000 * 30\n        },\n        week : {\n            decade      : -1 / 520,\n            year        : -1 / 52,\n            quarter     : -1 / 13,\n            month       : -1 / 4,\n            day         : 7,\n            hour        : 168,\n            minute      : 10080,\n            second      : 604800,\n            millisecond : 604800000\n        },\n        day : {\n            decade      : -1 / 3652,\n            year        : -1 / 365,\n            quarter     : -1 / 91,\n            month       : -1 / 30,\n            week        : 1 / 7,\n            hour        : 24,\n            minute      : 1440,\n            second      : 86400,\n            millisecond : 86400000\n        },\n        hour : {\n            decade      : -1 / (3652 * 24),\n            year        : -1 / (365 * 24),\n            quarter     : -1 / (91 * 24),\n            month       : -1 / (30 * 24),\n            week        : 1 / 168,\n            day         : 1 / 24,\n            minute      : 60,\n            second      : 3600,\n            millisecond : 3600000\n        },\n        minute : {\n            decade      : -1 / (3652 * 1440),\n            year        : -1 / (365 * 1440),\n            quarter     : -1 / (91 * 1440),\n            month       : -1 / (30 * 1440),\n            week        : 1 / 10080,\n            day         : 1 / 1440,\n            hour        : 1 / 60,\n            second      : 60,\n            millisecond : 60000\n        },\n        second : {\n            decade      : -1 / (3652 * 86400),\n            year        : -1 / (365 * 86400),\n            quarter     : -1 / (91 * 86400),\n            month       : -1 / (30 * 86400),\n            week        : 1 / 604800,\n            day         : 1 / 86400,\n            hour        : 1 / 3600,\n            minute      : 1 / 60,\n            millisecond : 1000\n        },\n        millisecond : {\n            decade  : -1 / (3652 * 86400000),\n            year    : -1 / (365 * 86400000),\n            quarter : -1 / (91 * 86400000),\n            month   : -1 / (30 * 86400000),\n            week    : 1 / 604800000,\n            day     : 1 / 86400000,\n            hour    : 1 / 3600000,\n            minute  : 1 / 60000,\n            second  : 1 / 1000\n        }\n    },\n    normalizedUnits            = {\n        ms           : 'millisecond',\n        milliseconds : 'millisecond',\n        s            : 'second',\n        seconds      : 'second',\n        m            : 'minute',\n        mi           : 'minute',\n        min          : 'minute',\n        minutes      : 'minute',\n        h            : 'hour',\n        hours        : 'hour',\n        d            : 'day',\n        days         : 'day',\n        w            : 'week',\n        weeks        : 'week',\n        M            : 'month',\n        mo           : 'month',\n        mon          : 'month',\n        months       : 'month',\n        q            : 'quarter',\n        quarters     : 'quarter',\n        y            : 'year',\n        years        : 'year',\n        dec          : 'decade',\n        decades      : 'decade'\n    },\n    withDecimalsDurationRegex  = /^\\s*([-+]?\\d+(?:[.,]\\d*)?|[-+]?(?:[.,]\\d+))\\s*([^\\s]+)?/i,\n    noDecimalsDurationRegex    = /^\\s*([-+]?\\d+)(?![.,])\\s*([^\\s]+)?/i,\n    canonicalUnitNames         = [\n        'millisecond',\n        'second',\n        'minute',\n        'hour',\n        'day',\n        'week',\n        'month',\n        'quarter',\n        'year',\n        'decade'\n    ],\n    canonicalUnitAbbreviations = [\n        ['mil'],\n        ['s', 'sec'],\n        ['m', 'min'],\n        ['h', 'hr'],\n        ['d'],\n        ['w', 'wk'],\n        ['mo', 'mon', 'mnt'],\n        ['q', 'quar', 'qrt'],\n        ['y', 'yr'],\n        ['dec']\n    ],\n    deltaUnits                 = [\n        'decade',\n        'year',\n        'month',\n        'week',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'millisecond'\n    ],\n    // Used when creating a date from an object, to fill in any blanks\n    dateProperties             = [\n        'milliseconds',\n        'seconds',\n        'minutes',\n        'hours',\n        'date',\n        'month',\n        'year'\n    ],\n    parseNumber                = (n) => {\n        const result = parseFloat(n);\n        return isNaN(result) ? null : result;\n    },\n    numberRegex                = /^[0-9]+$/,\n    timeZoneRegEx              = /([+-])(\\d\\d):*(\\d\\d)*$/,\n    unitMagnitudes             = {\n        millisecond : 0,\n        second      : 1,\n        minute      : 2,\n        hour        : 3,\n        day         : 4,\n        week        : 5,\n        month       : 6,\n        quarter     : 7,\n        year        : 8,\n        decade      : 9\n    },\n    snapFns = {\n        round(number, step = 1) {\n            return Math.round(number / step) * step;\n        },\n        floor(number, step = 1) {\n            return Math.floor(number / step) * step;\n        },\n        ceil(number, step = 1) {\n            return Math.ceil(number / step) * step;\n        }\n    },\n    keyCache = {};\nexport { unitMagnitudes };\n/**\n * @module Core/helper/DateHelper\n */\n/**\n * A static class offering date manipulation, comparison, parsing and formatting helper methods.\n *\n * ## Parsing strings\n * Use `DateHelper.parse()` to parse strings into dates. It accepts a date string and a format specifier.\n * The format specifier is string built up using the following tokens:\n *\n * | Unit        | Token | Description                       |\n * |-------------|-------|-----------------------------------|\n * | Year        | YYYY  | 4-digits year, like: 2018         |\n * |             | Y     | numeric, any number of digits     |\n * |             | YY    | < 68 -> 2000, > 68 -> 1900        |\n * | Month       | MM    | 01 - 12                           |\n * | Month       | MMM   | Short name of the month           |\n * | Date        | DD    | 01 - 31                           |\n * | Hour        | HH    | 00 - 23 or 1 - 12                 |\n * | Minute      | mm    | 00 - 59                           |\n * | Second      | ss    | 00 - 59                           |\n * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |\n * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |\n * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |\n * | AM/PM       | A     | AM or PM                          |\n * |             | a     | am or pm                          |\n * | TimeZone    | Z     | Z for UTC or +-HH:mm              |\n * | Predefined  | L     | Long date, MM/DD/YYYY             |\n * |             | LT    | Long time, HH:mm A                |\n *\n * Default parse format is: `'YYYY-MM-DDTHH:mm:ss.SSSZ'` see {@link #property-defaultParseFormat-static}\n *\n * For example:\n *\n * ```javascript\n * DateHelper.parse('2018-11-06', 'YYYY-MM-DD');\n * DateHelper.parse('13:14', 'HH:mm');\n * DateHelper.parse('6/11/18', 'DD/MM/YY');\n * ```\n *\n * ## Formatting dates\n * Use `DateHelper.format()` to create a string from a date using a format specifier. The format specifier is similar to\n * that used when parsing strings. It can use the following tokens (input used for output below is\n * `new Date(2018,8,9,18,7,8,145)`):\n *\n * | Unit                  | Token | Description & output                  |\n * |-----------------------|-------|---------------------------------------|\n * | Year                  | YYYY  | 2018                                  |\n * |                       | YY    | 18                                    |\n * |                       | Y     | 2018                                  |\n * | Quarter               | Q     | 3                                     |\n * |                       | Qo    | 3rd                                   |\n * | Month                 | MMMM  | September                             |\n * |                       | MMM   | Sep                                   |\n * |                       | MM    | 09                                    |\n * |                       | Mo    | 9th                                   |\n * |                       | M     | 9                                     |\n * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |\n * |                       | Wo    | 37th                                  |\n * |                       | W     | 37                                    |\n * |                       | WWp   | Week 37 (localized prefix, zero pad)  |\n * |                       | Wp    | Week 37 (localized prefix)            |\n * |                       | WWp0  | W37 (localized prefix)                |\n * |                       | Wp0   | W37 (localized prefix)                |\n * | Date                  | DDDD  | Day of year, 3 digits                 |\n * |                       | DDDo  | Day of year, ordinal                  |\n * |                       | DDD   | Day of year                           |\n * |                       | DD    | 09                                    |\n * |                       | Do    | 9th                                   |\n * |                       | D     | 9                                     |\n * | Weekday               | dddd  | Sunday                                |\n * |                       | ddd   | Sun                                   |\n * |                       | dd    | Su                                    |\n * |                       | d1    | S                                     |\n * |                       | do    | 0th                                   |\n * |                       | d     | 0                                     |\n * | Hour                  | HH    | 18 (00 - 23)                          |\n * |                       | H     | 18 (0 - 23)                           |\n * |                       | hh    | 06 (00 - 12)                          |\n * |                       | h     | 6 (0 - 12)                            |\n * |                       | KK    | 19 (01 - 24)                          |\n * |                       | K     | 19 (1 - 24)                           |\n * |                       | kk    | 06 or 18, locale determines           |\n * |                       | k     | 6 or 18, locale determines            |\n * | Minute                | mm    | 07                                    |\n * |                       | m     | 7                                     |\n * | Second                | ss    | 08                                    |\n * |                       | s     | 8                                     |\n * | Millisecond           | S     | 1 (100ms)                             |\n * |                       | SS    | 14 (140ms)                            |\n * |                       | SSS   | 145 (145ms)                           |\n * | AM/PM                 | A     | AM or PM                              |\n * |                       | a     | am or pm                              |\n * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |\n * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |\n * |                       | LST   | Depends on 12 or 24 hour clock        |\n * |                       |       | 12h, H : 1d, m : 0 or 2d              |\n * |                       |       | 24h, H : 2d, m : 2d                   |\n * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |\n * |                       | l     | Y: n, M : n, D : n                    |\n * |                       | LL    | Y: n, M : long (l), D : n             |\n * |                       | ll    | Y: n, M : short (s), D : n            |\n * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |\n * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |\n * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |\n * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |\n * |                       | u     | YYYYMMDDZ in UTC zone                 |\n * |                       | uu    | YYYYMMDDTHHMMSSZ in UTC zone          |\n *\n * Default format is: `'YYYY-MM-DDTHH:mm:ssZ'` see {@link #property-defaultFormat-static}\n *\n * For example:\n *\n * ```javascript\n * DateHelper.format(new Date(2018,10,6), 'YYYY-MM-DD'); // 2018-11-06\n * DateHelper.format(new Date(2018,10,6), 'M/D/YY'); // 11/6/18\n * ```\n *\n * Arbitrary text can be embedded in the format string by wrapping it with {}:\n *\n * ```javascript\n * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!\n * ```\n *\n * ## Unit names\n * Many DateHelper functions (for example add, as, set) accepts a unit among their params. The following units are\n * available:\n *\n * | Unit        | Aliases                       |\n * |-------------|-------------------------------|\n * | millisecond | millisecond, milliseconds, ms |\n * | second      | second, seconds, s            |\n * | minute      | minute, minutes, m            |\n * | hour        | hour, hours, h                |\n * | day         | day, days, d                  |\n * | week        | week, weeks, w                |\n * | month       | month, months, mon, mo, M     |\n * | quarter     | quarter, quarters, q          |\n * | year        | year, years, y                |\n * | decade      | decade, decades, dec          |\n *\n * For example:\n * ```javascript\n * DateHelper.add(date, 2, 'days');\n * DateHelper.as('hour', 7200, 'seconds');\n * ```\n * @static\n */\nexport default class DateHelper extends Localizable() {\n    static MS_PER_DAY = MS_PER_HOUR * 24;\n    static get $name() {\n        return 'DateHelper';\n    }\n    //region Parse & format\n    /**\n     * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`\n     * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).\n     * @member {String}\n     */\n    static set defaultFormat(format) {\n        DH._defaultFormat = format;\n    }\n    static get defaultFormat() {\n        return DH._defaultFormat || 'YYYY-MM-DDTHH:mm:ssZ';\n    }\n    /**\n     * Get/set the default format used by `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ss.SSSZ'` or {@link #property-defaultFormat-static}\n     * (~ISO 8601 Date and time, `'1962-06-17T09:21:34.123Z'`).\n     * @member {String}\n     */\n    static set defaultParseFormat(parseFormat) {\n        this._defaultParseFormat = parseFormat;\n    }\n    static get defaultParseFormat() {\n        return this._defaultParseFormat || this._defaultFormat || 'YYYY-MM-DDTHH:mm:ss.SSSZ';\n    }\n    static buildParser(format) {\n        // Split input format by regexp, which includes predefined patterns. Normally format would have some\n        // splitters, like 'YYYY-MM-DD' or 'D/M YYYY' so output will contain matched patterns as well as splitters\n        // which would serve as anchors. E.g. provided format is 'D/M!YYYY' and input is `11/6!2019` algorithm would work like:\n        // 1. split format by regexp                // ['', 'D', '/', 'M', '!', 'YYYY', '']\n        // 2. find splitters                        // ['/', '!']\n        // 3. split input by seps, step by step     // ['11', ['6', ['2019']]]\n        // Inputs like 'YYYYY' (5*Y) means 'YYYY' + 'Y', because it matches patterns from longer to shorter,\n        // but if few patterns describe same unit the last one is applied, for example\n        // DH.parse('20182015', 'YYYYY') equals to new Date(2015, 0, 0)\n        const\n            parts  = format.split(parserRegexp),\n            parser = [];\n        // if length of the parts array is 1 - there are no regexps in the input string. thus - no parsers\n        // do same if there are patterns matching locale strings (l, ll, LLLL etc.)\n        // returning empty array to use new Date() as parser\n        if (parts.length === 1 || localeStrRegExp.test(format)) {\n            return [];\n        }\n        else {\n            parts.reduce((prev, curr, index, array) => {\n                // ignore first and last empty string\n                if (index !== 0 || curr !== '') {\n                    // if current element matches parser regexp store it as a parser\n                    if (parserRegexp.test(curr)) {\n                        const\n                            localeParsers = this.localize('L{parsers}') || {},\n                            fn            = localeParsers[curr] || parsers[curr];\n                        // Z should be last element in the string that matches regexp. Last array element is always either\n                        // an empty string (if format ends with Z) or splitter (everything that doesn't match regexp after Z)\n                        // If there is a pattern after Z, then Z index will be lower than length - 2\n                        if (curr === 'Z' && index < array.length - 2) {\n                            throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);\n                        }\n                        const parserObj = (typeof fn === 'function') || (typeof fn === 'string')\n                            ? fn\n                            : fn.parser();\n                        // If fn is a string, we found an alias (L, LLL, l etc.).\n                        // Need to build parsers from mapped format and merge with existing\n                        if (typeof parserObj === 'string') {\n                            // we are going to merge nested parsers with current, some cleanup required:\n                            // 1. last element is no longer last\n                            // 2. need to pass last parser to the next step\n                            const\n                                nestedParsers = DH.buildParser(parserObj),\n                                lastItem      = nestedParsers.pop();\n                            delete lastItem.last;\n                            // elevate nested parsers\n                            parser.push(...nestedParsers);\n                            prev = lastItem;\n                        }\n                        else {\n                            prev.pattern = curr;\n                            prev.fn = parserObj;\n                        }\n                    }\n                    // if it doesn't match - we've found a splitter\n                    else {\n                        prev.splitter = curr;\n                        parser.push(prev);\n                        prev = {};\n                    }\n                }\n                else if (Object.prototype.hasOwnProperty.call(prev, 'pattern')) {\n                    parser.push(prev);\n                }\n                return prev;\n            }, {});\n        }\n        parser[parser.length - 1].last = true;\n        return parser;\n    }\n    /**\n     * A utility function to create a sortable string key for the passed date or ms timestamp using the `'YYYY-MM-DD'`\n     * format.\n     * @param {Number|Date} ms The Date instance or ms timestamp to generate a key for\n     * @returns {String} Date/timestamp as a string with `'YYYY-M-D'` format\n     * @internal\n     */\n    static makeKey(ms) {\n        // If an ten character string passed, assume it's already a key\n        if (ms.length === 10) {\n            return ms;\n        }\n        // Convert Date to ms timestamp\n        if (ms.getTime) {\n            ms = ms.getTime();\n        }\n        // Cache holds ms -> YYYY-MM-DD\n        const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];\n        if (cached) {\n            return cached;\n        }\n        tempDate.setTime(ms);\n        const\n            month = tempDate.getMonth() + 1,\n            date  = tempDate.getDate();\n        // Not using DateHelper.format to save some cycles, hit a lot\n        return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month < 10 ? '0' + month : month}-${date < 10 ? '0' + date : date}`;\n    }\n    /**\n     * A utility function to parse a sortable string to a date using the `'YYYY-MM-DD'` format.\n     * @param {String} key The string to return a date for\n     * @returns {Date} new Date instance\n     * @internal\n     */\n    static parseKey(key) {\n        return DH.parse(key, 'YYYY-MM-DD');\n    }\n    /**\n     * Returns a date created from the supplied string using the specified format. Will try to create even if format\n     * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default\n     * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.\n     * Supported tokens:\n     *\n     * | Unit        | Token | Description                       |\n     * |-------------|-------|-----------------------------------|\n     * | Year        | YYYY  | 2018                              |\n     * |             | YY    | < 68 -> 2000, > 68 -> 1900        |\n     * | Month       | MM    | 01 - 12                           |\n     * | Date        | DD    | 01 - 31                           |\n     * | Hour        | HH    | 00 - 23 or 1 - 12                 |\n     * | Minute      | mm    | 00 - 59                           |\n     * | Second      | ss    | 00 - 59                           |\n     * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |\n     * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |\n     * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |\n     * | AM/PM       | A     | AM or PM                          |\n     * |             | a     | am or pm                          |\n     * | TimeZone    | Z     | Z for UTC or +-HH:mm              |\n     * | Predefined  | L     | Long date, MM/DD/YYYY             |\n     * |             | LT    | Long time, HH:mm A                |\n     *\n     * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js\n     *\n     * NOTE: If no date parameters are provided then `Jan 01 2020` is used as a default date\n     *\n     * @param {String} dateString Date string\n     * @param {String} [format] Date format (or {@link #property-defaultParseFormat-static} if left out)\n     * @returns {Date} new Date instance parsed from the string\n     * @category Parse & format\n     */\n    static parse(dateString, format = DH.defaultParseFormat, strict = false) {\n        if (dateString instanceof Date) {\n            return dateString;\n        }\n        if (typeof dateString !== 'string' || !dateString) {\n            return null;\n        }\n        // // For ISO 8601 native is faster, but not very forgiving\n        // if (format === defaultFormat) {\n        //     const dt = new Date(dateString);\n        //     if (!isNaN(dt)) {\n        //         return dt;\n        //     }\n        // }\n        const config = {\n            year         : null,\n            month        : null,\n            date         : null,\n            hours        : null,\n            minutes      : null,\n            seconds      : null,\n            milliseconds : null\n        };\n        // Milliseconds parser is the same for S, SS, SSS\n        // We search for a string of 'S' characters *not* preceded by an alpha character.\n        // So that the formats such as 'LTS' do not get corrupted\n        format = format.replace(msRegExp, msReplacer);\n        let\n            parser = parserCache[format],\n            result;\n        if (!parser) {\n            parser = parserCache[format] = DH.buildParser(format);\n        }\n        // Since Unicode 15 standard arrived to browsers (Chrome 110+ and FF 109+) they add unicode \"thin\" space before AM/PM\n        // https://icu.unicode.org/download/72\n        // Convert unicode spaces to regular for parser\n        if (dateString.includes('\\u202f')) {\n            dateString = dateString.replace(/\\s/g, ' ');\n        }\n        // Each parser knows its pattern and splitter. It looks for splitter in the\n        // input string, takes first substring and tries to process it. Remaining string\n        // is passed to the next parser.\n        parser.reduce((dateString, parser) => {\n            if (parser.last) {\n                Object.assign(config, parser.fn(dateString));\n            }\n            else {\n                let splitAt;\n                // ISO 8601 says that T symbol can be replaced with a space\n                if (parser.splitter === 'T' && dateString.indexOf('T') === -1) {\n                    splitAt = dateString.indexOf(' ');\n                }\n                else {\n                    const timeZoneIndex = dateString.indexOf('+');\n                    let { splitter } = parser;\n                    // Use more forgiving regexp for parsing if strict mode is off\n                    if (!strict && splitRegExp.test(splitter)) {\n                        splitter = splitRegExp;\n                    }\n                    // If splitter specified find its position, otherwise try to determine pattern length\n                    splitAt = parser.splitter !== '' ? dateString.search(typeof splitter === 'string' ? StringHelper.escapeRegExp(splitter) : splitter) : parser.pattern?.length || -1;\n                    // Don't split in the time zone part\n                    if (timeZoneIndex > -1 && splitAt > timeZoneIndex) {\n                        splitAt = -1;\n                    }\n                }\n                let part, rest;\n                // If splitter is not found in the current string we may be dealing with\n                // 1. partial input - in that case we just feed all string to current parser and move on\n                // 2. time zone (ssZ - splitter is empty string) and pattern is not specified, see comment below\n                // 3. parse milliseconds before Z\n                if (splitAt === -1 || ((parser.pattern === 'SSS') && dateString.match(/^\\d+Z$/))) {\n                    // NOTE: parentheses are required here as + and - signs hold valuable information\n                    // with parentheses we get array like ['00','+','01:00'], omitting them we won't get\n                    // regexp match in result, loosing information\n                    const chunks = dateString.split(/([Z\\-+])/);\n                    // If splitter is not found in the string, we may be dealing with string that contains info about TZ.\n                    // For instance, if format contains Z as last arg which is not separated (normally it is not indeed),\n                    // like 'YYYY-MM-DD HH:mm:ssZ', then second to last parser will have string that it cannot just parse, like\n                    // '2010-01-01 10:00:00'        -> '00'\n                    // '2010-01-01 10:00:00Z'       -> '00Z'\n                    // '2010-01-01 10:00:00-01'     -> '00-01'\n                    // '2010-01-01 10:00:00+01:30'  -> '00+01:30'\n                    // this cannot be processed by date parsers, so we need to process that additionally. So we\n                    // split string by symbols that can be found around timezone info: Z,-,+\n                    if (chunks.length === 1) {\n                        part = dateString;\n                        rest = '';\n                    }\n                    else {\n                        part = chunks[0];\n                        rest = `${chunks[1]}${chunks[2]}`;\n                    }\n                }\n                else {\n                    part = dateString.substring(0, splitAt) || dateString;\n                    rest = dateString.substring(splitAt + parser.splitter.length);\n                }\n                if (parser.fn) {\n                    // Run parser and add result to config on successful parse otherwise continue parsing\n                    const res = parser.fn(part);\n                    if (res) {\n                        Object.assign(config, res);\n                    }\n                    else {\n                        rest = part + rest;\n                    }\n                }\n                return rest;\n            }\n        }, dateString);\n        // If year is specified date has to be greater than 0\n        if (config.year && !config.date) {\n            config.date = 1;\n        }\n        if (config.date > 31 || config.month > 12) {\n            return null;\n        }\n        const date = DH.create(config, strict);\n        if (date) {\n            result = date;\n        }\n        else if (!strict) {\n            // Last resort, try if native passing can do it\n            result = new Date(dateString);\n        }\n        return result;\n    }\n    /**\n     * Creates a date from a date definition object. The object can have the following properties:\n     * - year\n     * - month\n     * - date (day in month)\n     * - hours\n     * - minutes\n     * - seconds\n     * - milliseconds\n     * - amPm : 'am' or 'pm', implies 12-hour clock\n     * - timeZone : offset from UTC in minutes\n     * @param {Object} definition\n     * @param {Number} definition.year\n     * @param {Number} [definition.month]\n     * @param {Number} [definition.date]\n     * @param {Number} [definition.hours]\n     * @param {Number} [definition.minutes]\n     * @param {Number} [definition.seconds]\n     * @param {Number} [definition.milliseconds]\n     * @param {Number} [definition.amPm]\n     * @param {Number} [definition.timeZone]\n     * @returns {Date} new Date instance\n     * @category Parse & format\n     */\n    static create(definition, strict = false) {\n        // Shallow clone to not alter input\n        const def = { ...definition };\n        let invalid = isNaN(def.year) || (strict && (isNaN(def.month) || isNaN(def.date))),\n            useUTC  = false;\n        // Not much validation yet, only considered invalid if all properties are null\n        if (!invalid) {\n            let allNull = true;\n            dateProperties.forEach(property => {\n                if (!(property in def) || isNaN(def[property])) {\n                    def[property] = 0;\n                }\n                allNull = allNull && def[property] === null;\n            });\n            invalid = allNull;\n        }\n        if (invalid) {\n            return null;\n        }\n        if (def.amPm === 'am') {\n            def.hours = def.hours % 12;\n        }\n        else if (def.amPm === 'pm') {\n            def.hours = (def.hours % 12) + 12;\n        }\n        if ('timeZone' in def) {\n            useUTC = true;\n            def.minutes -= def.timeZone;\n        }\n        if (strict && (def.year == null || def.month == null || def.date == null)) {\n            return null;\n        }\n        const\n            args = [\n                defaultValue(def.year, DEFAULT_YEAR),\n                defaultValue(def.month, DEFAULT_MONTH),\n                defaultValue(def.date, DEFAULT_DAY),\n                def.hours,\n                def.minutes,\n                def.seconds,\n                def.milliseconds\n            ];\n        return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);\n    }\n    static toUTC(date) {\n        return new Date(Date.UTC(\n            date.getUTCFullYear(),\n            date.getUTCMonth(),\n            date.getUTCDate(),\n            date.getUTCHours(),\n            date.getUTCMinutes(),\n            date.getUTCSeconds(),\n            date.getUTCMilliseconds()\n        ));\n    }\n    /**\n     * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.\n     * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):\n     *\n     * | Unit                  | Token | Description & output                  |\n     * |-----------------------|-------|---------------------------------------|\n     * | Year                  | YYYY  | 2018                                  |\n     * |                       | YY    | 18                                    |\n     * |                       | Y     | 2018                                  |\n     * | Quarter               | Q     | 3                                     |\n     * |                       | Qo    | 3rd                                   |\n     * | Month                 | MMMM  | September                             |\n     * |                       | MMM   | Sep                                   |\n     * |                       | MM    | 09                                    |\n     * |                       | Mo    | 9th                                   |\n     * |                       | M     | 9                                     |\n     * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |\n     * |                       | Wo    | 37th                                  |\n     * |                       | W     | 37                                    |\n     * |                       | WWp   | Week 37 (localized prefix, zero pad)  |\n     * |                       | Wp    | Week 37 (localized prefix)            |\n     * |                       | WWp0  | W37 (localized prefix)                |\n     * |                       | Wp0   | W37 (localized prefix)                |\n     * | Date                  | DDDD  | Day of year, 3 digits                 |\n     * |                       | DDDo  | Day of year, ordinal                  |\n     * |                       | DDD   | Day of year                           |\n     * |                       | DD    | 09                                    |\n     * |                       | Do    | 9th                                   |\n     * |                       | D     | 9                                     |\n     * | Weekday               | dddd  | Sunday                                |\n     * |                       | ddd   | Sun                                   |\n     * |                       | dd    | Su                                    |\n     * |                       | d1    | S                                     |\n     * |                       | do    | 0th                                   |\n     * |                       | d     | 0                                     |\n     * | Hour                  | HH    | 18 (00 - 23)                          |\n     * |                       | H     | 18 (0 - 23)                           |\n     * |                       | hh    | 06 (00 - 12)                          |\n     * |                       | h     | 6 (0 - 12)                            |\n     * |                       | KK    | 19 (01 - 24)                          |\n     * |                       | K     | 19 (1 - 24)                           |\n     * |                       | kk    | 06 or 18, locale determines           |\n     * |                       | k     | 6 or 18, locale determines            |\n     * | Minute                | mm    | 07                                    |\n     * |                       | m     | 7                                     |\n     * | Second                | ss    | 08                                    |\n     * |                       | s     | 8                                     |\n     * | Millisecond           | S     | 1 (100ms)                             |\n     * |                       | SS    | 14 (140ms)                            |\n     * |                       | SSS   | 145 (145ms)                           |\n     * | AM/PM                 | A     | AM or PM                              |\n     * |                       | a     | am or pm                              |\n     * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |\n     * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |\n     * |                       | LST   | Depends on 12 or 24 hour clock        |\n     * |                       |       | 12h, H : 1d, m : 0 or 2d              |\n     * |                       |       | 24h, H : 2d, m : 2d                   |\n     * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |\n     * |                       | l     | Y: n, M : n, D : n                    |\n     * |                       | LL    | Y: n, M : long (l), D : n             |\n     * |                       | ll    | Y: n, M : short (s), D : n            |\n     * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |\n     * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |\n     * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |\n     * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |\n     *\n     * Some examples:\n     *\n     * ```javascript\n     * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday\n     * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27\n     * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14\n     * ```\n     *\n     * Arbitrary text can be embedded in the format string by wrapping it with {}:\n     *\n     * ```javascript\n     * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!\n     * ```\n     *\n     * @param {Date} date Date\n     * @param {String} [format] Desired format (uses `defaultFormat` if left out)\n     * @returns {String} Formatted string\n     * @category Parse & format\n     */\n    static format(date, format = DH.defaultFormat) {\n        // Bail out if no date or invalid date\n        if (!date || isNaN(date)) {\n            return null;\n        }\n        let formatter = formatCache[format],\n            output    = '';\n        if (!formatter) {\n            formatter = formatCache[format] = [];\n            // Build formatter array with the steps needed to format the date\n            for (let i = 0; i < format.length; i++) {\n                // Matches a predefined format?\n                const\n                    formatMatch = format.slice(i).match(formatRegexp),\n                    predefined  = formatMatch?.[0];\n                if (predefined) {\n                    const\n                        localeFormats = this.localize('L{formats}') || {},\n                        fn            = localeFormats[predefined] || formats[predefined];\n                    formatter.push(fn);\n                    i += predefined.length - 1;\n                }\n                // Start of text block? Append it\n                else if (format[i] === '{') {\n                    // Find closing brace\n                    const index = format.indexOf('}', i + 1);\n                    // No closing brace, grab rest of string\n                    if (index === -1) {\n                        formatter.push(format.substr(i + 1));\n                        i = format.length;\n                    }\n                    // Closing brace found\n                    else {\n                        formatter.push(format.substring(i + 1, index));\n                        // Carry on after closing brace\n                        i = index;\n                    }\n                }\n                // Otherwise append to output (for example - / : etc)\n                else {\n                    formatter.push(format[i]);\n                }\n            }\n        }\n        formatter.forEach(step => {\n            if (typeof step === 'string') {\n                output += step;\n            }\n            else {\n                output += step(date);\n            }\n        });\n        return output;\n    }\n    /**\n     * Formats a range of `dates` using the specified `format`. Because two dates are involved, the `format` specifier\n     * uses the tokens `S{}` and `E{}`. The text contained between the `{}` is the {@link #function-format-static format}\n     * for the start date or end date, respectively. Text not inside these tokens is retained verbatim.\n     *\n     * For example:\n     *\n     * ```javascript\n     *  DateHelper.formatRange(dates, 'S{DD MMM YYYY} - E{DD MMM YYYY}');\n     * ```\n     *\n     * The above will format `dates[0]` based on the `S{DD MMM YYYY}` segment and `dates[1] using `E{DD MMM YYYY}`. The\n     * `' - '` between these will remain between the two formatted dates.\n     *\n     * @param {Date[]} dates An array of start date and end date (`[startDate, endDate]`)\n     * @param {String} format The format specifier\n     * @returns {String}\n     */\n    static formatRange(dates, format) {\n        return format.replace(rangeFormatPartRe,\n            (s, which, fmt) => DateHelper.format(dates[(which === 'S') ? 0 : 1], fmt));\n    }\n    /**\n     * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the\n     * first argument, it then uses `amount = 1`.\n     *\n     * For example:\n     *\n     * ```javascript\n     * asMilliseconds('hour') == asMilliseconds(1, 'hour')\n     * ```\n     *\n     * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)\n     * @param {String} [unit] Time unit (s, hour, months etc.)\n     * @returns {Number}\n     * @category Parse & format\n     */\n    static asMilliseconds(amount, unit = null) {\n        if (typeof amount === 'string') {\n            unit = amount;\n            amount = 1;\n        }\n        return DH.as('millisecond', amount, unit);\n    }\n    /**\n     * Converts the passed Date to an accurate number of months passed since the epoch start.\n     * @param {Date} time The Date to find the month value of\n     * @returns {Number} The number of months since the system time epoch start. May be a fractional value\n     */\n    static asMonths(time) {\n        const\n            monthLength = DH.as('ms', DH.daysInMonth(time), 'day'),\n            fraction = (time.valueOf() - DH.startOf(time, 'month').valueOf()) / monthLength;\n        return time.getYear() * 12 + time.getMonth() + fraction;\n    }\n    static monthsToDate(months) {\n        const\n            intMonths = Math.floor(months),\n            fraction = months - intMonths,\n            result = new Date(0, intMonths),\n            msInMonth = DH.as('ms', DH.daysInMonth(result), 'days');\n        result.setTime(result.getTime() + fraction * msInMonth);\n        return result;\n    }\n    /**\n     * Converts a millisecond time delta to a human-readable form. For example `1000 * 60 * 60 * 50`\n     * milliseconds would be rendered as `'2 days, 2 hours'`.\n     * @param {Number} delta The millisecond delta value\n     * @param {Object} [options] Formatting options\n     * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `'2d, 2h'` for the above example\n     * @param {String} [options.precision] The minimum precision unit\n     * @param {String} [options.separator] The separator to use\n     * @param {Boolean} [options.asString] Pass `false` to return the result as an array, eg ['2d', '2h'] for the above example\n     * @returns {String} Formatted string\n     * @category Parse & format\n     */\n    static formatDelta(delta, options) {\n        let abbrev, unitName;\n        if (typeof options === 'boolean') {\n            abbrev = options;\n        }\n        else if (options) {\n            abbrev    = options.abbrev;\n        }\n        const\n            deltaObj = this.getDelta(delta, options),\n            result   = [],\n            sep      = options?.separator || (abbrev ? '' : ' ');\n        for (unitName in deltaObj) {\n            result.push(`${deltaObj[unitName]}${sep}${unitName}`);\n        }\n        return options?.asString === false ? result : result.join(', ');\n    }\n    /**\n     * Converts a millisecond time delta to an object structure. For example `1000 * 60 * 60 * 50`\n     * milliseconds the result would be as:\n     *\n     * ```javascript\n     * {\n     *     day  : 2,\n     *     hour : 2\n     * }\n     *```\n     *\n     * @param {Number} delta The millisecond delta value\n     * @param {Object} [options] Formatting options\n     * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `{ d: 2, h: 2 }` for the above example\n     * @param {String} [options.precision] The minimum precision unit\n     * @param {Boolean} [options.ignoreLocale] Pass true to return unlocalized unit name. Requires `abbrev` to be false\n     * @param {String} [options.maxUnit] Name of the maximum unit in the output. e.g. if you pass `day` then you'll get\n     * `{ h: 25 }` instead of `{ d: 1, h: 1 }`\n     * @returns {Object} The object with the values for each unit\n     */\n    static getDelta(delta, options) {\n        let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;\n        if (typeof options === 'boolean') {\n            abbrev = options;\n        }\n        else if (options) {\n            abbrev = options.abbrev;\n            precision = DH.normalizeUnit(options.precision);\n            maxUnit = options.maxUnit;\n            ignoreLocale = !abbrev && options.ignoreLocale;\n        }\n        const\n            result  = {},\n            getUnit = abbrev ? DH.getShortNameOfUnit : DH.getLocalizedNameOfUnit;\n        const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;\n        // Loop downwards through the magnitude of units from year -> ms\n        for (unitName of units) {\n            d = DH.as(unitName, delta);\n            done = precision === unitName;\n            d = Math[done ? 'round' : 'floor'](d);\n            // If there's a non-zero integer quantity of this unit, add it to result\n            // and subtract from the delta, then go round to next unit down.\n            if (d || (done && !result.length)) {\n                result[ignoreLocale ? unitName : getUnit.call(DH, unitName, d !== 1)] = d;\n                delta -= DH.as('ms', d, unitName);\n            }\n            if (done || !delta) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Converts the specified amount of one unit (`fromUnit`) into an amount of another unit (`toUnit`).\n     * @param {String} toUnit The name of units to convert to, eg: `'ms'`\n     * @param {Number|String} amount The time to convert. Either the magnitude number form or a duration string such as '2d'\n     * @param {String} [fromUnit='ms'] If the amount was passed as a number, the units to use to convert from\n     * @returns {Number}\n     * @category Parse & format\n     */\n    static as(toUnit, amount, fromUnit = 'ms') {\n        // Allow DH.as('ms', '2d')\n        if (typeof amount === 'string') {\n            amount = DH.parseDuration(amount);\n        }\n        // Allow DH.as('ms', myDurationObject)\n        if (typeof amount === 'object') {\n            fromUnit = amount.unit;\n            amount = amount.magnitude;\n        }\n        if (toUnit === fromUnit) {\n            return amount;\n        }\n        toUnit = DH.normalizeUnit(toUnit);\n        fromUnit = DH.normalizeUnit(fromUnit);\n        if (toUnit === fromUnit) {\n            return amount;\n        }\n        // validConversions[][] can be negative to signal that conversion is not exact, ignore sign here\n        else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {\n            return amount * Math.abs(validConversions[fromUnit][toUnit]);\n        }\n        else {\n            return amount / Math.abs(validConversions[toUnit][fromUnit]);\n        }\n    }\n    static formatContainsHourInfo(format) {\n        const\n            stripEscapeRe = /(\\\\.)/g,\n            hourInfoRe    = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;\n        return hourInfoRe.test(format.replace(stripEscapeRe, ''));\n    }\n    /**\n     * Returns `true` for 24-hour format.\n     * @param {String} format Date format\n     * @returns {Boolean} `true` for 24-hour format\n     * @category Parse & format\n     */\n    static is24HourFormat(format) {\n        return DH.format(DH.getTime(13, 0, 0), format).includes('13');\n    }\n    //endregion\n    //region Manipulate\n    /**\n     * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.\n     * @param {Date|String} date Original date\n     * @param {Number|String|Core.data.Duration|DurationConfig} amount Amount of days, hours etc. or a string representation of a duration\n     * as accepted by {@link #function-parseDuration-static} or an object with `{ magnitude, unit }` properties\n     * @param {String} [unit='ms'] Unit for amount\n     * @privateparam {Boolean} [clone=true] Pass `false` to affect the original\n     * @returns {Date} New calculated date\n     * @category Manipulate\n     */\n    static add(date, amount, unit = 'ms', clone = true) {\n        let d;\n        if (typeof date === 'string') {\n            d = DH.parse(date);\n        }\n        else if (clone) {\n            d = new Date(date.getTime());\n        }\n        else {\n            d = date;\n        }\n        if (typeof amount === 'string') {\n            const duration = DateHelper.parseDuration(amount);\n            amount = duration.magnitude;\n            unit   = duration.unit;\n        }\n        else if (amount && typeof amount === 'object') {\n            unit = amount.unit;\n            amount = amount.magnitude;\n        }\n        if (!unit || amount === 0) {\n            return d;\n        }\n        unit = DH.normalizeUnit(unit);\n        switch (unit) {\n            case 'millisecond':\n                d.setTime(d.getTime() + amount);\n                break;\n            case 'second':\n                d.setTime(d.getTime() + (amount * 1000));\n                break;\n            case 'minute':\n                d.setTime(d.getTime() + (amount * 60000));\n                break;\n            case 'hour':\n                d.setTime(d.getTime() + (amount * 3600000));\n                break;\n            case 'day':\n                // Integer value added, do calendar calculation to correctly handle DST etc.\n                if (amount % 1 === 0) {\n                    d.setDate(d.getDate() + amount);\n                    // When crossing DST in Brazil, we expect hours to end up the same\n                    if (d.getHours() === 23 && date.getHours() === 0) {\n                        d.setHours(d.getHours() + 1);\n                    }\n                }\n                // No browsers support fractional values for dates any longer, do time based calculation\n                else {\n                    d.setTime(d.getTime() + (amount * 86400000));\n                }\n                break;\n            case 'week':\n                d.setDate(d.getDate() + amount * 7);\n                break;\n            case 'month': {\n                let day = d.getDate();\n                if (day > 28) {\n                    day = Math.min(day, DH.getLastDateOfMonth(DH.add(DH.getFirstDateOfMonth(d), amount, 'month')).getDate());\n                }\n                d.setDate(day);\n                d.setMonth(d.getMonth() + amount);\n                break;\n            }\n            case 'quarter':\n                DH.add(d, amount * 3, 'month', false);\n                break;\n            case 'year':\n                d.setFullYear(d.getFullYear() + amount);\n                break;\n            case 'decade':\n                d.setFullYear(d.getFullYear() + amount * 10);\n                break;\n        }\n        return d;\n    }\n    /**\n     * Calculates the difference between two dates, in the specified unit.\n     * @param {Date} start First date\n     * @param {Date} end Second date\n     * @param {String} [unit='ms'] Unit to calculate difference in\n     * @param {Boolean} [fractional=true] Specify false to round result\n     * @returns {Number} Difference in the specified unit\n     * @category Manipulate\n     */\n    static diff(start, end, unit = 'ms', fractional = true) {\n        unit = DH.normalizeUnit(unit);\n        if (!start || !end) return 0;\n        let amount;\n        switch (unit) {\n            case 'year':\n                amount = DH.diff(start, end, 'month') / 12;\n                break;\n            case 'quarter':\n                amount = DH.diff(start, end, 'month') / 3;\n                break;\n            case 'month':\n                amount = ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());\n                if (amount === 0 && fractional) {\n                    amount = DH.diff(start, end, 'day', fractional) / DH.daysInMonth(start);\n                }\n                break;\n            case 'week':\n                amount = DH.diff(start, end, 'day') / 7;\n                break;\n            case 'day': {\n                const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();\n                amount = (end - start + dstDiff * 60 * 1000) / 86400000;\n                break;\n            }\n            case 'hour':\n                amount = (end - start) / 3600000;\n                break;\n            case 'minute':\n                amount = (end - start) / 60000;\n                break;\n            case 'second':\n                amount = (end - start) / 1000;\n                break;\n            case 'millisecond':\n                amount = (end - start);\n                break;\n        }\n        return fractional ? amount : Math.round(amount);\n    }\n    /**\n     * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it\n     * in place.\n     * @param {Date} date Original date\n     * @param {String} [unit='day'] Start of this unit, `'day'`, `'month'` etc\n     * @param {Boolean} [clone=true] Manipulate a copy of the date\n     * @param {Number} [weekStartDay] The first day of week, `0-6` (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}\n     * @returns {Date} Manipulated date\n     * @category Manipulate\n     */\n    static startOf(date, unit = 'day', clone = true, weekStartDay = DH.weekStartDay) {\n        if (!date) {\n            return null;\n        }\n        unit = DH.normalizeUnit(unit);\n        if (clone) {\n            date = DH.clone(date);\n        }\n        switch (unit) {\n            case 'year':\n                date.setMonth(0, 1);\n                date.setHours(0, 0, 0, 0);\n                return date;\n            case 'quarter':\n                date.setMonth((DH.get(date, 'quarter') - 1) * 3, 1);\n                date.setHours(0, 0, 0, 0);\n                return date;\n            case 'month':\n                date.setDate(1);\n                date.setHours(0, 0, 0, 0);\n                return date;\n            case 'week': {\n                const delta = date.getDay() - weekStartDay;\n                date.setDate(date.getDate() - delta);\n                date.setHours(0, 0, 0, 0);\n                return date;\n            }\n            case 'day':\n                date.setHours(0, 0, 0, 0);\n                return date;\n            // Cant use setMinutes(0, 0, 0) etc. for DST transitions\n            case 'hour':\n                date.getMinutes() > 0 && date.setMinutes(0);\n            // eslint-disable-next-line no-fallthrough\n            case 'minute':\n                date.getSeconds() > 0 && date.setSeconds(0);\n            // eslint-disable-next-line no-fallthrough\n            case 'second':\n                date.getMilliseconds() > 0 && date.setMilliseconds(0);\n            // eslint-disable-next-line no-fallthrough\n            case 'millisecond':\n                return date;\n        }\n    }\n    /**\n     * Returns the end point of the passed date, that is 00:00:00 of the day after the passed date.\n     * @param {Date} date The date to return the end point of\n     * @returns {Date} Manipulated date\n     */\n    static endOf(date) {\n        return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);\n    }\n    /**\n     * Creates a clone of the specified date\n     * @param {Date} date Original date\n     * @returns {Date} Cloned date\n     * @category Manipulate\n     */\n    static clone(date) {\n        return new Date(date.getTime());\n    }\n    /**\n     * Removes time from a date (same as calling {@link #function-startOf-static startOf(date)}).\n     * @param {Date} date Date to remove time from\n     * @param {Boolean} [clone=true] Manipulate a copy of the date\n     * @returns {Date} Manipulated date\n     * @category Manipulate\n     */\n    static clearTime(date, clone = true) {\n        if (!date) {\n            return null;\n        }\n        if (clone) {\n            date = new Date(date.getTime());\n        }\n        date.setHours(0, 0, 0, 0);\n        return date;\n    }\n    static midnight(date, inclusive) {\n        let ret = DH.clearTime(date);\n        if (inclusive && ret < date) {\n            ret = DH.add(ret, 1, 'd');\n        }\n        return ret;\n    }\n    /**\n     * Returns the elapsed milliseconds from the start of the specified date.\n     * @param {Date} date Date to remove date from\n     * @param {String} [unit='ms'] The time unit to return\n     * @returns {Number} The elapsed milliseconds from the start of the specified date\n     * @category Manipulate\n     */\n    static getTimeOfDay(date, unit = 'ms') {\n        const t = (date.getHours() * validConversions.hour.millisecond) +\n            (date.getMinutes() * validConversions.minute.millisecond) +\n            (date.getSeconds() * validConversions.second.millisecond) +\n            date.getMilliseconds();\n        return (unit === 'ms') ? t : DH.as(unit, t, 'ms');\n    }\n    /**\n     * Sets a part of a date (in place).\n     * @param {Date} date Date to manipulate\n     * @param {String|Object} unit Part of date to set, for example `'minute'`. Or an object like `{ second: 1, minute: 1 }`\n     * @param {Number} amount Value to set\n     * @returns {Date} Passed date instance modified according to the arguments\n     * @category Manipulate\n     */\n    static set(date, unit, amount) {\n        if (!unit) {\n            return date;\n        }\n        if (typeof unit === 'string') {\n            switch (DH.normalizeUnit(unit)) {\n                case 'millisecond':\n                    // Setting value to 0 when it is 0 at DST crossing messes it up\n                    if (amount !== 0 || date.getMilliseconds() > 0) {\n                        date.setMilliseconds(amount);\n                    }\n                    break;\n                case 'second':\n                    // Setting value to 0 when it is 0 at DST crossing messes it up\n                    if (amount !== 0 || date.getSeconds() > 0) {\n                        date.setSeconds(amount);\n                    }\n                    break;\n                case 'minute':\n                    // Setting value to 0 when it is 0 at DST crossing messes it up\n                    if (amount !== 0 || date.getMinutes() > 0) {\n                        date.setMinutes(amount);\n                    }\n                    break;\n                case 'hour':\n                    date.setHours(amount);\n                    break;\n                case 'day':\n                case 'date':\n                    date.setDate(amount);\n                    break;\n                case 'week':\n                    throw new Error('week not implemented');\n                case 'month':\n                    date.setMonth(amount);\n                    break;\n                case 'quarter':\n                    // Setting quarter = first day of first month of that quarter\n                    date.setDate(1);\n                    date.setMonth((amount - 1) * 3);\n                    break;\n                case 'year':\n                    date.setFullYear(amount);\n                    break;\n            }\n        }\n        else {\n            Object.entries(unit)\n                // Make sure smallest unit goes first, to not change month before changing day\n                .sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]])\n                .forEach(([unit, amount]) => {\n                    DH.set(date, unit, amount);\n                });\n        }\n        return date;\n    }\n    static setDateToMidday(date, clone = true) {\n        return DH.set(DH.clearTime(date, clone), 'hour', 12);\n    }\n    /**\n     * Constrains the date within a min and a max date.\n     * @param {Date} date The date to constrain\n     * @param {Date} [min] Min date\n     * @param {Date} [max] Max date\n     * @returns {Date} The constrained date\n     * @category Manipulate\n     */\n    static constrain(date, min, max) {\n        if (min != null) {\n            date = DH.max(date, min);\n        }\n        return max == null ? date : DH.min(date, max);\n    }\n    /**\n     * Returns time with default year, month, and day (Jan 1, 2020).\n     * @param {Number|Date} hours Hours value or the full date to extract the time of\n     * @param {Number} [minutes=0] Minutes value\n     * @param {Number} [seconds=0] Seconds value\n     * @param {Number} [ms=0] Milliseconds value\n     * @returns {Date} A new default date with the time extracted from the given date or from the time values provided individually\n     * @category Manipulate\n     */\n    static getTime(hours, minutes = 0, seconds = 0, ms = 0) {\n        if (hours instanceof Date) {\n            ms = hours.getMilliseconds();\n            seconds = hours.getSeconds();\n            minutes = hours.getMinutes();\n            hours = hours.getHours();\n        }\n        return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);\n    }\n    /**\n     * Copies hours, minutes, seconds, milliseconds from one date to another.\n     *\n     * @param {Date} targetDate The target date\n     * @param {Date} sourceDate The source date\n     * @returns {Date} The adjusted target date\n     * @category Manipulate\n     * @static\n     */\n    static copyTimeValues(targetDate, sourceDate) {\n        targetDate.setHours(sourceDate.getHours());\n        targetDate.setMinutes(sourceDate.getMinutes());\n        targetDate.setSeconds(sourceDate.getSeconds());\n        targetDate.setMilliseconds(sourceDate.getMilliseconds());\n        return targetDate;\n    }\n    //endregion\n    //region Comparison\n    static get isDSTEnabled() {\n        const\n            year = new Date().getFullYear(),\n            jan  = new Date(year, 0, 1),\n            jul  = new Date(year, 6, 1);\n        return jan.getTimezoneOffset() !== jul.getTimezoneOffset();\n    }\n    static isDST(date) {\n        const\n            year = date.getFullYear(),\n            jan  = new Date(year, 0, 1),\n            jul  = new Date(year, 6, 1);\n        return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n    }\n    /**\n     * Determines if a date precedes another.\n     * @param {Date} first First date\n     * @param {Date} second Second date\n     * @returns {Boolean} `true` if first precedes second, otherwise false\n     * @category Comparison\n     */\n    static isBefore(first, second) {\n        return first < second;\n    }\n    /**\n     * Determines if a date succeeds another.\n     * @param {Date} first First date\n     * @param {Date} second Second date\n     * @returns {Boolean} `true` if first succeeds second, otherwise false\n     * @category Comparison\n     */\n    static isAfter(first, second) {\n        return first > second;\n    }\n    /**\n     * Checks if two dates are equal.\n     * @param {Date} first First date\n     * @param {Date} second Second date\n     * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond\n     * @returns {Boolean} `true` if the dates are equal\n     * @category Comparison\n     */\n    static isEqual(first, second, unit = null) {\n        if (unit === null) {\n            // https://jsbench.me/3jk2bom2r3/1\n            // https://jsbench.me/ltkb3vk0ji/1 (more flavors) - getTime is >2x faster vs valueOf/Number/op+\n            return first && second && first.getTime() === second.getTime();\n        }\n        return DH.startOf(first, unit) - DH.startOf(second, unit) === 0;\n    }\n    /**\n     * Compares two dates using the specified precision.\n     * @param {Date} first First date\n     * @param {Date} second Second date\n     * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond\n     * @returns {Number} `0` = equal, `-1` = first before second, `1` = first after second\n     * @category Comparison\n     */\n    static compare(first, second, unit = null) {\n        // Unit specified, cut the rest out\n        if (unit) {\n            first = DH.startOf(first, unit);\n            second = DH.startOf(second, unit);\n        }\n        // Comparison on ms level\n        if (first < second) return -1;\n        if (first > second) return 1;\n        return 0;\n    }\n    /**\n     * Coerces the passed Date between the passed minimum and maximum values.\n     * @param {Date} date The date to clamp between the `min` and `max`\n     * @param {Date} min The minimum Date\n     * @param {Date} max The maximum Date\n     * @returns {Date} If the passed `date` is valid, a *new* Date object which is clamped between the `min` and `max`\n     */\n    static clamp(date, min, max) {\n        if (!isNaN(date)) {\n            if (min != null) {\n                date = Math.max(date, min);\n            }\n            if (max != null) {\n                date = Math.min(date, max);\n            }\n            return new Date(date);\n        }\n    }\n    static isSameDate(first, second) {\n        return DH.compare(first, second, 'd') === 0;\n    }\n    static isSameTime(first, second) {\n        return first.getHours() === second.getHours() &&\n            first.getMinutes() === second.getMinutes() &&\n            first.getSeconds() === second.getSeconds() &&\n            first.getMilliseconds() === second.getMilliseconds();\n    }\n    /**\n     * Checks if date is the start of specified unit.\n     * @param {Date} date Date\n     * @param {String} unit Time unit\n     * @returns {Boolean} `true` if date is the start of specified unit\n     * @category Comparison\n     */\n    static isStartOf(date, unit) {\n        return DH.isEqual(date, DH.startOf(date, unit));\n    }\n    /**\n     * Checks if this date is `>= start` and `< end`.\n     * @param {Date} date The source date\n     * @param {Date} start Start date\n     * @param {Date} end End date\n     * @returns {Boolean} `true` if this date falls on or between the given start and end dates\n     * @category Comparison\n     */\n    static betweenLesser(date, start, end) {\n        //return start <= date && date < end;\n        return start.getTime() <= date.getTime() && date.getTime() < end.getTime();\n    }\n    /**\n     * Checks if this date is `>= start` and `<= end`.\n     * @param {Date} date The source date\n     * @param {Date} start Start date\n     * @param {Date} end End date\n     * @returns {Boolean} `true` if this date falls on or between the given start and end dates\n     * @category Comparison\n     */\n    static betweenLesserEqual(date, start, end) {\n        return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();\n    }\n    /**\n     * Returns `true` if dates intersect.\n     * @param {Date} date1Start Start date of first span\n     * @param {Date} date1End End date of first span\n     * @param {Date} date2Start Start date of second span\n     * @param {Date} date2End End date of second span\n     * @returns {Boolean} Returns `true` if dates intersect\n     * @category Comparison\n     */\n    static intersectSpans(date1Start, date1End, date2Start, date2End) {\n        return DH.betweenLesser(date1Start, date2Start, date2End) ||\n            DH.betweenLesser(date2Start, date1Start, date1End);\n    }\n    /**\n     * Compare two units. Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal.\n     * @param {String} unit1 The 1st unit\n     * @param {String} unit2 The 2nd unit\n     * @returns {Number} Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal\n     * @category Comparison\n     */\n    static compareUnits(unit1, unit2) {\n        return Math.sign(unitMagnitudes[DH.normalizeUnit(unit1)] - unitMagnitudes[DH.normalizeUnit(unit2)]);\n    }\n    /**\n     * Returns `true` if the first time span completely 'covers' the second time span.\n     *\n     * @example\n     * DateHelper.timeSpanContains(\n     *     new Date(2010, 1, 2),\n     *     new Date(2010, 1, 5),\n     *     new Date(2010, 1, 3),\n     *     new Date(2010, 1, 4)\n     * ) ==> true\n     * DateHelper.timeSpanContains(\n     *   new Date(2010, 1, 2),\n     *   new Date(2010, 1, 5),\n     *   new Date(2010, 1, 3),\n     *   new Date(2010, 1, 6)\n     * ) ==> false\n     *\n     * @param {Date} spanStart The start date for initial time span\n     * @param {Date} spanEnd The end date for initial time span\n     * @param {Date} otherSpanStart The start date for the 2nd time span\n     * @param {Date} otherSpanEnd The end date for the 2nd time span\n     * @returns {Boolean} `true` if the first time span completely 'covers' the second time span\n     * @category Comparison\n     */\n    static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {\n        return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;\n    }\n    //endregion\n    //region Query\n    /**\n     * Get the first day of week, 0-6 (Sunday-Saturday).\n     * This is determined by the current locale's `DateHelper.weekStartDay` parameter.\n     * @property {Number}\n     * @readonly\n     */\n    static get weekStartDay() {\n        // Cache is reset in applyLocale\n        if (DH._weekStartDay == null) {\n            // Defaults to 0, should not need to happen in real world scenarios when a locale is always loaded\n            DH._weekStartDay = this.localize('L{weekStartDay}') || 0;\n        }\n        return DH._weekStartDay;\n    }\n    /**\n     * Get non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.\n     * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.\n     *\n     * For example:\n     * ```javascript\n     * {\n     *     0 : true, // Sunday\n     *     6 : true  // Saturday\n     * }\n     * ```\n     *\n     * @property {Object<Number,Boolean>}\n     * @readonly\n     */\n    static get nonWorkingDays() {\n        return { ...this.localize('L{nonWorkingDays}') };\n    }\n    /**\n     * Get non-working days as an array of day indices, 0-6 (Sunday-Saturday).\n     * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.\n     *\n     * For example:\n     *\n     * ```javascript\n     * [ 0, 6 ] // Sunday & Saturday\n     * ```\n     *\n     * @property {Number[]}\n     * @readonly\n     * @internal\n     */\n    static get nonWorkingDaysAsArray() {\n        // transform string keys to integers\n        return Object.keys(this.nonWorkingDays).map(Number);\n    }\n    /**\n     * Get weekend days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.\n     * Weekends are days which are declared as weekend days by the selected country and defined by the current locale's\n     * `DateHelper.weekends` parameter.\n     * To get non-working days see {@link #property-nonWorkingDays-static}.\n     *\n     * For example:\n     * ```javascript\n     * {\n     *     0 : true, // Sunday\n     *     6 : true  // Saturday\n     * }\n     * ```\n     * @property {Object<Number,Boolean>}\n     * @readonly\n     * @internal\n     */\n    static get weekends() {\n        return { ...this.localize('L{weekends}') };\n    }\n    /**\n     * Get the specified part of a date.\n     * @param {Date} date\n     * @param {String} unit Part of date, hour, minute etc.\n     * @returns {Number} The requested part of the specified date\n     * @category Query\n     */\n    static get(date, unit) {\n        switch (DH.normalizeUnit(unit)) {\n            case 'millisecond':\n                return date.getMilliseconds();\n            case 'second':\n                return date.getSeconds();\n            case 'minute':\n                return date.getMinutes();\n            case 'hour':\n                return date.getHours();\n            case 'date':\n            case 'day': // Scheduler has a lot of calculations expecting this to work\n                return date.getDate();\n            case 'week':\n                return formats.W(date);\n            case 'month':\n                return date.getMonth();\n            case 'quarter':\n                return Math.floor(date.getMonth() / 3) + 1;\n            case 'year':\n                return date.getFullYear();\n        }\n        return null;\n    }\n    /**\n     * Get number of days in the current year for the supplied date.\n     * @param {Date} date Date to check\n     * @returns {Number} Days in year\n     * @category Query\n     * @internal\n     */\n    static daysInYear(date) {\n        const\n            fullYear = date.getFullYear(),\n            duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);\n        return this.as('day', duration);\n    }\n    /**\n     * Get number of days in the current month for the supplied date.\n     * @param {Date} date Date which month should be checked\n     * @returns {Number} Days in month\n     * @category Query\n     */\n    static daysInMonth(date) {\n        return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();\n    }\n    /**\n     * Get number of hours in the current day for the supplied date.\n     * @param {Date} date Date to check\n     * @returns {Number} Hours in day\n     * @category Query\n     * @internal\n     */\n    static hoursInDay(date) {\n        const\n            fullYear = date.getFullYear(),\n            month    = date.getMonth(),\n            day      = date.getDate(),\n            duration = new Date(fullYear, month, day + 1) - new Date(fullYear, month, day);\n        return this.as('hour', duration);\n    }\n    /**\n     * Converts unit related to the date to actual amount of milliseconds in it. Takes into account leap years and\n     * different duration of months.\n     * @param {Date} date Date\n     * @param {String} unit Time unit\n     * @returns {Number} Returns amount of milliseconds\n     * @internal\n     */\n    static getNormalizedUnitDuration(date, unit) {\n        let result;\n        switch (unit) {\n            case 'month':\n                result = DH.asMilliseconds(DH.daysInMonth(date), 'day');\n                break;\n            case 'year':\n                result = DH.asMilliseconds(DH.daysInYear(date), 'day');\n                break;\n            case 'day':\n                result = DH.asMilliseconds(DH.hoursInDay(date), 'hour');\n                break;\n            default:\n                result = DH.asMilliseconds(unit);\n        }\n        return result;\n    }\n    /**\n     * Get the first date of the month for the supplied date.\n     * @param {Date} date Date\n     * @returns {Date} New Date instance\n     * @category Query\n     */\n    static getFirstDateOfMonth(date) {\n        return new Date(date.getFullYear(), date.getMonth(), 1);\n    }\n    /**\n     * Get the last date of the month for the supplied date.\n     * @param {Date} date Date\n     * @returns {Date} New Date instance\n     * @category Query\n     */\n    static getLastDateOfMonth(date) {\n        return new Date(date.getFullYear(), date.getMonth() + 1, 0);\n    }\n    /**\n     * Get the earliest of two dates.\n     * @param {Date} first First date\n     * @param {Date} second Second date\n     * @returns {Date} Earliest date\n     * @category Query\n     */\n    static min(first, second) {\n        return first.getTime() < second.getTime() ? first : second;\n    }\n    /**\n     * Get the latest of two dates.\n     * @param {Date} first First date\n     * @param {Date} second Second date\n     * @returns {Date} Latest date\n     * @category Query\n     */\n    static max(first, second) {\n        return first.getTime() > second.getTime() ? first : second;\n    }\n    /**\n     * Get an incremented date. Incrementation based on specified unit and optional amount.\n     * @param {Date} date Date\n     * @param {String} unit Time unit\n     * @param {Number} [increment=1] Increment amount\n     * @param {Number} [weekStartDay] Will default to what is set in locale\n     * @returns {Date} New Date instance\n     * @category Query\n     */\n    static getNext(date, unit, increment = 1, weekStartDay = DH.weekStartDay) {\n        if (unit === 'week') {\n            const\n                dt  = DH.clone(date),\n                day = dt.getDay();\n            DH.startOf(dt, 'day', false);\n            DH.add(dt, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)), 'day', false);\n            // For south american timezones, midnight does not exist on DST transitions, adjust...\n            if (dt.getDay() !== weekStartDay) {\n                DH.add(dt, 1, 'hour');\n            }\n            return dt;\n        }\n        return DH.startOf(DH.add(date, increment, unit), unit, false);\n    }\n    /**\n     * Checks if date object is valid.\n     *\n     * For example:\n     *\n     * ```javascript\n     * date = new Date('foo')\n     * date instanceof Date // true\n     * date.toString() // Invalid Date\n     * isNaN(date) // true\n     * DateHelper.isValidDate(date) // false\n     *\n     * date = new Date()\n     * date instanceof Date // true\n     * date.toString() // Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)\n     * isNaN(date) // false\n     * DateHelper.isValidDate(date) // true\n     * ```\n     *\n     * @param {Date} date Date\n     * @returns {Boolean} `true` if date object is valid\n     */\n    static isValidDate(date) {\n        return DH.isDate(date) && !isNaN(date);\n    }\n    /**\n     * Checks if value is a date object. Allows to recognize date object even from another context,\n     * like the top frame when used in an iframe.\n     *\n     * @param {*} value Value to check\n     * @returns {Boolean} `true` if value is a date object\n     */\n    static isDate(value) {\n        // see https://jsbench.me/s7kb49w83j/1 (cannot use instanceof cross-frame):\n        return value && toString.call(value) === DATE_TYPE;\n    }\n    /**\n     * Get the start of the next day.\n     * @param {Date} date Date\n     * @param {Boolean} [clone=false] Clone date\n     * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result\n     * @returns {Date} Passed Date or new Date instance, depending on the `clone` flag\n     * @category Query\n     */\n    static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {\n        let nextDay = DH.add(noNeedToClearTime ? date : DH.clearTime(date, clone), 1, 'day');\n        // DST case\n        if (nextDay.getDate() === date.getDate()) {\n            const\n                offsetNextDay = DH.add(DH.clearTime(date, clone), 2, 'day').getTimezoneOffset(),\n                offsetDate    = date.getTimezoneOffset();\n            nextDay = DH.add(nextDay, offsetDate - offsetNextDay, 'minute');\n        }\n        return nextDay;\n    }\n    /**\n     * Get the end of previous day.\n     * @param {Date} date Date\n     * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result\n     * @returns {Date} New Date instance\n     * @category Query\n     */\n    static getEndOfPreviousDay(date, noNeedToClearTime = false) {\n        const dateOnly = noNeedToClearTime ? date : DH.clearTime(date, true);\n        // dates are different\n        if (dateOnly - date) {\n            return dateOnly;\n        }\n        else {\n            return DH.add(dateOnly, -1, 'day');\n        }\n    }\n    /**\n     * Returns a string describing the specified week. For example, `'39, September 2020'` or `'40, Sep - Oct 2020'`.\n     * @param {Date} startDate Start date\n     * @param {Date} [endDate] End date\n     * @returns {String} String describing the specified week\n     * @internal\n     */\n    static getWeekDescription(startDate, endDate = startDate) {\n        const\n            monthDesc  = startDate.getMonth() === endDate.getMonth()\n                ? DateHelper.format(startDate, 'MMMM')\n                : `${DateHelper.format(startDate, 'MMM')} - ${DateHelper.format(endDate, 'MMM')}`,\n            week = DateHelper.getWeekNumber(startDate);\n        return `${week[1]}, ${monthDesc} ${week[0]}`;\n    }\n    /**\n     * Get week number for the date.\n     * @param {Date} date The date\n     * @param {Number} [weekStartDay] The first day of week, 0-6 (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}\n     * @returns {Number[]} year and week number\n     * @category Query\n     */\n    static getWeekNumber(date, weekStartDay = DateHelper.weekStartDay) {\n        const\n            jan01     = new Date(date.getFullYear(), 0, 1),\n            dec31     = new Date(date.getFullYear(), 11, 31),\n            firstDay  = normalizeDay(jan01.getDay() - weekStartDay),\n            lastDay   = normalizeDay(dec31.getDay() - weekStartDay),\n            dayNumber = getDayDiff(date, jan01);\n        let weekNumber;\n        // Check if the year starts before the middle of a week\n        if (firstDay < 4) {\n            weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;\n        }\n        else {\n            weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);\n        }\n        if (weekNumber) {\n            let year = date.getFullYear();\n            // Might be week 1 of next year if the year ends before day 3 (0 based)\n            if (weekNumber === 53 && lastDay < 3) {\n                year++;\n                weekNumber = 1;\n            }\n            return [year, weekNumber];\n        }\n        // We're in week zero which is the last week of the previous year, so ask what\n        // week encapsulates 31 Dec in the previous year.\n        const lastWeekOfLastYear = DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];\n        return [date.getFullYear() - 1, lastWeekOfLastYear];\n    }\n    //endregion\n    //region Unit helpers\n    /**\n     * Turns `(10, 'day')` into `'10 days'` etc.\n     * @param {Number} count Amount of unit\n     * @param {String} unit Unit, will be normalized (days, d -> day etc.)\n     * @returns {String} Amount formatted to string\n     * @category Unit helpers\n     */\n    static formatCount(count, unit) {\n        unit = DH.normalizeUnit(unit);\n        if (count !== 1) unit += 's';\n        return count + ' ' + unit;\n    }\n    /**\n     * Get the ratio between two units ( year, month -> 1/12 ).\n     * @param {String} baseUnit Base time unit\n     * @param {String} unit Time unit\n     * @param {Boolean} [acceptEstimate=false] If `true`, process negative values of validConversions\n     * @returns {Number} Ratio\n     * @category Unit helpers\n     */\n    static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {\n        baseUnit = DH.normalizeUnit(baseUnit);\n        unit = DH.normalizeUnit(unit);\n        if (baseUnit === unit) return 1;\n        // Some validConversions have negative sign to signal that it is not an exact conversion.\n        // Ignore those here unless acceptEstimate is provided.\n        if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {\n            return 1 / DH.as(unit, 1, baseUnit);\n        }\n        if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {\n            return DH.as(baseUnit, 1, unit);\n        }\n        return -1;\n    }\n    /**\n     * Returns a localized abbreviated form of the name of the duration unit.\n     * For example in the `EN` locale, for `'qrt'` it will return `'q'`.\n     * @param {String} unit Duration unit\n     * @returns {String} Localized abbreviated form of the name of the duration unit\n     * @category Unit helpers\n     */\n    static getShortNameOfUnit(unit) {\n        // Convert abbreviations to the canonical name.\n        // See locale file and the applyLocale method below.\n        unit = DH.parseTimeUnit(unit);\n        // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc\n        return DH.unitLookup[unit].abbrev;\n    }\n    /**\n     * Returns a localized full name of the duration unit.\n     *\n     * For example in the `EN` locale, for `'d'` it will return either\n     * `'day'` or `'days'`, depending on the `plural` argument\n     *\n     * Preserves casing of first letter.\n     *\n     * @static\n     * @param {String} unit Time unit\n     * @param {Boolean} [plural=false] Whether to return a plural name or singular\n     * @returns {String} Localized full name of the duration unit\n     * @category Unit helpers\n     */\n    static getLocalizedNameOfUnit(unit, plural = false) {\n        const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();\n        // Normalize to not have to have translations for each variation used in code\n        unit = DH.normalizeUnit(unit);\n        // Convert abbreviations to the canonical name.\n        // See locale file and the applyLocale method below.\n        unit = DH.parseTimeUnit(unit);\n        // Translate\n        // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc\n        unit = DH.unitLookup[unit][plural ? 'plural' : 'single'];\n        // Preserve casing of first letter\n        if (capitalize) {\n            unit = StringHelper.capitalize(unit);\n        }\n        return unit;\n    }\n    /**\n     * Normalizes a unit for easier usage in conditionals. For example `'year'`, `'years'`, `'y'` -> `'year'`.\n     * @param {String} unit Time unit\n     * @returns {String} Normalized unit name\n     * @category Unit helpers\n     */\n    static normalizeUnit(unit) {\n        if (!unit) {\n            return null;\n        }\n        const unitLower = unit.toLowerCase();\n        if (unitLower === 'date') {\n            return unitLower;\n        }\n        return canonicalUnitNames.includes(unitLower)\n            // Already valid\n            ? unitLower\n            // Trying specified case first, since we have both 'M' for month and 'm' for minute\n            : normalizedUnits[unit] || normalizedUnits[unitLower];\n    }\n    static getUnitByName(name) {\n        // Allow either a canonical name to be passed, or, if that fails, parse it as a localized name or abbreviation.\n        return DH.normalizeUnit(name) || DH.normalizeUnit(DH.parseTimeUnit(name));\n    }\n    /**\n     * Returns a duration of the timeframe in the given unit.\n     * @param {Date} start The start date of the timeframe\n     * @param {Date} end The end date of the timeframe\n     * @param {String} unit Duration unit\n     * @privateparam {Boolean} [doNotRound]\n     * @returns {Number} The duration in the units\n     * @category Unit helpers\n     * @ignore\n     */\n    static getDurationInUnit(start, end, unit, doNotRound) {\n        return DH.diff(start, end, unit, doNotRound);\n    }\n    /**\n     * Checks if two date units align.\n     * @private\n     * @param {String} majorUnit Major time unit\n     * @param {String} minorUnit Minor time unit\n     * @returns {Boolean} `true` if two date units align\n     * @category Unit helpers\n     */\n    static doesUnitsAlign(majorUnit, minorUnit) {\n        return !(majorUnit !== minorUnit && minorUnit === 'week');\n    }\n    static getSmallerUnit(unit) {\n        return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] - 1] || null;\n    }\n    static getLargerUnit(unit) {\n        return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] + 1] || null;\n    }\n    /**\n     *\n     * Rounds the passed Date value to the nearest `increment` value.\n     *\n     * Optionally may round relative to a certain base time point.\n     *\n     * For example `DH.round(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`\n     * would round to 9:45 because that's the nearest integer number of 30 minute increments\n     * from the base.\n     *\n     * Note that `base` is ignored when rounding to weeks. The configured {@link #property-weekStartDay-static}\n     * dictates what the base of a week is.\n     *\n     * @param {Date} time The time to round\n     * @param {String|Number} increment A millisecond value by which to round the time\n     * May be specified in string form eg: `'15 minutes'`\n     * @param {Date} [base] The start from which to apply the rounding\n     * @param {Number} [weekStartDay] Will default to what is set in locale\n     * @returns {Date} New Date instance\n     */\n    static round(time, increment, base, weekStartDay) {\n        return DH.snap('round', time, increment, base, weekStartDay);\n    }\n    /**\n     *\n     * Floor the passed Date value to the nearest `increment` value.\n     *\n     * Optionally may floor relative to a certain base time point.\n     *\n     * For example `DH.floor(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`\n     * would floor to 9:15 because that's the closest lower integer number of 30 minute increments\n     * from the base.\n     *\n     * Note that `base` is ignored when flooring to weeks. The configured {@link #property-weekStartDay-static}\n     * dictates what the base of a week is.\n     *\n     * @param {Date} time The time to floor\n     * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to floor the time.\n     * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`\n     * or `{unit: 'minute', increment: 30}`\n     * @param {Date} [base] The start from which to apply the flooring\n     * @param {Number} [weekStartDay] Will default to what is set in locale\n     * @returns {Date} New Date instance\n     */\n    static floor(time, increment, base, weekStartDay) {\n        return DH.snap('floor', time, increment, base, weekStartDay);\n    }\n    /**\n     *\n     * Ceils the passed Date value to the nearest `increment` value.\n     *\n     * Optionally may ceil relative to a certain base time point.\n     *\n     * For example `DH.ceil(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`\n     * would ceil to 9:45 because that's the closest higher integer number of 30 minute increments\n     * from the base.\n     *\n     * Note that `base` is ignored when ceiling to weeks. Use weekStartDay argument which default to the configured\n     * {@link #property-weekStartDay-static} dictates what the base of a week is\n     *\n     * @param {Date} time The time to ceil\n     * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to ceil the time\n     * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`\n     * or `{unit: 'minute', increment: 30}`\n     * @param {Date} [base] The start from which to apply the ceiling\n     * @param {Number} [weekStartDay] Will default to what is set in locale\n     * @returns {Date} New Date instance\n     */\n    static ceil(time, increment, base, weekStartDay) {\n        return DH.snap('ceil', time, increment, base, weekStartDay);\n    }\n    /**\n     * Implementation for round, floor and ceil.\n     * @internal\n     */\n    static snap(operation, time, increment, base, weekStartDay = DH.weekStartDay) {\n        const snapFn = snapFns[operation];\n        if (typeof increment === 'string') {\n            increment = DH.parseDuration(increment);\n        }\n        if (Objects.isObject(increment)) {\n            // Allow {unit: 'minute', increment: 30} or {unit: 'minute', magnitude: 30}\n            // parseDuration produces 'magnitude'. The Scheduler's TimeAxis uses 'increment'\n            // in its resolution object, so we allow that too.\n            const magnitude = increment.magnitude || increment.increment;\n            // increment is in weeks, months, quarters or years, then it can't be handled\n            // using millisecond arithmetic.\n            switch (increment.unit) {\n                case 'week':\n                {\n                    const weekDay = time.getDay();\n                    // weekStartDay gives our base\n                    // Our base is the start of the week\n                    base = DH.add(\n                        DH.clearTime(time),\n                        weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7),\n                        'day'\n                    );\n                    return DH[operation](time, `${magnitude * 7} days`, base);\n                }\n                case 'month':\n                {\n                    // Express the time as a number of months from epoch start.\n                    // May be a fraction, eg the 15th will be 0.5 through a month.\n                    time = DH.asMonths(time);\n                    let resultMonths;\n                    // Snap the month count in the way requested\n                    if (base) {\n                        base = DH.asMonths(base);\n                        resultMonths = time + snapFn(time - base, magnitude);\n                    }\n                    else {\n                        resultMonths = snapFn(time, magnitude);\n                    }\n                    // Convert resulting month value back to a date\n                    return DH.monthsToDate(resultMonths);\n                }\n                case 'quarter':\n                    return DH[operation](time, `${magnitude * 3} months`, base);\n                case 'year':\n                    return DH[operation](time, `${magnitude * 12} months`, base);\n                case 'decade':\n                    // We assume that decades begin with a year divisible by 10\n                    return DH[operation](time, `${magnitude * 10} years`, base);\n            }\n            // Convert to a millisecond value\n            increment = DH.as('ms', magnitude, increment.unit);\n        }\n        // It's a simple round to milliseconds\n        if (base) {\n            const tzChange = DH.as('ms', base.getTimezoneOffset() - time.getTimezoneOffset(), 'ms');\n            return new Date(base.valueOf() + snapFn(DH.diff(base, time, 'ms') + tzChange, increment));\n        }\n        else {\n            const offset = time.getTimezoneOffset() * 60 * 1000;\n            // Assuming current TZ is GMT+3\n            // new Date(2000, 0, 1) / 86400000      -> 10956.875\n            // new Date(2000, 0, 1, 3) / 86400000   -> 10957\n            // Before calculation we need to align time value of the current timezone to GMT+0\n            // And after calculate we need to adjust time back\n            return new Date(snapFn(time.valueOf() - offset, increment) + offset);\n        }\n    }\n    //endregion\n    //region Date picker format\n    /**\n     * Parses a typed duration value according to locale rules.\n     *\n     * The value is taken to be a string consisting of the numeric magnitude and the units:\n     * - The numeric magnitude can be either an integer or a float value. Both `','` and `'.'` are valid decimal separators.\n     * - The units may be a recognised unit abbreviation of this locale or the full local unit name.\n     *\n     * For example:\n     * `'2d'`, `'2 d'`, `'2 day'`, `'2 days'` will be turned into `{ magnitude : 2, unit : 'day' }`\n     * `'2.5d'`, `'2,5 d'`, `'2.5 day'`, `'2,5 days'` will be turned into `{ magnitude : 2.5, unit : 'day' }`\n     *\n     * **NOTE:** Doesn't work with complex values like `'2 days, 2 hours'`\n     *\n     * @param {String} value The value to parse\n     * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude\n     * @param {String} [defaultUnit] Default unit to use if only magnitude passed\n     * @returns {DurationConfig} If successfully parsed, the result contains two properties, `magnitude` being a number, and\n     * `unit` being the canonical unit name, *NOT* a localized name. If parsing was unsuccessful, `null` is returned\n     * @category Parse & format\n     */\n    static parseDuration(value, allowDecimals = true, defaultUnit) {\n        const\n            durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex,\n            match         = durationRegEx.exec(value);\n        if (value == null || !match) {\n            return null;\n        }\n        const\n            magnitude = parseNumber(match[1]?.replace(',', '.')),\n            unit      = DH.parseTimeUnit(match[2]) || defaultUnit;\n        if (!unit) {\n            return null;\n        }\n        return {\n            magnitude,\n            unit\n        };\n    }\n    /**\n     * Parses a typed unit name, for example `'ms'` or `'hr'` or `'yr'` into the\n     * canonical form of the unit name which may be passed to {@link #function-add-static}\n     * or {@link #function-diff-static}.\n     * @param {*} unitName Time unit name\n     * @category Parse & format\n     */\n    static parseTimeUnit(unitName) {\n        // NOTE: In case you get a crash here when running tests, it is caused by missing locale. Build locales\n        // using `scripts/build.js locales` to resolve.\n        const unitMatch = unitName == null ? null : DH.durationRegEx.exec(unitName.toLowerCase());\n        if (!unitMatch) {\n            return null;\n        }\n        // See which group in the unitAbbrRegEx matched match[2]\n        for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {\n            if (unitMatch[unitOrdinal + 1]) {\n                return canonicalUnitNames[unitOrdinal];\n            }\n        }\n    }\n    //endregion\n    //region Internal\n    static getGMTOffset(date = new Date()) {\n        if (!date) {\n            return;\n        }\n        const offsetInMinutes = date.getTimezoneOffset();\n        // return 'Z' for UTC\n        if (!offsetInMinutes) return 'Z';\n        return (offsetInMinutes > 0 ? '-' : '+') +\n            Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, '0') +\n            ':' +\n            Math.abs(offsetInMinutes % 60).toString().padStart(2, '0');\n    }\n    static fillDayNames() {\n        const\n            tempDate      = new Date('2000-01-01T12:00:00'),\n            dayNames      = DH._dayNames || [],\n            dayShortNames = DH._dayShortNames || [];\n        dayNames.length = 0;\n        dayShortNames.length = 0;\n        for (let day = 2; day < 9; day++) {\n            tempDate.setDate(day);\n            dayNames.push(DH.format(tempDate, 'dddd'));\n            dayShortNames.push(DH.format(tempDate, 'ddd'));\n        }\n        DH._dayNames = dayNames;\n        DH._dayShortNames = dayShortNames;\n    }\n    static getDayNames() {\n        return DH._dayNames;\n    }\n    static getDayName(day) {\n        return DH._dayNames[day];\n    }\n    static getDayShortNames() {\n        return DH._dayShortNames;\n    }\n    static getDayShortName(day) {\n        return DH._dayShortNames[day];\n    }\n    static fillMonthNames() {\n        const\n            tempDate        = new Date('2000-01-15T12:00:00'),\n            monthNames      = DH._monthNames || [],\n            monthShortNames = DH._monthShortNames || [],\n            monthNamesIndex = {},\n            monthShortNamesIndex = {};\n        monthNames.length = 0;\n        monthShortNames.length = 0;\n        for (let month = 0; month < 12; month++) {\n            tempDate.setMonth(month);\n            const monthName = DH.format(tempDate, 'MMMM');\n            monthNames.push(monthName);\n            const monthShortName = DH.format(tempDate, 'MMM');\n            monthShortNames.push(monthShortName);\n            monthNamesIndex[monthName.toLowerCase()] = { name : monthName, value : month };\n            monthShortNamesIndex[monthShortName.toLowerCase()] = { name : monthShortName, value : month };\n        }\n        DH._monthNames = monthNames;\n        DH._monthShortNames = monthShortNames;\n        DH._monthNamesIndex = monthNamesIndex;\n        DH._monthShortNamesIndex = monthShortNamesIndex;\n    }\n    static getMonthShortNames() {\n        return DH._monthShortNames;\n    }\n    static getMonthShortName(month) {\n        return DH._monthShortNames[month];\n    }\n    static getMonthNames() {\n        return DH._monthNames;\n    }\n    static getMonthName(month) {\n        return DH._monthNames[month];\n    }\n    static set locale(name) {\n        locale = name;\n        intlFormatterCache = {};\n        formatCache = {};\n        formatRedirects = {};\n    }\n    static get locale() {\n        return locale;\n    }\n    static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {\n        const\n            me         = this,\n            unitLookup = {};\n        let unitAbbrRegEx = '';\n        for (let i = 0; i < unitAbbreviations.length; i++) {\n            const\n                // for example ['s', 'sec']\n                abbreviations = unitAbbreviations[i],\n                // for example { single : 'second', plural : 'seconds', abbrev : 's' }\n                unitNamesCfg  = unitNames[i];\n            unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];\n            // Create a unitLookup object keyed by unit full names\n            // both lower and upper case to be able to look up plurals or abbreviations\n            // also always include english names, since those are used in sources\n            unitLookup[unitNamesCfg.single] =\n                unitLookup[unitNamesCfg.single.toUpperCase()] =\n                    unitLookup[unitNamesCfg.canonicalUnitName] =\n                        unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;\n            unitAbbrRegEx += `${i ? '|' : ''}(`;\n            for (let j = 0; j < abbreviations.length; j++) {\n                unitAbbrRegEx += `${abbreviations[j]}|`;\n            }\n            locale = me.localize('L{locale}') || 'en-US';\n            if (locale !== 'en-US') {\n                // Add canonical values to be able to parse durations specified in configs\n                const canonicalAbbreviations = canonicalUnitAbbreviations[i];\n                for (let j = 0; j < canonicalAbbreviations.length; j++) {\n                    unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;\n                }\n            }\n            unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;\n        }\n        me.unitLookup = unitLookup;\n        me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);\n    }\n    static applyLocale() {\n        const\n            me                = this,\n            unitAbbreviations = me.localize('L{unitAbbreviations}') || [],\n            unitNames         = me.unitNames = me.localize('L{unitNames}');\n        // This happens when applying an incomplete locale, as done in Localizable.t.js.\n        // Invalid usecase, but return to prevent a crash in that test.\n        if (unitNames === 'unitNames') {\n            return;\n        }\n        locale = me.localize('L{locale}') || 'en-US';\n        if (locale === 'en-US') {\n            ordinalSuffix = enOrdinalSuffix;\n        }\n        else {\n            ordinalSuffix = me.localize('L{ordinalSuffix}') || ordinalSuffix;\n        }\n        formatCache = {};\n        formatRedirects = {};\n        parserCache = {};\n        intlFormatterCache = {};\n        DH._weekStartDay = null;\n        DH.setupDurationRegEx(unitNames, unitAbbreviations);\n        // rebuild day/month names cache\n        DH.fillDayNames();\n        DH.fillMonthNames();\n    }\n    //endregion\n}\nconst DH = DateHelper;\nDH.useIntlFormat = useIntlFormat; // to use on tests\n// Update when changing locale\nLocaleManager.ion({\n    locale  : 'applyLocale',\n    prio    : 1000,\n    thisObj : DH\n});\n// Apply default locale\nif (LocaleManager.locale) {\n    DH.applyLocale();\n}\nDateHelper._$name = 'DateHelper';", "/**\n * The enumeration for the time units\n */\nexport var TimeUnit;\n(function (TimeUnit) {\n    TimeUnit[\"Millisecond\"] = \"millisecond\";\n    TimeUnit[\"Second\"] = \"second\";\n    TimeUnit[\"Minute\"] = \"minute\";\n    TimeUnit[\"Hour\"] = \"hour\";\n    TimeUnit[\"Day\"] = \"day\";\n    TimeUnit[\"Week\"] = \"week\";\n    TimeUnit[\"Month\"] = \"month\";\n    TimeUnit[\"Quarter\"] = \"quarter\";\n    TimeUnit[\"Year\"] = \"year\";\n})(TimeUnit || (TimeUnit = {}));\n/**\n * The enumeration for the supported constraint types\n */\nexport var ConstraintType;\n(function (ConstraintType) {\n    /**\n     * \"Must start on\" constraint.\n     * Restricts an event to start on a [[HasDateConstraintMixin.constraintDate|specified date]].\n     * The constraint cannot be used for a summary event.\n     */\n    ConstraintType[\"MustStartOn\"] = \"muststarton\";\n    /**\n     * \"Must finish on\" constraint.\n     * Restricts an event to finish on a [[HasDateConstraintMixin.constraintDate|specified date]].\n     * The constraint cannot be used for a summary event.\n     */\n    ConstraintType[\"MustFinishOn\"] = \"mustfinishon\";\n    /**\n     * \"Start no earlier than\" constraint.\n     * Restricting an event to start on or after a [[HasDateConstraintMixin.constraintDate|specified date]].\n     */\n    ConstraintType[\"StartNoEarlierThan\"] = \"startnoearlierthan\";\n    /**\n     * \"Start no later than\" constraint.\n     * Restricting an event to start on or before a [[HasDateConstraintMixin.constraintDate|specified date]].\n     *\n     * The constraint cannot be used for a summary task.\n     */\n    ConstraintType[\"StartNoLaterThan\"] = \"startnolaterthan\";\n    /**\n     * \"Finish no earlier than\" constraint.\n     * Restricting an event to finish on or after a [[HasDateConstraintMixin.constraintDate|specified date]].\n     *\n     * The constraint cannot be used for a summary task.\n     */\n    ConstraintType[\"FinishNoEarlierThan\"] = \"finishnoearlierthan\";\n    /**\n     * \"Finish no later than\" constraint.\n     * Restricting an event to finish on or before a [[HasDateConstraintMixin.constraintDate|specified date]].\n     */\n    ConstraintType[\"FinishNoLaterThan\"] = \"finishnolaterthan\";\n})(ConstraintType || (ConstraintType = {}));\n/**\n * The enumeration for the supported scheduling modes\n */\nexport var SchedulingMode;\n(function (SchedulingMode) {\n    SchedulingMode[\"Normal\"] = \"Normal\";\n    SchedulingMode[\"FixedDuration\"] = \"FixedDuration\";\n    SchedulingMode[\"FixedEffort\"] = \"FixedEffort\";\n    SchedulingMode[\"FixedUnits\"] = \"FixedUnits\";\n})(SchedulingMode || (SchedulingMode = {}));\n/**\n * The enumeration for the dependency validation result\n */\nexport var DependencyValidationResult;\n(function (DependencyValidationResult) {\n    /**\n     * Dependency has no errors\n     */\n    DependencyValidationResult[DependencyValidationResult[\"NoError\"] = 0] = \"NoError\";\n    /**\n     * Indicates that the validated dependency builds a cycle\n     */\n    DependencyValidationResult[DependencyValidationResult[\"CyclicDependency\"] = 1] = \"CyclicDependency\";\n    /**\n     * Indicates that a dependency with the same predecessor and successor as validated one's already exists\n     */\n    DependencyValidationResult[DependencyValidationResult[\"DuplicatingDependency\"] = 2] = \"DuplicatingDependency\";\n})(DependencyValidationResult || (DependencyValidationResult = {}));\n/**\n * The enumeration for the supported dependency types\n */\nexport var DependencyType;\n(function (DependencyType) {\n    /**\n     * Start-to-Start (_SS_)\n     *\n     * With this dependency type, the succeeding event is delayed to start not earlier than the preceding event starts.\n     */\n    DependencyType[DependencyType[\"StartToStart\"] = 0] = \"StartToStart\";\n    /**\n     * Start-to-Finish (_SF_)\n     *\n     * The finish of the succeeding event is constrained by the start of the preceding event.\n     * So the successor cannot finish before the predecessor starts.\n     */\n    DependencyType[DependencyType[\"StartToEnd\"] = 1] = \"StartToEnd\";\n    /**\n     * Finish-to-Start (_FS_)\n     *\n     * This type of dependency, restricts the dependent event to not start earlier than the preceding event finishes.\n     */\n    DependencyType[DependencyType[\"EndToStart\"] = 2] = \"EndToStart\";\n    /**\n     * Finish-to-Finish (_FF_)\n     *\n     * The succeeding event cannot finish before the completion of the preceding event.\n     */\n    DependencyType[DependencyType[\"EndToEnd\"] = 3] = \"EndToEnd\";\n})(DependencyType || (DependencyType = {}));\n/**\n * The enumeration for the supported sources of the calendar for the dependency.\n */\nexport var DependenciesCalendar;\n(function (DependenciesCalendar) {\n    DependenciesCalendar[\"Project\"] = \"Project\";\n    DependenciesCalendar[\"FromEvent\"] = \"FromEvent\";\n    DependenciesCalendar[\"ToEvent\"] = \"ToEvent\";\n})(DependenciesCalendar || (DependenciesCalendar = {}));\n/**\n * Engine provides with different project types, the enumeration describes the types currently available\n */\nexport var ProjectType;\n(function (ProjectType) {\n    ProjectType[ProjectType[\"SchedulerBasic\"] = 1] = \"SchedulerBasic\";\n    ProjectType[ProjectType[\"SchedulerPro\"] = 2] = \"SchedulerPro\";\n    ProjectType[ProjectType[\"Gantt\"] = 3] = \"Gantt\";\n})(ProjectType || (ProjectType = {}));\n/**\n * The enumeration for the scheduling direction\n */\nexport var Direction;\n(function (Direction) {\n    /**\n     * Forward (or As Soon As Possible (ASAP)) scheduling.\n     */\n    Direction[\"Forward\"] = \"Forward\";\n    /**\n     * Backward (or As Late As Possible (ALAP)) scheduling.\n     */\n    Direction[\"Backward\"] = \"Backward\";\n    Direction[\"None\"] = \"None\";\n})(Direction || (Direction = {}));\nexport var ConstraintIntervalSide;\n(function (ConstraintIntervalSide) {\n    ConstraintIntervalSide[\"Start\"] = \"Start\";\n    ConstraintIntervalSide[\"End\"] = \"End\";\n})(ConstraintIntervalSide || (ConstraintIntervalSide = {}));\n", "// http://ecma-international.org/ecma-262/5.1/#sec-15.9.1.1\n/**\n * Minimal date representable with native Date class\n */\nexport const MIN_DATE = new Date(-8640000000000000);\n/**\n * Maximal date representable with native Date class\n */\nexport const MAX_DATE = new Date(8640000000000000);\nexport const isDateFinite = (date) => {\n    if (!date)\n        return false;\n    const time = date.getTime();\n    return time !== MIN_DATE.getTime() && time !== MAX_DATE.getTime();\n};\n", "/**\n * The date intervals in the scheduling engine are always inclusive on one end and opened on another.\n * The \"opened\" end is not considered to be a part of the interval.\n *\n * Depending from the scheduling direction (forward/backward) this property may need to be inverted.\n *\n * This enum specifies what edge of the interval is inclusive.\n */\nexport var EdgeInclusion;\n(function (EdgeInclusion) {\n    EdgeInclusion[EdgeInclusion[\"Left\"] = 0] = \"Left\";\n    EdgeInclusion[EdgeInclusion[\"Right\"] = 1] = \"Right\";\n})(EdgeInclusion || (EdgeInclusion = {}));\n", "import DateHelper from \"../../Core/helper/DateHelper.js\";\nimport { TimeUnit } from \"../scheduling/Types.js\";\nimport { MAX_DATE, MIN_DATE } from \"../util/Constants.js\";\nimport { EdgeInclusion } from \"../util/Types.js\";\n/**\n * The enum type for result of [[forEachAvailabilityInterval]].\n */\nexport var CalendarIteratorResult;\n(function (CalendarIteratorResult) {\n    /**\n     * Indicates the iteration has completed by iterating the whole given timespan or has reached the MAX_DATE or MIN_DATE.\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"FullRangeIterated\"] = 0] = \"FullRangeIterated\";\n    /**\n     * Indicates the iteration has been stopped by returning `false` from the iterator.\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"StoppedByIterator\"] = 1] = \"StoppedByIterator\";\n    /**\n     * Indicates the iteration has exceeded the `maxRange` option\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"MaxCacheExtendCyclesReached\"] = 2] = \"MaxCacheExtendCyclesReached\";\n    /**\n     * Indicates the iteration has exceeded the `maxRange` option\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"MaxRangeReached\"] = 3] = \"MaxRangeReached\";\n})(CalendarIteratorResult || (CalendarIteratorResult = {}));\n/**\n * Calendar cache.\n */\nexport class CalendarCache {\n    constructor(config) {\n        this.cacheFilledStartDate = MAX_DATE;\n        this.cacheFilledEndDate = MIN_DATE;\n        this.intervalsCachingChunkDuration = 30;\n        this.intervalsCachingChunkUnit = TimeUnit.Day;\n        this.maxCacheExtendCycles = 1000;\n        // max range for the iteration - 5 years\n        this.maxRange = 5 * 365 * 24 * 60 * 60 * 1000;\n        config && Object.assign(this, config);\n    }\n    includeWrappingRangeFrom(cache, startDate, endDate) {\n        cache.ensureCacheFilledForInterval(startDate, endDate);\n        this.intervalCache.includeWrappingRange(cache.intervalCache, startDate, endDate);\n    }\n    // after this method, we guarantee, that for every point between `startDate` and `endDate` (_inclusive_)\n    // we'll have a final representation of the cache, that is, we'll be able to get an interval to which this point belongs\n    // _both_ for forward and backward directions\n    ensureCacheFilledForInterval(startDate, endDate) {\n        const cacheFilledStartDateN = this.cacheFilledStartDate.getTime();\n        const cacheFilledEndDateN = this.cacheFilledEndDate.getTime();\n        if (cacheFilledStartDateN !== MAX_DATE.getTime()) {\n            const startDateN = startDate.getTime();\n            const endDateN = endDate.getTime();\n            if (cacheFilledStartDateN <= startDateN && endDateN <= cacheFilledEndDateN)\n                return;\n            // asked to cache an interval which is to the left from the cached area - extend to the right\n            if (endDateN <= cacheFilledStartDateN) {\n                endDate = new Date(cacheFilledStartDateN - 1);\n            }\n            else if (startDateN >= cacheFilledEndDateN) {\n                startDate = new Date(cacheFilledEndDateN);\n            }\n            else if (cacheFilledStartDateN <= startDateN && startDateN <= cacheFilledEndDateN) {\n                startDate = new Date(cacheFilledEndDateN + 1);\n            }\n            else if (cacheFilledStartDateN <= endDateN && endDateN <= cacheFilledEndDateN) {\n                endDate = new Date(cacheFilledStartDateN - 1);\n            }\n            else {\n                this.ensureCacheFilledForInterval(startDate, new Date(cacheFilledStartDateN - 1));\n                this.ensureCacheFilledForInterval(new Date(cacheFilledEndDateN + 1), endDate);\n                return;\n            }\n        }\n        if (cacheFilledStartDateN === MAX_DATE.getTime() || startDate.getTime() < cacheFilledEndDateN) {\n            this.cacheFilledStartDate = startDate;\n        }\n        if (cacheFilledEndDateN === MIN_DATE.getTime() || cacheFilledEndDateN < endDate.getTime()) {\n            this.cacheFilledEndDate = endDate;\n        }\n        this.fillCache(startDate, endDate);\n    }\n    fillCache(_1 /* startDate */, _2 /* endDate */) {\n        throw new Error(\"Abstract method\");\n    }\n    clear() {\n        this.cacheFilledStartDate = MAX_DATE;\n        this.cacheFilledEndDate = MIN_DATE;\n        this.intervalCache.clear();\n    }\n    /**\n     * The core iterator method of the calendar cache.\n     *\n     * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties\n     * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided\n     * iterator function should return `false` at some point, to avoid infinite loops.\n     *\n     * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.\n     *\n     * Another recognized option is `maxRange`, which indicates the maximum timespan for this iterator (in milliseconds). When iterator\n     * exceeds this timespan, the iteration is stopped and [[CalendarIteratorResult.MaxRangeReached]] value is returned.\n     * Default value is 5 years.\n     *\n     * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found\n     * in the given timespan. All the intervals, which are \"active\" for current interval are collected in the 3rd argument\n     * for this function. If iterator returns `false` (checked with `===`) the iteration stops.\n     *\n     * @param scope The scope (`this` value) to execute the iterator in.\n     */\n    forEachAvailabilityInterval(options, func, scope) {\n        scope = scope || this;\n        const startDate = options.startDate;\n        const endDate = options.endDate;\n        const startDateN = startDate && startDate.getTime();\n        const endDateN = endDate && endDate.getTime();\n        const maxRange = options.maxRange ?? this.maxRange;\n        // `isForward = true` by default\n        const isForward = options.isForward !== false;\n        if (isForward ? !startDate : !endDate) {\n            throw new Error(\"At least `startDate` or `endDate` is required, depending from the `isForward` option\");\n        }\n        const intervalCache = this.intervalCache;\n        let cacheCursorDate = isForward ? startDate : endDate;\n        let cursorDate = isForward ? startDate : endDate;\n        const rangeStart = cursorDate.getTime();\n        // this is generally an endless loop, but we artificially limit it to `maxCacheExtendCycles` iterations\n        // to avoid freezing in unforeseen edge cases\n        for (let cycle = 1; cycle < this.maxCacheExtendCycles; cycle++) {\n            if (isForward) {\n                this.ensureCacheFilledForInterval(cacheCursorDate, endDate || DateHelper.add(cacheCursorDate, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit));\n            }\n            else {\n                this.ensureCacheFilledForInterval(startDate || DateHelper.add(cacheCursorDate, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), cacheCursorDate);\n            }\n            let interval = intervalCache.getIntervalOf(cursorDate, isForward ? EdgeInclusion.Left : EdgeInclusion.Right);\n            while (interval) {\n                const intervalStartDate = interval.startDate;\n                const intervalEndDate = interval.endDate;\n                // out of requested range - all done\n                if ((isForward && endDateN && intervalStartDate.getTime() >= endDateN)\n                    ||\n                        (!isForward && startDateN && intervalEndDate.getTime() <= startDateN)) {\n                    return CalendarIteratorResult.FullRangeIterated;\n                }\n                if ((isForward && intervalStartDate.getTime() - rangeStart >= maxRange)\n                    ||\n                        (!isForward && rangeStart - intervalEndDate.getTime() >= maxRange)) {\n                    return CalendarIteratorResult.MaxRangeReached;\n                }\n                // we are out of cached area, need to extend the cache,\n                // using `>=, <=` here, because, as an edge case the cache can be filled exactly up to that interval\n                // and following interval will be infinity, which will trigger premature loop exit\n                // caused by the https://github.com/bryntum/support/issues/6406\n                if ((isForward && intervalStartDate.getTime() >= this.cacheFilledEndDate.getTime())\n                    ||\n                        (!isForward && intervalEndDate.getTime() <= this.cacheFilledStartDate.getTime())) {\n                    break;\n                }\n                // save the last processed point, from which we should start after cache will be extended\n                cursorDate = isForward ? intervalEndDate : intervalStartDate;\n                // adjust to start / end date limits in iterator\n                const countFrom = startDateN && intervalStartDate.getTime() < startDateN ? startDate : intervalStartDate;\n                const countTill = endDateN && intervalEndDate.getTime() > endDateN ? endDate : intervalEndDate;\n                if (func.call(scope, countFrom, countTill, interval.cacheInterval) === false) {\n                    // indicates premature exit if iterator returns `false`\n                    return CalendarIteratorResult.StoppedByIterator;\n                }\n                interval = isForward ? intervalCache.getNextInterval(interval) : intervalCache.getPrevInterval(interval);\n            }\n            if (isForward && cursorDate.getTime() === MAX_DATE.getTime() || !isForward && cursorDate.getTime() === MIN_DATE.getTime()) {\n                return CalendarIteratorResult.FullRangeIterated;\n            }\n            cacheCursorDate = isForward ? this.cacheFilledEndDate : this.cacheFilledStartDate;\n        }\n        return CalendarIteratorResult.MaxCacheExtendCyclesReached;\n    }\n}\n", "export const stripDuplicates = (array) => Array.from(new Set(array));\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\n/**\n * A class, that represent a cached set of availability intervals. One can use the [[getIsWorking]] method\n * to determine if this set intervals represents working time or non-working.\n */\nexport class CalendarCacheInterval {\n    constructor(config) {\n        this.intervals = [];\n        config && Object.assign(this, config);\n        if (!this.calendar)\n            throw new Error(\"Required attribute `calendar` is missing\");\n    }\n    includeInterval(interval) {\n        if (this.intervals.indexOf(interval) == -1) {\n            const copy = this.intervals.slice();\n            copy.push(interval);\n            return new CalendarCacheInterval({ intervals: copy, calendar: this.calendar });\n        }\n        else\n            return this;\n    }\n    combineWith(interval) {\n        return new CalendarCacheInterval({ intervals: this.intervals.concat(interval.intervals), calendar: this.calendar });\n    }\n    /**\n     * Returns the working status of this intervals set. It is determined as a working status\n     * of the most prioritized interval (intervals are prioritized from child to parent)\n     */\n    getIsWorking() {\n        if (this.isWorking != null)\n            return this.isWorking;\n        const intervals = this.intervals = this.normalizeIntervals(this.intervals);\n        // return the value of the interval with the highest priority\n        return this.isWorking = intervals[0].isWorking;\n    }\n    normalizeIntervals(intervals) {\n        const filtered = stripDuplicates(intervals);\n        // sort in decreasing order\n        filtered.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());\n        return filtered;\n    }\n}\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\nexport class CalendarCacheIntervalMultiple {\n    constructor(config) {\n        this.intervalGroups = [];\n        config && Object.assign(this, config);\n    }\n    combineWith(interval) {\n        const copy = this.intervalGroups.slice();\n        copy.push([interval.calendar, interval]);\n        return new CalendarCacheIntervalMultiple({ intervalGroups: copy });\n    }\n    getIsWorkingForEvery() {\n        if (this.isWorkingForEvery != null)\n            return this.isWorkingForEvery;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (!intervals[0].isWorking)\n                return this.isWorkingForEvery = false;\n        }\n        return this.isWorkingForEvery = true;\n    }\n    getIsWorkingForSome() {\n        if (this.isWorkingForSome != null)\n            return this.isWorkingForSome;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (intervals[0].isWorking)\n                return this.isWorkingForSome = true;\n        }\n        return this.isWorkingForSome = false;\n    }\n    getCalendars() {\n        this.getGroups();\n        return this.calendars;\n    }\n    isCalendarWorking(calendar) {\n        return this.getCalendarsWorkStatus().get(calendar);\n    }\n    getCalendarsWorkStatus() {\n        if (this.calendarsWorkStatus)\n            return this.calendarsWorkStatus;\n        const res = new Map();\n        for (let [calendar, intervals] of this.getGroups()) {\n            res.set(calendar, intervals[0].isWorking);\n        }\n        return this.calendarsWorkStatus = res;\n    }\n    getCalendarsWorking() {\n        if (this.calendarsWorking)\n            return this.calendarsWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            if (intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsWorking = calendars;\n    }\n    getCalendarsNonWorking() {\n        if (this.calendarsNonWorking)\n            return this.calendarsNonWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            if (!intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsNonWorking = calendars;\n    }\n    getGroups() {\n        if (this.intervalsByCalendar)\n            return this.intervalsByCalendar;\n        const calendars = this.calendars = [];\n        const intervalsByCalendar = new Map();\n        this.intervalGroups.forEach(([calendar, interval]) => {\n            let data = intervalsByCalendar.get(calendar);\n            if (!data) {\n                calendars.push(calendar);\n                data = [];\n                intervalsByCalendar.set(calendar, data);\n            }\n            data.push.apply(data, interval.intervals);\n        });\n        intervalsByCalendar.forEach((intervals, calendar) => {\n            const unique = stripDuplicates(intervals);\n            unique.sort(\n            // sort in decreasing order\n            (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());\n            intervalsByCalendar.set(calendar, unique);\n        });\n        return this.intervalsByCalendar = intervalsByCalendar;\n    }\n}\n", "// Generic binary search\nexport const binarySearch = (value, array, comparator = (a, b) => a - b) => {\n    let left = 0;\n    let right = array.length;\n    while (left < right) {\n        // | 0 to make it integer, faster according to: https://jsperf.com/or-vs-floor/2\n        const mid = (left + right) / 2 | 0;\n        const compare = comparator(value, array[mid]);\n        if (compare === 0)\n            return { found: true, index: mid };\n        else if (compare < 0)\n            right = mid;\n        else\n            left = mid + 1;\n    }\n    return { found: false, index: right };\n};\n", "import { binarySearch } from \"../util/BinarySearch.js\";\nexport var IndexPosition;\n(function (IndexPosition) {\n    IndexPosition[IndexPosition[\"Exact\"] = 0] = \"Exact\";\n    IndexPosition[IndexPosition[\"Next\"] = 1] = \"Next\";\n})(IndexPosition || (IndexPosition = {}));\nexport class SortedMap {\n    constructor(comparator) {\n        this.keys = [];\n        this.values = [];\n        this.comparator = comparator || ((a, b) => a - b);\n    }\n    set(key, value) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        if (search.found) {\n            this.values[search.index] = value;\n        }\n        else {\n            this.keys.splice(search.index, 0, key);\n            this.values.splice(search.index, 0, value);\n        }\n        return search.index;\n    }\n    // you need to know what you are doing when using this method\n    insertAt(index, key, value) {\n        this.keys.splice(index, 0, key);\n        this.values.splice(index, 0, value);\n    }\n    setValueAt(index, value) {\n        this.values[index] = value;\n    }\n    get(key) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        return search.found ? this.values[search.index] : undefined;\n    }\n    getEntryAt(index) {\n        return index < this.keys.length ? { key: this.keys[index], value: this.values[index] } : undefined;\n    }\n    getKeyAt(index) {\n        return this.keys[index];\n    }\n    getValueAt(index) {\n        return this.values[index];\n    }\n    delete(key) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        if (search.found)\n            this.deleteAt(search.index);\n    }\n    size() {\n        return this.keys.length;\n    }\n    deleteAt(index) {\n        this.keys.splice(index, 1);\n        this.values.splice(index, 1);\n    }\n    indexOfKey(key) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        return {\n            found: search.found ? IndexPosition.Exact : IndexPosition.Next,\n            index: search.index\n        };\n    }\n    map(func) {\n        const keys = this.keys;\n        const values = this.values;\n        const result = [];\n        for (let i = 0; i < keys.length; i++)\n            result.push(func(values[i], keys[i], i));\n        return result;\n    }\n    getAllEntries() {\n        return this.map((value, key) => { return { value, key }; });\n    }\n    clear() {\n        this.keys.length = 0;\n        this.values.length = 0;\n    }\n}\n", "import { MAX_DATE, MIN_DATE } from \"../util/Constants.js\";\nimport { EdgeInclusion } from \"../util/Types.js\";\nimport { IndexPosition, SortedMap } from \"./SortedMap.js\";\nexport class IntervalCache {\n    constructor(config) {\n        this.points = new SortedMap((a, b) => a.getTime() - b.getTime());\n        this.leftInfinityKey = MIN_DATE;\n        this.rightInfinityKey = MAX_DATE;\n        Object.assign(this, config);\n        if (this.emptyInterval === undefined || !this.combineIntervalsFn)\n            throw new Error(\"All of `emptyPoint`, `combineIntervalsFn` are required\");\n        this.points.set(this.leftInfinityKey, this.emptyInterval);\n    }\n    size() {\n        return this.points.size();\n    }\n    indexOf(date) {\n        return this.points.indexOfKey(date);\n    }\n    getDateAt(index) {\n        return this.points.getKeyAt(index);\n    }\n    getPointAt(index) {\n        return this.points.getValueAt(index);\n    }\n    getIntervalOf(date, edgeInclusion = EdgeInclusion.Left) {\n        // the `index` here is guaranteed to be > 0, because at index 0 there's a `emptyPoint`\n        let { found, index } = this.indexOf(date);\n        let startDateIndex;\n        if (edgeInclusion === EdgeInclusion.Left) {\n            startDateIndex = found === IndexPosition.Exact ? index : index - 1;\n        }\n        else {\n            startDateIndex = index - 1;\n        }\n        return this.getIntervalWithStartDateIndex(startDateIndex);\n    }\n    getPrevInterval(interval) {\n        if (interval.startDateIndex === 0)\n            return null;\n        return this.getIntervalWithStartDateIndex(interval.startDateIndex - 1);\n    }\n    getNextInterval(interval) {\n        if (interval.startDateIndex >= this.size() - 1)\n            return null;\n        return this.getIntervalWithStartDateIndex(interval.startDateIndex + 1);\n    }\n    getIntervalWithStartDateIndex(startDateIndex) {\n        return {\n            startDateIndex: startDateIndex,\n            startDate: this.getDateAt(startDateIndex),\n            endDate: startDateIndex + 1 < this.size() ? this.getDateAt(startDateIndex + 1) : this.rightInfinityKey,\n            cacheInterval: this.getPointAt(startDateIndex)\n        };\n    }\n    addInterval(startDate, endDate, extendInterval) {\n        const points = this.points;\n        // there is always \"leftInfinityKey\" empty point, so `index >= 0`\n        const { found, index } = points.indexOfKey(startDate);\n        let curIndex;\n        let lastUpdatedPoint;\n        if (found == IndexPosition.Exact) {\n            const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index));\n            points.setValueAt(index, inclusion);\n            curIndex = index + 1;\n        }\n        else {\n            const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index - 1));\n            points.insertAt(index, startDate, inclusion);\n            curIndex = index + 1;\n        }\n        while (curIndex < points.size()) {\n            const curDate = points.getKeyAt(curIndex);\n            if (curDate.getTime() >= endDate.getTime())\n                break;\n            const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(curIndex));\n            points.setValueAt(curIndex, inclusion);\n            curIndex++;\n        }\n        if (curIndex === points.size()) {\n            points.insertAt(points.size(), endDate, this.emptyInterval);\n        }\n        else {\n            const curDate = points.getKeyAt(curIndex);\n            if (curDate.getTime() === endDate.getTime()) {\n                // we advanced till some point, which matches `endDate` config\n                // this point will setup a new label, no need to add an explicit end date point,\n                // we are done, do nothing\n            }\n            else {\n                points.insertAt(curIndex, endDate, lastUpdatedPoint);\n            }\n        }\n    }\n    includeWrappingRange(intervalCache, startDate, endDate) {\n        let interval = intervalCache.getIntervalOf(startDate);\n        while (interval) {\n            this.addInterval(interval.startDate, interval.endDate, existingInterval => this.combineIntervalsFn(existingInterval, interval.cacheInterval));\n            if (interval.endDate.getTime() > endDate.getTime())\n                break;\n            interval = intervalCache.getNextInterval(interval);\n        }\n    }\n    getSummary() {\n        return this.points.map((label, date) => { return { label, date }; });\n    }\n    clear() {\n        this.points.clear();\n        this.points.set(this.leftInfinityKey, this.emptyInterval);\n    }\n}\n", "import { stripDuplicates } from \"../util/StripDuplicates.js\";\nimport { CalendarCache } from \"./CalendarCache.js\";\nimport { CalendarCacheIntervalMultiple } from \"./CalendarCacheIntervalMultiple.js\";\nimport { IntervalCache } from \"./IntervalCache.js\";\n/**\n * The calendar cache for combination of multiple calendars\n */\nexport class CalendarCacheMultiple extends CalendarCache {\n    constructor(config) {\n        super(config);\n        this.calendarCaches = stripDuplicates(this.calendarCaches);\n        this.intervalCache = new IntervalCache({\n            emptyInterval: new CalendarCacheIntervalMultiple(),\n            combineIntervalsFn: (interval1, interval2) => {\n                return interval1.combineWith(interval2);\n            }\n        });\n    }\n    fillCache(startDate, endDate) {\n        this.calendarCaches.forEach(calendarCache => {\n            calendarCache.fillCache(startDate, endDate);\n            this.includeWrappingRangeFrom(calendarCache, startDate, endDate);\n        });\n    }\n}\nconst COMBINED_CALENDARS_CACHE = new Map();\nexport const combineCalendars = (calendars) => {\n    const uniqueOnly = stripDuplicates(calendars);\n    if (uniqueOnly.length === 0)\n        throw new Error(\"No calendars to combine\");\n    uniqueOnly.sort((calendar1, calendar2) => {\n        if (calendar1.internalId < calendar2.internalId)\n            return -1;\n        else\n            return 1;\n    });\n    const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');\n    const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');\n    let cached = COMBINED_CALENDARS_CACHE.get(hash);\n    let res;\n    if (cached && cached.versionsHash === versionsHash)\n        res = cached.cache;\n    else {\n        res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache) });\n        // COMBINED_CALENDARS_CACHE.set(hash, {\n        //     versionsHash    : versionsHash,\n        //     cache           : res\n        // })\n    }\n    return res;\n};\n", "/**\n * @module Core/helper/TimeZoneHelper\n */\n// region Internal\n// Used internally to save offset info\nclass TimeZoneOffsetInfo extends Array {\n    constructor(timeZone, year) {\n        super();\n        this.timeZone = timeZone;\n        this.year = year;\n    }\n}\n// Used internally to handle more info than possible with ordinary Date\nclass TimeZoneDate {\n    constructor(asString, timeZone) {\n        this.asString = asString;\n        this.timeZone = timeZone;\n        this.asArray = parseStringDate(asString);\n    }\n    // Lazy, used in TZH.toTimeZone\n    get asLocalDate() {\n        if (!this._asLocalDate) {\n            this._asLocalDate = new Date(...this.asArray);\n        }\n        return this._asLocalDate;\n    }\n    // Lazy, used when finding offsets\n    get asTicksUtc() {\n        if (!this._asTicksUtc) {\n            this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();\n        }\n        return this._asTicksUtc;\n    }\n}\n// Takes a local date and converts it to a TimeZoneDate by converting to string and parsing it\nconst\n    toTimeZoneInternal = (date, timeZone) => {\n        const tzDateString = date.toLocaleString('sv-SE', { timeZone });\n        return new TimeZoneDate(tzDateString, timeZone);\n    },\n    // Takes ticks (Date.getTime()) and a timezone and returns the difference\n    getOffsetUtc = (ticks, timeZone) => {\n        const { asTicksUtc, asString }  = toTimeZoneInternal(new Date(ticks), timeZone);\n        return { offset : (ticks - asTicksUtc) / 60000, tzTicksUtc : asTicksUtc, tzString : asString };\n    },\n    // Parse a 'YYYY-MM-DD HH:MM' formatted datetime into an array of numbers (month is zero-based)\n    parseStringDate = stringDate => {\n        const parsed = stringDate.split(/[\\s-:]/).map(i => i * 1);\n        parsed[1] -= 1;\n        return parsed;\n    },\n    min   = -60000,\n    hour  = 3600000,\n    day   = -86400000,\n    month = 2592000000,\n    // This function will take a IANA time zone and any year, and then loop through each month and test for UTC offsets\n    // If it finds more than one, that implies that current time zone has DST that actual year. The function will then go\n    // deeper and find the exact datetimes where DST changes occurs.\n    // All data is cached, so when same year is asked for later it's already calculated\n    findOffsetDates = (timeZone, year) => {\n        const cached = offsetDateCache.get(timeZone, year);\n        if (cached) {\n            return cached;\n        }\n        const\n            offsets        = new TimeZoneOffsetInfo(timeZone, year),\n            // The check runs with UTC ticks\n            startUtcTicks  = new Date(Date.UTC(year, 0, 1)).getTime();\n        let ticks          = startUtcTicks,\n            incr           = month,\n            monthIndex     = 0,\n            previousOffset = [],\n            currentOffset  = null,\n            tzTicksUtc, tzString, offset,  done;\n        // Loop is perhaps a bit difficult to understand. Basically, what it does is this:\n        // (1) Go forward month by month looking for changed offsets, if found continue reading (2), else no DST found.\n        // (2) Go backwards from date found in (1) day by day until offset changes back to the first one found.\n        // (3) Go forwards hour by hour from date found in (2) until offset changes again.\n        // (4) Go backwards minute by minute from date found in (3) until offset changes back to the first one found.\n        // (5) The offset we're looking for is the one previous to that found in (4).\n        // (6) Continue loop for next DST change date.\n        while (!done) {\n        // Gets UTC offset for current utc ticks\n            ({ offset, tzTicksUtc, tzString } = getOffsetUtc(ticks, timeZone));\n            // If first call, add that offset to the list of found offsets.\n            // Also save this offset as the current one found\n            if (currentOffset == null) {\n                currentOffset = offset;\n                offsets.push({ offset });\n            }\n            // If we are looping months or hours and the offset has changed from the one previously found\n            else if (incr > 0 && offset !== currentOffset) {\n            // Change to loop days or minutes\n                incr = incr === month ? day : min;\n            }\n            // If we are looping days or minutes and the offset again equals the one previously found\n            else if (incr < 0 && offset === currentOffset) {\n            // If we are looping days, change to loop hours\n                if (incr === day) {\n                    incr = hour;\n                }\n                // If we are looping minutes, that means that we have found the exact DST change position\n                else {\n                // Just one offset, add another\n                    if (offsets.length === 1) {\n                        offsets.push(previousOffset);\n                        currentOffset = previousOffset.offset;\n                    // Continue to find the ending of offset2/start of offset1\n                    }\n                    // Has two offset, found ending of offset2/start of offset1\n                    else {\n                        offsets[0].startTicks = previousOffset.startTicks;\n                        offsets[0].startDateString = previousOffset.startDateString;\n                        // We are done\n                        done = true;\n                    }\n                    // Change to loop months again\n                    incr = month;\n                }\n            }\n            // Always store previous offset as to easily be able to get back to it in loop\n            previousOffset = { offset, startDateString : tzString, startTicks : tzTicksUtc };\n            // If we're looping months, we need to ignore the day/hour/minute loop on ticks\n            if (incr === month) {\n                ticks = startUtcTicks;\n                ticks += monthIndex * month;\n                monthIndex += 1;\n            }\n            ticks += incr;\n            // If now DST, we are done after 12 months\n            if (monthIndex > 11) {\n                done = true;\n            }\n        }\n        // Save to cache\n        offsetDateCache.set(offsets);\n        return offsets;\n    },\n    offsetDateCache = {\n        _cache : {},\n        get(timeZone, year) {\n            return this._cache[timeZone]?.[year];\n        },\n        set(offsetInfo) {\n            const\n                { timeZone } = offsetInfo,\n                { _cache } = this;\n            if (!_cache[timeZone]) {\n                _cache[timeZone] = {};\n            }\n            _cache[timeZone][offsetInfo.year] = offsetInfo;\n        }\n    };\n// endregion\n/**\n * Helper for time zone manipulation.\n */\nexport default class TimeZoneHelper {\n    static get $name() {\n        return 'TimeZoneHelper';\n    }\n    /**\n     * Adjusts the time of the specified date to match the specified time zone. i.e. \"what time is it now in this\n     * timezone?\"\n     *\n     * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the\n     * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.\n     *\n     * Note that this time zone calculation relies on the browsers built-in functionality to convert a local date to a\n     * string in a given time zone and then converting the string back into a date. If browsers time zone information\n     * or interpretation is inaccurate or lacks data, the conversion will probably be inaccurate as well.\n     *\n     * ```javascript\n     * const localDate = new Date(2020, 7, 31, 7); // UTC+2 ('Europe/Stockholm')\n     * const cstDate   = TimeZoneHelper.toTimezone(localDate, 'America/Chicago'); // 2020, 7, 31, 0 (still UTC+2, but\n     * // appear as UTC-6)\n     * ```\n     *\n     * @static\n     * @param {Date} date\n     * @param {String|Number} timeZone Timezone supported by `Intl.DateFormat` or a UTC offset in minutes\n     * @returns {Date}\n     */\n    static toTimeZone(date, timeZone) {\n        if (typeof timeZone === 'number') {\n            return this.toUtcOffset(date, timeZone);\n        }\n        const tzDate = toTimeZoneInternal(date, timeZone);\n        if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {\n            console.warn('Incorrect time zone conversion due to local DST-switch detected');\n        }\n        return tzDate.asLocalDate;\n    }\n    /**\n     * Adjusts the time of the specified date to match local system time zone in the specified time zone. i.e. \"what\n     * time in my timezone would match time in this timezone?\"\n     *\n     * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the\n     * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.\n     *\n     * Note that this time zone calculation relies on the browsers built-in functionality to convert a date from a given\n     * timezone into a local date by calculating specified time zone UTC offsets and using those to perform the date\n     * conversion. If browsers time zone information or interpretation is inaccurate or lacks data, the conversion will\n     * probably be inaccurate as well.\n     *\n     * ```javascript\n     * const cstDate   = new Date(2022, 8, 27, 4); // CST 'America/Chicago'\n     * const localDate = TimeZoneHelper.fromTimeZone(cstDate, 'America/Chicago'); // 2022, 8, 27, 11 (UTC+2 Europe/Stockholm)\n     * ```\n     *\n     * @static\n     * @param {Date} date\n     * @param {String|Number} timeZone Timezone supported by Intl.DateFormat or a UTC offset in minutes\n     * @returns {Date}\n     */\n    static fromTimeZone(date, timeZone) {\n        if (typeof timeZone === 'number') {\n            return this.fromUtcOffset(date, timeZone);\n        }\n        const\n            dateArr     = this.dateAsArray(date),\n            offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());\n        let useOffset = offsetDates[0].offset;\n        if (offsetDates.length === 2) {\n            const utcTicks = Date.UTC(...dateArr);\n            if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {\n                useOffset = offsetDates[1].offset;\n            }\n        }\n        // Converting without having to deal with local time\n        dateArr[4] += useOffset; // Adds offset minutes\n        return new Date(Date.UTC(...dateArr));\n    }\n    /**\n     * Adjusts the time of the specified date with provided UTC offset in minutes\n     *\n     * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the\n     * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.\n     *\n     * ```javascript\n     * const localDate = new Date(2020, 7, 31, 7); // UTC+2\n     * const utcDate   = TimeZoneHelper.toUtcOffset(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)\n     * ```\n     *\n     * @static\n     * @private\n     * @param {Date} date\n     * @param {Number} utcOffset in minutes\n     * @returns {Date}\n     */\n    static toUtcOffset(date, utcOffset) {\n        const offset = date.getTimezoneOffset() + utcOffset;\n        return new Date(date.getTime() + offset * 60 * 1000);\n    }\n    /**\n     * Adjusts the time of the specified date by removing the provided UTC offset in minutes.\n     *\n     * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the\n     * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.\n     *\n     * ```javascript\n     * const utcDate = new Date(2020, 7, 31, 7); // UTC\n     * const utcDate = TimeZoneHelper.fromUtcOffset(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)\n     * ```\n     *\n     * @static\n     * @private\n     * @param {Date} date\n     * @param {Number} utcOffset in minutes\n     * @returns {Date}\n     */\n    static fromUtcOffset(date, utcOffset) {\n        const offset = -date.getTimezoneOffset() - utcOffset;\n        return new Date(date.getTime() + offset * 60 * 1000);\n    }\n    // Converts a date into an array of its parts ([year, month, day, etc.]).\n    // Convenient as a date info bearer which is not affected by local time zone\n    static dateAsArray(date) {\n        return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n    }\n}\nTimeZoneHelper.findOffsetDates = findOffsetDates;\nTimeZoneHelper._$name = 'TimeZoneHelper';", "import later from \"../vendor/later/later.js\";\nimport { CalendarCache } from \"./CalendarCache.js\";\nimport { CalendarCacheInterval } from \"./CalendarCacheInterval.js\";\nimport { IntervalCache } from \"./IntervalCache.js\";\nimport DateHelper from \"../../Core/helper/DateHelper.js\";\nimport TimeZoneHelper from \"../../Core/helper/TimeZoneHelper.js\";\nexport class CalendarCacheSingle extends CalendarCache {\n    constructor(config) {\n        super(config);\n        this.staticIntervalsCached = false;\n        if (!this.unspecifiedTimeInterval)\n            throw new Error(\"Required attribute `unspecifiedTimeInterval` is missing\");\n        this.intervalCache = new IntervalCache({\n            emptyInterval: new CalendarCacheInterval({\n                intervals: [this.unspecifiedTimeInterval],\n                calendar: this.calendar\n            }),\n            combineIntervalsFn: (interval1, interval2) => {\n                return interval1.combineWith(interval2);\n            }\n        });\n    }\n    fillCache(startDate, endDate) {\n        if (!this.staticIntervalsCached) {\n            this.cacheStaticIntervals();\n            this.staticIntervalsCached = true;\n        }\n        if (this.parentCache)\n            this.includeWrappingRangeFrom(this.parentCache, startDate, endDate);\n        const startDateN = startDate.getTime();\n        const endDateN = endDate.getTime();\n        const timeZone = this.calendar.project?.timeZone;\n        if (startDateN > endDateN)\n            throw new Error(\"Invalid cache fill interval\");\n        this.forEachRecurrentInterval(interval => {\n            const startSchedule = interval.getStartDateSchedule();\n            const endSchedule = interval.getEndDateSchedule();\n            let wrappingStartDate = startSchedule.prev(1, startDate);\n            let wrappingEndDate;\n            if (endSchedule === 'EOD') {\n                const nextEndDate = startSchedule.next(1, endDate);\n                if (nextEndDate !== later.NEVER) {\n                    wrappingEndDate = DateHelper.getStartOfNextDay(nextEndDate, true);\n                }\n                else {\n                    wrappingEndDate = later.NEVER;\n                }\n            }\n            else {\n                wrappingEndDate = endSchedule.next(1, endDate);\n            }\n            // if the `startDate` is an occurrence in the interval's schedule, we need to advance one point prior\n            // this is to provide the backward-scheduling information for the `startDate` point\n            if (wrappingStartDate !== later.NEVER && wrappingStartDate.getTime() === startDateN) {\n                const wrappingStartDates = startSchedule.prev(2, startDate);\n                if (wrappingStartDates !== later.NEVER && wrappingStartDates.length === 2)\n                    wrappingStartDate = wrappingStartDates[1];\n            }\n            if (wrappingEndDate !== later.NEVER && wrappingEndDate.getTime() === endDateN) {\n                const wrappingEndDates = endSchedule.next(2, endDate);\n                if (wrappingEndDates !== later.NEVER && wrappingEndDates.length === 2)\n                    wrappingEndDate = wrappingEndDates[1];\n            }\n            const startDates = startSchedule.next(Infinity, wrappingStartDate !== later.NEVER ? wrappingStartDate : startDate, wrappingEndDate !== later.NEVER ? new Date(wrappingEndDate.getTime() - 1) : endDate);\n            // schedule is empty for the interval of interest, do nothing\n            if (startDates === later.NEVER)\n                return;\n            // at this point `startDates` is a non-empty array\n            const endDates = endSchedule === 'EOD' ? startDates.map(date => DateHelper.getStartOfNextDay(date, true)) : endSchedule.next(Infinity, new Date(startDates[0].getTime() + 1), wrappingEndDate !== later.NEVER ? wrappingEndDate : endDate);\n            if (endDates === later.NEVER)\n                return;\n            if (endDates.length > startDates.length) {\n                // safe to ignore \"extra\" end dates\n                endDates.length = startDates.length;\n            }\n            else if (endDates.length < startDates.length) {\n                // monkey patch\n                startDates.length = endDates.length;\n                // throw new Error(\"Recurrent interval inconsistency: \" + interval + \", caching startDate: \" + startDate + \", caching endDate: \" + endDate)\n            }\n            startDates.forEach((startDate, index) => {\n                let recStartDate = startDate;\n                let recEndDate = endDates[index];\n                // Adjust calendar intervals when changing time zone\n                if (timeZone != null) {\n                    recStartDate = TimeZoneHelper.toTimeZone(recStartDate, timeZone);\n                    recEndDate = TimeZoneHelper.toTimeZone(recEndDate, timeZone);\n                }\n                // if (recStartDate.getTime() > recEndDate.getTime())\n                //     throw new Error(\"Recurrent interval inconsistency: \" + interval + \", startDate: \" + startDate + \", endDate: \" + endDates[ index ])\n                this.intervalCache.addInterval(recStartDate, recEndDate, existingCacheInterval => existingCacheInterval.includeInterval(interval));\n            });\n        });\n    }\n    clear() {\n        this.staticIntervalsCached = false;\n        super.clear();\n    }\n    cacheStaticIntervals() {\n        this.forEachStaticInterval(interval => {\n            const timeZone = this.calendar.project?.timeZone;\n            let { startDate, endDate } = interval;\n            // Adjust calendar intervals when changing time zone\n            if (timeZone != null) {\n                startDate = TimeZoneHelper.toTimeZone(startDate, timeZone);\n                endDate = TimeZoneHelper.toTimeZone(endDate, timeZone);\n            }\n            this.intervalCache.addInterval(startDate, endDate, existingCacheInterval => existingCacheInterval.includeInterval(interval));\n        });\n    }\n    forEachStaticInterval(func) {\n        this.intervalStore.forEach((interval) => {\n            if (interval.isStatic())\n                func(interval);\n        });\n    }\n    forEachRecurrentInterval(func) {\n        this.intervalStore.forEach((interval) => {\n            if (interval.isRecurrent())\n                func(interval);\n        });\n    }\n}\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\n/**\n * This a base generic mixin for every class, that belongs to a project.\n *\n * It just provides getter/setter for the `project` property, along with some convenience methods\n * to access the project's stores.\n */\nexport class AbstractPartOfProjectGenericMixin extends Mixin([], (base) => {\n    const superProto = base.prototype;\n    class AbstractPartOfProjectGenericMixin extends base {\n        async commitAsync() {\n            return this.project.commitAsync();\n        }\n        set project(project) {\n            this.$project = project;\n        }\n        get project() {\n            return this.$project;\n        }\n        calculateProject() {\n            throw new Error(\"Implement me\");\n        }\n        /**\n         * The method to set the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        setProject(project) {\n            return this.project = project;\n        }\n        /**\n         * The method to get the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getProject() {\n            if (this.project)\n                return this.project;\n            return this.setProject(this.calculateProject());\n        }\n        /**\n         * Convenience method to get the instance of the assignment store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getAssignmentStore() {\n            const project = this.getProject();\n            return project?.assignmentStore;\n        }\n        /**\n         * Convenience method to get the instance of the dependency store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getDependencyStore() {\n            const project = this.getProject();\n            return project?.dependencyStore;\n        }\n        /**\n         * Convenience method to get the instance of the event store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getEventStore() {\n            const project = this.getProject();\n            return project?.eventStore;\n        }\n        /**\n         * Convenience method to get the instance of the resource store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getResourceStore() {\n            const project = this.getProject();\n            return project?.resourceStore;\n        }\n        /**\n         * Convenience method to get the instance of the calendar manager store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getCalendarManagerStore() {\n            const project = this.getProject();\n            return project?.calendarManagerStore;\n        }\n    }\n    return AbstractPartOfProjectGenericMixin;\n}) {\n}\n", "import Objects from './util/Objects.js';\n// NOTE: This import prevents this module from being imported by Base (or anything Base imports):\nimport DateHelper from './DateHelper.js';\nimport StringHelper from './StringHelper.js';\n/**\n * @module Core/helper/ObjectHelper\n */\n// Detect if browser has bad implementation of toFixed()\nconst\n    { hasOwn } = Objects,\n    toFixedFix = (1.005).toFixed(2) === '1.01' ? null : function(number, fractionDigits) {\n        const\n            split = number.toString().split('.'),\n            newNumber = +(!split[1] ? split[0] : split.join('.') + '1');\n        return number.toFixed.call(newNumber, fractionDigits);\n    };\n/**\n * Helper for Object manipulation.\n */\nexport default class ObjectHelper extends Objects {\n    // These methods are inherited from Objects (an internal class) but need to be documented here for public use.\n    // This is primarily because static methods, while inherited by JavaScript classes, are not displayed in derived\n    // classes in the docs.\n    /**\n     * Copies all enumerable properties from the supplied source objects to `dest`. Unlike `Object.assign`, this copy\n     * also includes inherited properties.\n     * @param {Object} dest The destination object.\n     * @param {...Object} sources The source objects.\n     * @returns {Object} The `dest` object.\n     * @method assign\n     * @static\n     */\n    /**\n     * Copies all enumerable properties from the supplied source objects to `dest`, only including properties that does\n     * not already exist on `dest`. Unlike `Object.assign`, this copy also includes inherited properties.\n     * @param {Object} dest The destination object.\n     * @param {...Object} sources The source objects.\n     * @returns {Object} The `dest` object.\n     * @method assignIf\n     * @static\n     */\n    /**\n     * Creates a deep copy of the `value`. Simple objects ({@link #function-isObject-static}, arrays and `Date` objects\n     * are cloned. The enumerable properties of simple objects and the elements of arrays are cloned recursively.\n     * @param {*} value The value to clone.\n     * @param {Function} [handler] An optional function to call for values of types other than simple object, array or\n     * `Date`. This function should return the clone of the `value` passed to it. It is only called for truthy values\n     * whose `typeof` equals `'object'`.\n     * @param {*} handler.value The value to clone.\n     * @returns {*} The cloned value.\n     * @method clone\n     * @static\n     */\n    /**\n     * Converts a list of names (either a space separated string or an array), into an object with those properties\n     * assigned truthy values. The converse of {@link #function-getTruthyKeys-static}.\n     * @param {String|String[]} source The list of names to convert to object form.\n     * @method createTruthyKeys\n     * @static\n     */\n    /**\n     * Gathers the names of properties which have truthy values into an array.\n     *\n     * This is useful when gathering CSS class names for complex element production.\n     * Instead of appending to an array or string which may already contain the\n     * name, and instead of contending with space separation and concatenation\n     * and conditional execution, just set the properties of an object:\n     *\n     *     cls = {\n     *         [this.selectedCls] : this.isSelected(thing),\n     *         [this.dirtyCls] : this.isDirty(thing)\n     *     };\n     *\n     * @param {Object} source Source of keys to gather into an array.\n     * @returns {String[]} The keys which had a truthy value.\n     * @method getTruthyKeys\n     * @static\n     */\n    /**\n     * Gathers the values of properties which are truthy into an array.\n     * @param {Object} source Source of values to gather into an array.\n     * @returns {String[]} The truthy values from the passed object.\n     * @method getTruthyValues\n     * @static\n     */\n    /**\n     * Tests whether a passed object has any enumerable properties.\n     * @param {Object} object\n     * @returns {Boolean} `true` if the passed object has no enumerable properties.\n     * @method isEmpty\n     * @static\n     */\n    /**\n     * Returns `true` if the `value` is a simple `Object`.\n     * @param {Object} value\n     * @returns {Boolean} `true` if the `value` is a simple `Object`.\n     * @method isObject\n     * @static\n     */\n    /**\n     * Copies all enumerable properties from the supplied source objects to `dest`, recursing when the properties of\n     * both the source and `dest` are objects.\n     * ```\n     *  const o = {\n     *      a : 1,\n     *      b : {\n     *          c : 2\n     *      }\n     *  };\n     *  const o2 = {\n     *      b : {\n     *          d : 3\n     *      }\n     *  }\n     *\n     *  console.log(merge(o, o2));\n     *\n     *  > { a : 1, b : { c : 2, d : 3 } }\n     * ```\n     * @param {Object} dest The destination object.\n     * @param {...Object} sources The source objects.\n     * @returns {Object} The `dest` object.\n     * @method merge\n     * @static\n     */\n    /**\n     * Returns the specific type of the given `value`. Unlike the `typeof` operator, this function returns the text\n     * from the `Object.prototype.toString` result allowing `Date`, `Array`, `RegExp`, and others to be differentiated.\n     * ```\n     *  console.log(typeOf(null));\n     *  > null\n     *\n     *  console.log(typeOf({}));\n     *  > object\n     *\n     *  console.log(typeOf([]));\n     *  > array\n     *\n     *  console.log(typeOf(new Date()));\n     *  > date\n     *\n     *  console.log(typeOf(NaN));\n     *  > nan\n     *\n     *  console.log(typeOf(/a/));\n     *  > regexp\n     * ```\n     * @param {*} value\n     * @returns {String}\n     * @method typeOf\n     * @static\n     */\n    /**\n     * Returns value for a given path in the object\n     * @param {Object} object Object to check path on\n     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'\n     * @returns {*} Value associated with passed key\n     * @method getPath\n     * @static\n     */\n    /**\n     * Sets value for a given path in the object\n     * @param {Object} object Target object\n     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'\n     * @param {*} value Value for a given path\n     * @returns {Object} Returns passed object\n     * @method setPath\n     * @static\n     */\n    /**\n     * Creates a new object where key is a property in array item (`ref` by default) or index in the array and value is array item.\n     *\n     * From:\n     * ```\n     * [\n     *     {\n     *          text : 'foo',\n     *          ref : 'fooItem'\n     *     },\n     *     {\n     *          text : 'bar'\n     *     }\n     * ]\n     * ```\n     *\n     * To:\n     * ```\n     * {\n     *     fooItem : {\n     *         text : 'foo',\n     *         ref  : 'fooItem'\n     *     },\n     *     1 : {\n     *         text : 'bar'\n     *     }\n     * }\n     * ```\n     *\n     * @param {Object[]} arrayOfItems Array to transform.\n     * @param {String} [prop] Property to read the key from. `ref` by default.\n     * @returns {Object} namedItems\n     */\n    static transformArrayToNamedObject(arrayOfItems, prop = 'ref') {\n        const namedItems = {};\n        arrayOfItems.forEach((item, index) => {\n            const\n                // 0 is valid value, but empty string in not valid\n                key = (item[prop] != null && item[prop].toString().length) ? item[prop] : index;\n            namedItems[key] = item;\n        });\n        return namedItems;\n    }\n    /**\n     * Creates a new array from object values and saves key in a property (`ref` by default) of each item.\n     *\n     * From:\n     * ```\n     * {\n     *     fooItem : {\n     *         text : 'foo'\n     *     },\n     *     1 : {\n     *         text : 'bar'\n     *     },\n     *     barItem : false // will be ignored\n     * }\n     * ```\n     *\n     * To:\n     * ```\n     * [\n     *     {\n     *          text : 'foo',\n     *          ref : 'fooItem'\n     *     },\n     *     {\n     *          text : 'bar',\n     *          ref : 1\n     *     }\n     * ]\n     * ```\n     *\n     * @param {Object} namedItems Object to transform.\n     * @param {String} [prop] Property to save the key to. `ref` by default.\n     * @returns {Object[]} arrayOfItems\n     */\n    static transformNamedObjectToArray(namedItems, prop = 'ref') {\n        return Object.keys(namedItems).filter(key => namedItems[key]).map(key => {\n            const item = namedItems[key];\n            item[prop] = key;\n            return item;\n        });\n    }\n    /**\n     * Checks if two values are equal. Basically === but special handling of dates.\n     * @param {*} a First value\n     * @param {*} b Second value\n     * @returns {*} true if values are equal, otherwise false\n     */\n    static isEqual(a, b, useIsDeeply = false) {\n        // Eliminate null vs undefined mismatch\n        if (\n            (a === null && b !== null) ||\n            (a === undefined && b !== undefined) ||\n            (b === null && a !== null) ||\n            (b === undefined && a !== undefined)\n        ) {\n            return false;\n        }\n        // Covers undefined === undefined and null === null, since mismatches are eliminated above\n        if (a == null && b == null) {\n            return true;\n        }\n        // The same instance should equal itself.\n        if (a === b) {\n            return true;\n        }\n        const\n            typeA = typeof a,\n            typeB = typeof b;\n        if (typeA === typeB) {\n            switch (typeA) {\n                case 'number':\n                case 'string':\n                case 'boolean':\n                    return a === b;\n            }\n            switch (true) {\n                case a instanceof Date && b instanceof Date:\n                    // faster than calling DateHelper.isEqual\n                    // https://jsbench.me/3jk2bom2r3/1\n                    return a.getTime() === b.getTime();\n                case Array.isArray(a) && Array.isArray(b):\n                    return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;\n                case typeA === 'object' && a.constructor.prototype === b.constructor.prototype:\n                    return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : StringHelper.safeJsonStringify(a) === StringHelper.safeJsonStringify(b);\n            }\n        }\n        return String(a) === String(b);\n    }\n    /**\n     * Checks if two objects are deeply equal\n     * @param {Object} a\n     * @param {Object} b\n     * @param {Object} [options] Additional comparison options\n     * @param {Object} [options.ignore] Map of property names to ignore when comparing\n     * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.\n     * Return false to prevent comparison\n     * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation\n     * result or anything else to let `isEqual` handle the comparison\n     * @returns {Boolean}\n     */\n    static isDeeplyEqual(a, b, options = {}) {\n        // Same object, equal :)\n        if (a === b) {\n            return true;\n        }\n        // Nothing to compare, not equal\n        if (!a || !b) {\n            return false;\n        }\n        // Property names excluding ignored\n        const\n            aKeys = OH.keys(a, options.ignore),\n            bKeys = OH.keys(b, options.ignore);\n        // Property count differs, not equal\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        for (let i = 0; i < aKeys.length; i++) {\n            const\n                aKey = aKeys[i],\n                bKey = bKeys[i];\n            // Property name differs, not equal\n            if (aKey !== bKey) {\n                return false;\n            }\n            const\n                aVal = a[aKey],\n                bVal = b[bKey];\n            // Allow caller to determine if property values should be evaluated or not\n            if (options.shouldEvaluate) {\n                if (options.shouldEvaluate(\n                    aKey,\n                    {\n                        value  : aVal,\n                        object : a\n                    }, {\n                        value  : bVal,\n                        object : b\n                    }\n                ) === false) {\n                    continue;\n                }\n            }\n            // Allow caller to determine equality of properties\n            if (options.evaluate) {\n                const result = options.evaluate(aKey, {\n                    value  : aVal,\n                    object : a\n                }, {\n                    value  : bVal,\n                    object : b\n                });\n                // Not equal\n                if (result === false) {\n                    return false;\n                }\n                // Equal, skip isEqual call below\n                if (result === true) {\n                    continue;\n                }\n            }\n            // Values differ, not equal (also digs deeper)\n            if (!OH.isEqual(aVal, bVal, options)) {\n                return false;\n            }\n        }\n        // Found to be equal\n        return true;\n    }\n    /**\n     * Checks if value B is partially equal to value A.\n     * @param {*} a First value\n     * @param {*} b Second value\n     * @returns {Boolean} true if values are partially equal, false otherwise\n     */\n    static isPartial(a, b) {\n        a = String(a).toLowerCase();\n        b = String(b).toLowerCase();\n        return a.indexOf(b) !== -1;\n    }\n    /**\n     * Checks if value a is smaller than value b.\n     * @param {*} a First value\n     * @param {*} b Second value\n     * @returns {Boolean} true if a < b\n     */\n    static isLessThan(a, b) {\n        if (a instanceof Date && b instanceof Date) {\n            return DateHelper.isBefore(a, b);\n        }\n        return a < b;\n    }\n    /**\n     * Checks if value a is bigger than value b.\n     * @param {*} a First value\n     * @param {*} b Second value\n     * @returns {Boolean} true if a > b\n     */\n    static isMoreThan(a, b) {\n        if (a instanceof Date && b instanceof Date) {\n            return DateHelper.isAfter(a, b);\n        }\n        return a > b;\n    }\n    /**\n     * Used by the Base class to make deep copies of defaultConfig blocks\n     * @private\n     */\n    static fork(obj) {\n        let ret, key, value;\n        if (obj && obj.constructor === Object) {\n            ret = Object.setPrototypeOf({}, obj);\n            for (key in obj) {\n                value = obj[key];\n                if (value) {\n                    if (value.constructor === Object) {\n                        ret[key] = OH.fork(value);\n                    }\n                    else if (value instanceof Array) {\n                        ret[key] = value.slice();\n                    }\n                }\n            }\n        }\n        else {\n            ret = obj;\n        }\n        return ret;\n    }\n    /**\n     * Copies the named properties from the `source` parameter into the `dest` parameter.\n     * @param {Object} dest The destination into which properties are copied.\n     * @param {Object} source The source from which properties are copied.\n     * @param {String[]} props The list of property names.\n     * @returns {Object} The `dest` object.\n     */\n    static copyProperties(dest, source, props) {\n        let prop, i;\n        for (i = 0; i < props.length; i++) {\n            prop = props[i];\n            if (prop in source) {\n                dest[prop] = source[prop];\n            }\n        }\n        return dest;\n    }\n    /**\n     * Copies the named properties from the `source` parameter into the `dest` parameter\n     * unless the property already exists in the `dest`.\n     * @param {Object} dest The destination into which properties are copied.\n     * @param {Object} source The source from which properties are copied.\n     * @param {String[]} props The list of property names.\n     * @returns {Object} The `dest` object.\n     */\n    static copyPropertiesIf(dest, source, props) {\n        if (source) {\n            for (const prop of props) {\n                if (!(prop in dest)) {\n                    dest[prop] = source[prop];\n                }\n            }\n        }\n        return dest;\n    }\n    /**\n     * Returns an array containing the keys and values of all enumerable properties from every prototype level for the\n     * object. If `object` is `null`, this method returns an empty array.\n     * @param {Object} object Object from which to retrieve entries.\n     * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value\n     * which returns `true` to ignore the item.\n     * @returns {Array}\n     * @internal\n     */\n    static entries(object, ignore) {\n        const\n            result = [],\n            call = typeof ignore === 'function';\n        if (object) {\n            for (const p in object) {\n                if (call ? !ignore(p, object[p]) : !ignore?.[p]) {\n                    result.push([p, object[p]]);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Populates an `object` with the provided `entries`.\n     * @param {Array} entries The key/value pairs (2-element arrays).\n     * @param {Object} [object={}] The object onto which to add `entries`.\n     * @returns {Object} The passed `object` (by default, a newly created object).\n     * @internal\n     */\n    static fromEntries(entries, object) {\n        object = object || {};\n        if (entries) {\n            for (let i = 0; i < entries.length; ++i) {\n                object[entries[i][0]] = entries[i][1];\n            }\n        }\n        return object;\n    }\n    /**\n     * Returns an array containing all enumerable property names from every prototype level for the object. If `object`\n     * is `null`, this method returns an empty array.\n     * @param {Object} object Object from which to retrieve property names.\n     * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value\n     * which returns `true` to ignore the item.\n     * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this\n     * function is stored in the returned array. It is called with the array element as the first parameter, and the\n     * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so\n     * on).\n     * @returns {String[]}\n     */\n    static keys(object, ignore, mapper) {\n        const\n            result = [],\n            call = typeof ignore === 'function';\n        if (object) {\n            let index = 0;\n            for (const p in object) {\n                if (call ? !ignore(p, object[p]) : !ignore?.[p]) {\n                    result.push(mapper ? mapper(p, index) : p);\n                    ++index;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns an array containing the values of all enumerable properties from every prototype level for the object.\n     * If `object` is `null`, this method returns an empty array.\n     * @param {Object} object Object from which to retrieve values.\n     * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value\n     * which returns `true` to ignore the item.\n     * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this\n     * function is stored in the returned array. It is called with the array element as the first parameter, and the\n     * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so\n     * on).\n     * @returns {Array}\n     * @internal\n     */\n    static values(object, ignore, mapper) {\n        const\n            result = [],\n            call = typeof ignore === 'function';\n        if (object) {\n            let index = 0;\n            for (const p in object) {\n                if (call ? !ignore(p, object[p]) : !ignore?.[p]) {\n                    result.push(mapper ? mapper(object[p], index) : object[p]);\n                    ++index;\n                }\n            }\n        }\n        return result;\n    }\n    //region Path\n    /**\n     * Checks if a given path exists in an object\n     * @param {Object} object Object to check path on\n     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'\n     * @returns {Boolean} Returns `true` if path exists or `false` if it does not\n     */\n    static pathExists(object, path) {\n        const properties = path.split('.');\n        return properties.every(property => {\n            if (!object || !(property in object)) {\n                return false;\n            }\n            object = object[property];\n            return true;\n        });\n    }\n    /**\n     * Creates a simple single level key-value object from complex deep object.\n     * @param {Object} object Object to extract path and values from\n     * @returns {Object} Key-value object where key is a path to the corresponding value\n     * @internal\n     *\n     * ```javascript\n     * // converts deep object\n     * {\n     *     foo : {\n     *         bar : {\n     *             test : 1\n     *         }\n     *     }\n     * }\n     * // into a single level object\n     * {\n     *     'foo.bar.test' : 1\n     * }\n     * ```\n     */\n    static pathifyKeys(object) {\n        const result = {};\n        for (const key in object) {\n            if (hasOwn(object, key)) {\n                if (Array.isArray(object[key])) {\n                    result[key] = object[key].slice();\n                }\n                else if (object[key] instanceof Object) {\n                    const paths = this.pathifyKeys(object[key]);\n                    for (const path in paths) {\n                        result[`${key}.${path}`] = paths[path];\n                    }\n                }\n                else {\n                    result[key] = object[key];\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Removes value for a given path in the object. Doesn't cleanup empty objects.\n     * @param {Object} object\n     * @param {String} path Dot-separated path, e.g. `obj.child.someKey`\n     * @internal\n     */\n    static deletePath(object, path) {\n        path.split('.').reduce((result, key, index, array) => {\n            if (result == null) {\n                return null;\n            }\n            if (hasOwn(result, key)) {\n                if (index === array.length - 1) {\n                    delete result[key];\n                }\n                else {\n                    return result[key];\n                }\n            }\n        }, object);\n    }\n    //endregion\n    static coerce(from, to) {\n        const fromType = Objects.typeOf(from),\n            toType = Objects.typeOf(to),\n            isString = typeof from === 'string';\n        if (fromType !== toType) {\n            switch (toType) {\n                case 'string':\n                    return String(from);\n                case 'number':\n                    return Number(from);\n                case 'boolean':\n                    // See http://ecma262-5.com/ELS5_HTML.htm#Section_11.9.3 as to why '0'.\n                    // TL;DR => ('0' == 0), so if given string '0', we must return boolean false.\n                    return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);\n                case 'null':\n                    return isString && (!from || from === 'null') ? null : false;\n                case 'undefined':\n                    return isString && (!from || from === 'undefined') ? undefined : false;\n                case 'date':\n                    return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));\n            }\n        }\n        return from;\n    }\n    static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {\n        const newProperty = {};\n        let proto = Object.getPrototypeOf(object),\n            existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);\n        while (!existingProperty && proto && deep) {\n            proto = Object.getPrototypeOf(proto);\n            if (proto) {\n                existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);\n            }\n        }\n        if (existingProperty) {\n            if (existingProperty.set) {\n                newProperty.set = v => {\n                    existingProperty.set.call(object, v);\n                    // Must invoke the getter in case \"v\" has been transformed.\n                    newSetter && newSetter.call(object, existingProperty.get.call(object));\n                };\n            }\n            else {\n                newProperty.set = newSetter;\n            }\n            if (existingProperty.get) {\n                newProperty.get = () => {\n                    let result = existingProperty.get.call(object);\n                    if (newGetter) {\n                        result = newGetter.call(object, result);\n                    }\n                    return result;\n                };\n            }\n            else {\n                newProperty.get = newGetter;\n            }\n        }\n        else {\n            newProperty.set = v => {\n                object[`_${propertyName}`] = v;\n                newSetter && newSetter.call(object, v);\n            };\n            newProperty.get = () => {\n                let result = object[`_${propertyName}`];\n                if (newGetter) {\n                    result = newGetter.call(object, result);\n                }\n                return result;\n            };\n        }\n        Object.defineProperty(object, propertyName, newProperty);\n    }\n    /**\n     * Intercepts access to a `property` of a given `object`.\n     *\n     * ```javascript\n     *      ObjectHelper.hookProperty(object, 'prop', class {\n     *          get value() {\n     *              return super.value;\n     *          }\n     *          set value(v) {\n     *              super.value = v;\n     *          }\n     *      });\n     * ```\n     * The use of `super` allows the hook's getter and setter to invoke the object's existing get/set.\n     *\n     * @param {Object} object\n     * @param {String} property\n     * @param {Function} hook A `class` defining a `value` property getter and/or setter.\n     * @returns {Function} A function that removes the hook when called.\n     * @internal\n     */\n    static hookProperty(object, property, hook) {\n        const\n            desc = ObjectHelper.getPropertyDescriptor(hook.prototype, 'value'),\n            existingDesc = ObjectHelper.getPropertyDescriptor(object, property),\n            fieldName = `_${property}`,\n            base = class {\n                get value() {\n                    return existingDesc ? existingDesc.get.call(this) : this[fieldName];\n                }\n                set value(v) {\n                    if (existingDesc) {\n                        existingDesc.set.call(this, v);\n                    }\n                    else {\n                        this[fieldName] = v;\n                    }\n                }\n            },\n            baseDesc = ObjectHelper.getPropertyDescriptor(base.prototype, 'value');\n        Object.setPrototypeOf(hook.prototype, base.prototype);  // direct super calls to our \"base\" implementation\n        Object.defineProperty(object, property, {\n            configurable : true,\n            get : desc.get || baseDesc.get,\n            set : desc.set || baseDesc.set\n        });\n        return () => delete object[property];\n    }\n    /**\n     * Finds a property descriptor for the passed object from all inheritance levels.\n     * @param {Object} object The Object whose property to find.\n     * @param {String} propertyName The name of the property to find.\n     * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`\n     */\n    static getPropertyDescriptor(object, propertyName) {\n        let result = null;\n        for (let o = object; o && !result && !hasOwn(o, 'isBase'); o = Object.getPrototypeOf(o)) {\n            result = Object.getOwnPropertyDescriptor(o, propertyName);\n        }\n        return result;\n    }\n    /**\n     * Changes the passed object and removes all null and undefined properties from it\n     * @param {Object} object Target object\n     * @param {Boolean} [keepNull] Pass true to only remove undefined properties\n     * @returns {Object} Passed object\n     */\n    static cleanupProperties(object, keepNull = false) {\n        Object.entries(object).forEach(([key, value]) => {\n            if (keepNull) {\n                value === undefined && delete object[key];\n            }\n            else {\n                value == null && delete object[key];\n            }\n        });\n        return object;\n    }\n    /**\n     * Changes the passed object and removes all properties from it.\n     * Used while mutating when need to keep reference to the object but replace its properties.\n     * @param {Object} object Target object\n     * @returns {Object} Passed object\n     */\n    static removeAllProperties(obj) {\n        Object.keys(obj).forEach(key => delete obj[key]);\n        return obj;\n    }\n    //region Assert type\n    /**\n     * Checks that the supplied value is of the specified type.Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} type Expected type\n     * @param {String} name Name of the value, used in error message\n     * @param {Boolean} [allowNull] Accept `null` without throwing\n     */\n    static assertType(value, type, name) {\n        const valueType = Objects.typeOf(value);\n        if (value != null && valueType !== type) {\n            throw new Error(`Incorrect type \"${valueType}\" for ${name}, expected \"${type}\"`);\n        }\n    }\n    /**\n     * Checks that the supplied value is a plain object. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertObject(value, name) {\n        OH.assertType(value, 'object', name);\n    }\n    /**\n     * Checks that the supplied value is an instance of a Bryntum class. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertInstance(value, name) {\n        OH.assertType(value, 'instance', name);\n    }\n    /**\n     * Checks that the supplied value is a Bryntum class. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertClass(value, name) {\n        OH.assertType(value, 'class', name);\n    }\n    /**\n     * Checks that the supplied value is a function. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertFunction(value, name) {\n        if (typeof value !== 'function' || value.isBase || value.$$name) {\n            throw new Error(`Incorrect type for ${name}, got \"${value}\" (expected a function)`);\n        }\n    }\n    /**\n     * Checks that the supplied value is a number. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertNumber(value, name) {\n        const asNumber = Number(value);\n        if (typeof value !== 'number' || isNaN(asNumber)) {\n            throw new Error(`Incorrect type for ${name}, got \"${value}\" (expected a Number)`);\n        }\n    }\n    /**\n     * Checks that the supplied value is a boolean. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertBoolean(value, name) {\n        OH.assertType(value, 'boolean', name);\n    }\n    /**\n     * Checks that the supplied value is a string. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertString(value, name) {\n        OH.assertType(value, 'string', name);\n    }\n    /**\n     * Checks that the supplied value is an array. Throws if it is not\n     * @param {Object} value Value to check type of\n     * @param {String} name Name of the value, used in error message\n     */\n    static assertArray(value, name) {\n        OH.assertType(value, 'array', name);\n    }\n    //endregion\n    /**\n     * Number.toFixed(), with polyfill for browsers that needs it\n     * @param {Number} number\n     * @param {Number} digits\n     * @returns {String} A fixed point string representation of the passed number.\n     */\n    static toFixed(number, digits) {\n        if (toFixedFix) {\n            return toFixedFix(number, digits);\n        }\n        return number.toFixed(digits);\n    }\n    /**\n     * Round the passed number to closest passed step value.\n     * @param {Number} number The number to round.\n     * @param {Number} [step] The step value to round to.\n     * @returns {Number} The number rounded to the closest step.\n     */\n    static roundTo(number, step = 1) {\n        return Math.round(number / step) * step;\n    }\n    /**\n     * Round the passed number to the passed number of decimals.\n     * @param {Number} number The number to round.\n     * @param {Number} digits The number of decimal places to round to.\n     * @returns {Number} The number rounded to the passed number of decimal places.\n     */\n    static round(number, digits) {\n        // Undefined or null means do not round. NOT round to no decimals.\n        if (digits == null) {\n            return number;\n        }\n        const factor = 10 ** digits;\n        return Math.round(number * factor) / factor;\n    }\n    /**\n     * Returns a non-null entry from a Map for a given key path. This enables a specified defaultValue to be added \"just\n     * in time\" which is returned if the key is not already present.\n     * @param {Map} map The Map to find the key in (and potentially add to).\n     * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',\n     * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].\n     * @param {Object} [defaultValue] Optionally the value to insert if the key is not found.\n     */\n    static getMapPath(map, path, defaultValue) {\n        const\n            keyPath   = Array.isArray(path) ? path : typeof path === 'string' ? path.split('.') : [path],\n            simpleKey = keyPath.length === 1,\n            topKey    = keyPath[0],\n            topValue  = map.has(topKey) ? map.get(topKey) : map.set(topKey, simpleKey ? defaultValue : {}).get(topKey);\n        // If it was a simple key, we are done.\n        if (simpleKey) {\n            return topValue;\n        }\n        // Go down the property path on the top Object, filling entries in until the leaf.\n        return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue);\n    }\n}\nconst OH = ObjectHelper;\nObjectHelper._$name = 'ObjectHelper';", "import Base from '../Base.js';\nimport Events from '../mixin/Events.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport Localizable from '../localization/Localizable.js';\n/**\n * @module Core/mixin/InstancePlugin\n */\nfunction getDescriptor(me, fnName) {\n    const property = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);\n    return (property && (property.get || property.set)) ? property : null;\n}\n/**\n * Base class for plugins. Published functions will be available from the other class. `this` in published functions is\n * referenced to the plugin, access the other class using `this.client`.\n *\n * Observe that plugin doesn't apply itself on class level but instead on instance level. Plugin is its own instance\n * that can have own functions and data that is not exposed to target class.\n *\n * Functions can be published in four ways:\n *\n * * `assign` (when function is not already available on target)\n * * `before` (when function is already available on target, will be called before original function)\n * * `after` (when function is already available on target, will be called after original function)\n * * `override` (replaces function on target, but old function can be reached)\n *\n * To configure which functions get published and in what way, specify `pluginConfig` getter on plugin:\n *\n * ```javascript\n * class Sort extends InstancePlugin {\n *   static get pluginConfig {\n *      return {\n *          before   : ['init'],\n *          after    : ['destroy', 'onElementClick'],\n *          override : ['render']\n *      };\n *   }\n * }\n * ```\n *\n * @extends Core/Base\n * @mixes Core/localization/Localizable\n * @mixes Core/mixin/Events\n * @plugin\n */\nexport default class InstancePlugin extends Base.mixin(Events, Localizable) {\n    static $name = 'InstancePlugin';\n    //region Config\n    static get configurable() {\n        return {\n            clientListeners : null,\n            /**\n             * Get/set the plugin/feature `disabled` state.\n             * @member {Boolean} disabled\n             * @category Common\n             */\n            /**\n             * The plugin/feature `disabled` state.\n             *\n             * For a feature that is **off** by default that you want to enable later during runtime,\n             * configure it with `disabled : true`.\n             * ```javascript\n             * const grid = new Grid({\n             *      features : {\n             *          featureName : {\n             *              disabled : true // on and disabled, can be enabled later\n             *          }\n             *      }\n             * });\n             *\n             * // enable the feature\n             * grid.features.featureName.disabled = false;\n             * ```\n             *\n             * If the feature is **off** by default, and you want to include and enable the feature, configure it as `true`:\n             * ```javascript\n             * const grid = new Grid({\n             *      features : {\n             *          featureName : true // on and enabled, can be disabled later\n             *      }\n             * });\n             *\n             * // disable the feature\n             * grid.features.featureName.disabled = true;\n             * ```\n             *\n             * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:\n             * ```javascript\n             * const grid = new Grid({\n             *      features : {\n             *          featureName : false // turned off, not included at all\n             *      }\n             * });\n             * ```\n             *\n             * If the feature is **enabled** by default and you have no need of reconfiguring it,\n             * you can omit the feature configuration.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            disabled : false,\n            /**\n             * The Widget which was passed into the constructor,\n             * which is the Widget we are providing extra services for.\n             * @member {Core.widget.Widget} client\n             * @readonly\n             * @category Misc\n             */\n            /**\n             * The widget which this plugin is to attach to.\n             * @config {Core.widget.Widget}\n             * @category Misc\n             */\n            client : null,\n            // The plugins can define their own keyMap which will then be merged with their client's keyMap.\n            keyMap : null\n        };\n    }\n    //endregion\n    updateClient(client) {\n        // So that this.callback can reach the owning Widget when resolving function names.\n        if (!this.owner) {\n            this.owner = client;\n        }\n    }\n    /**\n     * This will merge a feature's (subclass of InstancePlugin) keyMap with it's client's keyMap.\n     * @private\n     */\n    updateKeyMap(keyMap) {\n        const { client } = this;\n        client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));\n    }\n    //region Init\n    /**\n     * Call from another instance to add plugins to it.\n     * @example\n     * InstancePlugin.initPlugins(this, Search, Stripe);\n     * @param plugInto Instance to mix into (usually this)\n     * @param plugins Classes to plug in\n     * @internal\n     */\n    static initPlugins(plugInto, ...plugins) {\n        const property = plugInto.plugins || (plugInto.plugins = {});\n        for (const PluginClass of plugins) {\n            property[PluginClass.$$name] = new PluginClass(plugInto);\n        }\n    }\n    /**\n     * Simple wrapper for {@link #property-disabled} to make optional chaining simple:\n     *\n     * ```javascript\n     * grid.features.myFeature?.enabled // returns true when feature exists and is enabled\n     * ```\n     * @returns {Boolean}\n     * @internal\n     */\n    get enabled() {\n        return !this.disabled;\n    }\n    // We can act as an owner of a widget, so must be able to participate in focus reversion\n    getFocusRevertTarget() {\n        return this.client?.getFocusRevertTarget();\n    }\n    construct(...args) {\n        const me = this;\n        let [plugInto, config] = args,\n            listeners;\n        // When called with one argument (a config object), grab the \"client\" from the config object.\n        if (args.length === 1) {\n            if (ObjectHelper.isObject(plugInto)) {\n                config = plugInto;\n                plugInto = config.client;\n            }\n        }\n        // Two args, so client is the first. Ensure the config doesn't contain a client property.\n        else {\n            config = ObjectHelper.assign({}, config);\n            delete config.client;\n        }\n        me.client = plugInto;\n        super.construct(config);\n        me.applyPluginConfig(plugInto);\n        listeners = me.clientListeners;\n        if (listeners) {\n            listeners = ObjectHelper.assign({}, listeners);\n            listeners.thisObj = me;\n            // NOTE: If clientListeners are ever made public, we need to separate internal clientListeners from app ones\n            plugInto.ion(listeners);\n        }\n    }\n    /**\n     * Applies config as found in plugInto.pluginConfig, or published all if no config found.\n     * @private\n     * @param plugInto Target instance to plug into\n     */\n    applyPluginConfig(plugInto) {\n        const\n            me     = this,\n            config = me.pluginConfig || me.constructor.pluginConfig;\n        if (config) {\n            const { assign, chain, after, before, override } = config;\n            assign && me.applyAssign(plugInto, assign);\n            (chain || after) && me.applyChain(plugInto, chain || after);\n            before && me.applyChain(plugInto, before, false);\n            override && me.applyOverride(plugInto, override);\n        }\n    }\n    /**\n     * Applies assigning for specified functions.\n     * @private\n     * @param plugInto\n     * @param fnNames\n     */\n    applyAssign(plugInto, fnNames) {\n        fnNames.forEach(fnName => this.assign(plugInto, fnName));\n    }\n    /**\n     * Applies chaining for specified functions.\n     * @private\n     * @param plugInto\n     * @param functions\n     * @param after\n     */\n    applyChain(plugInto, functions, after = true) {\n        if (Array.isArray(functions)) {\n            for (const fnName of functions) {\n                this.chain(plugInto, fnName, fnName, after);\n            }\n        }\n        else {\n            for (const intoName in functions) {\n                this.chain(plugInto, intoName, functions[intoName], after);\n            }\n        }\n    }\n    /**\n     * Applies override for specified functions.\n     * @private\n     * @param plugInto\n     * @param fnNames\n     */\n    applyOverride(plugInto, fnNames) {\n        const me = this;\n        if (!me.overridden) {\n            me.overridden = {};\n        }\n        fnNames.forEach(fnName => {\n            if (!me[fnName]) {\n                throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);\n            }\n            // override\n            if (typeof plugInto[fnName] === 'function') {\n                me.overridden[fnName] = plugInto[fnName].bind(plugInto);\n            }\n            plugInto[fnName] = me[fnName].bind(me);\n        });\n    }\n    /**\n     * Assigns specified functions.\n     * @private\n     * @param plugInto\n     * @param fnName\n     */\n    assign(plugInto, fnName) {\n        const\n            me       = this,\n            property = getDescriptor(me, fnName);\n        if (property) {\n            // getter/setter, define corresponding property on target\n            Object.defineProperty(plugInto, fnName, {\n                configurable : true,\n                enumerable   : true,\n                get          : property.get && property.get.bind(me),\n                set          : property.set && property.set.bind(me)\n            });\n        }\n        else {\n            plugInto[fnName] = me[fnName].bind(me);\n        }\n    }\n    //endregion\n    //region Chaining\n    /**\n     * Chains functions. When the function is called on the target class all functions in the chain will be called in\n     * the order they where added.\n     * @private\n     * @param plugInto\n     * @param intoName\n     * @param hookName\n     * @param after\n     */\n    chain(plugInto, intoName, hookName, after = true) {\n        // default hook prio\n        let prio = 0;\n        if (typeof intoName === 'object') {\n            intoName = intoName.fn;\n        }\n        // if hook is provided as an object\n        if (typeof hookName === 'object') {\n            // hook prio to order runs\n            prio     = hookName.prio || 0;\n            hookName = hookName.fn;\n        }\n        const\n            me    = this,\n            chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}),\n            hookFn =\n                me[hookName] && me[hookName].bind(me),\n            // Grab the fn so that we won't need our this pointer to call it. This is due\n            // to this instance possibly being destroyed by the time a chain call is made.\n            functionChainRunner = me.functionChainRunner;\n        if (!hookFn) {\n            throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);\n        }\n        if (!chains[intoName]) {\n            let intoFn = plugInto[intoName];\n            if (intoFn) {\n                intoFn = intoFn.bind(plugInto);\n                intoFn.$this = plugInto;\n                // use default prio\n                intoFn.$prio = 0;\n            }\n            chains[intoName] = intoFn ? [intoFn] : [];\n            plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);\n        }\n        hookFn.$this = me;\n        hookFn.$prio = prio;\n        chains[intoName][after ? 'push' : 'unshift'](hookFn);\n        chains[intoName].$sorted = false;\n    }\n    /**\n     * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a\n     * function will abort chain.\n     * @private\n     * @param {Array} chain\n     * @param {Array} params\n     * @returns {*} value returned from last function in chain (or false if any returns false)\n     */\n    functionChainRunner(chain, params) {\n        // NOTE: even though we are an instance method, we must not use our \"this\" pointer\n        // since our instance may be destroyed. We cope with that by receiving parameters\n        // for everything we need (so we're just a pure function).\n        let fn, i, returnValue;\n        // sort hooks by prio before running them\n        if (!chain.$sorted) {\n            chain.sort((a, b) => b.$prio - a.$prio);\n            chain.$sorted = true;\n        }\n        for (i = 0; i < chain.length; i++) {\n            fn = chain[i];\n            // Feature hooks remain in place even after GridBase loops and destroys its\n            // features, so skip over any destroyed features on the chain. In particular,\n            // bindStore hooks will be called when GridBase sets store to null.\n            if (!fn.$this.isDestroyed) {\n                returnValue = fn(...params);\n                if (returnValue === false) {\n                    break;\n                }\n            }\n        }\n        return returnValue;\n    }\n    //endregion\n    /**\n     * Called when disabling/enabling the plugin/feature, not intended to be called directly. To enable or disable a\n     * plugin/feature, see {@link #property-disabled}.\n     *\n     * By default removes the cls of the plugin from its client. Override in subclasses to take any other actions necessary.\n     * @category Misc\n     */\n    doDisable(disable) {\n        const\n            me = this,\n            { constructor } = me,\n            cls = 'featureClass' in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`;\n        // Some features do not use a cls\n        if (cls) {\n            // _element to not flush composable\n            me.client?._element?.classList[disable ? 'remove' : 'add'](cls);\n        }\n        if (!me.isConfiguring) {\n            if (disable) {\n                /**\n                 * Fired when the plugin/feature is disabled.\n                 * @event disable\n                 * @param {Core.mixin.InstancePlugin} source\n                 */\n                me.trigger('disable');\n            }\n            else {\n                /**\n                 * Fired when the plugin/feature is enabled.\n                 * @event enable\n                 * @param {Core.mixin.InstancePlugin} source\n                 */\n                me.trigger('enable');\n            }\n        }\n    }\n    updateDisabled(disabled) {\n        this.doDisable(disabled);\n    }\n    throwOverrideIsMissing(data) {\n        throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);\n    }\n    // Convenience method to read the rootElement from the owner widget\n    get rootElement() {\n        return this.client.rootElement;\n    }\n}\nInstancePlugin._$name = 'InstancePlugin';", "import Base from '../Base.js';\nimport InstancePlugin from './InstancePlugin.js';\n/**\n * @module Core/mixin/Pluggable\n */\n/**\n * Enables using plugins for a class by specifying property plugins as an array of plugin classes. If only a single plugin\n * is used, just give the plugin class instead of an array. This class isn't required for using plugins, just makes it\n * easier. Without mixin you can otherwise use `InstancePlugin.initPlugins(this, PluginClass)`.\n *\n * @example\n * new Store({\n *   plugins: [PluginClass, ...]\n * });\n *\n * @mixin\n */\nexport default Target => class Pluggable extends (Target || Base) {\n    static get $name() {\n        return 'Pluggable';\n    }\n    /**\n     * Specify plugins (an array of classes) in config\n     * @config {Function[]} plugins\n     * @category Misc\n     */\n    /**\n     * Map of applied plugins\n     * @property {Object<String,Core.mixin.InstancePlugin>}\n     * @readonly\n     * @category Misc\n     */\n    get plugins() {\n        if (!this._plugins) {\n            this._plugins = {};\n        }\n        return this._plugins;\n    }\n    set plugins(plugins) {\n        if (plugins) {\n            if (!Array.isArray(plugins)) plugins = [plugins];\n            InstancePlugin.initPlugins(this, ...plugins);\n        }\n        this.initPlugins();\n    }\n    /**\n     * Template method which may be implemented in subclasses to initialize any plugins.\n     * This method is empty in the `Pluggable` base class.\n     * @internal\n     */\n    initPlugins() {\n    }\n    /**\n     * Adds plugins to an instance.\n     * @param {Function[]} plugins The plugins to add\n     * @category Misc\n     */\n    addPlugins(...plugins) {\n        InstancePlugin.initPlugins(this, ...plugins);\n    }\n    /**\n     * Checks if instance has plugin.\n     * @param {String|Function} pluginClassOrName Plugin or name to check for\n     * @returns {Boolean}\n     * @category Misc\n     */\n    hasPlugin(pluginClassOrName) {\n        return this.getPlugin(pluginClassOrName) != null;\n    }\n    /**\n     * Get a plugin instance.\n     * @param {String|Function} pluginClassOrName\n     * @returns {Core.mixin.InstancePlugin}\n     * @category Misc\n     */\n    getPlugin(pluginClassOrName) {\n        if (typeof pluginClassOrName === 'function') {\n            pluginClassOrName = pluginClassOrName.$$name;\n        }\n        return this.plugins?.[pluginClassOrName];\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../Base.js';\nimport VersionHelper from '../helper/VersionHelper.js';\nimport BrowserHelper from '../helper/BrowserHelper.js';\nconst { defineProperty } = Reflect;\nlet performance;\nif (BrowserHelper.isBrowserEnv) {\n    performance = globalThis.performance;\n}\nelse {\n    performance = {\n        now() {\n            return new Date().getTime();\n        }\n    };\n}\n/**\n * @module Core/mixin/Delayable\n */\n// Global timeout collections for tests\nlet globalDelays = null;\nif (VersionHelper.isTestEnv) {\n    const bryntum = globalThis.bryntum || (globalThis.bryntum = {});\n    globalDelays = bryntum.globalDelays = {\n        timeouts        : new Map(),\n        intervals       : new Map(),\n        animationFrames : new Map(),\n        idleCallbacks   : new Map(),\n        isEmpty(includeIntervals = false) {\n            return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;\n        },\n        /**\n         * Returns filtered delays array\n         * @param {Object} options\n         * @param {String[]} [options.ignoreTimeouts] array of delays names to ignore\n         * @param {Number} [options.maxDelay] maximum delay in milliseconds. Timeouts with bigger delay will be filtered out\n         * @param {Boolean} [options.includeIntervals] include intervals\n         * @returns {Object[]} array of filtered delays\n         * @internal\n         */\n        getFiltered({ ignoreTimeouts = [], maxDelay = 5000, includeIntervals = false }) {\n            const\n                result = [],\n                scopes = ['timeouts', 'animationFrames', 'idleCallbacks'];\n            if (includeIntervals) {\n                scopes.push('intervals');\n            }\n            // Filter delays\n            for (const scope of scopes) {\n                const map = globalDelays[scope];\n                for (const [, entry] of map.entries()) {\n                    if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {\n                        result.push(entry);\n                    }\n                }\n            }\n            return result;\n        }\n    };\n}\nconst\n    /**\n     * Creates and returns a function that will call the user-supplied `fn`.\n     *\n     * @param {Core.mixin.Delayable} me\n     * @param {Function} fn The user function to call when the timer fires.\n     * @param {Function} wrapFn The function the user will call to start the timer.\n     * @param {Object} options The invoke options.\n     * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.\n     * @param {Object} [options.thisObj] The `this` reference for `fn`.\n     * @returns {Function}\n     * @private\n     */\n    makeInvoker = (me, fn, wrapFn, options) => {\n        const\n            named      = typeof fn === 'string',\n            appendArgs = options?.appendArgs || [],\n            // The invoker fn is intended to be wired directly to native setTimeout/requestAnimationFrame/etc. and so\n            // it does not receive any arguments worth passing on to the user's fn. Those come from the original call\n            // to the wrapFn.\n            invoker    = () => {\n                wrapFn.timerId = null;\n                wrapFn.lastCallTime = performance.now();\n                // Grab args now and null the stored args out (to avoid leaks):\n                const args = wrapFn.args;\n                wrapFn.args = null;\n                if (named) {\n                    me[fn](...args, ...appendArgs);\n                }\n                else {\n                    fn.call(me, ...args, ...appendArgs);\n                }\n                wrapFn.called = true;\n                ++wrapFn.calls;\n            };\n        if (options) {\n            me = options.thisObj || me;\n        }\n        // We put most everything as properties on the wrapFn so that it can all be inspected in the debugger (unlike\n        // closure variables) and expected in tests.\n        wrapFn.lastCallTime = -9e9;  // performance.now() = 0 at start...\n        wrapFn.calls = 0;\n        wrapFn.invoker = invoker;\n        invoker.wrapFn = wrapFn;\n        return invoker;\n    },\n    /**\n     * Decorates the supported `wrapFn` with additional methods and an `isPending` readonly\n     * property. These decorations are available to user code to help manage the scheduling\n     * behavior of the buffered function.\n     *\n     * @param {Core.mixin.Delayable} me\n     * @param {Function} wrapFn The function the user will call to start the timer.\n     * @param {String} cancelFn The name of the function that will cancel a timer.\n     * @returns {Function} The `wrapFn` is returned.\n     * @private\n     */\n    decorateWrapFn = (me, wrapFn, cancelFn = 'clearTimeout') => {\n        wrapFn.cancel = () => {\n            if (wrapFn.isPending) {\n                me[cancelFn](wrapFn.timerId);\n                // avoid leaks and cleanup:\n                wrapFn.args = wrapFn.timerId = null;\n            }\n        };\n        wrapFn.flush = () => {\n            if (wrapFn.isPending) {\n                me[cancelFn](wrapFn.timerId);\n                wrapFn.timerId = null;\n                // we don't call cancel() since it also sets args=null\n                wrapFn.invoker();\n            }\n        };\n        wrapFn.now = (...args) => {\n            wrapFn.cancel();\n            wrapFn.args = args;\n            wrapFn.invoker();\n        };\n        wrapFn.resume = all => {\n            const n = wrapFn.suspended;\n            wrapFn.suspended = (all || n < 1) ? 0 : (n - 1);\n        };\n        wrapFn.suspend = () => {\n            ++wrapFn.suspended;\n        };\n        wrapFn.immediate = false;\n        wrapFn.suspended = 0;\n        wrapFn.timerId = null;\n        defineProperty(wrapFn, 'isPending', {\n            get() {\n                return wrapFn.timerId !== null;\n            }\n        });\n        return wrapFn;\n    };\n/**\n * Configuration options available when defining a delayable function.\n *\n * @typedef {Object} DelayableConfig\n * @property {'buffer'|'raf'|'idle'|'throttle'} type Type of delay to use. `raf` is short for `requestAnimationFrame`,\n * 'idle' for `requestIdleCallback` (not supported in Safari)\n * @property {Number} [delay] Number of milliseconds to wait before (buffer) or after (throttle) calling the underlying\n * method. A value of 0 is equivalent to setting `immediate: true`.\n * @property {Boolean} [immediate] Set to `true` to call immediately (effectively disabling the buffer/throttle)\n * @property {Boolean} [cancelOutstanding] Set to `true` to cancel any pending animation frame requests and\n * schedule a new one on each call.\n */\n/**\n * Tracks setTimeout, setInterval and requestAnimationFrame calls and clears them on destroy.\n *\n * @example\n * someClass.setTimeout(() => console.log('hi'), 200);\n * someClass.setInterval(() => console.log('annoy'), 100);\n * // can also use named timeouts for easier tracking\n * someClass.setTimeout(() => console.log('named'), 300, 'named');\n * someClass.clearTimeout('named');\n *\n * @mixin\n */\nexport default Target => class Delayable extends (Target || Base) {\n    static get $name() {\n        return 'Delayable';\n    }\n    static get declarable() {\n        return [\n            /**\n             * This class property returns an object that specifies methods to wrap with configurable timer behaviors.\n             *\n             * It is used like so:\n             * ```javascript\n             *  class Foo extends Base.mixin(Delayable) {\n             *      static get delayable() {\n             *          return {\n             *              expensiveMethod : 500\n             *          };\n             *      }\n             *\n             *      expensiveMethod() {\n             *          this.things();\n             *          this.moreThings();\n             *          this.evenMoreThings();\n             *      }\n             *  }\n             * ```\n             * With the above in place, consider:\n             * ```javascript\n             *  let instance = new Foo();\n             *\n             *  instance.expensiveMethod();\n             * ```\n             * Instead of the above code immediately calling the `expensiveMethod()`, it will start a timer that will\n             * invoke the method 500ms later. Because `expensiveMethod()` is an instance method, each instance of `Foo`\n             * will have its own timer.\n             *\n             * NOTE: Only instance methods are currently supported (i.e., only non-`static` methods).\n             *\n             * #### Options\n             * The value of each key configures how the method will be scheduled. If the value is a number, it is\n             * promoted to a config object of `type='buffer'` as in the following:\n             * ```javascript\n             *  class Foo extends Base.mixin(Delayable) {\n             *      static get delayable() {\n             *          return {\n             *              expensiveMethod : {\n             *                  type  : 'buffer',\n             *                  delay : 500\n             *              }\n             *          };\n             *      }\n             *  }\n             * ```\n             * The `type` property of the config object must be one of three values. Other options can be provided\n             * depending on the `type`:\n             *\n             *  - `buffer`<br>\n             *    Other options:\n             *     - `delay` (Number) : The number of milliseconds to wait before calling the underlying method. A\n             *       value of 0 is equivalent to setting `immediate: true`.\n             *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the buffer).\n             *  - `raf` (short for \"request animation frame\")<br>\n             *  - `idle` (short for \"request idle callback\") __Not available on Safari__ <br>\n             *    Other options:\n             *     - `cancelOutstanding` (Boolean) : Set to `true` to cancel any pending animation frame requests and\n             *       schedule a new one on each call.\n             *     - `immediate` (Boolean) : Set to `true` to call immediately.\n             *  - `throttle`<br>\n             *    Other options:\n             *     - `delay` (Number) : The number of milliseconds to wait after each execution before another\n             *       execution takes place. A value of 0 is equivalent to setting `immediate: true`.\n             *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the throttle).\n             *\n             * While `immediate: true` can be specified at the class level, it is more typical to set it on the\n             * instance's method as described below.\n             *\n             * #### Delayable Method API\n             * Delayable methods have a consistent API to manage their scheduling. This API is added to the methods\n             * themselves.\n             *\n             * For example:\n             * ```javascript\n             *  let instance = new Foo();\n             *\n             *  instance.expensiveMethod();         // schedule a call in 500ms\n             *  instance.expensiveMethod.isPending; // true\n             *  instance.expensiveMethod.cancel();\n             *  instance.expensiveMethod.flush();\n             *  instance.expensiveMethod.now();\n             *\n             *  instance.expensiveMethod.delay = 10;\n             *  instance.expensiveMethod();         // schedule a call in 10ms\n             * ```\n             *\n             * ##### `isPending` (Boolean, readonly)\n             * This boolean property will be `true` if a call has been scheduled, and false otherwise.\n             *\n             * ##### `cancel()`\n             * Cancels a pending call if one has been scheduled. Otherwise this method does nothing.\n             *\n             * ##### `flush()`\n             * Cancels the timer and causes the pending call to execute immediately. If there is no pending call, this\n             * method does nothing.\n             *\n             * ##### `now()`\n             * Cancels the timer (if one is pending) and executes the method immediately. If there is no pending call,\n             * this method will still call the underlying method.\n             *\n             * @static\n             * @member {Object<String,'raf'|Number|DelayableConfig>} delayable\n             * @internal\n             */\n            'delayable'\n        ];\n    }\n    doDestroy() {\n        const me = this;\n        // Normally one would expect this call at the end of this method... but in this case we need to run cleanup\n        // of this stuff after config nullification since those can trigger delayable method calls.\n        super.doDestroy();\n        if (me.timeoutIds) {\n            me.timeoutIds.forEach((fn, id) => {\n                if (typeof fn === 'function') {\n                    fn();\n                }\n                clearTimeout(id);\n                globalDelays?.timeouts.delete(id);\n            });\n            me.timeoutIds = null;\n        }\n        if (me.timeoutMap) {\n            me.timeoutMap.forEach((name, id) => clearTimeout(id));\n            me.timeoutMap = null;\n        }\n        if (me.intervalIds) {\n            me.intervalIds.forEach(id => {\n                clearInterval(id);\n                globalDelays?.intervals.delete(id);\n            });\n            me.intervalIds = null;\n        }\n        if (me.animationFrameIds) {\n            me.animationFrameIds.forEach(id => {\n                cancelAnimationFrame(id);\n                globalDelays?.animationFrames.delete(id);\n            });\n            me.animationFrameIds = null;\n        }\n        if (me.idleCallbackIds) {\n            me.idleCallbackIds.forEach(id => {\n                cancelIdleCallback(id);\n                globalDelays?.idleCallbacks.delete(id);\n            });\n            me.idleCallbackIds = null;\n        }\n    }\n    /**\n     * Check if a named timeout is active\n     * @param name\n     * @internal\n     */\n    hasTimeout(name) {\n        return Boolean(this.timeoutMap?.has(name));\n    }\n    /**\n     * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will\n     * be used to store the timeout id.\n     * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.\n     * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.\n     * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.\n     * @param {Object[]} timeoutSpec.args The arguments to pass.\n     * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.\n     * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.\n     * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.\n     * @returns {Number}\n     * @internal\n     */\n    setTimeout({ fn, delay, name, runOnDestroy, cancelOutstanding, args }) {\n        if (arguments.length > 1 || typeof arguments[0] === 'function') {\n            [fn, delay, name, runOnDestroy] = arguments;\n        }\n        if (typeof fn === 'string') {\n            name = fn;\n        }\n        else if (!name) {\n            name = fn.name || fn;\n        }\n        if (cancelOutstanding) {\n            this.clearTimeout(name);\n        }\n        const\n            me         = this,\n            timeoutIds = me.timeoutIds || (me.timeoutIds = new Map()),\n            timeoutMap = me.timeoutMap || (me.timeoutMap = new Map()),\n            timeoutId  = setTimeout(() => {\n                if (typeof fn === 'string') {\n                    fn = me[name];\n                }\n                // Cleanup before invocation in case fn throws\n                timeoutIds?.delete(timeoutId);\n                timeoutMap?.delete(name);\n                globalDelays?.timeouts.delete(timeoutId);\n                fn.apply(me, args);\n            }, delay);\n        timeoutIds.set(timeoutId, runOnDestroy ? fn : true);\n        // Commented out code is helpful when debugging timeouts in tests\n        globalDelays?.timeouts.set(timeoutId, { fn, delay, name/*, stack : new Error().stack*/ });\n        if (name) {\n            timeoutMap.set(name, timeoutId);\n        }\n        return timeoutId;\n    }\n    /**\n     * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified\n     * a name to setTimeout())\n     * property to null.\n     * @param {Number|String} idOrName timeout id or name\n     * @internal\n     */\n    clearTimeout(idOrName) {\n        let id = idOrName;\n        if (typeof id === 'string') {\n            if (this.timeoutMap) {\n                id = this.timeoutMap.get(idOrName);\n                this.timeoutMap.delete(idOrName);\n            }\n            else {\n                return;\n            }\n        }\n        clearTimeout(id);\n        this.timeoutIds?.delete(id);\n        globalDelays?.timeouts.delete(id);\n    }\n    /**\n     * clearInterval wrapper\n     * @param {Number} id\n     * @internal\n     */\n    clearInterval(id) {\n        clearInterval(id);\n        this.intervalIds?.delete(id);\n        globalDelays?.intervals.delete(id);\n    }\n    /**\n     * Same as native setInterval, but will be cleared automatically on destroy\n     * @param {Function} fn callback method\n     * @param {Number} delay delay in milliseconds\n     * @param {String} name delay name for debugging\n     * @returns {Number}\n     * @internal\n     */\n    setInterval(fn, delay, name) {\n        const intervalId = setInterval(fn, delay);\n        (this.intervalIds || (this.intervalIds = new Set())).add(intervalId);\n        globalDelays?.intervals.set(intervalId, { fn, delay, name });\n        return intervalId;\n    }\n    /**\n     * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.\n     * @param {Function} fn\n     * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.\n     * @param {Object} [thisObj] `this` reference for the function.\n     * @returns {Number}\n     * @internal\n     */\n    requestAnimationFrame(fn, extraArgs = [], thisObj = this) {\n        const\n            animationFrameIds = this.animationFrameIds || (this.animationFrameIds = new Set()),\n            frameId           = requestAnimationFrame(() => {\n                globalDelays?.animationFrames.delete(frameId);\n                // [dongriffin 2022-01-19] It was observed that we can still be called even though we issued the\n                // cancelAnimationFrame call. Since delete() returns true if our frameId was present and is now\n                // removed, we can tell that we haven't been cancelled before we call our fn:\n                animationFrameIds.delete(frameId) && fn.apply(thisObj, extraArgs);\n            });\n        animationFrameIds.add(frameId);\n        globalDelays?.animationFrames.set(frameId, { fn, extraArgs, thisObj });\n        return frameId;\n    }\n    /**\n     * Relays to native requestIdleCallback and adds to tracking to have call automatically canceled on destroy.\n     * @param {Function} fn\n     * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.\n     * @param {Object} [thisObj] `this` reference for the function.\n     * @returns {Number}\n     * @internal\n     */\n    requestIdleCallback(fn, extraArgs = [], thisObj = this) {\n        const\n            idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = new Set()),\n            frameId           = requestIdleCallback(() => {\n                globalDelays?.idleCallbacks.delete(frameId);\n                // Since delete() returns true if our frameId was present and is now\n                // removed, we can tell that we haven't been cancelled before we call our fn:\n                idleCallbackIds.delete(frameId) && fn.apply(thisObj, extraArgs);\n            });\n        idleCallbackIds.add(frameId);\n        globalDelays?.idleCallbacks.set(frameId, { fn, extraArgs, thisObj });\n        return frameId;\n    }\n    /**\n     * Creates a function which will execute once, on the next animation frame. However many time it is\n     * called in one event run, it will only be scheduled to run once.\n     * @param {Function|String} fn The function to call, or name of function in this object to call.\n     * @param {Object[]} [args] The argument list to append to those passed to the function.\n     * @param {Object} [thisObj] `this` reference for the function.\n     * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.\n     * @internal\n     */\n    createOnFrame(fn, args = [], thisObj = this, cancelOutstanding) {\n        let rafId;\n        const result = (...callArgs) => {\n            // Cancel if outstanding if requested\n            if (rafId != null && cancelOutstanding) {\n                this.cancelAnimationFrame(rafId);\n                rafId = null;\n            }\n            if (rafId == null) {\n                rafId = this.requestAnimationFrame(() => {\n                    if (typeof fn === 'string') {\n                        fn = thisObj[fn];\n                    }\n                    rafId = null;\n                    callArgs.push(...args);\n                    fn.apply(thisObj, callArgs);\n                });\n            }\n        };\n        result.cancel = () => this.cancelAnimationFrame(rafId);\n        return result;\n    }\n    /**\n     * Relays to native cancelAnimationFrame and removes from tracking.\n     * @param {Number} handle\n     * @internal\n     */\n    cancelAnimationFrame(handle) {\n        cancelAnimationFrame(handle);\n        this.animationFrameIds?.delete(handle);\n        globalDelays?.animationFrames.delete(handle);\n    }\n    /**\n     * Relays to native cancelIdleCallback and removes from tracking.\n     * @param {Number} handle\n     * @internal\n     */\n    cancelIdleCallback(handle) {\n        cancelIdleCallback(handle);\n        this.idleCallbackIds?.delete(handle);\n        globalDelays?.idleCallbacks.delete(handle);\n    }\n    async nextAnimationFrame() {\n        return new Promise(resolve => this.requestAnimationFrame(resolve));\n    }\n    /**\n     * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper\n     * resets delay.\n     * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`\n     * instance (or `options.thisObj` instead, if provided).\n     * @param {Object|Number} options The delay in milliseconds or an options object.\n     * @param {Number} options.delay The delay in milliseconds.\n     * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.\n     * @param {Object} [options.thisObj] The `this` reference for the function.\n     * @returns {Function} Wrapped function to call.\n     * @internal\n     */\n    buffer(fn, options) {\n        let delay = options;\n        if (options && typeof options !== 'number') {  // if (config object)\n            delay = options.delay;\n        }\n        else {\n            options = null;\n        }\n        const\n            bufferWrapFn = (...params) => {\n                if (bufferWrapFn.suspended) {\n                    return;\n                }\n                const { delay } = bufferWrapFn;\n                bufferWrapFn.cancel();\n                bufferWrapFn.called = false;\n                bufferWrapFn.args = params;\n                // If delay=0, the buffer has been disabled so always call immediately.\n                if (bufferWrapFn.immediate || !delay) {\n                    invoker();\n                }\n                else {\n                    bufferWrapFn.timerId = this.setTimeout(invoker, delay);\n                }\n            },\n            invoker = makeInvoker(this, fn, bufferWrapFn, options);\n        bufferWrapFn.delay = delay;\n        return decorateWrapFn(this, bufferWrapFn);\n    }\n    /**\n     * Returns a function that when called will schedule a call to `fn` on the next animation frame.\n     *\n     * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`\n     * instance (or `options.thisObj` instead, if provided).\n     * @param {Boolean|Object} [options] An options object or the `cancelOutstanding` boolean property of it.\n     * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any pending animation frame requests and\n     * schedule a new one on each call to the returned function.\n     * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.\n     * @param {Object} [options.thisObj] The `this` reference for the function.\n     * @returns {Function}\n     * @internal\n     */\n    raf(fn, options) {\n        // NOTE: This method is only intended for use with `delayable`. It has a signature that is compatible\n        // with `buffer()` and `throttle()`. The name is 'raf' to make the following aesthetically pleasing:\n        //\n        //  class Foo extends Delayable() {\n        //      static get delayable() {\n        //          return {\n        //              bar : 'raf'\n        //          };\n        //      }\n        //  }\n        let cancelOutstanding = options;\n        if (options && typeof options !== 'boolean') {  // if (config object)\n            cancelOutstanding = options.cancelOutstanding;\n        }\n        else {\n            options = null;\n        }\n        const\n            rafWrapFn = (...params) => {\n                if (rafWrapFn.suspended) {\n                    return;\n                }\n                // Reschedule the frame on each call if requested\n                if (rafWrapFn.cancelOutstanding) {\n                    rafWrapFn.cancel();\n                }\n                rafWrapFn.called = false;\n                rafWrapFn.args = params;\n                if (rafWrapFn.immediate) {\n                    invoker();\n                }\n                else if (!rafWrapFn.isPending) {\n                    rafWrapFn.timerId = this.requestAnimationFrame(invoker);\n                }\n            },\n            invoker = makeInvoker(this, fn, rafWrapFn, options);\n        rafWrapFn.cancelOutstanding = cancelOutstanding;\n        return decorateWrapFn(this, rafWrapFn, 'cancelAnimationFrame');\n    }\n    idle(fn, options) {\n        let cancelOutstanding = options;\n        if (options && typeof options !== 'boolean') {  // if (config object)\n            cancelOutstanding = options.cancelOutstanding;\n        }\n        else {\n            options = null;\n        }\n        const\n            idleWrapFn = (...params) => {\n                if (idleWrapFn.suspended) {\n                    return;\n                }\n                // Reschedule the frame on each call if requested\n                if (idleWrapFn.cancelOutstanding) {\n                    idleWrapFn.cancel();\n                }\n                idleWrapFn.called = false;\n                idleWrapFn.args = params;\n                if (idleWrapFn.immediate) {\n                    invoker();\n                }\n                else if (!idleWrapFn.isPending) {\n                    idleWrapFn.timerId = this.requestIdleCallback(invoker);\n                }\n            },\n            invoker = makeInvoker(this, fn, idleWrapFn, options);\n        idleWrapFn.cancelOutstanding = cancelOutstanding;\n        // If the timer is still there in 100ms, then invoke it.\n        this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);\n        return decorateWrapFn(this, idleWrapFn, 'cancelIdleCallback');\n    }\n    /**\n     * Create a \"debounced\" function which will call on the \"leading edge\" of a timer period.\n     * When first invoked will call immediately, but invocations after that inside its buffer\n     * period will be rejected, and *one* invocation will be made after the buffer period has expired.\n     *\n     * This is useful for responding immediately to a first mousemove, but from then on, only\n     * calling the action function on a regular timer while the mouse continues to move.\n     *\n     * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`\n     * instance (or `options.thisObj` instead, if provided).\n     * @param {Number|Object} options The milliseconds to wait after each execution before another execution takes place\n     * or a object containing options.\n     * @param {Object} [options.thisObj] `this` reference for the function.\n     * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.\n     * @param {Function|String} [options.throttled] A function to call when the invocation is delayed due to buffer\n     * time not having expired. If this is a string, it is looked up as a method on `this` instance (or `options.thisObj`\n     * instead, if provided). When called, the same arguments are passed as would have been passed to `fn`, including\n     * any `options.appendArgs`.\n     * @internal\n     */\n    throttle(fn, options) {\n        let delay = options,\n            throttled;\n        if (options && typeof options !== 'number') {  // if (config object)\n            delay = options.delay;\n            throttled = options.throttled;\n        }\n        else {\n            options = null;\n        }\n        const\n            me = this,\n            throttleWrapFn = (...args) => {\n                if (throttleWrapFn.suspended) {\n                    return;\n                }\n                const\n                    { delay } = throttleWrapFn,\n                    elapsed = performance.now() - throttleWrapFn.lastCallTime;\n                throttleWrapFn.args = args;\n                // If it's been more then the delay period since we invoked, we can call it now.\n                // Setting delay=0 effectively disables the throttle (which is the goal)\n                if (throttleWrapFn.immediate || elapsed >= delay) {\n                    me.clearTimeout(throttleWrapFn.timerId);\n                    invoker();\n                }\n                else {\n                    // Kick off a timer for the requested period.\n                    if (!throttleWrapFn.isPending) {\n                        throttleWrapFn.timerId = me.setTimeout(invoker, delay - elapsed);\n                        throttleWrapFn.called = false;\n                    }\n                    if (throttled) {\n                        // Args have to be stored on the wrapFn for the invoker to pick them up:\n                        throttled.wrapFn.args = args;\n                        throttled();\n                    }\n                }\n            },\n            invoker = makeInvoker(me, fn, throttleWrapFn, options);\n        throttleWrapFn.delay = delay;\n        if (throttled) {\n            // Make an invoker for this callback to handle thisObj and typeof=string etc (pass a dud wrapFn):\n            throttled = makeInvoker(me, throttled, () => {}, options);\n        }\n        return decorateWrapFn(me, throttleWrapFn);\n    }\n    static setupDelayable(cls) {\n        cls.setupDelayableMethods(cls.delayable);\n    }\n    /**\n     * This method initializes the `delayable` methods on this class.\n     * @param {Object} delayable The `delayable` property.\n     * @param {Function} [cls] This parameter will be used internally to process static methods.\n     * @private\n     */\n    static setupDelayableMethods(delayable, cls = null) {\n        const\n            me = this,\n            statics = delayable.static,\n            target = cls || me.prototype;\n        if (statics) {\n            delete delayable.static;\n        }\n        for (const name in delayable) {\n            let options = delayable[name];\n            const\n                implName = name + 'Now',\n                type = typeof options;\n            if (!target[implName]) {\n                // Only move foo() -> fooNow() if a base class hasn't done so already\n                target[implName] = target[name];\n            }\n            if (type === 'number') {\n                options = {\n                    type  : 'buffer',\n                    delay : options\n                };\n            }\n            else if (type === 'string') {\n                options = {\n                    type : options\n                };\n            }\n            // For instance methods, we place a getter on the prototype. When the method is first accessed from the\n            // prototype, we create an instance-specific version by calling this.buffer()/throttle() (based on the type\n            // desired) and set that as the instance-level property.\n            defineProperty(target, name, {\n                get() {\n                    const value = this[options.type]((...params) => {\n                        this[implName](...params);\n                    }, options);\n                    defineProperty(this, name, { value });\n                    return value;\n                }\n            });\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "/**\n * @module Core/state/StateStorage\n */\n/**\n * Base class representing interface used by the {@link Core.state.StateProvider} to actually store the state data.\n * This class is not intended to be used directly.\n *\n * This class has an interface similar to the [Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Storage).\n */\nexport default class StateStorage {\n    /**\n     * Returns an object with all stored keys and their values as its properties\n     * @member {Object}\n     */\n    get data() {\n        return Object.create(null);\n    }\n    /**\n     * Returns the stored keys as set by {@link #function-setItem}\n     * @member {String[]}\n     */\n    get keys() {\n        return [];\n    }\n    /**\n     * Remove all stored keys\n     */\n    clear() {}\n    /**\n     * Returns key value as set by {@link #function-setItem}\n     * @param {String} key\n     * @returns {*}\n     */\n    getItem(key) {\n        return null;\n    }\n    /**\n     * Removes the specified key\n     * @param {String} key\n     */\n    removeItem(key) {}\n    /**\n     * Sets the specified key to the given value\n     * @param {String} key\n     * @param {*} value The item value\n     */\n    setItem(key, value) {}\n}\nStateStorage._$name = 'StateStorage';", "import Base from '../Base.js';\nimport Delayable from '../mixin/Delayable.js';\nimport Events from '../mixin/Events.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport StateStorage from './StateStorage.js';\n/**\n * @module Core/state/StateProvider\n */\nclass Local extends StateStorage {\n    constructor(stateProvider) {\n        super();\n        this.prefix = stateProvider.prefix || '';\n    }\n    get isLocal() {\n        return true;\n    }\n    get data() {\n        const\n            data = empty(),\n            keys = this.keys;\n        for (const key of keys) {\n            data[key] = this.getItem(key);\n        }\n        return data;\n    }\n    get keys() {\n        return getKeys(this.prefix, this.prefix.length);\n    }\n    clear() {\n        // It's important that we only clear our own StateProvider's keys, not all of localStorage. We get the\n        // full keys not the suffixes since we're just going to call removeItem() with them...\n        const keys = getKeys(this.prefix);\n        for (const key of keys) {\n            localStorage.removeItem(key);\n        }\n    }\n    getItem(key) {\n        const value = localStorage.getItem(this.prefix + key);\n        // We handle the JSON translation at this layer because the Memory storage does not do any such pickling\n        // of data but localStorage only handles strings\n        return (value === null) ? value : JSON.parse(value);\n    }\n    removeItem(key) {\n        return localStorage.removeItem(this.prefix + key);\n    }\n    setItem(key, value) {\n        return localStorage.setItem(this.prefix + key, JSON.stringify(value));\n    }\n}\nclass Memory extends StateStorage {\n    constructor() {\n        super();\n        this.clear();\n    }\n    get isMemory() {\n        return true;\n    }\n    get data() {\n        return ObjectHelper.clone(this._data);\n    }\n    get keys() {\n        return Object.keys(this._data);\n    }\n    clear() {\n        this._data = empty();\n    }\n    getItem(key) {\n        return (key in this._data) ? this._data[key] : null;\n    }\n    removeItem(key) {\n        delete this._data[key];\n    }\n    setItem(key, value) {\n        this._data[key] = value;\n    }\n}\nconst\n    empty = () => Object.create(null),\n    getKeys = (prefix, pos = 0) => {\n        const\n            keys = [],\n            count = localStorage.length;\n        for (let key, i = 0; i < count; ++i) {\n            key = localStorage.key(i);\n            key.startsWith(prefix) && keys.push(key.slice(pos));\n        }\n        return keys;\n    },\n    nullStorage = new StateStorage(),\n    storageTypes = {\n        local  : Local,\n        memory : Memory\n    };\n/**\n * Instances of this class are used to manage data storage for objects that use the {@link Core.mixin.State} mixin, i.e.\n * stateful components. When such components change their {@link Core.mixin.State#config-stateful} properties, they\n * notify the associated {@link Core.mixin.State#config-stateProvider}, which will save the changes after a short\n * delay (to allow multiple changes to coalesce into a single save operation).\n *\n * There are two (2) built-in types of storage supported by `StateProvider`:\n *\n *  - `local` : Stores data in the browser's `localStorage`. Because of this, all `StateProvider` instances share their\n *    state data if they have the same {@link #config-prefix}.\n *  - `memory` : Stores data in the provider's memory. Each instance has its own storage. This is typically used when\n *    the state data is saved to a backend server.\n *\n * ## Using `local` Storage\n *\n * The global `StateProvider` is typically to use `localStorage` for the page or application like so:\n *\n * ```javascript\n *  StateProvider.setup('local');\n * ```\n *\n * With this provider in place, all {@link Core.mixin.State stateful components} will save their\n * {@link Core.mixin.State#property-state} to this provider by default.\n *\n * This is the most typical, and recommended, strategy for proving data to stateful components. This approach allows\n * various widgets on the page to simply declare their {@link Core.mixin.State#config-stateId} to participate in the\n * saving and restoring of application state.\n *\n * Because this storage type uses `localStorage`, the `StateProvider` applies a string prefix to isolate its data from\n * other users of `localStorage`. The default prefix is `'bryntum-state:'`, but this can be configured to a different\n * value. This could be desired, for example, to isolate state data from multiple pages or for version changes.\n *\n * ```javascript\n *  StateProvider.setup({\n *      storage : 'local',\n *      prefix  : 'myApp-v1:'\n *  });\n * ```\n *\n * ## Using `memory` Storage\n *\n * In some applications it may be desirable to save state to a server and restore it on other devices for the user.\n * Because state data is consumed synchronously, and server I/O is asynchronous, the `StateProvider` can be configured\n * to use `'memory'` storage and the actual state data can be loaded/saved by the application.\n *\n * Two factors are important to consider before deciding to save application state on the server (beyond the async\n * adaptation):\n *\n * - State properties are often more of a reflection of the user's device than they are application preferences\n *   and, therefore, may not apply well on other devices.\n * - Potentially undesired application state will not be cleared by clearing local browser user data (a common\n *   troubleshooting strategy) and will follow the user to other browsers (another common troubleshooting technique).\n *\n * The use this type of storage, the global `StateProvider` is configured like so:\n *\n * ```javascript\n * StateProvider.setup('memory');\n * ```\n *\n * In this scenario, application code would download the user's state and use {@link #property-data} to populate\n * the {@link #property-instance-static StateProvider.instance}. In this case, the {@link #event-save} event is used\n * to save the data back to the server when it changes.\n *\n * See [state](https://bryntum.com/products/grid/examples/state/) demo for a usage example.\n * @mixes Core/mixin/Events\n */\nexport default class StateProvider extends Base.mixin(Delayable, Events) {\n    static get $name() {\n        return 'StateProvider';\n    }\n    static get configurable() {\n        return {\n            /**\n             * The key prefix applied when using the `'local'` {@link #config-storage} type.\n             * @config {String}\n             * @default\n             */\n            prefix : 'bryntum-state:',\n            /**\n             * Storage instance\n             * @member {Core.state.StateStorage} storage\n             */\n            /**\n             * One of the following storage types:\n             *  - `local` : Stores data in the browser's `localStorage` using the {@link #config-prefix}.\n             *  - `memory` : Stores data in the provider's memory.\n             *\n             * @config {'local'|'memory'|Core.state.StateStorage}\n             * @default\n             */\n            storage : 'local'\n        };\n    }\n    static get delayable() {\n        /*\n            The StateProvider uses a delayed write to save stateful components in batches. To illustrate, consider the\n            \"collapsed\" config for a Panel that has been marked as \"stateful\":\n                App                         Stateful                      State\n                Code                        Component                    Provider\n                  :                             :                           :\n                  | .collapsed=true             :                           :\n                  |---------------------------->|                           :\n                  |         onConfigChange() +--|                           :\n                  |                          |  |                           :\n                  |                          +->|                           :\n                  |              saveState() +--|                           :\n                  |                          |  |                           :\n                  |                          +->| saveStateful()            :\n                  |                             |-------------------------->|\n                  |                             |                           | pendingSaves.push()\n                  |                             |                           |----+ writeStatefuls()\n                  | .collapsed=true             |<..........................:    :\n                  |<............................:                           :    :  (maybe other changes)\n                  :                             :                           :    :\n                  :                             :                           |<---+ (50 ms later)\n                  :                             :                           | writeStatefuls()\n                  :                             :       saveState({         |\n                  :                             :         immediate:true})  | <---------------+\n                  :                             |<--------------------------|                  \\\n                  :                             | setValue()                |                   \\\n                  :                             |-------------------------->|                    \\\n                  :                             |                           | .trigger('set')     ) one or more of these\n                  :                             |<..........................|                    /\n                  :                             |              saveState()  |                   /\n                  :                             :..........................>|                  /\n                  :                             :                           | <---------------+\n                  :                             :                           |\n                  :                             :                           | .trigger('save')\n                  :                             :                           |\n                  :                             :                           :....> writeStatefuls()\n                  :                             :                           :\n        */\n        return {\n            writeStatefuls : 50\n        };\n    }\n    /**\n     * The default {@link Core.mixin.State#config-stateProvider} for stateful objects.\n     * @property {Core.state.StateProvider}\n     */\n    static get instance() {\n        return this._instance;\n    }\n    static set instance(inst) {\n        if (inst == null) {\n            inst = nullProvider;\n        }\n        else {\n            if (typeof inst === 'string' || ObjectHelper.isClass(inst) || (inst instanceof StateStorage)) {\n                inst = {\n                    storage : inst\n                };\n            }\n            if (ObjectHelper.isObject(inst)) {\n                inst = new StateProvider(inst);\n            }\n        }\n        this._instance = inst;\n    }\n    /**\n     * Initializes the default `StateProvider` instance for the page. This method can be passed an instance or one of\n     * the following type aliases:\n     *\n     *  - `'local'` : use `localStorage` to store application state (most common)\n     *  - `'memory'` : holds application state in the `StateProvider` instance (used when state is saved to a server)\n     *\n     * Once the `StateProvider` is initialized, components that use {@link Core.mixin.State} and assign components a\n     * {@link Core.mixin.State#config-stateId} will use this default provider to automatically save and restore their\n     * state.\n     *\n     * @param {'local'|'memory'|Core.state.StateProvider} inst The state provider storage type ('local' or 'memory') or\n     * the `StateProvider` instance.\n     * @returns {Core.state.StateProvider}\n     */\n    static setup(inst) {\n        this.instance = inst;  // use smart setter\n        return this.instance;\n    }\n    doDestroy() {\n        self.writeStatefuls.flush();\n        super.doDestroy();\n    }\n    /**\n     * On read, this property returns all state data stored in the provider. On write, this property _adds_ all the\n     * given values to the state provider's data. To replace the data, call {@link #function-clear} before assigning\n     * this property. This is used to bulk populate this `StateProvider` with data for stateful components.\n     * @member {Object}\n     */\n    get data() {\n        return this.storage.data;\n    }\n    set data(data) {\n        if (!data) {\n            this.clear();\n        }\n        else {\n            for (const key in data) {\n                this.setValue(key, data[key]);\n            }\n        }\n    }\n    /**\n     * Clears all state date\n     * @returns {Core.state.StateProvider} this instance\n     */\n    clear() {\n        this.storage.clear();\n        return this;\n    }\n    changeStorage(storage) {\n        if (storage == null) {\n            storage = nullStorage;\n        }\n        else {\n            if (typeof storage === 'string') {\n                if (!storageTypes[storage]) {\n                    throw new Error(`Invalid storage type \"${storage}\" (expected one of: \"${\n                        Object.keys(storageTypes).join('\", \"')}\")`);\n                }\n                storage = storageTypes[storage];\n            }\n            if (ObjectHelper.isClass(storage)) {\n                storage = new storage(this);\n            }\n        }\n        return storage;\n    }\n    /**\n     * This method is called to schedule saving the given `stateful` object.\n     * @param {Core.mixin.State} stateful The stateful object to save.\n     * @param {Object} [options] An object of options that affect the state saving process.\n     * @param {String} [options.id] The key for the saved state.\n     * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.\n     * @internal\n     */\n    saveStateful(stateful, options) {\n        (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);\n        this.writeStatefuls();\n    }\n    /**\n     * A delayable method that flushes pending stateful objects.\n     * @private\n     */\n    writeStatefuls() {\n        const\n            me = this,\n            { pendingSaves } = me,\n            n = pendingSaves?.length,\n            stateIds = [],\n            saved = [];\n        me.pendingSaves = null;\n        if (n) {\n            for (let options, stateful, stateId, i = 0; i < n; ++i) {\n                [stateful, options] = pendingSaves[i];\n                if (!stateful.isDestroying && stateful.isSaveStatePending) {\n                    stateId = stateful.saveState({\n                        ...options,\n                        immediate : true\n                    });\n                    if (stateId) {\n                        stateIds.push(stateId);\n                        saved.push(stateful);\n                    }\n                }\n            }\n            if (stateIds.length) {\n                /**\n                 * Triggered after one or more stateful objects save their state to the state provider. This event can\n                 * be used to save state to a backend server.\n                 *\n                 * For example, to save the page's state object as a single object on the server:\n                 *\n                 * ```javascript\n                 *  StateProvider.instance.on({\n                 *      save() {\n                 *          const data = StateProvider.instance.data;\n                 *          // Save \"data\" to server\n                 *      }\n                 *  });\n                 * ```\n                 *\n                 * Or, to save individual stateful components to the server:\n                 *\n                 * ```javascript\n                 *  StateProvider.instance.on({\n                 *      save({ stateIds }) {\n                 *          for (const stateId of stateIds) {\n                 *              const data = StateProvider.instance.getValue(stateId);\n                 *\n                 *              if (data == null) {\n                 *                  // Remove \"stateId\" from the server\n                 *              }\n                 *              else {\n                 *                  // Save new \"data\" for \"stateId\" to the server\n                 *              }\n                 *          }\n                 *      }\n                 *  });\n                 * ```\n                 *\n                 * Multi-page applications should probably include a page identifier in addition to the `stateId` to\n                 * prevent state from one page affecting other pages. If there are common components across all (or\n                 * many) pages, the `stateId` values would need to be assigned with all pages in mind.\n                 *\n                 * @event save\n                 * @param {Core.state.StateProvider} source The source of the event\n                 * @param {String[]} stateIds An array of `stateId` values that were saved to the state provider.\n                 * @param {Core.mixin.State[]} saved An array of stateful objects saved just saved to state provider\n                 * storage, in the same order as the `stateIds` array.\n                 */\n                me.trigger('save', {\n                    stateIds,\n                    saved\n                });\n            }\n        }\n    }\n    /**\n     * Returns the stored state given its `key`.\n     * @param {String} key The identifier of the state to return.\n     * @returns {Object}\n     */\n    getValue(key) {\n        this.writeStatefuls.flush();\n        return this.storage.getItem(key);\n    }\n    /**\n     * Stores the given state `value` under the specified `key`.\n     * @param {String} key The identifier of the state value.\n     * @param {Object} value The state value to set.\n     * @returns {Core.state.StateProvider} this instance\n     */\n    setValue(key, value) {\n        const\n            me = this,\n            { storage } = me,\n            was = me.getValue(key);\n        if (value != null) {\n            storage.setItem(key, value);\n            /**\n             * Triggered after an item is stored to the state provider.\n             * @event set\n             * @param {Core.state.StateProvider} source The source of the event\n             * @param {String} key The name of the stored item.\n             * @param {*} value The value of the stored item.\n             * @param {*} was The previous value of the stored item.\n             */\n            me.trigger('set', { key, value, was });\n        }\n        else if (was !== null) {\n            storage.removeItem(key);\n            /**\n             * Triggered after an item is removed from the state provider.\n             * @event remove\n             * @param {Core.state.StateProvider} source The source of the event\n             * @param {String} key The name of the removed item.\n             * @param {*} was The value of the removed item.\n             */\n            me.trigger('remove', { key, was });\n        }\n        return me;\n    }\n};\nconst nullProvider = new StateProvider({\n    storage : nullStorage\n});\nStateProvider._instance = nullProvider;\nStateProvider._$name = 'StateProvider';", "import Base from '../Base.js';\nimport DateHelper from '../helper/DateHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport StateProvider from '../state/StateProvider.js';\n//import Config from '../Config.js';\n/**\n * @module Core/mixin/State\n */\nconst primitiveRe = /boolean|number|string/;\n/**\n * A mixin that handles accessing, saving, and restoring an object's persistent state.\n *\n * ## Using Stateful Components\n *\n * Instances of classes that use this mixin (i.e., \"stateful components\") have a {@link #property-state} property that\n * provides read/write access to their persistable state in the form of a simple object. These state objects can be\n * saved and restored under application control, e.g., using `localStorage`.\n *\n * This approach can be streamlined using a {@link Core.state.StateProvider} either by setting the\n * {@link Core.state.StateProvider#property-instance-static default state provider} or by using an instance-level\n * {@link #config-stateProvider} config.\n *\n * When using a state provider, stateful components with a {@link #config-stateId} or an\n * {@link Core.widget.Widget#config-id} will automatically save (see {@link #function-saveState}) and restore\n * (see {@link #function-loadState}) their `state`. This use of the `id` as a `stateId` can be disabled by assigning\n * the {@link #config-stateful} config to `false`. When using a `stateId` and a state provider, it is not necessary to\n * call the {@link #function-loadState} and {@link #function-saveState} methods directly.\n *\n * ### Simple vs Complex State\n *\n * Some stateful components (e.g., {@link Core.widget.Panel panels}) have state that can be described purely by their\n * config properties. For these components, the {@link #config-stateful} config can be used to control which config\n * properties to include in their persistent state. For example:\n *\n * ```javascript\n *  const mainPanel = new Panel({\n *      collapsible : true,\n *      stateId     : 'mainPanel',\n *      stateful    : ['collapsed']\n *  });\n * ```\n *\n * Other components have a complex state (e.g., `GridState`), and do not use the `stateful` config in this way. In all\n * other ways, however, these components behave the same as their simple state counterparts.\n *\n * ## Implementing Stateful Components\n *\n * Implementors of stateful components have two main design points to consider:\n *\n *  - Getting and setting their persistent {@link #property-state} object.\n *  - Initiating calls to {@link #function-saveState} when the object's persistent state changes.\n *\n * ### Persistent State\n *\n * For simple cases, the {@link #config-stateful} config can be set to the list of config property names that should be\n * saved:\n *\n * ```javascript\n *  class MyStatefulComponent extends Base.mixin(State) {\n *      static get configurable() {\n *          return {\n *              stateful : ['text', 'size']\n *          };\n *      }\n *  }\n * ```\n *\n * While the `stateful` config supports an object form (where keys with truthy values are the config names), this form\n * is typically reserved for configuring instances.\n *\n * Classes can choose to implement the {@link #function-getState} and {@link #function-applyState} methods to enhance\n * the `state` object with data not easily mapped to config properties. These method can call their `super` methods or\n * fully replace them.\n *\n * ```javascript\n *  class MyStatefulComponent extends Base.mixin(State) {\n *      getState() {\n *          return {\n *              text : this.text,\n *              size : this.size\n *          };\n *      }\n *\n *      applyState(state) {\n *          this.text = state.text;\n *          this.size = state.size;\n *      }\n *  }\n * ```\n *\n * ### Saving Dates\n *\n * A stateful property may be a `Date` property if the `changeDate` method of the class accepts an\n * ISO 8601 formatted date. Dates are saved in state using ISO 8601 format: `YYYY-MM-DDTHH:mm:ssZ`\n *\n * ### Saving State\n *\n * When the persistent state of a stateful component changes, it must call {@link #function-saveState}. This method\n * schedules an update of the component's persistence {@link #property-state} with the appropriate\n * {@link #config-stateProvider}. When a config property named in the {@link #config-stateful} config changes, this\n * call will be made automatically. This means that even if a component replaces {@link #function-getState} and\n * {@link #function-applyState}, it can still be helpful to specify a value for the `stateful` config.\n *\n * ```javascript\n *  class MyStatefulComponent extends Base.mixin(State) {\n *      static get configurable() {\n *          return {\n *              stateful : ['text', 'size']\n *          };\n *      }\n *\n *      getState() { ... }\n *      applyState(state) { ... }\n *  }\n * ```\n *\n * Another way to ensure {@link #function-saveState} is called when necessary is to use {@link #config-statefulEvents}.\n *\n * ```javascript\n *  class MyStatefulComponent extends Base.mixin(State) {\n *      static get configurable() {\n *          return {\n *              statefulEvents : ['change', 'resize']\n *          };\n *      }\n *  }\n * ```\n *\n * @mixin\n */\nexport default Target => class State extends (Target || Base) {\n    static $name = 'State';\n    static configurable = {\n        /**\n         * This value can be one of the following:\n         *\n         * - `false` to not use an explicitly assigned {@link Core.widget.Widget#config-id} as the component's\n         * {@link #config-stateId} (this is only necessary when there is a {@link #config-stateProvider}).\n         * - An array of strings naming the config properties to save in the component's {@link #property-state}\n         * object.\n         * - An object whose truthy keys are the config properties to save in the component's {@link #property-state}\n         * object.\n         *\n         * These last two uses of the `stateful` config property do not apply to components that have a complex\n         * state, as described in the {@link Core.mixin.State State mixin documentation}.\n         *\n         * This config property is typically set by derived classes to a value including any config property that\n         * the user can affect via the user interface. For example, the {@link Core.widget.Panel#config-collapsed}\n         * config property is listed for a {@link Core.widget.Panel} since the user can toggle this config property\n         * using the {@link Core.widget.panel.PanelCollapser#config-tool collapse tool}.\n         *\n         * @config {Boolean|Object|String[]}\n         * @category State\n         */\n        stateful : {\n            value   : null,\n            $config : {\n                merge : 'classList'\n            }\n        },\n        /**\n         * The events that, when fired by this component, should trigger it to save its state by calling\n         * {@link #function-saveState}.\n         *\n         * ```javascript\n         *  class MyStatefulComponent extends Base.mixin(State) {\n         *      static get configurable() {\n         *          return {\n         *              statefulEvents : [ 'change', 'resize' ]\n         *          };\n         *      }\n         *  }\n         * ```\n         * In the above example, {@link #function-saveState} will be called any time an instance of this class\n         * fires the `change` or `resize` event.\n         *\n         * This config is typically set by derived classes as a way to ensure {@link #function-saveState} is called\n         * whenever their persistent state changes.\n         *\n         * @config {Object|String[]}\n         * @category State\n         * @default\n         */\n        statefulEvents : {\n            $config : {\n                merge : 'classList'\n            },\n            value : ['stateChange']\n        },\n        /**\n         * The key to use when saving this object's state in the {@link #config-stateProvider}. If this config is\n         * not assigned, and {@link #config-stateful} is not set to `false`, the {@link Core.widget.Widget#config-id}\n         * (if explicitly specified) will be used as the `stateId`.\n         *\n         * If neither of these is given, the {@link #function-loadState} and {@link #function-saveState} methods\n         * will need to be called directly to make use of the `stateProvider`.\n         *\n         * For single page applications (SPA's), or multi-page applications (MPA's) that have common, stateful\n         * components on multiple pages, the `stateId` should be unique across all stateful components (similar to DOM\n         * element id's). MPA's that want each page to be isolated can more easily achieve that isolation using the\n         * {@link Core.state.StateProvider#config-prefix}.\n         *\n         * @config {String}\n         * @category State\n         */\n        stateId : null,\n        /**\n         * The `StateProvider` to use to save and restore this object's {@link #property-state}. By default, `state`\n         * will be saved using the {@link Core.state.StateProvider#property-instance-static default state provider}.\n         *\n         * This config is useful for multi-page applications that have a set of common components that want to share\n         * state across pages, as well as other components that want their state to be isolated. One of these groups\n         * of stateful components could be assigned an explicit `stateProvider` while the other group could use the\n         * default state provider.\n         *\n         * @config {Core.state.StateProvider}\n         * @category State\n         */\n        stateProvider : null\n    };\n    static prototypeProperties = {\n        statefulLoaded : false,\n        statefulSuspended : 0\n    };\n    afterConstruct() {\n        super.afterConstruct();\n        this.loadState();\n    }\n    finalizeInit() {\n        // For widgets, this should happen before rendering which happens in Widget.finalizeInit():\n        this.loadState();\n        super.finalizeInit();\n    }\n    /**\n     * Returns `true` if this instance implements the {@link Core.mixin.State} interface.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isStateful() {\n        return true;\n    }\n    /**\n     * Returns `true` if this instance is ready to participate in state activities.\n     * @property {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isStatefulActive() {\n        // If a widget is rendered via appendTo (for example), this happens inside construct(), before we are called\n        // in afterConstruct(). When the Widget uses Responsive mixin, that will trigger its initial responsive update.\n        // In short, when isResponsivePending, the Widget is Responsive _and_ has not yet determined its responsiveState.\n        // In this case we do NOT want to activate statefulness.\n        // Further, if we are updating configs from a responsiveUpdate, we do not want to save to state.\n        return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;\n    }\n    // state\n    /**\n     * Gets or sets a component's state\n     * @property {Object}\n     * @category State\n     */\n    get state() {\n        return this._state = this.getState();\n    }\n    set state(state) {\n        this._state = state;\n        if (state) {\n            this.applyState(state);\n        }\n    }\n    // statefulEvents\n    updateStatefulEvents(events) {\n        const\n            me        = this,\n            listeners = {\n                name    : 'statefulEvents',\n                thisObj : me\n            };\n        me.detachListeners(listeners.name);\n        if (events) {\n            if (typeof events === 'string') {\n                events = StringHelper.split(events);\n            }\n            else if (!Array.isArray(events)) {\n                events = ObjectHelper.getTruthyKeys(events);\n            }\n            if (events.length) {\n                for (const event of events) {\n                    listeners[event] = 'onStatefulEvent';\n                }\n                me.ion?.(listeners);\n            }\n        }\n    }\n    // statefulId\n    /**\n     * Returns the state key to use for this instance. This will be either the {@link #config-stateId} or the\n     * {@link Core.widget.Widget#config-id} (if explicitly specified and {@link #config-stateful} is not `false`).\n     * @property {String}\n     * @category State\n     * @internal\n     */\n    get statefulId() {\n        const\n            me = this,\n            { responsiveState } = me;\n        let statefulId = me.stateId;\n        if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {\n            statefulId = me.id;\n        }\n        if (statefulId && responsiveState) {\n            statefulId = `${statefulId}[${responsiveState}]`;  // ex = 'foo[small]'\n        }\n        return statefulId;\n    }\n    // statefulness\n    /**\n     * Returns an object whose truthy keys are the config properties to include in this object's {@link #property-state}.\n     * @property {Object}\n     * @category State\n     * @readonly\n     * @private\n     */\n    get statefulness() {\n        const { stateful } = this;\n        return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;\n    }\n    // stateProvider\n    get stateProvider() {\n        return this._stateProvider || StateProvider.instance;\n    }\n    //---------------------------------------------------------------------------------------------------------------\n    // Methods\n    /**\n     * Applies the given `state` to this instance.\n     *\n     * This method is not called directly, but is called when the {@link #property-state} property is assigned a value.\n     *\n     * This method is implemented by derived classes that have complex state which exceeds the simple list of config\n     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to handle any\n     * config properties that are part of the complex state. The default implementation of this method will only assign\n     * those config properties listed in {@link #config-stateful} from the provided `state` object.\n     *\n     * @param {Object} state The state object to apply to this instance.\n     * @category State\n     */\n    applyState(state) {\n        state = this.pruneState(state);\n        if (state) {\n            this.setConfig(state);\n        }\n    }\n    /**\n     * Returns this object's state information.\n     *\n     * This method is not called directly, but is called to return the value of the {@link #property-state} property.\n     *\n     * This method is implemented by derived classes that have complex state which exceeds the simple list of config\n     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to gather the\n     * config properties that are part of the complex state. The default implementation of this method will only copy\n     * those config properties listed in {@link #config-stateful} to the returned `state` object.\n     *\n     * @returns {Object}\n     * @category State\n     */\n    getState() {\n        const\n            me          = this,\n            {\n                initialConfig,\n                statefulness,\n                isConstructing : defaultState\n            }           = me,\n            { configs } = me.$meta,\n            // If we are reading state at construction time, we are collecting the defaultState, so\n            // we should read from the initial config and the defaults.\n            source      = defaultState ? Object.setPrototypeOf(initialConfig, me.$meta.config) : me;\n        let state = null,\n            key, value;\n        if (statefulness) {\n            state = {};\n            for (key in statefulness) {\n                if (statefulness[key]) {\n                    value = source[key];\n                    if (value?.isStateful) {\n                        value = value.state;  // e.g.: stateful : { store : true }\n                    }\n                    else if (!defaultState) {\n                        // Dates can be saved in state as ISO 8601 Date and time.\n                        // This class's changer must be able to ingest this format.\n                        if (ObjectHelper.isDate(value)) {\n                            value = DateHelper.format(value, 'YYYY-MM-DDTHH:mm:ssZ');\n                        }\n                        // If we are reading state to save, ignore configs that have their initial value or aren't primitives\n                        if (configs[key].equal(value, initialConfig?.[key]) || !primitiveRe.test(typeof value)) {\n                            continue;\n                        }\n                    }\n                    state[key] = value;\n                }\n            }\n        }\n        return state;\n    }\n    /**\n     * Loads this object's state from its {@link #config-stateProvider} and applies it to its {@link #property-state}.\n     *\n     * This method only acts upon its first invocation for a given instance (unless `true` is passed for the `reload`\n     * parameter). This allows for flexibility in the timing of that call during the early stages of the instances'\n     * lifecycle. To reload the state after this time, manually assign the desired value to the {@link #property-state}\n     * property or call this method and pass `reload` as `true`.\n     *\n     * This method is called automatically during construction when a {@link #config-stateId} or (in some cases) an\n     * explicit {@link Core.widget.Widget#config-id} is provided.\n     *\n     * @param {String} [stateId] An overriding key to use instead of this object's {@link #config-stateId}.\n     * @param {Boolean} [reload=false] Pass `true` to load the state even if previously loaded.\n     * @category State\n     */\n    loadState(stateId, reload) {\n        if (typeof stateId === 'boolean') {\n            reload = stateId;\n            stateId = null;\n        }\n        const\n            me = this,\n            { statefulLoaded } = me;\n        if (me.isStatefulActive && (reload || !statefulLoaded)) {\n            const state = me.loadStatefulData(stateId || (stateId = me.statefulId));\n            if (!statefulLoaded && stateId) {\n                // Whether we have state data or not, we attempted to load it, so track the defaults and load attempt.\n                // The state as gathered when statefulLoaded not set is gathered from the configuration, *not*\n                // the running state.\n                me.defaultState = me.state;\n                me.statefulLoaded = true;\n            }\n            if (state) {\n                me.state = state;\n            }\n        }\n    }\n    loadStatefulData(stateId) {\n        stateId = this.isStatefulActive ? stateId || this.statefulId : null;\n        return stateId && this.stateProvider?.getValue(stateId);\n    }\n    resetDefaultState() {\n        if (this.defaultState) {\n            this.state = this.defaultState;\n        }\n    }\n    resumeStateful(full = false) {\n        this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);\n    }\n    /**\n     * Saves this object's state to its {@link #config-stateProvider}.\n     *\n     * When a {@link #config-stateId} or (in some cases) an explicit {@link Core.widget.Widget#config-id} is provided,\n     * this method will be called automatically any time a config property listed in {@link #config-stateful} changes or\n     * when a {@link #config-statefulEvents stateful event} is fired.\n     *\n     * Derived classes are responsible for calling this method whenever the persistent {@link #property-state} of the\n     * object changes.\n     *\n     * @param {Object|String} [options] Options that affect the state saving process or, if a string, the state `id`.\n     * @param {String} [options.id] The state id for the saved state (overrides {@link #config-stateId}).\n     * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.\n     * @category State\n     */\n    saveState(options) {\n        if (typeof options === 'string') {\n            options = {\n                id : options\n            };\n        }\n        else {\n            options = options || {};\n        }\n        const\n            me                = this,\n            { stateProvider } = me,\n            statefulId        = options.id || (me.isStatefulActive && me.statefulId);\n        if (statefulId && stateProvider) {\n            if (options.immediate) {\n                me.isSaveStatePending = false;\n                stateProvider.setValue(statefulId, me.state);\n            }\n            else if (!me.isSaveStatePending) {\n                me.isSaveStatePending = true;\n                stateProvider.saveStateful(me, options);\n            }\n            return statefulId;\n        }\n    }\n    suspendStateful() {\n        ++this.statefulSuspended;\n    }\n    //---------------------------------------------------------------------------------------------------------------\n    // Private / Internal\n    onConfigChange({ name, value, was, config }) {\n        super.onConfigChange({ name, value, was, config });\n        if (!this.isConstructing && this.isStatefulActive && this.statefulId) {\n            const { stateful } = this;\n            if (Array.isArray(stateful) ? stateful.includes(name) : stateful?.[name]) {\n                this.saveState();\n            }\n        }\n    }\n    onStatefulEvent() {\n        if (!this.isConstructing) {\n            this.saveState();\n        }\n    }\n    /**\n     * Returns an object that copies the {@link #config-stateful} config properties from the provided `state` object.\n     *\n     * @param {Object} state A state object from which to copy stateful configs.\n     * @returns {Object}\n     * @category State\n     * @private\n     */\n    pruneState(state) {\n        const { statefulness } = this;\n        if (statefulness) {\n            const pruned = {};\n            for (const key in state) {\n                if (statefulness[key]) {\n                    pruned[key] = state[key];\n                }\n            }\n            state = pruned;\n        }\n        return state;\n    }\n    //---------------------------------------------------------------------------------------------------------------\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../Base.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\n/**\n * @module Core/mixin/Identifiable\n */\nconst\n    // Id generation should be on a per page basis, not per module\n    idCounts     = ObjectHelper.getPathDefault(globalThis, 'bryntum.idCounts', Object.create(null)),\n    idTypes      = {\n        string : 1,\n        number : 1\n    };\n/**\n * A mixin which provides identifier services such as auto-creation of `id`s and registration and\n * lookup of instances by `id`.\n *\n * @mixin\n * @internal\n */\nexport default Target => class Identifiable extends (Target || Base) {\n    static get $name() {\n        return 'Identifiable';\n    }\n    static get declarable() {\n        return [\n            'identifiable'\n        ];\n    }\n    static get configurable() {\n        return {\n            /**\n             * The id of this object.  If not specified one will be generated. Also used for lookups through the\n             * static `getById` of the class which mixes this in. An example being {@link Core.widget.Widget}.\n             *\n             * For a {@link Core.widget.Widget Widget}, this is assigned as the `id` of the DOM\n             * {@link Core.widget.Widget#config-element element} and must be unique across all elements\n             * in the page's `document`.\n             * @config {String}\n             * @category Common\n             */\n            id : ''\n        };\n    }\n    static setupIdentifiable(cls, meta) {\n        const { identifiable } = cls;\n        identifiable.idMap = Object.create(null);\n        Reflect.defineProperty(cls, 'identifiable', {\n            get() {\n                return identifiable;\n            }\n        });\n    }\n    doDestroy() {\n        this.constructor.unregisterInstance(this);\n        super.doDestroy();\n    }\n    changeId(id) {\n        return ((this.hasGeneratedId /* assignment */ = !id)) ? this.generateAutoId() : id;\n    }\n    updateId(id, oldId) {\n        const\n            me = this,\n            C = me.constructor;\n        oldId && C.unregisterInstance(me, oldId);\n        if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {\n            C.registerInstance(me, id);\n        }\n    }\n    /**\n     * This method generates an id for this instance.\n     * @returns {String}\n     * @internal\n     */\n    generateAutoId() {\n        return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);\n    }\n    static get all() {\n        // not documented here since type of array is not knowable... documented at mixin target class\n        return Object.values(this.identifiable.idMap);\n    }\n    /**\n     * Generate a new id, using an internal counter and a prefix.\n     * @param {String} prefix Id prefix\n     * @returns {String} Generated id\n     */\n    static generateId(prefix = 'generatedId') {\n        // This produces \"b-foo-1, b-foo-2, ...\" for each prefix independently of the others. In other words, it makes\n        // id's more stable since the counter is on a per-class basis.\n        return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);\n    }\n    static registerInstance(instance, instanceId = instance.id) {\n        const { idMap } = this.identifiable;\n        // Code editor sets `disableThrow` to not get conflicts when loading the same module again\n        if (instanceId in idMap && !this.disableThrow) {\n            throw new Error('Id ' + instanceId + ' already in use');\n        }\n        idMap[instanceId] = instance;\n    }\n    /**\n     * Unregister Identifiable instance, normally done on destruction\n     * @param {Object} instance Object to unregister\n     * @param {String} id The id of the instance to unregister.\n     */\n    static unregisterInstance(instance, id = instance.id) {\n        const { idMap } = this.identifiable;\n        // ID may be passed, for example if the instance is destroyed and can no longer yield an id.\n        if (idTypes[typeof instance]) {\n            delete idMap[instance];\n        }\n        // Have to check for identity in case another instance by the same id has been created.\n        // Allow that to be overridden. Stores have always just evicted the previous owner of their IDs\n        else if (idMap[id] === instance) {\n            delete idMap[id];\n        }\n    }\n    static getById(id) {\n        const idMap = this.identifiable.idMap;\n        if (idMap) {\n            return idMap[id];\n        }\n    }\n    static get registeredInstances() {\n        const idMap = this.identifiable.idMap;\n        return idMap ? Object.values(idMap) : [];\n    }\n};\n", "/**\n * @module Core/data/stm/mixin/ModelStm\n */\nimport Base from '../../../Base.js';\nconst\n    STM_PROP         = Symbol('STM_PROP'),\n    unrecordedFields = {\n        // This field's value is a by product of node insertion and must not be recorded here.\n        // It's the node insertion operation which is recorded by STM.\n        parentIndex : 1\n    };\n/**\n * Mixin making a model compatible with {@link Core/data/stm/StateTrackingManager}\n *\n * @mixin\n */\nexport default Target => class ModelStm extends (Target || Base) {\n    static get $name() {\n        return 'ModelStm';\n    }\n    static get defaultConfig() {\n        return {\n            stm : null\n        };\n    }\n    joinStore(store) {\n        // No super on purpose, micro optimization of critical perf path\n        // super.joinStore && super.joinStore(store);\n        if (!this.stm) {\n            this.stm = store.stm;\n        }\n    }\n    unjoinStore(store) {\n        if (this.stm === store.stm) {\n            this.stm = null;\n        }\n        super.unjoinStore?.(store);\n    }\n    /**\n     * Reference to STM manager, if used\n     * @member {Core.data.stm.StateTrackingManager}\n     * @category Misc\n     */\n    get stm() {\n        return this[STM_PROP];\n    }\n    set stm(stm) {\n        this[STM_PROP] = stm;\n    }\n    // Hook for chronograph entity field accessors, for example; task.duration = 123.\n    // Triggers before setting the value.\n    beforeChronoFieldSet(fieldName, value) {\n        const me = this;\n        if (!me.inSetting && me.stm?.enabled && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {\n            // Do not record changes of identifiers that are not fields\n            if (me.getFieldDefinition(fieldName)) {\n                return { [fieldName] : { value, oldValue : me[fieldName] } };\n            }\n        }\n        return null;\n    }\n    // Hook for chronograph entity field accessors, for example; task.duration = 123\n    // Triggers after setting the value.\n    afterChronoFieldSet(fieldName, value, wasSet) {\n        wasSet && this.afterSet(fieldName, value, false, false, wasSet, true);\n    }\n    shouldRecordFieldChange(fieldName, oldValue, newValue) {\n        const store = this.firstStore;\n        // By default, we do not record:\n        // - not persistable field changes\n        // - null vs undefined changes\n        // - same value changes, compared by reference (by value for dates)\n        // - \"id\" changes\n        // - \"parentId\" changes caused by parent record idChange\n        return !(\n            this.constructor.nonPersistableFields[fieldName] ||\n            (oldValue == null && newValue == null) ||\n            (oldValue === newValue) ||\n            ((oldValue instanceof Date) && (newValue instanceof Date) && oldValue.getTime() === newValue.getTime()) ||\n            fieldName === 'id' ||\n            fieldName === '$PhantomId' ||\n            (fieldName === 'parentId' && store && store.oldIdMap[oldValue] === store.getById(newValue))\n        );\n    }\n    /**\n     * Overridden to store initial data of the changed fields and to notify STM\n     * manager about the change action if anything has been changed in result.\n     *\n     * The method is called from within {@link Core/data/Model#function-set} method.\n     *\n     * @private\n     */\n    afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet) {\n        const\n            { stm }              = this,\n            nonPersistableFields = this.constructor.nonPersistableFields;\n        if (stm?.isBase && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {\n            if (wasSet) {\n                let shouldRecord;\n                const [newData, oldData] = Object.keys(wasSet).reduce(\n                    (data, fieldName) => {\n                        const { value, oldValue } = wasSet[fieldName];\n                        if (this.shouldRecordFieldChange(fieldName, oldValue, value)) {\n                            shouldRecord       = true;\n                            data[0][fieldName] = value;\n                            data[1][fieldName] = oldValue;\n                        }\n                        return data;\n                    },\n                    [{}, {}]\n                );\n                if (shouldRecord) {\n                    stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);\n                }\n            }\n        }\n        // No super on purpose, micro optimization of critical perf path\n        // super.afterSet?.afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet);\n    }\n    /**\n     * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted\n     * records initial parents and parent index, to be able to restore the state back upon undo.\n     *\n     * @param {Core.data.Model[]} childRecords\n     * @returns {Array} Array of results from this call and any of super calls if any.\n     *               This result is consumed by {@link #function-afterInsertChild} which pops\n     *               from the result array to take only results of this method call and leave\n     *               results from super calls untouched.\n     *\n     * @private\n     */\n    beforeInsertChild(childRecords) {\n        const\n            preResult = super.beforeInsertChild?.(childRecords) || [],\n            { stm }   = this;\n        if (stm?.enabled) {\n            preResult.push(\n                childRecords.reduce((result, childRecord) => {\n                    // We are interested only in records from the same root node.\n                    // Removing (which is done before insertion) of the records\n                    // from another root (and store) should\n                    // be handled by that store STM instance.\n                    if (childRecord.root === this.root) {\n                        result.set(childRecord, {\n                            parent : childRecord.parent,\n                            index  : childRecord.parent ? childRecord.parentIndex : undefined\n                        });\n                    }\n                    return result;\n                }, new Map())\n            );\n        }\n        return preResult;\n    }\n    /**\n     * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}\n     * about children insertion. Provides it with all necessary context information collected\n     * in {@link #function-beforeInsertChild} required to undo/redo the action.\n     *\n     * @private\n     */\n    afterInsertChild(index, childRecords, beforeResult, inserted) {\n        const { stm } = this;\n        if (stm?.enabled) {\n            const context = beforeResult.pop();\n            if (inserted) {\n                stm.onModelInsertChild(this, index, inserted, context);\n            }\n        }\n        super.afterInsertChild?.(index, childRecords, beforeResult, inserted);\n    }\n    /**\n     * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed\n     * records initial parent index, to be able to restore the state back upon undo.\n     *\n     * @param {Core.data.Model[]} childRecords\n     * @param {Boolean} isMove\n     * @returns {Array} Array of results from this call and any of super calls if any.\n     *               This result is consumed by {@link #function-afterRemoveChild} which pops\n     *               from the result array to take only results of this method call and leave\n     *               results from super calls untouched.\n     *\n     * @private\n     */\n    beforeRemoveChild(childRecords, isMove) {\n        const\n            preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [],\n            { stm }   = this;\n        // If it's move then InsertChildAction will handle this case\n        if (stm?.enabled && !isMove) {\n            // Child records we receive are guaranteed to be direct children\n            // of this node, see Core/data/mixin/TreeNode#removeChild method\n            // Here we interested in the original index for each child removed,\n            // we collect it and store for future use in RemoveChildAction\n            preResult.push(\n                childRecords.reduce((result, childRecord) => {\n                    result.set(childRecord, childRecord.parentIndex);\n                    return result;\n                }, new Map())\n            );\n        }\n        return preResult;\n    }\n    /**\n     * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}\n     * about children removing. Provides it with all necessary context information collected\n     * in {@link #function-beforeRemoveChild} required to undo/redo the action.\n     *\n     * @private\n     */\n    afterRemoveChild(childRecords, beforeResult, isMove) {\n        const { stm } = this;\n        // If it's move then InsertChildAction will handle this case\n        if (stm?.enabled && !isMove) {\n            const context = beforeResult.pop();\n            if (childRecords && childRecords.length) {\n                stm.onModelRemoveChild(this, childRecords, context);\n            }\n        }\n        super.afterRemoveChild?.(childRecords, beforeResult, isMove);\n    }\n};\n", "import Base from '../../Base.js';\nimport ArrayHelper from '../../helper/ArrayHelper.js';\n/**\n * @module Core/data/mixin/TreeNode\n */\nconst\n    defaultTraverseOptions = {\n        includeFilteredOutRecords : false\n    },\n    fixTraverseOptions     = options => {\n        options = options || false;\n        if (typeof options === 'boolean') {\n            options = {\n                includeFilteredOutRecords : options\n            };\n        }\n        return options || defaultTraverseOptions;\n    };\n/**\n * Mixin for Model with tree node related functionality. This class is mixed into the {@link Core/data/Model} class.\n *\n * ## Adding and removing child nodes\n *\n * ```javascript\n * const parent = store.getById(1),\n *\n * firstBorn = parent.insertChild({\n *     name : 'Child node'\n * }, parent.children[0]); // Insert a child at a specific place in the children array\n *\n * parent.removeChild(parent.children[0]); // Removes a child node\n * parent.appendChild({ name : 'New child node' }); // Appends a child node\n * ```\n *\n * @mixin\n */\nexport default Target => class TreeNode extends (Target || Base) {\n    static get $name() {\n        return 'TreeNode';\n    }\n    /**\n     * This static configuration option allows you to control whether an empty parent task should be converted into a\n     * leaf. Enable/disable it for a whole class:\n     *\n     * ```javascript\n     * Model.convertEmptyParentToLeaf = false;\n     * ```\n     *\n     * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object\n     * with the following Boolean properties to customize the behaviour:\n     *\n     * ```javascript\n     * Model.convertEmptyParentToLeaf = {\n     *     onLoad   : false,\n     *     onRemove : true\n     * }\n     * ```\n     *\n     * @member {Boolean|{ onLoad : Boolean, onRemove : Boolean }} convertEmptyParentToLeaf\n     * @property {Boolean} onLoad Apply the transformation on load to any parents without children (`children : []`)\n     * @property {Boolean} onRemove Apply the transformation when all children have been removed from a parent\n     * @default false\n     * @static\n     * @category Parent & children\n     * */\n    static set convertEmptyParentToLeaf(value) {\n        if (value === true) {\n            value = {\n                onLoad   : true,\n                onRemove : true\n            };\n        }\n        else if (value === false) {\n            value = {\n                onLoad   : false,\n                onRemove : false\n            };\n        }\n        this._convertEmptyParentToLeaf = value;\n    }\n    constructor(...args) {\n        super(...args);\n        if (this.children) {\n            this.orderedChildren = this.orderedChildren || [];\n        }\n    }\n    static get convertEmptyParentToLeaf() {\n        return this._convertEmptyParentToLeaf || { onLoad : false, onRemove : false };\n    }\n    /**\n     * This is a read-only property providing access to the parent node.\n     * @member {Core.data.Model} parent\n     * @readonly\n     * @category Parent & children\n     */\n    /**\n     * This is a read-only field provided in server synchronization packets to specify\n     * which record id is the parent of the record.\n     * @readonly\n     * @field {String|Number|null} parentId\n     * @category Tree\n     */\n    /**\n     * This is a read-only field provided in server synchronization packets to specify\n     * which position the node takes in the parent's children array.\n     * This index is set on load and gets updated automatically after row reordering, sorting, etc.\n     * To save the order, need to persist the field on the server and when data is fetched to be loaded,\n     * need to sort by this field.\n     * @readonly\n     * @field {Number} parentIndex\n     * @category Tree\n     */\n    /**\n     * This is a read-only field provided in server synchronization packets to specify\n     * which position the node takes in the parent's ordered children array.\n     * This index is set on load and gets updated on reordering nodes in tree. Sorting and filtering\n     * have no effect on it.\n     * @readonly\n     * @field {Number} orderedParentIndex\n     * @category Tree\n     */\n    ingestChildren(childRecord, stores = this.stores) {\n        const\n            { inProcessChildren, constructor : MyClass } = this,\n            store                                        = stores[0];\n        if (childRecord === true) {\n            if (inProcessChildren) {\n                return true;\n            }\n            return [];\n        }\n        if (childRecord) {\n            childRecord = ArrayHelper.asArray(childRecord);\n            const\n                len    = childRecord.length,\n                result = [];\n            for (let i = 0, child; i < len; i++) {\n                child = childRecord[i];\n                child = child.isModel ? child : (store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true));\n                child = store ? store.processRecord(child) : child;\n                result.push(child);\n            }\n            if (this.children === true && store) {\n                const sorter = store.createSorterFn(store.sorters);\n                result.sort(sorter);\n            }\n            return result;\n        }\n    }\n    /**\n     * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field for leaf\n     * tasks.\n     *\n     * Note, if the tree store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}\n     * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise\n     * {@link Core/data/Store#function-loadChildren} has to be implemented.\n     *\n     * @field {Boolean|Object[]|Core.data.Model[]} children\n     * @category Parent & children\n     */\n    /**\n     * Array of sorted tree nodes but without a filter applied\n     * @member {Core.data.Model[]|null} unfilteredChildren\n     * @category Parent & children\n     * @private\n     */\n    /**\n     * Array of children unaffected by sorting and filtering, keeps original tree structure\n     * @member {Core.data.Model[]|null} orderedChildren\n     * @category Parent & children\n     * @private\n     */\n    /**\n     * Called during creation to also turn any children into Models joined to the same stores as this model\n     * @internal\n     * @category Parent & children\n     */\n    processChildren(stores = this.stores) {\n        const\n            me       = this,\n            { meta } = me;\n        me.inProcessChildren = true;\n        const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);\n        if (children) {\n            const\n                { convertEmptyParentToLeaf } = me.constructor,\n                shouldConvert                = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;\n            if (shouldConvert ? children.length : Array.isArray(children)) {\n                meta.isLeaf = false;\n                // We are processing a remote load\n                if (me.children === true) {\n                    me.children = [];\n                }\n                else if (children.length === 0) {\n                    me.children = children;\n                    return;\n                }\n                me.insertChild(children);\n            }\n            // Flagged for load on demand\n            else if (children === true) {\n                meta.isLeaf = false;\n                me.children = true;\n            }\n            // Empty child array, flag is leaf if configured to do so\n            else if (!me.isRoot) {\n                meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;\n            }\n        }\n        me.inProcessChildren = false;\n    }\n    /**\n     * This method returns `true` if this record has all expanded ancestors and is therefore\n     * eligible for inclusion in a UI.\n     * @param {Core.data.Store} [store] Optional store, defaults to nodes first store\n     * @returns {Boolean}\n     * @readonly\n     * @category Parent & children\n     * @returns {Boolean}\n     */\n    ancestorsExpanded(store = this.firstStore) {\n        const { parent } = this;\n        return !parent || (parent.isExpanded(store) && parent.ancestorsExpanded(store));\n    }\n    /**\n     * Used by stores to assess the record's collapsed/expanded state in that store.\n     * @param {Core.data.Store} store\n     * @category Parent & children\n     * @returns {Boolean}\n     */\n    isExpanded(store = this.firstStore) {\n        const mapMeta = this.instanceMeta(store.id);\n        // Default initial expanded/collapsed state when in the store\n        // to the record's original expanded property.\n        if (!Object.prototype.hasOwnProperty.call(mapMeta, 'collapsed')) {\n            mapMeta.collapsed = !this.expanded;\n        }\n        return !mapMeta.collapsed;\n    }\n    // A read-only property. It provides the initial state upon load\n    // The UI's expanded/collapsed state is in the store's meta map.\n    get expanded() {\n        return this.data.expanded;\n    }\n    /**\n     * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at\n     * level 1 and so on.\n     * @property {Number}\n     * @readonly\n     * @category Parent & children\n     */\n    get childLevel() {\n        let node = this,\n            ret  = -1;\n        while (node && !node.isRoot) {\n            ++ret;\n            node = node.parent;\n        }\n        return ret;\n    }\n    /**\n     * Is a leaf node in a tree structure?\n     * @property {Boolean}\n     * @readonly\n     * @category Parent & children\n     */\n    get isLeaf() {\n        return this.meta.isLeaf !== false && !this.isRoot;\n    }\n    /**\n     * Returns `true` if this node is the root of the tree\n     * @member {Boolean} isRoot\n     * @readonly\n     * @category Parent & children\n     */\n    /**\n     * Is a parent node in a tree structure?\n     * @property {Boolean}\n     * @readonly\n     * @category Parent & children\n     */\n    get isParent() {\n        return !this.isLeaf;\n    }\n    /**\n     * Returns true for parent nodes with children loaded (there might still be no children)\n     * @property {Boolean}\n     * @readonly\n     * @category Parent & children\n     */\n    get isLoaded() {\n        return this.isParent && Array.isArray(this.children);\n    }\n    /**\n     * Count all children (including sub-children) for a node (in its `firstStore\u00B4)\n     * @member {Number}\n     * @category Parent & children\n     */\n    get descendantCount() {\n        return this.getDescendantCount();\n    }\n    /**\n     * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)\n     * @member {Number}\n     * @category Parent & children\n     */\n    get visibleDescendantCount() {\n        return this.getDescendantCount(true);\n    }\n    /**\n     * Count visible (expanded)/all children for this node, optionally specifying for which store.\n     * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.\n     * @param {Core.data.Store} [store] A Store to which this node belongs\n     * @returns {Number}\n     * @category Parent & children\n     */\n    getDescendantCount(onlyVisible = false, store = this.firstStore) {\n        const { children } = this;\n        if (!children || !Array.isArray(children) || (onlyVisible && !this.isExpanded(store))) {\n            return 0;\n        }\n        return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);\n    }\n    /**\n     * Retrieve all children (by traversing sub nodes)\n     * @property {Core.data.Model[]}\n     * @category Parent & children\n     */\n    get allChildren() {\n        const { children } = this;\n        if (!children || children === true) {\n            return [];\n        }\n        return children.reduce((all, child) => {\n            all.push(child);\n            // push.apply is faster than push with array spread:\n            // https://jsperf.com/push-apply-vs-push-with-array-spread/1\n            all.push.apply(all, child.allChildren);\n            return all;\n        }, []);\n    }\n    /**\n     * Get the first child of this node\n     * @property {Core.data.Model}\n     * @readonly\n     * @category Parent & children\n     */\n    get firstChild() {\n        const { children } = this;\n        return (children?.length && children[0]) || null;\n    }\n    /**\n     * Get the last child of this node\n     * @property {Core.data.Model}\n     * @readonly\n     * @category Parent & children\n     */\n    get lastChild() {\n        const { children } = this;\n        return (children?.length && children[children.length - 1]) || null;\n    }\n    /**\n     * Get the previous sibling of this node\n     * @member {Core.data.Model} previousSibling\n     * @readonly\n     * @category Parent & children\n     */\n    /**\n     * Get the next sibling of this node\n     * @member {Core.data.Model} nextSibling\n     * @readonly\n     * @category Parent & children\n     */\n    /**\n     * Returns count of all preceding sibling nodes (including their children).\n     * @property {Number}\n     * @category Parent & children\n     */\n    get previousSiblingsTotalCount() {\n        let task  = this.previousSibling,\n            count = this.parentIndex;\n        while (task) {\n            count += task.descendantCount;\n            task = task.previousSibling;\n        }\n        return count;\n    }\n    get previousOrderedSibling() {\n        return this.parent?.orderedChildren[this.orderedParentIndex - 1];\n    }\n    get nextOrderedSibling() {\n        return this.parent?.orderedChildren[this.orderedParentIndex + 1];\n    }\n    get root() {\n        return this.parent?.root || this;\n    }\n    /**\n     * Reading this property returns the id of the parent node, if this record is a child of a node.\n     *\n     * Setting this property appends this record to the record with the passed id **in the same store that this record\n     * is already in**.\n     *\n     * Note that setting this property is **only valid if this record is already part of a tree store**.\n     *\n     * This is not intended for general use. This is for when a server responds to a record mutation and the server\n     * decides to move a record to a new parent. If a `parentId` property is passed in the response data for a record,\n     * that record will be moved.\n     *\n     * @property {Number|String|null}\n     * @category Parent & children\n     */\n    get parentId() {\n        return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;\n    }\n    set parentId(parentId) {\n        const\n            me         = this,\n            { parent } = me,\n            newParent  = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);\n        // Handle exact equality of parent.\n        // Also handle one being null and the other being undefined meaning no change.\n        if (!(newParent === parent || (!parent && !newParent))) {\n            // If we are batching, we do not trigger a change immediately.\n            // endBatch will set the field which will set the property again.\n            if (me.isBatchUpdating) {\n                me.meta.batchChanges.parentId = parentId;\n            }\n            else {\n                if (newParent) {\n                    newParent.appendChild(me);\n                }\n                else {\n                    me.parent.removeChild(me);\n                }\n            }\n        }\n    }\n    static set parentIdField(parentIdField) {\n        // Maintainer: the \"this\" references in here reference two different contexts.\n        // Outside of the property definition, it's the Model Class.\n        // In the getter and setter, it's the record instance.\n        this._parentIdField = parentIdField;\n        Object.defineProperty(this.prototype, parentIdField, {\n            set : function(parentId) {\n                // no arrow functions here, need `this` to change to instance\n                // noinspection JSPotentiallyInvalidUsageOfClassThis\n                this.parentId = parentId;\n            },\n            get : function() {\n                // no arrow functions here, need `this` to change to instance\n                // noinspection JSPotentiallyInvalidUsageOfClassThis\n                return this.parentId;\n            }\n        });\n    }\n    static get parentIdField() {\n        return this._parentIdField || 'parentId';\n    }\n    getChildren(options) {\n        let result;\n        if (options.includeFilteredOutRecords) {\n            result = this.unfilteredChildren || this.children;\n        }\n        else if (options.useOrderedTree) {\n            result = this.orderedChildren;\n        }\n        else {\n            result = this.children;\n        }\n        return result;\n    }\n    /**\n     * Traverses all child nodes recursively calling the passed function\n     * on a target node **before** iterating the child nodes.\n     * @param {Function} fn The function to call\n     * @param {Boolean} [skipSelf=false] True to ignore self\n     * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object\n     * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records\n     * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree\n     * @category Parent & children\n     */\n    traverse(fn, skipSelf, options) {\n        options = fixTraverseOptions(options);\n        const\n            me       = this,\n            children = me.getChildren(options);\n        if (!skipSelf) {\n            fn.call(me, me);\n        }\n        // Simply testing whether there is non-zero children length\n        // is 10x faster than using this.isLoaded\n        for (let i = 0, l = children?.length; i < l; i++) {\n            children[i].traverse(fn, false, options);\n        }\n    }\n    /**\n     * Traverses all child nodes recursively calling the passed function\n     * on child nodes of a target **before** calling it on the node.\n     * @param {Function} fn The function to call\n     * @param {Boolean} [skipSelf=false] True to skip this node in the traversal\n     * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object\n     * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records\n     * @category Parent & children\n     */\n    traverseBefore(fn, skipSelf, options) {\n        options = fixTraverseOptions(options);\n        const\n            me       = this,\n            children = me.getChildren(options);\n        // Simply testing whether there is non-zero children length\n        // is 10x faster than using me.isLoaded\n        for (let i = 0, l = children?.length; i < l; i++) {\n            children[i].traverse(fn, false, options);\n        }\n        if (!skipSelf) {\n            fn.call(me, me);\n        }\n    }\n    /**\n     * Traverses child nodes recursively while fn returns true\n     * @param {Function} fn\n     * @param {Boolean} [skipSelf=false] True to skip this node in the traversal\n     * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object\n     * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records\n     * @category Parent & children\n     * @returns {Boolean}\n     */\n    traverseWhile(fn, skipSelf, options) {\n        options = fixTraverseOptions(options);\n        const me = this;\n        let goOn = skipSelf || fn.call(me, me) !== false;\n        if (goOn) {\n            const children = me.getChildren(options);\n            // Simply testing whether there is non-zero children length\n            // is 10x faster than using me.isLoaded\n            if (children?.length) {\n                goOn = children.every(child => child.traverseWhile(fn, false, options));\n            }\n        }\n        return goOn;\n    }\n    /**\n     * Bubbles up from this node, calling the specified function with each node.\n     *\n     * @param {Function} fn The function to call for each node\n     * @param {Boolean} [skipSelf] True to skip this node in the traversal\n     * @category Parent & children\n     */\n    bubble(fn, skipSelf = false) {\n        let me = this;\n        if (!skipSelf) {\n            fn.call(me, me);\n        }\n        while (me.parent) {\n            me = me.parent;\n            fn.call(me, me);\n        }\n    }\n    /**\n     * Bubbles up from this node, calling the specified function with each node,\n     * while the function returns true.\n     *\n     * @param {Function} fn The function to call for each node\n     * @param {Boolean} [skipSelf] True to skip this node in the traversal\n     * @category Parent & children\n     * @returns {Boolean}\n     */\n    bubbleWhile(fn, skipSelf = false) {\n        let me   = this,\n            goOn = true;\n        if (!skipSelf) {\n            goOn = fn.call(me, me);\n        }\n        while (goOn && me.parent) {\n            me   = me.parent;\n            goOn = fn.call(me, me);\n        }\n        return goOn;\n    }\n    /**\n     * Checks if this model contains another model as one of it's descendants\n     *\n     * @param {Core.data.Model|String|Number} childOrId child node or id\n     * @param {Boolean} [skipSelf=false] True to ignore self in the traversal\n     * @category Parent & children\n     * @returns {Boolean}\n     */\n    contains(childOrId, skipSelf = false) {\n        if (childOrId && typeof childOrId === 'object') {\n            childOrId = childOrId.id;\n        }\n        return !this.traverseWhile(node => node.id != childOrId, skipSelf);\n    }\n    getTopParent(all) {\n        let result;\n        if (all) {\n            result = [];\n            this.bubbleWhile((t) => {\n                result.push(t);\n                return t.parent && !t.parent.isRoot;\n            });\n        }\n        else {\n            result = null;\n            this.bubbleWhile((t) => {\n                if (!t.parent) {\n                    result = t;\n                }\n                return t.parent && !t.parent.isRoot;\n            });\n        }\n        return result;\n    }\n    /**\n     * Append a child record(s) to any current children.\n     * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single\n     * record/data to append\n     * @param {Boolean} [silent] Pass `true` to not trigger events during append\n     * @returns {Core.data.Model|Core.data.Model[]|null}\n     * @category Parent & children\n     */\n    appendChild(childRecord, silent = false) {\n        return this.insertChild(childRecord, null, silent);\n    }\n    /**\n     * Insert a child record(s) before an existing child record.\n     * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single\n     * record/data to insert\n     * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end\n     * @param {Boolean} [silent] Pass `true` to not trigger events during append\n     * @returns {Core.data.Model|Core.data.Model[]|null}\n     * @category Parent & children\n     */\n    insertChild(childRecord, before = null, silent = false, options = {}) {\n        const\n            me          = this,\n            returnArray = Array.isArray(childRecord);\n        childRecord = ArrayHelper.asArray(childRecord);\n        if (typeof before === 'number') {\n            before = me.children?.[before] ?? null;\n        }\n        if (!silent && !me.stores.every(s => s.trigger('beforeAdd', {\n            records : childRecord, parent : me\n        }) !== false)) {\n            return null;\n        }\n        // This call makes child record an array containing Models\n        childRecord = me.ingestChildren(childRecord);\n        // NOTE: see comment in Model::set() about before/in/after calls approach.\n        const\n            index     = before?.parentIndex ?? me.children?.length ?? 0,\n            preResult = me.beforeInsertChild?.(childRecord),\n            inserted  = me.internalAppendInsert(childRecord, before, silent, options);\n        // Turn into a parent if not already one\n        if (inserted.length) {\n            me.convertToParent(silent);\n        }\n        me.afterInsertChild?.(index, childRecord, preResult, inserted);\n        return (returnArray || !inserted) ? inserted : inserted[0];\n    }\n    /**\n     * Converts a leaf node to a parent node, assigning an empty array as its children\n     * @param {Boolean} [silent] Pass `true` to not trigger any event\n     * @category Parent & children\n     */\n    convertToParent(silent = false) {\n        const\n            me      = this,\n            wasLeaf = me.isLeaf;\n        me.meta.isLeaf = false;\n        if (!me.children) {\n            me.children = [];\n        }\n        // Signal a change event so that the UI updates, unless it is during load in which case StoreTree#onNodeAddChild\n        // will handle it\n        if (wasLeaf && !me.root.isLoading && !silent) {\n            me.signalNodeChanged({\n                isLeaf : {\n                    value    : false,\n                    oldValue : true\n                }\n            });\n        }\n    }\n    signalNodeChanged(changes, stores = this.stores) {\n        stores.forEach(s => {\n            s.trigger('update', { record : this, records : [this], changes });\n            s.trigger('change', { action : 'update', record : this, records : [this], changes });\n        });\n    }\n    tryInsertChild() {\n        return this.insertChild(...arguments);\n    }\n    internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {\n        const\n            me                         = this,\n            { stores, root, children } = me,\n            { firstStore : rootStore } = root,\n            { parentIdField }          = me.constructor,\n            parentId                   = me.isAutoRoot ? null : me.id;\n        let isNoop, start, i, newRecordsCloned, oldParentIndices, isMove;\n        if (!root.isLoading && rootStore) {\n            // Only collect this info if not loading, to not produce garbage\n            isMove = {};\n            oldParentIndices = [];\n            for (i = 0; i < recordsToInsert.length; i++) {\n                const newRecord = recordsToInsert[i];\n                // Store added should not be modified for adds\n                // caused by moving.\n                isMove[newRecord.id] = newRecord.root === root;\n                oldParentIndices[i]  = newRecord.parentIndex;\n            }\n        }\n        // The reference node must be one of our children. If not, fall back to an append.\n        if (beforeRecord && beforeRecord.parent !== me) {\n            beforeRecord = null;\n        }\n        // If the records starting at insertAt or (insertAt - 1), are the same sequence\n        // that we are being asked to add, this is a no-op.\n        if (children) {\n            const insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;\n            if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {\n                for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {\n                    if (recordsToInsert[i] !== children[start + i]) {\n                        isNoop = false;\n                    }\n                }\n            }\n        }\n        // Fulfill the contract of appendChild/insertChild even if we did not have to do anything.\n        // Callers must be able to correctly postprocess the returned value as an array.\n        if (isNoop) {\n            return recordsToInsert;\n        }\n        // Remove incoming child nodes from any current parent.\n        for (i = 0; i < recordsToInsert.length; i++) {\n            const\n                newRecord = recordsToInsert[i],\n                oldParent = newRecord.parent;\n            // Check if any descendants of the added node are moves.\n            if (rootStore && !root.isLoading) {\n                newRecord.traverse(r => {\n                    if (r.root === root) {\n                        isMove[r.id] = true;\n                    }\n                });\n            }\n            // If the new record has a parent, remove from that parent.\n            // This operation may be vetoed by listeners.\n            // If it is vetoed, then remove from the newRecords and do not\n            // set the parent property\n            if (oldParent?.removeChild(newRecord, isMove?.[newRecord.id], silent, { isInserting : true, ...options }) === false) {\n                if (!newRecordsCloned) {\n                    recordsToInsert  = recordsToInsert.slice();\n                    newRecordsCloned = true;\n                }\n                recordsToInsert.splice(i--, 1);\n            }\n            else {\n                newRecord.parent = me;\n                // Set parentId directly to data, record.parentId uses a getter to return record.parent.id\n                newRecord.data[parentIdField] = parentId;\n                if (oldParent) {\n                    newRecord.meta.oldParentId = oldParent.id;\n                }\n            }\n        }\n        // Still records to insert after beforeRemove listeners may have vetoed some\n        if (recordsToInsert.length) {\n            if (!Array.isArray(children)) {\n                me.children = [];\n            }\n            if (!Array.isArray(me.orderedChildren)) {\n                me.orderedChildren = [];\n            }\n            // Add to the children\n            const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);\n            stores.forEach(store => {\n                if (!store.isChained) {\n                    recordsToInsert.forEach(record => {\n                        // Initialize context for newly added records\n                        record.joinStore(store);\n                    });\n                    // Add to store (will also add any child records and trigger events)\n                    store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);\n                    recordsToInsert.forEach((record, i) => {\n                        // If we are in the recursive inclusion of children at construction\n                        // time, or in a store load, that must not be a data modification.\n                        // Otherwise, we have to signal a change\n                        if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {\n                            const\n                                toSet                     = {\n                                    [parentIdField]                   : parentId,\n                                    [me.getDataSource('parentIndex')] : record.parentIndex\n                                },\n                                wasSet                    = {},\n                                { modified, oldParentId } = record.meta,\n                                oldParentIndex            = oldParentIndices[i];\n                            delete record.meta.oldParentId;\n                            if (me.id !== oldParentId) {\n                                wasSet[parentIdField] = {\n                                    value    : parentId,\n                                    oldValue : oldParentId\n                                };\n                            }\n                            if (record.parentIndex !== oldParentIndex) {\n                                wasSet.parentIndex = {\n                                    value    : record.parentIndex,\n                                    oldValue : oldParentIndex\n                                };\n                            }\n                            // Changing back to its original value\n                            if (modified[parentIdField] === me.id) {\n                                Reflect.deleteProperty(modified, parentIdField);\n                            }\n                            // Cache its original value\n                            else if (!(parentIdField in modified)) {\n                                modified[parentIdField] = oldParentId;\n                            }\n                            if (isMove[record.id]) {\n                                const oldParent = store.getById(oldParentId);\n                                // If old parent transitioned to being a leaf node, signal a change event so that the UI\n                                // updates. Handled here and not on remove to get the correct order of events on move\n                                if (oldParent.isLeaf && !silent) {\n                                    oldParent.signalNodeChanged({\n                                        isLeaf : {\n                                            value    : true,\n                                            oldValue : false\n                                        }\n                                    }, [store]);\n                                }\n                            }\n                            record.afterChange(toSet, wasSet);\n                        }\n                    });\n                }\n            });\n        }\n        return recordsToInsert;\n    }\n    /**\n     * Remove a child record. Only direct children of this node can be removed, others are ignored.\n     * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.\n     * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.\n     * @param {Boolean} [silent] Pass `true` to not trigger events during remove.\n     * @privateparam {Object} [options]\n     * @privateparam {Object} [options.isInserting] `true` is passed when removal is part of record inserting (acted on by\n     * ModelLink)\n     * @returns {Core.data.Model[]} All records (including nested children) removed\n     * @category Parent & children\n     */\n    removeChild(childRecords, isMove = false, silent = false, options = {}) {\n        const\n            me                = this,\n            allRemovedRecords = [],\n            wasLeaf           = me.isLeaf,\n            {\n                children,\n                stores\n            }                 = me;\n        childRecords = ArrayHelper.asArray(childRecords);\n        childRecords = childRecords.filter(r => r.parent === me);\n        if (!silent) {\n            // Allow store listeners to veto the beforeRemove event\n            for (const store of stores) {\n                if (!store.isChained && store.trigger('beforeRemove', {\n                    parent : me, records : childRecords, isMove\n                }) === false) {\n                    return false;\n                }\n            }\n        }\n        const preResult = me.beforeRemoveChild?.(childRecords, isMove);\n        for (const childRecord of childRecords) {\n            const\n                { parentIdField } = childRecord.constructor,\n                { modified }      = childRecord.meta,\n                oldParentId       = childRecord.parent ? childRecord.parent.id : null;\n            // Cache its original value (not if it is a link, that would pollute original)\n            if (!(parentIdField in modified) && !childRecord.isLinked) {\n                modified[parentIdField] = oldParentId;\n            }\n            const index = me.removeFromChildren(childRecord, options);\n            stores.forEach(store => {\n                if (!store.isChained) {\n                    const { isRemoving } = store;\n                    // Raise the store isRemoving flag (it's set in Store#remove() but not when we call record#removeChild() directly)\n                    store.isRemoving = true;\n                    allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, { isMove, silent }));\n                    // restore the flag initial state\n                    store.isRemoving = isRemoving;\n                }\n            });\n            // No need to clean up the node parent info and other meta data in case it is \"move\" operation. The info will be updated after \"insert\" operation.\n            if (!isMove) {\n                childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;\n                // Reset parentId in data, record.parentId uses a getter to return record.parent.id\n                childRecord.data[parentIdField] = null;\n            }\n        }\n        // Convert emptied parent into leaf if configured to do so\n        if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {\n            me.meta.isLeaf = true;\n        }\n        // If we've transitioned to being a leaf node, signal a change event so that the UI updates\n        // (but not if part of move, will be signaled by insert)\n        if (me.isLeaf !== wasLeaf && !silent && !isMove) {\n            me.signalNodeChanged({\n                isLeaf : {\n                    value    : true,\n                    oldValue : false\n                }\n            });\n        }\n        me.afterRemoveChild?.(childRecords, preResult, isMove);\n        return allRemovedRecords;\n    }\n    clearParentId() {\n        const me = this;\n        Reflect.deleteProperty(me.data, me.parentIdField);\n        Reflect.deleteProperty(me.originalData, me.parentIdField);\n        if (me.meta.modified) {\n            Reflect.deleteProperty(me.meta.modified, me.parentIdField);\n        }\n    }\n    /**\n     * Replaces all child nodes with the new node set.\n     * @param {Core.data.Model|Core.data.Model[]} childRecords The new child record set.\n     * @returns {Core.data.Model[]}\n     * @category Parent & children\n     */\n    replaceChildren(newChildren) {\n        this.clearChildren();\n        this.data[this.constructor.childrenField] = newChildren;\n        this.processChildren();\n        return this.children;\n    }\n    /**\n     * Removes all child nodes from this node.\n     * @param {Boolean} [silent=false] Pass `true` to not fire Store events during the remove.\n     * @returns {Core.data.Model[]}\n     * @category Parent & children\n     */\n    clearChildren(silent = false) {\n        const\n            me         = this,\n            { stores } = me,\n            children   = me.unfilteredChildren || me.children;\n        me.children        = [];\n        me.orderedChildren = [];\n        if (children && children !== true) {\n            stores.forEach(store => {\n                if (!store.isChained) {\n                    // unfiltered:true to unregister children on filtered stores\n                    store.onNodeRemoveChild(me, children, 0, { unfiltered : true, silent });\n                }\n            });\n            // clear unfilteredChildren (must be after the above loop)\n            if (me.unfilteredChildren) {\n                me.unfilteredChildren = [];\n            }\n        }\n    }\n    /**\n     * Removes all records from the rootNode\n     * @private\n     */\n    clear() {\n        const\n            me         = this,\n            { stores } = me,\n            children   = me.children?.slice();\n        // Only allow for root node and if data is present\n        if (!me.isRoot || !children) {\n            return;\n        }\n        for (const store of stores) {\n            if (!store.isChained) {\n                if (store.trigger('beforeRemove', {\n                    parent : me, records : children, isMove : false, removingAll : true\n                }) === false) {\n                    return false;\n                }\n            }\n        }\n        me.children.length = 0;\n        if (me.unfilteredChildren) {\n            me.unfilteredChildren.length = 0;\n        }\n        stores.forEach(store => {\n            children.forEach(child => {\n                if (child.stores.includes(store)) {\n                    // this will drill down the child, unregistering whole branch\n                    child.unjoinStore(store);\n                }\n                child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;\n            });\n            store.storage.suspendEvents();\n            store.storage.clear();\n            store.storage.resumeEvents();\n            store.added.clear();\n            store.modified.clear();\n            store.trigger('removeAll');\n            store.trigger('change', { action : 'removeall' });\n        });\n    }\n    updateChildrenIndices(children, indexName, silent = false) {\n        let previousSibling = null;\n        for (let i = 0; i < children.length; i++) {\n            const\n                child    = children[i],\n                oldValue = child[indexName];\n            if (indexName === 'parentIndex' || indexName === 'orderedParentIndex') {\n                // Record should not be considered modified by initial assignment of parentIndex\n                if (oldValue === undefined || silent) {\n                    child.setData(indexName, i);\n                }\n                // Check to avoid pointless beforeUpdates from inSet\n                else if (oldValue !== i) {\n                    // Silent set, do not want to trigger events from updated indices\n                    child.set(indexName, i, true);\n                }\n            }\n            else {\n                child[indexName] = i;\n            }\n            if (indexName === 'parentIndex') {\n                child.previousSibling = previousSibling;\n                if (previousSibling) {\n                    previousSibling.nextSibling = child;\n                }\n                // Last child never has a nextSibling\n                if (i === children.length - 1) {\n                    child.nextSibling = null;\n                }\n                previousSibling = child;\n            }\n        }\n    }\n    addToChildren(beforeRecord, newRecords, options = {}) {\n        // children can be sorted and filtered\n        // unfilteredChildren can not be filtered\n        // orderedChildren can not be nor filtered nor sorted. it holds true tree hierarchy\n        const\n            me      = this,\n            configs = [\n                [me.children, 'parentIndex', beforeRecord],\n                [me.unfilteredChildren, 'unfilteredIndex', beforeRecord],\n                [me.orderedChildren, 'orderedParentIndex', options?.orderedBeforeNode ?? beforeRecord]\n            ];\n        for (const config of configs) {\n            const [children, indexName, beforeRecord] = config;\n            if (children) {\n                const index = beforeRecord ? beforeRecord[indexName] : children.length;\n                config.push(index);\n                children.splice(index, 0, ...newRecords);\n                if (!options?.[indexName]?.skip) {\n                    me.updateChildrenIndices(children, indexName);\n                }\n            }\n        }\n        // always return index of the record in the children array\n        return configs[0][3];\n    }\n    removeFromChildren(childRecord, options) {\n        const configs = [\n            [this.children, 'parentIndex'],\n            [this.unfilteredChildren, 'unfilteredIndex'],\n            [this.orderedChildren, 'orderedParentIndex']\n        ];\n        for (const config of configs) {\n            const [children, indexName] = config;\n            if (children) {\n                // parentIndex/orderedParentIndex might be changed when applying a remote changeset leading to\n                // record getting removed from the wrong position in the children array. Therefore, we should\n                // not rely on the index value, instead we query array itself\n                const index = children.indexOf(childRecord);\n                config.push(index);\n                if (index > -1) {\n                    children.splice(index, 1);\n                    if (!options?.[indexName]?.skip) {\n                        this.updateChildrenIndices(children, indexName);\n                    }\n                }\n            }\n        }\n        // always return index of the record in the children array\n        return configs[0][2];\n    }\n    /**\n     * Iterates orderedChildren array to apply sorting order according to `orderedParentIndex`.\n     * Normally sorting is not required because order is maintained on append/insert. But is useful\n     * when pasting number of records to restore their original order.\n     * @param {Boolean} [deep=true] True to dive into children. False to sort own children.\n     * @param {Boolean} [usePreviousOrder=false] Enable to use previous value of `orderedParentIndex`.\n     * @returns {Set} Returns Set of moved nodes which require WBS update\n     * @private\n     */\n    sortOrderedChildren(deep = true, usePreviousOrder = false) {\n        // Collect moved nodes, we need to recalculate WBS on them.\n        const movedNodes = [];\n        if (!this.isLeaf) {\n            this.orderedChildren.sort((a, b) => {\n                if (usePreviousOrder) {\n                    const\n                        aPrevIndex = a.meta.modified.orderedParentIndex ?? a.orderedParentIndex,\n                        bPrevIndex = b.meta.modified.orderedParentIndex ?? b.orderedParentIndex,\n                        result     = aPrevIndex - bPrevIndex;\n                    if (result !== 0) {\n                        movedNodes.push(a);\n                        movedNodes.push(b);\n                    }\n                    return result;\n                }\n                else {\n                    return a.orderedParentIndex - b.orderedParentIndex;\n                }\n            });\n            if (deep) {\n                this.orderedChildren.forEach(child => {\n                    movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));\n                });\n            }\n            this.updateChildrenIndices(this.orderedChildren, 'orderedParentIndex', true);\n        }\n        return new Set(movedNodes);\n    }\n};\n", "import Base from '../../Base.js';\nimport ArrayHelper from '../../helper/ArrayHelper.js';\nimport StringHelper from '../../helper/StringHelper.js';\n/**\n * @module Core/data/mixin/ModelLink\n */\nconst\n    // Properties set on the proxy instead of on the original\n    propertyOverrides = {\n        id              : 1,\n        stores          : 1,\n        parentIndex     : 1,\n        parent          : 1,\n        previousSibling : 1,\n        nextSibling     : 1,\n        unfilteredIndex : 1\n    },\n    proxyConfig = {\n        get(target, prop) {\n            // Proxy record has some additional meta\n            if (prop === 'proxyMeta') {\n                return this.proxyMeta;\n            }\n            // Accessing constructor in functions should lead to original records constructor\n            // (for static fns etc.)\n            if (prop === 'constructor') {\n                return target.constructor;\n            }\n            // Override setData / set to reroute parentIndex updates\n            if (prop === 'setData') {\n                return this.setDataOverride;\n            }\n            if (prop === 'set') {\n                return this.setOverride;\n            }\n            // Special properties not shared with the original record\n            if (propertyOverrides[prop]) {\n                return this.proxyMeta.data[prop];\n            }\n            // Everything else is scoped to the proxy record\n            return Reflect.get(target, prop, this.proxyRecord);\n        },\n        set(target, prop, value) {\n            // Special properties not shared with the original record\n            if (propertyOverrides[prop]) {\n                this.proxyMeta.data[prop] = value;\n            }\n            // Everything else is relayed to the original record\n            else {\n                target[prop] = value;\n            }\n            return true;\n        },\n        // Override setData & set to reroute parentIndex updates\n        setDataOverride(toSet, value) {\n            if (toSet === 'parentIndex') {\n                this.proxyMeta.data.parentIndex = value;\n            }\n            else {\n                this.proxyMeta.originalRecord.setData(toSet, value);\n            }\n        },\n        setOverride(field, value, ...args) {\n            if (field === 'parentIndex') {\n                this.proxyMeta.data.parentIndex = value;\n            }\n            else {\n                this.proxyMeta.originalRecord.set(field, value, ...args);\n            }\n        }\n    };\n/**\n * Mixin that allows creating proxy records linked to an original record. See {@link #function-link} for more\n * information.\n *\n * <div class=\"note\">Note that not all UI features support linked records</div>\n *\n * @mixin\n */\nexport default Target => class ModelLink extends (Target || Base) {\n    static $name = 'ModelLink';\n    /**\n     * Creates a proxy record (using native Proxy) linked to this record (the original). The proxy records shares most\n     * data with the original, except for its `id` (which is always generated), and ordering fields such as\n     * `parentIndex` and `parentId` etc.\n     *\n     * Any change to the proxy record will be reflected on the original, and vice versa. A proxy record is not meant to\n     * be persisted, only the original record should be persisted. Thus, proxy records are not added to stores change\n     * tracking (added, modified and removed records).\n     *\n     * Removing the original record removes all proxies.\n     *\n     * Creating a proxy record allows a Store to seemingly contain the record multiple times, something that is\n     * otherwise not possible. It also allows a record to be used in both a tree store and in a flat store.\n     *\n     * <div class=\"note\">Note that not all UI features support linked records</div>\n     *\n     * @returns {Proxy} Proxy record linked to the original record\n     * @category Misc\n     */\n    link() {\n        // Calling link on a link creates another link of the original record\n        if (this.isLinked) {\n            return this.$original.link();\n        }\n        const\n            me           = this,\n            useConfig    =  {\n                ...proxyConfig,\n                // Data not shared with the original record\n                proxyMeta : {\n                    originalRecord : me,\n                    data           : {\n                        id     : `${me.id}_link_${StringHelper.generateUUID()}`,\n                        stores : []\n                    }\n                }\n            },\n            proxyRecord = new Proxy(me, useConfig);\n        useConfig.proxyRecord = proxyRecord;\n        // Original record keeps tracks of all proxies\n        (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);\n        return proxyRecord;\n    }\n    /**\n     * Is this record linked to another record?\n     * @member {Boolean}\n     * @readonly\n     * @category Misc\n     */\n    get isLinked() {\n        return Boolean(this.proxyMeta?.originalRecord);\n    }\n    /**\n     * Are other records linked to this record?\n     * @member {Boolean}\n     * @readonly\n     * @category Misc\n     */\n    get hasLinks() {\n        return Boolean(!this.proxyMeta && this.$links.length);\n    }\n    // Logic to remove a link shared between removing in a flat store and a tree store\n    removeLink(link, records = null, silent = false) {\n        // Removing original, also remove linked records\n        if (link.hasLinks) {\n            for (const linked of link.$links.slice()) {\n                // Flat\n                if (records) {\n                    ArrayHelper.include(records, linked);\n                }\n                // Tree\n                else {\n                    linked.remove(silent);\n                }\n            }\n        }\n        // Removing linked record, remove from originals link tracking\n        else if (link.isLinked) {\n            ArrayHelper.remove(link.$original.$links, link);\n        }\n    }\n    // Overrides beforeRemove in Model, to remove all linked records when original record is removed.\n    beforeRemove(records) {\n        this.removeLink(this, records);\n    }\n    // Overrides removeChild in TreeNode, to remove the original node and all linked nodes when either a linked or\n    // original node is removed.\n    removeChild(childRecords, isMove, silent, options) {\n        if (!options?.isInserting) {\n            childRecords = ArrayHelper.asArray(childRecords);\n            for (const child of childRecords) {\n                this.removeLink(child, null, silent);\n            }\n        }\n        return super.removeChild(childRecords, isMove, silent, options);\n    }\n    // Convenience getter for code keying by id that needs to work with both link and original\n    get $originalId() {\n        return this.$original.id;\n    }\n    // Convenience getter to retrieve linked records\n    get $links() {\n        return this.meta.linkedRecords ?? [];\n    }\n};\n", "import Base from '../Base.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\n/**\n * @module Core/mixin/Factoryable\n */\nconst\n    { defineProperty } = Reflect,\n    ownerSymbol        = Symbol('owner'),\n    typeSplitRe        = /[\\s,]+/;\n/**\n * This mixin is applied to base classes of a type that will be dynamically created by type name aliases.\n *\n * ```javascript\n *  class Layout extends Base.mixin(Factoryable) {\n *      static get factoryable() {\n *          return {\n *              defaultType : 'default'\n *          };\n *      }\n *\n *      static get type() {\n *          return 'default';\n *      }\n *  }\n *\n *  class Fit extends Layout {\n *      static get type() {\n *          return 'fit';\n *      }\n *  }\n * ```\n *\n * Once a family of classes has been defined, instances are created using the `create()` method:\n *\n * ```javascript\n *  const layout = Layout.create(config);\n * ```\n *\n * In the above example, `config` can be a type name (such as \"fit\") or a config object with a `type` property that\n * holds the type name.\n *\n * Factories can also extend other factories. For example, one factory creates objects that are useful across a wide\n * range of consumers, and a second factory creates objects for a more specialized consumer. If that specialized\n * consumer can also consume objects from the first factory, then the second factory can specify this relationship:\n *\n * ```javascript\n *  class General extends Base.mixin(Factoryable) {\n *      ...\n *  }\n *\n *  class Specialized extends Base.mixin(Factoryable) {\n *      static get factoryable() {\n *          return {\n *              extends : General,\n *              ...\n *          };\n *      }\n *  }\n * ```\n *\n * The `extends` factoryable option can be either a class that mixes in `Factoryable` or an array of such classes.\n * @mixin\n * @internal\n */\nexport default Target => class Factoryable extends (Target || Base) {\n    static get $name() {\n        return 'Factoryable';\n    }\n    static get declarable() {\n        return [\n            /**\n             * This property getter returns options that control the factory process. This property getter must be\n             * defined by the class that mixes in `Factoryable` in order to initialize the factory properly.\n             * ```\n             *  static get factoryable() {\n             *      return {\n             *          defaultType : 'default'\n             *      };\n             *  }\n             * ```\n             * If there are no special options to provide, this method can return nothing (`undefined`):\n             * ```\n             *  static get factoryable() {\n             *      // initialize the factory with all default options\n             *  }\n             * ```\n             * @static\n             * @member {Object} factoryable\n             * @property {Boolean} [factoryable.caseless=true] Specify `false` to use case-sensitive type names. The\n             * default is to ignore case.\n             * @property {String} [factoryable.defaultType=null] The default type to create when a config object has\n             * no `typeKey` property.\n             * @property {Function|Function[]} [factoryable.extends] One or more classes that mix in `Factoryable` to\n             * use for resolving type names when a type name is not found in this factory.\n             * @property {String} [factoryable.typeKey='type'] The name of the property in a config object that holds\n             * the type name.\n             * @internal\n             */\n            'factoryable',\n            /**\n             * One or more additional type name aliases for this class. This can be useful for renaming and maintaining\n             * a previous type name.\n             * ```\n             *  class Fit extends Layout {\n             *      static get type() {\n             *          return 'fit';\n             *      }\n             *\n             *      static get alias() {\n             *          return 'fill';  // deprecated type name (now known as 'fit')\n             *      }\n             *  }\n             * ```\n             * @static\n             * @member {String|String[]} alias\n             * @internal\n             */\n            'alias',\n            /**\n             * The (canonical) type name for this class by which instances can be created using the static\n             * {@link #function-create-static create()} method.\n             * @static\n             * @member {String} type\n             */\n            'type'\n        ];\n    }\n    /**\n     * Registers a class (`cls`) associated with the given `type`.\n     * @param {String|String[]} type A string, array of strings or a comma-separated string containing the type names\n     * for the specified `cls` class.\n     * @param {Function} cls The class (constructor function)\n     * @param {Boolean} [replace] Pass `true` to overwrite existing registered types. Otherwise, this method will throw\n     * an exception if the `type` is already registered with this factory.\n     * @internal\n     */\n    static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {\n        // `replace` default value is set to true while we are run inside a bryntum demo where code editor changes might\n        // lead to same widget class being registered over and over.\n        const\n            { factoryable }        = this.initClass(),\n            { caseless, registry } = factoryable,\n            types                  = StringHelper.split(type, typeSplitRe);  // if type is a string[] it will just be returned\n        for (let lower, name, i = 0; i < types.length; ++i) {\n            name = types[i];\n            lower = caseless ? name.toLowerCase() : name;\n            if (!replace && lower in registry) {\n                throw new Error(`Type \"${name}\" already registered with ${factoryable.class.name} factory`);\n            }\n            // Ensure class being registered is initialized. (initClass returns the class)\n            registry[name] = registry[lower] = cls.initClass();\n        }\n    }\n    /**\n     * Returns `true` if the passed instance is of the passed type or of a derived class.\n     * @param {Object} instance The object to test.\n     * @param {String} type The type to test against\n     */\n    static isA(instance, type) {\n        return this.isType(instance, type, true);\n    }\n    /**\n     * Returns `true` if the passed instance is of the passed type.\n     * @param {Object} instance The object to test.\n     * @param {String} type The type to test against\n     * @param {Boolean} [deep] Pass `true` to return `true` if the class is a subclass of the passed type.\n     */\n    static isType(instance, type, deep) {\n        const\n            { factoryable }        = this,\n            { caseless, registry } = factoryable,\n            typeCls                = registry[caseless ? type.toLowerCase() : type];\n        // If the type to be tested against maps to a class, see if the instance is an instanceof that\n        if (typeCls) {\n            if (deep) {\n                return instance instanceof typeCls;\n            }\n            return instance.constructor === typeCls;\n        }\n        return false;\n    }\n    static setupAlias(cls) {\n        cls.register(cls.alias, cls);\n    }\n    static setupFactoryable(cls, meta) {\n        const superClass = meta.super.class;\n        let { factoryable } = cls;\n        factoryable = {\n            caseless    : true,\n            defaultType : null,\n            extends     : superClass.factoryable ? [superClass] : null,\n            typeKey     : 'type',\n            ...factoryable\n        };\n        factoryable.class = cls;\n        factoryable.registry = Object.create(null);\n        if (factoryable.extends && !Array.isArray(factoryable.extends)) {\n            factoryable.extends = [factoryable.extends];\n        }\n        // Replace the class/static getter with a new one that returns the complete factoryable object:\n        defineProperty(cls, 'factoryable', {\n            get() {\n                return factoryable;\n            }\n        });\n    }\n    static setupType(cls, meta) {\n        const { type } = cls;\n        cls.register(type, cls, meta.replaceType);\n        // Copy the static type property onto the prototype as a readonly property:\n        defineProperty(cls.prototype, 'type', {\n            value : type\n        });\n    }\n    /**\n     * Creates an instance from this factory, given the type name or a config object.\n     * @param {String|Object} config The type name string or config object.\n     * @param {String|Function|Object} [options] Creation options (for details see {@link #function-reconfigure-static}).\n     * @returns {Object}\n     */\n    static create(config, options) {\n        return this.reconfigure(null, config, options);\n    }\n    /**\n     * Reconfigures an optional existing instance based on the provided config and returns the correctly configured\n     * instance. This will be the `existingInstance` if the `config` does not specify a different type.\n     *\n     * If `config` is `null` (or simply falsy), this method will destroy the `existingInstance` (if any) and return\n     * `null`.\n     *\n     * If there is no `existingInstance`, the config must specify a type. That is, it must be a string (the type name)\n     * or an object containing a `type` property, the `defaultType` must be provided or the factory itself must have\n     * a `defaultType` specified (see {@link #property-factoryable-static}).\n     *\n     * When an `existingInstance` is provided and a type is specified, the instance will be reconfigured via `setConfig`\n     * if it is of that type. Otherwise, the `existingInstance` is destroyed (if it is owned by the `options.owner`)\n     * and a new instance of the correct type is created.\n     *\n     * @param {Object} existingInstance The instance to reconfigure. This can be `null`.\n     *\n     * @param {String|Object} config The type name string or config object.\n     *\n     * @param {String|Function|Object} [options] Additional options to control the reconfiguration process. If this\n     * value is a string or a class constructor, it treated as `options.type`. If this value is a class instance, it\n     * is used as the `options.owner`. If this is a function, it is treated as `options.setup`. NOTE: functions declared\n     * using the `function` keyword are equivalent to class constructors. Use an arrow function or a class method to\n     * avoid this when a `setup` function is intended.\n     *\n     * @param {String|Function} [options.type] The default type to use if the `config` object does not specify a type.\n     *\n     * @param {Object} [options.owner] The owner of any created instances. If the `existingInstance` is being replaced,\n     * this value determines if the instance will be destroyed.\n     *\n     * @param {Object} [options.defaults] A config object of default values to use when creating a new instance.\n     *\n     * @param {Function|String} [options.setup] A function or the name of a method (on the `options.owner`) to call\n     * prior to creating a new instance. It is passed the config object that will be used to create the instance. If a\n     * truthy value is returned, that value is passed to the constructor instead of the provided config object.\n     *\n     * @param {Function|String} [options.transform] A function or the name of a method (on the `options.owner`) to call\n     * with the raw config object prior to processing and the value it returns replaces the raw value. This function is\n     * used to transform strings or arrays (for example) into proper config objects.\n     *\n     * @param {Function|String} [options.cleanup] A function or the name of a method (on the `options.owner`) to call\n     * prior to destroying the `existingInstance`. The `existingInstance` is passed as the sole argument.\n     *\n     * @returns {Object} The reconfigured instance (either `existingInstance` or a new instance of the desired type)\n     */\n    static reconfigure(existingInstance, config, options) {\n        const\n            me              = this,\n            { factoryable } = me,\n            { typeKey }     = factoryable;\n        let defaultType = options,\n            cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;\n        // Pick apart the options and set the vars accordingly\n        if (options && !ObjectHelper.isClass(options)) {  // if (options is not the defaultType)\n            defaultType = null;\n            t = typeof options;\n            if (t === 'function') {\n                setup = options;\n            }\n            else if (t === 'string') {\n                defaultType = options;\n            }\n            else if (ObjectHelper.isObject(options)) {\n                cleanup     = options.cleanup;\n                defaults    = options.defaults;\n                owner       = options.owner;\n                setup       = options.setup;\n                defaultType = options.type;\n                transform   = options.transform;\n            }\n            else {\n                owner = options;\n            }\n        }\n        if (transform) {\n            config = (typeof transform === 'string') ? owner[transform](config) : transform(config);\n        }\n        type = config;\n        // Figure out config... it's either a type (string), a config object or the actual instance.\n        if (typeof type === 'string') {\n            config = {};\n        }\n        else if (config) {\n            if (config === true) {\n                config = {};\n            }\n            if (!ObjectHelper.isObject(config)) {\n                // If we are being given an instance (not a config object), discard or destroy the existingInstance\n                if (owner && config !== existingInstance && existingInstance?.[ownerSymbol] === owner) {\n                    (typeof cleanup === 'string') ? owner[cleanup](existingInstance) : cleanup?.(existingInstance);\n                    existingInstance.destroy();\n                }\n                return config;\n            }\n            type = config[typeKey];\n        }\n        type = type && me.resolveType(type);\n        // We've got our orders... make it so...\n        if (existingInstance) {\n            // We can have a type-less config object when reconfiguring an existing instance, but if we have a type,\n            // the existingInstance must be of that type. If !config that means we are nulling out.\n            if (config && (!type || existingInstance.constructor === type)) {\n                if (typeKey in config) {\n                    config = ObjectHelper.assign({}, config);\n                    delete config[typeKey];  // so \"type\" won't be processed as a config property\n                }\n                existingInstance.setConfig(config);\n                return existingInstance;\n            }\n            if (owner && existingInstance[ownerSymbol] === owner) {\n                (typeof cleanup === 'string') ? owner[cleanup](existingInstance) : cleanup?.(existingInstance);\n                existingInstance.destroy();\n            }\n        }\n        if (config) {\n            if (defaults) {\n                if (!(mergeType = type)) {\n                    if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {\n                        throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);\n                    }\n                    mergeType = me.resolveType(mergeType);\n                }\n                if (mergeType) {\n                    // Allow the merge fn of each config to perform the task:\n                    config = mergeType.mergeConfigs(defaults, config);\n                }\n            }\n            if (setup) {\n                prepared = (typeof setup === 'string') ? owner[setup](config, type, defaults) : setup(config, type, defaults);\n                if (prepared === null) {\n                    return prepared;\n                }\n                config = prepared || config;\n            }\n            if (!type) {\n                // One more check on config[typeKey] since the setup() function may have added it...\n                if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {\n                    throw new Error(`No default type defined for ${factoryable.class.name} factory`);\n                }\n                type = me.resolveType(type);\n            }\n            if (defaults && !mergeType) {\n                config = type.mergeConfigs(defaults, config);\n            }\n            if (typeKey in config) {\n                config = ObjectHelper.assign({}, config);\n                delete config[typeKey];  // so \"type\" won't be processed as a config property\n            }\n            config = new type(config);\n            if (owner) {\n                config[ownerSymbol] = owner;\n            }\n        }\n        return config || null;\n    }\n    /**\n     * This method returns the constructor of the class registered for the given type name.\n     * @param {String} type The type name to look up.\n     * @param {Boolean} [optional] Pass `true` to return `null` if `type` is not found instead of throwing an exception.\n     * @returns {Function}\n     */\n    static resolveType(type, optional) {\n        if (typeof type !== 'string') {\n            return type;\n        }\n        const\n            { factoryable } = this,\n            bases           = factoryable.extends;\n        let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type],\n            i;\n        for (i = 0; !result && bases && i < bases.length; ++i) {\n            // Pass optional=true to base factory so the error is our own should the lookup fail:\n            result = bases[i].resolveType(type, /* optional = */true);\n        }\n        if (!result && !optional) {\n            throw new Error(`Invalid type name \"${type}\" passed to ${factoryable.class.name} factory`);\n        }\n        return result;\n    }\n};\n", "import Base from '../../Base.js';\nimport Factoryable from '../../mixin/Factoryable.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\n/**\n * @module Core/data/field/DataField\n */\nconst { getOwnPropertyDescriptor } = Reflect;\n/**\n * This is the base class for Model field classes. A field class defines how to handle the data for a particular type\n * of field. Many of these behaviors can be configured on individual field instances.\n *\n * @extends Core/Base\n * @datafield\n */\nexport default class DataField extends Base.mixin(Factoryable) {\n    static get $name() {\n        return 'DataField';\n    }\n    static get type() {\n        return 'auto';\n    }\n    static get factoryable() {\n        return {\n            defaultType : 'auto'\n        };\n    }\n    static get prototypeProperties() {\n        return {\n            /**\n             * The name of the field.\n             * @config {String} name\n             */\n            /**\n             * The label text for a form item generated for this field. This is also used to create\n             * a column header for a {@link #config-column} for this field.\n             * @config {String} label\n             */\n            /**\n             * A column config object for a column to display this field in a grid. For simple, atomic\n             * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional\n             * and the appropriate column type can be inferred.\n             *\n             * This also provides default values for column configuration if a configured column definition\n             * for a grid lacks a property.\n             *\n             * For complex fields, such as identifiers which link to other records, a more capable\n             * column type may be specified, for example a `type : `number'` field may be configured\n             * with\n             *\n             * ```javascript\n             * column : 'percent'\n             * ```\n             * or\n             * ```javascript\n             * column : {\n             *     type : 'percent',\n             *     width : 100\n             * }\n             * ```\n             * if it represents a percentage vaue and needs appropriate rendering and editing.\n             * @config {String|Object} column\n             */\n            /**\n             * A config object for a widget to edit this field in a form. For simple, atomic\n             * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional\n             * and the appropriate input widget type can be inferred.\n             *\n             * For complex fields, such as identifiers which link to other records, a more capable\n             * widget may be specified.\n             * @config {String|InputFieldConfig} editor\n             * @private\n             */\n            /**\n             * A function that compares two values and returns a value < 0 if the first is less than the second, or 0\n             * if the values are equal, or a value > 0 if the first is greater than the second.\n             * @config {Function}\n             * @default\n             */\n            compare : null,\n            /**\n             * A function that compares two objects or records using the `compare` function on the properties of each\n             * objects based on the `name` of this field.\n             * @config {Function}\n             * @default\n             * @internal\n             */\n            compareItems : null,\n            /**\n             * The property in a record's data object that contains the field's value.\n             * Defaults to the field's `name`.\n             * @config {String}\n             */\n            dataSource : null,\n            /**\n             * The default value to assign to this field in a record if no value is provided.\n             * @config {*} defaultValue\n             */\n            /**\n             * Setting to `true` will ensure this field is included in any update/insert request payload\n             * when a Store / Project / CrudManager performs a request.\n             * @config {Boolean}\n             * @default\n             */\n            alwaysWrite : false,\n            /**\n             * Setting to `false` indicates that `null` is not a valid value.\n             * @config {Boolean}\n             * @default\n             */\n            nullable : true,\n            /**\n             * The value to return from {@link #function-print} for a `null` or `undefined` value.\n             * @config {String}\n             * @default\n             */\n            nullText : null,\n            /**\n             * The value to replace `null` when the field is not `nullable`.\n             * @config {*}\n             * @default\n             */\n            nullValue : undefined,\n            /**\n             * Set to `false` to exclude this field when saving records to a server.\n             * @config {Boolean}\n             * @default\n             */\n            persist : true,\n            /**\n             * Set to `true` for the field's set accessor to ignore attempts to set this field.\n             * @config {Boolean}\n             * @default\n             */\n            readOnly : false,\n            /**\n             * By default, defined {@link Core.data.Model} fields may be used to create a grid column\n             * suitable for diplaying that field in a grid cell. Some fields may not be suitable for\n             * features which automatically generate columns for view. These fields are created using\n             * `internal : true`. Some examples are the `expanded` and `rowHeight` fields which are used\n             * internally.\n             * @config {Boolean}\n             * @default\n             */\n            internal : false\n        };\n    }\n    /**\n     * The class that first defined this field. Derived classes that override a field do not change this property.\n     * @member {Core.data.Model} definedBy\n     * @private\n     * @readonly\n     */\n    /**\n     * The class that most specifically defined this field. Derived classes that override a field set this property to\n     * themselves.\n     * @member {Core.data.Model} owner\n     * @private\n     * @readonly\n     */\n    // NOTE: Since we create lots of instances, they have no life cycle (they are not destroyed) and are readonly after\n    // creation, this class does not use configurable.\n    construct(config) {\n        const me = this;\n        if (config) {\n            me.name = config.name;  // assign name first for diagnostic reasons\n            Object.assign(me, config);\n        }\n        if (me.compare) {\n            // We wrap in this way to allow compareItems() to be used as an array sorter fn (which gets no \"this\"):\n            me.compareItems = (itemA, itemB) => me.compare(itemA?.[me.name], itemB?.[me.name]);\n        }\n    }\n    /**\n     * This method transforms a data value into the desired form for storage in the record's data object.\n     *\n     * ```javascript\n     * export default class Task extends TaskModel {\n     *    static get fields() {\n     *        return [\n     *            {\n     *                name    : 'status',\n     *                convert : (value, data) => {\n     *                    if (value >= 100) {\n     *                        return 'done';\n     *                    }\n     *                    else if (value > 0) {\n     *                        return 'started';\n     *                    }\n     *                }\n     *            }\n     *        ];\n     *    }\n     * }\n     * ```\n     *\n     * @method convert\n     * @param {*} value The value to convert for storage in a record.\n     * @param {Object} data The raw record data object\n     * @returns {*} The converted value.\n     */\n    /**\n     * This method transforms a data value into the desired form for transmitting to a server.\n     * @method serialize\n     * @param {*} value The value to serialize\n     * @param {Core.data.Model} record The record that contains the value being serialized.\n     * @returns {*} The serialized value.\n     */\n    /**\n     * This optional method is called when setting a data value on a record.\n     * @method set\n     * @param {*} value The value to set\n     * @param {Object} data The records future or current data object to set value to\n     * @param {Core.data.Model} record The record that owns or will own the data object\n     * @internal\n     */\n    /**\n     * This optional method is called when a record using this field is created.\n     * @method init\n     * @param {Core.data.Model} record The record being created\n     * @internal\n     */\n    /**\n     * Create getter and setter functions for the specified field name under the specified key.\n     * @internal\n     */\n    defineAccessor(target, force) {\n        const { name, dataSource } = this;\n        // Bail out if trying to override an explicitly defined accessor\n        if (\n            !force &&\n            name in target &&\n            target.$meta.hierarchy.some(current => getOwnPropertyDescriptor(current.prototype, name)?.enumerable === false)\n        ) {\n            return;\n        }\n        Reflect.defineProperty(target, name, {\n            configurable : true, // To allow removing it later\n            enumerable   : true,\n            // no arrow functions here, need `this` to change to instance\n            get : this.complexMapping\n                ? function() {\n                    return this.complexGet(name, dataSource);\n                }\n                : function() {\n                    // Inlined copy of Model#flatGet, to save a fn call since this is hit very often\n                    // When changes are batched, they get stored by field name, not dataSource\n                    if (this.batching && name in this.meta.batchChanges) {\n                        return this.meta.batchChanges[name];\n                    }\n                    return dataSource in this.data ? this.data[dataSource] : this.data[name];\n                },\n            // no arrow functions here, need `this` to change to instance\n            set(value) {\n                // Since the accessor is defined on a base class, we dip into the fields map for the actual\n                // calling class to get the correct field definition\n                const field = this.$meta.fields.map[name];\n                // Only set if field is read/write. Privately, we use setData to set its value\n                if (!(field && field.readOnly)) {\n                    this.set(name, value);\n                }\n            }\n        });\n    }\n    /**\n     * Compares two values for this field and returns `true` if they are equal, and `false` if not.\n     * @param {*} first The first value to compare for equality.\n     * @param {*} second The second value to compare for equality.\n     * @returns {Boolean} `true` if `first` and `second` are equal.\n     */\n    isEqual(first, second) {\n        return ObjectHelper.isEqual(first, second);\n    }\n    /**\n     * Returns the given field value as a `String`. If `value` is `null` or `undefined`, the value specified by\n     * {@link #config-nullText} is returned.\n     * @param {*} value The value to convert to a string.\n     * @returns {String}\n     */\n    print(value) {\n        return (value == null) ? this.nullText : this.printValue(value);\n    }\n    /**\n     * Returns the given, non-null field value as a `String`.\n     * @param {*} value The value to convert to a string (will not be `null` or `undefined`).\n     * @returns {String}\n     * @protected\n     */\n    printValue(value) {\n        return String(value);\n    }\n}\nDataField._$name = 'DataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/ArrayDataField\n */\n/**\n * This field class handles fields that hold an array.\n *\n * ```javascript\n * class Task extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             // Array field\n *             { name : 'todo', type : 'array' }\n *         ];\n *     }\n * }\n * ```\n *\n * A record can be constructed like this:\n *\n * ```javascript\n * const task = new Task({\n *     name : 'Task 1',\n *     todo : [\n *         { text : 'Something', done : false },\n *         { text : 'Some other thing', done : true }\n *     ]\n * };\n * ```\n *\n * Or by populating a store:\n *\n * ```javascript\n * const store = new Store({\n *     modelClass : Task,\n *     data : [\n *         {\n *             name : 'Task 1',\n *             todo : [\n *                 { text : 'Something', done : false },\n *                 { text : 'Some other thing', done : true }\n *             ]\n *         },\n *         ...\n *     ]\n * });\n * ```\n *\n * For the field to count as modified, the whole array has to be replaced:\n *\n * ```javascript\n * // This won't be detected as a modification\n * task.todo[0].done = true;\n * // task.isModified === false\n *\n * // But this will\n * const todo = task.todo.slice(); // Create a new array with same contents\n * todo[0].done = true;\n * task.todo = todo;\n * // task.isModified === true\n * ```\n *\n * @extends Core/data/field/DataField\n * @classtype array\n * @datafield\n */\nexport default class ArrayDataField extends DataField {\n    static get $name() {\n        return 'ArrayDataField';\n    }\n    static get type() {\n        return 'array';\n    }\n    isEqual(a, b) {\n        return a === b;\n    }\n}\nArrayDataField.initClass();\nArrayDataField._$name = 'ArrayDataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/BooleanDataField\n */\n/**\n * This field class handles field of type `Boolean`.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'active', type : 'boolean' }\n *         ];\n *     }\n * }\n * ```\n *\n * When a field is declared as a `'boolean'`, non-null values are promoted to `Boolean` type. This is seldom required,\n * but can be useful if a field value is received as a number but should be treated as a boolean.\n *\n * @extends Core/data/field/DataField\n * @classtype boolean\n * @datafield\n */\nexport default class BooleanDataField extends DataField {\n    static get $name() {\n        return 'BooleanDataField';\n    }\n    static get type() {\n        return 'boolean';\n    }\n    static get alias() {\n        return 'bool';\n    }\n    static get prototypeProperties() {\n        return {\n            /**\n             * The value to replace `null` when the field is not `nullable`.\n             * @config {Boolean}\n             * @default\n             */\n            nullValue : false\n        };\n    }\n    isEqual(first, second) {\n        if (first == null && second == null) {\n            return true;\n        }\n        return super.isEqual(first, second);\n    }\n    convert(value) {\n        if (value == null) {\n            return this.nullable ? value : this.nullValue;\n        }\n        // string 'false' will convert to false, other strings to true\n        if (value.toLowerCase?.() === 'false') {\n            return false;\n        }\n        return Boolean(value);\n    }\n}\nBooleanDataField.initClass();\nBooleanDataField._$name = 'BooleanDataField';", "import DataField from './DataField.js';\nimport DateHelper from '../../helper/DateHelper.js';\n/**\n * @module Core/data/field/DateDataField\n */\n/**\n * This field class handles field of type `Date`.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'birthday', type : 'date', format : 'YYYY-MM-DD' },\n *             { name : 'age', readOnly : true }\n *         ];\n *     }\n * }\n * ```\n *\n * When a field is declared as a `'date'`, non-null values are promoted to `Date` type. This is frequently needed due\n * to how date types are serialized to JSON strings.\n *\n * Date fields can have a special `defaultValue` of `'now'` which will convert to the current date/time.\n *\n * @extends Core/data/field/DataField\n * @classtype date\n * @datafield\n */\nexport default class DateDataField extends DataField {\n    static get $name() {\n        return 'DateDataField';\n    }\n    static get type() {\n        return 'date';\n    }\n    static get prototypeProperties() {\n        return {\n            /**\n             * The format of the date field.\n             *\n             * See {@link Core.helper.DateHelper DateHelper} for details.\n             * @config {String} format\n             * @default DateHelper.defaultFormat\n             */\n            format : null\n        };\n    }\n    convert(value) {\n        if (value == null) {\n            if (!this.nullable) {\n                value = this.nullValue;\n            }\n        }\n        else if (value === 'now') {\n            value = new Date();\n        }\n        else if (!(value instanceof Date)) {\n            // Use configured format, if null/undefined use DateHelpers default format\n            value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);\n            // if parsing has failed, we would like to return `undefined` to indicate the \"absence\" of data\n            // instead of `null` (presence of \"empty\" data)\n            if (!value || isNaN(value)) {\n                value = undefined;\n            }\n        }\n        return value;\n    }\n    serialize(value) {\n        if (value instanceof Date) {\n            // Use configured format or DateHelpers default one\n            value = DateHelper.format(value, this.format || DateHelper.defaultFormat);\n        }\n        return value;\n    }\n    printValue(value) {\n        return DateHelper.format(value, this.format || DateHelper.defaultFormat);\n    }\n}\nDateDataField.initClass();\nDateDataField._$name = 'DateDataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/StringDataField\n */\n/**\n * This field class handles field of type `String`.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             { name : 'name', type : 'string' }\n *         ];\n *     }\n * }\n * ```\n *\n * When a field is declared as a `'string'`, non-null values are promoted to `String` type. This is seldom required, but\n * can be useful if a field value is received as a number but should be treated as a string.\n *\n * @extends Core/data/field/DataField\n * @classtype string\n * @datafield\n */\nexport default class StringDataField extends DataField {\n    static get $name() {\n        return 'StringDataField';\n    }\n    static get type() {\n        return 'string';\n    }\n    static get prototypeProperties() {\n        return {\n            /**\n             * The value to replace `null` when the field is not `nullable`.\n             * @config {String}\n             * @default\n             */\n            nullValue : ''\n        };\n    }\n    convert(value) {\n        return (value == null) ? (this.nullable ? value : this.nullValue) : String(value);\n    }\n}\nStringDataField.initClass();\nStringDataField._$name = 'StringDataField';", "import DateHelper from '../../helper/DateHelper.js';\nimport StringDataField from './StringDataField.js';\n/**\n * @module Core/data/field/DurationUnitDataField\n */\n/**\n * This field class handles field of type `durationunit` (string type). See {@link Core.data.Duration} for more information.\n *\n * ```javascript\n * class Event extends Model {\n *     static get fields() {\n *         return [\n *             { name : 'durationUnit', type : 'durationunit' }\n *         ];\n *     }\n * }\n * ```\n *\n * @extends Core/data/field/StringDataField\n * @classtype durationunit\n * @datafield\n */\nexport default class DurationUnitDataField extends StringDataField {\n    static get $name() {\n        return 'DurationUnitDataField';\n    }\n    static get type() {\n        return 'durationunit';\n    }\n    isEqual(first, second) {\n        return DateHelper.compareUnits(first, second) === 0;\n    }\n}\nDurationUnitDataField.initClass();\nDurationUnitDataField._$name = 'DurationUnitDataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/IntegerDataField\n */\n/**\n * This field class handles field of type `Number` with no decimal digits.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'age', type : 'int' }\n *         ];\n *     }\n * }\n * ```\n *\n * When a field is declared as a `'int'`, non-null values are promoted to `Number` type and decimals are removed using\n * a specified `rounding`. This field type can be useful if a field value is received as a string but should be stored\n * as a number or has a fractional component that must be rounded or truncated.\n *\n * @extends Core/data/field/DataField\n * @classtype integer\n * @datafield\n */\nexport default class IntegerDataField extends DataField {\n    static get $name() {\n        return 'IntegerDataField';\n    }\n    static get type() {\n        return 'integer';\n    }\n    static get alias() {\n        return 'int';\n    }\n    static get prototypeProperties() {\n        return {\n            /**\n             * The value to replace `null` when the field is not `nullable`.\n             * @config {Number}\n             * @default\n             */\n            nullValue : 0,\n            /**\n             * The `Math` method to use to ensure fractional component is removed.\n             * @config {'round'|'floor'|'ceil'}\n             * @default\n             */\n            rounding : 'round'\n        };\n    }\n    convert(value) {\n        return (value == null) ? (this.nullable ? value : this.nullValue) : Math[this.rounding](Number(value));\n    }\n}\nIntegerDataField.initClass();\nIntegerDataField._$name = 'IntegerDataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/ModelDataField\n */\n/**\n * This field class handles fields that hold other records.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'address', type : 'model' }\n *         ];\n *     }\n * }\n * ```\n *\n * @internal\n * @extends Core/data/field/DataField\n * @classtype model\n * @datafield\n */\nexport default class ModelDataField extends DataField {\n    static get $name() {\n        return 'ModelDataField';\n    }\n    static get type() {\n        return 'model';\n    }\n    static get prototypeProperties() {\n        return {\n            complexMapping : true\n        };\n    }\n    isEqual(first, second) {\n        // Check for semantic equality. An instance of the same Model class of the same ID is equal.\n        return (first && second) && (second instanceof first.constructor) && second.id == first.id;\n    }\n}\nModelDataField.initClass();\nModelDataField._$name = 'ModelDataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/NumberDataField\n */\n/**\n * This field class handles field of type `Number`.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'age', type : 'number' }\n *         ];\n *     }\n * }\n * ```\n *\n * When a field is declared as a `'number'`, non-null values are promoted to `Number` type. This is seldom required, but\n * can be useful if a field value is received as a string but should be treated as a number.\n *\n * @extends Core/data/field/DataField\n * @classtype number\n * @datafield\n */\nexport default class NumberDataField extends DataField {\n    static get $name() {\n        return 'NumberDataField';\n    }\n    static get type() {\n        return 'number';\n    }\n    static get alias() {\n        return 'float';\n    }\n    static get prototypeProperties() {\n        return {\n            /**\n             * The value to replace `null` when the field is not `nullable`.\n             * @config {Number}\n             * @default\n             */\n            nullValue : 0,\n            /**\n             * The numeric precision of this field. Values are rounded to the specified number of digits. If `null`,\n             * the default, no rounding is performed.\n             * @config {Number}\n             * @default\n             */\n            precision : null\n        };\n    }\n    isEqual(first, second) {\n        // NaN !== NaN in JS which results having a number field w/ such value always dirty\n        // Not sure having two NaN-s not equal each other makes any sense here to us ..so handle it\n        return (isNaN(Number(first)) && isNaN(Number(second))) || super.isEqual(first, second);\n    }\n    convert(value) {\n        if (value == null) {\n            return this.nullable ? value : this.nullValue;\n        }\n        value = Number(value);\n        // Returning undefined to let set know that this is a invalid value\n        if (isNaN(value)) {\n            return;\n        }\n        let scale = this.precision;\n        if (scale) {\n            scale = 10 ** scale;\n            value = Math.round(value * scale) / scale;\n        }\n        else if (scale === 0) {\n            value = Math.round(value);\n        }\n        return value;\n    }\n}\nNumberDataField.initClass();\nNumberDataField._$name = 'NumberDataField';", "import DataField from './DataField.js';\n/**\n * @module Core/data/field/ObjectDataField\n */\n/**\n * This field class handles fields that hold an object.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'address', type : 'object' }\n *         ];\n *     }\n * }\n * ```\n *\n * For the field to count as modified, the whole object has to be replaced:\n *\n * ```javascript\n * person.address = { ...address };\n * ```\n *\n * @extends Core/data/field/DataField\n * @classtype object\n * @datafield\n */\nexport default class ObjectDataField extends DataField {\n    static get $name() {\n        return 'ObjectDataField';\n    }\n    static get type() {\n        return 'object';\n    }\n    static get prototypeProperties() {\n        return {\n            complexMapping : true\n        };\n    }\n}\nObjectDataField.initClass();\nObjectDataField._$name = 'ObjectDataField';", "import DataField from './DataField.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport StringHelper from '../../helper/StringHelper.js';\n/**\n * @module Core/data/field/StoreDataField\n */\n/**\n * This field class handles fields that accepts an array that is then converted to a store.\n *\n * ```javascript\n * class Task extends Model {\n *     static fields = [\n *         'name',\n *         // Store field\n *         { name : 'subTasks', type : 'store', storeClass : Store }\n *     ];\n * }\n * ```\n *\n * A record can be constructed like this:\n *\n * ```javascript\n * const task = new Task({\n *     name : 'Task 1',\n *     subTasks : [\n *         { text : 'Something', done : false },\n *         { text : 'Some other thing', done : true }\n *     ]\n * };\n * ```\n *\n * Or by populating a store:\n *\n * ```javascript\n * const store = new Store({\n *     modelClass : Task,\n *     data : [\n *         {\n *             name : 'Task 1',\n *             subTasks : [\n *                 { text : 'Something', done : false },\n *                 { text : 'Some other thing', done : true }\n *             ]\n *         },\n *         ...\n *     ]\n * });\n * ```\n *\n * Whenever the store or its records are manipulated, the field will be marked as modified:\n *\n * ```javascript\n * // These will all be detected as modifications\n * task.subTasks.first.done = true;\n * task.subTasks.last.remove();\n * task.subTasks.add({ text : 'New task', done : false });\n * ```\n *\n * @extends Core/data/field/DataField\n * @classtype store\n * @datafield\n */\nexport default class StoreDataField extends DataField {\n    static $name = 'StoreDataField';\n    static type = 'store';\n    /**\n     * Store class to use when creating the store.\n     *\n     * ```javascript\n     * class TodoStore extends Store {\n     *     ...\n     * }\n     *\n     * const task = new Store({\n     *     static fields = [\n     *         { type : 'store', name: 'todoItems', storeClass : TodoStore }\n     *     ]\n     * });\n     * ```\n     *\n     * @config {Class} storeClass\n     * @typings {typeof Store}\n     */\n    /**\n     * Model class to use for the store (can also be configured as usual on the store class, this config is for\n     * convenience).\n     *\n     * ```javascript\n     * class TodoItem extends Model {\n     *   ...\n     * }\n     *\n     * const task = new Store({\n     *     static fields = [\n     *         { type : 'store', name: 'todoItems', storeClass : Store, modelClass : TodoItem }\n     *     ]\n     * });\n     * ```\n     *\n     * @config {Class} modelClass\n     * @typings {typeof Model}\n     */\n    // Initializer, called when creating a record. Sets up the store and populates it with any initial data\n    init(data, record) {\n        const\n            me        = this,\n            storeName = `${me.name}Store`,\n            config    = { skipStack : true }; // Optimization when used from sources, don't create a stack in Base\n        // Optionally apply modelClass, for convenient configuration\n        if (me.modelClass) {\n            config.modelClass = me.modelClass;\n        }\n        // Call optional initializer (initSubTasksStore for subTasks field) on the record, letting it manipulate the\n        // config before creating a store\n        record[`init${StringHelper.capitalize(storeName)}`]?.(config);\n        if (!config.storeClass && !me.storeClass) {\n            throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);\n        }\n        // Store has to be assigned on the record, field is shared\n        const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);\n        if (me.complexMapping) {\n            ObjectHelper.setPath(data, me.dataSource, store);\n        }\n        else {\n            data[me.dataSource] = store;\n        }\n        // Don't warn about generated ids, responsibility lies elsewhere\n        store.verifyNoGeneratedIds = false;\n        // Keep track of if id should be included when serializing or not\n        store.usesId = !store.count || !store.every(record => record.hasGeneratedId);\n        // Cache value\n        store.$currentValue = me.getValue(store);\n        // Track changes to the store, applying them to the record and caching current value to be used when\n        // serializing and in comparisons (required, otherwise we would be comparing to already updated store\n        store.ion({\n            change : ({ action }) => {\n                const value = me.getValue(store);\n                if (!store.$isSettingStoreFieldData) {\n                    const oldPreserveCurrentDataset = store.$preserveCurrentDataset;\n                    store.$preserveCurrentDataset = me.subStore && (\n                        action === 'update' || action === 'remove' || action === 'add'\n                    );\n                    record.set(me.name, value);\n                    store.$preserveCurrentDataset = oldPreserveCurrentDataset;\n                }\n                // cache the field current value\n                store.$currentValue = value;\n            }\n        });\n    }\n    // Called when setting a new value to the field on a record\n    set(value, data, record) {\n        const\n            me        = this,\n            storeName = `${me.name}Store`,\n            { [storeName] : store } = record.meta;\n        // Lazy store might not be created yet, gets created on first access. Returning false keeps the value for later\n        // if called during init\n        if (!store) {\n            // Missing store suggests value was not yet initialized and future value resides\n            // in a special meta property. In which case we need to update it there\n            record.meta.initableValues.set(me, value);\n            return false;\n        }\n        // Prevent changes from leading to recursive calls\n        if (store.$isSettingStoreFieldData) {\n            return;\n        }\n        store.$isSettingStoreFieldData = true;\n        // Call optional processing fn (processSubTasksStoreData for subTasks field) on the record, letting it\n        // manipulate the data before creating records\n        value = record[`process${StringHelper.capitalize(storeName)}Data`]?.(value, record) ?? value;\n        // Apply incoming array to store\n        if (!store.$preserveCurrentDataset) {\n            store.data = value;\n        }\n        store.$isSettingStoreFieldData = false;\n        // Keep track of if id should be included when serializing or not\n        store.usesId = !store.count || !store.every(record => record.hasGeneratedId);\n    }\n    serialize(value, record) {\n        return record.meta[`${this.name}Store`].$currentValue;\n    }\n    // Extract persistable values, optionally including id depending on if ids are used\n    getValue(store) {\n        return store.allRecords.map(r => {\n            const data = r.persistableData;\n            if (!store.usesId) {\n                delete data.id;\n            }\n            return data;\n        });\n    }\n    isEqual(a, b) {\n        if (a?.isStore) {\n            a = a.$currentValue;\n        }\n        if (b?.isStore) {\n            b = b.$currentValue;\n        }\n        return ObjectHelper.isDeeplyEqual(a, b);\n    }\n    // Cloned value to be able to restore it later using STM\n    getOldValue(record) {\n        const store = record.meta[`${this.name}Store`];\n        return store ? ObjectHelper.clone(store.$currentValue) : null;\n    }\n}\nStoreDataField.initClass();\nStoreDataField._$name = 'StoreDataField';", "import Base from '../Base.js';\nimport ArrayHelper from '../helper/ArrayHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport ModelStm from './stm/mixin/ModelStm.js';\nimport TreeNode from './mixin/TreeNode.js';\nimport ModelLink from './mixin/ModelLink.js';\nimport DataField from './field/DataField.js';\n// The built-in model field types:\nimport './field/ArrayDataField.js';\nimport './field/BooleanDataField.js';\nimport './field/DateDataField.js';\nimport './field/DurationUnitDataField.js';\nimport './field/IntegerDataField.js';\nimport './field/ModelDataField.js';\nimport './field/NumberDataField.js';\nimport './field/ObjectDataField.js';\nimport './field/StoreDataField.js';\nimport './field/StringDataField.js';\n/**\n * @module Core/data/Model\n */\n/**\n * Defines the properties of a relation between two stores.\n *\n * Used as the values of a Model's {@link Core.data.Model#property-relations-static} definition.\n *\n * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It will\n * point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id matching the\n * players `teamId` field. The team record in turn, will have a field called `players` which is a collection of all\n * players in the team.\n *\n * ```javascript\n * class Player extends Model {\n *     static relations = {\n *         team : {\n *             foreignKey            : 'teamId',\n *             foreignStore          : 'teamStore',\n *             relatedCollectionName : 'players'\n *         }\n *     }\n * }\n * ```\n *\n * See {@link Core.data.Model#property-relations-static} for a more extensive example.\n *\n * @typedef {Object} RelationConfig\n * @property {String} foreignKey Name of a field on this model which holds the foreign key value.\n * @property {String|Core.data.Store} foreignStore Name of a property on the model's first store, which holds the\n * foreign store. Or the actual store instance\n * @property {String} [relatedCollectionName] Optionally, name of a property that will be added to the records of the\n * foreign store, which will hold all records from the model's store related to it.\n */\nconst\n    { defineProperty } = Reflect,\n    { hasOwn }         = ObjectHelper,\n    _undefined         = undefined,\n    internalProps      = {\n        children : 1,\n        data     : 1,\n        meta     : 1\n    },\n    abbreviationFields = [\n        'name',\n        'title',\n        'text',\n        'label',\n        'description'\n    ],\n    fieldDataTypes = {\n        boolean : 1,\n        number  : 1,\n        date    : 1,\n        object  : 1\n    },\n    fieldsOrder = {\n        parentId   : 1,\n        $PhantomId : 2,\n        id         : 3\n    };\n/**\n * A Model is the definition of a record which can be added to (or loaded into) a {@link Core.data.Store}. It defines\n * which fields the data contains and exposes an interface to access and manipulate that data. The Model data is\n * populated through simple a JSON object.\n *\n * By default, a Model stores a shallow copy of its raw json, but for records in stores configured with\n * `useRawData: true` it stores the supplied json object as is.\n *\n * ## Defining fields\n *\n * A Model can either define its fields explicitly (see {@link #property-fields-static}) or have them created from its\n * data (see {@link #property-autoExposeFields-static}). This snippet shows a model with 4 fields defined explicitly:\n *\n * ```javascript\n * class Person extends Model {\n *     static fields = [\n *         'name',\n *         { name : 'birthday', type : 'date', format : 'YYYY-MM-DD' },\n *         { name : 'shoeSize', type : 'number', defaultValue : 11 },\n *         { name : 'age', readOnly : true }\n *     ]\n * }\n * ```\n *\n * The first field (name) has an unspecified type, which means the field's value is held as received with no conversion\n * applied. The second field (birthday) is defined to be a date, which will make the model parse any supplied value into\n * an actual date. The parsing is handled by {@link Core/helper/DateHelper#function-parse-static DateHelper.parse()}\n * using the specified `format`, or if no format is specified using\n * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n *\n * The set of standard field types is as follows:\n *\n *  - {@link Core.data.field.ArrayDataField `array`}\n *  - {@link Core.data.field.BooleanDataField `boolean`}\n *  - {@link Core.data.field.DateDataField `date`}\n *  - {@link Core.data.field.IntegerDataField `integer`}\n *  - {@link Core.data.field.ObjectDataField `object`}\n *  - {@link Core.data.field.NumberDataField `number`}\n *  - {@link Core.data.field.StoreDataField `store`}\n *  - {@link Core.data.field.StringDataField `string`}\n *\n * You can also set a `defaultValue` that will be used if the data does not contain a value for the field:\n *\n * ```javascript\n * { name : 'shoeSize', type : 'number', defaultValue : 11 }\n * ```\n *\n * To create a record from a Model, supply data to its constructor:\n *\n * ```javascript\n * let guy = new Person({\n *     id       : 1,\n *     name     : 'Dude',\n *     birthday : '2014-09-01'\n * });\n * ```\n *\n * If no id is specified, a temporary id based on a UUID will be generated. This id is not meant to be serialized, it\n * should instead be replaced by the backend with a proper id from the underlying database (or similar).\n *\n * Please avoid using reserved names for your fields (such as `parent`, `children` and others that are used as Model\n * properties) to avoid possible data collisions and bugs.\n *\n * ## Nested fields\n *\n * Model supports mapping fields to nested data structures using dot `.` separated paths as the `dataSource`. For\n * example given this JSON object:\n *\n * ```json\n * {\n *     name : 'Borje Salming',\n *     team : {\n *         name   : 'Toronto Maple Leafs',\n *         league : 'NHL'\n *     }\n * }\n * ```\n *\n * A field can be mapped to the nested team name by using `dataSource : 'team.name'`:\n *\n * ```javascript\n * class Player extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             // Field mapped to a property on a nested object\n *             { name : 'teamName', dataSource : 'team.name' }\n *         ]\n *     }\n * }\n * ```\n *\n * Usage:\n *\n * ```javascript\n * const player = new Player(json);\n *\n * console.log(player.teamName); // > Toronto Maple Leafs\n * player.teamName = 'Minnesota Wild'; // Updates name property of the team object\n * ```\n *\n * ### Updating a nested object\n *\n * Note that directly altering a property of the nested object won't register as an update of the record, record does not\n * track changes deeply. If nested fields (as described above) is not enough for your usecase you can map a field\n * directly to the nested object and then assign a shallow copy of it to the record on changes:\n *\n * ```javascript\n * class Player extends Model {\n *     static get fields() {\n *         return [\n *             ...,\n *             // Field mapped directly to the nested object\n *             { name : 'team', type : 'object' }\n *         ]\n *     }\n * }\n *\n * // \"External object\" to nest\n * const team = {\n *     name   : 'Brynas',\n *     league : 'SHL'\n * }\n *\n * const player = new Player({\n *     name : 'Borje Salming',\n *     team\n * });\n *\n * // This will not flag player as dirty\n * team.league = 'CHL';\n *\n * // Instead you have to reassign the mapped field\n * player.team = { ...player.team };\n * ```\n *\n * ## Arrays of atomic types\n *\n * When a field holds an array of atomic types (strings, numbers etc.) we recommend using the\n * {@link Core/data/field/ArrayDataField `array`} type for the field:\n *\n * ```javascript\n * class GroceryList extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'items', type : 'array' }\n *         ];\n *     }\n * }\n *\n * const list = new GroceryList({\n *    name  : 'My list',\n *    items : ['Milk', 'Bread', 'Eggs']\n * });\n * ```\n *\n * <div class=\"note\">Modifying items in the array will not flag the field as updated, since the array itself does not\n * change. For it to register a change, you must assign it a new array (could be a copy of the old one). For more info,\n * see {@link Core/data/field/ArrayDataField}</div>\n *\n * ## Arrays of objects\n *\n * When a field holds an array of objects, we recommend using the {@link Core/data/field/StoreDataField `store`} type\n * for the field:\n *\n * ```javascript\n * class GroceryList extends Model {\n *     static fields = [\n *         'name',\n *         { name : 'items', type : 'store', storeClass : Store }\n *     ]\n * }\n *\n * const list = new GroceryList({\n *    name  : 'My list',\n *    items : [\n *        { name : 'Milk', quantity : 1 },\n *        { name : 'Bread', quantity : 2 },\n *        { name : 'Eggs', quantity : 12 }\n *    ]\n * });\n * ```\n *\n * The `items` field on the `list` above will be a {@link Core.data.Store} instance (because we passed that as\n * `storeClass`), which can be used to manipulate the items in the list. Doing so will flag the `list` as modified. For\n * more info, see {@link Core.data.field.StoreDataField}.\n *\n * ## Persisting fields\n *\n * By default, all fields are persisted. If you don't want particular field to get saved to the server, configure it\n * with `persist: false`. In this case field will not be among changes which are sent by\n * {@link Core/data/AjaxStore#function-commit store.commit()}, otherwise its behavior doesn't change.\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             'name',\n *             { name : 'age', persist : false }\n *         ];\n *     }\n * }\n * ```\n *\n * ## The `id` field\n * By default Model expects its id field to be stored in a data source named \"id\". The data source for the id field can\n * be customized by setting {@link Core/data/field/DataField#config-dataSource} on the id field object configuration.\n *\n * ```javascript\n * class Person extends Model {\n *     static fields = [\n *         { name : 'id', dataSource: 'personId'},\n *         'name',\n *         { name : 'age', persist : false },\n *         { name : 'birthday', type : 'date' }\n *      ];\n * }\n *\n * let girl = new Person({\n *     personId : 2,\n *     name     : 'Lady',\n *     birthday : '2011-11-05'\n * });\n * ```\n *\n * Also, it is possible to change the id field data source by setting {@link #property-idField-static}:\n *\n * ```javascript\n * class Person extends Model {\n *     // Id drawn from 'id' property by default; use custom field here\n *     static idField = 'personId';\n *\n *     static fields = [\n *         'name',\n *         { name : 'age', persist : false },\n *         { name : 'birthday', type : 'date' }\n *     ];\n * }\n * ```\n *\n * ## Getting and setting values\n *\n * Fields are used to generate getters and setters on the records. Use them to access or modify values (they are\n * reactive):\n *\n * ```javascript\n * console.log(guy.name);\n * girl.birthday = new Date(2011,10,6);\n * ```\n *\n * NOTE: In an application with multiple different models you should subclass Model, since the prototype is decorated\n * with getters and setters. Otherwise, you might get unforeseen collisions.\n *\n * ## Field data mapping\n *\n * By default, fields are mapped to data using their name. If you for example have a \"name\" field it expects data to be\n * `{ name: 'Some name' }`. If you need to map it to some other property, specify `dataSource` in your field definition:\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields {\n *         return [\n *             { name : 'name', dataSource : 'TheName' }\n *         ];\n *     }\n * }\n *\n * // This is now OK:\n * let dude = new Person({ TheName : 'Manfred' });\n * console.log(dude.name); // --> Manfred\n * ```\n *\n * ## Field inheritance\n *\n * Fields declared in a derived model class are added to those from its superclass. If a field declared by a derived\n * class has also been declared by its super class, the field properties of the super class are merged with those of\n * the derived class.\n *\n * For example:\n * ```javascript\n *  class Person extends Model {\n *      static get fields() {\n *          return [\n *              'name',\n *              { name : 'birthday', type : 'date', format : 'YYYY-MM-DD' }\n *          ];\n *      }\n *  }\n *\n *  class User extends Person {\n *      static get fields() {\n *          return [\n *              { name : 'birthday', dataSource : 'dob' },\n *              { name : 'lastLogin', type : 'date' }\n *          ];\n *      }\n *  }\n * ```\n *\n * In the above, the `Person` model declares the `birthday` field as a `date` with a specified `format`. The `User`\n * model extends `Person` and also declares the `birthday` field. This redeclared field only specifies `dataSource`, so\n * all the other fields are preserved from `Person`. The `User` model also adds a `lastLogin` field.\n *\n * The `User` from above could have been declared like so to achieve the same `fields`:\n *\n * ```javascript\n *  class User extends Model {\n *      static get fields() {\n *          return [\n *              'name',\n *              { name : 'birthday', type : 'date', format : 'YYYY-MM-DD', dataSource : 'dob' },\n *              { name : 'lastLogin', type : 'date' }\n *          ];\n *      }\n *  }\n * ```\n *\n * ## Override default values\n *\n * In case you need to define default value for a specific field, or override an existing default value, you can\n * define a new or re-define an existing field definition in {@link #property-fields-static} static getter:\n *\n * ```javascript\n * class Person extends Model {\n *     static get fields() {\n *         return [\n *             { name : 'username', defaultValue : 'New person' },\n *             { name : 'birthdate', type : 'date' }\n *         ];\n *     }\n * }\n *\n * class Bot extends Person {\n *     static get fields() {\n *         return [\n *             { name : 'username', defaultValue : 'Bot' } // default value of 'username' field is overridden\n *         ];\n *     }\n * }\n * ```\n *\n * ## Read-only records\n *\n * Model has a default field called {@link #field-readOnly}, which is used to make the record read-only in the UI while\n * still allowing programmatic changes to it. Setting it to `true` will prevent it from being edited by the built-in\n * editing features (cell editing in Grid, event draging in Scheduler, task editor in Gantt etc.). Please note that it\n * is not made read-only on the data level, the record can still be manipulated by application code.\n *\n * ```javascript\n * // Prevent record from being manipulated by the user\n * record.readOnly = true;\n *\n * // Programmatic manipulation is still allowed\n * record.remove();\n * ```\n *\n * ## Tree API\n *\n * This class mixes in the {@link Core/data/mixin/TreeNode TreeNode} mixin which provides an API for tree related\n * functionality (only relevant if your store is configured to be a {@link Core/data/Store#config-tree tree}).\n *\n * @mixes Core/data/mixin/ModelLink\n * @mixes Core/data/mixin/TreeNode\n * @mixes Core/data/stm/mixin/ModelStm\n */\nexport default class Model extends Base.mixin(ModelStm, TreeNode, ModelLink) {\n    static get $name() {\n        return 'Model';\n    }\n    static get declarable() {\n        return [\n            /**\n             * Array of defined fields for this model class. Subclasses add new fields by implementing this static\n             * getter:\n             *\n             * ```javascript\n             * // Model defining two fields\n             * class Person extends Model {\n             *     static get fields() {\n             *         return [\n             *             { name : 'username', defaultValue : 'New person' },\n             *             { name : 'birthdate', type : 'date' }\n             *         ];\n             *     }\n             * }\n             *\n             * // Subclass overriding one of the fields\n             * class Bot extends Person {\n             *     static get fields() {\n             *         return [\n             *             // Default value of 'username' field is overridden, any other setting from the parents\n             *             // definition is preserved\n             *             { name : 'username', defaultValue : 'Bot' }\n             *         ];\n             *     }\n             * }\n             * ```\n             *\n             * Fields in a subclass are merged with those from the parent class, making it easy to override mappings,\n             * formats etc.\n             *\n             * @member {Array<String|ModelFieldConfig|Core.data.field.DataField>} fields\n             * @readonly\n             * @static\n             * @category Fields\n             */\n            'fields'\n        ];\n    }\n    static get fields() {\n        return [\n            // The index of this item in its parent (respects filtering)\n            {\n                name     : 'parentIndex',\n                type     : 'number',\n                persist  : false,\n                internal : true\n            },\n            // The index of this item in its parent ghost (non-sortable) children array\n            {\n                name     : 'orderedParentIndex',\n                type     : 'number',\n                persist  : false,\n                internal : true\n            },\n            /**\n             * Flag the record as read-only on the UI level, preventing the end user from manipulating it using editing\n             * features such as cell editing and event dragging.\n             *\n             * Does not prevent altering the record programmatically, it can still be manipulated by application code.\n             *\n             * For more info, see the \"Read-only records\" section above.\n             *\n             * @field {Boolean} readOnly\n             * @category Common\n             */\n            {\n                name : 'readOnly',\n                type : 'boolean'\n            },\n            /**\n             * Start expanded or not (only valid for tree data)\n             * @readonly\n             * @field {Boolean} expanded\n             * @category Tree\n             */\n            {\n                name     : 'expanded',\n                internal : true\n            }\n        ];\n    }\n    /**\n     * Override in a subclass of Model to define relations to records in other stores.\n     *\n     * Always defined on the \"one\" side, not the \"many\" side.\n     *\n     * Expects an object where keys are relation names and values are {@link #typedef-RelationConfig relation configs}.\n     *\n     * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It\n     * will point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id\n     * matching the players `teamId` field. The team record in turn, will have a field called `players` which is a\n     * collection of all players in the team.\n     *\n     * ```javascript\n     * class Player extends Model {\n     *     static relations = {\n     *         // Define a relation between a player and a team\n     *         team : {\n     *             foreignKey            : 'teamId',\n     *             foreignStore          : 'teamStore',\n     *             relatedCollectionName : 'players'\n     *         }\n     *     }\n     * }\n     *\n     * const teamStore = new Store({\n     *     data : [\n     *         { id : 1, name : 'Brynas' },\n     *         { id : 2, name : 'Leksand' }\n     *     ]\n     * });\n     *\n     * const playerStore = new Store({\n     *     modelClass : Player,\n     *     // Matches foreignStore, allowing records of playerStore to find the related store\n     *     teamStore,\n     *     data       : [\n     *         // teamId is specified as foreignKey, will be used to match the team\n     *         { id : 1, name : 'Nicklas Backstrom', teamId : 1  },\n     *         { id : 2, name : 'Elias Lindholm',   teamId : 1  },\n     *         { id : 3, name : 'Filip Forsberg',  teamId : 2  }\n     *     ],\n     * }\n     *\n     * playerStore.first.team.name // > Brynas\n     * playerStore.last.team.name // > Leksand\n     * teamStore.first.players // > [nick, elias]\n     * teamStore.last.players // > [filip]\n     * ```\n     *\n     * @member {Object<String,RelationConfig>} relations\n     * @static\n     */\n    static relations = null;\n    /**\n     * Template static getter which is supposed to be overridden to define default field values for the Model class.\n     * Overrides `defaultValue` config specified by the {@link #property-fields-static} getter.\n     * Returns a named object where key is a field name and value is a default value for the field.\n     *\n     * NOTE: This is a legacy way of defining default values, we recommend using {@link #property-fields-static} moving\n     * forward.\n     *\n     * ```javascript\n     * class Person extends Model {\n     *     static get fields() {\n     *         return [\n     *             { name : 'username', defaultValue : 'New person' }\n     *         ];\n     *     }\n     * }\n     *\n     * class Bot extends Person {\n     *     static get defaults() {\n     *         return {\n     *             username : 'Bot' // default value of 'username' field is overridden\n     *         };\n     *     }\n     * }\n     * ```\n     *\n     * @member {Object} defaults\n     * @static\n     * @category Fields\n     */\n    /**\n     * The data source for the id field which provides the ID of instances of this Model.\n     * @property {String}\n     * @category Fields\n     */\n    static set idField(idField) {\n        this._assignedIdField = true;\n        this._idField = idField;\n    }\n    static get idField() {\n        return this._idField;\n    }\n    /**\n     * The name of the data field which holds children of this Model when used in a tree structure\n     * ```javascript\n     * MyModel.childrenField = 'kids';\n     * const parent = new MyModel({\n     *     name : 'Dad',\n     *     kids : [\n     *         { name : 'Daughter' },\n     *         { name : 'Son' }\n     *     ]\n     * });\n     * ```\n     * @property {String}\n     * @category Fields\n     */\n    static set childrenField(childrenField) {\n        this._childrenField = childrenField;\n    }\n    static get childrenField() {\n        if (!this._childrenField) {\n            const dataField = this.fieldMap.children;\n            this._childrenField = dataField?.dataSource || 'children';\n        }\n        return this._childrenField;\n    }\n    /**\n     * Returns index path to this node. This is the index of each node in the node path\n     * starting from the topmost parent. (only relevant when its part of a tree store).\n     * @returns {Number[]} The index of each node in the path from the topmost parent to this node.\n     * @category Parent & children\n     * @private\n     */\n    get indexPath() {\n        const indices = [];\n        let node = this,\n            depth = node.childLevel;\n        for (node = this; node && !node.isRoot; node = node.parent) {\n            indices[depth--] = node.parentIndex + 1;\n        }\n        return indices;\n    }\n    /**\n     * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as\n     * record.id. Will get a generated value if none is specified in records data.\n     *\n     * <div class=\"note\">Note that generated ids are meant to be temporary (phantom ids), they should not be serialized\n     * but instead replaced by the backend on commit</div>\n     *\n     * @field {String|Number} id\n     * @category Common\n     */\n    //region Init\n    /**\n     * Constructs a new record from the supplied data.\n     * @param {Object} [data] Raw data\n     * @param {Core.data.Store} [store] Data store\n     * @param {Object} [meta] Meta data\n     * @privateparam {Boolean} [skipExpose] Skip exposing properties from data\n     * @privateparam {Boolean} [forceUseRaw] Force using raw data, used by copy to not clone data twice\n     * @function constructor\n     * @category Lifecycle\n     */\n    construct(data = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {\n        const\n            me     = this,\n            stores = ArrayHelper.asArray(store) ?? [],\n            { constructor, fieldMap } = me;\n        // null passed to Base construct inhibits config processing.\n        let configs = null;\n        store = stores[0];\n        me.meta = {\n            modified : {},\n            ...constructor.metaConfig,\n            ...meta\n        };\n        // Should apply configs?\n        if (constructor.applyConfigs) {\n            // Extract from data and combine with defaultConfigs\n            for (const key in me.getDefaultConfiguration()) {\n                if (!configs) {  // if (first config)\n                    configs = {};\n                    if (!me.useRawData || !me.useRawData.enabled) {\n                        // Shallow copy of data to not mutate incoming object\n                        data = { ...data };\n                    }\n                }\n                // Loop through configs excluding fields\n                if (key in data) {\n                    // Let defaults override any config supplied with an `undefined` value\n                    if (data[key] !== undefined) {\n                        // Use as config\n                        configs[key] = data[key];\n                    }\n                    // Always remove config from data\n                    delete data[key];\n                }\n            }\n        }\n        super.construct(configs);\n        // make getters/setters for fields, needs to be done before processing data to make sure defaults are available\n        if (!skipExpose) {\n            constructor.exposeProperties(data, rawData);\n        }\n        // It's only valid to do this once, on construction of the first instance\n        if (!hasOwn(constructor, 'idFieldProcessed')) {\n            // idField can be overridden from meta, or from the store if we have not had an idField set programmatically\n            // and if we have not had an id field defined above the base Model class level.\n            let overriddenIdField = me.meta.idField;\n            if (!overriddenIdField) {\n                // Might have been set to Model after construction but before load\n                if (constructor._assignedIdField) {\n                    overriddenIdField = constructor.idField;\n                }\n                else if (store) {\n                    overriddenIdField = store.idField;\n                }\n            }\n            // If it's overridden to something different than we already have, replace the 'id' field in the fieldMap\n            if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {\n                constructor.addField({\n                    name       : 'id',\n                    dataSource : overriddenIdField,\n                    internal   : true\n                });\n            }\n            // Model.idField should always reflect the idField mapping\n            constructor._idField = fieldMap.id.dataSource;\n            constructor.idFieldProcessed = true;\n        }\n        // assign internalId, unique among all records\n        me._internalId = Model._internalIdCounter++;\n        // relation code expects store to be available for relation lookup, but actual join done below\n        me.stores = [];\n        me.unjoinedStores = [];\n        // Superclass constructors may set this in their own way before this is called.\n        if (!me.originalData) {\n            me.originalData = data;\n        }\n        me.data = constructor.processData(data, false, store, me, forceUseRaw);\n        // Assign any intiable value last, so that it can reference this record if needed\n        me.meta.initableValues?.size && me.assignInitables();\n        // Consider undefined and null as missing id and generate one\n        if (me.id == null) {\n            // Assign a generated id silently, record should not be considered modified\n            me.setData('id', me.generateId(store));\n        }\n        if (me.data[constructor.childrenField]) {\n            me.processChildren(stores);\n        }\n        me.generation = 0;\n    }\n    /**\n     * Set this property to `true` when adding a record on a conditional basis, that is, it is yet\n     * to be confirmed as an addition.\n     *\n     * When this is set, the {@link #property-isPersistable} value of the record is **false**, and upon being\n     * added to a Store it will *not* be eligible to be synced with the server as an added record.\n     *\n     * Subsequently, *clearing* this property means this record will become persistable and eligible\n     * for syncing as an added record.\n     * @property {Boolean}\n     * @category Editing\n     */\n    set isCreating(isCreating) {\n        const me = this;\n        // A no-change must not have any effect.\n        if (Boolean(me.meta.isCreating) !== isCreating) {\n            // This flag contributes to the evaluation of isPersistable.\n            // A record is not persistable if it isCreating.\n            me.meta.isCreating = isCreating;\n            // Owning Stores may have things to do at this lifecycle point\n            me.stores.forEach(s => {\n                s.onIsCreatingToggle(me, isCreating);\n            });\n        }\n    }\n    get isCreating() {\n        return Boolean(this.meta.isCreating);\n    }\n    /**\n     * Compares this Model instance to the passed instance. If they are of the same type, and all fields\n     * (except, obviously, `id`) are equal, this returns `true`.\n     * @param {Core.data.Model} other The record to compare this record with.\n     * @returns {Boolean} `true` if the other is of the same class and has all fields equal.\n     * @category Misc\n     */\n    equals(other) {\n        if (other instanceof this.constructor) {\n            for (let fields = this.$meta.fields.defs, i = 0, { length } = fields; i < length; i++) {\n                const\n                    field    = fields[i],\n                    { name } = field;\n                if (name !== 'id' && !field.isEqual(this[name], other[name])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    get subclass() {\n        return new this.constructor(Object.setPrototypeOf({\n            id : _undefined\n        }, this.data), this.stores[0], null, true);\n    }\n    /**\n     * Processes raw data, converting values and setting defaults.\n     * @private\n     * @param {Object} data Raw data\n     * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating\n     * @returns {Object} Processed data\n     * @category Fields\n     */\n    static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {\n        const\n            { fieldMap, defaultValues } = this,\n            { useRawData = { enabled : false } } = store || { },\n            // Store configured with useRawData uses the supplied data object, polluting it. When not configured with\n            // useRawData it instead makes a copy (intentionally deep, in case data has a prototype chain or contains\n            // arrays or objects)\n            processed = (forceUseRaw || useRawData.enabled) ? data : ObjectHelper.clone(data);\n        let fieldName;\n        ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;\n        if (!ignoreDefaults) {\n            for (fieldName in defaultValues) {\n                if (processed[fieldName] === _undefined) {\n                    let defaultValue = defaultValues[fieldName];\n                    // Avoid sharing arrays across instances\n                    if (Array.isArray(defaultValue)) {\n                        defaultValue = defaultValue.slice();\n                    }\n                    processed[fieldName] = defaultValue;\n                }\n            }\n        }\n        if (!useRawData.disableTypeConversion && !forceUseRaw) {\n            // Convert field types which need converting\n            for (fieldName in fieldMap) {\n                const\n                    field                = fieldMap[fieldName],\n                    { name, dataSource } = field,\n                    // Value might have been supplied either using mapped dataSource (when loading JSON etc. for example\n                    // event.myStartDate) or as field name (from internal code, for example event.startDate). If [name]\n                    // exists but not [dataSource], use it.\n                    hasSource            = dataSource !== name,\n                    complex              = field.complexMapping,\n                    sourceExists         = hasSource && (complex\n                        ? ObjectHelper.pathExists(data, dataSource)\n                        : dataSource in data),\n                    useNameForValue      = (name in data) && (!hasSource || !sourceExists),\n                    convert              = !useRawData.disableTypeConversion && field.convert;\n                // Only action field definitions which have a convert function or remap data\n                if (useNameForValue || convert) {\n                    // When ignoringDefaults, do not convert unspecified values\n                    if (!ignoreDefaults || useNameForValue || sourceExists) {\n                        const\n                            value     = useNameForValue\n                                ? processed[name]\n                                : complex\n                                    ? ObjectHelper.getPath(processed, dataSource)\n                                    : processed[dataSource],\n                            converted = convert ? field.convert(value, data, record) : value;\n                        if (complex) {\n                            ObjectHelper.setPath(processed, dataSource, converted);\n                        }\n                        else {\n                            processed[dataSource] = converted;\n                        }\n                        // Remove [startDate] from internal data holder, only keeping [myStartDate]\n                        if (hasSource) {\n                            delete processed[name];\n                        }\n                    }\n                }\n            }\n        }\n        // Fields that needs initializing\n        this.$meta.fields.initable.length && this.initInitables(record, processed);\n        return processed;\n    }\n    static setupClass(meta) {\n        super.setupClass(meta);\n        if (!meta.fields) {\n            // Normally setupFields will only run when a Model defines a fields getter, but we want to always run it:\n            this.setupFields(this, meta);\n        }\n    }\n    static setupFields(cls, meta) {\n        const\n            classFields = hasOwn(cls, 'fields') && cls.fields,\n            base        = meta.super.fields,\n            fieldsInfo  = meta.fields = {\n                defs : base?.defs.slice() ?? [],\n                // Set to true when an instance's data object is run through exposeProperties\n                exposedData : false,\n                // These objects are all keyed by field name:\n                defaults : base ? { ...base.defaults } : {}, // value=field.defaultValue\n                exposed  : Object.create(base?.exposed  ?? null),   // value=true if we've done defineProperty\n                ordinals : Object.create(base?.ordinals ?? null),   // value=index in the defs array\n                map      : Object.create(base?.map      ?? null),   // value=definition object\n                sources  : Object.create(base?.sources  ?? null)    // value=source definition object\n            };\n        // We use Object.create(null) as the base for these maps because some models declare \"constructor\" as a field\n        // NOTE: instead of chaining the defaults, we copy them so the defaults object can be used with Object.assign\n        // in other contexts (since it does not copy inherited properties from the prototype chain)\n        // Clone the superclass's defaults, and override that with our own defaults.\n        // As we find fields with a defaultValue, more defaults may be added\n        if (hasOwn(cls, 'defaults')) {\n            Object.assign(fieldsInfo.defaults, cls.defaults);\n        }\n        // Hook up our field maps with the class hierarchy's fieldMaps.\n        // We need to be able to look up field definitions by the name, or by the dataSource property name\n        // If the idField is overridden at this level, create a new field\n        if (hasOwn(cls, 'idField')) {\n            cls.addField({\n                name       : 'id',\n                dataSource : cls.idField,\n                internal   : true\n            });\n            fieldsInfo.exposed[cls.idField] = true;\n        }\n        // Process fields defined in the class definition\n        if (classFields?.length) {\n            classFields.map(cls.addField, cls);\n        }\n        // Collect fields that need to be initialized (StoreDataField for example)\n        fieldsInfo.initable = fieldsInfo.defs.filter(field => field.init);\n        cls.exposeRelations();\n    }\n    static get defaultValues() {\n        return this.$meta.fields.defaults;\n    }\n    /**\n     * An array containing all the _defined_ fields for this Model class. This will include all superclass's\n     * defined fields.\n     * @property {Core.data.field.DataField[]}\n     * @static\n     * @readonly\n     * @category Fields\n     */\n    static get allFields() {\n        return this.$meta.fields.defs;\n    }\n    /**\n     * Same as {@link #property-allFields-static}.\n     * @property {Core.data.field.DataField[]}\n     * @readonly\n     * @category Fields\n     */\n    get allFields() {\n        return this.$meta.fields.defs;\n    }\n    /**\n     * An object containing all the _defined_ fields for this Model class. This will include all superclass's\n     * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only\n     * access this class's defined fields.\n     * @property {Object<String,Core.data.field.DataField>}\n     * @static\n     * @readonly\n     * @category Fields\n     */\n    static get fieldMap() {\n        return this.$meta.fields.map;\n    }\n    /**\n     * Same as {@link #property-fieldMap-static}.\n     * @property {Object<String,Core.data.field.DataField>}\n     * @readonly\n     * @category Fields\n     */\n    get fieldMap() {\n        return this.$meta.fields.map;\n    }\n    static get fieldDataSourceMap() {\n        return this.$meta.fields.sources;\n    }\n    /**\n     * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when\n     * data is loaded first time.\n     * @internal\n     * @param {Object} [data] Raw data\n     * @param {Boolean} [raw=true] True if data is raw (contains data sources), False if data contains field names\n     * @category Fields\n     */\n    static exposeProperties(data, raw = true) {\n        const\n            me               = this,\n            fieldsInfo       = me.$meta.fields,\n            // exposeProperties method is called from two different places: from the model constructor which receives\n            // field names, and from store loadData method, which handles raw data. When loading data to store we need\n            // to use names as specified in the dataSource. And when calling a model constructor we need to use field\n            // names\n            fieldMapProperty = raw ? 'exposed' : 'map';\n        // Process the raw data properties and expose them as fields unless the property name\n        // has already been used by the \"dataSource\" of a defined field.\n        if (data && me.autoExposeFields && !fieldsInfo.exposedData) {\n            let dataProperty, fieldDef, type;\n            for (dataProperty in data) {\n                // We need to skip children field because it can be `true` and that would create boolean field.\n                // See https://github.com/bryntum/support/issues/2705\n                if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {\n                    type = ObjectHelper.typeOf(data[dataProperty]);\n                    // Create a field definition in our fieldMap with the flag that it's from data\n                    fieldDef = {\n                        name       : dataProperty,\n                        dataSource : dataProperty,\n                        fromData   : true\n                    };\n                    if (fieldDataTypes[type]) {\n                        fieldDef.type = type;\n                    }\n                    me.addField(fieldDef);\n                }\n            }\n            fieldsInfo.exposedData = true;\n        }\n        me.exposeRelations();\n    }\n    /**\n     * Add a field definition in addition to those predefined in `fields`.\n     * @param {String|ModelFieldConfig} fieldDef A field name or definition\n     * @category Fields\n     */\n    static addField(fieldDef) {\n        if (fieldDef == null) {\n            return;\n        }\n        if (typeof fieldDef === 'string') {\n            fieldDef = {\n                name : fieldDef\n            };\n        }\n        const\n            me                = this.initClass(),\n            fieldsInfo        = me.$meta.fields,\n            { ordinals }      = fieldsInfo,\n            propertiesExposed = fieldsInfo.exposed,\n            { name }          = fieldDef,\n            existing          = fieldsInfo.map[name],\n            dataSource        = fieldDef.dataSource || (fieldDef.dataSource = name);\n        let field, key;\n        if (!existing || (fieldDef.type && fieldDef.type !== existing.type)) {\n            field = DataField.create(fieldDef);\n            field.definedBy = existing ? existing.definedBy : me;\n            field.ordinal = existing ? existing.ordinal : (ordinals[name] = fieldsInfo.defs.length);\n        }\n        else {\n            field = Object.create(existing);\n            for (key in fieldDef) {\n                if (key !== 'type') {\n                    field[key] = fieldDef[key];\n                }\n            }\n        }\n        field.owner = me;\n        fieldsInfo.defs[field.ordinal] = field;\n        fieldsInfo.map[name] = field;\n        if (!fieldsInfo.sources[dataSource]) {\n            fieldsInfo.sources[dataSource] = field;\n        }\n        // With complex mapping avoid exposing object as model field\n        if (dataSource.includes('.')) {\n            field.complexMapping = true;\n        }\n        if (field.complexMapping) {  // model fields have this set on their prototype...\n            propertiesExposed[dataSource.split('.')[0]] = true;\n        }\n        else {\n            // When iterating through the raw data, if autoExposeFields is set\n            // We do not need to create properties for raw property names we've processed here\n            propertiesExposed[dataSource] = true;\n        }\n        // Maintain an object of defaultValues for fields.\n        if ('defaultValue' in field) {\n            fieldsInfo.defaults[dataSource] = field.defaultValue;\n        }\n        // Create a property on this Model's prototype, named for the defined field name\n        // which reads the correct property out of the raw data object.\n        if (!internalProps[name]) {\n            // Either creates a new accessor or redefines an existing\n            field.defineAccessor(me.prototype);\n        }\n        me._nonPersistableFields = null;\n        me._alwaysWriteFields = null;\n        return field;\n    }\n    /**\n     * Remove a field definition by name.\n     * @param {String} fieldName Field name\n     * @category Fields\n     */\n    static removeField(fieldName) {\n        const\n            me = this.initClass(),\n            fieldsInfo = me.$meta.fields,\n            definition = fieldsInfo.map[fieldName],\n            { ordinals } = fieldsInfo,\n            index = ordinals[fieldName];\n        if (definition) {\n            fieldsInfo.defs.splice(index, 1);\n            delete ordinals[fieldName];\n            delete fieldsInfo.defaults[fieldName];\n            delete fieldsInfo.exposed[fieldName];\n            delete fieldsInfo.map[fieldName];\n            delete fieldsInfo.sources[definition.dataSource];\n            for (const name in ordinals) {\n                if (ordinals[name] > index) {\n                    --ordinals[name];\n                }\n            }\n            // Note: if field was exposed by superclass, this won't do anything...\n            delete me.prototype[fieldName];\n        }\n    }\n    /**\n     * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it\n     * to be modified later when assigning stores.\n     * @internal\n     * @category Relations\n     */\n    static exposeRelations() {\n        const me = this;\n        if (hasOwn(me, 'exposedRelations')) {\n            return;\n        }\n        if (me.relations) {\n            me.exposedRelations = [];\n            for (const relationName in me.relations) {\n                const relation = me.relations[relationName];\n                relation.relationName = relationName;\n                me.exposedRelations.push(relation);\n                // getter and setter for related object\n                if (!Reflect.ownKeys(me.prototype).includes(relationName)) {\n                    defineProperty(me.prototype, relationName, {\n                        enumerable : true,\n                        get        : function() {\n                            // noinspection JSPotentiallyInvalidUsageOfClassThis\n                            return this.getForeign(relationName);\n                        },\n                        set : function(value) {\n                            // noinspection JSPotentiallyInvalidUsageOfClassThis\n                            this.setForeign(relationName, value, relation);\n                        }\n                    });\n                }\n            }\n        }\n    }\n    //endregion\n    //region Initable fields\n    // Initializes any fields using a data type that has an init method, and caches the value to assign to that field to\n    // be able to assign it after all others. That allows the initter to reference the records other data if needed\n    // (baselines use that to reference the task to get default values)\n    static initInitables(record, processedData) {\n        const laterValues = record.meta.initableValues = new Map();\n        // Initialize any initializable fields (only StoreDataField currently)\n        for (const field of this.$meta.fields.initable) {\n            // Set data (if any) later, in case it needs to reference this record\n            const value = ObjectHelper.getPath(processedData, field.dataSource);\n            value !== undefined && laterValues.set(field, value);\n            // Init field if not lazy, if lazy app is responsible for doing it\n            !field.lazy && field.init(processedData, record);\n        }\n    }\n    // Assigns values to the fields that were initialized earlier (see initInitables above)\n    assignInitables() {\n        const { initableValues } = this.meta;\n        for (const [field, value] of initableValues) {\n            if (field.set(value, this.data, this) !== false) {\n                initableValues.delete(field);\n            }\n        }\n    }\n    //endregion\n    //region Fields\n    /**\n     * Flag checked from Store when loading data that determines if fields found in first records should be exposed in\n     * same way as predefined fields.\n     *\n     * <div class=\"note\">Note that we for all but the most basic use cases recommend explicitly defining the fields.\n     * Having them auto exposed can lead to unexpected behavior, if the first record is not complete (fields missing,\n     * null etc).\n     * </div>\n     *\n     * @property {Boolean}\n     * @category Fields\n     */\n    static get autoExposeFields() {\n        return true;\n    }\n    /**\n     * This function forces correct field order. Correct order is parentId before id. If we process id field before\n     * parentId, idMap won't be updated and changing parent node will lead to duplicated records in storage\n     * @param {String} a\n     * @param {String} b\n     * @returns {number}\n     * @private\n     */\n    static fieldSorter(a, b) {\n        return (fieldsOrder[a] || 100) - (fieldsOrder[b] || 100);\n    }\n    /**\n     * Convenience getter to get field definitions from class.\n     * @property {Core.data.field.DataField[]}\n     * @readonly\n     * @category Fields\n     */\n    get fields() {\n        return this.$meta.fields.defs;\n    }\n    /**\n     * Convenience function to get the definition for a field from class.\n     * @param {String} fieldName Field name\n     * @returns {Core.data.field.DataField}\n     * @category Fields\n     */\n    getFieldDefinition(fieldName) {\n        return this.$meta.fields.map[fieldName];\n    }\n    getFieldDefinitionFromDataSource(dataSource) {\n        return this.$meta.fields.sources[dataSource];\n    }\n    /**\n     * Get the names of all fields in data.\n     * @property {String[]}\n     * @readonly\n     * @category Fields\n     */\n    get fieldNames() {\n        return Object.keys(this.data);\n    }\n    /**\n     * Get the definition for a field by name. Caches results.\n     * @param {String} fieldName Field name\n     * @returns {Core.data.field.DataField} Field definition or null if none found\n     * @category Fields\n     */\n    static getFieldDefinition(fieldName) {\n        return this.$meta.fields.map[fieldName];\n    }\n    /**\n     * Returns dataSource configuration for a given field name\n     * @param {String} fieldName\n     * @returns {String} Field `dataSource` mapping\n     * @internal\n     */\n    static getFieldDataSource(fieldName) {\n        return this.getFieldDefinition(fieldName).dataSource;\n    }\n    /**\n     * Get the data source used by specified field. Returns the fieldName if no data source specified.\n     * @param {String} fieldName Field name\n     * @returns {String}\n     * @category Fields\n     */\n    getDataSource(fieldName) {\n        const def = this.constructor.getFieldDefinition(fieldName);\n        return def?.dataSource || def?.name;\n    }\n    /**\n     * Processes input to a field, converting to expected type.\n     * @param {String} fieldName Field name\n     * @param {*} value Value to process\n     * @returns {*} Converted value\n     * @category Fields\n     */\n    static processField(fieldName, value, record) {\n        const field = this.fieldMap[fieldName];\n        return field?.convert ? field.convert(value, this.data, record) : value;\n    }\n    //endregion\n    //region Relations\n    /**\n     * Initializes model relations. Called from store when adding a record.\n     * @private\n     * @category Relations\n     */\n    initRelations() {\n        const\n            me        = this,\n            relations = me.constructor.exposedRelations;\n        if (!relations) {\n            return;\n        }\n        me.stores.forEach(store => {\n            if (!store.modelRelations) {\n                store.initRelations();\n            }\n            const relatedRecords = [];\n            store.modelRelations?.forEach(config => {\n                relatedRecords.push({ related : me.initRelation(config), config });\n            });\n            store.updateRecordRelationCache(me, relatedRecords);\n        });\n    }\n    /**\n     * Initializes/updates a single relation.\n     * @param config Relation config\n     * @returns {Core.data.Model} Related record\n     * @private\n     * @category Relations\n     */\n    initRelation(config) {\n        const\n            me            = this,\n            foreignId     = me.get(config.foreignKey),\n            foreign       = foreignId !== _undefined && typeof config.foreignStore !== 'string' && config.foreignStore.getById(foreignId),\n            relationCache = me.meta.relationCache || (me.meta.relationCache = {});\n        // apparently scheduler tests expect cache to work without matched related record, thus the placeholder\n        relationCache[config.relationName] = foreign || (foreignId != null ? { id : foreignId, placeHolder : true } : null);\n        return foreign;\n    }\n    removeRelation(config) {\n        const { relationName, foreignKey, nullFieldOnRemove } = config;\n        // (have to check for existence before deleting to work in Safari)\n        if (this.meta.relationCache[relationName]) {\n            delete this.meta.relationCache[relationName];\n            if (nullFieldOnRemove) {\n                // Setting to null silently, to not trigger additional relation behaviour\n                this.setData(foreignKey, null);\n            }\n        }\n    }\n    getForeign(name) {\n        return this.meta.relationCache?.[name];\n    }\n    setForeign(name, value, config) {\n        const id = Model.asId(value);\n        return this.set(config.foreignKey, id);\n    }\n    /**\n     * Get a relation config by name, from the first store.\n     * @param {String} name\n     * @returns {Object}\n     * @private\n     * @category Relations\n     */\n    getRelationConfig(name) {\n        //?\n        // Using first store for relations, might have to revise later...\n        return this.firstStore?.modelRelations?.find(r => r.foreignKey === name);\n    }\n    //endregion\n    //region Get/set values, data handling\n    flatGet(fieldName, dataSource) {\n        // NOTE: There is an inlined copy of this fn in DataField, when changing here make sure it is updated too\n        // When changes are batched, they get stored by field name, not dataSource\n        if (this.batching && fieldName in this.meta.batchChanges) {\n            return this.meta.batchChanges[fieldName];\n        }\n        return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];\n    }\n    complexGet(fieldName, dataSource) {\n        // When changes are batched, they get stored by field name, not dataSource\n        if (this.batching && fieldName in this.meta.batchChanges) {\n            return this.meta.batchChanges[fieldName];\n        }\n        return ObjectHelper.getPath(this.data, dataSource);\n    }\n    /**\n     * Get value for specified field name. You can also use the generated getters if loading through a Store.\n     * If model is currently in batch operation this will return updated batch values which are not applied to Model\n     * until endBatch() is called.\n     * @param {String} fieldName Field name to get value from\n     * @returns {*} Fields value\n     * @category Fields\n     */\n    get(fieldName) {\n        if (!fieldName) {\n            return;\n        }\n        const field = this.fieldMap[fieldName];\n        // Getting property of nested record?\n        if (!field && fieldName.includes('.')) {\n            return this.complexGet(fieldName, fieldName);\n        }\n        if (field?.complexMapping) {\n            return this.complexGet(fieldName, field.dataSource);\n        }\n        return this.flatGet(fieldName, field?.dataSource || fieldName);\n    }\n    /**\n     * Internal function used to update a records underlying data block (record.data) while still respecting field\n     * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a\n     * dataSource with a different name.\n     *\n     * For example:\n     * ```javascript\n     * // startDate mapped to data.beginDate\n     * { name : 'startDate', dataSource : 'beginDate' }\n     *\n     * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with\n     * // calling set. This would then not update \"beginDate\":\n     * record.data.startDate = xx;\n     *\n     * // But this would\n     * record.setData('startDate', xx);\n     * ```\n     * @internal\n     * @category Editing\n     */\n    setData(toSet, value) {\n        const { data, fieldMap } = this;\n        // Two separate paths for performance reasons\n        // setData('name', 'Quicksilver');\n        if (typeof toSet === 'string') {\n            const\n                field      = fieldMap[toSet],\n                dataSource = field?.dataSource ?? toSet;\n            if (field?.set) {\n                field.set(value, this.data, this);\n            }\n            else if (field?.complexMapping) {\n                ObjectHelper.setPath(data, dataSource, value);\n            }\n            else {\n                data[dataSource] = value;\n            }\n        }\n        // setData({ name : 'Magneto', power : 'Magnetism' });\n        else {\n            const keys = Object.keys(toSet);\n            for (let i = 0; i < keys.length; i++) {\n                const\n                    fieldName  = keys[i],\n                    field      = fieldMap[fieldName],\n                    dataSource = field?.dataSource ?? fieldName;\n                if (field?.set) {\n                    field.set(value, this.data, this);\n                }\n                else if (dataSource) {\n                    if (field?.complexMapping) {\n                        ObjectHelper.setPath(data, dataSource, toSet[fieldName]);\n                    }\n                    else {\n                        data[dataSource] = toSet[fieldName];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns raw data from the encapsulated data object for the passed field name\n     * @param {String} fieldName The field to get data for.\n     * @returns {*} The raw data value for the field.\n     * @category Editing\n     */\n    getData(fieldName) {\n        const\n            field      = this.fieldMap[fieldName],\n            dataSource = field?.dataSource ?? fieldName;\n        if (dataSource) {\n            if (field?.complexMapping) {\n                return ObjectHelper.getPath(this.data, dataSource);\n            }\n            return this.data[dataSource];\n        }\n    }\n    /**\n     * Silently updates record's id with no flagging the property as modified.\n     * Triggers onModelChange event for changed id.\n     * @param {String|Number} value id value\n     * @private\n     */\n    syncId(value) {\n        const oldValue = this.id;\n        if (oldValue !== value) {\n            this.setData('id', value);\n            const data = { id : { value, oldValue } };\n            this.afterChange(data, data);\n        }\n    }\n    /**\n     * Set value for the specified field. You can also use the generated setters if loading through a Store.\n     *\n     * Setting a single field, supplying name and value:\n     *\n     * ```javascript\n     * record.set('name', 'Clark');\n     * ```\n     *\n     * Setting multiple fields, supplying an object:\n     *\n     * ```javascript\n     * record.set({\n     *     name : 'Clark',\n     *     city : 'Metropolis'\n     * });\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} [value] Value to set\n     * @param {Boolean} [silent] Set to true to not trigger events. If event is recurring, occurrences won't be updated automatically.\n     * @privateparam {Boolean} [validOnly] If set to `true` it will ignore setting a `undefined` value, allowing conversion functions to invalidate a data input\n     * @privateparam {Boolean} [triggerBeforeUpdate]\n     * @fires Store#idChange\n     * @fires Store#update\n     * @fires Store#change\n     * @category Editing\n     */\n    set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {\n        const me = this;\n        if (me.isBatchUpdating) {\n            me.inBatchSet(field, value, silent || me.$silenceBatch);\n            return null;\n        }\n        else {\n            // We use inSet/afterSet approach here because mixin interested in overriding set() method like STM, for\n            // example, might be mixed before Model class or after. In general, we have no control over this.\n            // STM mixed before, so the only option to wrap set() method body is actually to call afterSet().\n            const wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);\n            me.afterSet?.(field, value, silent, fromRelationUpdate, wasSet);\n            return wasSet;\n        }\n    }\n    fieldToKeys(field, value) {\n        if (typeof field !== 'string') {\n            // will get in trouble when setting same field on multiple models without this\n            return ObjectHelper.assign({}, field);\n        }\n        return {\n            [field] : value\n        };\n    }\n    inBatchSet(field, value, silent) {\n        const\n            me     = this,\n            {\n                meta,\n                constructor,\n                fieldMap\n            }      = me,\n            wasSet = {};\n        let cmp, changed = false;\n        if (typeof field !== 'string') {\n            Object.keys(me.fieldToKeys(field, value)).forEach(key => {\n                cmp = fieldMap[key] || ObjectHelper;\n                value = constructor.processField(key, field[key], me);\n                // Store batch changes\n                if (!cmp.isEqual(meta.batchChanges[key], value)) {\n                    wasSet[key] = {\n                        value,\n                        oldValue : me.get(key)\n                    };\n                    meta.batchChanges[key] = value;\n                    changed = true;\n                }\n            });\n        }\n        else {\n            cmp = fieldMap[field] || ObjectHelper;\n            // Minor optimization for engine writing back a lot of changes\n            if (!cmp.isEqual(meta.batchChanges[field], value)) {\n                wasSet[field] = {\n                    value,\n                    oldValue : me.get(field)\n                };\n                meta.batchChanges[field] = value;\n                changed = true;\n            }\n        }\n        // Callers need to be able to detect changes\n        if (changed) {\n            me.generation++;\n            if (!silent) {\n                // Fire batched events for UIs which need to update themselves during batched updates.\n                // An example is evenResize feature which batches the changes to the endDate\n                // or startDate, but the UI must update during the drag.\n                const event = {\n                    action  : 'update',\n                    record  : me,\n                    records : [me],\n                    changes : wasSet\n                };\n                me.stores.forEach(store => {\n                    store.trigger('batchedUpdate', { ...event });\n                });\n                // Propagate to linked records\n                me.forEachLinked((store, record) =>\n                    store.trigger('batchedUpdate', { ...event, record, records : [record] })\n                );\n            }\n        }\n    }\n    inSet(field, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {\n        const\n            me       = this,\n            {\n                data,\n                meta,\n                fieldMap,\n                constructor\n            }        = me,\n            {\n                prototype : myProto,\n                childrenField\n            }        = constructor,\n            wasSet   = {},\n            toSet    = me.fieldToKeys(field, value),\n            // Sort fields to make sure parentId is processed before id\n            // https://github.com/bryntum/support/issues/6851\n            keys     = Object.keys(toSet).sort(this.constructor.fieldSorter);\n        let\n            changed  = false;\n        // Give a chance to cancel action before records are updated.\n        if (!silent && !me.triggerBeforeUpdate(toSet)) {\n            return null;\n        }\n        me.inSetting = true;\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            // Currently not allowed to set children in a TreeNode this way, will be ignored\n            if (key === childrenField) {\n                continue;\n            }\n            const\n                field    = fieldMap[key],\n                cmp      = field || ObjectHelper,\n                readOnly = field?.readOnly,\n                mapping  = field?.dataSource ?? key,\n                useProp  = !skipAccessors && !field && key in myProto,\n                oldValue = useProp ? me[mapping] : field?.complexMapping ? ObjectHelper.getPath(data, mapping) : data[mapping],\n                value    = constructor.processField(key, toSet[key], me),\n                val      = toSet[key] = { value },\n                relation = me.getRelationConfig(key);\n            if (!readOnly && !cmp.isEqual(oldValue, value) && (!validOnly || value !== undefined)) {\n                // Indicate to observers that data has changed.\n                me.generation++;\n                // Give fields a shot at affecting the old value (used by StoreDataField)\n                val.oldValue = field?.getOldValue?.(me) ?? oldValue;\n                changed = true;\n                // Update `modified` state which is used in sync request\n                if (key in meta.modified && cmp.isEqual(meta.modified[key], value)) {\n                    // Remove changes if values are the same\n                    Reflect.deleteProperty(meta.modified, key);\n                    // Hack for when reverting record changes when using engine. If data is not made up to date here,\n                    // the write-back from engine coming later will detect the revert as a change. And round we go\n                    if (me.isReverting) {\n                        me.data[mapping] = value;\n                    }\n                }\n                else if (!me.ignoreBag) { // Private flag in engine, speeds initial commit up by not recording changes\n                    // Cache its original value\n                    if (!(key in meta.modified)) {\n                        me.storeFieldChange(key, oldValue);\n                    }\n                    if (val.oldValue === _undefined) {\n                        Reflect.deleteProperty(val, 'oldValue');\n                    }\n                }\n                // The wasSet object keys must be the field *name*, not its dataSource.\n                wasSet[key] = val;\n                me.applyValue(useProp, mapping, value, skipAccessors, field);\n                // changing foreign key\n                if (relation && !fromRelationUpdate) {\n                    me.initRelation(relation);\n                    me.stores.forEach(store => store.cacheRelatedRecord(me, value, relation.relationName, val.oldValue));\n                }\n            }\n        }\n        if (changed) {\n            me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);\n        }\n        me.inSetting = false;\n        return changed ? wasSet : null;\n    }\n    // Provided as a hook for Engine to do what needs to be done which ever way a field value is changed\n    applyValue(useProp, key, value, skipAccessors, field) {\n        const me = this;\n        let complexMapping = field?.complexMapping;\n        // If we don't have a field, but we have a property define eg, the fullDuration property defined in TaskModel,\n        // then use the property.\n        // Setting parentId moves the node, always route through setter\n        if ((field?.name || key) === me.constructor.parentIdField) {\n            // key is the dataSource, if we use property we need to use field name\n            (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {\n                orderedParentIndex : { skip : true }\n            });\n            return;\n        }\n        else if (useProp) {\n            // key is the dataSource, if we use property we need to use field name\n            me[field?.name || key] = value;\n            return;\n        }\n        if (field?.set) {\n            field.set(value, me.data, me);\n            return;\n        }\n        // Might be setting value of nested object\n        if (!field && key.includes('.')) {\n            const nestedName = key.split('.')[0];\n            field = me.constructor.fieldMap[nestedName];\n            // We use complex mapping if the field's dataSource was defined as such,\n            // OR if we are being asked to set using dot notation and field is of Object type.\n            complexMapping = field?.complexMapping || field?.type === 'object';\n        }\n        // Use complex mapping?\n        if (complexMapping) {\n            ObjectHelper.setPath(me.data, key, value);\n        }\n        // Otherwise, push the value through into the data.\n        else {\n            me.data[key] = value;\n        }\n    }\n    // skipAccessors argument is used in the engine override\n    afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n        for (const store of this.stores) {\n            store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);\n        }\n        // Propagate to linked records\n        this.forEachLinked((store, record) =>\n            store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors)\n        );\n    }\n    // Run fn for each store on each linked record\n    forEachLinked(fn) {\n        for (const linked of this.$links) {\n            for (const store of linked.stores) {\n                fn(store, linked);\n            }\n        }\n    }\n    /**\n     * This yields `true` if this record is eligible for syncing with the server.\n     * It can yield `false` if the record is in the middle of a {@link #property-isBatchUpdating batched update},\n     * or if it is a {@link #property-isCreating tentative record} yet to be confirmed as a new addition.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isPersistable() {\n        // Record is not persistable if the owning app is in the middle of a batch update\n        // and the record is not flagged as being in the middle of a creation sequence.\n        // This means that a \"new\" record can be added on a conditional basis with its\n        // isCreating property set which means it is examplt from being synced until\n        // the isCreating flag is cleared.\n        return !this.isBatchUpdating && !this.isCreating;\n    }\n    /**\n     * True if this model has any uncommitted changes.\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isModified() {\n        return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);\n    }\n    get hasPersistableChanges() {\n        return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);\n    }\n    /**\n     * Returns true if this model has uncommitted changes for the provided field.\n     * @param {String} fieldName Field name\n     * @returns {Boolean} True if the field is changed\n     * @category Editing\n     */\n    isFieldModified(fieldName) {\n        return this.isModified && fieldName in this.meta.modified;\n    }\n    /**\n     * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.\n     * @param {String|Core.data.field.DataField} nameOrField Name of the field to get value for, or its field definition\n     * @private\n     * @category Fields\n     */\n    getFieldPersistentValue(nameOrField) {\n        const\n            field = typeof nameOrField === 'string' ? this.getFieldDefinition(nameOrField) : nameOrField,\n            name  = field?.name || nameOrField;\n        let result;\n        if (!field || field.persist) {\n            result = this[name];\n            // if serialize function is provided we use it to prepare the persistent value\n            if (field?.serialize) {\n                result = field.serialize(result, this);\n            }\n        }\n        return result;\n    }\n    /**\n     * Get a map of the modified fields in form of an object. The field *names* are used as the property names\n     * in the returned object.\n     * @property {Object}\n     * @readonly\n     * @category Editing\n     */\n    get modifications() {\n        const data = this.rawModifications;\n        if (data && Object.keys(data).length) {\n            data[this.constructor.idField] = this.id;\n        }\n        return data;\n    }\n    get rawModifications() {\n        const\n            me = this,\n            data = {};\n        if (!me.isModified) {\n            return null;\n        }\n        let keySet = false;\n        Object.keys(me.meta.modified).forEach(key => {\n            const value = me.getFieldPersistentValue(key);\n            if (value !== _undefined) {\n                data[key] = value;\n                keySet = true;\n            }\n        });\n        return keySet ? data : null;\n    }\n    /**\n     * Get a map of the modified fields in form of an object. The field\u00B4s {@link Core.data.field.DataField#config-dataSource}\n     * is used as the property name in the returned object. The record\u00B4s id is always included.\n     * @property {Object}\n     * @readonly\n     * @category Editing\n     */\n    get modificationData() {\n        const data = this.rawModificationData;\n        // If there are some persistable field changes, append record id\n        if (data && Object.keys(data).length) {\n            ObjectHelper.setPath(data, this.constructor.idField, this.id);\n        }\n        return data;\n    }\n    /**\n     * Returns a map of the modified persistable fields\n     * @internal\n     * @property {Object}\n     * @category Editing\n     */\n    get rawModificationData() {\n        const\n            me = this,\n            { fieldMap } = me.constructor,\n            data = {};\n        if (!me.isModified) {\n            return null;\n        }\n        let keySet = false;\n        Object.keys(me.meta.modified).forEach(fieldName => {\n            const field = fieldMap[fieldName];\n            // No field definition means there's no original dataSource to update\n            if (field?.persist) {\n                const value = me.getFieldPersistentValue(fieldName);\n                if (value !== _undefined) {\n                    ObjectHelper.setPath(data, field.dataSource, value);\n                    keySet = true;\n                }\n            }\n        });\n        return keySet ? data : null;\n    }\n    /**\n     * Get a map of the modified data fields along with any {@link Core/data/field/DataField#config-alwaysWrite} fields,\n     * in form of an object. The field\u00B4s *dataSource* is used as the property name in the returned object.\n     * Used internally by AjaxStore / CrudManager when sending updates.\n     * @property {Object}\n     * @readonly\n     * @category Editing\n     */\n    get modificationDataToWrite() {\n        const\n            alwaysWriteFields = this.constructor.alwaysWriteFields,\n            recordData        = this.modificationData;\n        alwaysWriteFields.forEach(fieldName => {\n            recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);\n        });\n        return recordData;\n    }\n    /**\n     * Returns data for **all** {@link Core.data.field.DataField#config-persist persistable} fields in form of an\n     * object, using dataSource if present.\n     * @property {Object}\n     * @internal\n     * @readonly\n     * @category Editing\n     */\n    get persistableData() {\n        const\n            me   = this,\n            data = {};\n        me.fields.forEach(field => {\n            const value = me.getFieldPersistentValue(field);\n            if (value !== _undefined) {\n                if (field?.complexMapping) {\n                    ObjectHelper.setPath(data, field.dataSource, value);\n                }\n                else {\n                    data[field.dataSource] = value;\n                }\n            }\n        });\n        return data;\n    }\n    get dataByFieldName() {\n        const { data } = this;\n        return this.fields.reduce((result, field) => {\n            if (ObjectHelper.hasPath(data, field.dataSource)) {\n                result[field.name] = data[field.dataSource];\n            }\n            return result;\n        }, {});\n    }\n    /**\n     * True if this models changes are currently being committed.\n     * @property {Boolean}\n     * @category Editing\n     */\n    get isCommitting() {\n        return Boolean(this.meta.committing);\n    }\n    /**\n     * Clear stored changes, used on commit. Does not revert changes.\n     * @param {Boolean} [includeDescendants] Supply `false` to not clear node descendants\n     * @privateparam {Boolean} [removeFromStoreChanges] Update related stores modified collection or not\n     * @privateparam {Object|null} [changes] Set of changes to clear on the record\n     * @category Editing\n     */\n    clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {\n        const\n            me = this,\n            { meta } = me;\n        // If we've received an object with changes, we only need to clean that one up\n        if (changes) {\n            for (const key in changes) {\n                delete meta.modified[key];\n            }\n        }\n        else {\n            meta.modified = {};\n        }\n        // We can only remove record from changes if we no modified fields in meta\n        const noChanges = ObjectHelper.isEmpty(meta.modified);\n        meta.committing = false;\n        if (removeFromStoreChanges) {\n            me.stores.forEach(store => {\n                noChanges && store.modified.remove(me);\n                store.added.remove(me);\n                if (includeDescendants) {\n                    const descendants = store.collectDescendants(me).all;\n                    store.added.remove(descendants);\n                    noChanges && store.modified.remove(descendants);\n                }\n            });\n        }\n    }\n    storeFieldChange(key, oldValue) {\n        this.meta.modified[key] = oldValue;\n    }\n    /**\n     * Reverts changes in this back to their original values.\n     * @privateparam {Boolean} [silent] Specify `true` to not trigger events.\n     * @category Editing\n     */\n    revertChanges(silent = false) {\n        // Flag checked by engine to not set startDate constraint on revert\n        this.isReverting = true;\n        this.set(this.meta.modified, _undefined, silent);\n        this.isReverting = false;\n    }\n    applyChangeset(rawChanges, phantomIdField = '$PhantomId', remote = true) {\n        const\n            me                     = this,\n            modelClass             = me.constructor,\n            {\n                idField,\n                fieldDataSourceMap\n            } = modelClass,\n            rawChangesSimplePaths  = ObjectHelper.pathifyKeys(rawChanges),\n            ownChangesSimplePaths  = ObjectHelper.pathifyKeys(me.modificationData),\n            changes                = {},\n            // Value of id field cannot be changed, it can only be set. In which case phantom id field will be in the\n            // rawChanges objects\n            idChanged              = phantomIdField in rawChanges;\n        // Collect the changes into a change set for field names.\n        for (const dataSource in rawChangesSimplePaths) {\n            const\n                field    = fieldDataSourceMap[dataSource],\n                propName = field?.name ?? dataSource;\n            // Only apply change to the model:\n            // 1. if changes is remote\n            // 2. or local change is not outdated\n            // 3. we are setting id (in which case phantom id would be in raw changes). id value cannot be changed here,\n            // only assigned if record is phantom - because we use id from the raw data to resolve this record in the\n            // first place\n            if (\n                remote ||\n                (\n                    field?.name === idField\n                        ? idChanged\n                        : (rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])\n                )\n            ) {\n                changes[propName] = rawChangesSimplePaths[dataSource];\n            }\n        }\n        // Apply all changes in one go, making sure record is considered unmodified after\n        const wasSet = me.set(changes);\n        me.clearChanges(false, true, remote ? null : changes);\n        // wasSet has format { field : { oldValue, value }}, convert to { field : value }\n        return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {\n            result[field] = change.value;\n            return result;\n        }, {}) : {};\n    }\n    //endregion\n    //region Id\n    /**\n     * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.\n     * @property {Number}\n     * @category Identification\n     */\n    get internalId() {\n        return this._internalId;\n    }\n    /**\n     * Returns true if the record is new and has not been persisted (and received a proper id).\n     * @property {Boolean}\n     * @readonly\n     * @category Identification\n     */\n    get isPhantom() {\n        return this.id === '' || this.id == null || this.hasGeneratedId;\n    }\n    get isModel() {\n        return true;\n    }\n    /**\n     * Checks if record has a generated id.\n     *\n     * New records are assigned a generated id based on a UUID (starting with `_generated`), which is intended to be\n     * temporary and should be replaced by the backend on commit.\n     *\n     * @property {Boolean}\n     * @category Identification\n     */\n    get hasGeneratedId() {\n        return typeof this.id === 'string' && this.id.startsWith('_generated');\n    }\n    static generateId(text = this.$$name) {\n        return `_generated${text}_${StringHelper.generateUUID()}`;\n    }\n    /**\n     * Generates an id for a new record (a phantom id), based on a UUID (starting with `_generated`).\n     *\n     * Generated ids are intended to be temporary and should be replaced by the backend on commit.\n     *\n     * @category Identification\n     * @returns {String}\n     */\n    generateId() {\n        return this.constructor.generateId();\n    }\n    /**\n     * Gets the id of specified model or model data object, or the value if passed string/number.\n     * @param {Core.data.Model|String|Number} model\n     * @returns {String|Number} id\n     * @category Identification\n     */\n    static asId(model) {\n        return model?.isModel ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;\n    }\n    //endregion\n    //region JSON\n    /**\n     * Get the records data as a json string.\n     *\n     * ```javascript\n     * const record = new Model({\n     *     title    : 'Hello',\n     *     children : [\n     *         ...\n     *     ]\n     * });\n     *\n     * const jsonString = record.json;\n     *\n     * //jsonString:\n     * '{\"title\":\"Hello\",\"children\":[...]}'\n     * ```\n     *\n     * @member {String}\n     * @category JSON\n     */\n    get json() {\n        return StringHelper.safeJsonStringify(this);  // calls our toJSON() method\n    }\n    /**\n     * Used by `JSON.stringify()` to correctly convert this record to json.\n     *\n     * In most cases no point in calling it directly.\n     *\n     * ```\n     * // This will call `toJSON()`\n     * const json = JSON.stringify(record);\n     * ```\n     *\n     * If called manually, the resulting object is a clone of `record.data` + the data of any children:\n     *\n     * ```\n     * const record = new Model({\n     *     title    : 'Hello',\n     *     children : [\n     *         ...\n     *     ]\n     * });\n     *\n     * const jsonObject = record.toJSON();\n     *\n     * // jsonObject:\n     * {\n     *     title : 'Hello',\n     *     children : [\n     *         ...\n     *     ]\n     * }\n     * ```\n     *\n     * @returns {Object}\n     * @category JSON\n     */\n    toJSON() {\n        const\n            { children, unfilteredChildren } = this,\n            jsonData                         = this.persistableData;\n        if (unfilteredChildren || children) {\n            jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map(c => c.toJSON());\n        }\n        return jsonData;\n    }\n    /**\n     * Represent the record as a string, by default as a JSON string. Tries to use an abbreviated version of the\n     * object's data, using id + name/title/text/label/description. If no such field exists, the full data is used.\n     *\n     * ```javascript\n     * const record = new Model({ id : 1, name : 'Steve Rogers', alias : 'Captain America' });\n     * console.log(record.toString()); // logs { \"id\" : 1, \"name\" : \"Steve Rogers\" }\n     * ```\n     *\n     * @returns {String}\n     * @category JSON\n     */\n    toString() {\n        const\n            me        = this,\n            nameField = abbreviationFields.find(field => field in me.constructor.fieldMap),\n            data      = nameField ? { [me.constructor.idField] : me.id, [nameField] : me[nameField] } : me.data;\n        return StringHelper.safeJsonStringify(data);\n    }\n    //endregion\n    //region Batch\n    /**\n     * True if this Model is currently batching its changes.\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isBatchUpdating() {\n        return Boolean(this.batching);\n    }\n    /**\n     * Returns `true` if this Model currently has outstanding batched changes for the specified field name.\n     * @param {String} fieldName The field name to check for batched updates on.\n     * @returns {Boolean}\n     * @category Editing\n     */\n    hasBatchedChange(fieldName) {\n        return this.meta?.batchChanges?.[fieldName];\n    }\n    /**\n     * Begin a batch, which stores changes and commits them when the batch ends.\n     * Prevents events from being fired during batch.\n     *\n     * ```javascript\n     * record.beginBatch();\n     * record.name = 'Mr Smith';\n     * record.team = 'Golden Knights';\n     * record.endBatch();\n     * ```\n     *\n     * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many\n     * cases can replace using a batch:\n     *\n     * ```javascript\n     * record.set({\n     *   name : 'Mr Smith',\n     *   team : 'Golden Knights'\n     * });\n     * ```\n     * @category Editing\n     * @privateparam {Boolean} silentUpdates Suppress firing the `batchUpdatedEvent`\n     */\n    beginBatch(silentUpdates = false) {\n        const me = this;\n        if (!me.batching) {\n            me.batching = 0;\n            me.meta.batchChanges = {};\n        }\n        if (silentUpdates) {\n            me.$silenceBatch = (me.$silenceBatch || 0) + 1;\n        }\n        me.batching++;\n    }\n    /**\n     * End a batch, triggering events if data has changed.\n     * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.\n     * @privateparam {Boolean} [silent=false] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.\n     * @privateparam {Boolean} [triggerBeforeUpdate=true]\n     * @category Editing\n    */\n    endBatch(silent = false, skipAccessors = false, triggerBeforeUpdate = true) {\n        const\n            me                = this,\n            { parentIdField } = me.constructor;\n        if (!me.batching) {\n            return;\n        }\n        me.batching--;\n        // Ideally we should track which batch was silenced, but that will complicate code more than what avoiding a few\n        // triggered events is worth (this is private and we do not start batches while batches are ongoing in the\n        // critical code path in engine)\n        me.$silenceBatch && me.$silenceBatch--;\n        if (me.batching > 0) {\n            return;\n        }\n        // Set pending batch changes\n        if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {\n            let { batchChanges } = me.meta;\n            me.meta.batchChanges = null;\n            // Move to its new parent before applying the other changes.\n            if (batchChanges[parentIdField]) {\n                batchChanges = { ...batchChanges };\n                me.parentId = batchChanges[parentIdField];\n                delete batchChanges[parentIdField];\n            }\n            me.set(batchChanges, _undefined, silent, false, skipAccessors, undefined, triggerBeforeUpdate);\n        }\n    }\n    /**\n     * Cancels current batch operation. Any changes during the batch are discarded.\n     * @category Editing\n     */\n    cancelBatch() {\n        if (this.batching) {\n            const\n                me               = this,\n                { batchChanges } = me.meta,\n                wasSet           = {};\n            me.batching = null;\n            me.meta.batchChanges = null;\n            me.generation++;\n            if (!me.$silenceBatch) {\n                // Create a wasSet describing the revert back from the batched values to the real values.\n                Object.entries(batchChanges).forEach(([key, oldValue]) => {\n                    wasSet[key] = {\n                        oldValue,\n                        value : me[key]\n                    };\n                });\n                // Fire batched events for UIs which need to update themselves during batched updates.\n                // An example is evenResize feature which batches the changes to the endDate\n                // or startDate, but the UI must update during the drag.\n                const event = {\n                    action  : 'update',\n                    record  : me,\n                    records : [me],\n                    changes : wasSet\n                };\n                me.stores.forEach(store => {\n                    // Cant use event directly, it will get polluted with `source` and then have that incorrect for\n                    // following calls\n                    store.trigger('batchedUpdate', { ...event });\n                });\n                // Propagate to linked records\n                me.forEachLinked((store, record) => {\n                    store.trigger('batchedUpdate', { ...event, record, records : [record] });\n                });\n            }\n            me.$silenceBatch && me.$silenceBatch--;\n        }\n    }\n    //endregion\n    //region Events\n    /**\n     * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.\n     * @param {Object} changes Data changes\n     * @returns {Boolean} returns true if data changes are accepted\n     * @private\n     */\n    triggerBeforeUpdate(changes) {\n        return !this.stores?.some(s => s.trigger('beforeUpdate', { record : this, changes }) === false);\n    }\n    //endregion\n    //region Additional functionality\n    /**\n     * Makes a copy of this model, assigning the specified id or a generated id and also allowing you to pass field values to\n     * the created copy.\n     *\n     * ```\n     * const record = new Model({ name : 'Super model', hairColor : 'Brown' });\n     * const clone = record.copy({ name : 'Super model clone' });\n     * ```\n     * @param {Number|String|Object} [newId] The id for the copied instance, or any field values to apply\n     * (overriding the values from the source record). If no id provided, one will be auto-generated\n     * @param {Boolean} [deep] True to also clone children\n     * @returns {Core.data.Model} Copy of this model\n     * @category Editing\n     */\n    copy(newId = null, deep) {\n        const\n            me      = this,\n            data    = ObjectHelper.clone(me.data),\n            idField = me.constructor.idField,\n            // Chrono model is adding more logic to copy and that logic should be manageable from arguments. So there is\n            // option to pass object as a last argument to switch method behavior. Used internally only, shouldn't be public.\n            useDeep = ObjectHelper.isObject(deep) ?  deep.deep : deep;\n        let id;\n        if (newId && typeof newId === 'object') {\n            id = newId[idField];\n            Object.assign(data, newId);\n        }\n        else {\n            id = newId;\n        }\n        // Iterate over instance children, because data may not reflect actual children state.\n        // Copy's initial expanded state will be from the \"expanded\" property of the data object\n        // which is cloned from the source.\n        if (useDeep && me.children) {\n            data.children = me.children.map(child => child.copy(undefined, deep));\n        }\n        else {\n            delete data.children;\n            delete data.expanded;\n        }\n        if (me.$meta.fields.initable.length > 0) {\n            const json    = me.toJSON();\n            for (const field of me.$meta.fields.initable) {\n                data[field.name] = json[field.name];\n            }\n        }\n        if (newId !== false) {\n            // We can use the value from the 'id' property, but as a fallback, generate the id.\n            data[idField] = id || me.generateId(me.firstStore);\n        }\n        // Force using raw data when creating a copy, since data was cloned above anyway\n        const copy = new me.constructor(data, null, null, false, true);\n        // Store original record internal id to lookup from copy later\n        copy.originalInternalId = me.internalId;\n        return copy;\n    }\n    // Copies data using the real field names to trigger setters\n    copyData(fromRecord, raw, silent) {\n        const propertiesAndValues = {};\n        fromRecord.allFields.forEach(({ name : fieldName }) => {\n            if (fieldName !== fromRecord.constructor.idField) {\n                propertiesAndValues[fieldName] = raw ? fromRecord.get(fieldName) : fromRecord[fieldName];\n            }\n        });\n        this.set(propertiesAndValues, null, silent);\n    }\n    /**\n     * Removes this record from all stores (and in a tree structure, also from its parent if it has one).\n     * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.\n     * @category Editing\n     */\n    remove(silent = false) {\n        const\n            me         = this,\n            { parent } = this;\n        // Remove from parent if we're in a tree structure.\n        // This informs the owning store(s)\n        if (parent) {\n            parent.removeChild(me);\n        }\n        // Store handles remove\n        // Not sure what should happen if you try to remove a special row (group row for example), bailing out\n        else if (me.stores.length && !me.isSpecialRow) {\n            me.stores.forEach(s => s.remove(me, silent, false, true));\n        }\n    }\n    // Called by stores before removing the record from the store. Returning false prevents the removal (overridden in\n    // ModelLink.js)\n    beforeRemove(stores, records) {\n        return super.beforeRemove(stores, records);\n    }\n    //endregion\n    //region Validation\n    /**\n     * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.\n     * @property {Boolean}\n     * @category Editing\n     */\n    get isValid() {\n        return true;\n    }\n    //endregion\n    //region Store\n    /**\n     * Get the first store that this model is assigned to.\n     * @property {Core.data.Store}\n     * @readonly\n     * @category Misc\n     */\n    get firstStore() {\n        return this.stores.length > 0 && this.stores[0];\n    }\n    /**\n     * Joins this record and any children to specified store, if not already joined.\n     * @internal\n     * @param {Core.data.Store} store Store to join\n     * @category Misc\n     */\n    joinStore(store) {\n        const\n            me         = this,\n            { stores } = me;\n        if (!stores.includes(store)) {\n            const { unjoinedStores } = me;\n            super.joinStore(store);\n            store.register(me);\n            stores.push(store);\n            if (unjoinedStores.includes(store)) {\n                unjoinedStores.splice(unjoinedStores.indexOf(store), 1);\n            }\n            me.isLoaded && me.children.forEach(child => child.joinStore(store));\n            me.initRelations();\n            // do not change the collapsed state during stm restoring\n            if (store.tree && !me.isRoot && !store.stm?.isRestoring) {\n                me.instanceMeta(store.id).collapsed = !me.expanded;\n            }\n        }\n    }\n    /**\n     * Unjoins this record and any children from specified store, if already joined.\n     * @internal\n     * @param {Core.data.Store} store Store to join\n     * @param {Boolean} [isReplacing] `true` if this record is being replaced\n     * @category Misc\n     */\n    unjoinStore(store, isReplacing = false) {\n        const me = this,\n            { stores, unjoinedStores } = me;\n        if (stores.includes(store)) {\n            if (!store.isDestroying) {\n                store.unregister(me);\n                unjoinedStores.push(store);\n            }\n            // me.children may === true...\n            // If filtered, *all* children must be unjoined when we are.\n            (me.unfilteredChildren || me.children)?.forEach?.(child => child.unjoinStore(store, isReplacing));\n            stores.splice(stores.indexOf(store), 1);\n            // keep the cord to allow removed records to reach the store when needed\n            super.unjoinStore?.(store, isReplacing);\n            // remove from relation cache\n            store.uncacheRelatedRecord(me);\n        }\n    }\n    /**\n     * Returns true if this record is contained in the specified store, or in any store if store param is omitted.\n     * @internal\n     * @param {Core.data.Store} store Store to join\n     * @returns {Boolean}\n     * @category Misc\n     */\n    isPartOfStore(store) {\n        if (store) {\n            return store.includes(this);\n        }\n        return this.stores.length > 0;\n    }\n    /**\n     * Returns true if this record is not part of any store.\n     * @property {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isRemoved() {\n        return !this.isPartOfStore();\n    }\n    //endregion\n    //region Per instance meta\n    /**\n     * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state\n     * per grid.\n     * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property\n     * @private\n     * @category Misc\n     */\n    instanceMeta(instanceOrId) {\n        const\n            { meta } = this,\n            id       = instanceOrId.id || instanceOrId;\n        if (!meta.map) {\n            meta.map = {};\n        }\n        return meta.map[id] || (meta.map[id] = {});\n    }\n    /**\n     * When called on a group header row returns list of records in that group. Returns `undefined` otherwise.\n     * @member {Core.data.Model[]|undefined} groupChildren\n     * @category Grouping\n     * @readonly\n     */\n    /**\n     * Returns true for a group header record\n     * @member {Boolean}\n     * @category Grouping\n     * @readonly\n     */\n    get isGroupHeader() {\n        return 'groupRowFor' in this.meta;\n    }\n    get isGroupFooter() {\n        return 'groupFooterFor' in this.meta;\n    }\n    get isSpecialRow() {\n        return Boolean(this.meta?.specialRow);\n    }\n    get $original() {\n        return this.isLinked ? this.proxyMeta.originalRecord : this;\n    }\n    //endregion\n    static get nonPersistableFields() {\n        const me = this;\n        if (!me._nonPersistableFields) {\n            me._nonPersistableFields = {};\n            me.allFields.forEach(field => {\n                if (!field.persist || field.calculated) {\n                    me._nonPersistableFields[field.name] = 1;\n                }\n            });\n        }\n        return me._nonPersistableFields;\n    }\n    static get alwaysWriteFields() {\n        const me = this;\n        if (!me._alwaysWriteFields) {\n            me._alwaysWriteFields = [];\n            me.allFields.forEach(field => {\n                if (field.alwaysWrite) {\n                    me._alwaysWriteFields.push(field.name);\n                }\n            });\n        }\n        return me._alwaysWriteFields;\n    }\n    // Id with spaces and dots replaced by -, for safe usage as an id in DOM\n    get domId() {\n        return typeof this.id === 'string' ? this.id.replace(/[ .]/g, '-') : this.id;\n    }\n    //region Extract config\n    // These functions are not meant to be called by any code other than Base#getCurrentConfig()\n    // Convert custom modelClass to string, keeping custom fields\n    static toJavaScriptValue(options) {\n        // Get name, skipping the automatically extended name that goes last (MyModel, not MyModelEx)\n        const\n            { names } = this.$meta,\n            className = names[names.length - 2],\n            superName =  names[names.length - 3];\n        return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;\n    }\n    // Get fields current values\n    getCurrentConfig(options) {\n        const\n            { data, children }              = this,\n            { defaultValues, applyConfigs } = this.constructor,\n            result                          = applyConfigs ? super.getCurrentConfig(options) : {};\n        if (result) {\n            for (const field of this.fields) {\n                if (field.persist) {\n                    const value = ObjectHelper.getPath(data, field.dataSource);\n                    if (!field.isEqual(value, defaultValues[field.name])) {\n                        ObjectHelper.setPath(result, field.dataSource, Base.processConfigValue(value, options));\n                    }\n                }\n            }\n            // Always include children\n            if (children) {\n                // Inline available children\n                if (Array.isArray(children)) {\n                    result.children = [];\n                    for (const child of children) {\n                        result.children.push(child.getCurrentConfig(options));\n                    }\n                }\n                // Load on demand\n                else {\n                    result.children = children;\n                }\n            }\n            if (this.hasGeneratedId) {\n                delete result.id;\n            }\n            delete result.parentId;\n            delete result.parentIndex;\n        }\n        return result;\n    }\n    //endregion\n}\nModel._idField = 'id';\nModel._internalIdCounter = 1;\nModel._assignedIdField = false;\nModel.exposeProperties();\nModel._$name = 'Model';", "import DateHelper from '../helper/DateHelper.js';\n/**\n * @module Core/data/Duration\n */\n/**\n * Object describing a duration.\n * @typedef {Object} DurationConfig\n * @property {Number} magnitude The magnitude of the duration\n * @property {String} unit The unit of the duration\n */\n/**\n * Class which represents a duration object. A duration consists of a `magnitude` and a `unit`.\n *\n * ```javascript\n * {\n *    unit      : String,\n *    magnitude : Number\n * }\n * ```\n *\n * Valid values are:\n * - \"millisecond\" - Milliseconds\n * - \"second\" - Seconds\n * - \"minute\" - Minutes\n * - \"hour\" - Hours\n * - \"day\" - Days\n * - \"week\" - Weeks\n * - \"month\" - Months\n * - \"quarter\" - Quarters\n * - \"year\"- Years\n */\nexport default class Duration {\n    /**\n     * Duration constructor.\n     * @param {Number|String} magnitude Duration magnitude value or a duration + magnitude string ('2h', '4d')\n     * @param {String} [unit] Duration unit value\n     */\n    constructor(magnitude, unit) {\n        // we treat `magnitude === null` specially, it indicates the user intention\n        // to unschedule the task\n        if (typeof magnitude === 'number' || magnitude === null) {\n            this._magnitude = magnitude;\n            this._unit = unit;\n        }\n        else {\n            if (typeof magnitude === 'string') {\n                Object.assign(this, DateHelper.parseDuration(magnitude));\n            }\n            if (typeof magnitude === 'object') {\n                Object.assign(this, magnitude);\n            }\n        }\n    }\n    /**\n     * Get/Set numeric magnitude `value`.\n     * @property {Number}\n     */\n    get magnitude() {\n        return this._magnitude;\n    }\n    set magnitude(value) {\n        this._magnitude = (typeof value === 'number') && value;\n    }\n    /**\n     * Get/Set duration unit to use with the current magnitude value.\n     * Valid values are:\n     * - \"millisecond\" - Milliseconds\n     * - \"second\" - Seconds\n     * - \"minute\" - Minutes\n     * - \"hour\" - Hours\n     * - \"day\" - Days\n     * - \"week\" - Weeks\n     * - \"month\" - Months\n     * - \"quarter\" - Quarters\n     * - \"year\"- Years\n     *\n     * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n     */\n    get unit() {\n        return this._unit;\n    }\n    set unit(value) {\n        this._unit = DateHelper.parseTimeUnit(value);\n    }\n    get isValid() {\n        return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));\n    }\n    /**\n     * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration\n     * @property {Number}\n     * @readonly\n     */\n    get milliseconds() {\n        // There's no smaller time unit in the Date class than milliseconds, so round any divided values\n        return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;\n    }\n    /**\n     * Returns truthy value if this Duration equals the passed value.\n     * @param {Core.data.Duration} value\n     * @returns {Boolean}\n     */\n    isEqual(value) {\n        return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;\n    }\n    toString(useAbbreviation) {\n        const\n            me             = this,\n            abbreviationFn = useAbbreviation ? 'getShortNameOfUnit' : 'getLocalizedNameOfUnit';\n        return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : '';\n    }\n    toJSON() {\n        return this.toString();\n    }\n    valueOf() {\n        return this.milliseconds;\n    }\n};\nDuration._$name = 'Duration';", "import Base from '../Base.js';\nimport DateHelper from '../helper/DateHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport FunctionHelper from '../helper/FunctionHelper.js';\nimport Identifiable from '../mixin/Identifiable.js';\nimport Duration from '../data/Duration.js';\n/**\n * @module Core/util/CollectionFilter\n */\nconst\n    nestedValueReducer = (object, path) => object?.[path],\n    relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i,\n    relativeDateOperators = [\n        'isToday',\n        'isTomorrow',\n        'isYesterday',\n        'isThisWeek',\n        'isNextWeek',\n        'isLastWeek',\n        'isThisMonth',\n        'isNextMonth',\n        'isLastMonth',\n        'isThisYear',\n        'isNextYear',\n        'isLastYear',\n        'isYearToDate'\n    ];\n/**\n * A class which encapsulates a single filter operation which may be applied to any object to decide whether to\n * include or exclude it from a set.\n *\n * A CollectionFilter generally has at least three main properties:\n *\n * * `property` - The name of a property in candidate objects from which to extract the value to test\n * * `value` - The value which  this filter uses to test against.\n * * `operator` - The comparison operator, eg: `'='` or `'>'` etc.\n *\n * Given these three essential values, further configurations may affect how the filter is applied:\n *\n * * `caseSensitive` - If configured as `false`, string comparisons are case insensitive.\n * * `convert` - A function which, when passed the extracted value from the candidate object, returns the value to test.\n *\n * A filter may also be configured with a single `filterBy` property. This function is just passed the raw\n * candidate object and must return `true` or `false`.\n *\n * A CollectionFilter may be configured to encapsulate a single filtering function by passing that function as the sole\n * parameter to the constructor:\n *\n *     new CollectionFilter(candidate => candidate.title.contains('search string'));\n *\n */\nexport default class CollectionFilter extends Base.mixin(Identifiable) {\n    static $name = 'CollectionFilter';\n    static get defaultConfig() {\n        return {\n            /**\n             * The value against which to compare the {@link #config-property} of candidate objects.\n             * @config {*}\n             */\n            value : null,\n            /**\n             * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.\n             * May be:\n             * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,\n             * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,\n             * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`, `'sameDay'`,\n             * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,\n             * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',\n             * `'isTrue'`, `'isFalse'`\n             * @config {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'sameDay'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}\n             */\n            operator : null,\n            /**\n             * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which\n             * accepts a candidate object and returns `true` or `false`\n             * @config {Function}\n             */\n            filterBy : null,\n            /**\n             * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and\n             * returns the value which the filter should use to compare against its {@link #config-value}.\n             * @config {Function}\n             */\n            convert : null,\n            /**\n             * Configure as `false` to have string comparisons case insensitive.\n             * @config {Boolean}\n             * @default\n             */\n            caseSensitive : true,\n            /**\n             * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.\n             * By default the `id` is the {@link #config-property} value.\n             * @config {String}\n             */\n            id : null,\n            // Type is required to process the Date value in State API. Store doesn't always know about field type to\n            // process filter value, when it applies it from the state, e.g. when you don't declare model field as `date`\n            // type but provide a Date instance there. When DateColumn is used to shows this field, it could add date\n            // filters to the store. When store is applying state it cannot just infer type, because model doesn't\n            // declare it. Only column knows. So to properly process the Date instance for the filter State API would\n            // have to process the field additionally, checking model field type and column type. So it is simpler to\n            // make Filter to put this information. That way when filter is instantiated by the store, it can gracefully\n            // handle value processing, converting date string to the Date instance.\n            // Date is the only known value type so far which requires this processing.\n            type : null,\n            /**\n             * Setting the `internal` config on a filter means that it is a fixed part of your store's operation.\n             *\n             * {@link Core.data.Store#function-clearFilters} does not remove `internal` filters. If you add an\n             * `internal` filter, you must explicitly remove it if it is no longer required.\n             *\n             * Grid features which offer column-based filtering do *not* ingest existing store filters on\n             * their data field if the filter is `internal`\n             * @config {Boolean}\n             * @default false\n             */\n            internal : null,\n            /**\n             * When `true`, the filter will not be applied.\n             * @config {Boolean}\n             * @default\n             */\n            disabled : false\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.\n             * @member {String} property\n             */\n            /**\n             * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.\n             * @config {String}\n             */\n            property : null\n        };\n    }\n    construct(config) {\n        if (typeof config === 'function') {\n            config = {\n                filterBy : config\n            };\n        }\n        // If Filter is created without a type (yet everything except applying state) create one\n        if (!config.type) {\n            if (DateHelper.isDate(config.value) || (Array.isArray(config.value) && config.value.every(DateHelper.isDate))) {\n                config.type = 'date';\n            }\n            else if (config.value instanceof Duration) {\n                config.type = 'duration';\n            }\n        }\n        // If type already exist, it means we are applying state and should process value\n        else {\n            if (config.type === 'date' && config.value != null && !Array.isArray(config.value)) {\n                config.value = new Date(config.value);\n            }\n            else if (config.type === 'duration' && config.value != null && !Array.isArray(config.value)) {\n                config.value = new Duration(config.value);\n            }\n        }\n        super.construct(config);\n    }\n    /**\n     * When in a Collection (A Collection holds its Filters in a Collection), we need an id.\n     * @property {String}\n     * @private\n     */\n    get id() {\n        if (!this._id) {\n            // Internal filters get a special, unique property so that they cannot collide\n            // with default filters for a field.\n            if (this.internal) {\n                this._id = CollectionFilter.generateId(`b-internal-${this.property}-filter-`);\n            }\n            else {\n                this._id = this.property || CollectionFilter.generateId('b-filter-');\n            }\n        }\n        return this._id;\n    }\n    set id(id) {\n        this._id = id;\n    }\n    onChange(propertyChanged) {\n        const me = this;\n        // Inform any owner (eg a Store), that it has to reassess its CollectionFilters\n        if (!me.isConfiguring && me.owner?.onFilterChanged && !me.owner.isConfiguring) {\n            me.owner.onFilterChanged(me, propertyChanged);\n        }\n    }\n    get filterBy() {\n        return this._filterBy || this.defaultFilterBy;\n    }\n    /**\n     * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which\n     * accepts a candidate object and returns `true` or `false`\n     * @type {Function}\n     */\n    set filterBy(filterBy) {\n        this._filterBy = filterBy;\n    }\n    defaultFilterBy(candidate) {\n        const me = this;\n        let candidateValue;\n        // check if is nested property\n        if (me._propertyItems.length > 1) {\n            // support nested props (https://github.com/bryntum/support/issues/1861)\n            candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);\n        }\n        else {\n            candidateValue = candidate[me.property];\n        }\n        return me[me.operator](me.convert(candidateValue));\n    }\n    updateProperty(property) {\n        this._propertyItems = property.split('.');\n        // Signal to owner about filter change\n        this.onChange('property');\n    }\n    /**\n     * The value against which to compare the {@link #config-property} of candidate objects.\n     * @type {*}\n     */\n    set value(value) {\n        const me = this;\n        me._value = value;\n        // Filter value is a processed value to be used by the comparators. Useful when value is object, like Duration field\n        if (Array.isArray(value) && (\n            { date : 1, duration : 1 }[me.type] ||\n            (value.length > 0 && typeof value[0] === 'string')\n        )) {\n            me._filterValue = value.map(v => me.convert(v));\n        }\n        else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === 'string') {\n            me._filterValue = value.map(s => s?.toLowerCase());\n        }\n        else if (!me.caseSensitive && typeof value === 'string') {\n            me._filterValue = value.toLowerCase();\n        }\n        else {\n            me._filterValue = me.convert(value);\n        }\n        // Signal to owner about filter change\n        me.onChange('value');\n    }\n    get value() {\n        return this._value;\n    }\n    get filterValue() {\n        return this._filterValue;\n    }\n    /**\n     * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.\n     * May be:\n     * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,\n     * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,\n     * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`,\n     * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,\n     * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',\n     * `'isTrue'`, `'isFalse'`\n     * @type {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}\n     */\n    set operator(operator) {\n        this._operator = operator;\n        // Signal to owner about filter change\n        this.onChange('operator');\n    }\n    get operator() {\n        const me = this;\n        if (me._operator) {\n            return me._operator;\n        }\n        if (Array.isArray(me.filterValue)) {\n            return 'isIncludedIn';\n        }\n        return typeof me.filterValue === 'string' ? '*' : '=';\n    }\n    convert(value) {\n        // This is a workaround for filterbar feature: it always converts input value to string. When date is typed,\n        // it is converted into string, and Date.valueOf() would return number. So if we are matching date against string\n        // type, we should not convert it.\n        if (this.operator !== 'sameTime' && !(typeof this.filterValue === 'string' && value instanceof Date)) {\n            if (this.operator === 'sameDay') {\n                value = DateHelper.clearTime(value);\n            }\n            // if value is a complex type, try to access `value` property to get primitive value\n            value = value?.valueOf() ?? value;\n        }\n        value = !this.caseSensitive && (typeof value === 'string') ? value.toLowerCase() : value;\n        return value;\n    }\n    filter(candidate) {\n        return this.filterBy(candidate);\n    }\n    startsWith(v) {\n        return String(v).startsWith(this.filterValue);\n    }\n    endsWith(v) {\n        return String(v).endsWith(this.filterValue);\n    }\n    isIncludedIn(v) {\n        return this.filterValue.length === 0 || this.filterValue.includes(v);\n    }\n    isNotIncludedIn(v) {\n        return !this.isIncludedIn(v);\n    }\n    includes(v) {\n        return this.filterValue.length === 0 || String(v).includes(this.filterValue);\n    }\n    doesNotInclude(v) {\n        return !this.includes(v);\n    }\n    sameTime(v) {\n        return DateHelper.isSameTime(v, this.filterValue);\n    }\n    sameDay(v) {\n        return v === this.filterValue;\n    }\n    '='(v) {\n        return ObjectHelper.isEqual(v, this.filterValue);\n    }\n    '!='(v) {\n        return !ObjectHelper.isEqual(v, this.filterValue);\n    }\n    '>'(v) {\n        return ObjectHelper.isMoreThan(v, this.filterValue);\n    }\n    '>='(v) {\n        return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);\n    }\n    '<'(v) {\n        return ObjectHelper.isLessThan(v, this.filterValue);\n    }\n    '<='(v) {\n        return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);\n    }\n    '*'(v) {\n        return ObjectHelper.isPartial(v, this.filterValue);\n    }\n    between(v) {\n        const [start, end] = this._filterValue;\n        return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) &&\n            (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));\n    }\n    notBetween(v) {\n        return !this.between(v);\n    }\n    empty(v) {\n        return v === undefined || v === null || String(v).length === 0;\n    }\n    notEmpty(v) {\n        return !this.empty(v);\n    }\n    isToday(v) {\n        // Values have already been converted to fixed date range\n        return this.between(v);\n    }\n    isTomorrow(v) {\n        return this.between(v);\n    }\n    isYesterday(v) {\n        return this.between(v);\n    }\n    isThisWeek(v) {\n        return this.between(v);\n    }\n    isNextWeek(v) {\n        return this.between(v);\n    }\n    isLastWeek(v) {\n        return this.between(v);\n    }\n    isThisMonth(v) {\n        return this.between(v);\n    }\n    isNextMonth(v) {\n        return this.between(v);\n    }\n    isLastMonth(v) {\n        return this.between(v);\n    }\n    isThisYear(v) {\n        return this.between(v);\n    }\n    isNextYear(v) {\n        return this.between(v);\n    }\n    isLastYear(v) {\n        return this.between(v);\n    }\n    isYearToDate(v) {\n        return this.between(v);\n    }\n    isTrue(v) {\n        return v === true;\n    }\n    isFalse(v) {\n        return v === false;\n    }\n    // Fill in actual dates relative to now\n    setRelativeDateValues() {\n        this._filterValue = CollectionFilter.getRelativeDateRange(this._operator)\n            .map(date => date.valueOf());\n    }\n    static getRelativeDateRange(relativeExpr, now = new Date()) {\n        let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;\n        switch (relativeExpr) {\n            case 'isYearToDate':\n                return [DateHelper.floor(now, '1 year'), now];\n            case 'isToday':\n                todayStart = DateHelper.floor(now, '1 day');\n                return [todayStart, DateHelper.add(todayStart, 1, 'day')];\n            case 'isYesterday':\n                todayStart = DateHelper.floor(now, '1 day');\n                return [DateHelper.add(todayStart, -1, 'day'), todayStart];\n            case 'isTomorrow':\n                tomorrowStart = DateHelper.getStartOfNextDay(now);\n                return [tomorrowStart, DateHelper.add(tomorrowStart, 1, 'day')];\n            case 'isThisWeek':\n            case 'isNextWeek':\n            case 'isLastWeek':\n            case 'isThisMonth':\n            case 'isNextMonth':\n            case 'isLastMonth':\n            case 'isThisYear':\n            case 'isNextYear':\n            case 'isLastYear':\n                parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);\n                if (!parts) {\n                    throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);\n                }\n                [, which, timeUnit] = parts;\n                oneTimeUnit = `1 ${timeUnit}`;\n                unitStart = DateHelper.floor(now, oneTimeUnit);\n                if (which === 'next') {\n                    unitStart = DateHelper.add(unitStart, 1, timeUnit);\n                }\n                else if (which === 'last') {\n                    unitStart = DateHelper.add(unitStart, -1, timeUnit);\n                }\n                return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];\n        }\n    }\n    // Accepts an array or a Collection\n    static generateFiltersFunction(filters) {\n        if (!filters || (!filters.length && !filters.count)) {\n            return FunctionHelper.returnTrue;\n        }\n        for (const filter of filters) {\n            if (filter.type === 'date' && relativeDateOperators.includes(filter._operator)) {\n                filter.setRelativeDateValues();\n            }\n        }\n        return function(candidate) {\n            let match = true;\n            for (const filter of filters) {\n                // Skip disabled filters\n                if (!filter.disabled) {\n                    match = filter.filter(candidate);\n                }\n                if (!match) {\n                    break;\n                }\n            }\n            return match;\n        };\n    }\n}\nCollectionFilter._$name = 'CollectionFilter';", "import ObjectHelper from './ObjectHelper.js';\n/**\n * @module Core/helper/IdHelper\n */\n// Id generation should be on a per page basis, not per module\nconst idCounts = ObjectHelper.getPathDefault(globalThis, 'bryntum.idCounts', Object.create(null));\n/**\n * IdHelper provides unique ID generation.\n *\n * This class is not intended for application use, it is used internally by the Bryntum infrastructure.\n * @internal\n */\nexport default class IdHelper {\n    /**\n     * Generate a new id, using IdHelpers internal counter and a prefix\n     * @param {String} prefix Id prefix\n     * @returns {String} Generated id\n     */\n    static generateId(prefix = 'generatedId') {\n        // This produces \"b-foo-1, b-foo-2, ...\" for each prefix independently of the others. In other words, it makes\n        // id's more stable since the counter is on a per-class basis.\n        return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);\n    }\n}\nIdHelper._$name = 'IdHelper';", "import Base from '../Base.js';\nimport IdHelper from '../helper/IdHelper.js';\n/**\n * @module Core/util/CollectionSorter\n */\n/**\n * A class which encapsulates a single sorter operation which may be applied to a {@link Core.util.Collection} to\n * order its elements in a specific way.\n *\n * A CollectionSorter generally has two properties:\n *\n * * `property` - The name of a property in collection objects by which to sort\n * * `direction` - The sort direction, `'ASC'` or `'DESC'`.\n *\n * It may also be configured with just a {@link #config-sortFn} function which returns the desired comparison\n * result when passed two objects to compare. Note that this does *not* require or use the\n * {@link #config-property} config. Two collection items are passed for comparison.\n *\n * Further configurations may affect how the sorter is applied:\n *\n * * `convert` - A function which, when passed the {@link #config-property} value from\n * a collection object, returns the value to sort by.\n *\n * A CollectionSorter may be configured to encapsulate a {@link #config-sortFn} by passing that function as the sole\n * parameter to the constructor:\n *\n *     new CollectionSorter((lhs, rhs) => {\n *         lhs = lhs.customerDetails.companyName.toLowerCase();\n *         rhs = rhs.customerDetails.companyName.toLowerCase();\n *\n *         if (lhs < rhs) {\n *             return -1;\n *         }\n *         else if (lhs > rhs) {\n *             return 1;\n *         }\n *         else {\n *             return 0;\n *         }\n *     });\n *\n */\nexport default class CollectionSorter extends Base {\n    static get defaultConfig() {\n        return {\n            /**\n             * The name of a property of collection objects which yields the value to sort by.\n             * @config {String}\n             */\n            property : null,\n            /**\n             * The direction to sort in, `'ASC'` or `'DESC'`\n             * @config {'ASC'|'DESC'}\n             * @default\n             */\n            direction : 'ASC',\n            /**\n             * A function which takes the place of using {@link #config-property} and {@link #config-direction}.\n             * The function is passed two objects from the collection to compare and must return the comparison result.\n             * @config {Function}\n             */\n            sortFn : null,\n            /**\n             * When using {@link #config-property}, this may be specified as a function which takes the raw\n             * property value and returns the value to actually sort by.\n             * @config {Function}\n             */\n            convert : null,\n            /**\n             * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.\n             * By default the `id` is the {@link #config-property} value.\n             * @config {String}\n             */\n            id : null,\n            /**\n             * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,\n             * a locale string or a locale config to enable.\n             *\n             * Enabling this has big negative impact on sorting performance. For more info on `localeCompare()`, see\n             * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).\n             *\n             * ```javascript\n             * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });\n             * ```\n             *\n             * @config {Boolean|String|Object}\n             * @default false\n             */\n            useLocaleSort : null\n        };\n    }\n    construct(config) {\n        if (typeof config === 'function') {\n            config = {\n                sortFn : config\n            };\n        }\n        super.construct(config);\n    }\n    /**\n     * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.\n     * @property {String}\n     * @private\n     */\n    get id() {\n        return this._id || (this._id = this.property || IdHelper.generateId('b-sorter'));\n    }\n    set id(id) {\n        this._id = id;\n    }\n    set sortFn(sortFn) {\n        this._sortFn = sortFn;\n    }\n    get sortFn() {\n        if (this._sortFn) {\n            return this._sortFn;\n        }\n        return this.defaultSortFn;\n    }\n    /**\n     * Default sortFn used when no sortFn specified. Uses the {@link #config-property},\n     * {@link #config-direction}, and {@link #config-convert}.\n     * @private\n    */\n    defaultSortFn(lhs, rhs) {\n        const\n            me                                   = this,\n            { convert, property, useLocaleSort } = me,\n            multiplier                           = me.direction.toLowerCase() === 'desc' ? -1 : 1;\n        lhs = lhs[property];\n        rhs = rhs[property];\n        if (convert) {\n            lhs = convert(lhs);\n            rhs = convert(rhs);\n        }\n        if (useLocaleSort && lhs != null && rhs != null && typeof lhs === 'string') {\n            // Use systems locale\n            if (useLocaleSort === true) {\n                return String(lhs).localeCompare(rhs);\n            }\n            // Use specified locale\n            if (typeof useLocaleSort === 'string') {\n                return String(lhs).localeCompare(rhs, useLocaleSort);\n            }\n            // Use locale config\n            if (typeof useLocaleSort === 'object') {\n                return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);\n            }\n        }\n        return ((lhs > rhs) ? 1 : (lhs < rhs ? -1 : 0)) * multiplier;\n    }\n    static generateSortFunction(sorters, tieBreaker) {\n        const items = sorters.isCollection ? sorters.values : sorters,\n            n = items.length;\n        return (lhs, rhs) => {\n            let comp, i;\n            for (i = 0; i < n; ++i) {\n                comp = items[i].sortFn(lhs, rhs);\n                if (comp) {\n                    return comp;\n                }\n            }\n            return tieBreaker ? tieBreaker(lhs, rhs) : 0;\n        };\n    }\n}\nCollectionSorter._$name = 'CollectionSorter';", "import Base from '../Base.js';\nimport Events from '../mixin/Events.js';\nimport CollectionFilter from './CollectionFilter.js';\nimport CollectionSorter from './CollectionSorter.js';\nimport FunctionHelper from '../helper/FunctionHelper.js';\nimport ArrayHelper from '../helper/ArrayHelper.js';\n/**\n * @module Core/util/Collection\n */\nconst\n    return0                 = () => 0,\n    reverseNumericSortFn    = (a, b) => b - a,\n    filteredIndicesProperty = Symbol('filteredIndicesProperty'),\n    emptyArray              = Object.freeze([]),\n    sortEvent               = Object.freeze({\n        action   : 'sort',\n        added    : emptyArray,\n        removed  : emptyArray,\n        replaced : emptyArray\n    }),\n    filterEvent             = Object.freeze({\n        action   : 'filter',\n        added    : emptyArray,\n        removed  : emptyArray,\n        replaced : emptyArray\n    }),\n    keyTypes               = {\n        string : 1,\n        number : 1\n    };\n// Adds a single item to a single index using the specified key\nfunction addItemToIndex(item, index, key) {\n    // Unique holds a single entry\n    if (index.unique !== false) {\n        index.set(key, item);\n    }\n    // Non-unique index holds a Set\n    else {\n        let set = index.get(key);\n        // Add a set if this is the first entry\n        if (!set) {\n            set = new Set();\n            index.set(key, set);\n        }\n        // Add entry to the set\n        set.add(item);\n    }\n}\n// Removes a single item from a single index using the specified key\nfunction removeItemFromIndex(item, index, key) {\n    // Unique holds single entry, remove it\n    if (index.unique !== false) {\n        index.delete(key);\n    }\n    else if (index.has(key)) {\n        // Remove from set\n        index.get(key).delete(item);\n        // Remove turned empty set\n        if (!index.get(key).size) {\n            index.delete(key);\n        }\n    }\n}\n// Used to fully build the indices, normal and filtered (if used). Better to do full builds for performance reasons\n// when assigning new datasets. For other CRUD operations, indices are kept up to date elsewhere\nfunction doRebuildIndices(values, indices, keyProps, indexCount) {\n    for (let i = 0; i < values.length; i++) {\n        const item = values[i];\n        for (let j = 0; j < indexCount; j++) {\n            const\n                keyProp = keyProps[j],\n                key     = item[keyProp],\n                index   = indices[keyProp];\n            addItemToIndex(item, index, key);\n        }\n    }\n}\n/**\n * A class which encapsulates a {@link #function-get keyed},\n * {@link #function-addFilter filterable}, {@link #function-addSorter sortable}\n * collection of objects. Entries may not be atomic data types such as `string` or `number`.\n *\n * The entries are keyed by their `id` which is determined by interrogating the {@link #config-idProperty}.\n *\n * To filter a Collection, add a {@link Core.util.CollectionFilter CollectionFilter}\n * using the {@link #function-addFilter} method. A Filter config object may be specified here\n * which will be promoted to a CollectionFilter instance.\n *\n * To sort a Collection, add a {@link Core.util.CollectionSorter CollectionSorter}\n * using the {@link #function-addSorter} method. A Sorter config object may be specified here\n * which will be promoted to a CollectionSorter instance.\n */\nexport default class Collection extends Base.mixin(Events) {\n    _sortFunction = null;\n    _addedValues = null;\n    //region Config\n    static get configurable() {\n        return {\n            /**\n             * Specify the name of the property of added objects which provides the lookup key\n             * @config {String}\n             * @default\n             */\n            idProperty : 'id',\n            /**\n             * Specify the names or index configs of properties which are to be indexed for fast lookup.\n             *\n             * Index configs use the format `{ property : string, unique : boolean }`. Unique indices stores one index\n             * per entry, non-unique stores a `Set`. If left out, `unique` defaults to `true`\n             *\n             * @config {String[]|Object[]}\n             * @property {String} property Property to index by\n             * @property {Boolean} [unique=true] `true` for unique keys (~primary keys), `false` for non-unique keys\n             * (~foreign keys)\n             */\n            extraKeys : null,\n            /**\n             * Automatically apply filters on item add.\n             * @config {Boolean}\n             * @default\n             */\n            autoFilter : true,\n            /**\n             * Automatically apply sorters on item add.\n             * @config {Boolean}\n             * @default\n             */\n            autoSort : true,\n            /**\n             * A {@link Core.util.CollectionSorter Sorter}, or Sorter config object, or\n             * an array of these, to use to sort this Collection.\n             * @config {CollectionSorterConfig[]}\n             * @default\n             */\n            sorters : {\n                $config : ['lazy'],\n                value   : []\n            }\n        };\n    }\n    get isCollection() {\n        return true;\n    }\n    //endregion\n    //region Init & destroy\n    construct(config) {\n        /**\n         * A counter which is incremented whenever the Collection is mutated in a meaningful way.\n         *\n         * If a {@link #function-splice} call results in no net replacement, removal or addition,\n         * then the `generation` will not be incremented.\n         * @property {Number}\n         * @readonly\n         */\n        this.generation = 0;\n        this._values = [];\n        super.construct(config);\n    }\n    doDestroy() {\n        super.doDestroy();\n        const me = this;\n        me._values.length = 0;\n        if (me.isFiltered) {\n            me._filteredValues.length = 0;\n            me.filters.destroy();\n        }\n        me._sorters?.destroy();\n    }\n    //endregion\n    //region \"CRUD\"\n    /**\n     * Clears this collection.\n     */\n    clear() {\n        const\n            me      = this,\n            removed = me._values.slice();\n        if (me.totalCount) {\n            me._values.length = 0;\n            if (me._filteredValues) {\n                me._filteredValues.length = 0;\n            }\n            me._indicesInvalid = true;\n            // Indicate to observers that data has changed.\n            me.generation++;\n            me.trigger('change', {\n                action : 'clear',\n                removed\n            });\n        }\n    }\n    /**\n     * Compares the content of this Collection with the content of the passed Collection or\n     * with the passed array. Order insensitive. This returns `true` if the two objects passed\n     * contain the same set of items.\n     * @param {Core.util.Collection|Array} other The Collection or array to compare with.\n     * @param {Function} [map] Optionally a function to convert the items into a comparable object\n     * to compare. For example `item => item.id` could be used to compare the ids of the\n     * constituent items.\n     * @returns {Boolean} `true` if the two objects passed have the same content.\n     */\n    equals(other, map) {\n        if (other.isCollection) {\n            other = other.values;\n        }\n        if (other.length === this.count) {\n            let { values } = this;\n            if (map) {\n                other = other.map(map);\n                values = values.map(map);\n            }\n            return ArrayHelper.delta(other, values).inBoth.length === this.count;\n        }\n        return false;\n    }\n    /**\n     * Replaces the internal `values` array with the passed `values`, or `filteredValues` array with the passed `filteredValues`.\n     * If `filteredValues` are not passed explicitly, but storage is filtered, decides internally `values` or `filteredValues` should\n     * be replaced by passed `values`.\n     *\n     * Note that this takes ownership of the array, and the array must not be mutated by outside code.\n     *\n     * This is an internal utility method, not designed for use by application code.\n     *\n     * @param {Object} params Values and parameters to replace\n     * @param {Object[]} params.values The new `values` array\n     * @param {Object[]} [params.filteredValues] The new `filteredValues` array. Applicable only when storage is filtered.\n     * @param {Boolean} [params.silent=false] If true, `change` event will not be fired\n     * @param {Boolean} [params.isNewDataset=false] If true, `values` is a new dataset\n     * @fires change\n     * @internal\n     */\n    replaceValues({ values, filteredValues, silent = false, isNewDataset = false }) {\n        const me = this;\n        let replacedValues, replacedFilteredValues;\n        // The isNewDataset flag is passed by store#loadData to indicate that it's\n        // a new data load, and that local filters can be applied.\n        // Other use cases are for purely local updates of an existing dataset such as\n        // refreshing the visible data with a values array containing group headers.\n        if (me.isFiltered && !isNewDataset) {\n            const filteredPassed = Boolean(filteredValues);\n            // If `filteredValues` are missing, take `values` as a source of filtered values\n            if (!filteredPassed) {\n                filteredValues = values.slice();\n                values = null;\n            }\n            // otherwise check if non-filtered values are passed together with filtered, and replace them too\n            else if (values) {\n                replacedValues = me._values;\n                me._values = values.slice();\n            }\n            replacedFilteredValues = me._filteredValues;\n            me._filteredValues = filteredValues.slice();\n        }\n        else {\n            replacedValues = me._values;\n            me._values = values.slice();\n            filteredValues = null;\n            if (me.isFiltered && isNewDataset && me.autoFilter) {\n                me._filterFunction = null;\n                me._filteredValues = me._values.filter(me.filterFunction);\n            }\n            else if (me._filteredValues) {\n                me._filteredValues.length = 0;\n            }\n        }\n        me._indicesInvalid = true;\n        me._addedValues = undefined;\n        // Indicate to observers that data has changed.\n        me.generation++;\n        if (!silent) {\n            me.trigger('change', {\n                action : 'replaceValues',\n                replacedValues,\n                replacedFilteredValues,\n                values,\n                filteredValues\n            });\n        }\n    }\n    set values(values) {\n        // Want a full rebuild for new dataset, less costly than doing it per item\n        this.invalidateIndices();\n        this.splice(0, this._values.length, values);\n    }\n    /**\n     * The set of values of this Collection. If this Collection {@link #property-isFiltered},\n     * this yields the filtered data set.\n     *\n     * Setting this property replaces the data set.\n     * @property {Object[]}\n     */\n    get values() {\n        return this.isFiltered ? this._filteredValues : this._values;\n    }\n    /**\n     * The set of filtered values of this Collection (those matching the current filters).\n     * @property {Object[]}\n     * @private\n     */\n    get filteredValues() {\n        return this._filteredValues;\n    }\n    /**\n     * Iterator that allows you to do `for (const item of collection)`\n     */\n    [Symbol.iterator]() {\n        return this.values[Symbol.iterator]();\n    }\n    /**\n     * Executes the passed function for each item in this Collection, passing in the item,\n     * ths index, and the full item array.\n     * @param {Function} fn The function to execute.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.\n     */\n    forEach(fn, ignoreFilters = false) {\n        (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);\n    }\n    /**\n     * Extracts ths content of this Collection into an array based upon the passed\n     * value extraction function.\n     * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.\n     * @returns {Object[]} An array of values extracted from this Collection.\n     */\n    map(fn, ignoreFilters = false) {\n        return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);\n    }\n    /**\n     * Returns the first item in this Collection which elicits a *truthy* return value from the passed function.\n     * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.\n     * @returns {Object} The matched item, or `undefined`.\n     */\n    find(fn, ignoreFilters = false) {\n        return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);\n    }\n    get first() {\n        return this.values[0];\n    }\n    get last() {\n        return this.values[this.count - 1];\n    }\n    /**\n     * The set of all values of this Collection regardless of filters applied.\n     * @readonly\n     * @property {Object[]}\n     */\n    get allValues() {\n        return this._values;\n    }\n    /**\n     * The set of values added to this Collection since the last sort or replaceValues operation.\n     * @private\n     * @readonly\n     * @property {Object[]}\n     */\n    get addedValues() {\n        return this._addedValues;\n    }\n    /**\n     * This method ensures that every item in this Collection is replaced by the matched by\n     * `id` item in the other Collection.\n     *\n     * By default, any items in this Collection which are __not__ in the other Collection are removed.\n     *\n     * If the second parameter is passed as `false`, then items which are not in the other\n     * Collection are not removed.\n     *\n     * This can be used for example when updating a selected record Collection when a new\n     * Store or new store dataset arrives. The selected Collection must reference the latest\n     * versions of the selected record `id`s\n     * @param {Core.util.Collection} other The Collection whose items to match.\n     */\n    match(other, allowRemove = true) {\n        const\n            me          = this,\n            { _values } = me,\n            toRemove    = [];\n        // Update selected records collection\n        me.forEach(item => {\n            const newInstance = other.get(item.id, true);\n            // If item exists in other Collection, update this with a reference to the other version.\n            // This must happen silently, so splice the _values array\n            if (newInstance) {\n                const\n                    index       = me.indexOf(item, true),\n                    oldInstance = _values[index];\n                // Replace the instance directly into our values\n                _values[index] = newInstance;\n                // Ensure the indexes match\n                me.removeFromIndices(oldInstance);\n                me.addToIndices(newInstance);\n            }\n            else if (allowRemove) {\n                toRemove.push(item);\n            }\n        });\n        if (toRemove.length) {\n            me.remove(toRemove);\n        }\n        // The filtered set must match the new reality.\n        if (me.isFiltered) {\n            me._filteredValues = me._values.filter(me.filterFunction);\n        }\n        return toRemove;\n    }\n    /**\n     * Adds items to this Collection. Multiple new items may be passed.\n     *\n     * By default, new items are appended to the existing values.\n     *\n     * Any {@link #property-sorters} {@link #property-sorters} present are re-run.\n     *\n     * Any {@link #property-filters} {@link #property-filters} present are re-run.\n     *\n     * *Note that if application functionality requires add and remove, the\n     * {@link #function-splice} operation is preferred as it performs both\n     * operations in an atomic manner*\n     * @param  {...Object} items The item(s) to add.\n     */\n    add(...items) {\n        if (items.length === 1) {\n            this.splice(this._values.length, null, ...items);\n        }\n        else {\n            this.splice(this._values.length, null, items);\n        }\n    }\n    /**\n     * Removes items from this Collection. Multiple items may be passed.\n     *\n     * Any {@link #property-sorters} {@link #property-sorters} present are re-run.\n     *\n     * Any {@link #property-filters} {@link #property-filters} present are re-run.\n     *\n     * *Note that if application functionality requires add and remove, the\n     * {@link #function-splice} operation is preferred as it performs both\n     * operations in an atomic manner*\n     * @param  {...Object} items The item(s) to remove.\n     */\n    remove(...items) {\n        if (items.length === 1) {\n            this.splice(0, ...items);\n        }\n        else {\n            this.splice(0, items);\n        }\n    }\n    /**\n     * Moves an individual item, or a block of items to another location.\n     * @param {Object|Object[]} items The item/items to move.\n     * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`\n     * is moved to the end of the Collection.\n     * @returns {Number} The new index of the `item`.\n     */\n    move(items, beforeItem) {\n        items = ArrayHelper.asArray(items);\n        // Handle the case of move(myItem, myItem). It's a no-op\n        while (items.length && items[0] === beforeItem) {\n            items.shift();\n        }\n        if (!items.length) {\n            return;\n        }\n        const\n            me          = this,\n            { _values } = me,\n            itemIndex   = me.indexOf(items[0], true);\n        // move(record, followingrecord) is a no-op\n        if (items.length === 1 && _values[itemIndex + 1] === beforeItem) {\n            return;\n        }\n        // Silently remove the items that are to be inserted before the \"beforeItem\".\n        me.suspendEvents();\n        me.remove(items);\n        me.resumeEvents();\n        const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;\n        if (beforeIndex === -1) {\n            throw new Error('Collection move beforeItem parameter must be present in Collection');\n        }\n        _values.splice(beforeIndex, 0, ...items);\n        me._indicesInvalid = 1;\n        me.trigger('change', {\n            action : 'move',\n            items,\n            from   : itemIndex,\n            to     : beforeIndex\n        });\n        return beforeIndex;\n    }\n    /**\n     * The core data set mutation method. Removes and adds at the same time. Analogous\n     * to the `Array` `splice` method.\n     *\n     * Note that if items that are specified for removal are also in the `toAdd` array,\n     * then those items are *not* removed then appended. They remain in the same position\n     * relative to all remaining items.\n     *\n     * @param {Number} index Index at which to remove a block of items. Only valid if the\n     * second, `toRemove` argument is a number.\n     * @param {Object[]|Number} [toRemove] Either the number of items to remove starting\n     * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).\n     * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.\n     */\n    splice(index = 0, toRemove, ...toAdd) {\n        const\n            me         = this,\n            idProperty = me.idProperty,\n            values     = me._values,\n            newIds     = {},\n            removed    = [],\n            replaced   = [],\n            oldCount   = me.totalCount;\n        let added,\n            mutated;\n        // Create an \"newIds\" map of the new items so remove ops know if it's really a replace\n        // {\n        //     1234 : true\n        // }\n        // And an \"added\" array of the items that need adding (there was not already an entry for the id)\n        //\n        if (me.trigger('beforeSplice', { index, toRemove, toAdd }) === false) {\n            return;\n        }\n        if (toAdd) {\n            if (toAdd.length === 1 && Array.isArray(toAdd[0])) {\n                toAdd = toAdd[0];\n            }\n            // Check for replacements if we contain any data\n            if (oldCount && toAdd.length) {\n                // Only risk rebuilding the indices if we are adding\n                const idIndex = me.indices[idProperty];\n                added = [];\n                for (let i = 0; i < toAdd.length; i++) {\n                    const\n                        newItem       = toAdd[i],\n                        id            = newItem[idProperty],\n                        existingItem  = idIndex.get(id),\n                        existingIndex = existingItem ? values.indexOf(existingItem) : -1;\n                    // Register incoming id so that removal leaves it be\n                    newIds[id] = true;\n                    // Incoming id is already present.\n                    // Replace it in place.\n                    if (existingIndex !== -1) {\n                        // If incoming is the same object, it's a no-op\n                        if (values[existingIndex] !== newItem) {\n                            replaced.push([values[existingIndex], newItem]);\n                            values[existingIndex] = newItem;\n                        }\n                    }\n                    else {\n                        added.push(newItem);\n                    }\n                }\n            }\n            // Empty Collection, we simply add what we're passed\n            else {\n                added = toAdd;\n            }\n        }\n        if (toRemove) {\n            // We're removing a chunk starting at index\n            if (typeof toRemove === 'number') {\n                // Ensure we don't walk off the end if the toRemove count exceeds what we contain\n                toRemove = Math.min(toRemove, values.length - index);\n                for (let removeIndex = index; toRemove; --toRemove) {\n                    const id = values[removeIndex][idProperty];\n                    // If the entry here is being replaced, skip the insertion index past it\n                    if (newIds[id]) {\n                        index++;\n                        removeIndex++;\n                    }\n                    // If the id is not among incoming items, remove it\n                    else {\n                        removed.push(values[removeIndex]);\n                        values.splice(removeIndex, 1);\n                        mutated = true;\n                    }\n                }\n            }\n            // We are removing an item/items\n            else {\n                let contiguous = added.length === 0,\n                    lastIdx;\n                toRemove = ArrayHelper.asArray(toRemove);\n                // Create array of index points to remove.\n                // They must be in reverse order so that removal leaves following remove indices stable\n                const removeIndices = toRemove.reduce((result, item) => {\n                    const\n                        isNumeric = typeof item === 'number',\n                        idx       = isNumeric ? item : me.indexOf(item, true);\n                    // Drop out of contiguous mode if we find a non-contiguous record, or a remove *index*\n                    if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {\n                        contiguous = false;\n                    }\n                    // Do not include indices out of range in our removeIndices\n                    if (idx >= 0 && idx < oldCount) {\n                        result.push(idx);\n                    }\n                    lastIdx = idx;\n                    return result;\n                }, []).sort(reverseNumericSortFn);\n                // If it's a pure remove of contiguous items with no adds, fast track it.\n                if (contiguous) {\n                    // If reduced to zero by being asked to remove items we do not contain\n                    // then this is a no-op\n                    if (removeIndices.length) {\n                        removed.push.apply(removed, toRemove);\n                        values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);\n                        mutated = true;\n                    }\n                }\n                else {\n                    // Loop through removeIndices splicing each index out of the values\n                    // unless there's an incoming identical id.\n                    for (let i = 0; i < removeIndices.length; i++) {\n                        const removeIndex = removeIndices[i];\n                        if (removeIndex !== -1) {\n                            const id = values[removeIndex][idProperty];\n                            // If the id is not among incoming items, remove it\n                            if (!newIds[id]) {\n                                removed.unshift(values[removeIndex]);\n                                values.splice(removeIndex, 1);\n                                mutated = true;\n                            }\n                        }\n                    }\n                }\n            }\n            // Update indices only if they have been used\n            if (removed.length && !me._indicesInvalid) {\n                removed.forEach(me.removeFromIndices, me);\n            }\n        }\n        // If we collected genuinely new entries, insert them at the splice index\n        if (added.length) {\n            values.splice(Math.min(index, values.length), 0, ...added);\n            mutated = true;\n            // Update indices only if they have been used\n            if (!me._indicesInvalid) {\n                added.forEach(me.addToIndices, me);\n            }\n            if (!me._addedValues) {\n                me._addedValues = new Set();\n            }\n            for (const value of added) {\n                me._addedValues.add(value);\n            }\n        }\n        if (removed.length && me._addedValues) {\n            for (const value of removed) {\n                me._addedValues.delete(value);\n            }\n        }\n        // Update indices only if they have been used\n        if (replaced.length && !me._indicesInvalid) {\n            replaced.forEach(rep => {\n                me.removeFromIndices(rep[0]);\n                me.addToIndices(rep[1]);\n            });\n        }\n        // If we either added or removed items, or we did an in-place replace operation\n        // then inform all interested parties.\n        if (mutated || replaced.length) {\n            // Ensure order of values matches the sorters\n            if (me.isSorted) {\n                me.onSortersChanged();\n            }\n            // The sort will also recreate the filteredValues so that it can be in correct sort order\n            else if (me.isFiltered) {\n                if (me.autoFilter) {\n                    me.onFiltersChanged({ action : 'splice', oldCount : 1 });\n                }\n                else {\n                    me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);\n                }\n            }\n            // Indicate to observers that data has changed.\n            me.generation++;\n            /**\n             * Fired when items are added, replace or removed\n             * @event change\n             * @param {'splice'|'clear'|'replaceValues'|'move'|'sort'|'filter'} action The underlying operation\n             * which caused data change. May be `'splice'` (meaning an atomic add/remove operation, `'sort'` or\n             * `'filter'`), `'clear'`, `'replaceValues'`, `'move'`, `'sort'` or `'filter'`.\n             * @param {Core.util.Collection} source This Collection.\n             * @param {Object[]} removed An array of removed items. If the `action` is `'filter'`, the\n             * removed property represents the records which were filtered out by the action.\n             * @param {Object[]} added An array of added items. If the `action` is `'filter'`, the\n             * added property represents the records which were filtered in by the action.\n             * @param {Object[]} replaced An array of replacements, each entry of which contains `[oldValue, newValue]`.\n             * @param {Number} oldCount The number of items in the full, unfiltered collection prior to the splice operation.\n             */\n            me.trigger('change', {\n                action : 'splice',\n                removed,\n                added,\n                replaced,\n                oldCount\n            });\n        }\n        else {\n            /**\n             * Fired when a {@link #function-splice} operation is requested but the operation\n             * is a no-op and has caused no change to this Collection's dataset. The splice\n             * method's parameters are passed for reference.\n             * @event noChange\n             * @param {Number} index Index at which to remove a block of items.\n             * @param {Object[]|Number} [toRemove] Either the number of items to remove starting\n             * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).\n             * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.\n             */\n            me.trigger('noChange', {\n                index,\n                toRemove,\n                toAdd\n            });\n        }\n    }\n    /**\n     * Change the id of an existing member by mutating its {@link #config-idProperty}.\n     * @param {String|Number|Object} item The item or id of the item to change.\n     * @param {String|Number} newId The id to set in the existing member.\n     */\n    changeId(item, newId) {\n        const\n            me             = this,\n            { idProperty } = me,\n            oldId          = keyTypes[typeof item] ? item : item[idProperty],\n            member         = me.get(oldId);\n        if (member) {\n            const existingMember = me.get(newId);\n            if (existingMember && member !== existingMember) {\n                throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);\n            }\n            me.removeIndexEntry(item, idProperty, oldId);\n            me.addIndexEntry(item, idProperty, newId);\n            // Last on purpose, onItemMutation would fail to find the item if its id was changed prior to the call\n            member[idProperty] = newId;\n        }\n    }\n    /**\n     * Returns the item with the passed `id`. By default, filtered are honoured, and\n     * if the item with the requested `id` is filtered out, nothing will be returned.\n     *\n     * To return the item even if it has been filtered out, pass the second parameter as `true`.\n     * @param {*} id The `id` to find.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.\n     * @returns {Object} The found item, or `undefined`.\n     */\n    get(id, ignoreFilters = false) {\n        return this.getBy(this.idProperty, id, ignoreFilters);\n    }\n    getAt(index, ignoreFilters = false) {\n        if (this.isFiltered && !ignoreFilters) {\n            return this._filteredValues[index];\n        }\n        else {\n            return this._values[index];\n        }\n    }\n    /**\n     * Returns the item with passed property name equal to the passed value. By default,\n     * filtered are honoured, and if the item with the requested `id` is filtered out,\n     * nothing will be returned.\n     *\n     * To return the item even if it has been filtered out, pass the third parameter as `true`.\n     * @param {String} propertyName The property to test.\n     * @param {*} value The value to find.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.\n     * @returns {Object} The found item, or `undefined`.\n     */\n    getBy(propertyName, value, ignoreFilters = false) {\n        return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);\n    }\n    /**\n     * The number of items in this collection. Note that this honours filtering.\n     * See {@link #property-totalCount};\n     * @property {Number}\n     * @readonly\n     */\n    get count() {\n        return this.values.length;\n    }\n    /**\n     * The number of items in this collection regardless of filtering.\n     * @property {Number}\n     * @readonly\n     */\n    get totalCount() {\n        return this._values.length;\n    }\n    /**\n     * The property name used to extract item `id`s from added objects.\n     * @member {String} idProperty\n     */\n    updateIdProperty(idProperty) {\n        this.addIndex({ property : idProperty, unique : true });\n    }\n    //endregion\n    //region Sorting\n    /**\n     * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.\n     * @member {Core.util.Collection} sorters\n     */\n    changeSorters(sorters) {\n        return new Collection({\n            values            : ArrayHelper.asArray(sorters),\n            internalListeners : {\n                change  : 'onSortersChanged',\n                thisObj : this\n            }\n        });\n    }\n    /**\n     * Adds a Sorter to the Collection of Sorters which are operating on this Collection.\n     *\n     * A Sorter may be specified as an instantiated {@link Core.util.CollectionSorter}, or a config object for a\n     * CollectionSorter of the form\n     *\n     *     {\n     *         property  : 'age',\n     *         direction : 'desc'\n     *     }\n     *\n     * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make\n     * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You\n     * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.\n     *\n     * A Sorter may also be specified as a function which compares two objects eg:\n     *\n     *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age\n     *\n     * @param {CollectionSorterConfig} sorter A Sorter configuration object to add to the Collection\n     * of Sorters operating on this Collection.\n     * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.\n     */\n    addSorter(sorter) {\n        const result = (sorter instanceof CollectionSorter) ? sorter : new CollectionSorter(sorter);\n        this.sorters.add(result);\n        return result;\n    }\n    /**\n     * A flag which is `true` if this Collection has active {@link #property-sorters}.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isSorted() {\n        return Boolean(this._sorters?.count);\n    }\n    onSortersChanged() {\n        const me = this;\n        me._sortFunction = null;\n        me._addedValues = null;\n        me._values.sort(me.sortFunction);\n        me.trigger('change', sortEvent);\n    }\n    /**\n     * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters}\n     * for this Collection.\n     * @property {Function}\n     * @readonly\n     */\n    get sortFunction() {\n        if (!this._sortFunction) {\n            if (this.isSorted) {\n                this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);\n            }\n            else {\n                this._sortFunction = return0;\n            }\n        }\n        return this._sortFunction;\n    }\n    //endregion\n    //region Filtering\n    /**\n     * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.\n     * @property {Core.util.Collection}\n     * @readonly\n     */\n    get filters() {\n        if (!this._filters) {\n            this._filters = new Collection({\n                internalListeners : {\n                    change  : 'onFiltersChanged',\n                    thisObj : this\n                }\n            });\n        }\n        return this._filters;\n    }\n    /**\n     * Adds a Filter to the Collection of Filters which are operating on this Collection.\n     *\n     * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter\n     * CollectionFilter}, or a config object for a CollectionFilter of the form\n     *\n     *     {\n     *         property : 'age',\n     *         operator : '>=',\n     *         value    : 21\n     *     }\n     *\n     * Note that by default, a Filter *replaces* a Filter with the same `property` to make\n     * it easy to change existing Filters. A Filter's `id` is its `property` by default. You\n     * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.\n     *\n     * A Filter may also be specified as a function which filters candidate objects eg:\n     *\n     *     candidate => candidate.customerDetails.age >= 21\n     *\n     * @param {CollectionFilterConfig|Core.util.CollectionFilter} filter A Filter or Filter configuration object to add\n     * to the Collection of Filters operating on this Collection.\n     * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.\n     */\n    addFilter(filter) {\n        const result = (filter instanceof CollectionFilter) ? filter : new CollectionFilter(filter);\n        this.filters.add(result);\n        return result;\n    }\n    removeFilter(filter) {\n        const { filters } = this;\n        if (!filter.isCollectionFilter) {\n            filter = filters.get(filter);\n        }\n        filters.remove(filter);\n    }\n    clearFilters() {\n        this.filters.clear();\n    }\n    /**\n     * A flag which is `true` if this Collection has active {@link #property-filters}.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isFiltered() {\n        return Boolean(this._filters && this._filters.count);\n    }\n    onFiltersChanged({ action, removed : gone, oldCount }) {\n        const\n            me          = this,\n            oldDataset  = oldCount || (action === 'clear' && gone.length) ? me._filteredValues : me._values;\n        me._filterFunction = null;\n        me._filteredValues = me._values.filter(me.filterFunction);\n        me._indicesInvalid = true;\n        const {\n            toAdd    : added,\n            toRemove : removed\n        } = ArrayHelper.delta(me._filteredValues, oldDataset, true);\n        me.trigger('change', { ...filterEvent, added, removed });\n    }\n    /**\n     * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}\n     * for this Collection.\n     * @property {Function}\n     * @readonly\n     */\n    get filterFunction() {\n        if (!this._filterFunction) {\n            if (this.isFiltered) {\n                this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);\n            }\n            else {\n                this._filterFunction = FunctionHelper.returnTrue;\n            }\n        }\n        return this._filterFunction;\n    }\n    //endregion\n    //region Indexing\n    changeExtraKeys(extraKeys) {\n        const keys = ArrayHelper.asArray(extraKeys);\n        // Normalize to always be an array of index configs\n        return keys.map(config => {\n            if (typeof config === 'string') {\n                return { property : config, unique : true };\n            }\n            return config;\n        });\n    }\n    updateExtraKeys(extraKeys) {\n        for (let i = 0; i < extraKeys.length; i++) {\n            this.addIndex(extraKeys[i]);\n        }\n    }\n    /**\n     * Adds a lookup index for the passed property name or index config. The index is built lazily when an index is\n     * searched\n     * @internal\n     * @param {Object} indexConfig An index config\n     * @param {String} indexConfig.property The property name to add an index for\n     * @param {Boolean} [indexConfig.unique] Specify `false` to allow multiple entries of the same index, turning\n     *   entries into sets\n     * @param {Object} [indexConfig.dependentOn] The properties that make the key\n     */\n    addIndex(indexConfig) {\n        const me = this;\n        // Combo without valueField used in some tests -> addIndex(undefined). Safeguarding here\n        if (indexConfig) {\n            (me._indices || (me._indices = {}))[indexConfig.property] = new Map();\n            // Piggyback the index config\n            Object.assign(me._indices[indexConfig.property], indexConfig);\n            // Indices need a rebuild now.\n            me.invalidateIndices();\n            if (indexConfig.dependentOn) {\n                me.hasCompositeIndex = true;\n            }\n            /**\n             * this.indices is keyed by the property name, and contains the keys linked to an item in the _values array.\n             * So collection.add({id : foo, name : 'Nige'}, {id : 'bar', name : 'Faye'}) where collection has had an index\n             * added for the \"name\" property would result in:\n             *\n             * {\n             *     id : Map({\n             *         foo : nige,\n             *         bar : faye\n             *     }),\n             *     name : Map({\n             *         Nige : nige,\n             *         Faye : faye\n             *     })\n             * }\n             */\n        }\n    }\n    /**\n     * Return the index of the item with the specified key having the specified value.\n     *\n     * By default, filtering is taken into account and this returns the index in the filtered dataset if present. To\n     * bypass this, pass the third parameter as `true`.\n     *\n     * Only useful for indices configured with `unique: true`.\n     *\n     * @param {String} propertyName The name of the property to test.\n     * @param {*} value The value to test for.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in\n     * the original data set if the item is filtered out.\n     * @returns {Number} The index of the item or `-1` if not found for unique indices\n     */\n    findIndex(propertyName, value, ignoreFilters = false) {\n        const item = this.findItem(propertyName, value, ignoreFilters);\n        if (!item) {\n            return -1;\n        }\n        const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;\n        return values.indexOf(item);\n    }\n    /**\n     * Return the item with the specified key having the specified value.\n     *\n     * By default, filtering is taken into account. To bypass this, pass the third parameter as `true`.\n     *\n     * For indices configured with `unique: false`, a Set of items will be returned.\n     *\n     * @param {String} propertyName The name of the property to test.\n     * @param {*} value The value to test for.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in\n     * the original data set if the item is filtered out.\n     * @returns {Object|Set} The found item or Set of items or null\n     */\n    findItem(propertyName, value, ignoreFilters = false) {\n        const\n            me             = this,\n            { isFiltered } = me,\n            index          = isFiltered && !ignoreFilters\n                ? me.indices[filteredIndicesProperty][propertyName]\n                : me.indices[propertyName];\n        if (index) {\n            // If the key is a numeric string, cast it to a number and find.\n            // Store's idRegister is an object which treats numeric keys as strings\n            // but Maps are more picky, so we have to work round that.\n            const item = index.get(value) ?? ((typeof value === 'string' && value.length && !isNaN(value) && index.get(Number(value))) || null);\n            if (item != null) {\n                return item;\n            }\n        }\n        else {\n            // Search the filtered values if we are filtered and not ignoring filters\n            const\n                values = isFiltered && !ignoreFilters ? me._filteredValues : me._values,\n                count  = values.length;\n            for (let i = 0; i < count; i++) {\n                const item = values[i];\n                if (item[propertyName] == value) {\n                    return item;\n                }\n            }\n        }\n        return null;\n    }\n    removeIndex(propertyName) {\n        delete this._indices[propertyName];\n        this.hasCompositeIndex = Object.values(this.indices).some(index => index.dependentOn);\n    }\n    /**\n     * Returns the index of the item with the same `id` as the passed item.\n     *\n     * By default, filtering is honoured, so if the item in question has been added, but is currently filtered out of\n     * visibility, `-1` will be returned.\n     *\n     * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;\n     * @param {Object|String|Number} item The item to find, or an `id` to find.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.\n     * @returns {Number} The index of the item, or `-1` if not found.\n     */\n    indexOf(item, ignoreFilters = false) {\n        return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);\n    }\n    /**\n     * Returns `true` if this Collection includes an item with the same `id` as the passed item.\n     *\n     * By default, filtering is honoured, so if the item in question has been added,\n     * but is currently filtered out of visibility, `false` will be returned.\n     *\n     * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;\n     * @param {Object|String|Number} item The item to find, or an `id` to find.\n     * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.\n     * @returns {Boolean} True if the passed item is found.\n     */\n    includes(item, ignoreFilters = false) {\n        if (Array.isArray(item)) {\n            return item.some(item => this.includes(item));\n        }\n        return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));\n    }\n    get indices() {\n        if (this._indicesInvalid) {\n            this.rebuildIndices();\n        }\n        return this._indices;\n    }\n    invalidateIndices() {\n        this._indicesInvalid = true;\n    }\n    /**\n     * Called when the Collection is mutated and the indices have been flagged as invalid.\n     *\n     * Rebuilds the indices object to allow lookup by keys.\n     * @internal\n     */\n    rebuildIndices() {\n        const\n            me         = this,\n            isFiltered = me.isFiltered,\n            indices    = (me._indices || (me._indices = {})),\n            keyProps   = Object.keys(indices),\n            indexCount = keyProps.length,\n            values     = me._values;\n        let filteredIndices;\n        if (isFiltered) {\n            filteredIndices = indices[filteredIndicesProperty] = {};\n        }\n        // First, clear indices.\n        for (let i = 0; i < indexCount; i++) {\n            const index = indices[keyProps[i]];\n            index.clear();\n            if (isFiltered) {\n                let filteredIndex = filteredIndices[keyProps[i]];\n                if (filteredIndex) {\n                    filteredIndex.clear();\n                }\n                else {\n                    filteredIndex = filteredIndices[keyProps[i]] = new Map();\n                    // Piggyback config\n                    filteredIndex.unique = index.unique;\n                }\n            }\n        }\n        doRebuildIndices(values, indices, keyProps, indexCount);\n        // Create a parallel lookup structure into the _filteredValues\n        if (isFiltered) {\n            doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount);\n        }\n        me._indicesInvalid = false;\n    }\n    // Returns an array with [indices] or [indices, filteredIndices] if filtering is used\n    getIndices(propertyName) {\n        const indices = [this.indices[propertyName]];\n        if (this.isFiltered) {\n            indices.push(this.indices[filteredIndicesProperty][propertyName]);\n        }\n        return indices;\n    }\n    /**\n     * Add an item to all indices\n     * @param {*} item Item already available in the Collection\n     * @private\n     */\n    addToIndices(item) {\n        Object.keys(this.indices).forEach(propertyName => {\n            this.addIndexEntry(item, propertyName, item[propertyName]);\n        });\n    }\n    /**\n     * Remove an item from all indices\n     * @param {*} item Item already available in the Collection\n     * @private\n     */\n    removeFromIndices(item) {\n        Object.keys(this.indices).forEach(propertyName => {\n            this.removeIndexEntry(item, propertyName, item[propertyName]);\n        });\n    }\n    /**\n     * Remove an entry from an index, and if filtering is used also from the filtered index.\n     * @param {*} item Item already available in the Collection\n     * @param {String} propertyName Property of the item, will be matched with configured indices\n     * @param {*} oldValue Value to remove\n     * @private\n     */\n    removeIndexEntry(item, propertyName, oldValue) {\n        this.getIndices(propertyName).forEach(index => removeItemFromIndex(item, index, oldValue));\n    }\n    /**\n     * Add a new entry to an index, and if filtering is used also to the filtered index.\n     * @param {*} item Item already available in the Collection\n     * @param {String} propertyName Property of the item, will be matched with configured indices\n     * @param {*} value Value to store\n     * @private\n     */\n    addIndexEntry(item, propertyName, value) {\n        this.getIndices(propertyName).forEach(index => addItemToIndex(item, index, value));\n    }\n    /**\n     * Call externally to update indices on item mutation (from Store)\n     * @param {*} item Item already available in the Collection\n     * @param {Object} wasSet Uses the `wasSet` format from Store, `{ field : { oldValue, newValue } }`\n     * @internal\n     */\n    onItemMutation(item, wasSet) {\n        const me = this;\n        // Iterate over changes if we have extra indices defined, keeping those indices up to date\n        if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {\n            Object.keys(wasSet).forEach(propertyName => {\n                const indexConfig = me.indices[propertyName];\n                if (indexConfig) {\n                    const { value, oldValue } = wasSet[propertyName];\n                    me.removeIndexEntry(item, propertyName, oldValue);\n                    me.addIndexEntry(item, propertyName, value);\n                }\n                else if (me.hasCompositeIndex) {\n                    // Now check if any composite index depends on the property that was changed\n                    const dependentIndex = Object.values(me.indices).find(index => index.dependentOn?.[propertyName]);\n                    if (dependentIndex) {\n                        const keysAndOldValues = {};\n                        for (const o in dependentIndex.dependentOn) {\n                            keysAndOldValues[o] = wasSet[o]?.oldValue || item[o];\n                        }\n                        const oldIndex = item.buildIndexKey(keysAndOldValues);\n                        me.removeIndexEntry(item, dependentIndex.property, oldIndex);\n                        me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);\n                    }\n                }\n            });\n        }\n    }\n    //endregion\n}\n// These are used by Bag for the same purpose\nexport  { keyTypes };\nCollection._$name = 'Collection';", "import { keyTypes } from './Collection.js';\nimport ArrayHelper from '../helper/ArrayHelper.js';\nconst\n    nonPrimitives          = new WeakMap(),\n    safeIndexKey           = (value) => {\n        if (value && typeof value === 'object') {\n            let substitute = nonPrimitives.get(value);\n            if (substitute === undefined) {\n                substitute = Symbol('bscik'); // Bryntum safe collection index key\n                nonPrimitives.set(value, substitute);\n            }\n            value = substitute;\n        }\n        return value;\n    };\n/**\n * @module Core/util/Bag\n */\n/**\n * A simple collection class to contain unique, keyed items.\n * @internal\n */\nexport default class Bag {\n    constructor(config) {\n        const me = this;\n        me.generation = 0;\n        me.items = new Set();\n        me.idMap = {};\n        me.idProperty = 'id';\n        if (config) {\n            if (config.idProperty) {\n                me.idProperty = config.idProperty;\n            }\n            if (config.values) {\n                me.values = config.values;\n            }\n        }\n    }\n    /**\n     * Returns the item with the passed `id`.\n     *\n     * @param {*} id The `id` to find.\n     * @returns {Object} The found item, or `undefined`.\n     */\n    get(key) {\n        return this.idMap[safeIndexKey(key)];\n    }\n    /**\n     * The number of items in this Bag.\n     * @property {Number}\n     * @readonly\n     */\n    get count() {\n        return this.items.size;\n    }\n    /**\n     * Adds the passed item(s) to this Bag. Existing items with the same ID\n     * will be replaced.\n     * @param {Object|Object[]} toAdd Item(s) to add.\n     */\n    add(...toAdd) {\n        if (toAdd.length === 1 && Array.isArray(toAdd[0])) {\n            toAdd = toAdd[0];\n        }\n        const\n            me  = this,\n            {\n                items,\n                idMap,\n                idProperty\n            }   = me,\n            len = toAdd.length;\n        for (let i = 0; i < len; i++) {\n            const\n                item         = toAdd[i],\n                key          = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),\n                existingItem = idMap[key];\n            // Not already present\n            if (existingItem == null) {\n                idMap[key] = item;\n                items.add(item);\n                me.generation++;\n            }\n            // Already present, replace it if different. No generational change.\n            // IDs rule.\n            else if (existingItem !== item) {\n                idMap[key] = item;\n                items.delete(existingItem);\n                items.add(item);\n            }\n        }\n    }\n    /**\n     * Returns `nth` item in this Bag.\n     * @param {Number} nth The index of the matching item. Negative numbers index for the last item. For example, -1\n     * returns the last item, -2 the 2nd to last item etc.\n     * @returns {Object} The matched item, or `undefined`.\n     */\n    at(nth) {\n        let item, ret;\n        if (nth < 0) {\n            nth += this.count;  // ex: count=10 ... -1 -> 9, -2 -> 8, -3 -> 7, ... -9 -> 1, -10 -> 0\n        }\n        for (item of this.items) {\n            if (!nth--) {\n                ret = item;\n                break;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Removes the passed item(s) from this Bag.\n     * @param {Object|Object[]} toRemove Item(s) to remove.\n     */\n    remove(toRemove) {\n        toRemove = ArrayHelper.asArray(toRemove);\n        const\n            { items, idMap, idProperty } = this,\n            len = toRemove.length;\n        for (let i = 0; i < len; i++) {\n            const\n                item         = toRemove[i],\n                key          = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),\n                existingItem = idMap[key];\n            // Found match, so delete it\n            if (existingItem != null) {\n                items.delete(existingItem);\n                delete idMap[key];\n                this.generation++;\n            }\n        }\n    }\n    clear() {\n        this.items.clear();\n        this.idMap = {};\n        this.generation++;\n    }\n    /**\n     * Returns the number of items in this Bag which elicits a truthy return value from the passed function.\n     * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.\n     * @returns {Number} The number of matched items.\n     */\n    countOf(fn) {\n        let ret = 0,\n            item;\n        for (item of this.items) {\n            if (fn(item)) {\n                ++ret;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Change the id of an existing member by mutating its idProperty.\n     * @param {String|Number|Object} item The item or id of the item to change.\n     * @param {String|Number} newId The id to set in the existing member.\n     */\n    changeId(item, newId) {\n        const\n            me                    = this,\n            { idMap, idProperty } = me,\n            oldId                 = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),\n            member                = me.get(oldId);\n        if (member) {\n            const existingMember = me.get(newId);\n            if (existingMember && member !== existingMember) {\n                throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);\n            }\n            member[idProperty] = newId;\n            delete idMap[oldId];\n            idMap[newId] = member;\n        }\n    }\n    /**\n     * Extracts the matching items from this Bag into an array based upon the passed value filter function.\n     * @param {Function} fn A function, which, when passed an item, returns a `true` to place into the resulting array.\n     * @param {Object} [thisObj] The `this` reference when the function is called.\n     * @returns {Object[]} An array of values extracted from this Bag.\n     */\n    filter(fn, thisObj) {\n        const\n            { items } = this,\n            result    = [];\n        let i = 0;\n        items.forEach(item => {\n            if (fn.call(thisObj, item, i++, items)) {\n                result.push(item);\n            }\n        });\n        return result;\n    }\n    /**\n     * Returns `true` if this Collection includes an item with the same `id` as the passed item.\n     *\n     * @param {Object|String|Number} item The item to find, or an `id` to find.\n     * @returns {Boolean} True if the passed item is found.\n     */\n    includes(item) {\n        const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);\n        return Boolean(this.idMap[key]);\n    }\n    /**\n     * Extracts the content of this Bag into an array based upon the passed\n     * value extraction function.\n     * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.\n     * @param {Object} [thisObj] The `this` reference when the function is called.\n     * @returns {Object[]} An array of values extracted from this Bag.\n     */\n    map(fn, thisObj) {\n        const\n            { items } = this,\n            result    = new Array(items.size);\n        // Set has no map\n        let i = 0;\n        items.forEach(item => {\n            result[i] = fn.call(thisObj, item, i++, items);\n        });\n        return result;\n    }\n    /**\n     * Executes the passed function for each item in this Bag, passing in the item.\n     * @param {Function} fn The function to execute.\n     * @param {Object} [thisObj] The `this` reference when the function is called.\n     */\n    forEach(fn, thisObj) {\n        return this.items.forEach(fn, thisObj);\n    }\n    /**\n     * Returns `nth` item in this Bag which elicits a truthy return value from the provided matcher function `fn`.\n     * @param {Function} fn A function which, when passed an item, returns `true` to select the item as a match.\n     * @param {Number} [nth=0] The index of the matching item. By default, 0 returns the first item that matches\n     * according to `fn`. Negative numbers index for the last item. For example, -1 returns the last matching item,\n     * -2 the 2nd to last matching item etc..\n     * @returns {Object} The matched item, or `undefined`.\n     */\n    find(fn, nth = 0) {\n        let item, ret;\n        if (nth < 0) {\n            nth += this.countOf(fn);  // ex: count=10 ... -1 -> 9, -2 -> 8, -3 -> 7, ... -9 -> 1, -10 -> 0\n        }\n        for (item of this.items) {\n            if (fn(item) && !nth--) {\n                ret = item;\n                break;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Iterator that allows you to do for (let item of bag)\n     */\n    [Symbol.iterator]() {\n        return this.items[Symbol.iterator]();\n    }\n    indexOf(item, matchFn) {\n        let index = -1,\n            it;\n        for (it of this.items) {\n            if (!matchFn || matchFn(it)) {\n                ++index;\n                if (it === item) {\n                    return index;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * The set of values of this Bag.\n     *\n     * Setting this property replaces the data set.\n     * @property {Object[]}\n     */\n    get values() {\n        return [...this.items];\n    }\n    set values(values) {\n        values = ArrayHelper.asArray(values);\n        this.clear();\n        this.add.apply(this, values);\n        this.generation++;\n    }\n    /**\n     * Sort the values of this Bag using the passed comparison function.\n     *\n     * Setting this property replaces the data set.\n     * @param {Function} fn Comparison function which returns -ve, 0, or +ve\n     */\n    sort(fn) {\n        this.values = this.values.sort(fn);\n    }\n    some(fn, thisObj) {\n        return this.values.some(fn, thisObj);\n    }\n}\nBag._$name = 'Bag';", "import Bag from '../util/Bag.js';\n/**\n * @module Core/data/StoreBag\n */\nexport default class StoreBag extends Bag {\n    add(...toAdd) {\n        if (toAdd.length === 1 && Array.isArray(toAdd[0])) {\n            toAdd = toAdd[0];\n        }\n        // ignore unpersistable records\n        return super.add(...toAdd.filter(record => record.isPersistable));\n    }\n};\nStoreBag._$name = 'StoreBag';", "import Base from '../../Base.js';\nimport ArrayHelper from '../../helper/ArrayHelper.js';\n/**\n * @module Core/data/mixin/StoreCRUD\n */\n/**\n * Mixin for Store that handles modifying records (add, remove etc).\n *\n * @example\n * // add new record to store\n * store.add({ id: 1, team: 'FC Krasnodar' });\n *\n * // remove a record from store, using id\n * store.remove(1);\n *\n * @mixin\n */\nexport default Target => class StoreCRUD extends (Target || Base) {\n    static get $name() {\n        return 'StoreCRUD';\n    }\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * Commit changes automatically\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            autoCommit : false\n        };\n    }\n    static get properties() {\n        return {\n            isRemoving   : false,\n            suspendCount : 0\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired after removing all records\n     * @event removeAll\n     * @param {Core.data.Store} source This Store\n     */\n    /**\n     * Fired before committing changes. Return false from handler to abort commit\n     * @event beforeCommit\n     * @param {Core.data.Store} source This Store\n     * @param {Object} changes Modification data\n     */\n    /**\n     * Fired after committing changes\n     * @event commit\n     * @param {Core.data.Store} source This Store\n     * @param {Object} changes Modification data\n     */\n    /**\n     * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.\n     * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.\n     * The remove may be vetoed by returning `false` from a handler.\n     * @event beforeRemove\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model[]} records The records which are to be removed.\n     * @param {Core.data.Model} parent The record from which children are being removed when using a tree store. Only\n     * provided when removing a single node.\n     * @param {Boolean} isMove This flag is `true` if the child node is being removed by\n     * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved\n     * _within the same tree_.\n     * @param {Boolean} removingAll This flag is `true` if the operation is removing the store's entire data set.\n     * @preventable\n     */\n    /**\n     * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree\n     * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and\n     * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`\n     * from a handler.\n     * @event beforeAdd\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model[]} records The records which are to be added\n     * @param {Core.data.Model} parent The parent node when using a tree store\n     * @preventable\n     */\n    /**\n     * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the\n     * event. If it was inserted, event contains `index`\n     * @event add\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root\n     * is returned\n     * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is\n     * added, all new records are returned, not only branch root\n     * @param {Core.data.Model} [parent] If due to an {@link Core/data/mixin/TreeNode#function-appendChild}\n     * call, this is the parent node added to.\n     * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.\n     * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.\n     * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record\n     * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent\n     * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another\n     * position in the store, or from another parent node in the store. The ids of moved records will be\n     * property names with a value `true`.\n     */\n    /**\n     * Fired when one or more records are removed\n     * @event remove\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model[]} records Array of removed records. In case of tree store, if branch is removed, only branch root\n     * is returned\n     * @param {Core.data.Model[]} [allRecords] Flat array of all removed records. In case of tree store, if branch is\n     * removed, all removed records are returned, not only branch root\n     * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}\n     * call, this is the parent node removed from. Only applicable when removing a single tree node.\n     * @param {Number} [index] Visible index at which record was removed. In case the record was removed from a collapsed\n     * branch, -1 is returned. For tree store, this is only provided when removing a single node.\n     * @param {Boolean} [isChild] Flag which is set to true if the record was removed from a parent record\n     * @param {Boolean} [isCollapse] Flag which is set to true if records were removed from the store by collapsing parent\n     * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.\n     */\n    //endregion\n    //region Add, insert & remove\n    /**\n     * Removes a record from this store. Fires a single {@link #event-remove} event passing the removed records.\n     * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove\n     * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit\n     * @returns {Core.data.Model[]} Removed records\n     * @fires beforeRemove\n     * @fires remove\n     * @fires change\n     * @category CRUD\n     */\n    remove(records, silent = false) {\n        const\n            me          = this,\n            { storage } = me;\n        // Ensure we have an array of records in case we are passed IDs\n        records = ArrayHelper.asArray(records).reduce((result, r) => {\n            r = me.getById(r);\n            if (r) {\n                result.push(r);\n            }\n            return result;\n        }, []);\n        if (records.length === 0) {\n            return records;\n        }\n        // Give chance to veto or take action before records disappear.\n        if (!me.tree && !silent && me.trigger('beforeRemove', { records }) === false) {\n            return [];\n        }\n        // Flag that can be checked in linked store to determine if removal is ongoing\n        me.isRemoving = true;\n        // Ensure that records in collapsed groups are removed and events fired.\n        if (me.isGrouped) {\n            const\n                oldCount                 = storage.count,\n                recordsInCollapsedGroups = [],\n                changedGroupParents      = new Set();\n            // Collect any records which are in collapsed groups which will not be in the storage\n            // Collection, and so will not cause a store change.\n            // If we find some, we must fire the event which the store will react to and update itself.\n            for (const rec of records) {\n                const { groupParent } = rec.instanceMeta(me);\n                if (groupParent.meta.collapsed) {\n                    recordsInCollapsedGroups.push(rec);\n                }\n                // Collect group header records which change so they can announce this to cause UI updates.\n                ArrayHelper.remove(groupParent.groupChildren, rec);\n                ArrayHelper.remove(groupParent.unfilteredGroupChildren, rec);\n                groupParent.meta.childCount--;\n                changedGroupParents.add(groupParent);\n            }\n            // The changed group parents must announce their changes, otherwise the group headers\n            // in a UI will not refresh to reflect the change.\n            for (const groupParent of changedGroupParents) {\n                if (groupParent.groupChildren.length > 0) {\n                    me.onModelChange(groupParent, {}, {});\n                }\n            }\n            // The store must react as if these records in collapsed groups have been removed from storage\n            if (recordsInCollapsedGroups.length) {\n                storage.trigger('change', {\n                    action   : 'splice',\n                    removed  : recordsInCollapsedGroups,\n                    added    : [],\n                    replaced : [],\n                    oldCount\n                });\n            }\n        }\n        else if (me.tree) {\n            const\n                allRemovedRecords = [],\n                removingMultiple  = records.length > 1,\n                firstRemoved      = records[0],\n                // index is only relevant when removing single node\n                index             = removingMultiple ? undefined : storage.indexOf(firstRemoved),\n                // Group all tree nodes by their parent since they might be out of order\n                removeChildArgs   = records.reduce((result, child) => {\n                    const { parent } = child;\n                    if (parent) {\n                        if (!result[parent.id]) {\n                            result[parent.id] = [parent, []];\n                        }\n                        result[parent.id][1].push(child);\n                    }\n                    return result;\n                }, {}),\n                removals          = Array.from(Object.values(removeChildArgs));\n            if (!silent && me.trigger('beforeRemove', { records, isMove : false, parent : removingMultiple ? undefined : firstRemoved.parent }) === false) {\n                me.isRemoving = false;\n                return [];\n            }\n            // need to process the removals starting from deep-most ones, otherwise if we start with removal\n            // from higher-level parent, then all its children are removed from the store as well\n            // when the order comes to remove from the child node, it is not in the store and does not have\n            // stm instance, so removal happens outside the stm context\n            // https://github.com/bryntum/support/issues/5436\n            removals.sort((a, b) => b[0].childLevel - a[0].childLevel);\n            // Remove the records each from their correct parent\n            for (const [parent, children] of removals) {\n                allRemovedRecords.push(...parent.removeChild(children, false, true));\n            }\n            if (!silent) {\n                me.trigger('remove', {\n                    // parent is only relevant when removing single node\n                    parent     : removingMultiple ? undefined : firstRemoved.parent,\n                    index,\n                    isChild    : true,\n                    allRecords : allRemovedRecords,\n                    isMove     : false,\n                    records\n                });\n                me.trigger('change', {\n                    action : 'remove',\n                    records\n                });\n            }\n            me.isRemoving = false;\n            return records;\n        }\n        if (records.length === 0) {\n            me.isRemoving = false;\n            return records;\n        }\n        // Call model hook to allow taking action before removal (used by ModelLink to remove linked records)\n        for (const record of records) {\n            record.beforeRemove(records);\n        }\n        if (silent) {\n            me.suspendEvents();\n        }\n        storage.remove(records);\n        if (silent) {\n            me.resumeEvents();\n        }\n        if (me.autoCommit) {\n            me.doAutoCommit();\n        }\n        me.isRemoving = false;\n        return records;\n    }\n    /**\n     * Clears store data. Used by removeAll, separate function for using with chained stores.\n     * @private\n     * @category CRUD\n     */\n    clear(isLoading = false) {\n        const\n            me          = this,\n            { storage } = me;\n        // For tree store, we have to check unfilteredChildren to see if store has contents\n        if (me.storage.totalCount || me.rootNode?.unfilteredChildren?.length) {\n            // Give chance to veto or take action before records disappear.\n            if (!isLoading && me.trigger('beforeRemove', { records : storage.allValues, removingAll : true }) === false) {\n                return null;\n            }\n            // For tree scenario, clean up root node too\n            if (me.rootNode) {\n                // A chained tree store shares root node with its master store\n                if (!me.isChained) {\n                    me.rootNode.clearChildren(isLoading);\n                }\n            }\n            else if (isLoading) {\n                // If we are loading, we suspend events, and Store#onDataChange won't get to\n                // do all this stuff.\n                const allRecords = me.registeredRecords;\n                for (let i = allRecords.length - 1, rec; i >= 0; i--) {\n                    rec = allRecords[i];\n                    if (rec && !rec.isDestroyed) {\n                        rec.unjoinStore(me);\n                    }\n                }\n            }\n            if (isLoading) {\n                me.removed.clear();\n                storage.suspendEvents();\n            }\n            // Clearing the storage will trigger 'removeAll' and 'change' if `removing`\n            storage.clear();\n            if (isLoading) {\n                storage.resumeEvents();\n            }\n            me.added.clear();\n            me.modified.clear();\n        }\n    }\n    /**\n     * Removes all records from the store.\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`\n     * @fires beforeRemove\n     * @fires removeAll\n     * @fires change\n     * @category CRUD\n     */\n    removeAll(silent = false) {\n        const\n            me      = this,\n            storage = me.storage;\n        let result;\n        me.isRemoving = true;\n        // No reaction to the storage Collection's change event.\n        if (silent) {\n            storage.suspendEvents();\n            // If silent, the storage Collection won't fire the event we react to\n            // to unjoin, and we allow the removing flag in remove() to be true,\n            // so *it* will not do the unJoin, so if silent, so do it here.\n            const allRecords = me.registeredRecords;\n            for (let i = allRecords.length - 1, rec; i >= 0; i--) {\n                rec = allRecords[i];\n                if (rec && !rec.isDestroyed && !rec.isRoot) {\n                    rec.unjoinStore(me);\n                }\n            }\n        }\n        if (me.tree) {\n            result = me.rootNode.clear() !== false;\n        }\n        else {\n            result = me.clear() !== null;\n        }\n        if (silent) {\n            storage.resumeEvents();\n        }\n        me.isRemoving = false;\n        return result;\n    }\n    /**\n     * Add records to store.\n     * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Core.data.Model[]} Added records\n     * @fires add\n     * @fires change\n     * @category CRUD\n     */\n    add(records, silent = false, options = {}) {\n        const\n            me          = this,\n            { storage } = me;\n        records = ArrayHelper.asArray(records);\n        if (!records?.length) {\n            // Adding zero records, bail out\n            return;\n        }\n        me.tree = me.tree || Boolean(me.autoTree && records[0].children);\n        if (me.tree) {\n            const\n                // Map and not Object to allow keys to keep their type\n                parentIdMap       = new Map(),\n                parentIndexField  = me.modelClass.getFieldDataSource('parentIndex'),\n                { parentIdField } = me.modelClass,\n                added             = [];\n            records.forEach(node => {\n                const parentId = node[parentIdField];\n                if (!parentIdMap.has(parentId)) {\n                    parentIdMap.set(parentId, { append : [], insert : [] });\n                }\n                const entry = parentIdMap.get(parentId);\n                // Allow inserting raw data at specific index when passing a parentIndex, used by\n                // ProjectChangeHandlerMixin\n                if (!node.isModel && parentIndexField in node) {\n                    entry.insert.push(node);\n                }\n                else {\n                    entry.append.push(node);\n                }\n            });\n            parentIdMap.forEach(({ append, insert }, parentId) => {\n                const parentNode = parentId == null ? me.rootNode : me.getById(parentId);\n                if (!parentNode) {\n                    throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);\n                }\n                // Append all that needs appending in one go\n                if (append.length) {\n                    added.push(...parentNode.appendChild(append, silent));\n                }\n                // Insertions has to happen one at the time\n                if (insert.length) {\n                    for (const toInsert of insert) {\n                        added.push(parentNode.insertChild(toInsert, toInsert[parentIndexField], silent, options));\n                    }\n                }\n            });\n            // Sort if configured to do so on add, but not if syncing data on load since that will sort anyway\n            if (me.reapplySortersOnAdd && !me.isSyncingDataOnLoad) {\n                me.sort();\n            }\n            return added;\n        }\n        // Give chance to cancel action before records added.\n        if (!silent && me.trigger('beforeAdd', { records }) === false) {\n            return null;\n        }\n        me.tree = me.tree || Boolean(me.autoTree && records[0].children);\n        if (me.tree) {\n            return me.rootNode.appendChild(records);\n        }\n        const added = me.processRecords(records);\n        if (silent) {\n            me.suspendEvents();\n        }\n        storage.add(added);\n        if (silent) {\n            me.resumeEvents();\n        }\n        if (me.autoCommit) {\n            me.doAutoCommit();\n        }\n        return added;\n    }\n    processRecords(records, onRecordCreated) {\n        return records.map(data => {\n            const record = this.processRecord(data.isModel ? data : this.createRecord(data));\n            onRecordCreated?.call(this, record);\n            return record;\n        });\n    }\n    /**\n     * Insert records into the store.\n     * @param {Number} index Index to insert at\n     * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Core.data.Model[]} Inserted records\n     * @fires add\n     * @fires change\n     * @category CRUD\n     */\n    insert(index, records, silent = false) {\n        const\n            me            = this,\n            storage       = me.storage,\n            insertBefore  = me.getAt(index),\n            _records      = storage.values,\n            removeIndices = [];\n        records = ArrayHelper.asArray(records);\n        if (me.tree) {\n            const root = me.rootNode;\n            return root.insertChild(records, root.children?.[index], silent);\n        }\n        // Give chance to cancel action before records added.\n        if (!silent && me.trigger('beforeAdd', { records }) === false) {\n            return null;\n        }\n        let isNoop, start, i;\n        // If the records starting at index or (index - 1), are the same sequence\n        // that we are being asked to add, this is a no-op.\n        if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {\n            for (isNoop = true, i = 0; isNoop && i < records.length; i++) {\n                if (records[i] !== _records[start + i]) {\n                    isNoop = false;\n                }\n            }\n        }\n        if (isNoop) {\n            return null;\n        }\n        const added = me.processRecords(records, record => {\n            const\n                removedAtIndex = storage.indexOf(record);\n            if (record.children && record.children.length && me.autoTree) {\n                me.tree = true;\n            }\n            // already in store, do some cleanup\n            if (removedAtIndex > -1) {\n                if (removedAtIndex < index && insertBefore) index--;\n                removeIndices.push(removedAtIndex);\n            }\n            // Store previous index to be able to determine that it is a move, since Collection does not handle that\n            record.meta.previousIndex = removedAtIndex;\n        });\n        // Silently remove them, so that they will be inserted into place.\n        // Collection is stable by default, and inserting an existing item\n        // is a no-op.\n        me.suspendEvents();\n        me.storage.remove(removeIndices);\n        me.resumeEvents();\n        if (silent) {\n            me.suspendEvents();\n        }\n        storage.splice(index, 0, ...added);\n        if (silent) {\n            me.resumeEvents();\n        }\n        if (me.autoCommit) {\n            me.doAutoCommit();\n        }\n        return added;\n    }\n    /**\n     * Moves a record, or block of records to another location.\n     * @param {Core.data.Model|Core.data.Model[]} records The record(s) to move.\n     * @param {Core.data.Model} beforeRecord the record to insert the first record(s) before.\n     * @fires change\n     * @category CRUD\n     */\n    move(records, beforeRecord) {\n        if (this.isTree) {\n            beforeRecord.parent.insertChild(records, beforeRecord);\n        }\n        else {\n            this.storage.move(records, beforeRecord);\n        }\n    }\n    //endregion\n    //region Update multiple\n    setMultiple(filterFn, field, value) {\n        const\n            me      = this,\n            records = [],\n            changes = [];\n        me.forEach(r => {\n            if (filterFn(r)) {\n                changes.push(r.set(field, value, true));\n                records.push(r);\n            }\n        });\n        me.trigger('updateMultiple', { records, all : me.records.length === records.length });\n        me.trigger('change', { action : 'updatemultiple', records, all : me.records.length === records.length });\n        if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();\n    }\n    setAll(field, value) {\n        const\n            me      = this,\n            changes = [];\n        me.forEach(r => {\n            changes.push(r.set(field, value, true));\n        });\n        me.trigger('updateMultiple', { records : me.records, all : true });\n        me.trigger('change', { action : 'updatemultiple', records : me.records, all : true });\n        if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();\n    }\n    //endregion\n    //region Commit\n    /**\n     * Accepts all changes, resets the modification tracking:\n     * * Clears change tracking for all records\n     * * Clears added\n     * * Clears modified\n     * * Clears removed\n     * Leaves the store in an \"unmodified\" state.\n     * @internal\n     */\n    acceptChanges() {\n        const me = this;\n        // Clear record change tracking\n        me.added.forEach(r => r.clearChanges(true, false));\n        me.modified.forEach(r => r.clearChanges(true, false));\n        // Clear store change tracking\n        me.added.clear();\n        me.modified.clear();\n        me.removed.clear();\n    }\n    /**\n     * Commits changes, per default only returns changes and resets tracking.\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Object} Changes, see {@link #property-changes}\n     * @fires beforeCommit\n     * @fires commit\n     * @category CRUD\n     */\n    commit(silent = false) {\n        // resets stores tracking of changed records, doesn't store changes, only returns them\n        const\n            { changes } = this;\n        if (!silent && this.trigger('beforeCommit', { changes }) === false) {\n            return false;\n        }\n        this.acceptChanges();\n        if (!silent) {\n            this.trigger('commit', { changes });\n        }\n        return changes;\n    }\n    /**\n     * Reverts all changes in the store (adds removed records back, and removes newly added records).\n     * @fires change\n     * @fires refresh\n     * @category CRUD\n     */\n    revertChanges() {\n        const\n            me          = this,\n            { changes } = me;\n        if (changes) {\n            const event = { action : 'clearchanges', changes };\n            me.add(me.removed.values, true);\n            me.remove(me.added.values, true);\n            me.modified.forEach(r => r.revertChanges(true));\n            me.added.clear();\n            me.modified.clear();\n            me.removed.clear();\n            me.trigger('change', event);\n            me.trigger('refresh', event);\n        }\n    }\n    /**\n     * Get uncommitted changes as an object of added/modified/removed arrays of records.\n     *\n     * ```javascript\n     * // Format:\n     * {\n     *      added: [], // array of Core.data.Model\n     *      modified: [], // array of Core.data.Model\n     *      removed: [] // array of Core.data.Model\n     * }\n     * ```\n     *\n     * @member {Object} changes\n     * @property {Core.data.Model[]} changes.added Records that have been added\n     * @property {Core.data.Model[]} changes.modified Records that have changes to persistable fields\n     * @property {Core.data.Model[]} changes.removed Records that have been removed\n     * @readonly\n     * @category Records\n     */\n    get changes() {\n        const\n            me       = this,\n            // Only include modified records that have persistable changes\n            modified = me.modified.values.filter(r => r.rawModifications);\n        return (me.added.count || modified.length || me.removed.count) ? {\n            // Slicing to have changes intact when triggering commit\n            added   : me.added.values.slice(),\n            modified,\n            removed : me.removed.values.slice()\n        } : null;\n    }\n    /**\n     * Setting autoCommit to true automatically commits changes to records.\n     * @property {Boolean}\n     * @category Records\n     */\n    get autoCommit() {\n        return this._autoCommit;\n    }\n    set autoCommit(auto) {\n        this._autoCommit = auto;\n        if (auto && this.changes) {\n            this.commit();\n        }\n    }\n    /**\n     * Suspends automatic commits upon store changes. Can be called multiple times (it uses an internal counter).\n     * @category Records\n     */\n    suspendAutoCommit() {\n        this.suspendCount++;\n    }\n    /**\n     * Resumes automatic commits upon store changes. Will trigger commit if the internal counter is 0.\n     * @category Records\n     */\n    resumeAutoCommit(doCommit = true) {\n        this.suspendCount--;\n        if (this.autoCommit && doCommit) {\n            this.doAutoCommit();\n        }\n    }\n    doAutoCommit() {\n        if (this.suspendCount <= 0) {\n            this.commit();\n        }\n    }\n    //endregion\n};\n", "import Base from '../../Base.js';\nimport ArrayHelper from '../../helper/ArrayHelper.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\n/**\n * @module Core/data/mixin/StoreChanges\n */\n/**\n * Mixin for Store that handles applying changes (presumable from a backend)\n *\n * @mixin\n */\nexport default Target => class StoreChanges extends (Target || Base) {\n    static get $name() {\n        return 'StoreChanges';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Specifies target to filter and sort after applying changeset:\n             * * `'changes'` - apply sort and filter to changeset only (see more below)\n             * * `'none'` - do not apply sort and filter\n             *\n             * ### `changes` behavior\n             * If the store has filters in effect when the changeset is applied, the following rules will determine how the\n             * filtered values are affected:\n             * - Among added records, only those that match the filter will be included in the filtered set\n             * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,\n             *   and those that did match but no longer do will also remain in the filtered set. This means that new records may\n             *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are\n             *   re-applied.\n             *\n             * @default\n             * @prp {'changes'|'none'}\n             */\n            applyChangesetFilterSortTarget : 'changes'\n        };\n    }\n    /**\n     * Applies changes from another store to this store. Useful if cloning records in one store to display in a\n     * grid in a popup etc. to reflect back changes.\n     * @param {Core.data.Store} otherStore\n     * @category CRUD\n     */\n    applyChangesFromStore(otherStore) {\n        const\n            me          = this,\n            { changes } = otherStore;\n        if (!changes) {\n            return;\n        }\n        if (changes.added) {\n            me.add(changes.added);\n        }\n        if (changes.removed) {\n            // Remove using id, otherwise indexOf in remove fn won't yield correct result\n            me.remove(changes.removed.map(r => r.id));\n        }\n        if (changes.modified) {\n            changes.modified.forEach(record => {\n                const localRecord = me.getById(record.id);\n                localRecord.set(record.modifications);\n            });\n        }\n    }\n    /**\n     * Applies a set of changes (presumable from a backend) expressed as an object matching the format outputted by the\n     * {@link Core/data/Store#property-changes} property: `{ added : [], modified/updated : [], removed : [] }`\n     *\n     * `added` is expected to be an array of raw data objects consumable by the stores model class for records to add to\n     * the store (see example snippet below).\n     *\n     * `modified` (or `updated` for compatibility with Schedulers CrudManager) is expected to have the same format as\n     * `added`, but should always include the `id` of the record to update.\n     *\n     * Records that have been created locally and gets assigned a proper id by the backend are expected to also pass a\n     * `phantomId` field (name of the field is configurable using the `phantomIdField` arg, more info on phantom ids\n     * below), to match it with the current id of a local record (`id` will contain the new id).\n     *\n     * Note that it is also possible to pass this `phantomId` -> `id` mapping in the `added` array. When encountering a\n     * record in that array that already exists in the local store, it will be treated the same was as a record in the\n     * `modified` array.\n     *\n     * `removed` is expected to be an array of objects with the `{ id : xx }` shape. Any matches on an id in the store\n     * will be removed, those and any non matches will also be cleared from the change tracking of the store.\n     *\n     * If the store has filters in effect when the changeset is applied, the following rules will determine how the\n     * filtered values are affected:\n     * - Among added records, only those that match the filter will be included in the filtered set\n     * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,\n     *   and those that did match but no longer do will also remain in the filtered set. This means that new records may\n     *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are\n     *   re-applied.\n     *\n     * As an example, consider a store with the following initial state and some operations performed on it:\n     *\n     * ```javascript\n     * // Load some data into the store\n     * store.data = [\n     *     { id : 1, name : 'Minerva' },\n     *     { id : 2, name : 'Mars' },\n     *     { id : 3, name : 'Jupiter' }\n     * ];\n     * // Add a new record. It gets assigned a generated id,\n     * // for example 'generated56'\n     * store.add({ name : 'Artemis' });\n     * // Remove Jupiter\n     * store.remove(3);\n     * ```\n     *\n     * After syncing those operations to a custom backend (however you chose to solve it in your application) we might\n     * get the following response (see \"Transforming a response to the correct format\" below if your backend responds\n     * in another format):\n     *\n     * ```javascript\n     * const serverResponse = {\n     *     added : [\n     *         // Added by the backend, will be added locally\n     *         { id : 5, name : 'Demeter' }\n     *     ],\n     *\n     *     updated : [\n     *         // Will change the name of Minerva -> Athena\n     *         { id : 1, name : 'Athena' },\n     *         // Will set proper id 4 for Artemis\n     *         { $PhantomId : 'generated56', id : 4 }\n     *     ],\n     *\n     *     removed : [\n     *         // Confirmed remove of Jupiter\n     *         { id : 3 },\n     *         // Removed by the backend, Mars will be removed locally\n     *         { id : 2 }\n     *     ]\n     * };\n     * ```\n     *\n     * If that response is then passed to this function:\n     *\n     * ```javascript\n     * store.applyChangeSet(serverResponse);\n     * ```\n     *\n     * The end result will be the following data in the store:\n     *\n     * ```javascript\n     * [\n     *     { id : 1, name : 'Athena' }, // Changed name\n     *     { id : 4, name : 'Artemis' }, // Got a proper id\n     *     { id : 5, name : 'Demeter' } // Added by the backend\n     * ]\n     * ```\n     *\n     * ### Phantom ids\n     *\n     * When a record is created locally, it is always assigned a generated id. That id is called a phantom id (note that\n     * it is assigned to the normal id field). When passing the new record to the backend, the id is sent with it. When\n     * the backend inserts the record into the database, it (normally) gets a proper id assigned. That id then needs to\n     * be passed back in the response, to update the local record with the correct id. Making sure that future updates\n     * match the correct row in the database.\n     *\n     * For example a newly created record should be passed similar to this to the backend (pseudo format, up to the\n     * application/backend to decide):\n     *\n     * ```json\n     * {\n     *     \"added\" : {\n     *         \"id\" : \"generated79\",\n     *         \"name\" : \"Hercules\",\n     *         ...\n     *     }\n     * }\n     * ```\n     *\n     * For the backend response to be applicable for this function, it should then respond with:\n     *\n     * ```json\n     * {\n     *     \"updated\" : {\n     *         {\n     *             \"$PhantomId\" : \"generated79\",\n     *             \"id\" : 465\n     *         }\n     *     }\n     * }\n     * ```\n     *\n     * (Or, as stated above, it can also be passed in the \"added\" array. Which ever suits your backend best).\n     *\n     * This function will then change the id of the local record using the phantom id `generated79` to `465`.\n     *\n     * ### Transforming a response to the correct format\n     *\n     * This function optionally accepts a `transformFn`, a function that will be called with the `changes`. It is\n     * expected to return a changeset in the format described above (`{ added : [], updated : [], removed : [] }`),\n     * which then will be used to apply the changes.\n     *\n     * Consider the following \"non standard\" (made up) changeset:\n     *\n     * ```javascript\n     * const changes = {\n     *     // Database ids for records previously added locally\n     *     assignedIds : {\n     *         'phantom1' : 10,\n     *         'phantom2' : 15\n     *     },\n     *     // Ids records removed by the backend\n     *     removed : [11, 27],\n     *     // Modified records, keyed by id\n     *     altered : {\n     *         12 : { name : 'Changed' }\n     *     },\n     *     // New records, keyed by id\n     *     inserted : {\n     *         20  : { name : 'New' }\n     *     }\n     * }\n     * ```\n     *\n     * Since it does not match the expected format it has to be transformed:\n     *\n     * ```javascript\n     * store.applyChangeset(changes, ({ assignedIds, inserted, altered, removed }) => ({\n     *    // Convert inserted to [{ id : 20, name : 'New' }]\n     *    added : Object.entries(inserted).map(([id, data] => ({ id, ...data }),\n     *    updated : [\n     *        // Convert assignedIds to [{ $PhantomId : 'phantom1', id : 10 }, ...]\n     *       ...Object.entries(assignedIds).map(([phantomId, id])) => ({ $PhantomId : phantomId, id }),\n     *       // Convert altered to [{ id : 12, name : 'Changed' }]\n     *       ...Object.entries(modified).map(([id, data] => ({ id, ...data })\n     *    ],\n     *    // Convert removed to [{ id : 11 }, ...]\n     *    removed : removed.map(id => ({ id }))\n     * }));\n     * ```\n     *\n     * The transform function above would output:\n     *\n     * ```javascript\n     * {\n     *     added : [\n     *         {  id : 20, name : 'New' }\n     *     ],\n     *     updated : [\n     *         { $PhantomId : 'phantom1', id : 10 },\n     *         { $PhantomId : 'phantom2', id : 15 },\n     *         {  id : 12, name : 'Changed' }\n     *     ],\n     *     removed : [\n     *        { id : 11 },\n     *        { id : 12 }\n     *     ]\n     * }\n     * ```\n     *\n     * And that format can then be applied.\n     *\n     * @param {Object} changes Changeset to apply to the store, see specification above\n     * @param {Function} [transformFn] Optional function used to preprocess a changeset in a different format,\n     * should return an object with the format expected by this function (see above)\n     * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a proper id\n     * instead of a phantom id (see above)\n     * @privateparam {Boolean} [remote] Set to true to indicate changes are from the remote source. Remote changes have\n     * precedence over local.\n     * @privateparam {Boolean} [logChanges] Used by CrudManager to be able to revert specific changes later\n     * @category CRUD\n     */\n    applyChangeset(changes, transformFn = null, phantomIdField = '$PhantomId', remote = true, logChanges = false) {\n        const\n            me                                    = this,\n            { added, updated, modified, removed } = transformFn?.(changes, me) ?? changes,\n            // To support both updated & modified (store uses modified, CM updated)\n            altered                               = updated ?? modified ?? [],\n            idDataSource                          = me.modelClass.getFieldDataSource('id'),\n            log                                   = logChanges ? new Map() : null,\n            allAdded                              = [],\n            allAltered                            = [];\n        let rootUpdated = false, modifiedParents = [];\n        // Store currently visible records to keep records which no longer match filter in view\n        me._groupVisibleRecordIds = [];\n        // We only need this for grouped store which cannot be a tree store\n        me.isGrouped && me.forEach(record => {\n            me._groupVisibleRecordIds.push(record.id);\n        });\n        // Process added records\n        if (added?.length > 0) {\n            const\n                toUpdate = [],\n                toAdd    = [];\n            // Separate actually new records from added records that get a proper id set up, to match more backends\n            for (const data of added) {\n                if (me.getById(data[phantomIdField] ?? ObjectHelper.getPath(data, idDataSource))) {\n                    // we need to keep order of the added records\n                    // https://github.com/bryntum/support/issues/5189\n                    toUpdate.push(data);\n                }\n                else {\n                    toAdd.push(data);\n                }\n            }\n            altered.unshift.apply(altered, toUpdate);\n            // Create new records in the store, and clear them out of the added bag\n            // When applying remote changes we do not want to update ordered tree index until all\n            // add/update/remove action are finalized. After that we can sort it correctly.\n            const addedRecords = me.add(toAdd, false, { orderedParentIndex : { skip : true } }) ?? [];\n            allAdded.push(...addedRecords);\n            if (me.tree) {\n                // Go over added records and find all parents which children are modified in case\n                // we need to restore ordered tree\n                for (const record of addedRecords) {\n                    const { parent } = record;\n                    // If root WBS should be updated\n                    if (parent.isRoot) {\n                        rootUpdated = true;\n                        modifiedParents = [parent];\n                        break;\n                    }\n                    if (!parent.isRoot && modifiedParents.every(r => !r.contains(parent))) {\n                        modifiedParents.push(parent);\n                    }\n                }\n            }\n            for (const record of addedRecords) {\n                log?.set(record.id, record.data);\n                record.clearChanges();\n            }\n        }\n        // Process modified records\n        if (altered?.length > 0) {\n            for (const data of altered) {\n                const\n                    phantomId = data[phantomIdField],\n                    id        = ObjectHelper.getPath(data, idDataSource),\n                    record    = me.getById(phantomId ?? id);\n                // Matching an existing record -> update it\n                if (record) {\n                    const changes = record.applyChangeset(data, phantomIdField, remote);\n                    // If current record is not part of tree already scheduled to ordering, add it\n                    if (me.tree && !rootUpdated && modifiedParents.every(r => !r.contains(record))) {\n                        if (record.parent.isRoot) {\n                            rootUpdated = true;\n                            modifiedParents = [record.parent];\n                        }\n                        else {\n                            modifiedParents.push(record.parent);\n                        }\n                    }\n                    log?.set(id, changes);\n                    allAltered.push(record);\n                }\n            }\n        }\n        // Process removed records\n        if (removed?.length > 0) {\n            me.applyRemovals(removed);\n        }\n        if (me.applyChangesetFilterSortTarget === 'changes') {\n            const parentsModifiedByFilter = me.filterChangeset(allAdded, allAltered);\n            modifiedParents.push(...parentsModifiedByFilter);\n        }\n        me.afterChangesetApplied(modifiedParents);\n        me._groupVisibleRecordIds = null;\n        return log;\n    }\n    afterChangesetApplied(modifiedParents) {\n        // Can we always safely use ordered tree?\n        modifiedParents.forEach(parent => {\n            parent.traverse(record => {\n                record.sortOrderedChildren(false, false);\n                // Parent index from the remote source might have been applied, in which case\n                // we need to update local index because we do not want any movements in the tree\n                if (record.children) {\n                    record.updateChildrenIndices(record.children, 'parentIndex', true);\n                }\n                if (record.unfilteredChildren) {\n                    record.updateChildrenIndices(record.unfilteredChildren, 'unfilteredIndex', true);\n                }\n            });\n        });\n    }\n    // Apply removals, removing records and updating the `removed` bag to match.\n    //\n    // Accepts an array of objects containing an `id` property. Records in the store matching an entry in the array\n    // will be removed from the store and the `removed` bag. Unmatched entries will be removed from the `removed` bag.\n    applyRemovals(removals) {\n        const\n            me                         = this,\n            { removed : removedStash } = me,\n            idDataSource               = me.modelClass.idField,\n            toRemove                   = [];\n        for (const removedEntry of removals) {\n            const id = ObjectHelper.getPath(removedEntry, idDataSource);\n            // Removed locally and confirmed by server, just remove the record from the removed stash\n            if (removedStash.includes(id)) {\n                removedStash.remove(id);\n            }\n            // Server driven removal (most likely), collect for removal locally too\n            else  {\n                toRemove.push(id);\n            }\n        }\n        // Remove collected records in one go\n        me.remove(toRemove);\n        // Leave no trace of them at all\n        for (const record of toRemove) {\n            removedStash.remove(record);\n        }\n    }\n    /**\n     * Filters records that have been added/updated as part of a changeset. The `added` and `updated` parameters\n     * are arrays of values that have already been added/updated in the Collection's values. This method brings\n     * the Collection's `_filteredValues` in sync without performing a full sort or filter, using the following rules:\n     *\n     * - Added records that do not match the filter are removed from _filteredValues\n     *\n     * - Updated records that now match the filter are inserted at the correct position in _filteredValues\n     *   if they were not formerly included\n     *\n     * - Updated records that formerly matched the filter, but now do not, are NOT removed from _filteredValues\n     *\n     * If the collection is sorted, either on its own or via a sort applied at the store level, that sort order is\n     * respected when adding items to _filteredValues. If not, items are inserted in the same order they occur in\n     * _values.\n     *\n     * @param {Object[]} added An array of unique values that were added as part of the changeset.\n     * @param {Object[]} updated An array of unique values that were updated as part of the changeset.\n     * @returns {Object[]} Any records that were added or removed from view, or whose children were modified.\n     * @private\n     */\n    filterChangeset(added, updated) {\n        const\n            me = this,\n            {\n                isFiltered,\n                tree,\n                isGrouped,\n                filtersFunction\n            } = me,\n            storeSortFunction = me.isSorted ? me.createSorterFn(me.sorters) : undefined,\n            {\n                allValues,\n                addedValues,\n                isSorted\n            } = me.storage,\n            sorter = storeSortFunction != null || isSorted ? storeSortFunction ?? me.storage.sortFunction : null,\n            modifiedParents = new Set();\n        if (!isFiltered) {\n            return [];\n        }\n        let trigger = false, groupers;\n        // When groups are involved we always rebuild them entirely. We need to store groupers, remove them to get flat\n        // store, apply flat store logic regarding filtering changes, and then re-group store again\n        // https://github.com/bryntum/support/issues/6134\n        if (isGrouped) {\n            groupers = me.groupers;\n            me.clearGroupers(true);\n        }\n        if (tree) {\n            const nodesToInclude = new Set(updated.filter(filtersFunction));\n            // Tree store does not automatically include new filter-matching nested descendants inside\n            // collapsed branches; we must make sure they and their ancestors are all included in the filtered set\n            for (const matchingAdd of added.filter(filtersFunction)) {\n                nodesToInclude.add(matchingAdd);\n            }\n            // Expand to include all ancestors of included rows\n            nodesToInclude.forEach(node => node.bubble(ancestor => nodesToInclude.add(ancestor)));\n            nodesToInclude.delete(me.rootNode);\n            const nodesToIncludeByParent = ArrayHelper.groupBy(Array.from(nodesToInclude), 'parentId');\n            for (const siblingsToInclude of Object.values(nodesToIncludeByParent)) {\n                const { parent } = siblingsToInclude[0];\n                // If `unfilteredChildren` is null, we assume `children` already contains all available children\n                if (parent.unfilteredChildren) {\n                    // Ignore ordering here and just append non-duplicates to `children`\n                    parent.children.push(...siblingsToInclude.filter(child => !parent.children.includes(child)));\n                    modifiedParents.add(parent); // Remember that we modified this, to re-sort later\n                }\n            }\n        }\n        // If store is grouped, sorter will be applied anyway\n        else if (sorter && !isGrouped) {\n            // Non-tree, sorted store\n            // Current approach is to divide the filtered list into a \"sorted\" head and an unsorted tail (items added\n            // since last sort). Insert the newly-matching items into the sorted part, re-sort that, then re-append\n            // the unsorted tail\n            const\n                // Must wait to read filteredValues after clearGroupers\n                { filteredValues } = me.storage,\n                sortedLength = addedValues\n                    ? (filteredValues.findLastIndex(value => !addedValues.has(value)) + 1)\n                    : filteredValues.length,\n                sorted = filteredValues.slice(0, sortedLength),\n                updatedMatches = new Set(updated.filter(filtersFunction));\n            for (const value of filteredValues) {\n                if (updatedMatches.has(value)) {\n                    updatedMatches.delete(value);\n                }\n            }\n            for (const newMatch of updatedMatches) {\n                sorted.push(newMatch);\n            }\n            sorted.sort(sorter);\n            filteredValues.splice(0, sortedLength, ...sorted);\n            trigger = true;\n        }\n        else {\n            // Non-tree, non-sorted store\n            // Move through filtered and unfiltered lists in order, inserting raw value into filtered list whenever one\n            // is encountered that's in the set of matching, updated values\n            const updatedMatches = updated.filter(item =>\n                filtersFunction(item) && !me.storage.includes(item));\n            if (updatedMatches.length > 0) {\n                me.includeInSubset(allValues, me.storage.filteredValues, updatedMatches);\n                trigger = true;\n            }\n        }\n        // Un-show non-matching added records\n        const nonMatchingAdds = new Set(added.filter(value => !filtersFunction(value)));\n        if (nonMatchingAdds.size > 0) {\n            if (tree) {\n                for (const addedChild of nonMatchingAdds) {\n                    ArrayHelper.remove(addedChild.parent.children, addedChild);\n                    modifiedParents.add(addedChild.parent);\n                }\n            }\n            else {\n                ArrayHelper.remove(me.storage.filteredValues, nonMatchingAdds);\n            }\n            trigger = true;\n        }\n        if (groupers) {\n            me.group(groupers[0], null, false, true, true);\n            trigger = true;\n        }\n        if (tree && modifiedParents.size > 0) {\n            me.storage.replaceValues({\n                values : me.collectDescendants(me.rootNode).visible,\n                silent : true\n            });\n        }\n        else if (trigger) {\n            // Storage content has changed, clear idMap to rebuild it\n            me._idMap = null;\n            me.trigger('refresh');\n        }\n        return [...modifiedParents];\n    }\n    /**\n     * Given an array `all`, an array `subset` that is a subset of `all` in the same order, and another array\n     * `toInclude` that is a different subset of `all` disjoint with `subset`, add each item from `toInclude`\n     * to `subset`, in an order matching the order in `all`. The order of `subset` must match the order of `all`.\n     * The order of `toInclude` is unimportant.\n     *\n     * Modifies `subset` in-place.\n     *\n     * @param {Array} all An array of unique items (e.g. records)\n     * @param {Array} subset An array containing a subset of the items in `all` (same order as `all`)\n     * @param {Array} toInclude An array or items from `all` that should be included in `subset` (unordered)\n     * @returns {Array} The subset modified in-place.\n     * @private\n     */\n    includeInSubset(all, subset, toInclude) {\n        const toIncludeSet = new Set(toInclude);\n        let\n            subsetIndex = 0,\n            allIndex = 0,\n            done = toIncludeSet.size === 0;\n        while (allIndex < all.length && !done) {\n            const subsetItem = subset[subsetIndex];\n            let allItem = all[allIndex];\n            // Move ahead in raw list until we find the matching item, inserting new items along the way\n            while (subsetItem !== allItem) {\n                if (toIncludeSet.has(allItem)) {\n                    subset.splice(subsetIndex, 0, allItem);\n                    subsetIndex++;\n                    toIncludeSet.delete(allItem);\n                    done = toIncludeSet.size === 0;\n                }\n                allItem = all[++allIndex];\n            }\n            // Ignore \"to include\" items that are already in the subset (prevents duplicates)\n            if (toIncludeSet.has(subsetItem)) {\n                toIncludeSet.delete(subsetItem);\n            }\n            // Keep going in filtered list\n            if (subsetIndex < subset.length) {\n                subsetIndex++;\n            }\n        }\n        return subset;\n    }\n};\n", "import Base from '../../Base.js';\nimport Filter from '../../util/CollectionFilter.js';\nimport FunctionHelper from '../../helper/FunctionHelper.js';\nimport Collection from '../../util/Collection.js';\nimport ArrayHelper from '../../helper/ArrayHelper.js';\n/**\n * @module Core/data/mixin/StoreFilter\n */\n/**\n * Mixin for Store that handles filtering.\n * Filters are instances of {@link Core/util/CollectionFilter} class.\n *\n * - Adding a filter for the same property will replace the current one (unless a unique {@link Core.util.CollectionFilter#config-id} is specified),\n * but will not clear any other filters.\n * - Adding a filter through the {@link #function-filterBy} function is ultimate.\n * It will clear all the property based filters and replace the current filterBy function if present.\n * - Removing records from the store does not remove filters!\n * The filters will be reapplied if {@link #config-reapplyFilterOnAdd}/{@link #config-reapplyFilterOnUpdate} are true and you add new records or update current.\n *\n * ```javascript\n * // Add a filter\n * store.filter({\n *     property : 'score',\n *     value    : 10,\n *     operator : '>'\n * });\n *\n * // Add filter as a function\n * store.filter(record => record.score > 10);\n *\n * // Add named filter as a function\n * store.filter({\n *     id : 'my filter',\n *     filterBy : record => record.score > 10\n * });\n *\n * // Replace any filter set with new filters\n * store.filter({\n *     filters : {\n *         property : 'score',\n *         value    : 10,\n *         operator : '>'\n *     },\n *     replace : true\n * });\n *\n * // Remove this one specific filter, leaving any possible others in place.\n * // A filter's id defaults to the property name that it's filtering on.\n * store.removeFilter('score');\n *\n * // Reapply filters without firing an event.\n * // Use if making multiple data mutations with the\n * // intention of updating UIs when all finished.\n * store.filter({\n *     silent : true\n * });\n * ```\n *\n * @mixin\n */\nexport default Target => class StoreFilter extends (Target || Base) {\n    static get $name() {\n        return 'StoreFilter';\n    }\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * Specify one or more {@link Core/util/CollectionFilter} config objects to apply initially.\n             *\n             * For example:\n             *\n             * ```javascript\n             *  // Configure the store to filter in clients over the age of 30\n             *  new Store({\n             *      ...,\n             *      filters : [{\n             *          property : 'age',\n             *          value    : 30,\n             *          operator : '>'\n             *      }],\n             *      ...\n             *  })\n             * ```\n             *\n             * or:\n             *\n             * ```javascript\n             *  // Configure the store to filter based on a complex operation\n             *  new Store({\n             *      ...,\n             *      filters : [{\n             *          filterBy(record) {\n             *              // Return true or false for filtering in or out\n             *              return shouldClientBeVisible(record);\n             *          }\n             *      }],\n             *      ...\n             *  })\n             * ```\n             *\n             * @config {CollectionFilterConfig|CollectionFilterConfig[]}\n             * @category Filtering\n             */\n            filters : null,\n            /**\n             * Specify true to reapply filters when a record is added to the store.\n             * @config {Boolean}\n             * @default\n             * @category Filtering\n             */\n            reapplyFilterOnAdd : false,\n            /**\n             * Specify true to reapply filters when a record is updated in the store.\n             * @config {Boolean}\n             * @default\n             * @category Filtering\n             */\n            reapplyFilterOnUpdate : false\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired after applying filters to the store\n     * @event filter\n     * @param {Core.data.Store} source This Store\n     * @param {Core.util.Collection} filters Filters used by this Store\n     * @param {Core.data.Model[]} removed The records which were filtered out by the action.\n     * @param {Core.data.Model[]} added The records which were filtered back in by the action.\n     * @param {Core.data.Model[]} records Filtered records\n     */\n    //endregion\n    //region Properties\n    set reapplyFilterOnAdd(enable) {\n        this.storage.autoFilter = enable;\n    }\n    get reapplyFilterOnAdd() {\n        return this.storage.autoFilter;\n    }\n    /**\n     * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.\n     * @type {Core.util.Collection}\n     * @readonly\n     * @category Sort, group & filter\n     */\n    set filters(filters) {\n        const\n            me         = this,\n            collection = me.filters;\n        collection.clear();\n        // Invalidate the filtersFunction so that it has to be recalculated upon next access\n        me._filtersFunction = null;\n        // If we are being asked to filter, parse the filters.\n        if (filters) {\n            if (filters.constructor.name === 'Object') {\n                for (const f of Object.entries(filters)) {\n                    // Entry keys are either a field name with its value being the filter value\n                    // or, there may be one filterBy property which specifies a filtering function.\n                    if (f[0] === 'filterBy' && typeof f[1] === 'function') {\n                        collection.add(new Filter({\n                            filterBy : f[1]\n                        }));\n                    }\n                    else {\n                        collection.add(new Filter(f[1].constructor.name === 'Object' ? Object.assign({\n                            property : f[0]\n                        }, f[1]) : {\n                            property : f[0],\n                            value    : f[1]\n                        }));\n                    }\n                }\n            }\n            else if (Array.isArray(filters)) {\n                // Make sure we are adding CollectionFilters\n                collection.add(...filters.map(filterConfig => {\n                    if (filterConfig instanceof Filter) {\n                        return filterConfig;\n                    }\n                    return new Filter(filterConfig);\n                }));\n            }\n            else if (filters.isCollection) {\n                // Use supplied collection? Opting to use items from it currently\n                collection.add(...filters.values);\n            }\n            else {\n                collection.add(new Filter({\n                    filterBy : filters\n                }));\n            }\n            collection.forEach(item => item.owner = me);\n        }\n    }\n    get filters() {\n        return this._filters || (this._filters = new Collection({ extraKeys : ['property'] }));\n    }\n    set filtersFunction(filtersFunction) {\n        this._filtersFunction = filtersFunction;\n    }\n    get filtersFunction() {\n        const\n            me                     = this,\n            { filters, isGrouped } = me;\n        if (!me._filtersFunction) {\n            if (filters.count) {\n                const generatedFilterFunction = Filter.generateFiltersFunction(filters);\n                me._filtersFunction = candidate => {\n                    // A group record is filtered in if it has passing groupChildren.\n                    if (isGrouped && candidate.isSpecialRow) {\n                        return candidate.groupChildren.some(generatedFilterFunction);\n                    }\n                    else {\n                        return generatedFilterFunction(candidate);\n                    }\n                };\n            }\n            else {\n                me._filtersFunction = FunctionHelper.returnTrue;\n            }\n        }\n        return me._filtersFunction;\n    }\n    /**\n     * Check if store is filtered\n     * @property {Boolean}\n     * @readonly\n     * @category Sort, group & filter\n     */\n    get isFiltered() {\n        return this.filters.values.some(filter => !filter.disabled);\n    }\n    //endregion\n    traverseFilter(record) {\n        const\n            me          = this,\n            hitsCurrent = !record.isRoot && me.filtersFunction(record),\n            children    = record.unfilteredChildren || record.children;\n        // leaf, bail out\n        if (!children || !children.length) {\n            return hitsCurrent;\n        }\n        if (!record.unfilteredChildren) {\n            record.unfilteredChildren = record.children.slice();\n        }\n        record.children = record.unfilteredChildren.filter(r => {\n            return me.traverseFilter(r);\n        });\n        // unfilteredIndex must be set for child elements\n        record.updateChildrenIndices(record.unfilteredChildren, 'unfilteredIndex', true);\n        // parentIndex must be set for visible child elements\n        record.updateChildrenIndices(record.children, 'parentIndex', true);\n        return hitsCurrent || Boolean(record.children.length);\n    }\n    traverseClearFilter(record) {\n        const me = this;\n        if (record.unfilteredChildren) {\n            record.children = record.unfilteredChildren.slice();\n            record.unfilteredChildren = null;\n        }\n        if (record.children) {\n            record.children.forEach(r => me.traverseClearFilter(r));\n            record.updateChildrenIndices(record.children, 'parentIndex', true);\n        }\n    }\n    get latestFilterField() {\n        return this.filters.last ? this.filters.last.property : null;\n    }\n    /**\n     * Adds a single filter to the {@link #config-filters} collection. By default, filters are reevaluated\n     * and a Store change event fired.\n     *\n     * If the `silent` parameter is passed as `true`, multiple filters can be added without causing data changes.\n     *\n     * When the filters are as required, call {@link #function-filter} with no parameters\n     * to apply the filters to the store.\n     *\n     * @param {CollectionFilterConfig|Function} newFilter A {@link Core.util.CollectionFilter filter} config,\n     * or a function to use for filtering.\n     * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when\n     * adding multiple filters.\n     * @returns {Core.util.CollectionFilter} The Filter instance that was added.\n     * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method\n     * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    addFilter(filter, silent = false) {\n        const me = this;\n        filter = filter instanceof Filter ? filter : new Filter(filter);\n        // We want notification upon change of field, value or operator\n        filter.owner = me;\n        // Collection will replace any already existing filter on the field, unless it has id specified\n        me.filters.add(filter);\n        if (!silent) {\n            if (me.remoteFilter) {\n                return me.filter().then(() => filter);\n            }\n            else {\n                me.filter();\n            }\n        }\n        return filter;\n    }\n    /**\n     * Filters the store by **adding** the specified filter(s) to the existing filters collection applied to this Store.\n     * If a filter has an {@link Core.util.CollectionFilter#config-id id} specified,\n     * or a {@link Core.util.CollectionFilter#config-property property} specified,\n     * it will search for corresponding filter(s) in the existing filters first and replace it with a new filter.\n     * **It will not remove other filters applied to the store!**\n     *\n     * To **add** a new filter:\n     * ```\n     * // Filter using simple object\n     * store.filter({\n     *     property : 'age',\n     *     operator : '>',\n     *     value    : 90\n     * });\n     *\n     * // Filter using function\n     * store.filter(r => r.age < 90);\n     *\n     * // Filter using a named filter as a function\n     * store.filter({\n     *     id : 'my-filter',\n     *     filterBy : record => record.score > 10\n     * });\n     * ```\n     *\n     * To **remove** a specific filter, but keep other filters applied\n     * ```\n     * // Remove by filter `id` or `property`. Filter `id` defaults to the `property` name.\n     * store.removeFilter('age');\n     * store.removeFilter('my-filter');\n     * ```\n     *\n     * To **replace** all existing filters with a new filter\n     * ```\n     * // Remove all filters and filter using simple object\n     * store.filter({\n     *     filters : {\n     *         property : 'age',\n     *         operator : '<',\n     *         value    : 90\n     *     },\n     *     replace : true\n     * });\n     *\n     * // Remove all filters and filter using function\n     * store.filter({\n     *     filters : r => r.age > 90,\n     *     replace : true\n     * });\n     *\n     * // Remove all filters and filter using a named filter as a function\n     * store.filter({\n     *     filters : {\n     *         id : 'my-filter',\n     *         filterBy : record => record.score > 10\n     *     },\n     *     replace : true\n     * });\n     * ```\n     *\n     * Basically filters replacing is an equivalent of having two sequenced calls:\n     * {@link #function-clearFilters clearFilters} and {@link #function-filter filter}.\n     *\n     * Call without arguments to reapply filters.\n     * ```\n     * // Re-filter the store\n     * store.filter();\n     * ```\n     *\n     * @param {Object|CollectionFilterConfig|CollectionFilterConfig[]|Function} newFilters\n     *        A {@link Core.util.CollectionFilter filter} config,\n     *        or an array of {@link Core.util.CollectionFilter filter} configs,\n     *        or a function to use for filtering,\n     *        or a special object like: ```{ replace : true, filters : newFilters }```\n     * @param {Boolean} [newFilters.replace]\n     *        A flag, indicating whether or not the previous filters should be removed.\n     * @param {Boolean} [newFilters.silent]\n     *        Set as true to not fire events. UI will not be informed about the changes.\n     * @param {CollectionFilterConfig|CollectionFilterConfig[]|Function} [newFilters.filters]\n     *        If `newFilters` is an object and `replace` property is defined in the `newFilters`,\n     *        it means that special object is used and real filter configuration must be nested down to this `filters` property.\n     *        It can be:\n     *        A {@link Core.util.CollectionFilter filter} config,\n     *        or an array of {@link Core.util.CollectionFilter filter} configs,\n     *        or a function to use for filtering.\n     * @fires filter\n     * @fires change\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns Promise\n     * which is resolved after data is loaded from remote server, otherwise it returns null value\n     * @async\n     * @category Sort, group & filter\n     */\n    filter(newFilters) {\n        const me = this;\n        let silent = false, internal;\n        if (newFilters) {\n            let fieldType = typeof newFilters;\n            if (fieldType === 'object') {\n                if (('silent' in newFilters) || ('replace' in newFilters) || newFilters.filters) {\n                    silent = newFilters.silent;\n                    if (newFilters.replace) {\n                        // If replacing with empty filters (i.e. clearing filters), clearFilters should trigger a re-filter\n                        me.clearFilters(newFilters.filters.length === 0);\n                    }\n                    internal = newFilters.internal;\n                    newFilters = newFilters.filters;\n                    fieldType = typeof newFilters;\n                }\n            }\n            // If it was just a config object containing no filters, this will be null\n            if (newFilters) {\n                const wasFiltered = me.isFiltered;\n                // We will not be informed about Filter mutations while configuring.\n                me.isConfiguring = true;\n                // If we provide array of objects looking like :\n                //  {\n                //      property  : 'fieldName',\n                //      value     : 'someValue',\n                //      [operator : '>']\n                //  }\n                //  or ...\n                //  {\n                //      property : 'fieldName',\n                //      filterBy : function (value, record) {\n                //          return value > 50;\n                //      }\n                //  }\n                if (Array.isArray(newFilters)) {\n                    newFilters.forEach(f => me.addFilter(f, true), me);\n                }\n                else if (fieldType === 'function') {\n                    const filter = new Filter(newFilters);\n                    filter.internal = internal;\n                    me.addFilter(filter, true);\n                }\n                // Old signature of field name, value with implicit equality test.\n                // Not documented, but still tested.\n                else if (fieldType === 'string') {\n                    me.addFilter({\n                        property : newFilters,\n                        value    : arguments[1]\n                    }, true);\n                }\n                // An object-based filter definition\n                else {\n                    me.addFilter(newFilters, true);\n                }\n                // Open up to receiving Filter mutation notifications again\n                me.isConfiguring = false;\n                // We added a disabled filter to either no filters, or all disabled filters, so no change.\n                if (!me.isFiltered && !wasFiltered) {\n                    return null;\n                }\n            }\n        }\n        // Invalidate the filtersFunction so that it has to be recalculated upon next access\n        me.filtersFunction = null;\n        // Implemented here for local filtering.\n        // AjaxStore implements for remote and returns a Promise, so MUST return the call value.\n        const result = me.performFilter(silent);\n        // Force rebuild of idMap\n        me._idMap = null;\n        return result;\n    }\n    /**\n     * Perform filtering according to the {@link #property-filters} Collection.\n     * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and\n     * must not be overridden.\n     * @private\n     */\n    performFilter(silent) {\n        const\n            me                             = this,\n            { storage, filters, rootNode } = me,\n            oldCount                       = me.count;\n        // Private event, did not need it documented or preventable right now\n        me.trigger('beforeFilter', { filters });\n        let added, removed;\n        if (me.tree) {\n            const oldDataset = storage.values;\n            if (me.isFiltered) {\n                me.traverseFilter(rootNode);\n            }\n            else {\n                me.traverseClearFilter(rootNode);\n            }\n            const newDataset = me.collectDescendants(rootNode).visible;\n            storage.replaceValues({\n                values : newDataset,\n                silent : true\n            });\n            const delta = ArrayHelper.delta(newDataset, oldDataset, true);\n            added   = delta.toAdd;\n            removed = delta.toRemove;\n        }\n        else {\n            // Collect the added and removed deltas from the filter operation\n            storage.ion({\n                change({ removed : r, added : a }) {\n                    removed = r;\n                    added = a;\n                },\n                once : true\n            });\n            if (me.isFiltered) {\n                // Bring collapsed away records in, to be considered in filtering\n                me.isGrouped && me.includeCollapsed();\n                storage.addFilter({\n                    id       : 'primary-filter', \n                    filterBy : me.filtersFunction\n                });\n                // Take them back out again after filtering\n                me.isGrouped && me.excludeCollapsed();\n            }\n            else {\n                storage.filters.clear();\n            }\n        }\n        me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {\n            action  : 'filter',\n            filters,\n            oldCount,\n            added,\n            removed,\n            records : me.storage.values\n        });\n    }\n    afterPerformFilter(event) {\n        this.resetRelationCache();\n        if (event) {\n            this.triggerFilterEvent(event);\n        }\n    }\n    get filtered() {\n        return this.storage.isFiltered;\n    }\n    // Used from filter() and StoreCRUD when reapplying filters\n    triggerFilterEvent(event) {\n        this.trigger('filter', event);\n        // Only fire these events if it's a local filter.\n        // If we are configured with filterParamName, the loadData will fire them.\n        if (!this.remoteFilter) {\n            this.trigger('refresh', event);\n            this.trigger('change', event);\n        }\n    }\n    /**\n     * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to\n     * include record in filtered set\n     *\n     * ```javascript\n     * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));\n     * ```\n     *\n     * @param {Function} fn Function used to test records\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    filterBy(fn) {\n        return this.filter(fn);\n    }\n    /**\n     * Removes the passed filter, or the filter by the passed ID from the {@link #config-filters} collection.\n     * By default, filters are reevaluated and a Store change event fired.\n     *\n     * If the `silent` parameter is passed as `true`, multiple filters can be removed without causing data changes.\n     *\n     * When the filters are as required, call {@link #function-filter} with no parameters\n     * to apply the filters to the store.\n     *\n     * ```javascript\n     * // Only view top priority events\n     * myEventStore.filter({\n     *     id       : 'priorityFilter',\n     *     property : 'priority',\n     *     value    : 1,\n     *     operator : '='\n     * });\n     *\n     * // That individual filter can be removed like this\n     * myEventStore.removeFilter('priorityFilter');\n     *\n     * // Add named filter as a function\n     * store.filter({\n     *     id : 'my filter',\n     *     filterBy : record => record.score > 10\n     * });\n     *\n     * // Remove named filter function\n     * store.removeFilter('my filter');\n     * ```\n     *\n     * @param {String|Core.util.CollectionFilter} idOrInstance Filter to remove, or ID of the filter to remove. By default,\n     * filters are reevaluated and a change event fired.\n     * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when\n     * removing multiple filters.\n     * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method\n     * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    removeFilter(idOrInstance, silent = false) {\n        const\n            me     = this,\n            filter = idOrInstance instanceof Filter ? idOrInstance : me.filters.get(idOrInstance);\n        // If we have such a filter, remove it.\n        if (filter) {\n            me.filters.remove(filter);\n            // Invalidate the filtersFunction so that it has to be recalculated upon next access\n            me._filtersFunction = null;\n            if (!silent) {\n                if (me.remoteFilter) {\n                    return me.filter().then(() => filter);\n                }\n                else {\n                    me.filter();\n                }\n            }\n            return filter;\n        }\n    }\n    /**\n     * Removes all filters from the store.\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    clearFilters(apply = true) {\n        // Remove all non-internal filters (those have to be explicitly removed)\n        this.filters.remove(this.filters.values.filter(f => !f.internal));\n        if (apply) {\n            return this.filter();\n        }\n    }\n    convertFilterToString(field) {\n        const filter = this.filters.getBy('property', field);\n        return (filter && !filter.filterBy) ? String(filter) : '';\n    }\n    doDestroy() {\n        this._filters?.destroy();\n        super.doDestroy();\n    }\n};\n", "import Base from '../../Base.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport StringHelper from '../../helper/StringHelper.js';\n/**\n * @module Core/data/mixin/StoreGroup\n */\nconst resortActions = {\n    add     : 1,\n    replace : 1\n};\n/**\n * An immutable object representing a store grouper.\n *\n * @typedef {Object} Grouper\n * @property {String} field Field name\n * @property {Boolean} [ascending=true] `true` to group ascending, `false` to group descending\n */\n/**\n * Mixin for Store that handles grouping.\n *\n * ```javascript\n * // simple grouper\n * store.group('city');\n *\n * // grouper as object, descending order\n * store.group({ field : 'city', ascending : false });\n *\n * // using custom sorting function\n * store.group({\n *     field : 'city',\n *     fn : (recordA, recordB) => {\n *         // apply custom logic, for example:\n *         return recordA.city.length < recordB.city.length ? -1 : 1;\n *     }\n * });\n * ```\n *\n * Currently grouping is not supported when using pagination, the underlying store cannot group data that is split into pages.\n *\n * @mixin\n */\nexport default Target => class StoreGroup extends (Target || Base) {\n    static get $name() {\n        return 'StoreGroup';\n    }\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * Initial groupers, specify to have store grouped automatically after initially setting data\n             * @config {Grouper[]}\n             * @category Common\n             */\n            groupers : null,\n            useGroupFooters : false,\n            /**\n             * To have all groups __initially loaded__ start collapsed, configure this as `true`.\n             *\n             * Note that this only affects the initial load of the store. Subsequent reloads maintain\n             * current group state where possible.\n             * @config {Boolean}\n             * @default false\n             */\n            startGroupsCollapsed : null\n        };\n    }\n    static get properties() {\n        return {\n            collapsedGroups : new Set()\n        };\n    }\n    //endregion\n    //region Init\n    construct(config) {\n        super.construct(config);\n        // For handling record mutation, *not* add/remove of records.\n        // Sorts dataset if necessary.\n        this.ion({ change : 'onDataChanged', thisObj : this });\n    }\n    /**\n     * Currently used groupers.\n     * To set groupers when remote sorting is enabled by {@link Core/data/AjaxStore#config-sortParamName} you should use\n     * {@link #function-setGroupers} instead to be able wait for operation to finish.\n     * @member {Grouper[]} groupers\n     * @category Sort, group & filter\n     */\n    get groupers() {\n        return this._groupers;\n    }\n    set groupers(groupers) {\n        this.setGroupers(groupers);\n    }\n    /**\n     * Set groupers.\n     * @param {Grouper[]} groupers Array of groupers to apply to store\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns\n     * `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    setGroupers(groupers, options) {\n        const\n            me         = this,\n            { storage } = me;\n        let result;\n        if (groupers?.length) {\n            me._groupers = groupers;\n        }\n        else if (me.groupers) {\n            delete me._groupers;\n            me.includeCollapsed();\n            storage.replaceValues({\n                values         : me.removeHeadersAndFooters(storage._values),\n                filteredValues : storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,\n                silent         : true\n            });\n            result = me.group(null, null, null, false, options?.silent);\n        }\n        // Need to clear the id map so it gets rebuilt next time its accessed\n        me._idMap = null;\n        return result;\n    }\n    // Collects group headers/footers on the fly. Not used in any performance sensitive code, but if that need arises\n    // it should be cached and invalidated on record remove, add, update, grouping changes, filter and sorting...\n    get groupRecords() {\n        const groupRecords = [];\n        if (this.isGrouped) {\n            for (const record of this) {\n                if (record.isSpecialRow) {\n                    groupRecords.push(record);\n                }\n            }\n        }\n        return groupRecords;\n    }\n    get unfilteredGroupRecords() {\n        const me = this;\n        if (me.isGrouped) {\n            const { generation } = me.storage;\n            if (me._unfilteredGroupRecords?.generation !== generation) {\n                me._unfilteredGroupRecords = me.storage.allValues.filter(r => r.isSpecialRow);\n                me._unfilteredGroupRecords.generation = generation;\n            }\n        }\n        return me._unfilteredGroupRecords || [];\n    }\n    /**\n     * Returns group header record for the passed record or last group header in the store\n     * @param {Core.data.Model} [targetRecord]\n     * @param {Boolean} [ignoreFilter] Pass true to search in the complete collection\n     * @returns {Core.data.Model}\n     * @internal\n     */\n    getGroupHeaderForRecord(targetRecord, ignoreFilter = false) {\n        if (this.isGrouped) {\n            let result;\n            const collection = ignoreFilter ? this.storage._values : this.storage.values;\n            for (const record of collection) {\n                if (record.isGroupHeader) {\n                    if (!targetRecord) {\n                        result = record;\n                    }\n                    else if (record === targetRecord || record.unfilteredGroupChildren.includes(targetRecord)) {\n                        result = record;\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    // Temporarily include records from collapsed groups, for example prior to filtering\n    includeCollapsed() {\n        for (const groupId of this.collapsedGroups) {\n            this.expand(this.getById(groupId), false);\n        }\n    }\n    // Exclude records in collapsed groups, intended to be used after a call to includeCollapsed()\n    excludeCollapsed() {\n        for (const groupId of this.collapsedGroups) {\n            this.collapse(this.getById(groupId));\n        }\n    }\n    onDataChange({ source : storage, action, removed }) {\n        const\n            me           = this,\n            { groupers } = me;\n        // Only do grouping transformations if we have groupers to apply.\n        // In stores which never use grouping, this code is superfluous and will reduce performance.\n        // The else side will simply replace the ungrouped data with itself.\n        if (groupers) {\n            // When records are added or removed, re-evaluate the group records\n            // so that when the events are fired by the super call, the group\n            // records are in place.\n            if (groupers.length) {\n                if ((action === 'splice' && removed?.length) || action === 'move') {\n                    storage.replaceValues({\n                        ...me.prepareGroupRecords(),\n                        silent : true\n                    });\n                }\n            }\n            // Remove all group headers and footers\n            else {\n                storage.replaceValues({\n                    values         : me.removeHeadersAndFooters(storage._values),\n                    filteredValues : storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,\n                    silent         : true\n                });\n            }\n        }\n        super.onDataChange?.(...arguments);\n    }\n    move(records, beforeRecord) {\n        const me = this;\n        if (me.isGrouped && !me.tree) {\n            let prevRecord = beforeRecord;\n            if (beforeRecord?.isSpecialRow) {\n                prevRecord = me.getPrev(beforeRecord, false, false);\n                if (!prevRecord) {\n                    // Trying to move above first group header, no-op\n                    return;\n                }\n            }\n            // Target group header always exists\n            const\n                targetGroupHeader         = me.getGroupHeaderForRecord(prevRecord),\n                groupField                = me.groupers[0].field,\n                newGroupValue             = targetGroupHeader.meta.groupRowFor,\n                { reapplyFilterOnUpdate } = me;\n            // Disable reapply filter on update because it will rebuild groups faster than we need. Groups will be\n            // updated in super.move call anyway\n            me.reapplyFilterOnUpdate = false;\n            me.beginBatch();\n            records.forEach(record => record[groupField] = newGroupValue);\n            me.endBatch();\n            me.reapplyFilterOnUpdate = reapplyFilterOnUpdate;\n            // If store is filtered, we might have hidden groups between target group header and `beforeRecord`. To\n            // make move safe we need to find new target group (visible) and find next group in the unfiltered\n            // collection. But only if `beforeRecord is a group header\n            if (me.isFiltered && beforeRecord?.isSpecialRow) {\n                const\n                    { unfilteredGroupRecords } = me,\n                    // Find index of the group header we're moving record into\n                    index = unfilteredGroupRecords.indexOf(targetGroupHeader);\n                // If `beforeRecord` exists, index cannot point to the last group in the store, meaning we can\n                // safely access element at index + 1\n                beforeRecord = unfilteredGroupRecords[index + 1];\n            }\n        }\n        super.move(records, beforeRecord);\n    }\n    collapse(groupRecord) {\n        if (groupRecord && !groupRecord.meta.collapsed) {\n            this.excludeGroupRecords(groupRecord);\n            groupRecord.meta.collapsed = true;\n            // Track which groups are collapsed\n            this.collapsedGroups.add(groupRecord.id);\n            return true;\n        }\n        return false;\n    }\n    expand(groupRecord, updateMap = true) {\n        if (groupRecord?.meta.collapsed) {\n            this.includeGroupRecords(groupRecord);\n            groupRecord.meta.collapsed = false;\n            // Optionally track which groups are collapsed (not done when expanding temporarily prior to filtering etc)\n            updateMap && this.collapsedGroups.delete(groupRecord.id);\n            return true;\n        }\n        return false;\n    }\n    removeHeadersAndFooters(records) {\n        return records.filter(r => {\n            if (r.isSpecialRow) {\n                this.unregister(r);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    prepareGroupRecords(sorter) {\n        const\n            me                = this,\n            {\n                isFiltered,\n                reapplyFilterOnUpdate,\n                startGroupsCollapsed\n            }                 = me,\n            toCollapse        = me.collapsedGroups,\n            { allValues }     = me.storage,\n            toExpand          = [],\n            // this property is set by StoreChanges mixin to keep in view records which were visible prior to\n            // `applyChangeset` call but after update no longer match the filter\n            visibleRecordsIds = me._groupVisibleRecordIds || [],\n            isVisible         = (record) => {\n                const matchesFilter = !isFiltered || me.filtersFunction(record);\n                return reapplyFilterOnUpdate ? matchesFilter : (matchesFilter || visibleRecordsIds.includes(record.id));\n            };\n        for (const record of allValues) {\n            if (record.isGroupHeader && (record.meta.collapsed || toCollapse.has(record.id))) {\n                toCollapse.add(record.id);\n                toExpand.push(record);\n            }\n        }\n        for (const record of toExpand) {\n            me.includeGroupRecords(record);\n        }\n        const records = me.removeHeadersAndFooters(me.storage._values);\n        if (sorter) {\n            records.sort(sorter);\n        }\n        // Update filters function\n        if (isFiltered) {\n            me.filtersFunction = null;\n        }\n        const\n            groupedRecords = [],\n            field          = me.groupers[0].field;\n        let curGroup       = null,\n            curGroupRecord = null,\n            childCount     = 0;\n        function addFooter() {\n            const\n                val    = curGroupRecord.meta.groupRowFor,\n                id     = `group-footer-${typeof val === 'number' ? val : StringHelper.createId(val)}`,\n                footer = me.getById(id) || new me.modelClass({ id }, me, {\n                    specialRow     : true,\n                    groupFooterFor : val,\n                    groupRecord    : curGroupRecord\n                });\n            // Used by indexOf to determine if part of store\n            footer.stores = [me];\n            me.register(footer);\n            footer.groupChildren = curGroupRecord.groupChildren;\n            if (!curGroupRecord.meta.collapsed) {\n                groupedRecords.push(footer);\n            }\n            me.allRecords.push(footer);\n            curGroupRecord.groupChildren.push(footer);\n            curGroupRecord.unfilteredGroupChildren.push(footer);\n            childCount++;\n            return footer;\n        }\n        records.forEach(record => {\n            const\n                val = record[field] == undefined ? '__novalue__' : record[field],\n                id  = `group-header-${typeof val === 'number' ? val : StringHelper.createId(val)}`;\n            // A group header or footer record of an empty group.\n            // Remove from the data\n            if (record.unfilteredGroupChildren?.length === 0) {\n                me.unregister(record);\n                return;\n            }\n            if (!ObjectHelper.isEqual(val, curGroup)) {\n                if (curGroupRecord) {\n                    // also add group footer? used by GroupSummary feature\n                    if (me.useGroupFooters) {\n                        addFooter(curGroupRecord);\n                    }\n                    curGroupRecord.meta.childCount = childCount;\n                }\n                curGroupRecord = me.getById(id);\n                if (!curGroupRecord) {\n                    curGroupRecord =  new me.modelClass({ id }, me, {\n                        specialRow  : true,\n                        groupRowFor : val,\n                        groupField  : field\n                    });\n                    // New groups start life collapsed\n                    if (startGroupsCollapsed) {\n                        toCollapse.add(id);\n                        // It only works the first time groups are created.\n                        me.startGroupsCollapsed = false;\n                    }\n                }\n                curGroupRecord.meta.collapsed = toCollapse.has(id);\n                // Used by indexOf to determine if part of store\n                curGroupRecord.stores = [me];\n                me.register(curGroupRecord);\n                curGroupRecord.groupChildren = [];\n                curGroupRecord.unfilteredGroupChildren = [];\n                groupedRecords.push(curGroupRecord);\n                me.allRecords.push(curGroupRecord);\n                curGroup = val;\n                childCount = 0;\n            }\n            record.instanceMeta(me.id).groupParent = curGroupRecord;\n            // Collapse groups that was collapsed earlier\n            if (!toCollapse.has(id)) {\n                groupedRecords.push(record);\n            }\n            if (isVisible(record)) {\n                curGroupRecord.groupChildren.push(record);\n                childCount++;\n            }\n            curGroupRecord.unfilteredGroupChildren.push(record);\n        });\n        // misses for last group without this\n        if (curGroupRecord) {\n            // footer for last group\n            if (me.useGroupFooters) {\n                addFooter();\n            }\n            curGroupRecord.meta.childCount = childCount;\n        }\n        me._idMap = null;\n        const result = {\n            values : groupedRecords\n        };\n        if (isFiltered) {\n            result.filteredValues = groupedRecords.filter(isVisible);\n        }\n        return result;\n    }\n    //endregion\n    //region Group and ungroup\n    /**\n     * Is store currently grouped?\n     * @property {Boolean}\n     * @readonly\n     * @category Sort, group & filter\n     */\n    get isGrouped() {\n        return Boolean(this.groupers?.length);\n    }\n    /**\n     * Group records, either by replacing current sorters or by adding to them.\n     * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).\n     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores\n     * normal sorting routine. Grouped store **must** always be sorted by the same field.\n     *\n     * ```javascript\n     * // simple grouper\n     * store.group('city');\n     *\n     * // grouper as object, descending order\n     * store.group({ field : 'city', ascending : false });\n     *\n     * // using custom sorting function\n     * store.group({\n     *     field : 'city',\n     *     fn : (recordA, recordB) => {\n     *         // apply custom logic, for example:\n     *         return recordA.city.length < recordB.city.length ? -1 : 1;\n     *     }\n     * });\n     * ```\n     *\n     * @param {String|Object} field Field to group by.\n     * Can also be a config containing a field to group by and a custom sorting function called `fn`.\n     * @param {Boolean} [ascending] Sort order of the group titles\n     * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)\n     * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping\n     * @param {Boolean} [silent] Set as true to not fire events\n     * @category Sort, group & filter\n     * @fires group\n     * @fires refresh\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     */\n    group(field, ascending, add = false, performSort = true, silent = false) {\n        const me = this;\n        let newGrouper, fn;\n        if (field && typeof field === 'object') {\n            ascending = field.ascending;\n            fn        = field.fn;\n            field     = field.field;\n        }\n        if (add) {\n            me.groupers.push(newGrouper = {\n                field,\n                ascending,\n                complexMapping : field.includes('.')\n            });\n        }\n        else if (field) {\n            if (ascending == null) {\n                ascending = me.groupInfo?.field === field && me.groupInfo?.fn === fn ? !me.groupInfo.ascending : true;\n            }\n            me.groupInfo = newGrouper = {\n                field,\n                ascending,\n                fn,\n                complexMapping : field.includes('.')\n            };\n            me.groupers = [me.groupInfo];\n        }\n        if (newGrouper) {\n            const { prototype } = me.modelClass;\n            // Create a getter for complex field names like \"get resource.city\"\n            if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype, field)) {\n                Object.defineProperty(prototype, field, {\n                    get() {\n                        return ObjectHelper.getPath(this, field);\n                    }\n                });\n            }\n        }\n        // as far as the store is concerned, grouping is just more sorting. so trigger sort\n        if (performSort !== false) {\n            if (me.remoteSort && !me.isRemoteDataLoading) {\n                return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));\n            }\n            else {\n                me.sort(null, null, false, true);\n            }\n        }\n        me.onAfterGrouping(silent);\n    }\n    onAfterGrouping(silent) {\n        if (silent) {\n            return;\n        }\n        const\n            me = this,\n            groupers = me.groupers || [];\n        /**\n         * Fired when grouping changes\n         * @event group\n         * @param {Core.data.Store} source This Store\n         * @param {Grouper[]} groupers Applied groupers\n         * @param {Core.data.Model[]} records Grouped records\n         */\n        me.trigger('group', { isGrouped : me.isGrouped, groupers, records : me.storage.values });\n        me.trigger('refresh', { action : 'group', isGrouped : me.isGrouped, groupers, records : me.storage.values });\n    }\n    // Internal since UI does not support multi grouping yet\n    /**\n     * Add a grouping level (a grouper).\n     * @param {String} field Field to group by\n     * @param {Boolean} ascending Group direction\n     * @category Sort, group & filter\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @internal\n     */\n    addGrouper(field, ascending = true) {\n        return this.group(field, ascending, true);\n    }\n    // Internal since UI does not support multi grouping yet\n    /**\n     * Removes a grouping level (a grouper)\n     * @param {String} field Grouper to remove\n     * @category Sort, group & filter\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @internal\n     */\n    removeGrouper(field) {\n        const\n            me           = this,\n            { groupers } = me;\n        if (!groupers) {\n            return;\n        }\n        const index = groupers.findIndex(grouper => grouper.field === field);\n        if (index > -1) {\n            groupers.splice(index, 1);\n            if (!groupers.length) {\n                return me.clearGroupers();\n            }\n            else {\n                return me.group();\n            }\n        }\n    }\n    /**\n     * Removes all groupers, turning store grouping off.\n     * @privateparam {Boolean} [silent=false] Pass true to suppress events.\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    clearGroupers(silent = false) {\n        return this.setGroupers(null, { silent });\n    }\n    //endregion\n    //region Get and check\n    /**\n     * Check if a record belongs to a certain group (only for the first grouping level)\n     * @param {Core.data.Model} record The Record\n     * @param {*} groupValue The group value\n     * @returns {Boolean} True if the record belongs to the group, otherwise false\n     * @category Sort, group & filter\n     */\n    isRecordInGroup(record, groupValue) {\n        if (!this.isGrouped) {\n            return null;\n        }\n        const groupField = this.groupers[0]?.field;\n        return record[groupField] === groupValue && !record.isSpecialRow;\n    }\n    isInCollapsedGroup(record) {\n        const parentGroupRec = record.instanceMeta(this).groupParent;\n        return parentGroupRec?.meta.collapsed;\n    }\n    /**\n     * Returns all records in the group with specified groupValue.\n     * @param {*} groupValue\n     * @returns {Core.data.Model[]} Records in specified group or null if store not grouped\n     * @category Sort, group & filter\n     */\n    getGroupRecords(groupValue) {\n        if (!this.isGrouped) {\n            return null;\n        }\n        return this.storage.values.filter(record => this.isRecordInGroup(record, groupValue));\n    }\n    /**\n     * Get all group titles.\n     * @returns {String[]} Group titles\n     * @category Sort, group & filter\n     */\n    getGroupTitles() {\n        if (!this.isGrouped) {\n            return null;\n        }\n        return this.getDistinctValues(this.groupers[0].field);\n    }\n    //endregion\n    onDataChanged({ changes, action }) {\n        if (\n            this.isGrouped && (\n                // If an action flagged as requiring resort is performed...\n                (!changes && resortActions[action]) ||\n                // ...or if the group field has changes...\n                (changes && this.groupers.some(grouper => grouper.field in changes))\n            )\n        ) {\n            // ...then re-sort\n            this.sort();\n        }\n    }\n    /**\n     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.\n     * @private\n     * @param {Core.data.Model} groupRecord Group which records should be added or removed\n     * @param {Boolean} include Include (true) or exclude (false) records\n     * @category Grouping\n     */\n    internalIncludeExcludeGroupRecords(groupRecord, include) {\n        const\n            me                      = this,\n            index                   = me.indexOf(groupRecord),\n            allIndex                = me.allIndexOf(groupRecord),\n            { id : mapId, storage } = me,\n            {\n                _filteredValues,\n                _values\n            }                       = storage,\n            {\n                meta,\n                groupChildren,\n                unfilteredGroupChildren\n            }                       = groupRecord;\n        // Skip if group record is not found, otherwise it removes records from wrong position.\n        // Also prevent removing from already collapsed and vice versa\n        if (allIndex === -1 || (meta.collapsed && !include) || (!meta.collapsed && include)) {\n            return;\n        }\n        unfilteredGroupChildren.forEach(child =>\n            child.instanceMeta(mapId).hiddenByCollapse = !include\n        );\n        if (include) {\n            // Avoid adding record duplicates which may already have been reinserted by clearing filters\n            if (_filteredValues) {\n                _filteredValues.splice(index + 1, 0, ...groupChildren.filter(r => !me.isAvailable(r)));\n            }\n            storage._values.splice(allIndex + 1, 0, ...unfilteredGroupChildren.filter(r => !me.isAvailable(r)));\n        }\n        else {\n            if (_filteredValues) {\n                _filteredValues.splice(index + 1, groupChildren.length);\n            }\n            _values.splice(allIndex + 1, unfilteredGroupChildren.length);\n        }\n        storage._indicesInvalid = true;\n        me._idMap = null;\n    }\n    /**\n     * Removes records in a group from storage. Used when collapsing a group.\n     * @private\n     * @param groupRecord Group which records should be removed\n     * @category Grouping\n     */\n    excludeGroupRecords(groupRecord) {\n        this.internalIncludeExcludeGroupRecords(groupRecord, false);\n    }\n    /**\n     * Adds records in a group to storage. Used when expanding a group.\n     * @private\n     * @param groupRecord Group which records should be added\n     * @category Grouping\n     */\n    includeGroupRecords(groupRecord) {\n        this.internalIncludeExcludeGroupRecords(groupRecord, true);\n    }\n    /**\n     * Collects all group headers + children, whether expanded or not\n     * @private\n     * @param {Boolean} allRecords True to include filtered out records\n     * @param {Boolean} includeHeaders True to also include group headers\n     * @returns {Core.data.Model[]}\n     */\n    collectGroupRecords(allRecords, includeHeaders = true) {\n        const records = allRecords ? this.storage.allValues : this.storage.values;\n        return records.reduce((records, record) => {\n            if (record.isSpecialRow) {\n                if (includeHeaders && !record.isGroupFooter) {\n                    records.push(record);\n                }\n                if (record.isGroupHeader) {\n                    records.push.apply(records, record.groupChildren);\n                }\n            }\n            return records;\n        }, []);\n    }\n};\n", "import Base from '../../Base.js';\nimport StringHelper from '../../helper/StringHelper.js';\n/**\n * @module Core/data/mixin/StoreProxy\n */\n/**\n * Object-like interaction with a Store by using a Proxy. To enable, configure the store with `objectify : true`.\n *\n * ```javascript\n * const store = new Store({\n *    objectify : true,\n *    data      : [\n *        { id : 'batman', name : 'Bruce' }\n *    ]\n * });\n * ```\n *\n * Access records using their ids as Store properties:\n * ```javascript\n * console.log(store.batman.name); // logs Bruce\n * ```\n *\n * Add records by assigning properties to the Store:\n * ```javascript\n * store.superman = { name : 'Clark' }; // Id will be 'superman'\n * ```\n *\n * Remove records by removing their property:\n * ```javascript\n * delete store.batman;\n * ```\n *\n * Check if a certain id existing in the store by using `in`:\n * ```javascript\n * console.log('superman' in store): // logs true\n * ```\n *\n * Please note that this approach:\n * * Will affect performance slightly, not recommended for larger datasets.\n * * Uses native Proxy.\n * * Preserves predefined Store properties, records cannot use ids that match those.\n * * Might have other limitations preventing the use of it in some scenarios where a normal Store can be used.\n *\n * @mixin\n */\nexport default Target => class StoreProxy extends (Target || Base) {\n    static get configurable() {\n        return {\n            /**\n             * Allow object like interaction with the Store. For example:\n             *\n             * ```javascript\n             * const store = new Store({\n             *    objectify : true,\n             *    data      : [\n             *        { id : 'batman', name : 'Bruce' }\n             *    ]\n             * });\n             *\n             * // retrieve using id as property\n             * const record = store.batman;\n             *\n             * // add as property\n             * store.superman = { name : 'Clark' };\n             *\n             * // delete to remove\n             * delete store.batman;\n             * ``\n             *\n             * @config {Boolean}\n             * @default false\n             */\n            objectify : null\n        };\n    }\n    initProxy() {\n        if (!globalThis.Proxy) {\n            throw new Error('Proxy not supported');\n        }\n        const proxy = new Proxy(this, {\n            // Support getting records using `store[id/index]\n            get(target, property) {\n                // Stores own properties take precedence\n                if (property in target) {\n                    return target[property];\n                }\n                // To allow accessing the underlying store\n                if (property === '$store') {\n                    return target;\n                }\n                // Then ids\n                let record = target.getById(property);\n                // And finally index\n                if (!record && !isNaN(parseInt(property))) {\n                    record = target.getAt(parseInt(property));\n                }\n                return record;\n            },\n            // Support adding/replacing records using `store.id = { ...data }`\n            set(target, property, value) {\n                // Pass through when using names of existing properties or when destroyed/ing\n                if (property in target || target.isDestroying) {\n                    target[property] = value;\n                }\n                // Otherwise add/replace a record\n                else {\n                    target.add({ [target.modelClass.idField] : property, ...value });\n                }\n                return true;\n            },\n            // Support deleting records using `delete store.id`\n            deleteProperty(target, property) {\n                // Properties are deleted on destroy\n                if (target.isDestroying) {\n                    delete target[property];\n                    return true;\n                }\n                return Boolean(target.remove(property).length);\n            },\n            // Support `id in store`\n            has(target, property) {\n                // Actual property\n                if (property in target) {\n                    return true;\n                }\n                // Threat { ... } as JSON representation of a record (likely from toString())\n                if (property.startsWith('{') && property.endsWith('}')) {\n                    const data = StringHelper.safeJsonParse(property);\n                    property = data?.id;\n                }\n                return target.includes(property);\n            }\n        });\n        return proxy;\n    }\n};\n", "import Base from '../../Base.js';\nimport ArrayHelper from '../../helper/ArrayHelper.js';\nimport StringHelper from '../../helper/StringHelper.js';\nimport Model from '../Model.js';\n/**\n * @module Core/data/mixin/StoreRelation\n */\n/**\n * Mixin for Store that handles relations with other stores.\n *\n * The relation is defined in a Model subclass, see Model's {@link Core/data/Model#property-relations-static} property\n * for more information.\n *\n * @mixin\n */\nexport default Target => class StoreRelation extends (Target || Base) {\n    static $name = 'StoreRelation';\n    //region Init\n    /**\n     * Initialized relations, called from constructor\n     * @private\n     */\n    initRelations(reset) {\n        const\n            me        = this,\n            relations = me.modelClass.exposedRelations;\n        if (reset && me.modelRelations) {\n            // reset will reinit all relations, stop listening for store events on existing ones\n            me.modelRelations.forEach(relation => relation.storeDetacher?.());\n        }\n        if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {\n            me.modelRelations = [];\n            // foreignKeys is filled when model exposes its properties\n            relations?.forEach(modelRelationConfig => {\n                const\n                    config       = { ...modelRelationConfig },\n                    {\n                        foreignStore,\n                        relationName,\n                        relatedCollectionName\n                    }            = config,\n                    relatedStore = typeof foreignStore === 'string' ? me[foreignStore] : foreignStore;\n                config.dependentStore = me;\n                me.modelRelations.push(config);\n                if (relatedStore) {\n                    config.foreignStoreProperty = config.foreignStore;\n                    config.foreignStore = relatedStore; // repeated from initRelationStores, needed if stored is assigned late\n                    const dependentStoreConfigs = relatedStore.dependentStoreConfigs;\n                    // Add link to dependent store\n                    if (dependentStoreConfigs.has(me)) {\n                        const dependentConfigs = dependentStoreConfigs.get(me);\n                        // Remove existing config on reset\n                        if (reset) {\n                            const existingConfig = dependentConfigs.find(c => c.relationName === relationName);\n                            if (existingConfig) {\n                                ArrayHelper.remove(dependentConfigs, existingConfig);\n                            }\n                        }\n                        dependentConfigs.push(config);\n                    }\n                    else {\n                        dependentStoreConfigs.set(me, [config]);\n                    }\n                    // if foreign key specifies relatedCollectionName the related store should also be configured\n                    if (relatedCollectionName) {\n                        relatedStore.initRelationCollection(config, me);\n                    }\n                    if (relatedStore.count > 0) {\n                        relatedStore.updateDependentStores('dataset', relatedStore.records);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Called from other end of an relation when this store should hold a collection of related records.\n     * @private\n     * @param config\n     * @param collectionStore\n     */\n    initRelationCollection(config, collectionStore) {\n        const\n            me               = this,\n            name             = config.relatedCollectionName,\n            collectionStores = me.collectionStores || (me.collectionStores = {});\n        collectionStores[name] = {\n            store : collectionStore,\n            config\n        };\n        if (!me[name + 'Store']) {\n            me[name + 'Store'] = collectionStore;\n        }\n        if (me.count > 0) {\n            me.initModelRelationCollection(name, me.records);\n        }\n    }\n    initModelRelationCollection(name, records) {\n        const me = this;\n        // add collection getter to each model\n        records.forEach(record => {\n            // Needs to work in trees also, if not a tree traverse just calls fn on self\n            record.traverse(node => {\n                // Add/replace $relatedAssignments (or similar) if assignments already exists on target\n                const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;\n                Object.defineProperty(node, useName, {\n                    enumerable   : true,\n                    configurable : true,\n                    get          : function() {\n                        return me.getCollection(this, name);\n                    },\n                    set : function(value) {\n                        return me.setCollection(this, name, value);\n                    }\n                });\n            });\n        });\n    }\n    /**\n     * Updates relationCache for all records.\n     * @private\n     */\n    resetRelationCache() {\n        this.relationCache = {};\n        this.forEach(record => record.initRelations());\n    }\n    /**\n     * Caches related records from related store on the local store.\n     * @private\n     * @param record Local record\n     * @param relations Relations to related store\n     */\n    updateRecordRelationCache(record, relations) {\n        relations?.forEach(relation => {\n            const\n                { config } = relation,\n                // use related records id, or if called before \"binding\" is complete use foreign key\n                foreignId = relation.related ? relation.related.id : record.get(config.foreignKey);\n            // cache on that id, removing previously cached value if any\n            foreignId !== undefined && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);\n        });\n    }\n    //endregion\n    //region Getters\n    /**\n     * Returns records the relation cache. Same result as if retrieving the collection on the dependent store, but\n     * without the need of accessing that store.\n     * @internal\n     * @param {String} name\n     * @param {Core.data.Model|String|Number} recordOrId\n     * @returns {Array}\n     */\n    getRelationCollection(name, recordOrId) {\n        const id = Model.asId(recordOrId);\n        return (this.relationCache[name] && this.relationCache[name][id]) || [];\n    }\n    /**\n     * Returns records from a collection of related records. Not to be called directly, called from Model getter.\n     * @private\n     * @param {Core.data.Model} record\n     * @param {String} name\n     * @returns {Array}\n     */\n    getCollection(record, name) {\n        const { config, store } = this.collectionStores[name];\n        return (store.relationCache[config.relationName] && store.relationCache[config.relationName][record.id]) || [];\n    }\n    /**\n     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called\n     * directly, called from Model setter.\n     * @private\n     */\n    setCollection(model, name, records) {\n        const\n            { config, store } = this.collectionStores[name],\n            relationCache     = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}),\n            old               = (relationCache[model.id] || []).slice(),\n            added             = [],\n            removed           = [];\n        store.suspendEvents();\n        // Remove any related records not in the new collection\n        old.forEach(record => {\n            if (!records.includes(record)) {\n                record[config.foreignKey] = null;\n                store.remove(record);\n                removed.push(record);\n            }\n        });\n        // Add records from the new collection not already in store\n        records.forEach(record => {\n            if (record.isModel instanceof Model) {\n                if (!record.stores.includes(store)) {\n                    store.add(record);\n                    added.push(record);\n                }\n            }\n            else {\n                [record] = store.add(record);\n                added.push(record);\n            }\n            // Init relation\n            record[config.foreignKey] = model.id;\n        });\n        store.resumeEvents();\n        if (removed.length) {\n            store.trigger('remove', { records : removed });\n            store.trigger('change', { action : 'remove', records : removed });\n        }\n        if (added.length) {\n            store.trigger('add', { records : added });\n            store.trigger('change', { action : 'add', records : added });\n        }\n    }\n    //endregion\n    //region Caching\n    /**\n     * Adds a record to relation cache, optionally removing it if already there.\n     * @private\n     * @param record\n     * @param id\n     * @param name\n     * @param uncacheId\n     */\n    cacheRelatedRecord(record, id, name, uncacheId = null) {\n        const\n            me    = this,\n            cache = me.relationCache[name] || (me.relationCache[name] = {});\n        if (uncacheId !== null) {\n            me.uncacheRelatedRecord(record, name, uncacheId);\n        }\n        if (id != null) {\n            // Only include of not already in relation cache, which might happen when removing and re-adding the same instance\n            ArrayHelper.include(cache[id] || (cache[id] = []), record);\n        }\n    }\n    /**\n     * Removes a record from relation cache, for a specific relation (specify relation name and id) or for all relations\n     * @private\n     * @param record Record to remove from cache\n     * @param name Optional, relation name\n     * @param id Optional, id\n     */\n    uncacheRelatedRecord(record, name = null, id = null) {\n        const me = this;\n        function remove(relationName, relatedId) {\n            const\n                cache    = me.relationCache[relationName],\n                oldCache = cache?.[relatedId];\n            // When unjoining a record from a filtered store the relationCache will also be filtered\n            // and might give us nothing, in which case we have nothing to clean up and bail out\n            if (oldCache) {\n                const uncacheIndex = oldCache.indexOf(record);\n                uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);\n                if (oldCache.length === 0) {\n                    delete cache[relatedId];\n                }\n            }\n        }\n        if (id != null) {\n            remove(name, id);\n        }\n        else {\n            if (record.meta.relationCache) {\n                Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) =>\n                    remove(relationName, relatedRecord?.id)\n                );\n            }\n        }\n    }\n    /**\n     * Updates related stores when store is cleared, a record is removed or added.\n     * @private\n     * @param {String} action\n     * @param {Core.data.Model[]} records\n     */\n    updateDependentStores(action, records) {\n        this.dependentStoreConfigs.forEach(configs => {\n            configs.forEach(config => {\n                const\n                    {\n                        dependentStore,\n                        relatedCollectionName,\n                        relationName,\n                        foreignKey\n                    }     = config,\n                    cache = dependentStore.relationCache[relationName];\n                if (action === 'dataset') {\n                    relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);\n                    dependentStore.forEach(record => {\n                        const foreign = record.initRelation(config);\n                        foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);\n                    });\n                    return;\n                }\n                if (action === 'removeall') {\n                    dependentStore.forEach(record => record.removeRelation(config));\n                    delete dependentStore.relationCache[relationName];\n                    return;\n                }\n                if (action === 'add') {\n                    relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);\n                }\n                if (action === 'add' || action === 'remove') {\n                    records.forEach(record => {\n                        const dependentRecords = cache?.[record.id];\n                        switch (action) {\n                            case 'remove':\n                                // removing related record removes from cache on model and store\n                                if (dependentRecords) {\n                                    dependentRecords.forEach(dependentRecord => dependentRecord.removeRelation(config));\n                                    // Altered to not delete on self, simplifies taking actions on related records after remove if relation still lives\n                                    //delete cache[relatedRecord.id];\n                                }\n                                break;\n                            case 'add':\n                                // adding a new record in related store checks if any foreign keys match the new id,\n                                // and if so it sets up the relation\n                                dependentStore.forEach(dependentRecord => {\n                                    if (dependentRecord.get(foreignKey) == record.id) {\n                                        dependentRecord.initRelation(config);\n                                        dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);\n                                    }\n                                });\n                                break;\n                        }\n                    });\n                }\n            });\n        });\n    }\n    /**\n     * Updates relation cache and foreign key value when a related objects id is changed.\n     * @private\n     */\n    updateDependentRecordIds(oldValue, value) {\n        this.dependentStoreConfigs?.forEach(configs => {\n            configs.forEach(config => {\n                const\n                    {\n                        dependentStore,\n                        relationName,\n                        foreignKey\n                    }            = config,\n                    cache        = dependentStore.relationCache[relationName],\n                    localRecords = cache?.[oldValue]?.slice();\n                localRecords?.forEach(localRecord => {\n                    // First update cache\n                    dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);\n                    // Then update & announce, otherwise relations won't be up-to-date in listeners\n                    localRecord.set(foreignKey, value, false, true);\n                });\n            });\n        });\n    }\n    //endregion\n};\n", "import Base from '../../Base.js';\n/**\n * @module Core/data/mixin/StoreSum\n */\n/**\n * Mixin for Store that handles summaries.\n *\n * @mixin\n */\nexport default Target => class StoreSum extends (Target || Base) {\n    static get $name() {\n        return 'StoreSum';\n    }\n    /**\n     * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records\n     * in store\n     * @param {String} field Field to summarize by\n     * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.\n     * @returns {Number}\n     * @category Sum\n     */\n    sum(field, records = this.storage.values) {\n        if (!records) return 0;\n        return records.reduce((sum, record) => {\n            if (record.isSpecialRow) return sum;\n            const v = Number(record[field]);\n            return isNaN(v) ? sum : sum + v;\n        }, 0);\n    }\n    /**\n     * Returns min value for the specified field, can be used with Date or Number values. Defaults to look through all records in store\n     * @param {String} field Field to find min value for\n     * @param {Core.data.Model[]} records Records to process, uses all records if unspecified\n     * @returns {Number|Date}\n     * @category Sum\n     */\n    min(field, records = this.storage.values) {\n        if (!records || !records.length) return 0;\n        return records.reduce((min, record) => {\n            const type = typeof record[field]?.valueOf();\n            if (type === 'number' && record[field] < min) min = record[field];\n            return min;\n        }, records[0][field]);\n    }\n    /**\n     * Returns max value for the specified field, can be used with Date or Number values. Defaults to look through all records in store\n     * @param {String} field Field to find max value for\n     * @param {Core.data.Model[]} records Records to process, uses all records if unspecified\n     * @returns {Number|Date}\n     * @category Sum\n     */\n    max(field, records = this.storage.values) {\n        if (!records || !records.length) return 0;\n        return records.reduce((max, record) => {\n            const type = typeof record[field]?.valueOf();\n            if (type === 'number' && record[field] > max) max = record[field];\n            return max;\n        }, records[0][field]);\n    }\n    /**\n     * Returns the average value for the specified field. Defaults to look through all records in store\n     * @param {String} field Field to calculate average value for\n     * @param {Core.data.Model[]} records Records to process, uses all records if unspecified\n     * @returns {Number}\n     * @category Sum\n     */\n    average(field, records = this.storage.values) {\n        if (!records || !records.length) return 0;\n        let count = 0;\n        const sum = records.reduce((sum, record) => {\n            if (record.isSpecialRow) return sum;\n            const v = parseFloat(record[field]);\n            if (!isNaN(v)) {\n                count++;\n                return sum + v;\n            }\n            else {\n                return sum;\n            }\n        }, 0);\n        return count > 0 ? sum / count : 0;\n    }\n    /**\n     * Returns sum by adding value of specified field for records in the group with the specified groupValue.\n     * @param {*} groupValue The group to summarize\n     * @param {String} field Field to summarize by\n     * @returns {Number} Sum or null if store not grouped\n     * @category Sum\n     */\n    groupSum(groupValue, field) {\n        return this.sum(field, this.getGroupRecords(groupValue));\n    }\n};\n", "import Base from '../../Base.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\n/**\n * @module Core/data/mixin/StoreSearch\n */\nconst\n    findInString = (value, text) => String(value).toLowerCase().includes(text),\n    matchFns     = {\n        string  : findInString,\n        number  : findInString,\n        boolean : findInString,\n        date    : (value, text) => {\n            if (value instanceof Date && text instanceof Date) {\n                return value - text === 0;\n            }\n            return String(value.getMonth() + 1).includes(text) ||\n                String(value.getDate()).includes(text) ||\n                String(value.getFullYear()).includes(text);\n        },\n        object    : (value, text) => value === text, // typeof null === object\n        undefined : (value, text) => value === text\n    };\n/**\n * Format returned by Store#findByField().\n * @typedef {Object} StoreSearchResult\n * @property {Number} index Index of the record in the store\n * @property {Core.data.Model} data The record\n */\n/**\n * Mixin for Store that handles searching (multiple records) and finding (single record).\n *\n * @example\n * // find all records that has a field containing the string john\n * let hits = store.search('john');\n *\n * @mixin\n */\nexport default Target => class StoreSearch extends (Target || Base) {\n    static get $name() {\n        return 'StoreSearch';\n    }\n    //region Search (multiple hits)\n    /**\n     * Find all hits matching the specified input\n     * @param {String} text Value to search for\n     * @param {String[]} fields Fields to search value in\n     * @param {Function[]} [formatters] An array of field formatting functions to format the found value\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching\n     * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }\n     * @category Search\n     */\n    search(text, fields = null, formatters, searchAllRecords) {\n        const\n            records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords),\n            len     = records.length,\n            found   = [];\n        if (text == null) {\n            return [];\n        }\n        if (typeof text === 'string') {\n            text = text.toLowerCase();\n        }\n        let i,\n            j,\n            record,\n            value,\n            valueType,\n            comparison;\n        for (i = 0; i < len; i++) {\n            record = records[i];\n            j      = 0;\n            for (const key of fields || record.fieldNames) {\n                value     = record[key];\n                valueType = (value instanceof Date) ? 'date' : typeof value;\n                const formatter = formatters?.[j];\n                if (formatter) {\n                    value     = formatter(value);\n                    valueType = 'string';\n                }\n                comparison = matchFns[valueType];\n                if (value && comparison?.(value, text)) {\n                    found.push({\n                        index : i,\n                        data  : record,\n                        field : key,\n                        id    : record.id\n                    });\n                }\n                j++;\n            }\n        }\n        return found;\n    }\n    /**\n     * Find occurrences of the specified `value` in the specified `field` on all records in the store\n     * @param {String} field The record field to search in\n     * @param {*} value Value to search for\n     * @param {Boolean} distinct True to only return distinct matches, no duplicates\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching\n     * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }\n     * @category Search\n     */\n    findByField(field, value, distinct = false, searchAllRecords = false) {\n        const\n            records    = this.getAllDataRecords(searchAllRecords),\n            len        = records.length,\n            usedValues = new Set(),\n            found      = [];\n        let i, record, fieldValue;\n        if (value != null) {\n            value = String(value).toLowerCase();\n        }\n        for (i = 0; i < len; i++) {\n            record     = records[i];\n            fieldValue = record[field];\n            if (!distinct || !usedValues.has(fieldValue)) {\n                const\n                    type    = fieldValue instanceof Date ? 'date' : typeof fieldValue,\n                    matchFn = matchFns[type];\n                if ((value == null && fieldValue === value) || value && matchFn(fieldValue, value)) {\n                    found.push({\n                        id    : record.id,\n                        index : i,\n                        data  : record\n                    });\n                    if (distinct) {\n                        usedValues.add(fieldValue);\n                    }\n                }\n            }\n        }\n        return found;\n    }\n    //endregion\n    //region Find (single hit)\n    /**\n     * Finds the first record for which the specified function returns true\n     * @param {Function} fn Comparison function, called with record as parameter\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching\n     * @returns {Core.data.Model} Record or undefined if none found\n     *\n     * @example\n     * store.find(record => record.color === 'blue');\n     * @category Search\n     */\n    find(fn, searchAllRecords = false)  {\n        return this.getAllDataRecords(searchAllRecords).find(fn);\n    }\n    /**\n     * Finds the first record for which the specified field has the specified value\n     * @param {String} fieldName Field name\n     * @param {*} value Value to find\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching\n     * @returns {Core.data.Model} Record or undefined if none found\n     * @category Search\n     */\n    findRecord(fieldName, value, searchAllRecords = false) {\n        const\n            matchFn = r => ObjectHelper.isEqual(r[fieldName], value);\n        if (this.isTree) {\n            return this.query(matchFn, searchAllRecords)[0];\n        }\n        return this.getAllDataRecords(searchAllRecords).find(matchFn);\n    }\n    /**\n     * Searches the Store records using the passed function.\n     * @param {Function} fn A function that is called for each record. Return true to indicate a match\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching\n     * @returns {Core.data.Model[]} An array of the matching Records\n     * @category Search\n     */\n    query(fn, searchAllRecords = false) {\n        if (this.isTree) {\n            const matches = [];\n            this.traverse((node) => {\n                if (fn(node)) {\n                    matches.push(node);\n                }\n            }, undefined, undefined, searchAllRecords);\n            return matches;\n        }\n        return this.getAllDataRecords(searchAllRecords).filter(fn);\n    }\n    //endregion\n    //region Others\n    /**\n     * Returns true if the supplied function returns true for any record in the store\n     * @param {Function} fn A function that should return true to indicate a match\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching\n     * @returns {Boolean}\n     *\n     * @example\n     * store.some(record => record.age > 95); // true if any record has age > 95\n     * @category Search\n     */\n    some(fn, searchAllRecords = false) {\n        return this.getAllDataRecords(searchAllRecords).some(fn);\n    }\n    //endregion\n};\n", "import Base from '../../Base.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\n/**\n * @module Core/data/mixin/StoreSort\n */\nconst nestedRe = /\\./;\n/**\n * An immutable object representing a store sorter.\n *\n * @typedef {Object} Sorter\n * @property {String} field Field name\n * @property {Boolean} [ascending=true] `true` to sort ascending, `false` to sort descending\n */\n/**\n * Mixin for Store that handles simple sorting as well as multi-level sorting.\n *\n * ```javascript\n * // single sorter\n * store.sort('age');\n *\n * // single sorter as object, descending order\n * store.sort({ field : 'age', ascending : false });\n *\n * // multiple sorters\n * store.sort(['age', 'name']);\n *\n * // using custom sorting function\n * store.sort({\n *     fn : (recordA, recordB) => {\n *         // apply custom logic, for example:\n *         return recordA.name.length < recordB.name.length ? -1 : 1;\n *     }\n * });\n *\n * // using locale specific sort (slow)\n * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });\n * ```\n *\n * @mixin\n */\nexport default Target => class StoreSort extends (Target || Base) {\n    static get $name() {\n        return 'StoreSort';\n    }\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,\n             * a locale string or a locale config to enable.\n             *\n             * Enabling this has big negative impact on sorting\n             * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).\n             *\n             * Examples:\n             *\n             * ```javascript\n             * const store = new Store({\n             *     // Swedish sorting\n             *     useLocaleSort : 'sv-SE'\n             * });\n             *\n             * const store = new Store({\n             *     // Swedish sorting with custom casing order\n             *     useLocaleSort : {\n             *         locale    : 'sv-SE',\n             *         caseFirst : 'upper'\n             *     }\n             * });\n             * ```\n             *\n             * Can also be configured on a per-sorter basis:\n             *\n             * ```javascript\n             * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });\n             * ```\n             *\n             * @config {Boolean|String|Object}\n             * @default false\n             * @category Advanced\n             */\n            useLocaleSort : null\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Initial sorters, format is [{ field: 'name', ascending: false }, ...]\n             * @config {Sorter[]|String[]}\n             * @category Common\n             */\n            sorters : [],\n            /**\n             * Specify true to sort this store after records are added.\n             * @config {Boolean}\n             * @default\n             * @category Sorting\n             */\n            reapplySortersOnAdd : false\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired before sorting\n     * @event beforeSort\n     * @param {Core.data.Store} source This Store\n     * @param {Sorter[]} sorters Sorter configs\n     * @param {Core.data.Model[]} records Records to sort\n     */\n    /**\n     * Fired after sorting\n     * @event sort\n     * @param {Core.data.Store} source This Store\n     * @param {Sorter[]} sorters Sorter configs\n     * @param {Core.data.Model[]} records Sorted records\n     */\n    //endregion\n    //region Properties\n    /**\n     * Currently applied sorters\n     * @member {Sorter[]} sorters\n     * @readonly\n     * @category Sort, group & filter\n     */\n    /**\n     * Is store sorted?\n     * @property {Boolean}\n     * @readonly\n     * @category Sort, group & filter\n     */\n    get isSorted() {\n        return Boolean(this.sorters.length) || this.isGrouped;\n    }\n    changeSorters(sorters) {\n        return sorters.map(sorter => this.normalizeSorterConfig(sorter, true));\n    }\n    updateReapplySortersOnAdd(enable) {\n        this.storage.autoSort = enable;\n    }\n    //endregion\n    //region Add & remove sorters\n    /**\n     * Sort records, either by replacing current sorters or by adding to them.\n     * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).\n     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores\n     * normal sorting routine.\n     *\n     * ```javascript\n     * // single sorter\n     * store.sort('age');\n     *\n     * // single sorter as object, descending order\n     * store.sort({ field : 'age', ascending : false });\n     *\n     * // multiple sorters\n     * store.sort(['age', 'name']);\n     *\n     * // using custom sorting function\n     * store.sort((recordA, recordB) => {\n     *     // apply custom logic, for example:\n     *     return recordA.name.length < recordB.name.length ? -1 : 1;\n     * });\n     *\n     * // using locale specific sort (slow)\n     * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });\n     * ```\n     *\n     * @param {String|Sorter[]|Sorter|Function} field Field to sort by.\n     * Can also be an array of {@link Core.util.CollectionSorter sorter} config objects, or a sorting function, or a\n     * {@link Core.util.CollectionSorter sorter} config.\n     * @param {Boolean} [ascending] Sort order.\n     * Applicable when the `field` is a string (if not specified and already sorted by the field, reverts direction),\n     * or an object and `ascending` property is not specified for the object. `true` by default.\n     * Not applicable when `field` is a function. `ascending` is always `true` in this case.\n     * @param {Boolean} [add] If `true`, adds a sorter to the sorters collection.\n     * Not applicable when `field` is an array. In this case always replaces active sorters.\n     * @param {Boolean} [silent] Set as true to not fire events. UI will not be informed about the changes.\n     * @category Sort, group & filter\n     * @fires beforeSort\n     * @fires sort\n     * @fires refresh\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     */\n    sort(field, ascending, add = false, silent = false) {\n        const\n            me             = this,\n            records        = me.allRecords,\n            currentSorters = me.sorters ? me.sorters.slice() : [];\n        let currentDir = null,\n            curSort;\n        if (field) {\n            if (Array.isArray(field)) {\n                // array of strings make fields always be sorted ascending\n                me.sorters = field.map(sorter => me.normalizeSorterConfig(sorter, typeof sorter === 'string' ? true : ascending));\n            }\n            else {\n                const sorter = me.normalizeSorterConfig(field, ascending);\n                if (add) {\n                    curSort = me.getCurrentSorterByField(sorter.field);\n                    // Field already among sorters? change sort direction instead of adding new sorter\n                    if (curSort) {\n                        currentDir        = curSort.ascending;\n                        curSort.ascending = sorter.ascending;\n                    }\n                    else {\n                        me.sorters.push(sorter);\n                    }\n                }\n                else {\n                    me.sorters = [sorter];\n                }\n            }\n        }\n        if (!silent && me.trigger('beforeSort', { sorters : me.sorters, records, currentSorters }) === false) {\n            // Restore sorters\n            me.sorters = currentSorters;\n            // Restore sorting direction if toggled\n            if (currentDir !== null) {\n                curSort.ascending = currentDir;\n            }\n            return null;\n        }\n        return me.performSort(silent);\n    }\n    normalizeSorterConfig(field, ascending) {\n        const\n            me     = this,\n            sorter = { ascending };\n        if (typeof field === 'object') {\n            ObjectHelper.assign(sorter, field);\n            if (field.fn) {\n                delete sorter.fn;\n                sorter.sortFn = field.fn;\n            }\n            sorter.ascending = field.ascending ?? ascending;\n        }\n        else if (typeof field === 'function') {\n            sorter.sortFn = field;\n        }\n        else {\n            sorter.field = field;\n        }\n        // sort in opposite direction if not specified and already sorted, default to sorting ascending\n        if (sorter.ascending == null) {\n            const curSort = me.getCurrentSorterByField(sorter.field);\n            sorter.ascending = curSort ? !curSort.ascending : true;\n        }\n        if (sorter.sortFn == null) {\n            const compareItems = me.modelClass?.$meta.fields.map[sorter.field]?.compareItems;\n            if (compareItems) {\n                // These sorters will be ignored by AjaxStore when remoting...\n                sorter.sortFn = compareItems;\n            }\n        }\n        return sorter;\n    }\n    getCurrentSorterByField(field) {\n        return typeof field === 'string' && this.sorters.find(s => s.field === field) || null;\n    }\n    /**\n     * Add a sorting level (a sorter).\n     * @param {String|Sorter[]|Sorter|Function} field Field to sort by. Can also be an array of sorters, or a sorting\n     * function, or a {@link Core.util.CollectionSorter sorter} config.\n     * @param {Boolean} [ascending] Sort order (used only if field specified as string)\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    addSorter(field, ascending = true) {\n        return this.sort(field, ascending, true);\n    }\n    /**\n     * Remove a sorting level (a sorter)\n     * @param {String|Function} field Stop sorting by this field (or sorter function)\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    removeSorter(field) {\n        const\n            sorterIndex = this.sorters.findIndex(sorter => sorter.field === field || sorter.sortFn === field);\n        if (sorterIndex > -1) {\n            this.sorters.splice(sorterIndex, 1);\n            return this.sort();\n        }\n    }\n    /**\n     * Removes all sorters, turning store sorting off.\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @category Sort, group & filter\n     */\n    clearSorters(silent = false) {\n        if (this.sorters.length) {\n            this.sorters.length = 0;\n            return this.sort(undefined, undefined, undefined, silent);\n        }\n    }\n    //region\n    //region Sorting logic\n    /**\n     * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.\n     * @param {Sorter[]} sorters An array of sorter config objects\n     * @returns {Function}\n     * @category Sort, group & filter\n     */\n    createSorterFn(sorters) {\n        const storeLocaleSort = this.useLocaleSort;\n        return (lhs, rhs) => {\n            for (let i = 0; i < sorters.length; i++) {\n                const\n                    sorter = sorters[i],\n                    { field, ascending = true, useLocaleSort = storeLocaleSort } = sorter,\n                    fn = sorter.fn || sorter.sortFn,\n                    direction = ascending ? 1 : -1;\n                if (fn) {\n                    const val = fn.call(sorter, lhs, rhs);\n                    if (val === 0) {\n                        // equal values, let next sorter define order\n                        continue;\n                    }\n                    if (val !== null) {\n                        return val * direction;\n                    }\n                }\n                const\n                    nested = nestedRe.test(field),\n                    lhsValue = nested ? lhs.get(field) : lhs[field],\n                    rhsValue = nested ? rhs.get(field) : rhs[field];\n                if (lhsValue === rhsValue) {\n                    continue;\n                }\n                if (lhsValue == null) {\n                    return -direction;\n                }\n                if (rhsValue == null) {\n                    return direction;\n                }\n                if (useLocaleSort && typeof lhsValue === 'string') {\n                    // Use systems locale\n                    if (useLocaleSort === true) {\n                        return String(lhsValue).localeCompare(rhsValue) * direction;\n                    }\n                    // Use specified locale\n                    if (typeof useLocaleSort === 'string') {\n                        return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;\n                    }\n                    // Use locale config\n                    if (typeof useLocaleSort === 'object') {\n                        return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;\n                    }\n                }\n                if (lhsValue > rhsValue) {\n                    return direction;\n                }\n                if (lhsValue < rhsValue) {\n                    return -direction;\n                }\n            }\n            return 0;\n        };\n    }\n    /**\n     * The sorter function for sorting records in the store.\n     * @member {Function}\n     * @internal\n     * @readonly\n     */\n    get sorterFn() {\n        const\n            me = this,\n            { sorters } = me;\n        // When remoteSort is enabled then always sort by data order received from remote server\n        // _remoteSortIndex is set inside store.setStoreData() method\n        return me.createSorterFn(me.remoteSort ?  [{ field : '_remoteSortIndex' }] : (me.isGrouped ? me.groupers.concat(sorters) : sorters));\n    }\n    /**\n     * Perform sorting according to the {@link #config-sorters} configured.\n     * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and\n     * must not be overridden.\n     * @async\n     * @private\n     * @category Sort, group & filter\n     */\n    performSort(silent) {\n        const\n            me = this,\n            { rootNode, storage, sorterFn: sorter } = me;\n        if (me.tree) {\n            !me.isChained && rootNode.traverse(node => {\n                if (node.isLoaded && node.isParent) {\n                    node.children.sort(sorter);\n                    // Since child nodes change order their parentIndex needs to be updated.\n                    // Update is silent, records won't be considered modified because of the sort\n                    node.updateChildrenIndices(node.children, 'parentIndex', true);\n                }\n            });\n            storage.replaceValues({\n                values : me.collectDescendants(rootNode).visible,\n                silent : true\n            });\n        }\n        else if (me.isGrouped) {\n            storage.replaceValues({\n                ...me.prepareGroupRecords(sorter),\n                silent : true\n            });\n        }\n        else {\n            storage.replaceValues({\n                values : storage.values.sort(sorter),\n                silent : true\n            });\n        }\n        me.afterPerformSort(silent || me.isRemoteDataLoading);\n    }\n    afterPerformSort(silent) {\n        if (silent) {\n            return;\n        }\n        const me = this;\n        me._idMap = null;\n        const event = {\n            action  : 'sort',\n            sorters : me.sorters,\n            records : me.allRecords\n        };\n        me.trigger('sort', event);\n        me.trigger('refresh', event);\n    }\n    //endregion\n};\n", "import Base from '../../Base.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\n/**\n * @module Core/data/mixin/StoreChained\n */\nconst returnTrue = () => true;\n/**\n * A chained Store contains a subset of records from a master store. Which records to include is determined by a\n * filtering function, {@link #config-chainedFilterFn}.\n *\n * ```javascript\n * masterStore.chain(record => record.percent < 10);\n *\n * // or\n *\n * new Store({\n *   masterStore     : masterStore,\n *   chainedFilterFn : record => record.percent < 10\n * });\n * ```\n *\n * @mixin\n */\nexport default Target => class StoreChained extends (Target || Base) {\n    static get $name() {\n        return 'StoreChained';\n    }\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * Function used to filter records in the masterStore into a chained store. If not provided,\n             * all records from the masterStore will be included in the chained store.\n             * @config {Function}\n             * @category Chained store\n             */\n            chainedFilterFn : null,\n            /**\n             * Array of field names that should trigger filtering of chained store when the fields are updated.\n             * @config {String[]}\n             * @category Chained store\n             */\n            chainedFields : null,\n            /**\n             * Master store that a chained store gets its records from.\n             * @config {Core.data.Store}\n             * @category Chained store\n             */\n            masterStore : null,\n            /**\n             * Method names calls to which should be relayed to master store.\n             * @config {String[]}\n             * @category Chained store\n             */\n            doRelayToMaster : ['add', 'remove', 'insert'],\n            /**\n             * Method names calls to which shouldn't be relayed to master store.\n             * @config {String}\n             * @category Chained store\n             */\n            dontRelayToMaster : [],\n            /**\n             * If true, collapsed records in original tree will be excluded from the chained store.\n             * @config {Boolean}\n             * @category Chained store\n             */\n            excludeCollapsedRecords : true\n        };\n    }\n    // All props should be predefined to work properly with objectified stores\n    static get properties() {\n        return {\n            chainedStores : null\n        };\n    }\n    //endregion\n    construct(config) {\n        super.construct(config);\n        const\n            me              = this,\n            { masterStore } = me,\n            sort            = me.syncOrder ? 'sort' : '';\n        if (masterStore) {\n            me.methodNamesToRelay.forEach(fnName => me[fnName] = (...params) => me.relayToMaster(fnName, params));\n            me.removeAll = (...params) => {\n                masterStore.remove(me.getRange(), ...params);\n            };\n            masterStore.ion({\n                // HACK to have chained stores react early in a async events scenario (with engine). Could be turned\n                // into a config, but this way one does not have to think about it\n                changePreCommit : me.onMasterDataChangedPreCommit,\n                change          : me.onMasterDataChanged,\n                [sort]          : me.onMasterDataChanged,\n                prio            : 1,\n                thisObj         : me\n            });\n            if (!masterStore.chainedStores) {\n                masterStore.chainedStores = [];\n            }\n            masterStore.chainedStores.push(me);\n            me.fillFromMaster();\n        }\n    }\n    //region Properties\n    // For accessing the full set of records, whether chained or not\n    get $master() {\n        return this.masterStore || this;\n    }\n    /**\n     * Is this a chained store?\n     * @property {Boolean}\n     * @readonly\n     * @category Store\n     */\n    get isChained() {\n        return Boolean(this.masterStore);\n    }\n    set chainedFilterFn(chainedFilterFn) {\n        this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;\n    }\n    get chainedFilterFn() {\n        return this._chainedFilterFn || returnTrue;\n    }\n    get methodNamesToRelay() {\n        const\n            doIsArray   = Array.isArray(this.doRelayToMaster),\n            dontIsArray = Array.isArray(this.dontRelayToMaster);\n        return doIsArray && this.doRelayToMaster.filter(name => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];\n    }\n    //endregion\n    //region Internal\n    updateChainedStores() {\n        if (this.chainedStores) {\n            this.chainedStores.forEach(store => store.fillFromMaster());\n        }\n    }\n    /**\n     * Updates records available in a chained store by filtering the master store records using\n     * {@link #config-chainedFilterFn}\n     * @category Chained store\n     */\n    fillFromMaster() {\n        const\n            me                      = this,\n            { masterStore, isTree } = me;\n        let records = [];\n        if (!me.isChained) {\n            throw new Error('fillFromMaster only allowed on chained store');\n        }\n        if (masterStore.isGrouped && masterStore.isFiltered) {\n            masterStore.forEach(r => records.push(r), masterStore, { includeFilteredOutRecords : true, includeCollapsedGroupRecords : true });\n        }\n        else {\n            records = masterStore.allRecords.filter(r => !r.isSpecialRow && me.chainedFilterFn(r));\n        }\n        if (isTree) {\n            // All nodes will be registered\n            me.idRegister = {};\n            me.internalIdRegister = {};\n            // *all* owned records have to join, as they would have done if they'd all gone through\n            // the appendChild route for this store.\n            records.forEach(r => {\n                if (r.stores.includes(me)) {\n                    me.register(r);\n                }\n                else {\n                    r.joinStore(me);\n                }\n            });\n            // We exclude collapsed records by default. It's used in Columns Store.\n            // Because grid columns is a tree store when subgrid columns is just a chained store of the columns store.\n            // And we don't need to include collapsed column.\n            // If we need to show collapsed nodes in Combo we need to chain tree store and set `excludeCollapsedRecords` to `false`.\n            if (me.excludeCollapsedRecords) {\n                const children = me.getChildren(me.rootNode);\n                records = me.doIncludeExclude(children, true);\n            }\n        }\n        me.isFillingFromMaster = true;\n        me.data = records;\n        me.isFillingFromMaster = false;\n    }\n    /**\n     * Commits changes back to master.\n     * - the records deleted from chained store and present in master will be deleted from master\n     * - the records added to chained store and missing in master will added to master\n     * Internally calls {Store#function-commit commit()}.\n     * @returns {Object} Changes, see Store#changes\n     * @internal\n     */\n    commitToMaster() {\n        const\n            me = this,\n            master = me.masterStore;\n        if (!me.isChained) {\n            throw new Error('commitToMaster only allowed on chained store');\n        }\n        master.beginBatch();\n        master.remove(me.removed.values);\n        master.add(me.added.values);\n        master.endBatch();\n        return me.commit();\n    }\n    /**\n     * Relays some function calls to the master store\n     * @private\n     */\n    relayToMaster(fnName, params) {\n        return this.masterStore[fnName](...params);\n    }\n    // HACK, when used with engine the chained store will catch events early (sync) and prevent late (async) listeners\n    onMasterDataChangedPreCommit(event) {\n        this.onMasterDataChanged(event);\n        this.$masterEventhandled = true;\n    }\n    /**\n     * Handles changes in master stores data. Updates the chained store accordingly\n     * @private\n     */\n    onMasterDataChanged({ action, changes, $handled, isMove }) {\n        // Handled early in engine store (above), bail out\n        if (this.$masterEventhandled) {\n            this.$masterEventhandled = false;\n            return;\n        }\n        // 'move' action triggers a remove event first, we wait for the 'add' - no need to fill twice\n        if (isMove && action === 'remove') {\n            return;\n        }\n        // if a field not defined in chainedFields is changed, ignore the change.\n        // there is no need to refilter the store in such cases, the change will be available anyhow since data is\n        // shared\n        if (action !== 'update' || this.chainedFields?.some(field => field in changes)) {\n            this.fillFromMaster();\n        }\n    }\n    //endregion\n    //region public API\n    /**\n     * Creates a chained store, a new Store instance that contains a subset of the records from current store.\n     * Which records is determined by a filtering function, which is reapplied when data in the base store changes.\n     *\n     * ```javascript\n     * const oldies = store.makeChained(record => record.age > 50);\n     * // or use a simple query\n     * const ages = store.makeChained(() => store.allRecords.distinct('age')));\n     * ```\n     *\n     * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting chained store\n     * will be a tree store sharing the same root node, but only child nodes which pass the `chainedFilterFn` will be\n     * considered when iterating the tree through the methods such as\n     * {@link Core.data.Store#function-traverse} or {@link Core.data.Store#function-forEach}.\n     *\n     * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be\n     * included (return true / false), or a query function called with no arguments (see example below). Defaults to\n     * including all records (fn always returning true)\n     * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated\n     * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}\n     * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.\n     * @returns {Core.data.Store}\n     */\n    makeChained(chainedFilterFn = returnTrue, chainedFields, config) {\n        return new (config?.storeClass || this.constructor)({\n            ...config || {},\n            tree           : false,\n            autoTree       : false,\n            // If someone ever chains a chained store, chain master instead\n            masterStore    : this.$master,\n            modelClass     : this.modelClass,\n            // Chained store should never use syncDataOnLoad, that will create an infinite loop when they determine\n            // that a record is added and then add it to master, repopulating this store and round we go\n            syncDataOnLoad : false,\n            chainedFilterFn,\n            chainedFields\n        });\n    }\n    /**\n     * Alias for {@link Core.data.Store#function-makeChained}\n     *\n     * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be\n     * included (return true / false), or a query function called with no arguments (see example below). Defaults to\n     * including all records (fn always returning true)\n     * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated\n     * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}\n     * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.\n     * @returns {Core.data.Store}\n     */\n    chain() {\n        return this.makeChained(...arguments);\n    }\n    //endregion\n    doDestroy() {\n        // Destroy chained store on master store destroy\n        this.chainedStores?.forEach(chainedStore => chainedStore.destroy());\n        // Events superclass fires destroy event.\n        super.doDestroy();\n    }\n};\n", "import Base from '../../Base.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\n/**\n * @module Core/data/mixin/StoreState\n */\n/**\n * A Mixin for Store that manages its state.\n *  * **sorters**\n *  * **groupers**\n *  * **filters**: Only serializable filters are saved (filters defined with `property` and `value`).\n * @mixin\n */\nexport default Target => class StoreState extends (Target || Base) {\n    static get $name() {\n        return 'StoreState';\n    }\n    /**\n     * Get store state. Used by State-plugin to serialize state\n     * @private\n     * @returns {{ sorters, groupers }}\n     */\n    getState() {\n        const\n            { sorters, groupers, filters } = this,\n            state                          = {};\n        if (sorters?.length) {\n            state.sorters = sorters.map(sorter => {\n                const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));\n                // Remove sorting fns\n                delete clone.fn;\n                delete clone.sortFn;\n                return clone;\n            });\n        }\n        if (groupers?.length) {\n            state.groupers = groupers.map(grouper => {\n                const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));\n                // Remove grouping fns\n                delete clone.fn;\n                return clone;\n            });\n        }\n        if (filters?.values.length) {\n            state.filters = filters.values.map(filter => {\n                const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter.config));\n                // Apply value, needed because of filterable fn reusing instance (so not in config)\n                clone.value = filter.value;\n                // Remove default value, no need to store that in state\n                if (clone.caseSensitive) {\n                    delete clone.caseSensitive;\n                }\n                // Remove filtering fns\n                // delete clone.filterBy; // Cannot remove it, required by export feature\n                return clone;\n            });\n        }\n        return state;\n    }\n    /**\n     * Apply store state. Used by State-plugin to restore a previously serialized state\n     * @private\n     * @param {{ sorters, groupers }} state\n     */\n    applyState(state) {\n        const\n            me = this,\n            {\n                sorters  = [],\n                groupers = [],\n                filters  = []\n            }  = state,\n            {\n                sortParamName,\n                filterParamName\n            } = me;\n        // We cannot apply sorters with a sortFn if we are doing server-side sorting\n        me.sorters = sorters.filter(sorter => sorter.field || (sorter.sortFn && !sortParamName));\n        me.groupers = groupers.slice();\n        me.sort();\n        // We cannot apply filters with a filterBy if we are doing server-side filtering\n        me.filters = filters.filter(filter => filter.property || (filter.filterBy && !filterParamName));\n        me.filter();\n    }\n};\n", "/**\n * @module Core/data/Wbs\n */\nconst zeroPad = v => String(v).padStart(6, '0');\n/**\n * This class holds a WBS (Work Breakdown Structure) value (e.g., '1.2.1'). This class ensures that such values compare\n * correctly, for example, that '1.2' is less than '1.10' (which do not compare that way as simple text).\n */\nexport default class Wbs {\n    /**\n     * Wbs constructor.\n     * @param {String|Number} value The value of WBS\n     */\n    constructor(value) {\n        this.value = value;\n        this._padded = null;\n    }\n    /**\n     * The WBS value\n     * @readonly\n     * @member {String} value\n     */\n    set value(value) {\n        this._value = String(value ?? '');\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Returns a `Wbs` instance given a `value`. If the `value` is already a `Wbs` object, it is returned. Otherwise,\n     * a new `Wbs` is created. If `value` is `null` or `undefined`, that value is returned.\n     * @param {String|Number|Core.data.Wbs} value\n     * @returns {Core.data.Wbs}\n     */\n    static from(value) {\n        // this must preserve null to be useful as a data field, where a null value means no value present.\n        return (value == null) ? value : ((value instanceof Wbs) ? value : new Wbs(value));\n    }\n    /**\n     * Returns a WBS code where each component is 0-padded on the left to 6 digits. That is \"1.2\" is padded to be\n     * \"000001.000002\". These values can be compared for proper semantic order (e.g., Wbs.pad('1.2') < Wbs.pad('1.10')).\n     * @param {String|Number|Core.data.Wbs} value\n     * @returns {String}\n     * @private\n     */\n    static pad(value) {\n        return (value instanceof Wbs) ? value.valueOf() : Wbs.split(value).map(zeroPad).join('.');\n    }\n    /**\n     * Returns an array of digits from a given WBS code `value`. If the value cannot be converted, an empty array is\n     * returned.\n     * @param {String|Number|Core.data.Wbs} value\n     * @returns {Number[]}\n     * @private\n     */\n    static split(value) {\n        let i, ret;\n        if (value || value === 0) {\n            switch (typeof value) {\n                case 'object':\n                    value = String(value);\n                // noinspection FallThroughInSwitchStatementJS\n                case 'string': // eslint-disable-line no-fallthrough\n                    ret = value.split('.');\n                    for (i = ret.length; i-- > 0; /* empty */) {\n                        ret[i] = parseInt(ret[i], 10);\n                    }\n                    break;\n                case 'number':\n                    ret = [value];\n                    break;\n            }\n        }\n        return ret || [];\n    }\n    /**\n     * Compares two WBS values, returning 0 if equal, -1 if `lhs` is less than `rhs, or 1 if `lhs` is greater than `rhs`.\n     * @param {String|Core.data.Wbs} lhs\n     * @param {String|Core.data.Wbs} rhs\n     * @returns {Number}\n     */\n    static compare(lhs, rhs) {\n        if (lhs === rhs) {\n            return 0;\n        }\n        if (!lhs || !rhs) {\n            return lhs ? 1 : (rhs ? -1 : 0);\n        }\n        lhs = Wbs.pad(lhs);\n        rhs = Wbs.pad(rhs);\n        return (lhs < rhs) ? -1 : ((rhs < lhs) ? 1 : 0);\n    }\n    /**\n     * Appends a sub-level WBS value to this WBS code and returns a `Wbs` instance for it.\n     * @param {String|Number} value\n     * @returns {Core.data.Wbs}\n     */\n    append(value) {\n        const s = this.value;\n        return Wbs.from(s ? `${s}.${value}` : value);\n    }\n    /**\n     * Returns truthy value if this Wbs equals the passed value.\n     * @param {String|Core.data.Wbs} value\n     * @returns {Boolean}\n     */\n    isEqual(value) {\n        return !Wbs.compare(this, value);\n    }\n    /**\n     * Compares this WBS value with a specified pattern, returning `true` if they match. If the `pattern` is simply a\n     * sequence of digits and decimal points (e.g., \"1.2\"), it is a match if it is a substring of this WBS code (e.g.,\n     * \"3.1.2.4\"). If the `pattern` starts with `*` (e.g., \"*.1.2\"), it is a match if this WBS code ends with the text\n     * following the `*` (e.g., \"4.3.1.2\"). If the `pattern` ends with `*`, it is a match if this WBS code starts with\n     * the text up to the `*`.\n     *\n     * Some examples:\n     * ```\n     *  console.log(Wbs.from('1.2.3.4').match('2.3'));\n     *  > true\n     *  console.log(Wbs.from('1.2.3.4').match('*.4'));\n     *  > true\n     *  console.log(Wbs.from('1.2.3.4').match('1.2.*'));\n     *  > true\n     *\n     *  console.log(Wbs.from('1.2.3.4').match('2.4'));\n     *  > false\n     *  console.log(Wbs.from('1.2.3.4').match('*.3'));\n     *  > false\n     *  console.log(Wbs.from('1.2.3.4').match('2.*'));\n     *  > false\n     * ```\n     * @param {String} pattern A partial WBS code (e.g., \"1.2\"), optionally starting or ending with `*`.\n     * @returns {Boolean}\n     */\n    match(pattern) {\n        let ret = false;\n        if (pattern) {\n            const\n                wbs = this.value,\n                globLeft = pattern[0] === '*',\n                globRight = pattern.endsWith('*'),\n                n = pattern.length;\n            if (globLeft === globRight) {\n                // no globs behavior is the same as both globs ('1.2' is the same as '*1.2*')\n                ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;\n            }\n            else if (globLeft) {\n                ret = wbs.endsWith(pattern.substr(1));\n            }\n            else {\n                ret = wbs.startsWith(pattern.substr(0, n - 1));\n            }\n        }\n        return ret;\n    }\n    toString() {\n        return this.value;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    valueOf() {\n        // the value we return is implicitly used by < and > operators when comparing instances of this type, so we\n        // need to return a value that makes \"1.2 < 1.10\" evaluate as true:\n        return this._padded ?? (this._padded = Wbs.pad(this.value));\n    }\n}\nWbs._$name = 'Wbs';", "import Base from '../../Base.js';\nimport StringHelper from '../../helper/StringHelper.js';\nimport VersionHelper from '../../helper/VersionHelper.js';\nimport Wbs from './../Wbs.js';\n/**\n * @module Core/data/mixin/StoreTree\n */\nconst emptyArray = Object.freeze([]);\n/**\n * Mixin for store with tree related functionality. To learn more about working with tree nodes please see the\n * {@link Core/data/mixin/TreeNode} class and [this guide](#Core/guides/data/treedata.md).\n * @mixin\n */\nexport default Target => class StoreTree extends (Target || Base) {\n    static $name = 'StoreTree';\n    static configurable = {\n        /**\n         * Set to `true` to on load transform a flat dataset with raw objects containing `parentId` into the format\n         * expected for tree data.\n         *\n         * Example input format:\n         *\n         * ```javascript\n         * [\n         *   { id : 1, name : 'Parent' },\n         *   { id : 2, name : 'Child', parentId : 1 }\n         * ]\n         * ```\n         *\n         * Will be transformed into:\n         *\n         * ```javascript\n         * [\n         *   {\n         *     id       : 1,\n         *     name     : 'Parent',\n         *     children : [\n         *       { id : 2, name : 'Child', parentId : 1 }\n         *     ]\n         *   }\n         * ]\n         * ```\n         *\n         * @config {Boolean}\n         * @category Tree\n         */\n        transformFlatData : null,\n        /**\n         * This flag prevents firing of 'remove' event when moving a node in the tree. In 6.0 this will be the default\n         * behavior and this flag will be removed.\n         * @config {Boolean}\n         * @category Tree\n         */\n        fireRemoveEventForMoveAction : VersionHelper.checkVersion('core', '6.0', '<')\n    };\n    //region Getters\n    /**\n     * True if this Store is configured to handle tree data (with `tree : true`) or if this is a\n     * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.\n     * @property {Boolean}\n     * @readonly\n     * @category Tree\n     */\n    get isTree() {\n        return this.tree || (this.masterStore && this.masterStore.tree);\n    }\n    /**\n     * Returns all leaf records in a tree store\n     * @property {Core.data.Model[]}\n     * @category Tree\n     */\n    get leaves() {\n        const me = this,\n            result = [];\n        if (me.isTree) {\n            me.traverse(record => {\n                if (record.isLeaf) {\n                    result.push(record);\n                }\n            });\n            return result;\n        }\n        else {\n            me.allRecords.forEach(r => {\n                if (r.isLeaf) {\n                    result.push(r);\n                }\n                r.traverse(record => {\n                    if (record.isLeaf) {\n                        result.push(record);\n                    }\n                }, true);\n            });\n        }\n        return result;\n    }\n    //endregion\n    //region Children\n    /**\n     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,\n     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for\n     * `toggleNode` and insert records when you have them available.\n     * @param {Core.data.Model} parentRecord\n     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is\n     * vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler, or if an {@link Core.data.AjaxStore#event-exception} is detected.\n     * The resolved function is passed the event object passed to any event handlers.\n     * The rejected function is passed the {@link Core.data.AjaxStore#event-exception} event if an exception occurred,\n     * or `false` if the load was vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler.\n     * @category Tree\n     */\n    async loadChildren(parentRecord) {\n    }\n    /**\n     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.\n     * @internal\n     * @param {Core.data.mixin.TreeNode} parent\n     * @param {Core.data.mixin.TreeNode[]} children\n     * @param {Number} index\n     * @param {Object} isMove\n     * @param {Boolean} [silent]\n     * @fires add\n     * @fires change\n     * @category Tree\n     */\n    onNodeAddChild(parent, children, index, isMove, silent = false) {\n        const\n            me                  = this,\n            isRootLoad          = parent === me.rootNode && parent.isLoading,\n            { storage }         = me,\n            toAddToUI           = [],\n            toAdd               = [],\n            { previousSibling } = children[0];\n        let storeInsertionPoint;\n        me.collectDescendants(children, toAddToUI, toAdd, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)) });\n        // Keep CRUD caches up to date unless it's a root load\n        if (!isRootLoad && toAdd.length) {\n            for (const record of toAdd) {\n                // Only considered an add if not modified or moved\n                if (!me.modified.includes(record) && !isMove[record.id]) {\n                    // If was removed, remove from `removed` list\n                    if (me.removed.includes(record)) {\n                        me.removed.remove(record);\n                    }\n                    // Else add to `added` list\n                    else if (!record.isLinked) {\n                        me.added.add(record);\n                    }\n                }\n            }\n        }\n        // Root node inserted first\n        if (isRootLoad && me.rootVisible) {\n            toAddToUI.unshift(parent);\n            toAdd.unshift(parent);\n        }\n        if (toAddToUI.length) {\n            // Calculate the insertion point into the flat store.\n            // If the new node is the first, then it goes after the parent node.\n            if (index === 0 || !previousSibling) {\n                storeInsertionPoint = storage.indexOf(parent);\n            }\n            // Otherwise it has to go after the previous visible node which has\n            // to be calculated. See indexOfPreviousVisibleNode for explanation.\n            else {\n                storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);\n            }\n            // Insert added child nodes at correct location in storage.\n            // We must not react to change - we fire the events here.\n            storage.suspendEvents();\n            me.storage.splice(++storeInsertionPoint, 0, toAddToUI);\n            storage.resumeEvents();\n            me._idMap = null;\n        }\n        else {\n            // Since storage is not updated, need to invalidate allRecords\n            me._allRecords = null;\n        }\n        // Since we do not pass through Store#onDataChange we have to handle relations manually here. And since they are\n        // not tied to flat part of store, use all children\n        me.updateDependentStores('add', children);\n        // If it's a root level set data op, then signal 'dataset'\n        if (isRootLoad && toAddToUI.length) {\n            // If we have initial sorters, perform a silent sort before triggering `dataset`\n            // NOTE: Records in toAddToUI will be in the original order, not affected by the sort\n            if (me.sorters.length) {\n                me.sort(null, null, false, true);\n            }\n            me.afterLoadData?.();\n            if (!silent) {\n                const event = { action : 'dataset', data : me._data, records : toAddToUI };\n                me.trigger('refresh', event);\n                me.trigger('change', event);\n            }\n        }\n        // Else, continue as before to signal an \"isChild\" add.\n        else if (!silent) {\n            const event = { action : 'add', parent, isChild : true, isMove, records : children, allRecords : toAdd, index : storeInsertionPoint };\n            me.trigger('add', event);\n            me.trigger('change', event);\n            // Check if any add is actually a move\n            if (Object.values(isMove).some(wasMoved => wasMoved)) {\n                const event = {\n                    newParent  : parent,\n                    records    : children.filter(record => isMove[record.id]),\n                    oldParents : children.map(child => {\n                        return me.getById(child.meta.oldParentId);\n                    })\n                };\n                me.trigger('move', event);\n            }\n        }\n    }\n    onNodeRemoveChild(parent, children, index, flags = { isMove : false, silent : false, unfiltered : false }) {\n        const\n            me                             = this,\n            { storage }                    = me,\n            toRemoveFromUI                 = [],\n            toRemove                       = [],\n            { isMove, silent, unfiltered } = flags,\n            removeUnfiltered               = unfiltered && me.isFiltered,\n            childrenToRemove               = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;\n        me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)), unfiltered : removeUnfiltered });\n        // test StoreTree.t.js should fail if the next line replaces the above line\n        // me.collectDescendants(children, toRemoveFromUI, toRemove, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)) });\n        if (!isMove) {\n            // Unjoin is recursive, use flat children array\n            for (const record of children) {\n                record.unjoinStore(me);\n            }\n            // Keep CRUD caches up to date\n            for (const record of toRemove) {\n                if (record.stores.includes(me)) {\n                    record.unjoinStore(me);\n                }\n                // If was newly added, remove from `added` list\n                if (me.added.includes(record)) {\n                    me.added.remove(record);\n                }\n                // Else add to `removed` list\n                else if (!record.isLinked) {\n                    me.removed.add(record);\n                }\n            }\n            me.modified.remove(toRemove);\n        }\n        // Remove removed child nodes at correct location in storage\n        if (toRemoveFromUI.length) {\n            index = storage.indexOf(toRemoveFromUI[0]);\n            // We must not react to change - we fire the events here.\n            if (index > -1) {\n                storage.suspendEvents();\n                storage.splice(index, toRemoveFromUI.length);\n                storage.resumeEvents();\n                me._idMap = null;\n            }\n        }\n        else {\n            // If nothing is removed from UI (storage) return -1, showing that removed node was in a collapsed branch\n            index = -1;\n            // Since storage is not updated, need to invalidate allRecords\n            me._allRecords = null;\n        }\n        if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {\n            const event = {\n                action     : 'remove',\n                parent,\n                isChild    : true,\n                isMove,\n                records    : children,\n                allRecords : toRemove,\n                index\n            };\n            me.trigger('remove', event);\n            me.trigger('change', event);\n        }\n        return toRemove;\n    }\n    collectDescendants(node, visible = [], all = [], flags) {\n        const me = this,\n            { inCollapsedBranch = false, unfiltered = false } = flags || 0,\n            children = Array.isArray(node) ? node : me.getChildren(node, unfiltered);\n        if (children) {\n            for (let i = 0, len = children.length, child; i < len; i++) {\n                child = children[i];\n                if (!inCollapsedBranch) {\n                    visible.push(child);\n                }\n                all.push(child);\n                me.collectDescendants(child, visible, all, {\n                    inCollapsedBranch : inCollapsedBranch || !child.isExpanded(me),\n                    unfiltered\n                });\n            }\n        }\n        return { visible, all };\n    }\n    /**\n     * Returns the children of the passed branch node which this store owns. By default, this\n     * is the entire `children` array.\n     *\n     * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then\n     * this returns only the subset of children which are filtered into this store by the\n     * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.\n     * @param {Core.data.Model} parent The node to return the children of.\n     * @returns {Core.data.Model[]}\n     * @category Tree\n     */\n    getChildren(parent, unfiltered = false) {\n        const\n            me = this,\n            children = ((unfiltered || me.isChained) && parent.unfilteredChildren) || parent.children;\n        return !children?.length ? emptyArray : (\n            me.isChained\n                // In case of chained store we need to apply chainedFilterFn and sorter\n                ? children.filter(me.chainedFilterFn).sort(me.sorterFn)\n                : children\n        );\n    }\n    /**\n     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing\n     * nodes.\n     * @private\n     * @param parentRecord Parent record\n     * @param include Include (true) or exclude (false)\n     * @category Tree\n     */\n    internalToggleTreeSubRecords(parentRecord, include) {\n        const\n            me          = this,\n            { storage } = me,\n            index       = storage.indexOf(parentRecord),\n            children    = me.doIncludeExclude(me.getChildren(parentRecord), include);\n        // When expanded a parent node while being filtered, need to update the hidden flag of its children\n        if (me.isFiltered && include && parentRecord.unfilteredChildren) {\n            me.updateChildrenHiddenState(parentRecord);\n        }\n        // If we expanded a node which is yet to load children, the collected children\n        // array will be empty, so do not broadcast any change event.\n        // If we are collapsing a record which isn't visible (because parent is collapsed) we won't get an index,\n        // which is fine since it is already removed from processedRecords\n        if (children.length && index !== false) {\n            // We must not react to change - we fire the events here with a flag\n            // to tell responders that it's due to an expand or collapse.\n            storage.suspendEvents();\n            if (include) {\n                storage.splice(index + 1, 0, ...children);\n                const event = { action : 'add', isExpand : true, records : children, index : index + 1 };\n                me.trigger('add', event);\n                me.trigger('change', event);\n            }\n            else {\n                storage.splice(index + 1, children.length);\n                const event = { action : 'remove', isCollapse : true, records : children, index : index + 1 };\n                me.trigger('remove', event);\n                me.trigger('change', event);\n            }\n            storage.resumeEvents();\n            me._idMap = null;\n        }\n    }\n    // Updates the hidden flag of its children while store is filtered\n    updateChildrenHiddenState(parentRecord) {\n        parentRecord.unfilteredChildren?.forEach(child => {\n            child.instanceMeta(this.id).hidden = false;\n            if (!child.isLeaf) {\n                this.updateChildrenHiddenState(child);\n            }\n        });\n    }\n    doIncludeExclude(children, include, result = []) {\n        const\n            me         = this,\n            childCount = children?.length || 0;\n        for (let i = 0; i < childCount; i++) {\n            const child = children[i];\n            // Only consider child nodes who we own.\n            // If we are a chained store, skip nodes that are not ours.\n            if (!me.isChained || me.chainedFilterFn(child)) {\n                const mapMeta = child.instanceMeta(me.id);\n                if (include || !mapMeta.hidden) {\n                    // if including sub-records, add those who are not hidden by a collapsed sub parent\n                    result.push(child);\n                }\n                mapMeta.hidden = !include;\n                if (child.isExpanded(me)) {\n                    me.doIncludeExclude(me.getChildren(child), include, result);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.\n     * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle\n     * @param {Boolean} [collapse] Force collapse (true) or expand (false)\n     * @category Tree\n     */\n    async toggleCollapse(idOrRecord, collapse) {\n        const\n            me                 = this,\n            record             = me.getById(idOrRecord),\n            meta               = record.instanceMeta(me);\n        if (collapse === undefined) {\n            collapse = !meta.collapsed;\n        }\n        // Reject if we're in the middle of loading children, or it's a leaf, or it's a no-op\n        if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {\n            me.trigger('beforeToggleNode', { record, collapse });\n            meta.collapsed = collapse;\n            if (meta.collapsed) {\n                me.onNodeCollapse(record);\n                return true;\n            }\n            else {\n                me.onNodeExpand(record);\n                let success = true;\n                // Children not yet loaded, ask store for them.\n                // It will append them. Appending to a node which\n                // is expanded will insert the children into the UI.\n                if (!record.isLoaded) {\n                    meta.isLoadingChildren = true;\n                    try {\n                        await me.loadChildren(record);\n                    }\n                    catch (exception) {\n                        // Revert to being collapsed\n                        meta.collapsed = true;\n                        success = false;\n                        me.trigger('loadChildrenException', { record, exception });\n                    }\n                    finally {\n                        meta.isLoadingChildren = false;\n                    }\n                }\n                return success;\n            }\n        }\n    }\n    /**\n     * Remove all records beneath parentRecord from storage.\n     * @private\n     * @param parentRecord Parent record\n     * @category Tree\n     */\n    onNodeCollapse(parentRecord) {\n        // We don't care about collapse if it's inside a collapsed subtree\n        if (parentRecord.ancestorsExpanded(this)) {\n            return this.internalToggleTreeSubRecords(parentRecord, false);\n        }\n    }\n    /**\n     * Add all records beneath parentRecord from storage.\n     * @private\n     * @param parentRecord Parent record\n     * @category Tree\n     */\n    onNodeExpand(parentRecord) {\n        // We don't care about expand if it's inside a collapsed subtree\n        if (parentRecord.ancestorsExpanded(this)) {\n            return this.internalToggleTreeSubRecords(parentRecord, true);\n        }\n    }\n    //endregion\n    //region Transform flat data\n    /**\n     * Transforms flat data containing parent ids into tree data\n     * @param {Object[]} data Flat raw data\n     * @returns {Object[]} Tree data\n     * @private\n     */\n    transformToTree(data) {\n        const\n            { parentIdField, idField, childrenField } = this.modelClass,\n            parents                                   = new Map(),\n            transformed                               = [];\n        for (const node of data) {\n            const parentId = node[parentIdField];\n            // Child, find parent\n            if (parentId != null) {\n                // Detected parents are kept in a map to no have to iterate to find them each time\n                let parent = parents.get(parentId);\n                // Parent not in map, find it and add it (also adds unmatched parents, to not search for\n                // them again)\n                if (parent === undefined) {\n                    parent = data.find(node => node[idField] === parentId) ?? null;\n                    parents.set(parentId, parent);\n                }\n                // Parent found, add node as child of it\n                if (parent) {\n                    if (!parent[childrenField]) {\n                        parent[childrenField] = [];\n                    }\n                    parent[childrenField].push(node);\n                }\n            }\n            // Parent, keep\n            else {\n                transformed.push(node);\n            }\n        }\n        return transformed;\n    }\n    /**\n     * Transforms data into a tree with parent levels based on supplied fields.\n     *\n     * ```javascript\n     * const newRoot = store.treeify(['name', r => r.age % 10]);\n     * ```\n     *\n     * @param {Array<String|Function>} fields The field names, or a function to call to extract a value to create parent\n     * nodes for records with the same value.\n     * @param {Function} [parentTransform] A function which is called to allow the caller to transform the raw data\n     * object of any newly created parent nodes.\n     * @param {Boolean} [convertParents] Pass `true` to convert raw new parent data objects to this Store's\n     * {@link Core.data.Store#config-modelClass}.\n     * @returns {Core.data.Model} New root node\n     * @internal\n     */\n    treeify(fields, parentTransform, convertParents = false) {\n        const\n            { length } = fields,\n            parents    = [],\n            newRoot    = {};\n        let i, lastParent;\n        // New branch nodes are ID'd by their field values concatenated into\n        // string form.\n        //\n        // The key value that was used to create them is their \"key\" property.\n        //\n        // rootNode : {\n        //    children : [{\n        //        id       : 'p1',\n        //        name     : 'Parent 1',\n        //        expanded : true,\n        //        children : [\n        //            { id : 700, name : 'Task 700', startDate : '2021-11-26', duration : 3, percentDone : 20 },\n        //            { id : 500, name : 'Task 500', startDate : '2021-11-22', duration : 5, percentDone : 20 },\n        //            { id : 300, name : 'Task 300', startDate : '2021-11-24', duration : 3, percentDone : 10 },\n        //            { id : 100, name : 'Task 100', startDate : '2021-11-22', duration : 5, percentDone : 10 }\n        //       ]\n        //    },\n        //    {\n        //        id       : 'p2',\n        //        name     : 'Parent 2',\n        //        expanded : true,\n        //        children : [\n        //            { id : 600, name : 'Task 600', startDate : '2021-11-22', duration : 6, percentDone : 20 },\n        //            { id : 800, name : 'Task 800', startDate : '2021-11-26', duration : 2, percentDone : 20 },\n        //            { id : 400, name : 'Task 400', startDate : '2021-11-24', duration : 2, percentDone : 10 },\n        //            { id : 200, name : 'Task 200', startDate : '2021-11-22', duration : 6, percentDone : 10 }\n        //        ]\n        //    }]\n        // }\n        //\n        // Becomes the following. Note that all records are sorted into ascending\n        // order of their field values:\n        //\n        // rootNode : {\n        //    children : [{\n        //        id       : '10',\n        //        key      : 10,\n        //        expanded : true,\n        //        children : [\n        //            {\n        //                id       : '10Mon Nov 22 2021 00:00:00 GMT+0100 (Central European Standard Time)',\n        //                key      : new Date(2021, 10, 22),\n        //                expanded : true,\n        //                children : [\n        //                    { id : 100, name : 'Task 100', startDate : '2021-11-22', duration : 5, percentDone : 10 },\n        //                    { id : 200, name : 'Task 200', startDate : '2021-11-22', duration : 6, percentDone : 10 }\n        //                ]\n        //            },\n        //            {\n        //                id       : '10Wed Nov 24 2021 00:00:00 GMT+0100 (Central European Standard Time)',\n        //                key      : new Date(2021, 10, 24),\n        //                expanded : true,\n        //                children : [\n        //                    { id : 300, name : 'Task 300', startDate : '2021-11-24', duration : 3, percentDone : 10 },\n        //                    { id : 400, name : 'Task 400', startDate : '2021-11-24', duration : 2, percentDone : 10 }\n        //                ]\n        //            }\n        //        ]\n        //    },\n        //    {\n        //        id       : '20',\n        //        key      : 20,\n        //        expanded : true,\n        //        children : [\n        //            {\n        //                id       : '20Mon Nov 22 2021 00:00:00 GMT+0100 (Central European Standard Time)',\n        //                key      : new Date(2021, 10, 22),\n        //                expanded : true,\n        //                children : [\n        //                    { id : 500, name : 'Task 500', startDate : '2021-11-22', duration : 5, percentDone : 20 },\n        //                    { id : 600, name : 'Task 600', startDate : '2021-11-22', duration : 6, percentDone : 20 }\n        //                ]\n        //            },\n        //            {\n        //                id       : '20Fri Nov 26 2021 00:00:00 GMT+0100 (Central European Standard Time)',\n        //                key      : new Date(2021, 10, 26),\n        //                expanded : true,\n        //                children : [\n        //                    { id : 700, name : 'Task 700', startDate : '2021-11-26', duration : 3, percentDone : 20 },\n        //                    { id : 800, name : 'Task 800', startDate : '2021-11-26', duration : 2, percentDone : 20 }\n        //                ]\n        //            }\n        //        ]\n        //    }]\n        // }\n        //\n        // Convert field definitions to a function which extracts the field]\n        // for a simpler field value extraction.\n        for (i = 0; i < length; i++) {\n            if (!fields[i].call) {\n                const field = fields[i];\n                fields[i] = n => n[field];\n            }\n            parents[i] = new Map();\n        }\n        this.rootNode.traverse(n => {\n            lastParent = null;\n            if (n.isLeaf) {\n                for (i = 0; i < length; i++) {\n                    const\n                        lastParentPath = lastParent?.path || '',\n                        nodeMap        = parents[i],\n                        key            = fields[i](n),\n                        path           = `${lastParentPath + key}/`,\n                        id             = StringHelper.makeValidDomId(`generated_${path}`, '_'),\n                        parent         = nodeMap.get(id) || (nodeMap.set(id, {\n                            id,\n                            key,\n                            path,\n                            expanded        : true,\n                            readOnly        : true,\n                            children        : [],\n                            generatedParent : true\n                        })).get(id);\n                    if (lastParent && !lastParent.children.includes(parent)) {\n                        lastParent.children.push(parent);\n                    }\n                    lastParent = parent;\n                }\n                lastParent.children.push(n);\n            }\n        }, true);\n        // Call the optional transformer, and if we are configured to do so,\n        // convert the new branches into TreeNodes.\n        parents.forEach(p => p.forEach((p, id, map) => {\n            parentTransform?.(p);\n            if (convertParents) {\n                p = this.createRecord(p);\n                map.set(id, p);\n            }\n        }));\n        newRoot.children = [...parents[0].values()];\n        // Cascade a sort down so that all \"groups\" are in order.\n        const sort = (n) => {\n            if (n.children) {\n                n.children.sort((lhs, rhs) => {\n                    // If it's a leaf, sort by comparing all \"fields\"\n                    if (lhs.isLeaf) {\n                        let result;\n                        for (let i = 0; !result && i < length; i++) {\n                            const\n                                lv = fields[i](lhs),\n                                rv = fields[i](rhs);\n                            result = lv < rv ? -1 : rv > lv ? 1 : 0;\n                        }\n                        return result;\n                    }\n                    // Sort branch nodes by their key values\n                    else {\n                        // Sort numbers in strings nicely\n                        if (typeof lhs.key === 'string' || typeof rhs.key === 'string') {\n                            return lhs.key.localeCompare(rhs.key, undefined, { numeric : true });\n                        }\n                        return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;\n                    }\n                });\n                n.children.forEach(sort);\n            }\n        };\n        sort(newRoot);\n        return newRoot;\n    }\n    //endregion\n    treeifyFlatData(data) {\n        const { childrenField, parentIdField } = this.modelClass;\n        let hasParentId     = false,\n            shouldTransform = true;\n        // Configured to transform flat data into tree data, make sure that we have:\n        // - raw data without children defined\n        // - parentIds\n        for (const node of data) {\n            if (node.isModel || Array.isArray(node[childrenField])) {\n                shouldTransform = false;\n                break;\n            }\n            if (node[parentIdField] != null) {\n                hasParentId = true;\n            }\n        }\n        if (shouldTransform && hasParentId) {\n            data = this.transformToTree(data);\n        }\n        return data;\n    }\n    /**\n     * Increase the indentation level of one or more nodes in the tree\n     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.\n     * @fires indent\n     * @fires change\n     */\n    async indent(nodes) {\n        const me = this;\n        nodes = Array.isArray(nodes) ? nodes : [nodes];\n        // 2. Filtering out all nodes which parents are also to be indented as well as the ones having no previous\n        //    sibling since such nodes can't be indented\n        nodes = nodes.filter(node => {\n            let result = Boolean(node.previousSibling);\n            while (result && !node.isRoot) {\n                result = !nodes.includes(node.parent);\n                node   = node.parent;\n            }\n            return result;\n        });\n        /**\n         * Fired before nodes in the tree are indented. Return `false` from a listener to prevent the indent.\n         * @event beforeIndent\n         * @preventable\n         * @param {Core.data.Store} source The store\n         * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.\n         */\n        if (nodes.length && me.trigger('beforeIndent', { records : nodes }) !== false) {\n            // 3. Sorting nodes into tree walk order\n            nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));\n            // No events should go to the UI until we have finished the operation successfully\n            me.beginBatch();\n            // Ask the project to try the indent operation\n            for (const node of nodes) {\n                const newParent = node.previousSibling;\n                newParent.appendChild(node);\n                me.toggleCollapse(newParent, false);\n            }\n            // Now show the successful result\n            me.endBatch();\n            /**\n             * Fired after tasks in the tree are indented\n             * @event indent\n             * @param {Core.data.Store} source The store\n             * @param {Core.data.Model[]} records Nodes that were indented\n             */\n            me.trigger('indent', { records : nodes });\n            me.trigger('change', {\n                action  : 'indent',\n                records : nodes\n            });\n        }\n    }\n    /**\n     * Decrease the indentation level of one or more nodes in the tree\n     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to outdent.\n     * @fires outdent\n     * @fires change\n     */\n    async outdent(nodes) {\n        const me = this;\n        nodes = Array.isArray(nodes) ? nodes : [nodes];\n        // 2. Filtering out all nodes which parents are also to be outdented as well as the ones having no previous sibling\n        //    since such nodes can't be indented\n        nodes = nodes.filter(node => {\n            const { parent } = node;\n            let result       = parent && !parent.isRoot;\n            while (result && !node.isRoot) {\n                result = !nodes.includes(parent);\n                node   = node.parent;\n            }\n            return result;\n        });\n        /**\n         * Fired before nodes in the tree are outdented. Return `false` from a listener to prevent the outdent.\n         * @event beforeOutdent\n         * @preventable\n         * @param {Core.data.Store} source This store\n         * @param {Core.data.Model[]} records Nodes to be outdented\n         */\n        if (nodes.length && me.trigger('beforeOutdent', { records : nodes }) !== false) {\n            // 3. Sorting nodes into reverse tree walk order\n            nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));\n            // No events should go to the UI until we have finished the operation successfully\n            me.beginBatch();\n            for (const node of nodes) {\n                const\n                    { parent }  = node,\n                    newChildren = parent.children.slice(parent.children.indexOf(node) + 1);\n                parent.parent.insertChild(node, parent.nextSibling);\n                node.appendChild(newChildren);\n                me.toggleCollapse(node, false);\n            }\n            me.endBatch();\n            /**\n             * Fired after tasks in the tree are outdented\n             * @event outdent\n             * @param {Core.data.Store} source The store\n             * @param {Core.data.Model[]} records Nodes that were outdented\n             */\n            me.trigger('outdent', { records : nodes });\n            me.trigger('change', {\n                action  : 'outdent',\n                records : nodes\n            });\n        }\n    }\n};\n", "/**\n * @module Core/helper/WalkHelper\n */\n/**\n * Tree walking helper\n * @internal\n */\nexport default class WalkHelper {\n    /**\n     * Pre-walks any hierarchical data structure\n     *\n     * @param {Object} data Walking starting point\n     * @param {Function} childrenFn Function to return `data` children entries in an array\n     *                   or null if no children exists for the entry\n     * @param {Function} fn Function to call on each entry\n     */\n    static preWalk(data, childrenFn, fn) {\n        const walkStack = [data];\n        let node, children;\n        while (walkStack.length) {\n            node = walkStack.pop();\n            fn(node);\n            children = childrenFn(node);\n            if (children) {\n                walkStack.push.apply(walkStack, children.slice().reverse());\n            }\n        }\n    }\n    /**\n     * Pre-walks any hierarchical data structure, passing along a link to the parent node\n     *\n     * @param {Object} data Walking starting point\n     * @param {Function} childrenFn Function to return `data` children entries in an array\n     *                   or null if no children exists for the entry\n     * @param {Function} fn Function to call on each entry, called with `parent` and `node`\n     */\n    static preWalkWithParent(data, childrenFn, fn) {\n        const walkStack = [{ node : data, parent : null }];\n        while (walkStack.length) {\n            const { parent, node } = walkStack.pop();\n            fn(parent, node);\n            const children = childrenFn(node);\n            if (Array.isArray(children)) {\n                walkStack.push(...children.slice().reverse().map(child => ({ node : child, parent : node })));\n            }\n        }\n    }\n    /**\n     * Pre-walk unordered.\n     *\n     * Like {@link #function-preWalk-static} but doesn't reverse children before walk,\n     * thus children will be walked last child first - first child last\n     *\n     * @param {Object} data Walking starting point\n     * @param {Function} childrenFn Function to return `data` children entries in an array\n     *                   or null if no children exists for the entry\n     * @param {Function} fn Function to call on each entry\n     */\n    static preWalkUnordered(data, childrenFn, fn) {\n        const walkStack = [data];\n        let node, children;\n        while (walkStack.length) {\n            node = walkStack[walkStack.length - 1];\n            fn(node);\n            children = childrenFn(node);\n            if (children) {\n                walkStack.splice(walkStack.length - 1, 1, ...children);\n            }\n            else {\n                walkStack.length = walkStack.length - 1;\n            }\n        }\n    }\n    /**\n     * Post-walks any hierarchical data structure\n     *\n     * @param {Object} data Walking starting point\n     * @param {Function} childrenFn Function to return `data` children entries in an array\n     *                   or null if no children exists for the entry\n     * @param {Function} fn Function to call on each entry\n     */\n    static postWalk(data, childrenFn, fn) {\n        const\n            visited = new Map(),\n            walkStack = [data];\n        let node, children;\n        while (walkStack.length) {\n            node = walkStack[walkStack.length - 1];\n            if (visited.has(node)) {\n                fn(node);\n                walkStack.pop();\n            }\n            else {\n                children = childrenFn(node);\n                if (children) {\n                    walkStack.push(...children.slice().reverse());\n                }\n                visited.set(node, node);\n            }\n        }\n    }\n    /**\n     * Pre-/Post-walks any hierarchical data structure calling inFn each node when it walks in,\n     * and outFn when it walks out.\n     *\n     * @param {Object} data Walking starting point\n     * @param {Function} childrenFn Function to return `data` children entries in an array\n     *                   or null if no children exists for the entry\n     * @param {Function} inFn  Function to call on each entry upon enter\n     * @param {Function} outFn Function to call on each entry upon exit\n     */\n    static prePostWalk(data, childrenFn, inFn, outFn) {\n        const\n            visited = new Map(),\n            walkStack = [data];\n        let node, children;\n        while (walkStack.length) {\n            node = walkStack[walkStack.length - 1];\n            if (visited.has(node)) {\n                outFn(node);\n                walkStack.pop();\n            }\n            else {\n                inFn(node);\n                children = childrenFn(node);\n                if (children) {\n                    walkStack.push(...children.slice().reverse());\n                }\n                visited.set(node, node);\n            }\n        }\n    }\n}\nWalkHelper._$name = 'WalkHelper';", "import Base from '../../Base.js';\nimport WalkHelper from '../../helper/WalkHelper.js';\n/**\n * @module Core/data/mixin/StoreSync\n */\n/**\n * Options available when supplying a config object to the `syncDataOnLoad` config.\n * @typedef {Object} SyncDataOnLoadOptions\n * @property {Boolean} [keepMissingValues] How to handle values for missing fields, see\n * {@link Core/data/Store#config-syncDataOnLoad}\n * @property {String|Number} [threshold] Threshold above which events are batched, see\n * {@link Core/data/Store#config-syncDataOnLoad}\n */\n/**\n * Mixin that allows Store to sync a new dataset with its existing records, instead of fully replacing everything.\n * Configure Store with `syncDataOnLoad: true` to activate the functionality. Sync is performed when a new dataset\n * is loaded, either by directly assigning it to `store.data` or by loading it using Ajax (if using an AjaxStore).\n *\n * ```javascript\n * const store = new Store({\n *   syncDataOnLoad : true,\n *   data           : [\n *     { id : 1, name : 'Saitama' },\n *     { id : 2, name : 'Genos' },\n *     { id : 3, name : 'Mumen Rider' }\n *   ]\n * });\n *\n * // Sync a new dataset by assigning to data:\n * store.data = [\n *   { id : 1, name : 'Caped Baldy' },\n *   { id : 4, name : 'Horse-Bone' }\n * ];\n *\n *  // Result : Record 1 updated, record 2 & 3 removed, record 4 added\n * ```\n *\n * For more details, please see {@link #config-syncDataOnLoad}.\n *\n * @mixin\n */\nexport default Target => class StoreSync extends (Target || Base) {\n    static get $name() {\n        return 'StoreSync';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.\n             *\n             * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset\n             * with a new one, creating all new records:\n             *\n             * ```javascript\n             * store.data = [ { id : 1, name : 'Saitama' } ];\n             *\n             * const first = store.first;\n             *\n             * store.data = [ { id : 1, name : 'One-Punch man' } ];\n             *\n             * // store.first !== first;\n             * ```\n             *\n             * When configured with `true` the new dataset is instead synced against the old, figuring out what was\n             * added, removed and updated:\n             *\n             * ```javascript\n             * store.data = [ { id : 1, name : 'Saitama' } ];\n             *\n             * const first = store.first;\n             *\n             * store.data = [ { id : 1, name : 'One-Punch man' } ];\n             *\n             * // store.first === first;\n             * ```\n             *\n             * After the sync, any configured sorters, groupers and filters will be reapplied.\n             *\n             * #### Threshold\n             *\n             * The sync operation has a configurable threshold, above which the operation will be treated as a\n             * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events\n             * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,\n             * supply a config object with a `threshold` property instead of `true`:\n             *\n             * ```javascript\n             * const store = new Store({\n             *     syncDataOnLoad : {\n             *         threshold : '20%'\n             *     }\n             * });\n             * ```\n             *\n             * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a\n             * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold\n             * is used.\n             *\n             * #### Missing fields\n             *\n             * The value of any field not supplied in the new dataset is by default kept as is (if record is not removed\n             * by the sync). This behaviour is configurable, by setting `keepMissingValues : false` in a config object\n             * it will reset any unspecified field back to their default values:\n             *\n             * ```javascript\n             * const store = new Store({\n             *     syncDataOnLoad : {\n             *         keepMissingValues : false\n             *     }\n             * });\n             * ```\n             *\n             * Considering the following sync operation:\n             *\n             * ```javascript\n             * // Existing data\n             * { id : 1, name : 'Saitama', powerLevel : 100 }\n             * // Sync data\n             * { id : 1, name : 'One-Punch Man' }\n             * ```\n             *\n             * The result would by default (or when explicitly configured with `true`)  be:\n             *\n             * ```javascript\n             * { id : 1, name : 'One-Punch Man', powerLevel : 100 }\n             * ```\n             *\n             * If configured with `keepMissingValues : false` it would instead be:\n             *\n             * ```javascript\n             * { id : 1, name : 'One-Punch Man' }\n             * ```\n             *\n             * <div class=\"note\">Never enable `syncDataOnLoad` on a chained store, it will create an infinite loop when\n             * it is populated from the main store (the main store can use the setting)</div>\n             *\n             * @config {Boolean|SyncDataOnLoadOptions} syncDataOnLoad\n             * @default false\n             * @category Common\n             */\n            syncDataOnLoad : null,\n            shouldSyncDataset : null,\n            shouldSyncRecord  : null\n        };\n    }\n    /**\n     * Syncs a new dataset against the already loaded one, only applying changes.\n     * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to\n     * `store.data` as usual instead.\n     *\n     * ```\n     * const store = new Store({\n     *    syncDataOnLoad : true,\n     *    data : [\n     *        // initial data\n     *    ]\n     * });\n     *\n     * store.data = [ // new data ]; //  Difference between initial data and new data will be applied\n     * ```\n     *\n     * @param {Object[]|Core.data.Model[]} data New dataset, an array of records or data objects\n     * @private\n     */\n    syncDataset(data) {\n        const\n            me          = this,\n            { storage } = me,\n            // Allow app to determine if sync should be performed, and/or for which records. It might have better\n            // knowledge of the data to make a cheaper decision\n            idsToCheck  = me.shouldSyncDataset?.({ data });\n        if (idsToCheck === false) {\n            return;\n        }\n        me.isSyncingDataOnLoad = true;\n        const { toAdd, toRemove, toMove, updated, ids } = me.tree ? me.syncTreeDataset(data, idsToCheck) : me.syncFlatDataset(data, idsToCheck);\n        let { threshold } = me.syncDataOnLoad,\n            surpassed = false;\n        // Check if threshold is surpassed\n        if (threshold) {\n            // Any string is treated as a percentage\n            if (typeof threshold === 'string') {\n                threshold = parseInt(threshold, 10) / 100 * me.count;\n            }\n            surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;\n        }\n        if (me.tree) {\n            // Flat data is spliced into/out of the collection, but in a tree it has to be added/removed from store\n            // to end up on correct parents\n            if (toAdd.length) {\n                // Add all new nodes in one go, will be added to correct parent using `parentId`. Triggering multiple times\n                const added = me.add(toAdd, surpassed);\n                // parentId was tucked on in syncTreeDataset() to allow the single flat add above, clean it out\n                added.forEach(node => node.clearParentId());\n            }\n            if (toMove.length) {\n                for (const { parent, node, index } of toMove) {\n                    const newParent = me.getById(parent.id);\n                    newParent.insertChild(node, index);\n                }\n            }\n            // Remove in one go, removing from each parent. Triggering multiple times\n            me.remove(toRemove, surpassed);\n        }\n        else {\n            if (surpassed) {\n                me.suspendEvents();\n            }\n            // Add and remove, will trigger if below threshold/no threshold\n            // We cannot simply splice into our Collection because of the extra\n            // processing various Store mixins do in add and remove implementations\n            me.remove(toRemove);\n            me.add(toAdd);\n            if (surpassed) {\n                me.resumeEvents();\n            }\n        }\n        // Trigger updates if using threshold, but have not surpassed it. If threshold is not used, the updates\n        // are triggered when data is set (avoiding another iteration)\n        if (threshold && !surpassed) {\n            updated.forEach(({ record, toSet, wasSet }) => me.onModelChange(record, toSet, wasSet));\n        }\n        // Clear change-tracking\n        me.acceptChanges();\n        const event = { added : toAdd, removed : toRemove, updated, thresholdSurpassed : surpassed };\n        if (me.isFiltered && !me.remoteFilter) {\n            // Apply filtering to the next dataset if filtering is local\n            me.filter({\n                silent : me.isRemoteDataLoading\n            });\n        }\n        if (me.isGrouped) {\n            // Announced group\n            me.group(null, null, false, true, me.isRemoteDataLoading);\n        }\n        else if (me.isSorted) {\n            // If we updated records in-place, the order may not match what we sent to\n            // the server, so silently sort the collection according to our sorters.\n            if (me.remoteSort) {\n                storage.replaceValues({\n                    values : storage.values.sort(me.createSorterFn(me.sorters)),\n                    silent : true\n                });\n            }\n            // If we are sorting locally, just do a normal sort\n            else {\n                me.sort();\n            }\n        }\n        // Neither grouped nor sorted, match order in incoming data\n        else if (!me.tree) {\n            // Only bother if data isn't already in order (to avoid unnecessary re-rendering)\n            if (storage.values.some((record, index) => record.id !== ids[index])) {\n                storage.replaceValues({\n                    values : storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),\n                    silent : true\n                });\n                // Announce the sort, unless we will refresh below\n                !surpassed && me.afterPerformSort();\n            }\n        }\n        // Ditto, but not flat data\n        else {\n            let unsorted = false,\n                i = 0;\n            WalkHelper.preWalk(\n                me.rootNode,\n                n => Array.isArray(n.children) && !unsorted ? n.children : null,\n                node => {\n                    if (node.id !== ids[i++]) {\n                        unsorted = true;\n                    }\n                }\n            );\n            // Only bother if data isn't already in order (to avoid unnecessary re-rendering)\n            if (unsorted) {\n                me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), undefined, undefined, true);\n                me.clearSorters(true);\n                // Announce the sort, unless we will refresh below\n                !surpassed && me.afterPerformSort();\n            }\n        }\n        // Trigger `batch` if threshold is surpassed, more similar to a batch than a full `dataset`\n        if (surpassed) {\n            me.trigger('refresh', {\n                action   : 'batch',\n                data,\n                records  : storage.values,\n                syncInfo : event\n            });\n        }\n        me.isSyncingDataOnLoad = false;\n        me.trigger('loadSync', event);\n    }\n    // Used by syncDataset()\n    syncFlatDataset(data, idsToCheck) {\n        if (!data) {\n            return {\n                toRemove : this.records\n            };\n        }\n        const\n            me                     = this,\n            { idField, allFields } = me.modelClass,\n            toRemove               = [],\n            toAdd                  = [],\n            updated                = [],\n            usedIds                = {},\n            ids                    = [],\n            limitedSet             = Array.isArray(idsToCheck);\n        const { threshold, keepMissingValues } = me.syncDataOnLoad;\n        let hitCount = 0;\n        data.forEach(rawData => {\n            rawData = rawData.isModel ? rawData.data : rawData;\n            const\n                id     = rawData[idField],\n                record = me.getById(id);\n            // Only bother checking for changes if not passed a specific set of ids to check, or if the id is in the set\n            if (!limitedSet || idsToCheck.includes(id)) {\n                // Record exists, might be an update\n                if (record) {\n                    // Allow app to determine if sync should be performed, it might have better knowledge of the data to\n                    // make a cheaper decision\n                    if (me.shouldSyncRecord?.({ record, data : rawData }) !== false) {\n                        // Apply default value for any missing fields if configured to do so\n                        if (keepMissingValues === false) {\n                            for (const field of allFields) {\n                                if (!(field.dataSource in rawData) && (field.dataSource in record.data)) {\n                                    rawData[field.dataSource] = field.defaultValue;\n                                }\n                            }\n                        }\n                        // Update silently if using threshold, otherwise trigger away\n                        const wasSet = record.set(rawData, null, Boolean(threshold));\n                        if (wasSet) {\n                            updated.push({\n                                record,\n                                wasSet,\n                                toSet : rawData\n                            });\n                        }\n                    }\n                }\n                // Does not exist, add\n                else {\n                    toAdd.push(me.processRecord(me.createRecord(rawData)));\n                }\n            }\n            if (record) {\n                hitCount++;\n            }\n            usedIds[id] = 1;\n            ids.push(id);\n        });\n        // Check removals, unless all records were visited above\n        if (hitCount < me.storage.totalCount) {\n            // If given a set of ids that should be checked, limit removals to those. Any id not represented in the new\n            // dataset will be removed\n            if (idsToCheck) {\n                for (const id of idsToCheck) {\n                    if (!usedIds[id]) {\n                        toRemove.push(me.getById(id));\n                    }\n                }\n            }\n            // Otherwise, check all records\n            else {\n                me.forEach(record => {\n                    if (!usedIds[record.id]) {\n                        toRemove.push(record);\n                    }\n                });\n            }\n        }\n        return { toAdd, toRemove, toMove : [], updated, ids };\n    }\n    // Used by syncDataset()\n    syncTreeDataset(data) {\n        if (!data) {\n            return {\n                toRemove : this.records\n            };\n        }\n        const\n            me           = this,\n            {\n                idField,\n                parentIdField,\n                childrenField,\n                allFields\n            }            = me.modelClass,\n            {\n                keepMissingValues,\n                threshold\n            }            = me.syncDataOnLoad,\n            toRemove     = [],\n            toAdd        = [],\n            toMove       = [],\n            updated      = [],\n            matchedNodes = new Set(),\n            ids          = [];\n        if (me.transformFlatData) {\n            data = me.treeifyFlatData(data);\n        }\n        WalkHelper.preWalkWithParent({ isRoot : true, id : me.rootNode.id, children : data }, n => n.children, (parent, rawData) => {\n            if (parent) {\n                const { id, node } = me.resolveSyncNode(rawData);\n                // Record exists, might be an update\n                if (node) {\n                    // Allow app to determine if sync should be performed, it might have better knowledge of the data to\n                    // make a cheaper decision\n                    if (me.shouldSyncRecord?.({ record : node, data : rawData }) !== false) {\n                        let childrenUpdated;\n                        const oldChildrenValue = node.children;\n                        // Edge case: Check for conversion from normal parent to lazy loaded\n                        if (oldChildrenValue !== true && rawData[childrenField] === true) {\n                            node.clearChildren();\n                            node.data[childrenField] = node.children = true;\n                            delete rawData[childrenField];\n                            me.toggleCollapse(node, true);\n                            childrenUpdated = true;\n                        }\n                        // Changed parent?\n                        if (node.parent.id !== parent[idField]) {\n                            toMove.push({\n                                node,\n                                parent,\n                                index : parent[childrenField].indexOf(rawData)\n                            });\n                        }\n                        // parentIdField has no default value to not pollute flat data,\n                        // assign to root here if no value specified\n                        // else if (parent.isRoot && !(parentIdField in rawData)) {\n                        //     rawData[parentIdField] = null;\n                        // }\n                        // Apply default value for any missing fields if configured to do so\n                        if (keepMissingValues === false) {\n                            for (const field of allFields) {\n                                // Ignore parentId, handled above since it has no default\n                                if (field.name !== 'parentId' && !(field.dataSource in rawData) && (field.dataSource in node.data)) {\n                                    rawData[field.dataSource] = field.defaultValue;\n                                }\n                            }\n                        }\n                        // Update silently if using threshold, otherwise trigger away\n                        const wasSet = node.set(rawData, null, Boolean(threshold));\n                        if (wasSet) {\n                            updated.push({\n                                record : node,\n                                wasSet,\n                                toSet  : rawData\n                            });\n                        }\n                        else if (childrenUpdated) {\n                            node.signalNodeChanged({\n                                [childrenField] : {\n                                    value    : true,\n                                    oldValue : oldChildrenValue\n                                }\n                            });\n                        }\n                    }\n                }\n                // Does not exist, add\n                else {\n                    rawData[parentIdField] = parent[idField];\n                    toAdd.push({ ...rawData, ...(Array.isArray(rawData[childrenField]) ? { children : [] } : undefined) });\n                }\n                matchedNodes.add(node);\n                ids.push(id);\n            }\n        });\n        if (matchedNodes.length !== data.length) {\n            me.traverse(node => {\n                if (!matchedNodes.has(node)) {\n                    toRemove.push(node);\n                }\n            });\n        }\n        return { toAdd, toRemove, toMove, updated, ids };\n    }\n    // ColumnStore overrides this fn to allow syncing by field & type\n    resolveSyncNode(rawData) {\n        const\n            id   = rawData[this.modelClass.idField],\n            node = this.getById(id);\n        return { id, node };\n    }\n};\n", "/**\n * @module Core/data/stm/mixin/StoreStm\n */\nimport Base from '../../../Base.js';\nimport Model from '../../../data/Model.js';\nconst STM_PROP = Symbol('STM_PROP');\n/**\n * Store mixin to make it compatible with {@link Core/data/stm/StateTrackingManager}.\n * @mixin\n */\nexport default Target => class StoreStm extends (Target || Base) {\n    static get $name() {\n        return 'StoreStm';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to STM manager\n             *\n             * @config {Core.data.stm.StateTrackingManager}\n             * @default\n             * @category Advanced\n             */\n            stm : null,\n            /**\n             * Set false, to not record transaction during `applyChangeset` call\n             *\n             * @prp {Boolean}\n             * @default\n             */\n            ignoreRemoteChangesInSTM : false\n        };\n    }\n    get stm() {\n        return this[STM_PROP];\n    }\n    set stm(stm) {\n        const me = this;\n        if (me.stm !== stm) {\n            if (me.stm?.hasStore(me)) {\n                me.stm.removeStore(me);\n            }\n            me[STM_PROP] = stm;\n            if (me.stm && !me.stm.hasStore(me)) {\n                me.stm.addStore(me);\n            }\n        }\n    }\n    // Overridden to notify STM about flat add action\n    add(records, silent = false, options = {}) {\n        let result;\n        const { stm } = this;\n        // Tree adding is routed via rootNode.appendChild() it has it's own\n        // STM override thus if the store is tree we ignore the action\n        if (!this.tree && stm?.enabled) {\n            // Flat adding here only, the only data needed to undo/redo the action\n            // is the list of records added.\n            result = super.add(records, silent);\n            // If adding wasn't vetoed and something has been added then\n            // notifying the STM about the fact.\n            if (result?.length) {\n                stm.onStoreModelAdd(this, result, silent);\n            }\n        }\n        else {\n            result = super.add(records, silent, options);\n        }\n        return result;\n    }\n    // Overridden to notify STM about flat insert action\n    insert(index, records, silent = false) {\n        let result;\n        const { stm } = this;\n        // Tree inserting is routed via rootNode.insertChild() it has it's own\n        // STM override thus if the store is tree we ignore the action\n        if (!this.tree && stm?.enabled) {\n            // Flat inserting here only, the only data needed to undo/redo the action is:\n            // - the list of record inserted\n            // - index they are inserted at\n            // - index they have been at if they are part of this store already and are moved\n            // Here we are getting indices of records which are in this store already\n            // not all records might be from this store, some might be new or from another store\n            const context = (Array.isArray(records) ? records : [records]).reduce(\n                (context, r) => {\n                    const index = r instanceof Model ? this.indexOf(r) : undefined;\n                    if (index !== undefined && index !== -1) {\n                        context.set(r, index);\n                    }\n                    return context;\n                },\n                new Map()\n            );\n            // Result here is the array of Models inserted or undefined,\n            // and it might be different from `records` we received as argument.\n            result = super.insert(index, records);\n            // Here we check if anything has been actually inserted.\n            // The insertion action might be vetoed by event handler or something\n            if (result?.length) {\n                // We can't rely on `index` we've got as argument since `result` might\n                // differ from records.\n                index = this.indexOf(result[0]);\n                // Notifying STM manager about the insertion action providing all\n                // the required data to undo/redo.\n                stm.onStoreModelInsert(this, index, result, context, silent);\n            }\n        }\n        else {\n            result = super.insert(index, records, silent);\n        }\n        return result;\n    }\n    // Overridden to notify STM about flat removing action\n    remove(recordsOrIds, silent = false, fromRemoveChild) {\n        let result;\n        const { stm } = this;\n        // Tree removing is routed via rootNode.removeChild() it has it's own\n        // STM override thus if the store is tree we ignore the action\n        if (!this.tree && stm?.enabled) {\n            // Flat removing here only, the only date needed to undo/redo the actions is:\n            // - the list of records removed\n            // - their original index to re-insert them back correctly\n            const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map(r => this.getById(r)).filter(r => !!r);\n            const context = recordsOrIdsNormalized.reduce(\n                (context, r) => {\n                    const index = this.indexOf(r);\n                    if (index !== undefined && index !== -1) {\n                        context.set(r, index);\n                    }\n                    return context;\n                },\n                new Map()\n            );\n            // Calling original store method\n            result = super.remove(recordsOrIds, silent, fromRemoveChild);\n            // Here we check if anything has been actually removed.\n            // The removing action might be vetoed by event handler or something\n            if (result?.length) {\n                stm.onStoreModelRemove(this, result, context, silent);\n            }\n        }\n        else {\n            result = super.remove(recordsOrIds, silent, fromRemoveChild);\n        }\n        return result;\n    }\n    // Overridden to notify STM about flat clear action\n    removeAll(silent) {\n        const { stm } = this;\n        let result;\n        if (stm?.enabled) {\n            // Here we are to detect if anything has been removed\n            // the only way is to check if store has anything before removing all\n            // and has nothing after.\n            const\n                { tree, rootNode, allRecords } = this,\n                wasNotEmpty                    = allRecords.length,\n                // need to store children/records before super method call, otherwise those would report empty list\n                records                        = tree ? rootNode.children.slice() : allRecords.slice();\n            result = super.removeAll(silent);\n            // The trick here is to distinguish tree and flat case\n            // For the flat case it's simple we just store all records\n            // For the tree we are to store root node children only\n            // Upon restoring store.add() will do the right thing for the flat case and tree case regardless.\n            if (wasNotEmpty && this.count === 0) {\n                stm.onStoreRemoveAll(this, records, silent);\n            }\n        }\n        else {\n            result = super.removeAll(silent);\n        }\n        return result;\n    }\n    beforeApplyChangeset() {\n        const { stm, crudManager } = this;\n        let shouldResume = false;\n        if (!crudManager?.applyingChangeset && stm?.enabled) {\n            shouldResume = true;\n            // If stm is recording at the moment, we need to stash changes and reject them\n            if (stm.isRecording) {\n                stm.stash();\n            }\n            if (this.ignoreRemoteChangesInSTM) {\n                stm.disable();\n            }\n            else {\n                stm.startTransaction();\n            }\n        }\n        return shouldResume;\n    }\n    // When applying changes while STM is in the recording state, first we need to discard local changes, then apply\n    // changes from remote, then try to apply local changes. This would emulate starting transaction as if data was\n    // already in the correct state\n    applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {\n        const\n            shouldResume = this.beforeApplyChangeset(),\n            log          = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);\n        this.afterApplyChangeset(shouldResume);\n        return log;\n    }\n    afterApplyChangeset(shouldResume) {\n        if (shouldResume) {\n            const { stm } = this;\n            if (this.ignoreRemoteChangesInSTM) {\n                stm.enable();\n            }\n            else {\n                stm.stopTransaction();\n            }\n            stm.applyStash();\n        }\n    }\n};\n", "import Base from '../Base.js';\nimport Pluggable from '../mixin/Pluggable.js';\nimport Events from '../mixin/Events.js';\nimport State from '../mixin/State.js';\nimport Identifiable from '../mixin/Identifiable.js';\nimport Model from './Model.js';\nimport BrowserHelper from '../helper/BrowserHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport StoreBag from './StoreBag.js';\nimport Collection from '../util/Collection.js';\nimport StoreCRUD from './mixin/StoreCRUD.js';\nimport StoreChanges from './mixin/StoreChanges.js';\nimport StoreFilter from './mixin/StoreFilter.js';\nimport StoreGroup from './mixin/StoreGroup.js';\nimport StoreProxy from './mixin/StoreProxy.js';\nimport StoreRelation from './mixin/StoreRelation.js';\nimport StoreSum from './mixin/StoreSum.js';\nimport StoreSearch from './mixin/StoreSearch.js';\nimport StoreSort from './mixin/StoreSort.js';\nimport StoreChained from './mixin/StoreChained.js';\nimport StoreState from './mixin/StoreState.js';\nimport StoreTree from './mixin/StoreTree.js';\nimport StoreSync from './mixin/StoreSync.js';\nimport StoreStm from './stm/mixin/StoreStm.js';\nimport Delayable from '../mixin/Delayable.js';\n/**\n * @module Core/data/Store\n */\nconst\n    dataAddRemoveActions   = {\n        splice : 1,\n        clear  : 1\n    },\n    defaultTraverseOptions = {\n        includeFilteredOutRecords    : false,\n        includeCollapsedGroupRecords : false\n    },\n    fixTraverseOptions     = (store, options) => {\n        // backward compatibility to support includeFilteredOutRecords parameter instead of options\n        options = options || false;\n        if (typeof options === 'boolean') {\n            options = {\n                includeFilteredOutRecords    : options,\n                includeCollapsedGroupRecords : false\n            };\n        }\n        return options || defaultTraverseOptions;\n    };\n/**\n * The Store represents a data container which holds flat data or tree structures. An item in the Store is often called\n * a \u00B4record\u00B4 and it is simply an instance of the {@link Core.data.Model} (or any subclass thereof).\n *\n * Typically you load data into a store to display it in a Grid or a ComboBox. The Store is the backing data component\n * for any component that is showing data in a list style UI.\n *\n * ## Data format\n * Data is store in a JSON array the Store offers an API to edit, filter, group and sort the records.\n *\n * ## Store with flat data\n * To create a flat store simply provide an array of objects that describe your records\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         { id : 1, name : 'ABBA', country : 'Sweden' },\n *         { id : 2, name : 'Beatles', country : 'UK' }\n *     ]\n * });\n *\n * // retrieve record by id\n * const beatles = store.getById(2);\n * ```\n *\n * ## Store with tree data\n * To create a tree store use `children` property for descendant records\n *\n * ```javascript\n * const store = new Store({\n *     tree: true,\n *     data : [\n *         { id : 1, name : 'ABBA', country : 'Sweden', children: [\n *             { id: 2, name: 'Agnetha' },\n *             { id: 3, name: 'Bjorn' },\n *             { id: 4, name: 'Benny' },\n *             { id: 5, name: 'Anni-Frid' }\n *         ]},\n *     ]\n * });\n *\n * // retrieve record by id\n * let benny = store.getById(4);\n * ```\n *\n * Optionally a tree store can consume a flat dataset with nodes that have a `parentId` property. By configuring the\n * store with `tree : true` and `transformFlatData : true`, the flat data is transformed into tree data:\n *\n * ```javascript\n * const store = new Store({\n *     tree              : true,\n *     transformFlatData : true,\n *     data              : [\n *         { id : 1, name : 'ABBA', country : 'Sweden' },\n *         { id : 2, name : 'Agnetha', parentId : 1 },\n *         { id : 3, name : 'Bjorn', parentId : 1 },\n *         { id : 4, name : 'Benny', parentId : 1 },\n *         { id : 5, name : 'Anni-Frid', parentId : 1 }\n *     ]\n * });\n * ```\n *\n * ### Retrieving and consuming JSON\n * For both flat stores or tree stores it is possible to retrieve the data of all records in JSON format:\n *\n * ```javascript\n * const jsonString = store.json;\n *\n * // or\n *\n * const jsonArray = store.toJSON();\n * ```\n *\n * To plug the JSON data back in later:\n *\n * ```javascript\n * store.data = JSON.parse(jsonString);\n *\n * // or\n *\n * store.data = jsonArray;\n * ```\n *\n * ## Sharing stores\n * You cannot directly share a Store between widgets, but the data in a Store can be shared. There are two different\n * approaches depending on your needs, sharing data and chaining stores:\n *\n * ### Shared data\n * To create 2 widgets that share data, you can create 2 separate stores and pass records of the first store as the\n * dataset of the second store.\n *\n * ```javascript\n * let combo1 = new Combo({\n *     appendTo : document.body,\n *     store    : new Store({\n *         data : [\n *             { id : 1, name : 'ABBA', country : 'Sweden' },\n *             { id : 2, name : 'Beatles', country : 'UK' }\n *         ]\n *     }),\n *     valueField   : 'id',\n *     displayField : 'name'\n * });\n *\n * let combo2 = new Combo({\n *     appendTo : document.body,\n *     store    : new Store({\n *         data : combo1.store.records\n *     }),\n *     valueField   : 'id',\n *     displayField : 'name'\n * });\n *\n * combo1.store.first.name = 'foo';\n * combo2.store.first.name; // \"foo\"\n * ```\n *\n * ### Chained stores\n * Another more powerful option to share data between widgets is to create {@link Core.data.mixin.StoreChained chained}\n * stores. The easiest way to create a chained store is to call {@link #function-chain} function.\n *\n * ```javascript\n * let combo1 = new Combo({\n *     appendTo : document.body,\n *     store    : new Store({\n *         data : [\n *             { id : 1, name : 'ABBA', country : 'Sweden' },\n *             { id : 2, name : 'Beatles', country : 'UK' }\n *         ]\n *     }),\n *     valueField   : 'id',\n *     displayField : 'name'\n * });\n *\n * let combo2 = new Combo({\n *     appendTo     : document.body,\n *     store        : combo1.store.chain(),\n *     valueField   : 'id',\n *     displayField : 'name'\n * });\n *\n * combo1.store.first.name = 'foo';\n * combo2.store.first.name; // \"foo\"\n * ```\n *\n * A chained store can optionally be created with a filtering function, to only contain a subset of the records from\n * the main store. In addition, the chained store will reflect record removals/additions to the master store, something\n * the shared data approach will not.\n *\n * ## Non-homogeneous data structures\n *\n * You can use different Model classes to represent the records in the store by overriding the {@link #function-createRecord}\n * method:\n *\n * ```javascript\n * const store = new Store ({\n *     modelClass : Gate,\n *     readUrl    : 'data/the-airport.json',\n *     autoLoad   : true,\n *     // The default model is a Gate (see above) and in this createRecord method, we can decide at runtime based\n *     // on the data which model class to use. This is useful when your record types aren't homogenous.\n *     createRecord(data) {\n *         let modelClass = this.modelClass;\n *         if (data.type === 'terminal') {\n *             modelClass = Terminal;\n *         }\n *         return new modelClass(data, this);\n *     }\n * },\n * ```\n *\n * @mixes Core/mixin/Events\n * @mixes Core/data/mixin/StoreFilter\n * @mixes Core/data/mixin/StoreChanges\n * @mixes Core/data/mixin/StoreCRUD\n * @mixes Core/data/mixin/StoreSum\n * @mixes Core/data/mixin/StoreSearch\n * @mixes Core/data/mixin/StoreSort\n * @mixes Core/data/mixin/StoreGroup\n * @mixes Core/data/mixin/StoreChained\n * @mixes Core/data/mixin/StoreState\n * @mixes Core/data/mixin/StoreRelation\n * @mixes Core/data/mixin/StoreTree\n * @mixes Core/data/stm/mixin/StoreStm\n * @mixes Core/data/mixin/StoreSync\n *\n * @extends Core/Base\n */\nexport default class Store extends Base.mixin(\n    Delayable,\n    Identifiable,\n    Events,\n    Pluggable,\n    State,\n    StoreFilter,\n    StoreChanges,\n    StoreCRUD,\n    StoreRelation, // Private\n    StoreSum,\n    StoreSearch,\n    StoreSort,\n    StoreGroup,\n    StoreChained,\n    StoreState,\n    StoreTree,\n    StoreStm,\n    StoreSync,\n    StoreProxy // Private for now, thus not mentioned in @mixes block above\n) {\n    //region Config & properties\n    static get $name() {\n        return 'Store';\n    }\n    static get properties() {\n        return {\n            relationCache         : {},\n            dependentStoreConfigs : new Map()\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Store's unique identifier.\n             *\n             * @member {String|Number} id\n             * @readonly\n             * @category Common\n             */\n            /**\n             * Store's unique identifier. When set the store is added to a store map accessible through\n             * `Store.getStore(id)`.\n             *\n             * @config {String|Number}\n             * @category Common\n             */\n            id : true,\n            /**\n             * Class used to represent records in the store, should be a subclass of {@link Core.data.Model}. Only\n             * applies when supplying data to the store (load, add), any supplied record instances are kept as is.\n             *\n             * ```javascript\n             * class MyModel extends Model {\n             *     static get fields() {\n             *         return [\n             *             'name',\n             *             'city',\n             *             'company'\n             *         ]\n             *     }\n             * }\n             *\n             * const store = new Store({\n             *     modelClass : MyModel,\n             *     data : [\n             *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },\n             *         ...\n             *     ]\n             * });\n             * ```\n             *\n             * @config {Core.data.Model}\n             * @default\n             * @typings {typeof Model}\n             * @category Common\n             */\n            modelClass : Model,\n            /**\n             * Verify that loaded data does not contain any generated ids. If it does, a warning is logged on console.\n             *\n             * Set this to `false` to disable the check and give a very minor performance boost.\n             *\n             * @prp {Boolean}\n             * @default\n             */\n            verifyNoGeneratedIds : true\n        };\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * An array of field definitions used to create a {@link Core.data.Model} (modelClass) subclass. Optional.\n             * If the Model already has fields defined, these fields will extend those.\n             *\n             * ```javascript\n             * const store = new Store({\n             *     fields : ['name', 'city', 'company'],\n             *     data   : [\n             *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },\n             *         ...\n             *     ]\n             * });\n             * ```\n             *\n             * See {@link Core.data.Model} for more info on defining fields, changing data source and mapping fields to\n             * nested objects.\n             *\n             * Note that pre-created record instances supplied to the store are kept as is and thus these fields will\n             * not apply to them.\n             *\n             * @config {Array<String|ModelFieldConfig|Core.data.field.DataField>}\n             * @category Common\n             */\n            fields : null,\n            /**\n             * Automatically detect from set data if used as tree store or flat store\n             * @config {Boolean}\n             * @default\n             * @category Tree\n             */\n            autoTree : true,\n            /**\n             * Raw data to load initially.\n             *\n             * Expects an array of JavaScript objects, with properties matching store's fields (defined on its\n             * {@link #config-modelClass model} or in the {@link #config-fields} config).\n             *\n             * ```javascript\n             * const store = new Store({\n             *     data : [\n             *         { id : 1, name : 'Linda', city : 'NY' },\n             *         { id : 2, name : 'Olivia', city : 'Paris' },\n             *         ...\n             *     ]\n             * });\n             * ```\n             *\n             * @config {Object[]|Core.data.Model[]}\n             * @category Common\n             */\n            data : null,\n            /**\n             * `true` to act as a tree store.\n             * @config {Boolean}\n             * @category Tree\n             */\n            tree : false,\n            callOnFunctions : true,\n            /**\n             * A {@link Core/util/Collection}, or Collection config object\n             * to use to contain this Store's constituent records.\n             * @config {Core.util.Collection|CollectionConfig}\n             * @category Advanced\n             */\n            storage : null,\n            /**\n             * Retools the loaded data objects instead of making shallow copies of them. This increases performance but\n             * pollutes the incoming data and does not allow remapping of fields (dataSource).\n             *\n             * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an\n             * object with the params described below or `true` which equals `disableDuplicateIdCheck` and\n             * `disableTypeConversion`.\n             *\n             * ```javascript\n             * // No duplicate id checking, no type conversions\n             * new Store({ useRawData : true });\n             *\n             * new Store({\n             *   // No type conversions only\n             *   useRawData : {\n             *     disableTypeConversion : true\n             *   }\n             * });\n             * ```\n             *\n             * @config {Boolean|Object}\n             * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.\n             * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.\n             * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data.\n             * @category Advanced\n             */\n            useRawData : false,\n            /**\n             * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a\n             * backend.\n             *\n             * By default Store allows loading records without ids, in which case a generated id will be assigned.\n             *\n             * @config {Boolean}\n             * @default true\n             * @category Advanced\n             */\n            allowNoId : true,\n            /**\n             * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing\n             * properties. Should rarely need to be used.\n             * @config {Boolean}\n             * @default false\n             * @private\n             * @category Advanced\n             */\n            preventSubClassingModel : null\n        };\n    }\n    static get identifiable() {\n        return {\n            registerGeneratedId : false\n        };\n    }\n    /**\n     * Class used to represent records. Defaults to class Model.\n     * @member {Core.data.Model} modelClass\n     * @typings {typeof Model}\n     * @category Records\n     */\n    //endregion\n    //region Events\n    /**\n     * Fired when the id of a record has changed\n     * @event idChange\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model} record Modified record\n     * @param {String|Number} oldValue Old id\n     * @param {String|Number} value New id\n     */\n    /**\n     * Fired before record is modified in this store.\n     * Modification may be vetoed by returning `false` from a handler.\n     * @event beforeUpdate\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model} record Modified record\n     * @param {Object} changes Modification data\n     */\n    /**\n     * Fired when a record is modified\n     * @event update\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model} record Modified record\n     * @param {Object} changes Modification data\n     */\n    /**\n     * Fired when one of this Store's constituent records is modified while in\n     * {@link Core.data.Model#function-beginBatch batched} state. This may be used to keep\n     * UIs up to date while \"tentative\" changes are made to a record which must not be synced with a server.\n     * @event batchedUpdate\n     * @private\n     */\n    /**\n     * Fired when the root node is set\n     * @event rootChange\n     * @param {Core.data.Store} source This Store\n     * @param {Core.data.Model} oldRoot The old root node.\n     * @param {Core.data.Model} rootNode The new root node.\n     */\n    /**\n     * Data in the store was changed. This is a catch-all event which is fired for all changes\n     * which take place to the store's data.\n     *\n     * This includes mutation of individual records, adding and removal of records, as well as\n     * setting a new data payload using the {@link #property-data} property, sorting, filtering,\n     * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.\n     *\n     * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple\n     * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add},\n     * {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh} and\n     * {@link Core.data.mixin.StoreCRUD#event-removeAll} events.\n     *\n     * A more complex databound widget such as a grid may use the more granular events to perform less\n     * destructive updates more appropriate to each type of change. The properties will depend upon the value of the\n     * `action` property.\n     *\n     * @event change\n     * @param {Core.data.Store} source This Store.\n     * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n     * Name of action which triggered the change. May be one of the options listed above\n     * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n     * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n     * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n     */\n    // NOTE: When updating params above, also update change event in ProjectModelMixin and dataChange in ProjectConsumer\n    /**\n     * Data in the store has completely changed, such as by a filter, or sort or load operation.\n     * @event refresh\n     * @param {Core.data.Store} source This Store.\n     * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch\n     * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of\n     * action which triggered the change. May be one of the options listed above.\n     */\n    //endregion\n    /* break doc comment from next method */\n    //region Init\n    constructor(...args) {\n        super(...args);\n        // When using a Proxy, the Proxy is returned instead of the actual Store\n        if (this.objectify) {\n            return this.initProxy();\n        }\n    }\n    construct(config = {}) {\n        const me = this;\n        Object.assign(me, {\n            added              : new StoreBag(),\n            removed            : new StoreBag(),\n            modified           : new StoreBag(),\n            idRegister         : {},\n            internalIdRegister : {},\n            oldIdMap           : {}\n        });\n        if (config.storeId) {\n            // avoid changing id when setting storeId:\n            config = ObjectHelper.assign({ id : config.storeId }, config);\n            // We cannot remove storeId since it can also be inherited and if so, it will override the id above:\n            // delete config.storeId;\n        }\n        super.construct(config);\n        me.initRelations();\n    }\n    /**\n     * Retrieves/creates a store based on the passed config.\n     *\n     * | Type              | Result                                                                 |\n     * |-------------------|------------------------------------------------------------------------|\n     * | Core.data.Store   | Returns supplied store as is                                           |\n     * | String            | Retrieves an existing store by id                                      |\n     * | Object            | Creates a new store using supplied config object                       |\n     * | Object[]          | Creates a new store, populated with records created from supplied data |\n     * | Core.data.Model[] | Creates a new store, populated with supplied records                   |\n     *\n     *\n     * @param {Core.data.Store|StoreConfig|String|StoreConfig[]|Core.data.Model[]} config\n     * @param {Object} [defaults] Config object to apply when creating a new store for passed data\n     * @param {Function} [converterFn] Function called for each data object prior to creating a record from it. The\n     * return value is used to create a record.\n     * @private\n     */\n    static from(config, defaults = {}, converterFn = null) {\n        // null and store instances pass through\n        if (config && !config.isStore) {\n            // Passed a string, get store by id\n            if (typeof config === 'string') {\n                config = Store.getStore(config);\n            }\n            // Passed something else, create a store using the input as its data\n            else {\n                // Array of records or data, pass to converterFn if one is supplied\n                if (Array.isArray(config)) {\n                    if (converterFn) {\n                        config = config.map(data => data.isModel ? data : converterFn(data));\n                    }\n                    config = ObjectHelper.assign({}, defaults, { data : config });\n                }\n                config = new Store(config);\n            }\n        }\n        return config;\n    }\n    doDestroy() {\n        const\n            me         = this,\n            allRecords = me.registeredRecords;\n        for (let i = allRecords.length - 1, rec; i >= 0; i--) {\n            rec = allRecords[i];\n            if (!rec?.isDestroyed) {\n                rec.unjoinStore(me);\n            }\n        }\n        me._storage?.destroy();\n        // Remove from STM if added there (STM might also have gotten destroyed before us)\n        me.stm?.removeStore?.(me);\n        if (!me.isChained) {\n            me.rootNode?.destroy();\n        }\n        // Events superclass fires destroy event.\n        super.doDestroy();\n    }\n    /**\n     * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`\n     * stack up, and will require an equal number of `endBatch` calls to resume events.\n     *\n     * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to\n     * update themselves based upon the new state of the store.\n     *\n     * This is extremely useful when making a large number of changes to a store. It is important not to trigger\n     * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this\n     * store are only updated once at the end of the updates.\n     */\n    beginBatch() {\n        this.suspendEvents();\n    }\n    /**\n     * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}\n     * stack up, and will require an equal number of `endBatch` calls to resume events.\n     *\n     * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update\n     * themselves based upon the new state of the store.\n     *\n     * This is extremely useful when making a large number of changes to a store. It is important not to trigger\n     * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this\n     * store are only updated once at the end of the updates.\n     */\n    endBatch() {\n        if (this.resumeEvents()) {\n            this.trigger('refresh', {\n                action  : 'batch',\n                data    : this.storage.values,\n                records : this.storage.values\n            });\n        }\n    }\n    set storage(storage) {\n        const me = this;\n        if (storage?.isCollection) {\n            me._storage = storage;\n        }\n        else {\n            me._storage = new Collection(storage);\n        }\n        me._storage.autoFilter = me.reapplyFilterOnAdd;\n        me._storage.autoSort = me.reapplySortersOnAdd;\n        // Join all the constituent records to this Store\n        for (const r of me._storage) {\n            r.joinStore(me);\n        }\n        me._storage.ion({\n            change  : 'onDataChange',\n            thisObj : me\n        });\n    }\n    get storage() {\n        if (!this._storage) {\n            this.storage = {};\n        }\n        return this._storage;\n    }\n    /**\n     * Returns all records (ignoring any filters) from the store.\n     * @property {Core.data.Model[]}\n     * @readonly\n     * @category Records\n     */\n    get allRecords() {\n        const me = this;\n        if (me._allRecords?.generation !== me.storage.generation) {\n            if (me.isTree) {\n                const result = me.collectDescendants(me.rootNode, undefined, undefined, { unfiltered : true }).all;\n                if (me.rootVisible) {\n                    result.unshift(me.rootNode);\n                }\n                me._allRecords = result;\n            }\n            else {\n                me._allRecords = me.isGrouped\n                    ? me.collectGroupRecords()\n                    : me.storage.allValues;\n            }\n            me._allRecords.generation = me.storage.generation;\n        }\n        return me._allRecords;\n    }\n    // All records except special rows such group headers etc\n    getAllDataRecords(searchAllRecords) {\n        return this.isGrouped ? this.collectGroupRecords(searchAllRecords, false) : (searchAllRecords ? this.storage.allValues : this.storage.values);\n    }\n    /**\n     * Called by owned record when the record has its {@link Core.data.Model#property-isCreating}\n     * property toggled.\n     * @param {Core.data.Model} record The record that is being changed.\n     * @param {Boolean} isCreating The new value of the {@link Core.data.Model#property-isCreating} property.\n     * @internal\n     */\n    onIsCreatingToggle(record, isCreating) {\n        const\n            me               = this,\n            newlyPersistable = record.isPersistable && !isCreating;\n        // If it's a transient \"isCreating\" record, waiting to be confirmed as a new entry\n        // into the store, then it should *not* be in the added Bag as a syncable record.\n        // If we are upgrading it to a permanent record, it *should* be in the added Bag.\n        me.added[newlyPersistable ? 'add' : 'remove'](record);\n        // If the record is newly persistable...\n        if (newlyPersistable) {\n            /**\n             * Fired when a temporary record with the {@link Core.data.Model#property-isCreating} property set\n             * has been confirmed as a part of this store by having its {@link Core.data.Model#property-isCreating}\n             * property cleared.\n             * @event addConfirmed\n             * @param {Core.data.Store} source This Store.\n             * @param {Core.data.Model} record The record confirmed as added.\n             */\n            me.trigger('addConfirmed', { record });\n            // AjaxStore to commit confirmed new record\n            if (me.autoCommit) {\n                me.doAutoCommit();\n            }\n        }\n    }\n    // Join added records to store, not called when loading\n    joinRecordsToStore(records) {\n        const { allCount } = this;\n        for (let i = 0; i < records.length; i++) {\n            const record = records[i];\n            // Set a parentIndex on newly added records, based on count prior to the add\n            record.setData('parentIndex', allCount + i - records.length);\n            record.joinStore(this);\n        }\n    }\n    /**\n     * Responds to mutations of the underlying storage Collection\n     * @param {Object} event\n     * @protected\n     */\n    onDataChange({ source : storage, action, added, removed, replaced, oldCount, items, from, to }) {\n        const\n            me           = this,\n            isAddRemove  = dataAddRemoveActions[action],\n            // The \"filter\" action's removed and added are not processed as adds and removes.\n            // In a filter operation the records are still members of the store.\n            addedCount   = isAddRemove && added?.length,\n            removedCount = isAddRemove && removed?.length;\n        let filtersWereReapplied,\n            sortersWereReapplied;\n        me._idMap = null;\n        if (addedCount) {\n            me.joinRecordsToStore(added);\n        }\n        replaced?.forEach(([oldRecord, newRecord]) => {\n            oldRecord.unjoinStore(me, true);\n            newRecord.joinStore(me);\n        });\n        // Allow mixins to mutate the storage before firing events.\n        // StoreGroup does this to introduce group records into the mix.\n        super.onDataChange(...arguments);\n        // Join/unjoin incoming/outgoing records unless its as a result of TreeNode operations.\n        // If we are a tree, joining is done when nodes are added/removed\n        // as child nodes of a joined parent.\n        if (!me.isTree) {\n            if (addedCount) {\n                for (const record of added) {\n                    // If was removed, remove from `removed` list\n                    if (me.removed.includes(record)) {\n                        me.removed.remove(record);\n                    }\n                    // Else add to `added` list\n                    else if (!record.isLinked) {\n                        me.added.add(record);\n                    }\n                }\n                // Re-evaluate the current *local* filter set silently so that the\n                // information we are broadcasting below is up to date.\n                filtersWereReapplied = !me.remoteFilter && me.filtered && me.reapplyFilterOnAdd;\n                if (filtersWereReapplied) {\n                    me.filter({\n                        silent : true\n                    });\n                }\n                // if sortParamName not defined, is not remote sort\n                sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;\n                if (sortersWereReapplied) {\n                    me.sort(null, null, false, true);\n                }\n            }\n            if (removedCount) {\n                for (const record of removed) {\n                    // If app was in the middle of a batched update, cancel the update.\n                    record.cancelBatch();\n                    record.unjoinStore(me);\n                    // If was newly added, remove from `added` list\n                    if (me.added.includes(record)) {\n                        me.added.remove(record);\n                    }\n                    // Else add to `removed` list\n                    // Unless it's StateTrackingManager reverting the record insertion.\n                    // Also unless it's a record which was a transient record created by the UI\n                    // and then the create was canceled at the edit stage.\n                    else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {\n                        me.removed.add(record);\n                    }\n                }\n                me.modified.remove(removed);\n                // Re-evaluate the current *local* filter set silently so that the\n                // information we are broadcasting below is up to date.\n                filtersWereReapplied = !me.remoteFilter && me.filtered;\n                if (filtersWereReapplied) {\n                    me.filter({\n                        silent : true\n                    });\n                }\n            }\n        }\n        switch (action) {\n            case 'clear':\n                // Clear our own relationCache, since we will be empty\n                me.relationCache = {};\n                // Signal to stores that depend on us\n                me.updateDependentStores('removeall');\n                me.trigger('removeAll');\n                me.trigger('change', {\n                    action : 'removeall'\n                });\n                break;\n            case 'splice':\n                if (addedCount) {\n                    me.updateDependentStores('add', added);\n                    const\n                        // Collection does not handle moves, figure out if and where a record was moved from by checking\n                        // previous index value stored in meta\n                        oldIndex = added.reduce((lowest, record) => {\n                            const { previousIndex } = record.meta;\n                            if (previousIndex > -1 && previousIndex < lowest) lowest = previousIndex;\n                            return lowest;\n                        }, added[0].meta.previousIndex),\n                        index    = storage.indexOf(added[0], !storage.autoFilter),\n                        params   = {\n                            records : added,\n                            index\n                        };\n                    // Only include param oldIndex when used\n                    if (oldIndex > -1) {\n                        params.oldIndex = oldIndex;\n                    }\n                    me.trigger('add', params);\n                    me.trigger('change', Object.assign({ action : 'add' }, params));\n                    if (filtersWereReapplied) {\n                        me.triggerFilterEvent({\n                            action : 'filter', filters : me.filters, oldCount, records : me.storage.allValues\n                        });\n                    }\n                    if (sortersWereReapplied) {\n                        me.trigger('sort', { action : 'sort', sorters : me.sorters, records : me.storage.allValues });\n                    }\n                }\n                if (removed.length) {\n                    me.updateDependentStores('remove', removed);\n                    me.trigger('remove', {\n                        records : removed\n                    });\n                    me.trigger('change', {\n                        action  : 'remove',\n                        records : removed\n                    });\n                }\n                if (replaced.length) {\n                    me.trigger('replace', {\n                        records : replaced,\n                        all     : me.records.length === replaced.length\n                    });\n                    me.trigger('change', {\n                        action : 'replace',\n                        replaced,\n                        all    : me.records.length === replaced.length\n                    });\n                }\n                break;\n            case 'filter':\n                // Reapply grouping/sorting to make sure unfiltered records get sorted correctly\n                if (me.isGrouped || me.isSorted) {\n                    me.performSort(true);\n                }\n                break;\n            case 'move': {\n                // silently update parentIndex of records affected\n                const\n                    start = Math.min(from, to),\n                    // We need to constrain maximum index in case record gets removed due to moving to the\n                    // collapsed group\n                    end   = Math.min(me.storage.allValues.length - 1, Math.max(from, to));\n                for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {\n                    allRecords[i].setData('parentIndex', i);\n                }\n                /**\n                 * Fired when a block of records has been moved within this Store\n                 * @event move\n                 * @param {Core.data.Store} source This Store\n                 * @param {Core.data.Model} record (DEPRECATED) The first record moved (The\n                 * {@link Core.data.mixin.StoreCRUD#function-move} API now accepts an array of records to move).\n                 * @param {Core.data.Model[]} records The records moved.\n                 * @param {Number} from The index from which the record was removed (applicable only for flat store).\n                 * @param {Number} to The index at which the record was inserted (applicable only for flat store).\n                 * @param {Core.data.Model} [newParent] The new parent record for the dragged records (applicable only for tree stores)\n                 * @param {Core.data.Model[]} [oldParents] The old parent records for the dragged records (applicable only for move operations in tree stores)\n                 */\n                me.trigger('move', {\n                    record  : items[0],\n                    records : items,\n                    from,\n                    to\n                });\n                // The move was in real data. If we are filtered, the\n                // filtered set has to be refreshed.\n                if (me.isFiltered) {\n                    me.performFilter();\n                }\n                me.trigger('change', {\n                    action,\n                    record  : items[0],\n                    records : items,\n                    from,\n                    to\n                });\n                break;\n            }\n        }\n    }\n    onDataReplaced(action, data) {\n        const\n            me          = this,\n            { storage } = me,\n            all         = storage.allValues,\n            sorted      = Boolean(me.sorters.length > 0);\n        for (let i = 0; i < all.length; i++) {\n            all[i].joinStore(me);\n        }\n        // The three operations below, filter, store and sort, all are passed\n        // the \"silent\" parameter meaning they do not fire their own events.\n        // The 'refresh' and 'change' events after are used to update UIs.\n        if (!me.remoteFilter && me.isFiltered) {\n            me.filter({\n                silent : true\n            });\n        }\n        if (me.remoteSort) {\n            if (me.isGrouped) {\n                storage.replaceValues({\n                    // Need to update group records info (headers and footers)\n                    ...me.prepareGroupRecords(),\n                    silent : true\n                });\n            }\n        }\n        else {\n            if (me.isGrouped) {\n                me.group(null, null, false, !sorted, true);\n            }\n            // Only request sorting of arriving data if sorting is not remote.\n            if (sorted) {\n                me.sort(null, null, false, true);\n            }\n        }\n        // Check for duplicate ids, unless user guarantees data validity\n        if (!me.useRawData.disableDuplicateIdCheck) {\n            const { idMap } = me;\n            if (Object.keys(idMap).length < storage.values.length) {\n                // idMap has fewer entries than expected, a duplicate id was used. pick idMap apart to find out which\n                const collisions = [];\n                storage.values.forEach(r => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));\n                throw new Error(`Id collision on ${collisions.map(r => r.id)}`);\n            }\n        }\n        const event = { action, data, records : storage.values };\n        me.updateDependentStores(action, event.records);\n        // Allow subclasses to postprocess a new dataset\n        me.afterLoadData?.();\n        if (!me.isRemoteDataLoading) {\n            me.trigger('refresh', event);\n        }\n        me.trigger('change', event);\n    }\n    /**\n     * This is called from Model after mutating any fields so that Stores can take any actions necessary at that point,\n     * and distribute mutation event information through events.\n     * @param {Core.data.Model} record The record which has just changed\n     * @param {Object} toSet A map of the field names and values that were passed to be set\n     * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and\n     * the property value is an object containing two properties: `oldValue` and `value` eg:\n     * ```javascript\n     *     {\n     *         name {\n     *             oldValue : 'Rigel',\n     *             value : 'Nigel'\n     *         }\n     *     }\n     *\n     * @param {Boolean} silent Do not trigger events\n     * @param {Boolean} fromRelationUpdate Update caused by a change in related model\n     * @private\n     */\n    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {\n        const\n            me          = this,\n            event       = {\n                record,\n                records : [record],\n                changes : wasSet,\n                // Cannot use isBatching, since change is triggered when batching has reached 0\n                // (but before it is set to null)\n                batch   : record.batching != null,\n                fromRelationUpdate\n            },\n            committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);\n        // Inform underlying collection of the changes, allowing it to keep any indices up to date\n        me.storage.onItemMutation(record, wasSet);\n        // Always update indices, otherwise they will be left out of date (was previously skipped when silent)\n        if ('id' in wasSet) {\n            const { oldValue, value } = toSet.id;\n            me.updateDependentRecordIds(oldValue, value);\n            me.onRecordIdChange({ record, oldValue, value });\n        }\n        if (!silent) {\n            if ('id' in wasSet) {\n                const { oldValue, value } = toSet.id;\n                me.trigger('idChange', {\n                    store : me,\n                    record,\n                    oldValue,\n                    value\n                });\n            }\n            me.onUpdateRecord(record, wasSet);\n            me.trigger('update', event);\n            me.trigger('change', Object.assign({ action : 'update' }, event));\n        }\n        if (me.autoCommit && committable) {\n            me.doAutoCommit();\n        }\n    }\n    updateModifiedBagForRecord(record) {\n        const me       = this;\n        let addedToBag = false;\n        // Add or remove from our modified Bag\n        if (record.isModified) {\n            if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isAutoRoot) {\n                // When we add a new model first time and the model is not persistable (for example when the model is not valid),\n                // it is not added to the \"added\" collection (StoreBag), but only joined to the store.\n                // So if the record is not added neither to \"modified\" nor \"added\",\n                // need to check if this record is phantom. If so, add it to the \"added\", otherwise to the \"modified\".\n                if (record.isPhantom) {\n                    me.added.add(record);\n                }\n                else {\n                    me.modified.add(record);\n                }\n                addedToBag = true;\n            }\n        }\n        else {\n            me.modified.remove(record);\n        }\n        return addedToBag;\n    }\n    get idMap() {\n        const\n            me           = this,\n            needsRebuild = !me._idMap,\n            idMap        = me._idMap || (me._idMap = {});\n        if (needsRebuild) {\n            const processedRecords = me.storage.values;\n            for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {\n                record           = processedRecords[index];\n                idMap[record.id] = { index, visibleIndex, record };\n                if (!record.isSpecialRow) {\n                    visibleIndex++;\n                }\n            }\n            // If store is filtered and grouped, we often need to lookup record index in filtered and unfiltered\n            // collections\n            if (me.isFiltered) {\n                for (let index = 0, l = me.storage._values.length; index < l; index++) {\n                    const record = me.storage._values[index];\n                    if (record.id in idMap) {\n                        idMap[record.id].unfilteredIndex = index;\n                    }\n                    else {\n                        // If record is not in the idMap, set its index as -1 which allows\n                        // `store.includes` API work correctly\n                        idMap[record.id] = { index : -1, unfilteredIndex : index, record };\n                    }\n                }\n            }\n        }\n        return idMap;\n    }\n    changeModelClass(ClassDef) {\n        const { fields } = this;\n        this.originalModelClass = ClassDef;\n        let ClassDefEx = ClassDef;\n        // Ensure our modelClass is exchanged for an extended of modelClass decorated with any configured fields.\n        if (fields?.length) {\n            // angular prod build messes up \"Foo = class extends Base\" (https://github.com/bryntum/support/issues/6395)\n            class ModelClass extends ClassDef {\n                static get fields() {\n                    return fields;\n                }\n            }\n            ClassDefEx = ModelClass;\n        }\n        // If we expose properties on Model we will pollute all other models, use internal subclass instead\n        else if (!this.preventSubClassingModel) {\n            // angular prod build messes up \"Foo = class extends Base\" (https://github.com/bryntum/support/issues/6395)\n            class ModelClass extends ClassDef {}\n            ClassDefEx = ModelClass;\n        }\n        // Need to properly expose relations on this new subclass\n        ClassDefEx.initClass();\n        return ClassDefEx;\n    }\n    //endregion\n    //region Store id & map\n    set storeId(storeId) {\n        this.id = storeId;\n    }\n    get storeId() {\n        return this.id;\n    }\n    changeId(id, oldId) {\n        return super.changeId((id !== true) && id, oldId);\n    }\n    updateId(id, oldId) {\n        const duplicate = Store.getById(id);\n        duplicate && Store.unregisterInstance(duplicate);\n        super.updateId(id, oldId);\n    }\n    generateAutoId() {\n        return Store.generateId(`store-`);\n    }\n    get tree() {\n        return this._tree;\n    }\n    set tree(tree) {\n        this._tree = tree;\n        if (tree && !this.rootNode) {\n            this.rootNode            = this.buildRootNode();\n            this.rootNode.isAutoRoot = true;\n        }\n    }\n    // a hook to build a customized root node\n    buildRootNode() {\n        return {};\n    }\n    /**\n     * Get a store from the store map by id.\n     * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects\n     * from which to create the contents of a new Store.\n     * @returns {Core.data.Store} The store with the specified id\n     */\n    static getStore(id, storeClass) {\n        if (id instanceof Store) {\n            return id;\n        }\n        if (this.getById(id)) {\n            return this.getById(id);\n        }\n        if (Array.isArray(id)) {\n            let storeModel;\n            const storeData = id.map(item => {\n                if (item instanceof Model) {\n                    storeModel = item.constructor;\n                }\n                else if (typeof item === 'string') {\n                    item = {\n                        text : item\n                    };\n                }\n                else {\n                }\n                return item;\n            });\n            if (!storeModel) {\n                // angular prod build messes up \"Foo = class extends Base\" (https://github.com/bryntum/support/issues/6395)\n                class ModelClass extends Model {}\n                storeModel = ModelClass;\n            }\n            id = {\n                autoCreated : true,\n                data        : storeData,\n                modelClass  : storeModel,\n                allowNoId   : true // String items have no id and are not guaranteed to be unique\n            };\n            if (!storeClass) {\n                storeClass = Store;\n            }\n        }\n        if (storeClass) {\n            return new storeClass(id);\n        }\n    }\n    /**\n     * Get all registered stores\n     * @property {Core.data.Store[]}\n     */\n    static get stores() {\n        return Store.registeredInstances;\n    }\n    //endregion\n    //region Data\n    /**\n     * The invisible root node of this tree.\n     * @property {Core.data.Model}\n     * @readonly\n     * @category Tree\n     */\n    get rootNode() {\n        return this.masterStore ? this.masterStore.rootNode : this._rootNode;\n    }\n    set rootNode(rootNode) {\n        const me      = this,\n            oldRoot = me._rootNode;\n        // No change\n        if (rootNode === oldRoot) {\n            return;\n        }\n        if (oldRoot) {\n            me.clear(true);\n        }\n        if (rootNode instanceof Model) {\n            // We insist that the rootNode is expanded otherwise no children will be added\n            rootNode.instanceMeta(me).collapsed = false;\n            me._rootNode = rootNode;\n        }\n        else {\n            me._rootNode = rootNode = new me.modelClass(Object.assign({\n                expanded                : true,\n                [me.modelClass.idField] : `${me.id}-rootNode`\n            }, rootNode), me, null, true);\n        }\n        me._tree        = true;\n        rootNode.isRoot = true;\n        rootNode.joinStore(me);\n        // If there are nodes to be inserted into the flat storage\n        // then onNodeAddChild knows how to do that and what events\n        // to fire based upon rootNode.isLoading.\n        if (rootNode.children?.length || me.rootVisible) {\n            rootNode.isLoading = true;\n            me.onNodeAddChild(rootNode, rootNode.children || [], 0);\n            rootNode.isLoading = false;\n        }\n        me.trigger('rootChange', { oldRoot, rootNode });\n    }\n    /**\n     * Sets data in the store.\n     *\n     * Expects an array of JavaScript objects, with properties matching store's fields (defined on its\n     * {@link #config-modelClass model} or in the {@link #config-fields} config).\n     *\n     * Called on initialization if data is in config otherwise call it yourself after ajax call etc. Can also be used to\n     * get the raw original data.\n     *\n     * ```javascript\n     * store.data = [\n     *     { id : 1, name : 'Linda', city : 'NY' },\n     *     { id : 2, name : 'Olivia', city : 'Paris' },\n     *     ...\n     * ];\n     * ```\n     *\n     * @property {Object[]}\n     * @fires refresh\n     * @fires change\n     * @category Records\n     */\n    set data(data) {\n        this.setStoreData(data);\n    }\n    // For overridability in engine\n    setStoreData(data) {\n        const\n            me                         = this,\n            { idField, childrenField } = me.modelClass;\n        // Take a peek at first data row, and clone data if we are provided immutable objects\n        if (me.transformFlatData && data?.length > 0 && !Object.isExtensible(data[0])) {\n            // Avoid cloning object again in Model\n            me.useRawData = me.useRawData || {\n                disableDuplicateIdCheck : false,\n                disableDefaultValue     : false,\n                disableTypeConversion   : false\n            };\n            data          = ObjectHelper.clone(data);\n        }\n        // Make sure that if the plugins have not been processed yet, we call\n        // the temporary property getter which configuration injects to\n        // process plugins at this point. Some plugins are required to\n        // operate on incoming data.\n        me.getConfig('plugins');\n        // In case data is loaded during configuration before configuredListeners have been processed\n        me.processConfiguredListeners();\n        // Allow data as a \"named object\", using keys as ids\n        if (data && !Array.isArray(data)) {\n            data = ObjectHelper.transformNamedObjectToArray(data, idField);\n        }\n        // Convert to being a tree store if any of the new rows have a children property\n        me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && data?.some(r => r[childrenField])));\n        // Store received data order to preserve on sort if remote data loading enabled\n        if (data && (me.remoteSort || me.remoteFilter)) {\n            for (let i = 0; i < data.length; i++) {\n                data[i]._remoteSortIndex = i;\n            }\n        }\n        // Always load a new dataset initially\n        if (!me.syncDataOnLoad || !me._data) {\n            me._data = data;\n            // This means load the root node\n            if (me.tree) {\n                if (me.transformFlatData) {\n                    data = me.treeifyFlatData(data);\n                }\n                const root = me.rootNode;\n                root.isLoading = true;\n                // Remove data parentId before clearing\n                me._data.forEach(record => delete record.parentId);\n                // clear silently without marking as removed\n                me.clear(true);\n                // Append child will detect that this is a dataset operation and trigger sort + events needed\n                root.appendChild(data);\n                me.updateDependentStores('dataset', [root]);\n                root.isLoading = false;\n                if (data.length === 0) {\n                    const event = { action : 'dataset', data : [], records : [] };\n                    me.trigger('refresh', event);\n                    me.trigger('change', event);\n                }\n                // we must re-apply filters for the filtered tree store\n                else if (me.isFiltered) {\n                    me.filter();\n                }\n            }\n            else {\n                me.loadData(data);\n            }\n            // loading the store discards all tracked changes\n            me.added.clear();\n            me.removed.clear();\n            me.modified.clear();\n        }\n        // Sync dataset if configured to do so\n        else {\n            me.syncDataset(data);\n        }\n    }\n    loadData(data, action = 'dataset') {\n        const\n            me                     = this,\n            { storage, allowNoId } = me,\n            idField                = me.modelClass.fieldMap.id.dataSource,\n            creatingRecord         = me.find(rec => rec.isCreating);\n        if (creatingRecord) {\n            storage.values.splice(me.records.indexOf(creatingRecord), 1);\n        }\n        let warnGenerated = me.verifyNoGeneratedIds;\n        // Need to unregister all groups\n        me.removeHeadersAndFooters(me.storage.values);\n        me._idMap   = null;\n        me.oldIdMap = {};\n        if (data) {\n            const isRaw = !(data[0] instanceof Model);\n            if (isRaw) {\n                me.modelClass.exposeProperties(data[0]);\n                const\n                    count   = data.length,\n                    records = new Array(count);\n                for (let i = 0; i < count; i++) {\n                    const recordData = data[i];\n                    if (!allowNoId && recordData[idField] == null) {\n                        throw new Error(`Id required but not found on row ${i}`);\n                    }\n                    if (warnGenerated && recordData[idField]?.startsWith?.('_generated')) {\n                        console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);\n                        warnGenerated = false;\n                    }\n                    records[i] = me.processRecord(me.createRecord(recordData, true), true);\n                    records[i].setData('parentIndex', i);\n                }\n                // clear without marking as removed\n                me.clear(true);\n                // Allow Collection's own filters to work on the Collection by\n                // passing the isNewDataset param as true.\n                // The storage Collection may have been set up with its own filters\n                // while we are doing remote filtering. An example is ComboBox\n                // with filterSelected: true. Records which are in the selection are\n                // filtered out of visibility using a filter directly in the Combobox's\n                // Store's Collection.\n                storage.replaceValues({\n                    values       : records,\n                    isNewDataset : true,\n                    silent       : true\n                });\n            }\n            else {\n                // clear without marking as removed\n                me.clear(true);\n                storage.replaceValues({\n                    values       : data.slice(),\n                    isNewDataset : true,\n                    silent       : true\n                });\n            }\n            if (creatingRecord) {\n                storage.values.push(creatingRecord);\n            }\n            me._data = data;\n            me.onDataReplaced(action, data);\n        }\n        else {\n            // clear without marking as removed\n            me.clear(true);\n            me._data = null;\n        }\n        me.isSyncingDataOnLoad = false;\n    }\n    get data() {\n        return this._data;\n    }\n    /**\n     * Creates an array of records from this store from the `start` to the `end' - 1\n     * @param {Number} [start] The index of the first record to return\n     * @param {Number} [end] The index *after* the last record to return `(start + length)`\n     * @returns {Core.data.Model[]} The requested records.\n     * @category Records\n     */\n    getRange(start, end, all = true) {\n        return (all ? this.storage.allValues : this.storage.values).slice(start, end);\n    }\n    /**\n     * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom\n     * conversion from data to record.\n     * @param {Object} data Json data\n     * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times\n     * @category Records\n     */\n    createRecord(data, skipExpose = false, rawData = false) {\n        return new this.modelClass(data, this, null, skipExpose, false, rawData);\n    }\n    processRecord(record, isDataset = false) {\n        return record;\n    }\n    refreshData() {\n        this.filter();\n        this.sort();\n    }\n    onRecordIdChange({ record, oldValue, value }) {\n        const\n            me                       = this,\n            idMap                    = me._idMap,\n            { idRegister, oldIdMap } = me;\n        me.storage._indicesInvalid = true;\n        // Remember the record used to have this identifier\n        // this is used by STM to understand when a foreign key\n        // value update really means targeting other record or\n        // it's just a reaction to the target record id change\n        oldIdMap[oldValue] = record;\n        // Update idMap to reflect the changed id. Some code paths (auto syncing changes with CrudManager) will lead to\n        // idMap already being up-to-date when we get here\n        if (idMap && !idMap[value]) {\n            const entry = idMap[oldValue];\n            delete idMap[oldValue];\n            idMap[value] = entry;\n        }\n        me.added.changeId(oldValue, value);\n        me.removed.changeId(oldValue, value);\n        me.modified.changeId(oldValue, value);\n        delete idRegister[oldValue];\n        idRegister[value] = record;\n        record.index = me.storage.indexOf(record);\n    }\n    onUpdateRecord(record, changes) {\n        const\n            me                     = this,\n            { internalId }         = changes,\n            { internalIdRegister } = me;\n        if (internalId) {\n            this.storage._indicesInvalid = true;\n            delete internalIdRegister[internalId.oldValue];\n            internalIdRegister[internalId.value] = record;\n        }\n        // Reapply filters when records change?\n        if (me.reapplyFilterOnUpdate && me.isFiltered) {\n            me.filter();\n        }\n    }\n    get useRawData() {\n        return this._useRawData;\n    }\n    set useRawData(options) {\n        if (options === true) {\n            this._useRawData = {\n                enabled                 : true,\n                disableDuplicateIdCheck : true,\n                disableTypeConversion   : true,\n                disableDefaultValue     : false\n            };\n        }\n        else {\n            this._useRawData = options ? Object.assign(options, { enabled : true }) : { enabled : false };\n        }\n    }\n    //endregion\n    //region Count\n    /**\n     * Number of records in the store\n     * @param {Boolean} [countProcessed] Count processed (true) or real records (false)\n     * @returns {Number} Record count\n     * @category Records\n     */\n    getCount(countProcessed = true) {\n        return countProcessed ? this.count : this.originalCount;\n    }\n    /**\n     * Record count, for data records. Not including records added for group headers etc.\n     * @property {Number}\n     * @readonly\n     * @category Records\n     */\n    get originalCount() {\n        return this.storage.totalCount - (this.groupRecords?.length || 0);\n    }\n    /**\n     * Record count, including records added for group headers etc.\n     * @property {Number}\n     * @readonly\n     * @category Records\n     */\n    get count() {\n        return this.storage.count;\n    }\n    /**\n     * Returns the complete dataset size regardless of tree node collapsing or filtering\n     * @property {Number}\n     * @readonly\n     * @category Records\n     */\n    get allCount() {\n        return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;\n    }\n    //endregion\n    //region Get record(s)\n    /**\n     * Returns all \"visible\" records.\n     * **Note:** The returned value **may not** be mutated!\n     * @property {Core.data.Model[]}\n     * @readonly\n     * @immutable\n     * @category Records\n     */\n    get records() {\n        return this.storage.values;\n    }\n    /**\n     * Get the first record in the store.\n     * @property {Core.data.Model}\n     * @readonly\n     * @category Records\n     */\n    get first() {\n        return this.storage.values[0];\n    }\n    /**\n     * Get the last record in the store.\n     * @property {Core.data.Model}\n     * @readonly\n     * @category Records\n     */\n    get last() {\n        return this.storage.values[this.storage.values.length - 1];\n    }\n    /**\n     * Get the record at the specified index\n     * @param {Number} index Index for the record\n     * @returns {Core.data.Model} Record at the specified index\n     * @category Records\n     */\n    getAt(index, all = false) {\n        // all means include filtered out records\n        return this.storage.getAt(index, all);\n    }\n    // These are called by Model#join and Model#unjoin\n    // register a record as a findable member keyed by id and internalId\n    register(record) {\n        const me = this;\n        if (!me.useRawData.disableDuplicateIdCheck) {\n            // Test for duplicate IDs on register only when a tree store.\n            // loadData does it in the case of a non-tree\n            const existingRec = me.isTree && me.idRegister[record.id];\n            if (existingRec && existingRec !== record) {\n                throw new Error(`Id collision on ${record.id}`);\n            }\n        }\n        me.idRegister[record.id]                 = record;\n        me.internalIdRegister[record.internalId] = record;\n    }\n    unregister(record) {\n        delete this.idRegister[record.id];\n        delete this.internalIdRegister[record.internalId];\n    }\n    get registeredRecords() {\n        return Object.values(this.idRegister);\n    }\n    /**\n     * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node\n     * @param {Core.data.Model|String|Number} id Id of record to return.\n     * @returns {Core.data.Model} A record with the specified id\n     * @category Records\n     */\n    getById(id) {\n        // In case `id` is a record, we use its ID to try to find the record in the store,\n        // because if the record is removed from the store it shouldn't be found.\n        // if (id instanceof Model) {\n        //     id = id.id;\n        // }\n        if (id?.isModel) {\n            const record = id;\n            // When asking for a record that has links, we resolve first link if original is not found.\n            // This allows `linkedStore.isAvailable(original)` to return true and `linkedStore.getById(original)` to\n            // return the linked record.\n            if (record.hasLinks && !this.storage.allValues.includes(record)) {\n                return record.$links.find(r => this.storage.allValues.includes(r));\n            }\n            return record;\n        }\n        //return this.tree ? this.idRegister[id] : this.storage.get(id);\n        return this.idRegister[id];\n    }\n    /**\n     * Checks if a record is available, in the sense that it is not filtered out,\n     * hidden in a collapsed group or in a collapsed node.\n     * @param {Core.data.Model|String|Number} recordOrId Record to check\n     * @returns {Boolean}\n     * @category Records\n     */\n    isAvailable(recordOrId) {\n        const record = this.getById(recordOrId);\n        return record && this.storage.includes(record) || false;\n    }\n    /**\n     * Get a record by internalId.\n     * @param {Number} internalId The internalId of the record to return\n     * @returns {Core.data.Model} A record with the specified internalId\n     * @category Records\n     */\n    getByInternalId(internalId) {\n        return this.internalIdRegister[internalId];\n    }\n    /**\n     * Checks if the specified record is contained in the store\n     * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record\n     * @returns {Boolean}\n     * @category Records\n     */\n    includes(recordOrId) {\n        if (this.isTree) {\n            return this.idRegister[Model.asId(recordOrId)] != null;\n        }\n        return this.indexOf(recordOrId) > -1;\n    }\n    //endregion\n    //region Get index\n    /**\n     * Returns the index of the specified record/id, or `-1` if not found.\n     * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.\n     * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.\n     * as opposed to the dataset index. This omits group header records.\n     * @param {Boolean} [allExceptFilteredOutRecords] For trees, when true this searches all except filtered out records\n     * in the flattened tree, similar to a flat store.\n     * @returns {Number} Index for the record/id, or `-1` if not found.\n     * @category Records\n     */\n    indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {\n        // Only check records actually in the store ($store is for objectify scenario)\n        if (recordOrId?.isModel && !recordOrId.stores.includes(this.$store || this)) {\n            // When asking for a record that has links, we resolve first link if original is not found.\n            // This allows finding index for links using relations to original records (dep -> event for example)\n            const linkedRecord = recordOrId.$links.find(r => this.storage.allValues.includes(r));\n            if (linkedRecord) {\n                return this.indexOf(linkedRecord, visibleRecords);\n            }\n            return -1;\n        }\n        // When a tree, indexOf is always in the visible records - filtering is different in trees.\n        if (this.isTree) {\n            // Cheaper than this.storage.indexOf() which takes a detour to result in the same call\n            return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));\n        }\n        const id = Model.asId(recordOrId);\n        if (id == null) {\n            return -1;\n        }\n        const found = this.idMap[id];\n        return found ? found[visibleRecords ? 'visibleIndex' : 'index'] : -1;\n    }\n    allIndexOf(recordOrId) {\n        if (this.isTree) {\n            return this.allRecords.indexOf(this.getById(recordOrId));\n        }\n        else {\n            return this.storage.indexOf(recordOrId, true);\n        }\n    }\n    //endregion\n    //region Get values\n    /**\n     * Returns an array of distinct values for the specified field.\n     *\n     * ```javascript\n     * store.getDistinctValues('age'); // Returns an array of the unique age values\n     * ```\n     *\n     * @param {String} field Field to extract values for\n     * @param {Boolean} [searchAllRecords] True to ignore any applied filters\n     * @returns {Array} Array of values\n     * @category Values\n     */\n    getDistinctValues(field, searchAllRecords = false) {\n        const\n            me     = this,\n            values = [],\n            keys   = {};\n        let value;\n        me.forEach(r => {\n            if (!r.isSpecialRow && !r.isRoot) {\n                value                = r.get(field);\n                const primitiveValue = value instanceof Date ? value.getTime() : value;\n                if (!keys[primitiveValue]) {\n                    values.push(value);\n                    keys[primitiveValue] = 1;\n                }\n            }\n        }, me, searchAllRecords);\n        return values;\n    }\n    /**\n     * Counts how many times the specified value appears in the store\n     * @param {String} field Field to look in\n     * @param {*} value Value to look for\n     * @returns {Number} Found count\n     * @category Values\n     */\n    getValueCount(field, value) {\n        let count = 0;\n        this.forEach(r => {\n            if (ObjectHelper.isEqual(r.get(field), value)) count++;\n        });\n        return count;\n    }\n    //endregion\n    //region JSON & console\n    /**\n     * Retrieve or set the data of all records as a JSON string\n     *\n     * ```javascript\n     * const store = new Store({\n     *     data : [\n     *         { id : 1, name : 'Superman' },\n     *         { id : 2, name : 'Batman' }\n     *     ]\n     * });\n     *\n     * const jsonString = store.json;\n     *\n     * //jsonString:\n     * '[{\"id\":1,\"name\":\"Superman\"},{\"id\":2,\"name\":\"Batman\"}]\n     * ```\n     *\n     * @property {String}\n     */\n    set json(json) {\n        if (typeof json === 'string') {\n            json = StringHelper.safeJsonParse(json);\n        }\n        this.data = json;\n    }\n    get json() {\n        return StringHelper.safeJsonStringify(this);\n    }\n    /**\n     * Pretty printed version of {@link #property-json}\n     * @readonly\n     * @property {String}\n     */\n    get formattedJSON() {\n        return StringHelper.safeJsonStringify(this, null, 4);\n    }\n    /**\n     * Retrieve the data of all (unfiltered) records as an array of JSON objects.\n     *\n     * ```javascript\n     * const store = new Store({\n     *     data : [\n     *         { id : 1, name : 'Superman' },\n     *         { id : 2, name : 'Batman' }\n     *     ]\n     * });\n     *\n     * const jsonArray = store.toJSON();\n     *\n     * //jsonArray:\n     * [{id:1,name:\"Superman\"},{id:2,name:\"Batman\"}]\n     * ```\n     *\n     * @returns {Object[]}\n     */\n    toJSON() {\n        // extract entire structure.\n        // If we're a tree, then that consists of the payload of the rootNode.\n        return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map(record => record.toJSON());\n    }\n    //endregion\n    //region Extract config\n    // These functions are not meant to be called by any code other than Base#getCurrentConfig()\n    preProcessCurrentConfigs(configs) {\n        super.preProcessCurrentConfigs(configs);\n        delete configs.project;\n    }\n    // Extract current data for all accessible records\n    getInlineData(options) {\n        const data = [];\n        if (this.tree) {\n            this.rootNode.children?.forEach(r => data.push(r.getCurrentConfig(options)));\n        }\n        else {\n            this.forEach(r => data.push(r.getCurrentConfig(options)));\n        }\n        return data;\n    }\n    // Extract current configs and data\n    getCurrentConfig(options) {\n        const\n            result    = super.getCurrentConfig(options),\n            { state } = this;\n        if (result) {\n            // Replace initial data with values from current records\n            if (result.data) {\n                result.data = this.getInlineData(options);\n            }\n            // Never include project or stm\n            delete result.project;\n            delete result.stm;\n            delete result.asyncEvents;\n            // Exclude default modelClass, gets added to config by engine, spam\n            if (result.modelClass?.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2] === this.constructor.defaultConfig.modelClass) {\n                delete result.modelClass;\n            }\n            // Pollution from grid\n            if (!this.tree) {\n                delete result.tree;\n            }\n            // Include current state\n            if (state) {\n                Object.assign(result, state);\n            }\n        }\n        return result;\n    }\n    //endregion\n    //region Iteration & traversing\n    /**\n     * Iterates over all normal records in store. Omits group header and footer records if this store is grouped.\n     * @param {Function} fn A function that is called for each record. Returning `false` from that function cancels\n     * iteration. It is called with the following arguments:\n     * @param {Core.data.Model} fn.record Current record\n     * @param {Number} fn.index Current index\n     * @param {Object} [thisObj] `this` reference for the function\n     * @param {Object|Boolean} [options] A boolean for `includeFilteredOutRecords`, or detailed options for\n     * exclude/include records\n     * @param {Boolean} [options.includeFilteredOutRecords] `true` to also include filtered out records\n     * @param {Boolean} [options.includeCollapsedGroupRecords] `true` to also include records from collapsed groups of\n     * grouped store\n     * @category Iteration\n     */\n    forEach(fn, thisObj = this, options) {\n        const\n            me       = this,\n            callback = (r, i) => {\n                if (!r.isRoot && !r.isSpecialRow) {\n                    return fn.call(thisObj, r, i);\n                }\n            };\n        options = fixTraverseOptions(me, options);\n        if (me.isTree) {\n            // forEach uses traverse() but is not perceived as a tree walk, so we want to apply our sorter\n            if (me.isChained) {\n                options = {\n                    ...options,\n                    sorterFn : me.sorterFn\n                };\n            }\n            me.rootNode.traverseWhile(callback, false, options);\n        }\n        else {\n            // native forEach cannot be aborted by returning false, have to loop \"manually\"\n            const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;\n            // grouped store has own tree-like structure, but cannot be handled like a regular tree\n            if (me.isGrouped && options.includeCollapsedGroupRecords) {\n                for (let i = 0; i < records.length; i++) {\n                    const\n                        record        = records[i],\n                        groupChildren = options.includeFilteredOutRecords ? record.unfilteredGroupChildren : record.groupChildren;\n                    if (groupChildren && record.meta.collapsed === true) {\n                        for (let j = 0; j < groupChildren.length; j++) {\n                            const rec = groupChildren[j];\n                            if (callback(rec, j) === false) {\n                                return;\n                            }\n                        }\n                    }\n                    else if (callback(record, i) === false) {\n                        return;\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < records.length; i++) {\n                    if (callback(records[i], i) === false) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record\n     * @param {Function} fn\n     * @returns {Array}\n     * @category Iteration\n     */\n    map(fn, thisObj = this) {\n        return this.storage.values.map(fn, thisObj);\n    }\n    /**\n     * Equivalent to Array.every(). Returns `true` if every call of the provided function\n     * on each record yields a truthy value.\n     * @param {Function} fn\n     * @param {Function} fn.record The record to test.\n     * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store.\n     * @param {Boolean} [ignoreFilters] Pass `true` to iterate all records including filtered out ones.\n     * @returns {Array}\n     * @category Iteration\n     */\n    every(fn, thisObj = this, ignoreFilters) {\n        return this.storage[ignoreFilters ? 'allValues' : 'values'].every(fn, thisObj);\n    }\n    /**\n     * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to\n     * reduce it to a single value.\n     * @param {Function} fn\n     * @param {*} initialValue\n     * @returns {*}\n     * @category Iteration\n     */\n    reduce(fn, initialValue = [], thisObj = this) {\n        if (thisObj !== this) {\n            fn = fn.bind(thisObj);\n        }\n        return this.storage.values.reduce(fn, initialValue, thisObj);\n    }\n    /**\n     * Iterator that allows you to do for (let record of store)\n     * @category Iteration\n     */\n    [Symbol.iterator]() {\n        return this.storage.values[Symbol.iterator]();\n    }\n    /**\n     * Traverse all tree nodes (only applicable for Tree Store)\n     * @param {Function} fn The function to call on visiting each node.\n     * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.\n     * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.\n     * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or detailed options for exclude/include records\n     * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records\n     * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store\n     * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree\n     * @category Traverse\n     */\n    traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {\n        const me = this;\n        options = fixTraverseOptions(me, options);\n        if (me.isTree) {\n            // Allow store.traverse(fn, true) to start from rootNode\n            if (typeof topNode === 'boolean') {\n                skipTopNode = topNode;\n                topNode     = me.rootNode;\n            }\n            if (me.isChained) {\n                const passedFn = fn;\n                fn = node => {\n                    if (me.chainedFilterFn(node)) {\n                        passedFn(node);\n                    }\n                };\n            }\n            topNode.traverse(fn, skipTopNode, options);\n        }\n        else {\n            me.forEach(rec => rec.traverse(fn, false, options), me, options);\n        }\n    }\n    /**\n     * Traverse all tree nodes while the passed `fn` returns true\n     * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.\n     * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.\n     * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.\n     * @param {Object} [options] An options object to exclude/include records\n     * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records\n     * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store\n     * @category Traverse\n     */\n    traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {\n        const me = this;\n        options = fixTraverseOptions(me, options);\n        if (me.isTree) {\n            // Allow store.traverse(fn, true) to start from rootNode\n            if (typeof topNode === 'boolean') {\n                skipTopNode = topNode;\n                topNode     = me.rootNode;\n            }\n            if (me.isChained) {\n                const passedFn = fn;\n                fn = node => {\n                    if (me.chainedFilterFn(node)) {\n                        passedFn(node);\n                    }\n                };\n            }\n            topNode.traverseWhile(fn, skipTopNode, options);\n        }\n        else {\n            for (const record of me.storage) {\n                if (record.traverse(fn, false, options) === false) {\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Finds the next record.\n     * @param {Core.data.Model|String|Number} recordOrId Current record or its id\n     * @param {Boolean} [wrap=false] Wrap at start/end or stop there\n     * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers\n     * @returns {Core.data.Model} Next record or null if current is the last one\n     * @category Traverse\n     */\n    getNext(recordOrId, wrap = false, skipSpecialRows = false) {\n        const\n            me      = this,\n            records = me.storage.values;\n        let idx     = me.indexOf(recordOrId);\n        if (idx >= records.length - 1) {\n            if (wrap) {\n                idx = -1;\n            }\n            else {\n                return null;\n            }\n        }\n        const record = records[idx + 1];\n        // Skip the result if it's a specialRow and we are told to skip them\n        if (skipSpecialRows && record && record.isSpecialRow) {\n            return me.getNext(records[idx + 1], wrap, true);\n        }\n        return record;\n    }\n    /**\n     * Finds the previous record.\n     * @param {Core.data.Model|String|Number} recordOrId Current record or its id\n     * @param {Boolean} [wrap=false] Wrap at start/end or stop there\n     * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers\n     * @returns {Core.data.Model} Previous record or null if current is the last one\n     * @category Traverse\n     */\n    getPrev(recordOrId, wrap = false, skipSpecialRows = false) {\n        const\n            me      = this,\n            records = me.storage.values;\n        let idx     = me.indexOf(recordOrId);\n        if (idx === 0) {\n            if (wrap) {\n                idx = records.length;\n            }\n            else {\n                return null;\n            }\n        }\n        const record = records[idx - 1];\n        // Skip the result if it's a specialRow and we are told to skip them\n        if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {\n            return me.getPrev(records[idx - 1], wrap, true);\n        }\n        return record;\n    }\n    /**\n     * Gets the next or the previous record. Optionally wraps from first -> last and vice versa\n     * @param {String|Core.data.Model} recordOrId Record or records id\n     * @param {Boolean} next Next (true) or previous (false)\n     * @param {Boolean} wrap Wrap at start/end or stop there\n     * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers\n     * @returns {Core.data.Model}\n     * @category Traverse\n     * @internal\n     */\n    getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {\n        return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);\n    }\n    /**\n     * Finds the next record among leaves (in a tree structure)\n     * @param {Core.data.Model|String|Number} recordOrId Current record or its id\n     * @param {Boolean} [wrap] Wrap at start/end or stop there\n     * @returns {Core.data.Model} Next record or null if current is the last one\n     * @category Traverse\n     * @internal\n     */\n    getNextLeaf(recordOrId, wrap = false) {\n        const\n            me      = this,\n            records = me.leaves,\n            record  = me.getById(recordOrId);\n        let idx     = records.indexOf(record);\n        if (idx >= records.length - 1) {\n            if (wrap) {\n                idx = -1;\n            }\n            else {\n                return null;\n            }\n        }\n        return records[idx + 1];\n    }\n    /**\n     * Finds the previous record among leaves (in a tree structure)\n     * @param {Core.data.Model|String|Number} recordOrId Current record or its id\n     * @param {Boolean} [wrap] Wrap at start/end or stop there\n     * @returns {Core.data.Model} Previous record or null if current is the last one\n     * @category Traverse\n     * @internal\n     */\n    getPrevLeaf(recordOrId, wrap = false) {\n        const\n            me      = this,\n            records = me.leaves,\n            record  = me.getById(recordOrId);\n        let idx     = records.indexOf(record);\n        if (idx === 0) {\n            if (wrap) {\n                idx = records.length;\n            }\n            else {\n                return null;\n            }\n        }\n        return records[idx - 1];\n    }\n    /**\n     * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and\n     * vice versa\n     * @param {String|Core.data.Model} recordOrId Record or record id\n     * @param {Boolean} [next] Next (true) or previous (false)\n     * @param {Boolean} [wrap] Wrap at start/end or stop there\n     * @returns {Core.data.Model}\n     * @category Traverse\n     * @internal\n     */\n    getAdjacentLeaf(recordOrId, next = true, wrap = false) {\n        return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);\n    }\n    //endregion\n}\nStore.initClass();\nStore._$name = 'Store';", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"../../AbstractPartOfProjectGenericMixin.js\";\nimport Store from \"../../../../Core/data/Store.js\";\n/**\n * This an abstract mixin for every Store, that belongs to a project.\n *\n * The store with this mixin, supposes, that it will be \"joining\" the project, a reference to which is saved\n * and made available for all models.\n */\nexport class AbstractPartOfProjectStoreMixin extends Mixin([\n    AbstractPartOfProjectGenericMixin,\n    Store\n], (base) => {\n    const superProto = base.prototype;\n    class AbstractPartOfProjectStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.isLoadingData = false;\n            this.disableHasLoadedDataToCommitFlag = false;\n        }\n        //region Async event triggering\n        // NOTE: Tested in Scheduler (EventStore.t.js)\n        construct(config = {}) {\n            config.asyncEvents = {\n                add: true,\n                remove: true,\n                removeAll: true,\n                change: true,\n                refresh: true,\n                replace: true,\n                move: true,\n                update: true\n            };\n            return superProto.construct.call(this, config);\n        }\n        // Override for event triggering, to allow triggering events before and after some async operation.\n        // The \"before\" events are prefix, the \"after\" are not.\n        trigger(eventName, param) {\n            const me = this, { asyncEvents, project } = me, asyncEvent = asyncEvents?.[eventName], asyncAction = asyncEvent && (asyncEvent === true || asyncEvent[param.action]);\n            if (!asyncAction) {\n                // Trigger as usual\n                return superProto.trigger.call(me, eventName, param);\n            }\n            // Trigger prefixed before event\n            superProto.trigger.call(me, `${eventName}PreCommit`, { ...param });\n            // Event that did not invalidate engine, for example \"update\"\n            if (!project || project.isEngineReady() && !project.isWritingData) {\n                // Trigger \"original\" event\n                superProto.trigger.call(me, eventName, param);\n            }\n            else if (!me.eventsSuspended && project) {\n                // Instead of making n auto-destroying listeners (which takes enormous amount of time), we make a single\n                // one and queue all the events. When dataReady event is triggered we trigger those events\n                // https://github.com/bryntum/support/issues/3154\n                if (!project.dataReadyDetacher) {\n                    project.queuedDataReadyEvents = [];\n                    // Wait for commit without triggering one, otherwise we would affect commit scheduling\n                    project.dataReadyDetacher = project.ion({\n                        dataReady() {\n                            // Trigger \"original\" event\n                            this.queuedDataReadyEvents.forEach(([superProto, scope, eventName, param]) => {\n                                superProto.trigger.call(scope, eventName, param);\n                            });\n                            project.queuedDataReadyEvents = null;\n                            project.dataReadyDetacher();\n                            project.dataReadyDetacher = null;\n                        },\n                        once: true\n                    });\n                }\n                project.queuedDataReadyEvents.push([superProto, me, eventName, param]);\n            }\n            // No way of handling other return values in this scenario, won't work for preventable events\n            return true;\n        }\n        //endregion\n        calculateProject() {\n            // project is supposed to be provided for stores from outside\n            return this.project;\n        }\n        setStoreData(data) {\n            // Loading data sets hasLoadedDataToCommit flag.\n            // So we treat the 1st commit after data loading as the initial one\n            if (this.project && !(this.syncDataOnLoad || this.disableHasLoadedDataToCommitFlag)) {\n                this.project.hasLoadedDataToCommit = true;\n            }\n            this.isLoadingData = true;\n            superProto.setStoreData.call(this, data);\n            this.isLoadingData = false;\n            this.project?.trigger('storeRefresh', { store: this });\n        }\n        // Override to postpone auto commits to after project commit, makes sure records are unmodified after commit\n        async doAutoCommit() {\n            if (this.suspendCount <= 0 && this.project && !this.project.isEngineReady()) {\n                // @ts-ignore\n                await this.project.commitAsync();\n            }\n            superProto.doAutoCommit.call(this);\n        }\n        async addAsync(records, silent) {\n            const result = this.add(records, silent);\n            await this.project.commitAsync();\n            return result;\n        }\n        async insertAsync(index, records, silent) {\n            const result = this.insert(index, records, silent);\n            await this.project.commitAsync();\n            return result;\n        }\n        async loadDataAsync(data) {\n            this.data = data;\n            await this.project.commitAsync();\n        }\n        performFilter() {\n            if (this.project && (this.isLoadingData || this.rootNode?.isLoading)) {\n                // Reapply filters after calculations, in case filtering on some calculated field\n                this.project.commitAsync().then(() => this.filter());\n            }\n            return super.performFilter(...arguments);\n        }\n    }\n    return AbstractPartOfProjectStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"../../store/mixin/AbstractPartOfProjectStoreMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"../../AbstractPartOfProjectGenericMixin.js\";\nimport Model from \"../../../../Core/data/Model.js\";\nimport { isInstanceOf } from '../../../../ChronoGraph/class/BetterMixin.js';\n/**\n * This an abstract mixin for every Model that belongs to a project.\n *\n * The model with this mixin, supposes that it will be \"joining\" a store that is already part of a project,\n * so that such model can take a reference to the project from it.\n *\n * It provides 2 template methods [[joinProject]] and [[leaveProject]], which can be overridden in other mixins.\n */\nexport class AbstractPartOfProjectModelMixin extends Mixin([AbstractPartOfProjectGenericMixin, Model], (base) => {\n    const superProto = base.prototype;\n    class AbstractPartOfProjectModelMixin extends base {\n        joinStore(store) {\n            let joinedProject = null;\n            // Joining a store that is not part of project (for example a chained store) should not affect engine\n            if (isInstanceOf(store, AbstractPartOfProjectStoreMixin)) {\n                const project = store.getProject();\n                if (project && !this.getProject()) {\n                    this.setProject(project);\n                    joinedProject = project;\n                }\n            }\n            superProto.joinStore.call(this, store);\n            // Join directly only if not repopulating the store, in which case we will be joined later after\n            // graph has been recreated\n            if (joinedProject && !joinedProject.isRepopulatingStores)\n                this.joinProject();\n        }\n        unjoinStore(store, isReplacing = false) {\n            superProto.unjoinStore.call(this, store, isReplacing);\n            const { project } = this;\n            const isLeavingProjectStore = (isInstanceOf(store, AbstractPartOfProjectStoreMixin))\n                && !store.isFillingFromMaster && project === (store.isChained && store.project ?\n                store.masterStore.project\n                : store.project);\n            // Leave project when unjoining from store, but do not bother if the project is being destroyed or if\n            // the dataset is being replaced, or if store is chained into other project\n            if (project && !project.isDestroying && !project.isRepopulatingStores && isLeavingProjectStore) {\n                this.leaveProject(isReplacing);\n                this.setProject(null);\n            }\n            // @ts-ignore\n            if (isLeavingProjectStore)\n                this.graph = null;\n        }\n        /**\n         * Template method, which is called when model is joining the project (through joining some store that\n         * has already joined the project)\n         */\n        joinProject() { }\n        /**\n         * Template method, which is called when model is leaving the project (through leaving some store usually)\n         */\n        leaveProject(isReplacing = false) { }\n        calculateProject() {\n            const store = this.stores.find(s => (isInstanceOf(s, AbstractPartOfProjectStoreMixin)) && !!s.getProject());\n            return store?.getProject();\n        }\n        async setAsync(fieldName, value, silent) {\n            const result = this.set(fieldName, value, silent);\n            await this.project?.commitAsync();\n            return result;\n        }\n        async getAsync(fieldName) {\n            await this.project?.commitAsync();\n            return this.get(fieldName);\n        }\n        get isStmRestoring() {\n            const project = this.getProject();\n            return project?.isRestoringData || project?.stm.isRestoring || false;\n        }\n    }\n    return AbstractPartOfProjectModelMixin;\n}) {\n}\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport later from \"../vendor/later/later.js\";\nimport { AbstractPartOfProjectModelMixin } from \"../quark/model/mixin/AbstractPartOfProjectModelMixin.js\";\n/**\n * This is a calendar interval mixin.\n *\n * Can be either a static time interval (if [[startDate]]/[[endDate]] are specified) or recurrent time interval\n * ([[recurrentStartDate]]/[[recurrentEndDate]]).\n *\n * By default it defines a non-working period ([[isWorking]] field has default value `false`),\n * but can also define an explicit working time, for example to override some previous period.\n *\n * You probably don't need to create instances of this mixin directly, instead you pass its configuration object to the [[AbstractCalendarMixin.addInterval]]\n */\nexport class CalendarIntervalMixin extends Mixin([AbstractPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CalendarIntervalMixin extends base {\n        static get fields() {\n            return [\n                'name',\n                { name: 'startDate', type: 'date' },\n                { name: 'endDate', type: 'date' },\n                'recurrentStartDate',\n                'recurrentEndDate',\n                'cls',\n                'iconCls',\n                { name: 'isWorking', type: 'boolean', defaultValue: false },\n                { name: 'priority', type: 'number' }\n            ];\n        }\n        getCalendar() {\n            return this.stores[0].calendar;\n        }\n        resetPriority() {\n            this.priorityField = null;\n            this.getCalendar().getDepth();\n        }\n        // not just `getPriority` to avoid clash with auto-generated getter in the subclasses\n        getPriorityField() {\n            if (this.priorityField != null)\n                return this.priorityField;\n            // 0 - 10000 interval is reserved for \"unspecified time\" intervals\n            // then 10000 - 10100, 10100-10200, ... etc intervals are for the calendars at depth 0, 1, ... etc\n            let base = 10000 + this.getCalendar().getDepth() * 100;\n            let priority = this.priority;\n            if (priority == null) {\n                // recurrent intervals are considered \"base\" and have lower priority\n                // static intervals are considered special case overrides and have higher priority\n                priority = this.isRecurrent() ? 20 : 30;\n            }\n            // intervals from parent calendars will have lower priority\n            return this.priorityField = base + priority;\n        }\n        /**\n         * Whether this interval is recurrent (both [[recurrentStartDate]] and [[recurrentEndDate]] are present and parsed correctly\n         * by the `later` library)\n         */\n        isRecurrent() {\n            return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule());\n        }\n        /**\n         * Whether this interval is static - both [[startDate]] and [[endDate]] are present.\n         */\n        isStatic() {\n            return Boolean(this.startDate && this.endDate);\n        }\n        /**\n         * Helper method to parse [[recurrentStartDate]] and [[recurrentEndDate]] field values.\n         * @param {Object|String} schedule Recurrence schedule\n         * @returns {Object} Processed schedule ready to be used by later.schedule() method.\n         * @private\n         */\n        parseDateSchedule(value) {\n            let schedule = value;\n            if (value && value !== Object(value)) {\n                schedule = later.parse.text(value);\n                if (schedule !== Object(schedule) || schedule.error >= 0) {\n                    // can be provided as JSON text\n                    try {\n                        schedule = JSON.parse(value);\n                    }\n                    catch (e) {\n                        return null;\n                    }\n                }\n            }\n            return schedule;\n        }\n        getStartDateSchedule() {\n            if (this.startDateSchedule)\n                return this.startDateSchedule;\n            const schedule = this.parseDateSchedule(this.recurrentStartDate);\n            return this.startDateSchedule = later.schedule(schedule);\n        }\n        getEndDateSchedule() {\n            if (this.endDateSchedule)\n                return this.endDateSchedule;\n            if (this.recurrentEndDate === 'EOD')\n                return 'EOD';\n            const schedule = this.parseDateSchedule(this.recurrentEndDate);\n            return this.endDateSchedule = later.schedule(schedule);\n        }\n    }\n    return CalendarIntervalMixin;\n}) {\n}\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { CalendarIntervalMixin } from \"./CalendarIntervalMixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"../quark/store/mixin/AbstractPartOfProjectStoreMixin.js\";\n/**\n * This a collection of [[CalendarIntervalMixin]] items. Its a dumb collection though, the \"real\" calendar\n * is a [[AbstractCalendarMixin]] model, which is part of the [[AbstractCalendarManagerStoreMixin]].\n */\nexport class CalendarIntervalStore extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CalendarIntervalStore extends base {\n        constructor() {\n            super(...arguments);\n            this.disableHasLoadedDataToCommitFlag = true;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: CalendarIntervalMixin\n            };\n        }\n    }\n    return CalendarIntervalStore;\n}) {\n}\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { CalendarIntervalMixin } from \"./CalendarIntervalMixin.js\";\n// Calendar interval model denoting unspecified interval\nexport class UnspecifiedTimeIntervalModel extends Mixin([CalendarIntervalMixin], (base) => {\n    const superProto = base.prototype;\n    class UnspecifiedTimeIntervalModel extends base {\n        getCalendar() {\n            return this.calendar;\n        }\n        // NOTE: See parent class implementation for further comments\n        getPriorityField() {\n            if (this.priorityField != null)\n                return this.priorityField;\n            return this.priorityField = this.getCalendar().getDepth();\n        }\n    }\n    return UnspecifiedTimeIntervalModel;\n}) {\n}\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"./AbstractPartOfProjectGenericMixin.js\";\n/**\n * This a base generic mixin for every class, that belongs to a scheduler_core project.\n *\n * It just provides getter/setter for the `project` property, along with some convenience methods\n * to access the project's stores.\n */\nexport class CorePartOfProjectGenericMixin extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {\n    const superProto = base.prototype;\n    class CorePartOfProjectGenericMixin extends base {\n        //region Store getters\n        get eventStore() {\n            return this.project?.eventStore;\n        }\n        get resourceStore() {\n            return this.project?.resourceStore;\n        }\n        get assignmentStore() {\n            return this.project?.assignmentStore;\n        }\n        get dependencyStore() {\n            return this.project?.dependencyStore;\n        }\n        get calendarManagerStore() {\n            return this.project?.calendarManagerStore;\n        }\n        //endregion\n        //region Entity getters\n        /**\n         * Convenience method to get the instance of event by its id.\n         */\n        getEventById(id) {\n            return this.eventStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of dependency by its id.\n         */\n        getDependencyById(id) {\n            return this.dependencyStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of resource by its id.\n         */\n        getResourceById(id) {\n            return this.resourceStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of assignment by its id.\n         */\n        getAssignmentById(id) {\n            return this.assignmentStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of calendar by its id.\n         */\n        getCalendarById(id) {\n            return this.calendarManagerStore?.getById(id);\n        }\n    }\n    return CorePartOfProjectGenericMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalendarIntervalStore } from \"../../calendar/CalendarIntervalStore.js\";\nimport { CalendarIteratorResult } from \"../../calendar/CalendarCache.js\";\nimport { TimeUnit } from \"../../scheduling/Types.js\";\nimport { CalendarCacheSingle } from \"../../calendar/CalendarCacheSingle.js\";\nimport { UnspecifiedTimeIntervalModel } from \"../../calendar/UnspecifiedTimeIntervalModel.js\";\nimport DateHelper from \"../../../Core/helper/DateHelper.js\";\nimport { AbstractPartOfProjectModelMixin } from \"./mixin/AbstractPartOfProjectModelMixin.js\";\n/**\n * Calendar for project scheduling, mixed by CoreCalendarMixin and BaseCalendarMixin. It is used to mark certain time\n * intervals as \"non-working\" and ignore them during scheduling.\n *\n * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.\n */\nexport class AbstractCalendarMixin extends Mixin([AbstractPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CalendarMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.version = 1;\n        }\n        // intervalStore            : CalendarIntervalStore\n        static get fields() {\n            return [\n                { name: 'version', type: 'number' },\n                'name',\n                { name: 'unspecifiedTimeIsWorking', type: 'boolean', defaultValue: true },\n                { name: 'intervals', type: 'store', subStore: true },\n                'cls',\n                'iconCls'\n            ];\n        }\n        get intervalStoreClass() {\n            return CalendarIntervalStore;\n        }\n        get intervalStore() {\n            // @ts-ignore\n            return this.meta.intervalsStore;\n        }\n        // Not a typo, name is generated from the fields name = intervals\n        initIntervalsStore(config) {\n            config.storeClass = this.intervalStoreClass;\n            // @ts-ignore\n            config.modelClass = this.getDefaultConfiguration().calendarIntervalModelClass || this.intervalStoreClass.defaultConfig.modelClass;\n            config.calendar = this;\n        }\n        // this method is called when the new value for the `intervals` field of this model is assigned\n        // the type of the `intervals` field is \"store\" that's why this magic\n        processIntervalsStoreData(intervals) {\n            this.bumpVersion();\n        }\n        isDefault() {\n            const project = this.getProject();\n            if (project) {\n                return this === project.defaultCalendar;\n            }\n            return false;\n        }\n        getDepth() {\n            return this.childLevel + 1;\n        }\n        /**\n         * The core iterator method of the calendar.\n         *\n         * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties\n         * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided\n         * iterator function should return `false` at some point, to avoid infinite loops.\n         *\n         * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.\n         *\n         * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found\n         * in the given timespan. All the intervals, which are \"active\" for current interval are collected in the 3rd argument\n         * for this function - [[CalendarCacheInterval|calendarCacheInterval]]. If iterator returns `false` (checked with `===`)\n         * the iteration stops.\n         *\n         * @param scope The scope (`this` value) to execute the iterator in.\n         */\n        forEachAvailabilityInterval(options, func, scope) {\n            const maxRange = this.getProject()?.maxCalendarRange;\n            if (maxRange) {\n                options = Object.assign({ maxRange }, options);\n            }\n            return this.calendarCache.forEachAvailabilityInterval(options, func, scope);\n        }\n        /**\n         * This method starts at the given `date` and moves forward or backward in time, depending on `isForward`.\n         * It stops moving as soon as it accumulates the `durationMs` milliseconds of working time and returns the date\n         * at which it has stopped and remaining duration - the [[AccumulateWorkingTimeResult]] object.\n         *\n         * Normally, the remaining duration will be 0, indicating the full `durationMs` has been accumulated.\n         * However, sometimes, calendar might not be able to accumulate enough working time due to various reasons,\n         * like if it does not contain enough working time - this case will be indicated with remaining duration bigger than 0.\n         *\n         * @param date\n         * @param durationMs\n         * @param isForward\n         */\n        accumulateWorkingTime(date, durationMs, isForward) {\n            // if duration is 0 - return the same date\n            if (durationMs === 0)\n                return { finalDate: new Date(date), remainingDurationInMs: 0 };\n            if (isNaN(durationMs))\n                throw new Error(\"Invalid duration\");\n            let finalDate = date;\n            const adjustDurationToDST = this.getProject()?.adjustDurationToDST ?? false;\n            this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                let result = true;\n                if (calendarCacheInterval.getIsWorking()) {\n                    let diff = intervalEndDate.getTime() - intervalStartDate.getTime();\n                    if (durationMs <= diff) {\n                        if (adjustDurationToDST) {\n                            const dstDiff = isForward\n                                ? intervalStartDate.getTimezoneOffset() - (new Date(intervalStartDate.getTime() + durationMs)).getTimezoneOffset()\n                                : (new Date(intervalEndDate.getTime() - durationMs)).getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                            durationMs -= dstDiff * 60 * 1000;\n                        }\n                        finalDate = isForward\n                            ? new Date(intervalStartDate.getTime() + durationMs)\n                            : new Date(intervalEndDate.getTime() - durationMs);\n                        durationMs = 0;\n                        result = false;\n                    }\n                    else {\n                        if (adjustDurationToDST) {\n                            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                            diff += dstDiff * 60 * 1000;\n                        }\n                        finalDate = isForward ? intervalEndDate : intervalStartDate;\n                        durationMs -= diff;\n                    }\n                }\n                return result;\n            });\n            return { finalDate: new Date(finalDate), remainingDurationInMs: durationMs };\n        }\n        /**\n         * Calculate the working time duration between the 2 dates, in milliseconds.\n         *\n         * @param {Date} startDate\n         * @param {Date} endDate\n         * @param {Boolean} [allowNegative] Method ignores negative values by default, returning 0. Set to true to get\n         * negative duration.\n         */\n        calculateDurationMs(startDate, endDate, allowNegative = false) {\n            let duration = 0;\n            const multiplier = startDate.getTime() <= endDate.getTime() || !allowNegative ? 1 : -1;\n            if (multiplier < 0) {\n                [startDate, endDate] = [endDate, startDate];\n            }\n            const adjustDurationToDST = this.getProject().adjustDurationToDST;\n            this.forEachAvailabilityInterval({ startDate: startDate, endDate: endDate }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (calendarCacheInterval.getIsWorking()) {\n                    duration += intervalEndDate.getTime() - intervalStartDate.getTime();\n                    if (adjustDurationToDST) {\n                        const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                        duration += dstDiff * 60 * 1000;\n                    }\n                }\n            });\n            return duration * multiplier;\n        }\n        /**\n         * Calculate the end date of the time interval which starts at `startDate` and has `durationMs` working time duration\n         * (in milliseconds).\n         *\n         * @param startDate\n         * @param durationMs\n         */\n        calculateEndDate(startDate, durationMs) {\n            // the method goes forward by default ..unless a negative duration provided\n            const isForward = durationMs >= 0;\n            const res = this.accumulateWorkingTime(startDate, Math.abs(durationMs), isForward);\n            return res.remainingDurationInMs === 0 ? res.finalDate : null;\n        }\n        /**\n         * Calculate the start date of the time interval which ends at `endDate` and has `durationMs` working time duration\n         * (in milliseconds).\n         *\n         * @param endDate\n         * @param durationMs\n         */\n        calculateStartDate(endDate, durationMs) {\n            // the method goes backwards by default ..unless a negative duration provided\n            const isForward = durationMs <= 0;\n            const res = this.accumulateWorkingTime(endDate, Math.abs(durationMs), isForward);\n            return res.remainingDurationInMs === 0 ? res.finalDate : null;\n        }\n        /**\n         * Returns the earliest point at which a working period of time starts, following the given date.\n         * Can be the date itself, if it comes on the working time.\n         *\n         * @param date The date after which to skip the non-working time.\n         * @param isForward Whether the \"following\" means forward in time or backward.\n         */\n        skipNonWorkingTime(date, isForward = true) {\n            let workingDate;\n            const res = this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (calendarCacheInterval.getIsWorking()) {\n                    workingDate = isForward ? intervalStartDate : intervalEndDate;\n                    return false;\n                }\n            });\n            if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)\n                return 'empty_calendar';\n            return workingDate ? new Date(workingDate) : new Date(date);\n        }\n        /**\n         * This method adds a single [[CalendarIntervalMixin]] to the internal collection of the calendar\n         */\n        addInterval(interval) {\n            return this.addIntervals([interval]);\n        }\n        /**\n         * This method adds an array of [[CalendarIntervalMixin]] to the internal collection of the calendar\n         */\n        addIntervals(intervals) {\n            this.bumpVersion();\n            return this.intervalStore.add(intervals);\n        }\n        /**\n         * This method removes a single [[CalendarIntervalMixin]] from the internal collection of the calendar\n         */\n        removeInterval(interval) {\n            return this.removeIntervals([interval]);\n        }\n        /**\n         * This method removes an array of [[CalendarIntervalMixin]] from the internal collection of the calendar\n         */\n        removeIntervals(intervals) {\n            this.bumpVersion();\n            return this.intervalStore.remove(intervals);\n        }\n        /**\n         * This method removes all intervals from the internal collection of the calendar\n         */\n        clearIntervals(silent) {\n            if (!silent) {\n                this.bumpVersion();\n            }\n            return this.intervalStore.removeAll(silent);\n        }\n        bumpVersion() {\n            this.clearCache();\n            this.version++;\n        }\n        get calendarCache() {\n            if (this.$calendarCache !== undefined)\n                return this.$calendarCache;\n            const unspecifiedTimeInterval = new UnspecifiedTimeIntervalModel({\n                isWorking: this.unspecifiedTimeIsWorking\n            });\n            unspecifiedTimeInterval.calendar = this;\n            return this.$calendarCache = new CalendarCacheSingle({\n                calendar: this,\n                unspecifiedTimeInterval: unspecifiedTimeInterval,\n                intervalStore: this.intervalStore,\n                parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null\n            });\n        }\n        clearCache() {\n            // not strictly needed, we just help garbage collector\n            this.$calendarCache && this.$calendarCache.clear();\n            this.$calendarCache = undefined;\n        }\n        resetPriorityOfAllIntervals() {\n            this.traverse((calendar) => {\n                calendar.intervalStore.forEach((interval) => interval.resetPriority());\n            });\n        }\n        insertChild(child, before, silent) {\n            let res = superProto.insertChild.call(this, ...arguments);\n            if (!Array.isArray(res)) {\n                res = [res];\n            }\n            // invalidate cache of the child record, since now it should take parent into account\n            res.forEach((r) => {\n                r.bumpVersion();\n                r.resetPriorityOfAllIntervals();\n            });\n            return res;\n        }\n        joinProject() {\n            superProto.joinProject.call(this);\n            this.intervalStore.setProject(this.getProject());\n        }\n        leaveProject() {\n            superProto.leaveProject.call(this);\n            this.intervalStore.setProject(null);\n            this.clearCache();\n        }\n        doDestroy() {\n            this.leaveProject();\n            this.intervalStore.destroy();\n            super.doDestroy();\n        }\n        isDayHoliday(day) {\n            const startDate = DateHelper.clearTime(day), endDate = DateHelper.getNext(day, TimeUnit.Day);\n            let hasWorkingTime = false;\n            this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (_intervalStartDate, _intervalEndDate, calendarCacheInterval) => {\n                hasWorkingTime = calendarCacheInterval.getIsWorking();\n                return !hasWorkingTime;\n            });\n            return !hasWorkingTime;\n        }\n        getDailyHolidaysRanges(startDate, endDate) {\n            const result = [];\n            startDate = DateHelper.clearTime(startDate);\n            while (startDate < endDate) {\n                if (this.isDayHoliday(startDate)) {\n                    result.push({\n                        startDate,\n                        endDate: DateHelper.getStartOfNextDay(startDate, true, true)\n                    });\n                }\n                startDate = DateHelper.getNext(startDate, TimeUnit.Day);\n            }\n            return result;\n        }\n        /**\n         * Returns working time ranges between the provided dates.\n         * @param startDate Start of the period to get ranges from.\n         * @param endDate End of the period to get ranges from.\n         *\n         * @param {Date} startDate\n         * @param {Date} endDate\n         */\n        getWorkingTimeRanges(startDate, endDate) {\n            const result = [];\n            this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (calendarCacheInterval.getIsWorking()) {\n                    const entry = calendarCacheInterval.intervals[0];\n                    result.push({\n                        name: entry.name,\n                        startDate: intervalStartDate,\n                        endDate: intervalEndDate\n                    });\n                }\n            });\n            return result;\n        }\n        /**\n         * Returns non-working time ranges between the provided dates.\n         * @param startDate Start of the period to get ranges from.\n         * @param endDate End of the period to get ranges from.\n         *\n         * @param {Date} startDate\n         * @param {Date} endDate\n         */\n        getNonWorkingTimeRanges(startDate, endDate) {\n            const result = [];\n            this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (!calendarCacheInterval.getIsWorking()) {\n                    const entry = calendarCacheInterval.intervals[0];\n                    result.push({\n                        name: entry.name,\n                        iconCls: entry.iconCls,\n                        cls: entry.cls,\n                        startDate: intervalStartDate,\n                        endDate: intervalEndDate\n                    });\n                }\n            });\n            return result;\n        }\n        /**\n         * Checks if there is a working time interval in the provided time range (or when just startDate is provided,\n         * checks if the date is contained inside a working time interval in this calendar)\n         * @param startDate\n         * @param [endDate]\n         * @param [fullyContained] Pass true to check if the range is fully covered by a single continuous working time block\n         */\n        isWorkingTime(startDate, endDate, fullyContained) {\n            if (fullyContained) {\n                let found;\n                const res = this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                    if (calendarCacheInterval.getIsWorking() && intervalStartDate <= startDate && intervalEndDate >= endDate) {\n                        found = true;\n                        return false;\n                    }\n                });\n                if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)\n                    return false;\n                return found;\n            }\n            else {\n                // Can be Date | null | 'empty_calendar'\n                const workingTimeStart = this.skipNonWorkingTime(startDate);\n                return workingTimeStart && workingTimeStart !== 'empty_calendar' ? (endDate ? workingTimeStart < endDate : workingTimeStart.getTime() === startDate.getTime()) : false;\n            }\n        }\n    }\n    return CalendarMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectModelMixin } from './mixin/AbstractPartOfProjectModelMixin.js';\n/**\n * This is a mixin enabling events to handle assignments. It is mixed by CoreHasAssignmentsMixin and\n * BaseHasAssignmentsMixin. It provides a collection of all assignments, which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class AbstractHasAssignmentsMixin extends Mixin([AbstractPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class HasAssignmentsMixin extends base {\n        /**\n         * If a given resource is assigned to this task, returns a [[BaseAssignmentMixin]] instance for it.\n         * Otherwise returns `null`\n         */\n        getAssignmentFor(resource) {\n            // Bucket `assigned` might not be set up yet when using delayed calculations\n            for (const assignment of this.assigned ?? []) {\n                if (assignment.resource === resource)\n                    return assignment;\n            }\n            return null;\n        }\n        isAssignedTo(resource) {\n            return Boolean(this.getAssignmentFor(resource));\n        }\n        /**\n         * A method which assigns a resource to the current event\n         */\n        async assign(resource) {\n            const assignmentCls = this.project.assignmentStore.modelClass;\n            this.addAssignment(new assignmentCls({\n                event: this,\n                resource: resource\n            }));\n            return this.commitAsync();\n        }\n        /**\n         * A method which unassigns a resource from the current event\n         */\n        async unassign(resource) {\n            const assignment = this.getAssignmentFor(resource);\n            this.removeAssignment(assignment);\n            return this.commitAsync();\n        }\n        leaveProject() {\n            // `this.assigned` will be empty if model is added to project and then removed immediately\n            // w/o any propagations\n            // @ts-ignore\n            if (this.isInActiveTransaction && this.assigned) {\n                const eventStore = this.getEventStore();\n                // to batch the assignments removal, we don't remove the assignments right away, but instead\n                // add them for the batched removal to the `assignmentsForRemoval` property of the event store\n                this.assigned.forEach(assignment => eventStore.assignmentsForRemoval.add(assignment));\n            }\n            superProto.leaveProject.call(this, ...arguments);\n        }\n        remove() {\n            if (this.parent) {\n                // need to get the event store in advance, because after removal the project reference will be cleared (all that is what provide\n                // references to all stores\n                const eventStore = this.getEventStore();\n                superProto.remove.call(this);\n                eventStore && eventStore.afterEventRemoval();\n            }\n            else {\n                return superProto.remove.call(this);\n            }\n        }\n        // template methods, overridden in scheduling modes mixins\n        // should probably be named something like \"onEventAssignmentAdded\"\n        // should be a listener for the `add` event of the assignment store instead\n        addAssignment(assignment) {\n            this.getProject().assignmentStore.add(assignment);\n            return assignment;\n        }\n        // should be a listener for the `remove` event of the assignment store instead\n        removeAssignment(assignment) {\n            this.getProject().assignmentStore.remove(assignment);\n            return assignment;\n        }\n    }\n    return HasAssignmentsMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectGenericMixin } from \"../../CorePartOfProjectGenericMixin.js\";\nimport Model from \"../../../../Core/data/Model.js\";\nimport { AbstractPartOfProjectModelMixin } from \"./AbstractPartOfProjectModelMixin.js\";\n/**\n * This a mixin for every Model that belongs to a scheduler_core project.\n *\n * It adds functions needed to calculate invalidated fields on project commit.\n */\nexport class CorePartOfProjectModelMixin extends Mixin([\n    AbstractPartOfProjectModelMixin,\n    CorePartOfProjectGenericMixin,\n    Model\n], (base) => {\n    const superProto = base.prototype;\n    class CorePartOfProjectModelMixin extends base {\n        constructor() {\n            super(...arguments);\n            // Flag set during calculation\n            this.$isCalculating = false;\n            // Proposed changes\n            this.$changed = {};\n            // Value before proposed change, for buckets that need to update data early\n            this.$beforeChange = {};\n        }\n        get isInActiveTransaction() {\n            return true;\n        }\n        // Invalidate record upon joining project, leads to a buffered commit\n        joinProject() {\n            this.invalidate();\n        }\n        // Trigger a buffered commit when leaving the project\n        leaveProject(isReplacing = false) {\n            superProto.leaveProject.call(this, isReplacing);\n            this.project?.bufferedCommitAsync();\n        }\n        /**\n         * Invalidates this record, queueing it for calculation on project commit.\n         */\n        invalidate() {\n            this.project?.invalidate(this);\n        }\n        /**\n         * Used to retrieve the proposed (before 'dataReady') or current (after 'dataReady') value for a field.\n         * If there is no proposed change, it is functionally equal to a normal `record.get()` call.\n         */\n        getCurrentOrProposed(fieldName) {\n            if (fieldName in this.$changed && this.$changed[fieldName] !== true) {\n                return this.$changed[fieldName];\n            }\n            return this.get(fieldName) ?? null;\n        }\n        /**\n         * Determines if the specified field has a value or not, value can be either current or proposed.\n         */\n        hasCurrentOrProposed(fieldName) {\n            return ((fieldName in this.$changed) && this.$changed[fieldName] != true) || this.get(fieldName) != null;\n        }\n        /**\n         * Propose changes, to be considered during calculation. Also invalidates the record.\n         */\n        propose(changes) {\n            // @ts-ignore\n            if (this.project || this.recurringTimeSpan?.project) {\n                const keys = Object.keys(changes);\n                for (let i = 0; i < keys.length; i++) {\n                    const key = keys[i];\n                    this.$changed[key] = changes[key];\n                }\n                this.invalidate();\n            }\n            else {\n                // If no project, behave as a normal model would\n                this.set(changes);\n            }\n        }\n        /**\n         * Similar to propose, but with more options. Mostly used by buckets, since they need data to update early.\n         */\n        setChanged(field, value, invalidate = true, setData = false) {\n            const me = this;\n            me.$changed[field] = value;\n            // Buckets need to keep data up to date immediately\n            if (setData) {\n                if (!(field in me.$beforeChange)) {\n                    me.$beforeChange[field] = me.get(field);\n                }\n                me.setData(field, value);\n            }\n            invalidate && me.invalidate();\n        }\n        /**\n         * Hook called before project refresh, override and calculate required changes in subclasses\n         */\n        calculateInvalidated() { }\n        /**\n         * Called after project refresh, before dataReady. Announce updated data\n         */\n        finalizeInvalidated(silent = false) {\n            const me = this;\n            me.$isCalculating = true;\n            if (!silent) {\n                // First silently revert any data change (used by buckets), otherwise it won't be detected by `set()`\n                me.setData(me.$beforeChange);\n                // Then do a proper set\n                me.set(me.$changed);\n            }\n            else {\n                me.setData(me.$changed);\n            }\n            me.$changed = {};\n            me.$beforeChange = {};\n            me.$isCalculating = false;\n        }\n    }\n    return CorePartOfProjectModelMixin;\n}) {\n}\n", "import { CI } from \"../../ChronoGraph/collection/Iterator.js\";\nexport const isNotNumber = (value) => Number(value) !== value;\nexport const CIFromSetOrArrayOrValue = (value) => {\n    if (value instanceof Set || value instanceof Array)\n        return CI(value);\n    return CI([value]);\n};\nexport const delay = (value) => new Promise(resolve => setTimeout(resolve, value));\nexport const format = (format, ...values) => {\n    return format.replace(/{(\\d+)}/g, (match, number) => typeof values[number] !== 'undefined' ? values[number] : match);\n};\n", "import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nimport { CIFromSetOrArrayOrValue } from \"../../util/Functions.js\";\n// Shared functionality for CoreAssignmentStore & ChronoAssignmentStore\nexport class AbstractAssignmentStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractAssignmentStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.assignmentsForRemoval = new Set();\n            this.allAssignmentsForRemoval = false;\n        }\n        remove(records, silent) {\n            this.assignmentsForRemoval = CIFromSetOrArrayOrValue(records).toSet();\n            const res = superProto.remove.call(this, records, silent);\n            this.assignmentsForRemoval.clear();\n            return res;\n        }\n        removeAll(silent) {\n            this.allAssignmentsForRemoval = true;\n            const res = superProto.removeAll.call(this, silent);\n            this.allAssignmentsForRemoval = false;\n            return res;\n        }\n    }\n    return AbstractAssignmentStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\n/**\n * Shared functionality for [[CoreCalendarManagerStoreMixin]] and [[ChronoCalendarManagerStoreMixin]]\n */\nexport class AbstractCalendarManagerStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractCalendarManagerStoreMixin extends base {\n        // special handling to destroy calendar models as part of destroying this store\n        doDestroy() {\n            const records = [];\n            // When chained, traverse can be called on destroyed nodes.\n            if (!this.rootNode?.isDestroyed) {\n                this.traverse(record => records.push(record));\n            }\n            super.doDestroy();\n            records.forEach(record => record.destroy());\n        }\n    }\n    return AbstractCalendarManagerStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nimport { CIFromSetOrArrayOrValue } from '../../util/Functions.js';\n// Shared functionality for CoreDependencyStore & ChronoDependencyStore\nexport class AbstractDependencyStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractDependencyStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.dependenciesForRemoval = new Set();\n            this.allDependenciesForRemoval = false;\n        }\n        remove(records, silent) {\n            this.dependenciesForRemoval = CIFromSetOrArrayOrValue(records).toSet();\n            const res = superProto.remove.call(this, records, silent);\n            this.dependenciesForRemoval.clear();\n            return res;\n        }\n        removeAll(silent) {\n            this.allDependenciesForRemoval = true;\n            const res = superProto.removeAll.call(this, silent);\n            this.allDependenciesForRemoval = false;\n            return res;\n        }\n    }\n    return AbstractDependencyStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nconst dataAddRemoveActions = {\n    splice: 1,\n    clear: 1\n};\n// Shared functionality for CoreEventStore & ChronoEventStore\nexport class AbstractEventStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractEventStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.assignmentsForRemoval = new Set();\n            this.dependenciesForRemoval = new Set();\n        }\n        // we need `onDataChange` for `syncDataOnLoad` option to work\n        onDataChange(event) {\n            // remove from a filter action must be ignored.\n            const isAddRemove = dataAddRemoveActions[event.action];\n            super.onDataChange(event);\n            if (isAddRemove && event.removed?.length)\n                this.afterEventRemoval();\n        }\n        // it seems `onDataChange` is not triggered for `remove` with `silent` flag\n        remove(records, silent) {\n            const res = superProto.remove.call(this, records, silent);\n            this.afterEventRemoval();\n            return res;\n        }\n        // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`\n        removeAll(silent) {\n            const res = superProto.removeAll.call(this, silent);\n            this.afterEventRemoval();\n            return res;\n        }\n        onNodeRemoveChild(parent, children, index, flags) {\n            // @ts-ignore\n            const removed = superProto.onNodeRemoveChild.call(this, ...arguments);\n            this.afterEventRemoval();\n            return removed;\n        }\n        afterEventRemoval() {\n            const { assignmentsForRemoval, dependenciesForRemoval } = this;\n            // Can be called from `set data` during construction\n            if (!assignmentsForRemoval)\n                return;\n            // ORDER IS IMPORTANT!\n            // First remove assignments\n            const assignmentStore = this.getAssignmentStore();\n            if (assignmentStore && !assignmentStore.allAssignmentsForRemoval && assignmentsForRemoval.size) {\n                const toRemove = [...assignmentsForRemoval].filter(assignment => !assignmentStore.assignmentsForRemoval.has(assignment));\n                toRemove.length > 0 && assignmentStore.remove(toRemove);\n            }\n            assignmentsForRemoval.clear();\n            // Then remove dependencies\n            const dependencyStore = this.getDependencyStore();\n            if (dependencyStore && !dependencyStore.allDependenciesForRemoval && dependenciesForRemoval.size) {\n                const toRemove = [...dependenciesForRemoval].filter(dependency => !dependencyStore.dependenciesForRemoval.has(dependency));\n                toRemove.length > 0 && dependencyStore.remove(toRemove);\n            }\n            dependenciesForRemoval.clear();\n        }\n        processRecord(eventRecord, isDataset = false) {\n            if (!this.project?.isRepopulatingStores) {\n                const existingRecord = this.getById(eventRecord.id);\n                const isReplacing = existingRecord && existingRecord !== eventRecord;\n                //@ts-ignore\n                if (isReplacing && existingRecord.assigned) {\n                    //@ts-ignore\n                    for (const assignment of existingRecord.assigned) {\n                        assignment.event = eventRecord;\n                    }\n                }\n            }\n            return eventRecord;\n        }\n    }\n    return AbstractEventStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nconst dataAddRemoveActions = {\n    splice: 1,\n    clear: 1\n};\n// Shared functionality for CoreResourceStore & ChronoResourceStore\nexport class AbstractResourceStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractResourceStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.assignmentsForRemoval = new Set();\n        }\n        // we need `onDataChange` for `syncDataOnLoad` option to work\n        onDataChange(event) {\n            // remove from a filter action must be ignored.\n            const isAddRemove = dataAddRemoveActions[event.action];\n            super.onDataChange(event);\n            if (isAddRemove && event.removed?.length)\n                this.afterResourceRemoval();\n        }\n        // it seems `onDataChange` is not triggered for `remove` with `silent` flag\n        remove(records, silent) {\n            const res = superProto.remove.call(this, records, silent);\n            this.afterResourceRemoval();\n            return res;\n        }\n        // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`\n        removeAll(silent) {\n            const res = superProto.removeAll.call(this, silent);\n            this.afterResourceRemoval();\n            return res;\n        }\n        afterResourceRemoval() {\n            const assignmentStore = this.getAssignmentStore();\n            if (assignmentStore && !assignmentStore.allAssignmentsForRemoval) {\n                const assignmentsForRemoval = [...this.assignmentsForRemoval].filter(assignment => !assignmentStore.assignmentsForRemoval.has(assignment));\n                assignmentsForRemoval.length > 0 && assignmentStore.remove(assignmentsForRemoval);\n            }\n            this.assignmentsForRemoval.clear();\n        }\n        processRecord(resourceRecord, isDataset = false) {\n            const existingRecord = this.getById(resourceRecord.id);\n            const isReplacing = existingRecord && existingRecord !== resourceRecord;\n            if (isReplacing) {\n                //@ts-ignore\n                for (const assignment of existingRecord.assigned || []) {\n                    assignment.resource = resourceRecord;\n                }\n            }\n            return resourceRecord;\n        }\n    }\n    return AbstractResourceStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\n/**\n * Core event entity mixin type.\n *\n * At this level event is only aware about its dates\n * The functionality, related to the assignments etc is provided in other mixins.\n */\nexport class CoreEventMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreEventMixin extends base {\n        constructor() {\n            super(...arguments);\n            this._startDate = null;\n            this._endDate = null;\n            this._duration = null;\n        }\n        // Proper engine defines these fields since they enter graph, thus we need them\n        static get fields() {\n            return [\n                { name: 'startDate', type: 'date' },\n                { name: 'endDate', type: 'date' },\n                { name: 'duration', type: 'number' },\n                { name: 'durationUnit', type: 'durationunit', defaultValue: 'day' }\n            ];\n        }\n        // Getters return current or proposed value\n        get startDate() { return this._startDate ?? this.get('startDate') ?? null; }\n        get endDate() { return this._endDate ?? this.get('endDate') ?? null; }\n        get duration() { return this._duration ?? this.get('duration') ?? null; }\n        // Route all setting through applyXX (setStartDate, startDate = , set('startDate'), batching)\n        set startDate(value) { this.proposeStartDate(value); }\n        set endDate(value) { this.proposeEndDate(value); }\n        set duration(value) { this.proposeDuration(value); }\n        //region Edge case normalization\n        inSet(field, value, silent, fromRelationUpdate, skipAccessors) {\n            const me = this;\n            // Catch \"normal\" set calls\n            if (me.project && !me.project.isWritingData && typeof field !== 'string' && !skipAccessors) {\n                // Flag fields as changed even if we are given a no-change value, to let calculations take decision on\n                // whether to keep duration or not\n                if ('startDate' in field && !('startDate' in me.$changed)) {\n                    me.$changed.startDate = true;\n                    me.invalidate();\n                }\n                if ('endDate' in field && !('endDate' in me.$changed)) {\n                    me.$changed.endDate = true;\n                    me.invalidate();\n                }\n            }\n            // @ts-ignore\n            return superProto.inSet.call(me, field, value, silent, fromRelationUpdate, skipAccessors);\n        }\n        //endregion\n        //region StartDate\n        getStartDate() {\n            return this.startDate;\n        }\n        proposeStartDate(startDate, keepDuration = !('endDate' in this.$changed)) {\n            if (this.inSetting || startDate?.getTime() !== this.startDate?.getTime()) {\n                this._startDate = startDate;\n                this.propose({ startDate, keepDuration });\n            }\n        }\n        async setStartDate(startDate, keepDuration = true) {\n            this.proposeStartDate(startDate, keepDuration);\n            return this.project?.commitAsync();\n        }\n        //endregion\n        //region EndDate\n        getEndDate() {\n            return this.endDate;\n        }\n        proposeEndDate(endDate, keepDuration = false) {\n            if (this.inSetting || endDate?.getTime() !== this.endDate?.getTime()) {\n                this._endDate = endDate;\n                this.propose({ endDate, keepDuration });\n            }\n        }\n        async setEndDate(endDate, keepDuration = false) {\n            this.proposeEndDate(endDate, keepDuration);\n            return this.project?.commitAsync();\n        }\n        //endregion\n        //region Duration\n        getDuration() {\n            return this.duration;\n        }\n        proposeDuration(duration, unit, keepStart = true) {\n            this._duration = duration;\n            this.propose({ duration, keepStart });\n            if (unit)\n                this.propose({ durationUnit: unit });\n        }\n        async setDuration(duration, unit, keepStart = true) {\n            this.proposeDuration(duration, unit, keepStart);\n            return this.project?.commitAsync();\n        }\n        getDurationUnit() {\n            return this.durationUnit;\n        }\n        //endregion\n        // When joining as part of inline data, store is available. If joining through load, it is passed\n        joinProject() {\n            const me = this;\n            const changed = me.$changed;\n            const startDate = me.getCurrentOrProposed('startDate');\n            const endDate = me.getCurrentOrProposed('endDate');\n            const duration = me.getCurrentOrProposed('duration');\n            // Initial values should be considered changed, to be normalized\n            if (startDate != null)\n                changed.startDate = me._startDate = startDate;\n            if (endDate != null)\n                changed.endDate = me._endDate = endDate;\n            if (duration != null)\n                changed.duration = me._duration = duration;\n            // Resolve assignments when event joins project after load\n            if (me.eventStore && !me.eventStore.isLoadingData) {\n                const unresolved = me.assignmentStore?.storage.findItem('event', null);\n                if (unresolved) {\n                    // To avoid n\u00B2 iterations over raw assignments we cache them by raw eventId, which saves us\n                    // some iterations over the storage\n                    // https://github.com/bryntum/support/issues/3141\n                    const cachedAssignments = me.assignmentStore?.storage.findItem('eventId', me.id);\n                    if (cachedAssignments) {\n                        for (const assignment of cachedAssignments) {\n                            assignment.setChanged('event', me);\n                        }\n                    }\n                    else {\n                        for (const assignment of unresolved) {\n                            if (assignment.getCurrentOrProposed('event') === me.id) {\n                                assignment.setChanged('event', me);\n                            }\n                        }\n                    }\n                }\n            }\n            superProto.joinProject.call(me);\n        }\n        // Mimic how proper engine applies values\n        applyValue(useProp, key, value, skipAccessors, field) {\n            // @ts-ignore\n            if ((this.project || this.recurringTimeSpan?.project) && field) {\n                const { name } = field;\n                if (name === 'startDate' || name == 'duration' || name === 'endDate') {\n                    useProp = true;\n                    // Update cached value\n                    this['_' + name] = value;\n                }\n                if (skipAccessors) {\n                    useProp = false;\n                }\n            }\n            superProto.applyValue.call(this, useProp, key, value, skipAccessors, field);\n        }\n        // Catch changes from batches etc. In which case it is sometimes expected for data to be available directly\n        afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n            if (!this.$isCalculating && !skipAccessors) {\n                // In certain scenarios data is expected to be available of the bat, messy!\n                this.setData({\n                    startDate: this.getCurrentOrProposed('startDate'),\n                    endDate: this.getCurrentOrProposed('endDate'),\n                    duration: this.getCurrentOrProposed('duration'),\n                    durationUnit: this.getCurrentOrProposed('durationUnit')\n                });\n            }\n            superProto.afterChange.call(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);\n        }\n        // Normalizes dates & duration\n        calculateInvalidated() {\n            const me = this;\n            const changed = me.$changed;\n            const changedStart = 'startDate' in changed;\n            const changedEnd = 'endDate' in changed;\n            const changedDuration = 'duration' in changed;\n            const { startDate, endDate, duration, keepDuration, keepStart } = changed;\n            let calculate = null;\n            // Only start changed\n            if (changedStart && !changedEnd && !changedDuration) {\n                // Also null end when nulling start (keeping duration)\n                if (startDate === null) {\n                    changed.endDate = null;\n                }\n                // Start after end without keeping duration -> move end to start\n                else if (me.hasCurrentOrProposed('endDate') && startDate > me.getCurrentOrProposed('endDate') && !keepDuration) {\n                    changed.endDate = startDate;\n                    changed.duration = 0;\n                }\n                // Start changed and we either have a duration that we want to keep or no end -> calculate end\n                else if (me.hasCurrentOrProposed('duration') && (keepDuration || !me.hasCurrentOrProposed('endDate'))) {\n                    calculate = 'endDate';\n                }\n                // Start change and we have an end already -> calculate duration\n                else if (me.hasCurrentOrProposed('endDate')) {\n                    calculate = 'duration';\n                }\n            }\n            // Only end changed\n            else if (!changedStart && changedEnd && !changedDuration) {\n                // Also null start when nulling end (keeping duration)\n                if (endDate === null) {\n                    changed.startDate = null;\n                }\n                // End before start without keeping duration -> move start to end\n                else if (me.hasCurrentOrProposed('startDate') && !keepDuration && endDate !== true && endDate < me.getCurrentOrProposed('startDate')) {\n                    changed.startDate = endDate;\n                    changed.duration = 0;\n                }\n                // End changed and we either have a duration that we want to keep or no start -> calculate start\n                else if (me.hasCurrentOrProposed('duration') && (keepDuration || !me.hasCurrentOrProposed('startDate'))) {\n                    calculate = 'startDate';\n                }\n                // End changed and we have a start already -> calculate duration\n                else if (me.hasCurrentOrProposed('startDate')) {\n                    calculate = 'duration';\n                }\n            }\n            // Only duration changed\n            else if (!changedStart && !changedEnd && changedDuration) {\n                // Also null end when nulling duration (keeping start)\n                if (duration === null) {\n                    changed.endDate = null;\n                }\n                // Duration changed and we either have a start that we want to keep or no end -> calculate end\n                else if (me.hasCurrentOrProposed('startDate') && (keepStart || !me.hasCurrentOrProposed('endDate'))) {\n                    if (keepStart && changed.duration < 0) {\n                        changed.duration = 0;\n                    }\n                    calculate = 'endDate';\n                }\n                // Duration changed and we have an end already -> calculate start\n                else if (me.hasCurrentOrProposed('endDate')) {\n                    calculate = 'startDate';\n                }\n            }\n            // Start and end change, affect duration\n            else if (changedStart && changedEnd && !changedDuration) {\n                // Both nulled, null duration\n                if (startDate === null && endDate === null) {\n                    changed.duration = null;\n                }\n                // Other cases -> calculate duration\n                else {\n                    calculate = 'duration';\n                }\n            }\n            // Start and duration change -> calculate end\n            else if (changedStart && !changedEnd && changedDuration) {\n                calculate = 'endDate';\n            }\n            // End and duration changed -> calculate start\n            else if (!changedStart && changedEnd && changedDuration) {\n                calculate = 'startDate';\n            }\n            // All changed -> calculate whichever is null or by default end to be sure things add up\n            else if (changedStart && changedEnd && changedDuration) {\n                if (duration == null) {\n                    calculate = 'duration';\n                }\n                else if (startDate == null) {\n                    calculate = 'startDate';\n                }\n                else {\n                    calculate = 'endDate';\n                }\n            }\n            // Normalize if needed\n            const currentOrProposedStartDate = me.getCurrentOrProposed('startDate');\n            const currentOrProposedEndDate = me.getCurrentOrProposed('endDate');\n            const currentOrProposedDuration = me.getCurrentOrProposed('duration');\n            const currentOrProposedDurationUnit = me.getCurrentOrProposed('durationUnit');\n            let hourDuration, targetDuration;\n            switch (calculate) {\n                case 'startDate':\n                    changed.startDate = DateHelper.add(currentOrProposedEndDate, -currentOrProposedDuration, currentOrProposedDurationUnit);\n                    break;\n                case 'endDate':\n                    // convert proposed duration to hours to safely add over DST\n                    hourDuration = DateHelper.as('hour', currentOrProposedDuration, currentOrProposedDurationUnit);\n                    // convert calculated duration to task duration in task duration unit\n                    targetDuration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, 'h');\n                    changed.endDate = DateHelper.add(currentOrProposedStartDate, targetDuration, currentOrProposedDurationUnit);\n                    break;\n                case 'duration':\n                    // convert proposed duration to hours to safely add over DST\n                    hourDuration = DateHelper.diff(currentOrProposedStartDate, currentOrProposedEndDate, 'h');\n                    // convert calculated duration to task duration in task duration unit\n                    changed.duration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, 'h');\n                    break;\n            }\n            if ('startDate' in changed && changed.startDate !== true)\n                this._startDate = changed.startDate;\n            if ('endDate' in changed && changed.endDate !== true)\n                this._endDate = changed.endDate;\n            if ('duration' in changed && changed.duration !== true)\n                this._duration = changed.duration;\n            // Clean up flags, not intended to be actually set\n            if (changed.startDate === true)\n                delete changed.startDate;\n            if (changed.endDate === true)\n                delete changed.endDate;\n            delete changed.keepDuration;\n            delete changed.keepStart;\n        }\n    }\n    return CoreEventMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\n/**\n * Core resource model class.\n */\nexport class CoreResourceMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreResourceMixin extends base {\n        get assigned() {\n            return this.project?.assignmentStore.getResourcesAssignments(this);\n        }\n        joinProject() {\n            // Set up assignment -> resource mapping when joining store after assignment (skip during load)\n            // (note that there is no resourceStore yet when loading inline data, thus the first part of the condition)\n            if (this.resourceStore && !this.resourceStore.isLoadingData) {\n                this.assignmentStore?.query(a => a.get('resource') === this.id).forEach(unresolved => unresolved.setChanged('resource', this));\n            }\n            superProto.joinProject.call(this);\n        }\n        leaveProject(isReplacing = false) {\n            // `this.assigned` will be empty if model is added to project and then removed immediately\n            // w/o any propagations\n            // when replacing a resource or reloading the store, the assignments should be left intact\n            if (this.assigned && !isReplacing && !this.resourceStore?.isLoadingData) {\n                const resourceStore = this.resourceStore;\n                // to batch the assignments removal, we don't remove the assignments right away, but instead\n                // add them for the batched removal to the `assignmentsForRemoval` property of the event store\n                this.assigned.forEach(assignment => resourceStore.assignmentsForRemoval.add(assignment));\n            }\n            superProto.leaveProject.call(this);\n        }\n        applyValue(useProp, key, value, skipAccessor, field) {\n            // Changing id on a resource should update resourceId on its assignments\n            // (note that field might not exist, if user supplies data for undefined fields)\n            if (field?.name === 'id') {\n                this.assigned.forEach(assignment => {\n                    assignment.set('resourceId', value);\n                });\n            }\n            superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);\n        }\n    }\n    return CoreResourceMixin;\n}) {\n}\n", "import { Mixin, isInstanceOf } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\nimport { CoreResourceMixin } from \"./CoreResourceMixin.js\";\nfunction asId(recordOrId) {\n    return recordOrId?.isModel ? recordOrId.id : recordOrId;\n}\n/**\n * Core assignment model class. It just contains references to the [[CoreEventMixin|event]] and [[CoreResourceMixin|resource]] being assigned.\n */\nexport class CoreAssignmentMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreAssignmentMixin extends base {\n        // Fields declared in the Model way, existing decorators all assume ChronoGraph is used\n        static get fields() {\n            return [\n                // isEqual required to properly detect changed resource / event\n                { name: 'resource', isEqual: (a, b) => a === b, persist: false },\n                { name: 'event', isEqual: (a, b) => a === b, persist: false }\n            ];\n        }\n        // Resolve early + update indices to have buckets ready before commit\n        setChanged(field, value, invalidate) {\n            const { assignmentStore, eventStore, resourceStore, project } = this;\n            let update = false;\n            if (field === 'event') {\n                const event = isInstanceOf(value, CoreEventMixin) ? value : eventStore?.$master.getById(value);\n                if (event)\n                    update = true;\n                value = event || value;\n            }\n            if (field === 'resource') {\n                const resource = isInstanceOf(value, CoreResourceMixin) ? value : resourceStore?.$master.getById(value);\n                if (resource)\n                    update = true;\n                value = resource || value;\n            }\n            // Passing true as last arg, bucket expected to work before commit\n            superProto.setChanged.call(this, field, value, invalidate, true);\n            // Update on resolve, if this is a single operation and record is part of project (might be standalone record)\n            if (assignmentStore && update && !project.isPerformingCommit && !assignmentStore.isLoadingData && !resourceStore.isLoadingData && !assignmentStore.skipInvalidateIndices) {\n                assignmentStore.invalidateIndices();\n            }\n        }\n        // Resolve event and resource when joining project\n        joinProject() {\n            superProto.joinProject.call(this);\n            this.setChanged('event', this.get('event'));\n            this.setChanged('resource', this.get('resource'));\n        }\n        // Resolved resource & event as part of commit\n        // Normally done earlier in setChanged, but stores might not have been available yet at that point\n        calculateInvalidated() {\n            // Changed values, should be used instead of current where available\n            let { event = this.event, resource = this.resource } = this.$changed;\n            if (event !== null && !(isInstanceOf(event, CoreEventMixin))) {\n                const resolved = this.eventStore?.getById(event);\n                if (resolved)\n                    this.setChanged('event', resolved, false);\n            }\n            if (resource !== null && !(isInstanceOf(resource, CoreResourceMixin))) {\n                const resolved = this.resourceStore?.getById(resource);\n                if (resolved)\n                    this.setChanged('resource', resolved, false);\n            }\n        }\n        // resourceId and eventId required to be available for new datasets\n        finalizeInvalidated(silent) {\n            const changed = this.$changed;\n            if ('resource' in changed) {\n                changed.resourceId = asId(changed.resource);\n            }\n            if ('event' in changed) {\n                changed.eventId = asId(changed.event);\n            }\n            superProto.finalizeInvalidated.call(this, silent);\n        }\n        //region Event\n        set event(event) {\n            this.setChanged('event', event);\n            this.setChanged('eventId', asId(event));\n        }\n        get event() {\n            const event = this.get('event');\n            // Engine returns null instead of id when unresolved\n            return event?.id != null ? event : null;\n        }\n        //endregion\n        //region Resource\n        set resource(resource) {\n            this.setChanged('resource', resource);\n            this.setChanged('resourceId', asId(resource));\n        }\n        get resource() {\n            const resource = this.get('resource');\n            // Engine returns null instead of id when unresolved\n            return resource?.id != null ? resource : null;\n        }\n    }\n    return CoreAssignmentMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectGenericMixin } from \"../../CorePartOfProjectGenericMixin.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./AbstractPartOfProjectStoreMixin.js\";\n/**\n * This a mixin for every Store, that belongs to a scheduler_core project.\n */\nexport class CorePartOfProjectStoreMixin extends Mixin([\n    AbstractPartOfProjectStoreMixin,\n    CorePartOfProjectGenericMixin,\n    Store\n], (base) => {\n    const superProto = base.prototype;\n    class CorePartOfProjectStoreMixin extends base {\n        setProject(project) {\n            const result = superProto.setProject.call(this, project);\n            if (project)\n                this.joinProject(project);\n            return result;\n        }\n        joinProject(project) { }\n        onCommitAsync() { }\n    }\n    return CorePartOfProjectStoreMixin;\n}) {\n}\n", "import { CoreAssignmentMixin } from \"../model/scheduler_core/CoreAssignmentMixin.js\";\nimport { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { AbstractAssignmentStoreMixin } from \"./AbstractAssignmentStoreMixin.js\";\nconst emptySet = new Set();\n/**\n * A store mixin class, that represent collection of all assignments in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreAssignmentStoreMixin extends Mixin([AbstractAssignmentStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreAssignmentStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.skipInvalidateIndices = false;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: CoreAssignmentMixin,\n                storage: {\n                    extraKeys: [\n                        { property: 'event', unique: false },\n                        { property: 'resource', unique: false },\n                        { property: 'eventId', unique: false }\n                    ]\n                }\n            };\n        }\n        set data(value) {\n            this.allAssignmentsForRemoval = true;\n            super.data = value;\n            this.allAssignmentsForRemoval = false;\n        }\n        getEventsAssignments(event) {\n            return this.storage.findItem('event', event, true) || emptySet;\n        }\n        getResourcesAssignments(resource) {\n            return this.storage.findItem('resource', resource.$original, true) || emptySet;\n        }\n        updateIndices() {\n            this.storage.rebuildIndices();\n        }\n        invalidateIndices() {\n            this.storage.invalidateIndices();\n        }\n        afterLoadData() {\n            this.eventStore && this.linkAssignments(this.eventStore, 'event');\n            this.resourceStore && this.linkAssignments(this.resourceStore, 'resource');\n        }\n        // Link events/resources to assignments, called when those stores are populated or joined to project\n        linkAssignments(store, modelName) {\n            // If we are passed a chained store, the ultimate source of truth is the masterStore\n            store = store.masterStore || store;\n            const unresolved = this.count && this.storage.findItem(modelName, null, true);\n            if (unresolved) {\n                for (const assignment of unresolved) {\n                    const record = store.getById(assignment.getCurrentOrProposed(modelName));\n                    if (record)\n                        assignment.setChanged(modelName, record);\n                }\n                this.invalidateIndices();\n            }\n        }\n        // Unlink events/resources from assignments, called when those stores are cleared\n        unlinkAssignments(modelName) {\n            // Invalidate links to events/resources, need to link to new records so set it back to the id (might be resource or resourceId)\n            // As assignment.resource returns null if it's an id, need to check for that in data\n            this.forEach(assignment => assignment.setChanged(modelName, assignment[modelName]?.id ?? assignment?.getData(modelName) ?? assignment[modelName + 'Id']));\n            this.invalidateIndices();\n        }\n        onCommitAsync() {\n            this.updateIndices();\n        }\n    }\n    return CoreAssignmentStoreMixin;\n}) {\n}\n", "import { CorePartOfProjectModelMixin } from '../mixin/CorePartOfProjectModelMixin.js';\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractCalendarMixin } from \"../AbstractCalendarMixin.js\";\n/**\n * The calendar for project scheduling, it is used to mark certain time intervals as \"non-working\" and ignore them during scheduling.\n *\n * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.\n */\nexport class CoreCalendarMixin extends Mixin([AbstractCalendarMixin, CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreCalendarMixin extends base {\n    }\n    return CoreCalendarMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from './mixin/CorePartOfProjectStoreMixin.js';\nimport { CoreCalendarMixin } from '../model/scheduler_core/CoreCalendarMixin.js';\nimport { AbstractCalendarManagerStoreMixin } from \"./AbstractCalendarManagerStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all calendars in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreCalendarManagerStoreMixin extends Mixin([AbstractCalendarManagerStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreCalendarManagerStoreMixin extends base {\n        static get defaultConfig() {\n            return {\n                tree: true,\n                modelClass: CoreCalendarMixin\n            };\n        }\n    }\n    return CoreCalendarManagerStoreMixin;\n}) {\n}\n", "import { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\nimport { isInstanceOf } from '../../../../ChronoGraph/class/Mixin.js';\nexport class CoreDependencyMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreDependencyMixin extends base {\n        static get fields() {\n            return [\n                { name: 'fromEvent', isEqual: (a, b) => a === b, persist: false },\n                { name: 'toEvent', isEqual: (a, b) => a === b, persist: false }\n            ];\n        }\n        // Resolve early + update indices to have buckets ready before commit\n        setChanged(field, value, invalidate) {\n            let update = false;\n            if (field === 'fromEvent' || field === 'toEvent') {\n                const event = isInstanceOf(value, CoreEventMixin) ? value : this.eventStore?.getById(value);\n                if (event)\n                    update = true;\n                value = event || value;\n            }\n            superProto.setChanged.call(this, field, value, invalidate, true);\n            if (update && !this.project.isPerformingCommit && !this.dependencyStore?.isLoadingData) {\n                this.dependencyStore?.invalidateIndices();\n            }\n        }\n        // Resolve events when joining project\n        joinProject() {\n            superProto.joinProject.call(this);\n            // Initial values should be considered changed, to be normalized\n            // (needs to pass through setChanged for early normalization expected for buckets)\n            this.setChanged('fromEvent', this.get('fromEvent'));\n            this.setChanged('toEvent', this.get('toEvent'));\n        }\n        // Resolved events as part of commit\n        // Normally done earlier in setChanged, but stores might not have been available yet at that point\n        calculateInvalidated() {\n            // Changed values, should be used instead of current where available\n            let { fromEvent, toEvent } = this.$changed;\n            if (fromEvent !== null && !(isInstanceOf(fromEvent, CoreEventMixin))) {\n                const resolved = this.eventStore?.getById(fromEvent);\n                if (resolved)\n                    this.$changed.fromEvent = resolved;\n            }\n            if (toEvent !== null && !(isInstanceOf(toEvent, CoreEventMixin))) {\n                const resolved = this.eventStore?.getById(toEvent);\n                if (resolved)\n                    this.$changed.toEvent = resolved;\n            }\n        }\n        //region Events\n        // Not using \"propose\" mechanism from CoreEventMixin, because buckets are expected to be up to date right away\n        set fromEvent(fromEvent) {\n            this.setChanged('fromEvent', fromEvent);\n        }\n        get fromEvent() {\n            const fromEvent = this.get('fromEvent');\n            // Engine returns null instead of id when unresolved\n            return fromEvent?.id != null ? fromEvent : null;\n        }\n        set toEvent(toEvent) {\n            this.setChanged('toEvent', toEvent);\n        }\n        get toEvent() {\n            const toEvent = this.get('toEvent');\n            // Engine returns null instead of id when unresolved\n            return toEvent?.id != null ? toEvent : null;\n        }\n    }\n    return CoreDependencyMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { CoreDependencyMixin } from \"../model/scheduler_core/CoreDependencyMixin.js\";\nimport { AbstractDependencyStoreMixin } from \"./AbstractDependencyStoreMixin.js\";\nconst emptySet = new Set();\n/**\n * A store mixin class, that represent collection of all dependencies in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreDependencyStoreMixin extends Mixin([AbstractDependencyStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreDependencyStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.dependenciesForRemoval = new Set();\n            this.allDependenciesForRemoval = false;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: CoreDependencyMixin,\n                storage: {\n                    extraKeys: [\n                        { property: 'fromEvent', unique: false },\n                        { property: 'toEvent', unique: false }\n                    ]\n                }\n            };\n        }\n        getIncomingDepsForEvent(event) {\n            return this.storage.findItem('toEvent', event) || emptySet;\n        }\n        getOutgoingDepsForEvent(event) {\n            return this.storage.findItem('fromEvent', event) || emptySet;\n        }\n        set data(value) {\n            this.allDependenciesForRemoval = true;\n            super.data = value;\n            this.allDependenciesForRemoval = false;\n        }\n        updateIndices() {\n            this.storage.rebuildIndices();\n        }\n        invalidateIndices() {\n            this.storage.invalidateIndices();\n        }\n        onCommitAsync() {\n            this.updateIndices();\n        }\n    }\n    return CoreDependencyStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\nimport ObjectHelper from \"../../../../Core/helper/ObjectHelper.js\";\nimport { AbstractHasAssignmentsMixin } from '../AbstractHasAssignmentsMixin.js';\n/**\n * This is a mixin, which can be applied to the [[CoreEventMixin]]. It provides the collection of all assignments,\n * which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class CoreHasAssignmentsMixin extends Mixin([CoreEventMixin, AbstractHasAssignmentsMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreHasAssignmentsMixin extends base {\n        get assigned() {\n            return this.project?.assignmentStore.getEventsAssignments(this) ?? this.$cachedAssignments;\n        }\n        leaveProject(isReplacing = false) {\n            // Expected to still be able to return assignments when removed from project\n            this.$cachedAssignments = this.assigned;\n            super.leaveProject(isReplacing);\n        }\n        applyValue(useProp, key, value, skipAccessor, field) {\n            // Changing id on an event should update resourceId on its assignments\n            if (key === 'id') {\n                this.assigned?.forEach(assignment => assignment.set('eventId', value));\n            }\n            superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);\n        }\n        copy(newId = null, deep = null) {\n            const copy = superProto.copy.call(this, newId, deep);\n            // If deep is everything but object - use default behavior, which is to invoke accessors\n            // If deep is an object, check if it has certain field disabled\n            if ((ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers) || !ObjectHelper.isObject(deep)) {\n                // Copy current assignments, used for occurrences\n                copy.$cachedAssignments = this.assigned;\n            }\n            return copy;\n        }\n    }\n    return CoreHasAssignmentsMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\n/**\n * This is a mixin, which can be applied to the [[CoreEventMixin]]. It provides the collection of all dependencies,\n * which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class CoreHasDependenciesMixin extends Mixin([CoreEventMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreHasDependenciesMixin extends base {\n        get outgoingDeps() {\n            return this.project.dependencyStore.getOutgoingDepsForEvent(this);\n        }\n        get incomingDeps() {\n            return this.project.dependencyStore.getIncomingDepsForEvent(this);\n        }\n        leaveProject() {\n            const eventStore = this.eventStore;\n            // the buckets may be empty if a model is removed from the project immediately after adding\n            // (without propagation)\n            if (this.outgoingDeps) {\n                this.outgoingDeps.forEach(dependency => eventStore.dependenciesForRemoval.add(dependency));\n            }\n            if (this.incomingDeps) {\n                this.incomingDeps.forEach(dependency => eventStore.dependenciesForRemoval.add(dependency));\n            }\n            superProto.leaveProject.call(this);\n        }\n    }\n    return CoreHasDependenciesMixin;\n}) {\n}\n", "import { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { CoreEventMixin } from './CoreEventMixin.js';\nimport { CoreHasAssignmentsMixin } from \"./CoreHasAssignmentsMixin.js\";\nimport { CoreHasDependenciesMixin } from './CoreHasDependenciesMixin.js';\n/**\n * This is an event class, [[SchedulerCoreProjectMixin]] is working with.\n * It is constructed as [[CoreEventMixin]], enhanced with [[CoreHasAssignmentsMixin]] and [[CoreHasDependenciesMixin]]\n */\nexport class SchedulerCoreEvent extends Mixin([\n    CoreEventMixin,\n    CoreHasAssignmentsMixin,\n    CoreHasDependenciesMixin\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerCoreEvent extends base {\n    }\n    return SchedulerCoreEvent;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerCoreEvent } from \"../model/scheduler_core/SchedulerCoreEvent.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { AbstractEventStoreMixin } from \"./AbstractEventStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all events in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreEventStoreMixin extends Mixin([AbstractEventStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreEventStoreMixin extends base {\n        static get defaultConfig() {\n            return {\n                modelClass: SchedulerCoreEvent\n            };\n        }\n        joinProject() {\n            this.assignmentStore?.linkAssignments(this, 'event');\n        }\n        afterLoadData() {\n            this.afterEventRemoval();\n            this.assignmentStore?.linkAssignments(this, 'event');\n        }\n    }\n    return CoreEventStoreMixin;\n}) {\n}\n// /**\n//  * The tree store version of [[EventStoreMixin]].\n//  */\n// export class EventTreeStoreMixin extends Mixin(\n//     [ EventStoreMixin ],\n//     (base : AnyConstructor<EventStoreMixin, typeof EventStoreMixin>) => {\n//\n//     const superProto : InstanceType<typeof base> = base.prototype\n//\n//\n//         class EventTreeStoreMixin extends base {\n//             rootNode            : SchedulerBasicProjectMixin\n//\n//             buildRootNode () : object {\n//                 return this.getProject() || {}\n//             }\n//\n//\n//             static get defaultConfig () : object {\n//                 return {\n//                     tree        : true\n//                 }\n//             }\n//         }\n//\n//         return EventTreeStoreMixin\n//     }){}\n//\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { CoreResourceMixin } from \"../model/scheduler_core/CoreResourceMixin.js\";\nimport { AbstractResourceStoreMixin } from \"./AbstractResourceStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all resources in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreResourceStoreMixin extends Mixin([AbstractResourceStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreResourceStoreMixin extends base {\n        static get defaultConfig() {\n            return {\n                modelClass: CoreResourceMixin\n            };\n        }\n        joinProject() {\n            this.assignmentStore?.linkAssignments(this, 'resource');\n        }\n        afterLoadData() {\n            this.assignmentStore?.linkAssignments(this, 'resource');\n        }\n        clear(removing) {\n            superProto.clear.call(this, removing);\n            this.assignmentStore?.unlinkAssignments('resource');\n        }\n    }\n    return CoreResourceStoreMixin;\n}) {\n}\n", "/**\n * @module Core/data/stm/state/StateBase\n */\nimport Base from '../../../Base.js';\nexport const throwAbstractMethodCall = () => {\n    throw new Error('Abstract method call!');\n};\nexport const throwInvalidMethodCall = () => {\n    throw new Error('Method cannot be called at this state!');\n};\n/**\n * Abstract class for STM states\n *\n * Every on* method should return a state for the STM which it should switch to\n * or throw an exception that this call at this state is illegal.\n *\n * Interface of this class mirrors interface of {@link Core.data.stm.StateTrackingManager}.\n *\n * @abstract\n */\nexport default class StateBase extends Base {\n    canUndo(stm) {\n        throwAbstractMethodCall();\n    }\n    canRedo(stm) {\n        throwAbstractMethodCall();\n    }\n    onUndo(stm) {\n        throwAbstractMethodCall();\n    }\n    onRedo(stm) {\n        throwAbstractMethodCall();\n    }\n    onStartTransaction(stm) {\n        throwAbstractMethodCall();\n    }\n    onStopTransaction(stm) {\n        throwAbstractMethodCall();\n    }\n    onStopTransactionDelayed(stm) {\n        throwAbstractMethodCall();\n    }\n    onRejectTransaction(stm) {\n        throwAbstractMethodCall();\n    }\n    onEnable(stm) {\n        throwAbstractMethodCall();\n    }\n    onDisable(stm) {\n        throwAbstractMethodCall();\n    }\n    onAutoRecordOn(stm) {\n        throwAbstractMethodCall();\n    }\n    onAutoRecordOff(stm) {\n        throwAbstractMethodCall();\n    }\n    onResetQueue(stm) {\n        throwAbstractMethodCall();\n    }\n    onModelUpdate(stm) {\n        throwAbstractMethodCall();\n    }\n    onStoreModelAdd(stm) {\n        throwAbstractMethodCall();\n    }\n    onStoreModelInsert(stm) {\n        throwAbstractMethodCall();\n    }\n    onStoreModelRemove(stm) {\n        throwAbstractMethodCall();\n    }\n    onStoreModelRemoveAll(stm) {\n        throwAbstractMethodCall();\n    }\n    onModelInsertChild(stm) {\n        throwAbstractMethodCall();\n    }\n    onModelRemoveChild(stm) {\n        throwAbstractMethodCall();\n    }\n}\nStateBase._$name = 'StateBase';", "/**\n * @module Core/data/stm/Props.js\n * @internal\n */\nexport const STATE_PROP             = Symbol('STATE_PROP');\nexport const STORES_PROP            = Symbol('STORES_PROP');\nexport const QUEUE_PROP             = Symbol('QUEUE_PROP');\nexport const POS_PROP               = Symbol('POS_PROP');\nexport const TRANSACTION_PROP       = Symbol('TRANSACTION_PROP');\nexport const TRANSACTION_TIMER_PROP = Symbol('TRANSACTION_TIMER_PROP');\nexport const AUTO_RECORD_PROP       = Symbol('AUTO_RECORD_PROP');\nexport const PROPS                  = Object.freeze([\n    STATE_PROP,\n    STORES_PROP,\n    QUEUE_PROP,\n    POS_PROP,\n    TRANSACTION_PROP,\n    TRANSACTION_TIMER_PROP,\n    AUTO_RECORD_PROP\n]);\n", "import StateBase from './StateBase.js';\n/**\n * @module Core/data/stm/state/Registry\n *\n * Provides map of registered STM states.\n *\n * Needed to remove states circular dependency.\n *\n * @internal\n */\nconst registry = new Map();\n/**\n * Registers STM state class with the given name.\n *\n * @private\n *\n * @param {String} name\n * @param {Core.data.stm.state.StateBase} state\n */\nexport const registerStmState = (name, state) => {\n    registry.set(name, state);\n};\n/**\n * Resolves STM state class with the given name.\n *\n * @private\n *\n * @param {String} name\n * @returns {Core.data.stm.state.StateBase} state\n */\nexport const resolveStmState = (state) => {\n    if (typeof state === 'string') {\n        state = registry.get(state);\n    }\n    return state;\n};\n// UMD/module compatible export\n// NOTE: the most compatible way of exporting is:\n//       import registry from './Registry.js';\n//       { registerStmState, resolveStmState } = registry;\n//          or\n//       registry.registerStmState(...);\nexport default {\n    registerStmState,\n    resolveStmState\n};\n", "import { QUEUE_PROP, POS_PROP } from './Props.js';\nexport const resetQueue = (stm, options) => {\n    const { undo, redo } = options;\n    let newProps;\n    if (undo && !redo) {\n        newProps = {\n            [QUEUE_PROP] : stm[QUEUE_PROP].slice(stm.position),\n            [POS_PROP]   : 0\n        };\n    }\n    else if (redo && !undo) {\n        newProps = {\n            [QUEUE_PROP] : stm[QUEUE_PROP].slice(0, stm.position)\n        };\n    }\n    else {\n        newProps = {\n            [QUEUE_PROP] : [],\n            [POS_PROP]   : 0\n        };\n    };\n    return [\n        newProps,\n        () => {\n            stm.notifyStoresAboutQueueReset(options);\n        }\n    ];\n};\n", "/**\n * @module Core/data/stm/state/DisabledState\n */\nimport StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport { AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n/**\n * STM disabled state class.\n *\n * @internal\n */\nexport class DisabledStateClass extends StateBase {\n    canUndo() {\n        return false;\n    }\n    canRedo() {\n        return false;\n    }\n    onUndo() {\n        throwInvalidMethodCall();\n    }\n    onRedo() {\n        throwInvalidMethodCall();\n    }\n    onEnable(stm) {\n        return stm.autoRecord ? 'autoreadystate' : 'readystate';\n    }\n    onDisable() {\n        throwInvalidMethodCall();\n    }\n    onAutoRecordOn() {\n        return {\n            [AUTO_RECORD_PROP] : true\n        };\n    }\n    onAutoRecordOff() {\n        return {\n            [AUTO_RECORD_PROP] : false\n        };\n    }\n    onStartTransaction() {\n        throwInvalidMethodCall();\n    }\n    onStopTransaction()  {\n        throwInvalidMethodCall();\n    }\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n    onRejectTransaction() {\n        throwInvalidMethodCall();\n    }\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n    onModelUpdate()      {}\n    onModelInsertChild() {}\n    onModelRemoveChild() {}\n    onStoreModelAdd()    {}\n    onStoreModelInsert() {}\n    onStoreModelRemove() {}\n    onStoreRemoveAll()   {}\n}\n/**\n * STM disabled state.\n *\n * @internal\n */\nconst DisabledState = new DisabledStateClass();\nexport default DisabledState;\nRegistry.registerStmState('disabledstate', DisabledState);\n", "/**\n * @module Core/data/stm/Transaction\n */\nimport Base from '../../Base.js';\nconst ACTION_QUEUE_PROP = Symbol('ACTION_QUEUE_PROP');\n/**\n * STM transaction class, holds list of actions constituting a transaction.\n *\n * A transaction can be undone and redone. Upon undo all the actions being held\n * are undone in reverse order. Upon redo all the actions being held are redone\n * in forward order.\n */\nexport default class Transaction extends Base {\n    get defaultConfig() {\n        return {\n            /**\n             * Transaction title\n             *\n             * @config {String}\n             */\n            title : null\n        };\n    }\n    construct(...args) {\n        this[ACTION_QUEUE_PROP] = [];\n        super.construct(...args);\n    }\n    /**\n     * Gets transaction's actions queue\n     *\n     * @property {Core.data.stm.action.ActionBase[]}\n     */\n    get queue() {\n        return this[ACTION_QUEUE_PROP].slice(0);\n    }\n    /**\n     * Gets transaction's actions queue length\n     *\n     * @property {Number}\n     */\n    get length() {\n        return this[ACTION_QUEUE_PROP].length;\n    }\n    /**\n     * Adds an action to the transaction.\n     *\n     * @param {Core.data.stm.action.ActionBase|Object} action\n     */\n    addAction(action) {\n        this[ACTION_QUEUE_PROP].push(action);\n    }\n    /**\n     * Undoes actions held\n     */\n    undo() {\n        const queue = this[ACTION_QUEUE_PROP];\n        for (let i = queue.length - 1; i >= 0; --i) {\n            queue[i].undo();\n        }\n    }\n    /**\n     * Redoes actions held\n     */\n    redo() {\n        const queue = this[ACTION_QUEUE_PROP];\n        for (let i = 0, len = queue.length; i < len; ++i) {\n            queue[i].redo();\n        }\n    }\n}\nTransaction._$name = 'Transaction';", "import StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport Transaction from '../Transaction.js';\nimport { STATE_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n/**\n * @module Core/data/stm/state/ReadyState\n */\n/**\n * STM ready state class.\n *\n * @internal\n */\nexport class ReadyStateClass extends StateBase {\n    canUndo(stm) {\n        //      v\n        // |*|*|\n        return 0 < stm.position && stm.position <= stm.length;\n    }\n    canRedo(stm) {\n        //  v\n        // |*|*|\n        return 0 <= stm.position && stm.position < stm.length;\n    }\n    onUndo(stm, steps) {\n        let curPos = stm.position;\n        const\n            queue  = stm[QUEUE_PROP],\n            newPos = Math.max(0, curPos - steps),\n            next = () => {\n                stm.notifyStoresAboutStateRestoringStart();\n                const undoneTransactions = [];\n                while (curPos !== newPos) {\n                    const transaction = queue[--curPos];\n                    transaction.undo();\n                    undoneTransactions.push(transaction);\n                }\n                return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {\n                    stm.notifyStoresAboutStateRestoringStop({ cause : 'undo', transactions : undoneTransactions });\n                }];\n            };\n        return [{\n            [STATE_PROP] : 'restoringstate',\n            [POS_PROP]   : newPos\n        }, next];\n    }\n    onRedo(stm, steps) {\n        let curPos = stm.position;\n        const\n            queue  = stm[QUEUE_PROP],\n            newPos = Math.min(queue.length, curPos + steps);\n        const next = () => {\n            stm.notifyStoresAboutStateRestoringStart();\n            const redoneTransactions = [];\n            do {\n                const transaction = queue[curPos++];\n                transaction.redo();\n                redoneTransactions.push(transaction);\n            }\n            while (curPos !== newPos);\n            return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {\n                stm.notifyStoresAboutStateRestoringStop({ cause : 'redo', transactions : redoneTransactions });\n            }];\n        };\n        return [{\n            [STATE_PROP] : 'restoringstate',\n            [POS_PROP]   : newPos\n        }, next];\n    }\n    onEnable() {\n        throwInvalidMethodCall();\n    }\n    onDisable() {\n        return 'disabledstate';\n    }\n    onAutoRecordOn() {\n        return {\n            [STATE_PROP]       : 'autoreadystate',\n            [AUTO_RECORD_PROP] : true\n        };\n    }\n    onAutoRecordOff() {\n        throwInvalidMethodCall();\n    }\n    onStartTransaction(stm, title) {\n        const transaction = new Transaction({ title });\n        return [{\n            [STATE_PROP]       : 'recordingstate',\n            [TRANSACTION_PROP] : transaction\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStart(transaction);\n        }];\n    }\n    onStopTransaction() {\n        throwInvalidMethodCall();\n    }\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n    onRejectTransaction() {\n        throwInvalidMethodCall();\n    }\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n    onModelUpdate()      {}\n    onModelInsertChild() {}\n    onModelRemoveChild() {}\n    onStoreModelAdd()    {}\n    onStoreModelInsert() {}\n    onStoreModelRemove() {}\n    onStoreRemoveAll()   {}\n}\n/**\n * STM ready state.\n *\n * @internal\n */\nconst ReadyState = new ReadyStateClass();\nexport default ReadyState;\nRegistry.registerStmState('readystate', ReadyState);\n", "/**\n * @module Core/data/stm/state/RecordingState\n */\nimport StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport { STATE_PROP, TRANSACTION_PROP, QUEUE_PROP, POS_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n/**\n * STM recording state class.\n *\n * @internal\n */\nexport class RecordingStateClass extends StateBase {\n    canUndo() {\n        return false;\n    }\n    canRedo() {\n        return false;\n    }\n    onEnable() {}\n    onDisable(stm) {\n        const transaction = stm[TRANSACTION_PROP];\n        stm.notifyStoresAboutStateRecordingStop(transaction, { disabled : true });\n        return {\n            [STATE_PROP]       : 'disabledstate',\n            [TRANSACTION_PROP] : null\n        };\n    }\n    onAutoRecordOn(stm) {\n        return [{\n            [STATE_PROP]       : 'autorecordingstate',\n            [AUTO_RECORD_PROP] : true\n        }, () => {\n            stm.stopTransactionDelayed();\n        }];\n    }\n    onAutoRecordOff() {\n        throwInvalidMethodCall();\n    }\n    onStartTransaction() {\n        throwInvalidMethodCall();\n    }\n    onStopTransaction(stm, title) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            queue       = stm[QUEUE_PROP];\n        let position = stm[POS_PROP];\n        if (transaction.length) {\n            if (!transaction.title && !title && stm.getTransactionTitle) {\n                transaction.title = stm.getTransactionTitle(transaction);\n            }\n            else if (title) {\n                transaction.title = title;\n            }\n            queue[position] = transaction;\n            queue.length    = ++position;\n        }\n        return [{\n            [STATE_PROP]       : 'readystate',\n            [POS_PROP]         : position,\n            [TRANSACTION_PROP] : null\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStop(transaction, { stop : true });\n        }];\n    }\n    onRejectTransaction(stm) {\n        const transaction = stm[TRANSACTION_PROP];\n        return [{\n            [STATE_PROP]       : 'restoringstate',\n            [TRANSACTION_PROP] : null\n        }, () => {\n            if (transaction.length) {\n                transaction.undo();\n            }\n            return [\n                'readystate',\n                () => {\n                    stm.notifyStoresAboutStateRecordingStop(transaction, { rejected : true });\n                }\n            ];\n        }];\n    }\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n    onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));\n    }\n    onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));\n    }\n    onModelRemoveChild(stm, parentModel, childModels, context) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));\n    }\n    onStoreModelAdd(stm, store, models, silent)    {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));\n    }\n    onStoreModelInsert(stm, store, index, models, context, silent) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));\n    }\n    onStoreModelRemove(stm, store, models, context, silent) {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));\n    }\n    onStoreRemoveAll(stm, store, allRecords, silent)   {\n        const transaction = stm[TRANSACTION_PROP];\n        transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));\n    }\n}\n/**\n * STM recording state.\n *\n * @internal\n */\nconst RecordingState = new RecordingStateClass();\nexport default RecordingState;\nRegistry.registerStmState('recordingstate', RecordingState);\n", "/**\n * @module Core/data/stm/state/RestoringState\n */\nimport StateBase, { throwInvalidMethodCall } from './StateBase.js';\nimport { AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\n/**\n * STM restoring state class.\n *\n * @internal\n */\nexport class RestoringStateClass extends StateBase {\n    static get $name() {\n        return 'RestoringStateClass';\n    }\n    canUndo() {\n        return false;\n    }\n    canRedo() {\n        return false;\n    }\n    onUndo() {\n        throwInvalidMethodCall();\n    }\n    onRedo() {\n        throwInvalidMethodCall();\n    }\n    onEnable() {\n        throwInvalidMethodCall();\n    }\n    onDisable() {\n        throwInvalidMethodCall();\n    }\n    onAutoRecordOn() {\n        return {\n            [AUTO_RECORD_PROP] : true\n        };\n    }\n    onAutoRecordOff() {\n        return {\n            [AUTO_RECORD_PROP] : false\n        };\n    }\n    onStartTransaction() {\n        throwInvalidMethodCall();\n    }\n    onStopTransaction()  {\n        throwInvalidMethodCall();\n    }\n    onStopTransactionDelayed() {\n        throwInvalidMethodCall();\n    }\n    onRejectTransaction() {\n        throwInvalidMethodCall();\n    }\n    onQueueReset() {\n        throwInvalidMethodCall();\n    }\n    onModelUpdate()      {}\n    onModelInsertChild() {}\n    onModelRemoveChild() {}\n    onStoreModelAdd()    {}\n    onStoreModelInsert() {}\n    onStoreModelRemove() {}\n    onStoreRemoveAll()   {}\n}\n/**\n * STM restoring state.\n *\n * @internal\n */\nconst RestoringState = new RestoringStateClass();\nexport default RestoringState;\nRegistry.registerStmState('restoringstate', RestoringState);\n", "import { throwInvalidMethodCall } from './StateBase.js';\nimport Transaction from '../Transaction.js';\nimport { ReadyStateClass } from './ReadyState.js';\nimport { STATE_PROP, TRANSACTION_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\n/**\n * @module Core/data/stm/state/AutoReadyState\n */\n/**\n * STM transaction autostart ready state class.\n *\n * @internal\n */\nexport class AutoReadyStateClass extends ReadyStateClass {\n    onAutoRecordOn() {\n        throwInvalidMethodCall();\n    }\n    onAutoRecordOff() {\n        return {\n            [STATE_PROP]       : 'readystate',\n            [AUTO_RECORD_PROP] : false\n        };\n    }\n    onStartTransaction(stm, title) {\n        const transaction = new Transaction({ title });\n        return [{\n            [STATE_PROP]       : 'autorecordingstate',\n            [TRANSACTION_PROP] : transaction\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStart(transaction);\n            stm.stopTransactionDelayed();\n        }];\n    }\n    onModelUpdate(stm, model, newData, oldData) {\n        stm.startTransaction();\n        stm.onModelUpdate(model, newData, oldData);\n    }\n    onModelInsertChild(stm, parentModel, index, childModels, context) {\n        stm.startTransaction();\n        stm.onModelInsertChild(parentModel, index, childModels, context);\n    }\n    onModelRemoveChild(stm, parentModel, childModels, context) {\n        stm.startTransaction();\n        stm.onModelRemoveChild(parentModel, childModels, context);\n    }\n    onStoreModelAdd(stm, store, models, silent) {\n        stm.startTransaction();\n        stm.onStoreModelAdd(store, models, silent);\n    }\n    onStoreModelInsert(stm, store, index, models, context, silent) {\n        stm.startTransaction();\n        stm.onStoreModelInsert(store, index, models, context, silent);\n    }\n    onStoreModelRemove(stm, store, models, context, silent) {\n        stm.startTransaction();\n        stm.onStoreModelRemove(store, models, context, silent);\n    }\n    onStoreRemoveAll(stm, store, allRecords, silent) {\n        stm.startTransaction();\n        stm.onStoreRemoveAll(store, allRecords, silent);\n    }\n}\n/**\n * STM transaction autostart ready state.\n *\n * @internal\n */\nconst AutoReadyState = new AutoReadyStateClass();\nexport default AutoReadyState;\nRegistry.registerStmState('autoreadystate', AutoReadyState);\n", "/**\n * @module Core/data/stm/state/AutoRecordingState\n */\nimport Delayable from '../../../mixin/Delayable.js';\nimport { throwInvalidMethodCall } from './StateBase.js';\nimport { RecordingStateClass } from './RecordingState.js';\nimport { STATE_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, QUEUE_PROP, POS_PROP, AUTO_RECORD_PROP } from '../Props.js';\nimport Registry from './Registry.js';\nimport { resetQueue } from '../Helpers.js';\n/**\n * STM recording state class.\n *\n * @internal\n */\nexport class AutoRecordingStateClass extends RecordingStateClass.mixin(Delayable) {\n    onDisable(stm) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            timer       = stm[TRANSACTION_TIMER_PROP];\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n        stm.notifyStoresAboutStateRecordingStop(transaction, { disabled : true });\n        return {\n            [STATE_PROP]             : 'disabledstate',\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null\n        };\n    }\n    onAutoRecordOn(stm) {\n        throwInvalidMethodCall();\n    }\n    onAutoRecordOff(stm) {\n        const timer       = stm[TRANSACTION_TIMER_PROP];\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n        return {\n            [STATE_PROP]             : 'recordingstate',\n            [AUTO_RECORD_PROP]       : false,\n            [TRANSACTION_TIMER_PROP] : null\n        };\n    }\n    onStopTransaction(stm, title) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            timer       = stm[TRANSACTION_TIMER_PROP],\n            queue       = stm[QUEUE_PROP];\n        let position = stm[POS_PROP];\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n        if (transaction.length) {\n            if (!transaction.title && !title && stm.getTransactionTitle) {\n                transaction.title = stm.getTransactionTitle(transaction);\n            }\n            else if (title) {\n                transaction.title = title;\n            }\n            queue[position] = transaction;\n            queue.length    = ++position;\n        }\n        return [{\n            [STATE_PROP]             : 'autoreadystate',\n            [POS_PROP]               : position,\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null\n        }, () => {\n            stm.notifyStoresAboutStateRecordingStop(transaction, { stop : true });\n        }];\n    }\n    onStopTransactionDelayed(stm) {\n        let timer = stm[TRANSACTION_TIMER_PROP];\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n        timer = this.setTimeout(\n            () => {\n                stm.stopTransaction();\n            },\n            stm.autoRecordTransactionStopTimeout\n        );\n        return {\n            [STATE_PROP]             : AutoRecordingState,\n            [TRANSACTION_TIMER_PROP] : timer\n        };\n    }\n    onResetQueue(stm, options) {\n        return resetQueue(stm, options);\n    }\n    onRejectTransaction(stm) {\n        const\n            transaction = stm[TRANSACTION_PROP],\n            timer = stm[TRANSACTION_TIMER_PROP];\n        if (timer) {\n            this.clearTimeout(timer);\n        }\n        return [{\n            [STATE_PROP]             : 'restoringstate',\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null\n        }, () => {\n            if (transaction.length) {\n                transaction.undo();\n            }\n            return [\n                'autoreadystate',\n                () => {\n                    stm.notifyStoresAboutStateRecordingStop(transaction, { rejected : true });\n                }\n            ];\n        }];\n    }\n    onModelUpdate(stm, ...rest) {\n        super.onModelUpdate(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n    onModelInsertChild(stm, ...rest) {\n        super.onModelInsertChild(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n    onModelRemoveChild(stm, ...rest) {\n        super.onModelRemoveChild(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n    onStoreModelAdd(stm, ...rest)    {\n        super.onStoreModelAdd(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n    onStoreModelInsert(stm, ...rest) {\n        super.onStoreModelInsert(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n    onStoreModelRemove(stm, ...rest) {\n        super.onStoreModelRemove(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n    onStoreRemoveAll(stm, ...rest)   {\n        super.onStoreRemoveAll(stm, ...rest);\n        stm.stopTransactionDelayed();\n    }\n}\n/**\n * STM recording state.\n *\n * @internal\n */\nconst AutoRecordingState = new AutoRecordingStateClass();\nexport default AutoRecordingState;\nRegistry.registerStmState('autorecordingstate', AutoRecordingState);\n", "/**\n * @module Core/data/stm/action/ActionBase\n */\nimport Base from '../../../Base.js';\nconst throwAbstractMethodCall = () => {\n    throw new Error('Abstract method call!');\n};\n/**\n * Base class for STM actions.\n *\n * @abstract\n */\nexport default class ActionBase extends Base {\n    /**\n     * Gets the type of the action (stringified class name).\n     * @readonly\n     * @property {String}\n     */\n    get type() {\n        return this.constructor.name;\n    }\n    /**\n     * Undoes an action\n     */\n    undo() {\n        throwAbstractMethodCall();\n    }\n    /**\n     * Redoes an action\n     */\n    redo() {\n        throwAbstractMethodCall();\n    }\n}\nActionBase._$name = 'ActionBase';", "/**\n * @module Core/data/stm/action/UpdateAction\n */\nimport ActionBase from './ActionBase.js';\nconst\n    MODEL_PROP    = Symbol('MODEL_PROP'),\n    NEW_DATA_PROP = Symbol('NEW_DATA_PROP'),\n    OLD_DATA_PROP = Symbol('OLD_DATA_PROP');\n/**\n * Action to record the fact that a model has been updated.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class UpdateAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a model which has been updated.\n             *\n             * @config {Core.data.Model}\n             * @default\n             */\n            model : undefined,\n            /**\n             * Map of updated properties with new values.\n             *\n             * @config {Object}\n             * @default\n             */\n            newData : undefined,\n            /**\n             * Map of updated properties with old values.\n             *\n             * @config {Object}\n             * @default\n             */\n            oldData : undefined,\n            isInitialUserAction : false\n        };\n    }\n    get type() {\n        return 'UpdateAction';\n    }\n    get model() {\n        return this[MODEL_PROP];\n    }\n    set model(value) {\n        this[MODEL_PROP] = value;\n    }\n    get newData() {\n        return this[NEW_DATA_PROP];\n    }\n    set newData(value) {\n        this[NEW_DATA_PROP] = { ...value };\n    }\n    get oldData() {\n        return this[OLD_DATA_PROP];\n    }\n    set oldData(value) {\n        this[OLD_DATA_PROP] = { ...value };\n    }\n    undo() {\n        const { model, oldData } = this;\n        // engine needs the setters to be activated, since there's some additional logic (for example, invalidate\n        // dispatcher)\n        if (model.$) {\n            Object.assign(model, oldData);\n        }\n        // it seems STM has to use `model.set()` because of `model.inSet` overrides or smth\n        // w/o this call, just with `Object.assign()` above, the view is not refreshed\n        // Since invoking accessor will just forward change to the engine, we need to pass `skipAccessors = true`\n        // to this call to make this change on data level.\n        // Covered by TaskEdit.t `autoSync` subtest\n        // but it seems, bypassing the setters puts the change in the `data` property and does not\n        // modify the engine-like caches, that Core uses\n        // this may lead to change being lost, overwritten by some other change, which does\n        model.set(oldData, null, null, null, Boolean(model.$));\n    }\n    redo() {\n        const { model, newData } = this;\n        // see comments above\n        if (model.$) {\n            Object.assign(model, newData);\n        }\n        model.set(newData, null, null, null, Boolean(model.$));\n    }\n}\nUpdateAction._$name = 'UpdateAction';", "/**\n * @module Core/data/stm/action/InsertChildAction\n */\nimport ActionBase from './ActionBase.js';\nconst\n    PARENT_MODEL_PROP = Symbol('PARENT_MODEL_PROP'),\n    CHILD_MODELS_PROP = Symbol('CHILD_MODELS_PROP'),\n    INSERT_INDEX_PROP = Symbol('INSERT_INDEX_PROP'),\n    CONTEXT_PROP      = Symbol('CONTEXT_PROP');\n/**\n * Action to record the fact of adding a children models into a parent model.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class InsertChildAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a parent model a child model has been added to.\n             *\n             * @config {Core.data.Model}\n             * @default\n             */\n            parentModel : undefined,\n            /**\n             * Children models inserted.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            childModels : undefined,\n            /**\n             * Index a children models are inserted at\n             *\n             * @config {Number}\n             * @default\n             */\n            insertIndex : undefined,\n            /**\n             * Map having children models as keys and values containing previous parent\n             * of each model and index at the previous parent.\n             *\n             * @config {Object}\n             * @default\n             */\n            context : undefined\n        };\n    }\n    get type() {\n        return 'InsertChildAction';\n    }\n    get parentModel() {\n        return this[PARENT_MODEL_PROP];\n    }\n    set parentModel(model) {\n        this[PARENT_MODEL_PROP] = model;\n    }\n    get childModels() {\n        return this[CHILD_MODELS_PROP];\n    }\n    set childModels(models) {\n        this[CHILD_MODELS_PROP] = models.slice(0);\n    }\n    get insertIndex() {\n        return this[INSERT_INDEX_PROP];\n    }\n    set insertIndex(index) {\n        this[INSERT_INDEX_PROP] = index;\n    }\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n    set context(ctx) {\n        this[CONTEXT_PROP] = ctx;\n    }\n    undo() {\n        const\n            { parentModel, context, childModels } = this,\n            byFromParent = new Map(),\n            newlyAdded = new Set();\n        for (const childModel of childModels) {\n            const ctx = context.get(childModel);\n            if (!ctx) {\n                newlyAdded.add(childModel);\n            }\n            else {\n                let undoTaskData = byFromParent.get(ctx.parent);\n                if (!undoTaskData) {\n                    undoTaskData = { moveRight : [], moveLeft : [], moveFromAnotherParent : [] };\n                    byFromParent.set(ctx.parent, undoTaskData);\n                }\n                if (ctx.parent === parentModel) {\n                    if (ctx.index > childModel.parentIndex) {\n                        undoTaskData.moveRight.push({ parent : ctx.parent, model : childModel, index : ctx.index + 1 });\n                    }\n                    else {\n                        undoTaskData.moveLeft.push({ parent : ctx.parent, model : childModel, index : ctx.index });\n                    }\n                }\n                else {\n                    undoTaskData.moveFromAnotherParent.push({ parent : ctx.parent, model : childModel, index : ctx.index });\n                }\n            }\n        }\n        for (const undoTaskData of byFromParent.values()) {\n            const { moveRight, moveLeft } = undoTaskData;\n            moveLeft.sort((a, b) => a.index - b.index);\n            moveRight.sort((a, b) => b.index - a.index);\n        }\n        newlyAdded.forEach(model => model.parent.removeChild(model));\n        for (const undoTaskData of byFromParent.values()) {\n            const { moveRight, moveLeft, moveFromAnotherParent } = undoTaskData;\n            moveLeft.forEach(task => {\n                task.parent.insertChild(task.model, task.index);\n            });\n            moveRight.forEach(task => {\n                task.parent.insertChild(task.model, task.index);\n            });\n            moveFromAnotherParent.forEach(task => {\n                task.parent.insertChild(task.model, task.index);\n            });\n        }\n    }\n    redo() {\n        const { parentModel, insertIndex, childModels } = this;\n        parentModel.insertChild(childModels, insertIndex);\n    }\n}\nInsertChildAction._$name = 'InsertChildAction';", "/**\n * @module Core/data/stm/action/RemoveChildAction\n */\nimport ActionBase from './ActionBase.js';\nconst\n    PARENT_MODEL_PROP = Symbol('PARENT_MODEL_PROP'),\n    CHILD_MODELS_PROP = Symbol('CHILD_MODELS_PROP'),\n    CONTEXT_PROP      = Symbol('CONTEXT_PROP');\n/**\n * Action to record store remove child operation.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class RemoveChildAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a parent model a child model has been removed to.\n             *\n             * @config {Core.data.Model}\n             * @default\n             */\n            parentModel : undefined,\n            /**\n             * Children models removed.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            childModels : undefined,\n            /**\n             * Map having children models as keys and values containing previous parent\n             * index at the parent.\n             *\n             * @config {Object}\n             * @default\n             */\n            context : undefined\n        };\n    }\n    get type() {\n        return 'RemoveChildAction';\n    }\n    get parentModel() {\n        return this[PARENT_MODEL_PROP];\n    }\n    set parentModel(model) {\n        this[PARENT_MODEL_PROP] = model;\n    }\n    get childModels() {\n        return this[CHILD_MODELS_PROP];\n    }\n    set childModels(models) {\n        this[CHILD_MODELS_PROP] = models.slice(0);\n    }\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n    set context(ctx) {\n        this[CONTEXT_PROP] = ctx;\n    }\n    undo() {\n        const { parentModel, context, childModels } = this;\n        // Let's sort models by parent index such that models with lesser index\n        // were inserted back first, thus making valid parent index of models following.\n        childModels.sort((lhs, rhs) => {\n            const\n                lhsIndex = context.get(lhs),\n                rhsIndex = context.get(rhs);\n            return (lhsIndex - rhsIndex);\n        });\n        // Now let's re-insert records back to where they were\n        childModels.forEach(m => {\n            parentModel.insertChild(m, context.get(m));\n        });\n    }\n    redo() {\n        this.parentModel.removeChild(this.childModels);\n    }\n}\nRemoveChildAction._$name = 'RemoveChildAction';", "import ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\n/**\n * @module Core/data/stm/action/AddAction\n */\nconst\n    STORE_PROP      = Symbol('STORE_PROP'),\n    MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP');\n/**\n * Action to record the fact of models adding to a store.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class AddAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store models have been added into.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n            /**\n             * List of models added into the store.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            modelList : undefined,\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n    get type() {\n        return 'AddAction';\n    }\n    get store() {\n        return this[STORE_PROP];\n    }\n    set store(store) {\n        this[STORE_PROP] = store;\n    }\n    get modelList() {\n        return this[MODEL_LIST_PROP];\n    }\n    set modelList(list) {\n        this[MODEL_LIST_PROP] = list.slice(0);\n    }\n    undo() {\n        this.store.remove(this.modelList, this.silent);\n    }\n    redo() {\n        this.store.add(this.modelList, this.silent);\n    }\n}\nAddAction._$name = 'AddAction';", "import ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\n/**\n * @module Core/data/stm/action/InsertAction\n */\nconst\n    STORE_PROP        = Symbol('STORE_PROP'),\n    MODEL_LIST_PROP   = Symbol('MODEL_LIST_PROP'),\n    INSERT_INDEX_PROP = Symbol('INSERT_INDEX_PROP'),\n    CONTEXT_PROP      = Symbol('CONTEXT_PROP');\n/**\n * Action to record the fact of models inserting into a store.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class InsertAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store models have been inserted into.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n            /**\n             * List of models inserted into the store.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            modelList : undefined,\n            /**\n             * Index the models have been inserted at.\n             *\n             * @config {Number}\n             * @default\n             */\n            insertIndex : undefined,\n            /**\n             * Models move context (if models has been moved), if any.\n             * Map this {@link Core/data/Model} instances as keys and their\n             * previous index as values\n             *\n             * @config {Map}\n             * @default\n             */\n            context : undefined,\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n    get type() {\n        return 'InsertAction';\n    }\n    get store() {\n        return this[STORE_PROP];\n    }\n    set store(store) {\n        this[STORE_PROP] = store;\n    }\n    get modelList() {\n        return this[MODEL_LIST_PROP];\n    }\n    set modelList(list) {\n        this[MODEL_LIST_PROP] = list.slice(0);\n    }\n    get insertIndex() {\n        return this[INSERT_INDEX_PROP];\n    }\n    set insertIndex(index) {\n        this[INSERT_INDEX_PROP] = index;\n    }\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n    set context(context) {\n        this[CONTEXT_PROP] = context;\n    }\n    undo() {\n        const { store, modelList, context, silent } = this;\n        // Let's sort models by index such that models with lesser index\n        // were inserted back first, thus making valid index of models following.\n        modelList.sort((lhs, rhs) => {\n            const\n                lhsIndex = context.get(lhs),\n                rhsIndex = context.get(rhs);\n            return lhsIndex !== undefined && rhsIndex !== undefined ? lhsIndex - rhsIndex : 0;\n        });\n        modelList.forEach(m => {\n            const index = context.get(m);\n            // Flag the inserted record that we undo to skip adding it to \"store.removed\"\n            m._undoingInsertion = true;\n            if (index !== undefined) {\n                // Insert at previous index\n                store.insert(index, m, silent);\n            }\n            else {\n                // Just remove\n                store.remove(m, silent);\n            }\n            m._undoingInsertion = false;\n        });\n    }\n    redo() {\n        const me = this;\n        me.store.insert(me.insertIndex, me.modelList, me.silent);\n    }\n}\nInsertAction._$name = 'InsertAction';", "/**\n * @module Core/data/stm/action/RemoveAction\n */\nimport ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\nconst\n    STORE_PROP      = Symbol('STORE_PROP'),\n    MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP'),\n    CONTEXT_PROP    = Symbol('CONTEXT_PROP');\n/**\n * Action to record the fact of models removed from a store.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class RemoveAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store models have been removed from.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n            /**\n             * List of models removed from the store.\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            modelList : undefined,\n            /**\n             * Models removing context.\n             *\n             * @config {Object}\n             * @default\n             */\n            context : undefined,\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n    get type() {\n        return 'RemoveAction';\n    }\n    get store() {\n        return this[STORE_PROP];\n    }\n    set store(store) {\n        this[STORE_PROP] = store;\n    }\n    get modelList() {\n        return this[MODEL_LIST_PROP];\n    }\n    set modelList(list) {\n        this[MODEL_LIST_PROP] = list.slice(0);\n    }\n    get context() {\n        return this[CONTEXT_PROP];\n    }\n    set context(context) {\n        this[CONTEXT_PROP] = context;\n    }\n    undo() {\n        const { store, context, modelList, silent } = this;\n        // Let's sort models by index such that models with lesser index\n        // were inserted back first, thus making valid index of models following.\n        modelList.sort((lhs, rhs) => {\n            const\n                lhsIndex = context.get(lhs),\n                rhsIndex = context.get(rhs);\n            // Here, in contrast to InsertAction, index is always present\n            return lhsIndex - rhsIndex;\n        });\n        modelList.forEach(m => {\n            const index = context.get(m);\n            // Insert at previous index\n            store.insert(index, m, silent);\n        });\n    }\n    redo() {\n        this.store.remove(this.modelList, this.silent);\n    }\n}\nRemoveAction._$name = 'RemoveAction';", "/**\n * @module Core/data/stm/action/RemoveAllAction\n */\nimport ActionBase from './ActionBase.js';\nimport Store from '../../Store.js';\nconst\n    STORE_PROP       = Symbol('STORE_PROP'),\n    ALL_RECORDS_PROP = Symbol('ALL_RECORDS_PROP');\n/**\n * Action to record store remove all operation.\n * @extends Core/data/stm/action/ActionBase\n */\nexport default class RemoveAllAction extends ActionBase {\n    static get defaultConfig() {\n        return {\n            /**\n             * Reference to a store cleared.\n             *\n             * @config {Core.data.Store}\n             * @default\n             */\n            store : undefined,\n            /**\n             * All store records removed\n             *\n             * @config {Core.data.Model[]}\n             * @default\n             */\n            allRecords : undefined,\n            /**\n             * Flag showing if undo/redo should be done silently i.e. with events suppressed\n             *\n             * @config {Boolean}\n             * @default\n             */\n            silent : false\n        };\n    }\n    get type() {\n        return 'RemoveAllAction';\n    }\n    get store() {\n        return this[STORE_PROP];\n    }\n    set store(store) {\n        this[STORE_PROP] = store;\n    }\n    get allRecords() {\n        return this[ALL_RECORDS_PROP];\n    }\n    set allRecords(records) {\n        this[ALL_RECORDS_PROP] = records.slice(0);\n    }\n    undo() {\n        const { store, allRecords, silent } = this;\n        store.add(allRecords, silent);\n    }\n    redo() {\n        this.store.removeAll(this.silent);\n    }\n}\nRemoveAllAction._$name = 'RemoveAllAction';", "/**\n * @module Core/data/stm/StateTrackingManager\n */\nimport Base from '../../Base.js';\nimport Events from '../../mixin/Events.js';\nimport StateBase from './state/StateBase.js';\nimport DisabledState from './state/DisabledState.js';\nimport ReadyState from './state/ReadyState.js';\nimport RecordingState from './state/RecordingState.js';\nimport RestoringState from './state/RestoringState.js';\nimport AutoReadyState from './state/AutoReadyState.js';\nimport AutoRecordingState from './state/AutoRecordingState.js';\nimport Registry from './state/Registry.js';\nimport UpdateAction from './action/UpdateAction.js';\nimport InsertChildAction from './action/InsertChildAction.js';\nimport RemoveChildAction from './action/RemoveChildAction.js';\nimport AddAction from './action/AddAction.js';\nimport InsertAction from './action/InsertAction.js';\nimport RemoveAction from './action/RemoveAction.js';\nimport RemoveAllAction from './action/RemoveAllAction.js';\nimport { STATE_PROP, STORES_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, AUTO_RECORD_PROP } from './Props.js';\nexport const makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {\n    return new UpdateAction({\n        model,\n        newData,\n        oldData,\n        isInitialUserAction\n    });\n};\nexport const makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {\n    return new InsertChildAction({\n        parentModel,\n        childModels,\n        insertIndex,\n        context\n    });\n};\nexport const makeModelRemoveChildAction = (parentModel, childModels, context) => {\n    return new RemoveChildAction({\n        parentModel,\n        childModels,\n        context\n    });\n};\nexport const makeStoreModelAddAction = (store, modelList, silent) => {\n    return new AddAction({\n        store,\n        modelList,\n        silent\n    });\n};\nexport const makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {\n    return new InsertAction({\n        store,\n        insertIndex,\n        modelList,\n        context,\n        silent\n    });\n};\nexport const makeStoreModelRemoveAction = (store, modelList, context, silent) => {\n    return new RemoveAction({\n        store,\n        modelList,\n        context,\n        silent\n    });\n};\nexport const makeStoreRemoveAllAction = (store, allRecords, silent) => {\n    return new RemoveAllAction({\n        store,\n        allRecords,\n        silent\n    });\n};\nconst stateTransition = (stm, event, ...args) => {\n    const\n        oldState = stm.state,\n        newState = event.call(stm[STATE_PROP], stm, ...args);\n    if (typeof newState === 'string') {\n        stm[STATE_PROP] = Registry.resolveStmState(newState);\n    }\n    else if (newState instanceof StateBase) {\n        stm[STATE_PROP] = newState;\n    }\n    else if (Array.isArray(newState)) {\n        const [state, next] = newState;\n        if (typeof state === 'string') {\n            stm[STATE_PROP] = Registry.resolveStmState(state);\n        }\n        else if (state instanceof StateBase) {\n            stm[STATE_PROP] = state;\n        }\n        else if (state && typeof state === 'object') {\n            stm = Object.assign(stm, state);\n            stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);\n        }\n        if (typeof next === 'function') {\n            stateTransition(stm, next, ...args);\n        }\n    }\n    else if (newState && typeof newState === 'object') {\n        stm = Object.assign(stm, newState);\n        stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);\n    }\n    if (oldState !== ReadyState && oldState !== AutoReadyState && (newState !== ReadyState && newState !== AutoReadyState)) {\n        stm.trigger('ready');\n    }\n};\n/**\n * Tracks the state of every store registered via {@link #function-addStore}. It is {@link #config-disabled} by default\n * so remember to call {@link #function-enable} when your stores are registered and initial dataset is loaded.\n * Use {@link #function-undo} / {@link #function-redo} method calls to restore state to a particular\n * point in time\n *\n * ```javascript\n * stm = new StateTrackingManager({\n *     autoRecord : true,\n *     listeners  : {\n *        'recordingstop' : () => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        },\n *        'restoringstop' : ({ stm }) => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        }\n *    },\n *    getTransactionTitle : (transaction) => {\n *        // your custom code to analyze the transaction and return custom transaction title\n *        const lastAction = transaction.queue[transaction.queue.length - 1];\n *\n *        if (lastAction instanceof AddAction) {\n *            let title = 'Add new record';\n *        }\n *\n *        return title;\n *    }\n * });\n *\n * stm.addStore(userStore);\n * stm.addStore(companyStore);\n * stm.addStore(otherStore);\n *\n * stm.enable();\n * ```\n *\n * **Note:** STM currently does not support undoing server side added and saved records.\n * Therefore it's recommended to {@link #function-resetQueue reset the queue}\n * each time a tracked store(s) loads from or saves its changes to the server.\n * If Crud Manager is used it can be done like this:\n *\n * ```javascript\n * crudManager.on({\n *     requestDone() {\n *         stm.resetQueue();\n *     }\n * });\n * ```\n *\n * and in case individual stores are used:\n *\n * ```javascript\n * ajaxStore.on({\n *     afterRequest({ exception }) {\n *         if (!exception) {\n *             stm.resetQueue();\n *         }\n *     }\n * });\n * ```\n *\n * @mixes Core/mixin/Events\n * @extends Core/Base\n */\nexport default class StateTrackingManager extends Events(Base) {\n    static get defaultConfig() {\n        return {\n            /**\n             * Default manager disabled state\n             *\n             * @config {Boolean}\n             * @default\n             */\n            disabled : true,\n            /**\n             * Whether to start transaction recording automatically in case the Manager is enabled.\n             *\n             * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.\n             * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and\n             * afterwards creates one undo/redo step, including all changes in the stores during that period of time.\n             *\n             * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end\n             * a transaction.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            autoRecord : false,\n            /**\n             * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}\n             *\n             * @config {Number}\n             * @default\n             */\n            autoRecordTransactionStopTimeout : 100,\n            /**\n             * Store model update action factory\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeModelUpdateAction,\n            /**\n             * Store insert child model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeModelInsertChildAction,\n            /**\n             * Store remove child model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeModelRemoveChildAction,\n            /**\n             * Store add model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreModelAddAction,\n            /**\n             * Store insert model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreModelInsertAction,\n            /**\n             * Store remove model action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreModelRemoveAction,\n            /**\n             * Store remove all models action factory.\n             *\n             * @config {Function}\n             * @default\n             * @private\n             */\n            makeStoreRemoveAllAction,\n            /**\n             * Function to create a transaction title if none is provided.\n             *\n             * The function receives a transaction and should return a title.\n             *\n             * @config {Function}\n             * @default\n             */\n            getTransactionTitle : null\n        };\n    }\n    construct(...args) {\n        Object.assign(this, {\n            [STATE_PROP]             : ReadyState,\n            [STORES_PROP]            : [],\n            [QUEUE_PROP]             : [],\n            [POS_PROP]               : 0,\n            [TRANSACTION_PROP]       : null,\n            [TRANSACTION_TIMER_PROP] : null,\n            [AUTO_RECORD_PROP]       : false\n        });\n        super.construct(...args);\n    }\n    /**\n     * Gets current state of the manager\n     *\n     * @property {Core.data.stm.state.StateBase}\n     */\n    get state() {\n        return this[STATE_PROP];\n    }\n    /**\n     * Gets current undo/redo queue position\n     *\n     * @property {Number}\n     */\n    get position() {\n        return this[POS_PROP];\n    }\n    /**\n     * Gets current undo/redo queue length\n     *\n     * @property {Number}\n     */\n    get length() {\n        return this[QUEUE_PROP].length;\n    }\n    /**\n     * Gets all the stores registered in STM\n     *\n     * @property {Core.data.Store[]}\n     */\n    get stores() {\n        return Array.from(this[STORES_PROP]);\n    }\n    /**\n     * Checks if a store has been added to the manager\n     *\n     * @param  {Core.data.Store} store\n     * @returns {Boolean}\n     */\n    hasStore(store) {\n        return this[STORES_PROP].includes(store);\n    }\n    /**\n     * Adds a store to the manager\n     *\n     * @param {Core.data.Store} store\n     */\n    addStore(store) {\n        if (!this.hasStore(store)) {\n            this[STORES_PROP].push(store);\n            store.stm = this;\n        }\n    }\n    /**\n     * Removes a store from the manager\n     *\n     * @param {Core.data.Store} store\n     */\n    removeStore(store) {\n        if (this.hasStore(store)) {\n            this[STORES_PROP] = this[STORES_PROP].filter(s => s !== store);\n            store.stm = null;\n        }\n    }\n    /**\n     * Calls `fn` for each store registered in STM.\n     *\n     * @param {Function} fn (store, id) => ...\n     */\n    forEachStore(fn) {\n        this[STORES_PROP].forEach(s => fn(s, s.id));\n    }\n    //#region Disabled state\n    /**\n     * Get/set manager disabled state\n     *\n     * @property {Boolean}\n     */\n    get disabled() {\n        return this.state === DisabledState;\n    }\n    set disabled(val) {\n        const me = this;\n        if (me.disabled !== val) {\n            if (val) {\n                stateTransition(me, me.state.onDisable, me);\n            }\n            else {\n                stateTransition(me, me.state.onEnable, me);\n            }\n            me.trigger('stmDisabled', { disabled : val });\n            /**\n             * Fired when the disabled state of the STM changes\n             *\n             * @event disabled\n             * @param {Core.data.stm.StateTrackingManager} source\n             * @param {Boolean} disabled The current disabled state of the STM\n             */\n            me.trigger('disabled', { disabled : val });\n        }\n    }\n    get enabled() {\n        return !this.disabled;\n    }\n    /**\n     * Enables manager\n     */\n    enable() {\n        this.disabled = false;\n    }\n    /**\n     * Disables manager\n     */\n    disable() {\n        this.disabled = true;\n    }\n    //#endregion\n    /**\n     * Checks manager ready state\n     * @readonly\n     * @property {Boolean}\n     */\n    get isReady() {\n        return this.state === ReadyState || this.state === AutoReadyState;\n    }\n    waitForReadiness() {\n        return this.await('ready', false);\n    }\n    /**\n     * Checks manager recording state\n     * @readonly\n     * @property {Boolean}\n     */\n    get isRecording() {\n        return this.state === RecordingState || this.state === AutoRecordingState;\n    }\n    /**\n     * Gets/sets manager auto record option\n     *\n     * @property {Boolean}\n     */\n    get autoRecord() {\n        return this[AUTO_RECORD_PROP];\n    }\n    set autoRecord(value) {\n        const me = this;\n        if (me.autoRecord != value) {\n            if (value) {\n                stateTransition(me, me.state.onAutoRecordOn, me);\n            }\n            else {\n                stateTransition(me, me.state.onAutoRecordOff, me);\n            }\n        }\n    }\n    /**\n     * Starts undo/redo recording transaction.\n     *\n     * @param {String} [title]\n     */\n    startTransaction(title = null) {\n        stateTransition(this, this.state.onStartTransaction, title);\n    }\n    /**\n     * Stops undo/redo recording transaction\n     *\n     * @param {String} [title]\n     */\n    stopTransaction(title = null) {\n        stateTransition(this, this.state.onStopTransaction, title);\n    }\n    /**\n     * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.\n     *\n     * @private\n     */\n    stopTransactionDelayed() {\n        stateTransition(this, this.state.onStopTransactionDelayed);\n    }\n    /**\n     * Rejects currently recorded transaction.\n     */\n    rejectTransaction() {\n        stateTransition(this, this.state.onRejectTransaction);\n    }\n    /**\n     * Gets currently recording STM transaction.\n     * @readonly\n     * @property {Core.data.stm.Transaction}\n     */\n    get transaction() {\n        return this[TRANSACTION_PROP];\n    }\n    /**\n     * Gets titles of all recorded undo/redo transactions\n     * @readonly\n     * @property {String[]}\n     */\n    get queue() {\n        return this[QUEUE_PROP].map((t) => t.title);\n    }\n    get rawQueue() {\n        return this[QUEUE_PROP];\n    }\n    /**\n     * Gets manager restoring state.\n     * @readonly\n     * @property {Boolean}\n     */\n    get isRestoring() {\n        return this.state === RestoringState;\n    }\n    /**\n     * Checks if the manager can undo.\n     *\n     * @property {Boolean}\n     */\n    get canUndo() {\n        return this.state.canUndo(this);\n    }\n    /**\n     * Checks if the manager can redo.\n     *\n     * @property {Boolean}\n     */\n    get canRedo() {\n        return this.state.canRedo(this);\n    }\n    /**\n     * Undoes current undo/redo transaction.\n     * @param {Number} [steps=1]\n     * @returns {Promise} A promise which is resolved when undo action has been performed\n     */\n    async undo(steps = 1) {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        stateTransition(this, this.state.onUndo, steps);\n    }\n    /**\n     * Undoes all transactions.\n     * @returns {Promise} A promise which is resolved when undo actions has been performed\n     */\n    async undoAll() {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        this.undo(this.length);\n    }\n    /**\n     * Redoes current undo/redo transaction.\n     *\n     * @param {Number} [steps=1]\n     * @returns {Promise} A promise which is resolved when redo action has been performed\n     */\n    async redo(steps = 1) {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        stateTransition(this, this.state.onRedo, steps);\n    }\n    /**\n     * Redoes all transactions.\n     * @returns {Promise} A promise which is resolved when redo actions has been performed\n     */\n    async redoAll() {\n        if (!this.isReady) {\n            await this.waitForReadiness();\n        }\n        this.redo(this.length);\n    }\n    /**\n     * Resets undo/redo queue.\n     */\n    resetQueue(/* private */options = { undo : true, redo : true }) {\n        stateTransition(this, this.state.onResetQueue, options);\n    }\n    /**\n     * Resets undo queue.\n     */\n    resetUndoQueue() {\n        this.resetQueue({ undo : true });\n    }\n    /**\n     * Resets redo queue.\n     */\n    resetRedoQueue() {\n        this.resetQueue({ redo : true });\n    }\n    notifyStoresAboutStateRecordingStart(transaction) {\n        this.forEachStore((store) => store.onStmRecordingStart?.(this, transaction));\n        /**\n         * Fired upon state recording operation starts.\n         *\n         * @event recordingStart\n         * @param {Core.data.stm.StateTrackingManager} stm\n         * @param {Core.data.stm.Transaction} transaction\n         */\n        this.trigger('recordingStart', { stm : this, transaction });\n    }\n    notifyStoresAboutStateRecordingStop(transaction, reason) {\n        this.forEachStore((store) => store.onStmRecordingStop?.(this, transaction, reason));\n        /**\n         * Fired upon state recording operation stops.\n         *\n         * @event recordingStop\n         * @param {Core.data.stm.StateTrackingManager} stm\n         * @param {Core.data.stm.Transaction} transaction\n         * @param {Object} reason Transaction stop reason\n         * @param {Boolean} reason.stop Transaction recording has been stopped in a normal way.\n         * @param {Boolean} reason.disabled Transaction recording has been stopped due to STM has been disabled.\n         * @param {Boolean} reason.rejected Transaction recording has been stopped due to transaction has been rejected.\n         */\n        this.trigger('recordingStop', { stm : this, transaction, reason });\n    }\n    notifyStoresAboutStateRestoringStart() {\n        this.forEachStore((store) => store.onStmRestoringStart?.(this));\n        /**\n         * Fired upon state restoration operation starts.\n         *\n         * @event restoringStart\n         * @param {Core.data.stm.StateTrackingManager} stm\n         */\n        this.trigger('restoringStart', { stm : this });\n    }\n    /**\n     * @param {'undo'|'redo'} cause The cause of the restore, if applicable\n     * @internal\n     */\n    notifyStoresAboutStateRestoringStop({ cause, transactions }) {\n        this.forEachStore((store) => store.onStmRestoringStop?.(this));\n        /**\n         * Fired upon state restoration operation stops.\n         *\n         * @event restoringStop\n         * @param {Core.data.stm.StateTrackingManager} stm\n         */\n        this.trigger('restoringStop', { stm : this, cause, transactions });\n    }\n    notifyStoresAboutQueueReset(options) {\n        this.forEachStore((store) => store.onStmQueueReset?.(this, options));\n        /**\n         * Fired upon state undo/redo queue reset.\n         *\n         * @event queueReset\n         * @param {Core.data.stm.StateTrackingManager} stm\n         */\n        this.trigger('queueReset', { stm : this, options });\n    }\n    /**\n     * Method to call from model STM mixin upon model update\n     *\n     * @param {Core.data.Model} model\n     * @param {Object} newData\n     * @param {Object} oldData\n     *\n     * @private\n     */\n    onModelUpdate(model, newData, oldData, isInitialUserAction) {\n        stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);\n    }\n    /**\n     * Method to call from model STM mixin upon tree model child insertion\n     *\n     * @param {Core.data.Model} parentModel Parent model\n     * @param {Number} index Insertion index\n     * @param {Core.data.Model[]} childModels Array of models inserted\n     * @param {Map} context Map with inserted models as keys and objects with previous parent,\n     *                      and index at previous parent.\n     *\n     * @private\n     */\n    onModelInsertChild(parentModel, index, childModels, context) {\n        stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);\n    }\n    /**\n     * Method to call from model STM mixin upon tree model child removal\n     *\n     * @param {Core.data.Model} parentModel\n     * @param {Core.data.Model[]} childModels\n     * @param {Map} context\n     *\n     * @private\n     */\n    onModelRemoveChild(parentModel, childModels, context) {\n        stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);\n    }\n    /**\n     * Method to call from store STM mixin upon store models adding\n     *\n     * @param {Core.data.Store} store\n     * @param {Core.data.Model[]} models\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreModelAdd(store, models, silent) {\n        stateTransition(this, this.state.onStoreModelAdd, store, models, silent);\n    }\n    /**\n     * Method to call from store STM mixin upon store models insertion\n     *\n     * @param {Core.data.Store} store\n     * @param {Number} index\n     * @param {Core.data.Model[]} models\n     * @param {Map} context\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreModelInsert(store, index, models, context, silent) {\n        stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);\n    }\n    /**\n     * Method to call from store STM mixin upon store models removal\n     *\n     * @param {Core.data.Store} store\n     * @param {Core.data.Model[]} models\n     * @param {Object} context\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreModelRemove(store, models, context, silent) {\n        stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);\n    }\n    /**\n     * Method to call from store STM mixin upon store clear\n     *\n     * @param {Core.data.Store} store\n     * @param {Core.data.Model[]} allRecords\n     * @param {Boolean} silent\n     *\n     * @private\n     */\n    onStoreRemoveAll(store, allRecords, silent) {\n        stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);\n    }\n    // UI key event handling\n    onUndoKeyPress(event) {\n        const me = this;\n        if (me.enabled) {\n            if (event.shiftKey) {\n                if (me.canRedo) {\n                    event.preventDefault();\n                    me.redo();\n                }\n            }\n            else if (me.canUndo) {\n                event.preventDefault();\n                me.undo();\n            }\n        }\n    }\n    stash() {\n        if (this.transaction) {\n            this.stashedTransaction = this.transaction;\n            this.rejectTransaction();\n        }\n    }\n    applyStash() {\n        if (this.stashedTransaction) {\n            this.startTransaction(this.stashedTransaction.title);\n            this.stashedTransaction.redo();\n            delete this.stashedTransaction;\n        }\n    }\n}\nStateTrackingManager._$name = 'StateTrackingManager';", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport Delayable from \"../../../Core/mixin/Delayable.js\";\nimport Events from \"../../../Core/mixin/Events.js\";\nimport Model from \"../../../Core/data/Model.js\";\nexport class EventsWrapper extends Mixin([], Events) {\n}\nexport class DelayableWrapper extends Mixin([], Delayable) {\n}\n/**\n * This is an abstract project, which just lists the available stores.\n *\n * The actual project classes are [[SchedulerCoreProjectMixin]], [[SchedulerBasicProjectMixin]],\n * [[SchedulerProProjectMixin]], [[GanttProjectMixin]].\n */\nexport class AbstractProjectMixin extends Mixin([\n    EventsWrapper,\n    DelayableWrapper,\n    Model\n], (base) => {\n    const superProto = base.prototype;\n    class AbstractProjectMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.isRestoringData = false;\n        }\n        get isRepopulatingStores() {\n            return false;\n        }\n        get isInitialCommit() {\n            return !this.isInitialCommitPerformed || this.hasLoadedDataToCommit;\n        }\n        construct(config = {}) {\n            // Define default values for these flags here\n            // if defined where declared then TS compiles them this way:\n            // constructor() {\n            //     super(...arguments)\n            //     this.isInitialCommitPerformed   = false\n            //     this.isLoadingInlineData        = false\n            //     this.isWritingData              = false\n            //\n            // }\n            // which messes the flags values for inline data loading (since it's async)\n            this.isInitialCommitPerformed = false;\n            this.isLoadingInlineData = false;\n            this.isWritingData = false;\n            this.hasLoadedDataToCommit = false;\n            const silenceInitialCommit = ('silenceInitialCommit' in config) ? config.silenceInitialCommit : true;\n            const adjustDurationToDST = ('adjustDurationToDST' in config) ? config.adjustDurationToDST : false;\n            // 5 years roughly === 5 * 365 * 24 * 60 * 60 * 1000\n            this.maxCalendarRange = ('maxCalendarRange' in config) ? config.maxCalendarRange : 157680000000;\n            // delete configs otherwise super.construct() call treat them as fields and makes accessors for them\n            delete config.maxCalendarRange;\n            delete config.silenceInitialCommit;\n            delete config.adjustDurationToDST;\n            superProto.construct.call(this, config);\n            this.silenceInitialCommit = silenceInitialCommit;\n            this.adjustDurationToDST = adjustDurationToDST;\n        }\n        // Template method called when a stores dataset is replaced. Implemented in SchedulerBasicProjectMixin\n        repopulateStore(store) { }\n        // Template method called when replica should be repopulated. Implemented in SchedulerBasicProjectMixin\n        repopulateReplica() { }\n        deferUntilRepopulationIfNeeded(deferId, func, args) {\n            // no deferring at this level (happens in projects using engine)\n            func(...args);\n        }\n        // Template method called when a store is attached to the project\n        attachStore(store) { }\n        // Template method called when a store is detached to the project\n        detachStore(store) { }\n        async commitAsync() {\n            throw new Error(\"Abstract method called\");\n        }\n        // Different implementations for Core and Basic engines\n        isEngineReady() {\n            throw new Error(\"Abstract method called\");\n        }\n        getStm() {\n            throw new Error(\"Abstract method called\");\n        }\n    }\n    return AbstractProjectMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerCoreEvent } from \"./SchedulerCoreEvent.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nimport Model from \"../../../../Core/data/Model.js\";\nimport Delayable from \"../../../../Core/mixin/Delayable.js\";\nimport { CoreEventStoreMixin } from \"../../store/CoreEventStoreMixin.js\";\nimport { CoreAssignmentMixin } from \"./CoreAssignmentMixin.js\";\nimport { CoreAssignmentStoreMixin } from \"../../store/CoreAssignmentStoreMixin.js\";\nimport { CoreResourceMixin } from \"./CoreResourceMixin.js\";\nimport { CoreResourceStoreMixin } from \"../../store/CoreResourceStoreMixin.js\";\nimport { CorePartOfProjectGenericMixin } from \"../../CorePartOfProjectGenericMixin.js\";\nimport { CoreDependencyStoreMixin } from \"../../store/CoreDependencyStoreMixin.js\";\nimport { CoreDependencyMixin } from \"./CoreDependencyMixin.js\";\nimport { CoreCalendarMixin } from './CoreCalendarMixin.js';\nimport { CoreCalendarManagerStoreMixin } from '../../store/CoreCalendarManagerStoreMixin.js';\nimport { delay } from \"../../../util/Functions.js\";\nimport StateTrackingManager from \"../../../../Core/data/stm/StateTrackingManager.js\";\nimport { AbstractProjectMixin } from \"../AbstractProjectMixin.js\";\nimport ObjectHelper from \"../../../../Core/helper/ObjectHelper.js\";\nexport class DelayableWrapper extends Mixin([], Delayable) {\n}\n/**\n * This is a project, implementing _basic scheduling_ as [[SchedulerBasicProjectMixin]] does.\n * Yet this class does not use _chronograph_ based engine.\n */\nexport class SchedulerCoreProjectMixin extends Mixin([\n    AbstractProjectMixin,\n    CorePartOfProjectGenericMixin,\n    DelayableWrapper,\n    Model\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerCoreProjectMixin extends base {\n        static get configurable() {\n            return {\n                stm: {},\n                eventStore: {},\n                assignmentStore: {},\n                resourceStore: {},\n                dependencyStore: {},\n                calendarManagerStore: {},\n                eventModelClass: SchedulerCoreEvent,\n                assignmentModelClass: CoreAssignmentMixin,\n                resourceModelClass: CoreResourceMixin,\n                dependencyModelClass: CoreDependencyMixin,\n                calendarModelClass: CoreCalendarMixin,\n                eventStoreClass: CoreEventStoreMixin,\n                assignmentStoreClass: CoreAssignmentStoreMixin,\n                resourceStoreClass: CoreResourceStoreMixin,\n                dependencyStoreClass: CoreDependencyStoreMixin,\n                calendarManagerStoreClass: CoreCalendarManagerStoreMixin,\n                assignmentsData: null,\n                calendarsData: null,\n                dependenciesData: null,\n                eventsData: null,\n                resourcesData: null\n            };\n        }\n        //endregion\n        //region Init\n        construct(config = {}) {\n            const me = this;\n            // Cannot be created with declaration, because of how TS is compiled to JS. Ends up after `construct()`\n            me.$invalidated = new Set();\n            // Define default values for these flags here\n            // if defined where declared then TS compiles them this way:\n            // constructor() {\n            //     super(...arguments)\n            //     this.isPerformingCommit   = false\n            //     this.silenceInitialCommit = true\n            //     this.ongoing              = Promise.resolve()\n            // }\n            // which messes the flags values for inline data loading (since it's async)\n            me.isPerformingCommit = false;\n            me.silenceInitialCommit = true;\n            me.ongoing = Promise.resolve();\n            if (config.eventStore && !config.assignmentStore) {\n                const eventStore = config.eventStore.masterStore || config.eventStore;\n                // If chained from a CrudManager, the assignment store might not be part of a project, and we might\n                // need to ingest it from the CrudManager\n                // @ts-ignore\n                const assignmentStore = eventStore.assignmentStore || eventStore.crudManager?.assignmentStore;\n                // In this case we must ingest the assignment store from the eventStore\n                if (assignmentStore?.isAssignmentStore) {\n                    config.assignmentStore = assignmentStore;\n                    me.isSharingAssignmentStore = true;\n                }\n            }\n            superProto.construct.call(me, config);\n            // not part of the CalendarManagerStore intentionally, not persisted\n            me.defaultCalendar = new me.calendarManagerStore.modelClass({\n                unspecifiedTimeIsWorking: me.unspecifiedTimeIsWorking\n            });\n            me.defaultCalendar.project = me;\n            const { calendarsData, eventsData, dependenciesData, resourcesData, assignmentsData } = me;\n            const hasInlineData = Boolean(calendarsData || eventsData || dependenciesData || resourcesData || assignmentsData);\n            if (hasInlineData) {\n                me.loadInlineData({\n                    calendarsData,\n                    eventsData,\n                    dependenciesData,\n                    resourcesData,\n                    assignmentsData\n                });\n                delete me.calendarsData;\n                delete me.eventsData;\n                delete me.dependenciesData;\n                delete me.resourcesData;\n                delete me.assignmentsData;\n            }\n            else {\n                // Trigger initial commit\n                me.bufferedCommitAsync();\n            }\n        }\n        doDestroy() {\n            const me = this;\n            me.eventStore?.destroy();\n            me.dependencyStore?.destroy();\n            me.assignmentStore?.destroy();\n            me.resourceStore?.destroy();\n            me.calendarManagerStore?.destroy();\n            me.defaultCalendar.destroy();\n            me.stm?.destroy();\n            superProto.doDestroy.call(this);\n        }\n        /**\n         * This method loads the \"raw\" data into the project. The loading is basically happening by\n         * assigning the individual data entries to the `data` property of the corresponding store.\n         *\n         * @param data\n         */\n        async loadInlineData(data) {\n            const me = this;\n            me.isLoadingInlineData = true;\n            if (data.calendarsData) {\n                me.calendarManagerStore.data = data.calendarsData;\n            }\n            if (data.resourcesData) {\n                me.resourceStore.data = data.resourcesData;\n            }\n            if (data.assignmentsData) {\n                me.assignmentStore.data = data.assignmentsData;\n            }\n            if (data.eventsData) {\n                me.eventStore.data = data.eventsData;\n            }\n            if (data.tasksData) {\n                me.eventStore.data = data.tasksData;\n            }\n            if (data.dependenciesData) {\n                me.dependencyStore.data = data.dependenciesData;\n            }\n            await me.commitLoad();\n            me.isLoadingInlineData = false;\n            return;\n        }\n        //endregion\n        //region Join\n        async commitLoad() {\n            await this.commitAsync();\n            // Might have been destroyed during the async operation above\n            if (!this.isDestroyed)\n                this.trigger('load');\n        }\n        joinStoreRecords(store) {\n            const fn = (record) => {\n                record.setProject(this);\n                record.joinProject();\n            };\n            if (store.rootNode) {\n                store.rootNode.traverse(fn);\n            }\n            else {\n                store.forEach(fn);\n            }\n        }\n        unJoinStoreRecords(store) {\n            const fn = (record) => {\n                record.leaveProject();\n                record.setProject(this);\n            };\n            if (store.rootNode) {\n                store.rootNode.traverse(node => {\n                    // do not unjoin/leave project for the root node, which is the project itself\n                    if (node !== store.rootNode)\n                        fn(node);\n                });\n            }\n            else {\n                store.forEach(fn);\n            }\n        }\n        //endregion\n        //region EventStore\n        resolveStoreAndModelClass(name, config) {\n            // storeClass from supplied config or our properties\n            const storeClass = config?.storeClass || this[`${name}StoreClass`];\n            // modelClass from supplied config\n            let modelClass = config?.modelClass;\n            if (!modelClass) {\n                // or from storeClass.modelClass if customized\n                // @ts-ignore\n                if (this.getDefaultConfiguration()[`${name}ModelClass`] !== storeClass.getDefaultConfiguration().modelClass) {\n                    modelClass = storeClass.getDefaultConfiguration().modelClass;\n                }\n                // and if none of the above, use from our properties\n                else {\n                    modelClass = this[`${name}ModelClass`];\n                }\n            }\n            return { storeClass, modelClass };\n        }\n        setEventStore(eventStore) {\n            this.eventStore = eventStore;\n        }\n        changeEventStore(eventStore, oldStore) {\n            const me = this, { stm } = me;\n            me.detachStore(oldStore);\n            if (!(eventStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('event', eventStore);\n                eventStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm\n                }, eventStore));\n            }\n            else {\n                eventStore.project = me;\n                stm.addStore(eventStore);\n                me.joinStoreRecords(eventStore);\n            }\n            if (oldStore && stm.hasStore(oldStore)) {\n                stm.removeStore(oldStore);\n                me.unJoinStoreRecords(oldStore);\n                const { assignmentsForRemoval } = oldStore;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldEvent = assignment.event;\n                    if (oldEvent) {\n                        const newEvent = eventStore.getById(oldEvent.id);\n                        if (newEvent) {\n                            assignment.event = newEvent;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldStore.afterEventRemoval();\n            }\n            eventStore.setProject(me);\n            return eventStore;\n        }\n        updateEventStore(eventStore, oldStore) {\n            this.attachStore(eventStore);\n            this.trigger('eventStoreChange', { store: eventStore });\n        }\n        //endregion\n        //region AssignmentStore\n        setAssignmentStore(assignmentStore) {\n            this.assignmentStore = assignmentStore;\n        }\n        changeAssignmentStore(assignmentStore, oldStore) {\n            const me = this, { stm } = me;\n            me.detachStore(oldStore);\n            if (oldStore && stm.hasStore(oldStore)) {\n                stm.removeStore(oldStore);\n                me.unJoinStoreRecords(oldStore);\n            }\n            if (!(assignmentStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('assignment', assignmentStore);\n                assignmentStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm\n                }, assignmentStore));\n            }\n            else {\n                assignmentStore.project = me;\n                stm.addStore(assignmentStore);\n                me.joinStoreRecords(assignmentStore);\n            }\n            assignmentStore.setProject(me);\n            return assignmentStore;\n        }\n        updateAssignmentStore(assignmentStore, oldStore) {\n            this.attachStore(assignmentStore);\n            this.trigger('assignmentStoreChange', { store: assignmentStore });\n        }\n        //endregion\n        //region ResourceStore\n        setResourceStore(resourceStore) {\n            this.resourceStore = resourceStore;\n        }\n        changeResourceStore(resourceStore, oldStore) {\n            const me = this, { stm } = me;\n            me.detachStore(oldStore);\n            if (!(resourceStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('resource', resourceStore);\n                resourceStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm\n                }, resourceStore));\n            }\n            else {\n                resourceStore.project = me;\n                stm.addStore(resourceStore);\n                me.joinStoreRecords(resourceStore);\n            }\n            if (oldStore && stm.hasStore(oldStore)) {\n                stm.removeStore(oldStore);\n                me.unJoinStoreRecords(oldStore);\n                const { assignmentsForRemoval } = oldStore;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldResource = assignment.resource;\n                    if (oldResource) {\n                        const newResource = resourceStore.getById(oldResource.id);\n                        if (newResource) {\n                            assignment.resource = newResource;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldStore.afterResourceRemoval();\n            }\n            resourceStore.setProject(me);\n            return resourceStore;\n        }\n        updateResourceStore(resourceStore, oldStore) {\n            this.attachStore(resourceStore);\n            this.trigger('resourceStoreChange', { store: resourceStore });\n        }\n        //endregion\n        //region DependencyStore\n        setDependencyStore(dependencyStore) {\n            this.dependencyStore = dependencyStore;\n        }\n        changeDependencyStore(dependencyStore, oldStore) {\n            const me = this;\n            me.detachStore(oldStore);\n            if (!(dependencyStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('dependency', dependencyStore);\n                dependencyStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm: me.stm\n                }, dependencyStore));\n            }\n            else {\n                dependencyStore.project = me;\n                me.stm.addStore(dependencyStore);\n                me.joinStoreRecords(dependencyStore);\n            }\n            return dependencyStore;\n        }\n        updateDependencyStore(dependencyStore, oldStore) {\n            this.attachStore(dependencyStore);\n            this.trigger('dependencyStoreChange', { store: dependencyStore });\n        }\n        //endregion\n        //region CalendarManagerStore\n        setCalendarManagerStore(calendarManagerStore) {\n            this.calendarManagerStore = calendarManagerStore;\n        }\n        changeCalendarManagerStore(calendarManagerStore, oldStore) {\n            const me = this;\n            me.detachStore(oldStore);\n            if (!(calendarManagerStore instanceof Store)) {\n                // @ts-ignore\n                const storeClass = calendarManagerStore?.storeClass || me.calendarManagerStoreClass;\n                // @ts-ignore\n                const modelClass = calendarManagerStore?.modelClass || storeClass.getDefaultConfiguration().modelClass || me.calendarModelClass;\n                calendarManagerStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm: me.stm\n                }, calendarManagerStore));\n            }\n            else {\n                me.stm.addStore(calendarManagerStore);\n            }\n            calendarManagerStore.setProject(me);\n            return calendarManagerStore;\n        }\n        updateCalendarManagerStore(calendarManagerStore, oldStore) {\n            this.attachStore(calendarManagerStore);\n            this.trigger('calendarManagerStoreChange', { store: calendarManagerStore });\n        }\n        //endregion\n        //region Calendar\n        get calendar() {\n            return this.$calendar || this.defaultCalendar;\n        }\n        set calendar(calendar) {\n            this.$calendar = calendar;\n        }\n        get effectiveCalendar() {\n            return this.calendar;\n        }\n        //endregion\n        //region Add records\n        async addEvent(event) {\n            this.eventStore.add(event);\n            return this.commitAsync();\n        }\n        async addAssignment(assignment) {\n            this.assignmentStore.add(assignment);\n            return this.commitAsync();\n        }\n        async addResource(resource) {\n            this.resourceStore.add(resource);\n            return this.commitAsync();\n        }\n        async addDependency(dependency) {\n            this.dependencyStore.add(dependency);\n            return this.commitAsync();\n        }\n        //endregion\n        //region Auto commit\n        // Buffer commitAsync using setTimeout. Not using `buffer` on purpose, for performance reasons and to better\n        // mimic how graph does it\n        bufferedCommitAsync() {\n            if (!this.hasPendingAutoCommit) {\n                this.setTimeout({\n                    fn: 'commitAsync',\n                    delay: 10\n                });\n            }\n        }\n        get hasPendingAutoCommit() {\n            return this.hasTimeout('commitAsync');\n        }\n        unScheduleAutoCommit() {\n            this.clearTimeout('commitAsync');\n        }\n        //endregion\n        //region Commit\n        async commitAsync() {\n            if (this.isPerformingCommit)\n                return this.ongoing;\n            return this.ongoing = this.doCommitAsync();\n        }\n        async doCommitAsync() {\n            const me = this;\n            me.isPerformingCommit = true;\n            // Cancel any outstanding commit\n            me.unScheduleAutoCommit();\n            await delay(0);\n            if (!me.isDestroyed) {\n                // Calculate all invalidated records, updates their data silently\n                for (const record of me.$invalidated) {\n                    record.calculateInvalidated();\n                }\n                const { isInitialCommit, silenceInitialCommit } = me;\n                // apply changes silently if this is initial commit and \"silenceInitialCommit\" option is enabled\n                const silenceCommit = isInitialCommit && silenceInitialCommit;\n                // Notify stores that care about commit (internal)\n                me.assignmentStore.onCommitAsync();\n                me.dependencyStore.onCommitAsync();\n                me.isInitialCommitPerformed = true;\n                me.hasLoadedDataToCommit = false;\n                me.isPerformingCommit = false;\n                const stores = [me.assignmentStore, me.dependencyStore, me.eventStore, me.resourceStore, me.calendarManagerStore];\n                stores.forEach(store => store.suspendAutoCommit?.());\n                me.isWritingData = true;\n                // \"Real\" project triggers refresh before data is written back to records\n                me.trigger('refresh', { isInitialCommit, isCalculated: true });\n                // If we are not announcing changes, take a cheaper path\n                if (silenceCommit) {\n                    for (const record of me.$invalidated) {\n                        record.finalizeInvalidated(true);\n                    }\n                }\n                else {\n                    // Two loops looks a bit weird, but needed since editing assignment might affect event etc.\n                    // And we do only want a single update in the end\n                    // 1. Start batches and perform all calculations\n                    for (const record of me.$invalidated) {\n                        record.beginBatch(true);\n                        record.finalizeInvalidated();\n                    }\n                    // 2. End batches, announcing changes (unless initial commit)\n                    for (const record of me.$invalidated) {\n                        record.endBatch(false, true);\n                    }\n                }\n                me.isWritingData = false;\n                me.$invalidated.clear();\n                // Mimic real projects events\n                me.trigger('dataReady');\n                stores.forEach(store => store.resumeAutoCommit?.());\n                // Chrono version triggers \"dataReady\" only if there were no commit rejection\n                // (in case of a rejection it triggers \"commitRejected\" event)\n                // but in both cases it triggers \"commitFinalized\" afterwards\n                me.trigger('commitFinalized');\n                return true;\n            }\n        }\n        async propagateAsync() {\n            return this.commitAsync();\n        }\n        // Called when a record invalidates itself, queues it for calculation\n        invalidate(record) {\n            this.$invalidated.add(record);\n            this.bufferedCommitAsync();\n        }\n        // this does not account for possible scheduling conflicts\n        async isValidDependency() {\n            return true;\n        }\n        //endregion\n        //region STM\n        getStm() {\n            return this.stm;\n        }\n        /**\n         * State tracking manager instance the project relies on\n         */\n        set stm(stm) {\n            stm = this.$stm = new StateTrackingManager(ObjectHelper.assign({\n                disabled: true\n            }, stm));\n            stm.ion({\n                // Propagate on undo/redo\n                restoringStop: async () => {\n                    // Disable STM meanwhile to not pick it up as a new STM transaction\n                    stm.disable();\n                    await this.commitAsync();\n                    if (!this.isDestroyed) {\n                        stm.enable();\n                        this.trigger('stateRestoringDone');\n                    }\n                }\n            });\n        }\n        get stm() {\n            return this.$stm;\n        }\n        //endregion\n        isEngineReady() {\n            return !this.hasPendingAutoCommit && !this.isPerformingCommit && this.isInitialCommitPerformed;\n        }\n    }\n    //region Config\n    SchedulerCoreProjectMixin.applyConfigs = true;\n    return SchedulerCoreProjectMixin;\n}) {\n}\n", "//---------------------------------------------------------------------------------------------------------------------\n// assume 32-bit platform (https://v8.dev/blog/react-cliff)\nimport { CI } from \"../collection/Iterator.js\";\nexport const MIN_SMI = -Math.pow(2, 30);\nexport const MAX_SMI = Math.pow(2, 30) - 1;\n//---------------------------------------------------------------------------------------------------------------------\nexport const uppercaseFirst = (str) => str.slice(0, 1).toUpperCase() + str.slice(1);\n//---------------------------------------------------------------------------------------------------------------------\nexport const isAtomicValue = (value) => Object(value) !== value;\n//---------------------------------------------------------------------------------------------------------------------\nexport const typeOf = (value) => Object.prototype.toString.call(value).slice(8, -1);\n//---------------------------------------------------------------------------------------------------------------------\nexport const defineProperty = (target, property, value) => {\n    Object.defineProperty(target, property, { value, enumerable: true, configurable: true });\n    return value;\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const prototypeValue = (value) => {\n    return function (target, propertyKey) {\n        target[propertyKey] = value;\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const copyMapInto = (sourceMap, targetMap) => {\n    for (const [key, value] of sourceMap)\n        targetMap.set(key, value);\n    return targetMap;\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const copySetInto = (sourceSet, targetSet) => {\n    for (const value of sourceSet)\n        targetSet.add(value);\n    return targetSet;\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const delay = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));\n//---------------------------------------------------------------------------------------------------------------------\nexport const matchAll = function* (regexp, testStr) {\n    let match;\n    while ((match = regexp.exec(testStr)) !== null) {\n        yield match;\n    }\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const allMatches = function (regexp, testStr) {\n    return CI(matchAll(regexp, testStr)).map(match => CI(match).drop(1)).concat().toArray();\n};\nlet isRegeneratorRuntime = null;\nexport const isGeneratorFunction = function (func) {\n    if (isRegeneratorRuntime === null)\n        isRegeneratorRuntime = typeof regeneratorRuntime !== 'undefined';\n    if (isRegeneratorRuntime === true) {\n        return regeneratorRuntime.isGeneratorFunction(func);\n    }\n    else {\n        return func.constructor.name === 'GeneratorFunction';\n    }\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const isPromise = function (obj) {\n    return obj && typeof obj.then === 'function';\n};\n", "import { Base } from \"../class/Base.js\";\nimport { CI } from \"../collection/Iterator.js\";\nimport { matchAll } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const DEBUG = false;\nconst emptyFn = (...args) => undefined;\nexport const DEBUG_ONLY = (func) => DEBUG ? func : emptyFn;\nexport const debug = DEBUG_ONLY((e) => {\n    debugger;\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport const warn = DEBUG_ONLY((e) => {\n    if (typeof console !== 'undefined')\n        console.warn(e);\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport class StackEntry extends Base {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class SourceLinePoint extends Base {\n    constructor() {\n        super(...arguments);\n        this.stackEntries = [];\n    }\n    static fromError(e) {\n        const res = SourceLinePoint.new({\n            exception: e,\n            stackEntries: parseErrorStack(e.stack)\n        });\n        return res;\n    }\n    static fromThisCall() {\n        const sourceLinePoint = this.fromError(new Error());\n        sourceLinePoint.stackEntries.splice(0, 2);\n        return sourceLinePoint;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n// sample stack\n// Error\n//     at exceptionCatcher (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/environment/Debug.js:15:11)\n//     at Function.fromCurrentCall (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/environment/Debug.js:39:38)\n//     at Object.get (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/replica/Entity.js:31:73)\n//     at MinimalGanttProject.set (http://lh/bryntum-suite/SchedulingEngine/lib/ChronoGraph/replica/Entity.js:222:23)\n//     at MinimalGanttProject.set data [as data] (http://lh/bryntum-suite/SchedulingEngine/lib/Engine/chrono/ChronoModelMixin.js:48:31)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Core/data/Model.js:290:17)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Core/mixin/Events.js:236:15)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Engine/chrono/ChronoModelMixin.js:21:19)\n//     at MinimalGanttProject.construct (http://lh/bryntum-suite/SchedulingEngine/lib/Engine/quark/model/scheduler_basic/SchedulerBasicProjectMixin.js:53:19)\n//     at new Base (http://lh/bryntum-suite/SchedulingEngine/lib/Core/Base.js:55:14)\"\nconst parseErrorStack = (stack) => {\n    return CI(matchAll(/^   +at\\s*(.*?)\\s*\\((https?:\\/\\/.*?):(\\d+):(\\d+)/gm, stack))\n        .map(match => StackEntry.new({\n        statement: match[1],\n        sourceFile: match[2],\n        sourceLine: Number(match[3]),\n        sourceCharPos: Number(match[4])\n    }))\n        .toArray();\n};\n", "import { DEBUG_ONLY } from \"../environment/Debug.js\";\nconst RequiredProperties = Symbol('RequiredProperties');\nconst emptyFn = () => undefined;\nexport const required = DEBUG_ONLY((proto, propertyKey) => {\n    let required = proto[RequiredProperties];\n    if (!required)\n        required = proto[RequiredProperties] = [];\n    required.push(propertyKey);\n});\nexport const validateRequiredProperties = DEBUG_ONLY((context) => {\n    const required = context[RequiredProperties];\n    if (required) {\n        for (let i = 0; i < required.length; i++)\n            if (context[required[i]] === undefined)\n                throw new Error(`Required attribute [${String(required[i])}] is not provided`);\n    }\n});\n", "import { Base } from \"../class/Base.js\";\nexport var OnCycleAction;\n(function (OnCycleAction) {\n    OnCycleAction[\"Cancel\"] = \"Cancel\";\n    OnCycleAction[\"Resume\"] = \"Resume\";\n})(OnCycleAction || (OnCycleAction = {}));\n//---------------------------------------------------------------------------------------------------------------------\nexport const WalkSource = Symbol('WalkSource');\nexport const NOT_VISITED = -1;\nexport const VISITED_TOPOLOGICALLY = -2;\n//---------------------------------------------------------------------------------------------------------------------\nexport class WalkContext extends Base {\n    constructor() {\n        super(...arguments);\n        this.visited = new Map();\n        this.toVisit = [];\n        this.currentEpoch = 0;\n    }\n    startFrom(sourceNodes) {\n        this.continueFrom(sourceNodes);\n    }\n    continueFrom(sourceNodes) {\n        this.toVisit.push.apply(this.toVisit, sourceNodes.map(node => { return { node: node, from: WalkSource, label: undefined }; }));\n        this.walkDepth();\n    }\n    onNode(node, walkStep) {\n    }\n    onTopologicalNode(node) {\n    }\n    onCycle(node, stack) {\n        return OnCycleAction.Cancel;\n    }\n    forEachNext(node, func) {\n        throw new Error(\"Abstract method called\");\n    }\n    collectNext(node, toVisit, visitInfo) {\n        throw new Error(\"Abstract method called\");\n    }\n    getVisitedInfo(node) {\n        return this.visited.get(node);\n    }\n    setVisitedInfo(node, visitedAt, info) {\n        if (!info) {\n            info = { visitedAt, visitEpoch: this.currentEpoch };\n            this.visited.set(node, info);\n        }\n        else {\n            info.visitedAt = visitedAt;\n            info.visitEpoch = this.currentEpoch;\n        }\n        return info;\n    }\n    walkDepth() {\n        const visited = this.visited;\n        const toVisit = this.toVisit;\n        let depth;\n        while (depth = toVisit.length) {\n            const node = toVisit[depth - 1].node;\n            const visitedInfo = this.getVisitedInfo(node);\n            // this supports the \"ahead-of-time\" creation of the \"visited\" entries, which actually lead to improved benchmarks,\n            // so it might be a default\n            if (visitedInfo && visitedInfo.visitedAt === VISITED_TOPOLOGICALLY && visitedInfo.visitEpoch === this.currentEpoch) {\n                toVisit.pop();\n                continue;\n            }\n            if (visitedInfo && visitedInfo.visitEpoch === this.currentEpoch && visitedInfo.visitedAt !== NOT_VISITED) {\n                // it is valid to find itself \"visited\", but only if visited at the current depth\n                // (which indicates stack unwinding)\n                // if the node has been visited at earlier depth - its a cycle\n                if (visitedInfo.visitedAt < depth) {\n                    // ONLY resume if explicitly returned `Resume`, cancel in all other cases (undefined, etc)\n                    if (this.onCycle(node, toVisit) !== OnCycleAction.Resume)\n                        break;\n                }\n                else {\n                    visitedInfo.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node);\n                }\n                toVisit.pop();\n            }\n            else {\n                // if we break here, we can re-enter the loop later\n                if (this.onNode(node, toVisit[depth - 1]) === false)\n                    break;\n                // first entry to the node\n                const visitedInfo2 = this.setVisitedInfo(node, depth, visitedInfo);\n                const lengthBefore = toVisit.length;\n                this.collectNext(node, toVisit, visitedInfo2);\n                // if there's no outgoing edges, node is at topological position\n                // it would be enough to just continue the `while` loop and the `onTopologicalNode`\n                // would happen on next iteration, but with this \"inlining\" we save one call to `visited.get()`\n                // at the cost of length comparison\n                if (toVisit.length === lengthBefore) {\n                    visitedInfo2.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node);\n                    toVisit.pop();\n                }\n            }\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function cycleInfo(stack) {\n    const length = stack.length;\n    if (length === 0)\n        return [];\n    const cycleSource = stack[length - 1].node;\n    const cycle = [cycleSource];\n    let current = length - 1;\n    let cursor = current;\n    while (current >= 0 && stack[current].from !== cycleSource) {\n        // going backward in steps, skipping the nodes with identical `from`\n        while (current >= 0 && stack[current].from === stack[cursor].from)\n            current--;\n        if (current >= 0) {\n            // the first node with different `from` will be part of the cycle path\n            cycle.push(stack[current].node);\n            cursor = current;\n        }\n    }\n    // no cycle\n    if (current < 0)\n        return [];\n    cycle.push(cycleSource);\n    return cycle.reverse();\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base } from \"../class/Base.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { required, validateRequiredProperties } from \"../class/RequiredProperty.js\";\nimport { CI, concatIterable, map, uniqueOnly } from \"../collection/Iterator.js\";\nimport { DEBUG } from \"../environment/Debug.js\";\nimport { OnCycleAction, WalkContext } from \"../graph/WalkDepth.js\";\nlet FORMULA_ID = 0;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Pre-defined constant formula id. If assigned to some variable, specifies, that this variable should keep the value proposed by user\n * (user input), or, if there's none, its previous value.\n */\nexport const CalculateProposed = FORMULA_ID++;\n// export const CalculatePure : FormulaId          = FORMULA_ID++\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Class, describing a formula, which is part of the cyclic set. Formula just specifies its input variables and output variable,\n * it does not contain actual calculation.\n *\n * It is assumed that formula can only be \"activated\" if all of its inputs has value. It can be either a value from the previous iteration,\n * a value provided by user, or an output value of some other formula. See [[VariableInputState]] and [[CycleResolutionInput]].\n */\nexport class Formula extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * The id of the formula. It is assigned automatically, should not be changed.\n         */\n        this.formulaId = FORMULA_ID++;\n        /**\n         * A set of the input variables for this formula.\n         */\n        this.inputs = new Set();\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class VariableWalkContext extends WalkContext {\n    collectNext(sourceNode, toVisit) {\n        if (sourceNode instanceof Formula) {\n            toVisit.push({ node: sourceNode.output, from: sourceNode, label: undefined });\n        }\n        else {\n            const formulas = this.cache.formulasByInput.get(sourceNode);\n            formulas && formulas.forEach(formula => toVisit.push({ node: formula, from: sourceNode, label: undefined }));\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class FormulasCache extends Mixin([Base], (base) => class FormulasCache extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * A set of variables, which forms cyclic computation\n         */\n        this.variables = new Set();\n        /**\n         * A set of formulas, which forms cyclic computation\n         */\n        this.formulas = new Set();\n        this.$formulasByInput = undefined;\n        this.$formulasByOutput = undefined;\n    }\n    get formulasByInput() {\n        if (this.$formulasByInput !== undefined)\n            return this.$formulasByInput;\n        this.fillCache();\n        return this.$formulasByInput;\n    }\n    get formulasByOutput() {\n        if (this.$formulasByOutput !== undefined)\n            return this.$formulasByOutput;\n        this.fillCache();\n        return this.$formulasByOutput;\n    }\n    add(formula) {\n        this.$formulasByInput = undefined;\n        this.$formulasByOutput = undefined;\n        this.formulas.add(formula);\n    }\n    has(formula) {\n        return this.formulas.has(formula);\n    }\n    fillCache() {\n        this.$formulasByInput = new Map();\n        this.$formulasByOutput = new Map();\n        this.formulas.forEach(formula => {\n            let formulasByOutput = this.$formulasByOutput.get(formula.output);\n            if (!formulasByOutput) {\n                formulasByOutput = new Set();\n                this.$formulasByOutput.set(formula.output, formulasByOutput);\n            }\n            formulasByOutput.add(formula);\n            formula.inputs.forEach(input => {\n                let formulasByInput = this.$formulasByInput.get(input);\n                if (!formulasByInput) {\n                    formulasByInput = new Set();\n                    this.$formulasByInput.set(input, formulasByInput);\n                }\n                formulasByInput.add(formula);\n            });\n        });\n    }\n    allInputVariables() {\n        return uniqueOnly(concatIterable(map(this.formulas, formula => formula.inputs.values())));\n    }\n    isCyclic() {\n        let isCyclic = false;\n        const walkContext = VariableWalkContext.new({ cache: this, onCycle: () => { isCyclic = true; return OnCycleAction.Cancel; } });\n        walkContext.startFrom(Array.from(this.allInputVariables()));\n        return isCyclic;\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Abstract description of the cycle. Does not include the default formula resolution, only variables and formulas. See also [[CycleResolution]].\n */\nexport class CycleDescription extends FormulasCache {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Class describing the cycle resolution process. Requires the abstract cycle [[description]] and a set of default formulas.\n *\n * The resolution is performed with [[CycleResolution.resolve]] method.\n *\n * Resolution are memoized, based on the input. You should generally have a single instance of this class for a single set of default formulas,\n * to accumulate the results and make resolution fast.\n */\nexport class CycleResolution extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Abstract cycle description for this resolution.\n         */\n        this.description = undefined;\n        /**\n         * A set of default formulas for this resolution. Default formulas specifies how the calculation should be performed, if there's no user input\n         * for any variable (or there's input for all of them). Also, default formulas are preferred, if several formulas can be chosen to continue the resolution.\n         */\n        this.defaultResolutionFormulas = new Set();\n        this.resolutionsByInputHash = new Map();\n    }\n    // the caching space is 3^var_num might need to clear the memory at some time\n    clear() {\n        this.resolutionsByInputHash.clear();\n    }\n    /**\n     * This method accepts an input object and returns a cycle resolution.\n     * Resolution are memoized, based on the input.\n     *\n     * @param input\n     */\n    resolve(input) {\n        const cached = this.resolutionsByInputHash.get(input.hash);\n        if (cached !== undefined)\n            return cached;\n        const resolution = this.buildResolution(input);\n        this.resolutionsByInputHash.set(input.hash, resolution);\n        return resolution;\n    }\n    buildResolution(input) {\n        const walkContext = WalkState.new({ context: this, input });\n        const allResolutions = Array.from(walkContext.next()).map(state => {\n            return {\n                resolution: state.asResolution(),\n                nbrOfDefaultFormulas: Array.from(state.activatedFormulas.formulas).reduce((count, formula) => state.formulaIsDefault(formula) ? count + 1 : count, 0),\n                unCoveredInputWeight: state.unCoveredInputWeight()\n            };\n        });\n        allResolutions.sort((res1, res2) => {\n            if (res1.unCoveredInputWeight < res2.unCoveredInputWeight)\n                return -1;\n            if (res1.unCoveredInputWeight > res2.unCoveredInputWeight)\n                return 1;\n            return res2.nbrOfDefaultFormulas - res1.nbrOfDefaultFormulas;\n        });\n        if (allResolutions.length > 0)\n            return allResolutions[0].resolution;\n        else\n            debugger; // return default? or all-proposed?\n    }\n}\n/**\n * Enumeration for various states of the input data for variables in the cycle. Individual members corresponds to binary bits and can be set simultaneously, like:\n *\n * ```ts\n * const input : VariableInputState = VariableInputState.HasPreviousValue | VariableInputState.HasProposedValue\n * ```\n */\nexport var VariableInputState;\n(function (VariableInputState) {\n    VariableInputState[VariableInputState[\"NoInput\"] = 0] = \"NoInput\";\n    /**\n     * This bit indicates that variable has some previous value, when resolution starts. It can be any non-`undefined` value, including `null`.\n     */\n    VariableInputState[VariableInputState[\"HasPreviousValue\"] = 1] = \"HasPreviousValue\";\n    /**\n     * This bit indicates that variable has user input, when resolution starts. It can be any non-`undefined` value, including `null`.\n     */\n    VariableInputState[VariableInputState[\"HasProposedValue\"] = 2] = \"HasProposedValue\";\n    /**\n     * This bit indicates, that user intention is to keep this variable unchanged, if that is possible (does not contradict to other user input).\n     */\n    VariableInputState[VariableInputState[\"KeepIfPossible\"] = 4] = \"KeepIfPossible\";\n})(VariableInputState || (VariableInputState = {}));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Class, describing the input data for a set of variables during cycle resolution.\n */\nexport class CycleResolutionInput extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * A cycle resolution instance this input corresponds to.\n         */\n        this.context = undefined;\n        this.input = undefined;\n        this.$hash = '';\n    }\n    get hash() {\n        if (this.$hash !== '')\n            return this.$hash;\n        return this.$hash = this.buildHash();\n    }\n    get description() { return this.context.description; }\n    /**\n     * Returns the same result as calling [[CycleResolution.resolve]] on this input instance\n     */\n    get resolution() {\n        return this.context.resolve(this);\n    }\n    initialize(...args) {\n        super.initialize(...args);\n        validateRequiredProperties(this);\n        this.input = new Map(CI(this.description.variables).map(variable => [variable, VariableInputState.NoInput]));\n    }\n    buildHash() {\n        return String.fromCharCode(...CI(this.description.variables).inBatchesBySize(5).map(batch => this.batchToCharCode(batch)));\n    }\n    batchToCharCode(batch) {\n        return batch.reduceRight((charCode, variable, index) => charCode | (this.input.get(variable) << index * 3), 0);\n    }\n    //---------------------\n    /**\n     * This method sets the [[HasProposedValue]] flag for the specified variable.\n     *\n     * @param variable\n     */\n    addProposedValueFlag(variable) {\n        if (DEBUG) {\n            if (!this.description.variables.has(variable))\n                throw new Error('Unknown variable');\n            if (this.$hash !== '')\n                throw new Error('Already hashed');\n        }\n        const input = this.input.get(variable);\n        this.input.set(variable, input | VariableInputState.HasProposedValue);\n    }\n    hasProposedValue(variable) {\n        return Boolean(this.input.get(variable) & VariableInputState.HasProposedValue);\n    }\n    hasProposedValueVars() {\n        return CI(this.description.variables).filter(variable => this.hasProposedValue(variable));\n    }\n    //---------------------\n    /**\n     * This method sets the [[HasPreviousValue]] flag for the specified variable.\n     *\n     * @param variable\n     */\n    addPreviousValueFlag(variable) {\n        if (DEBUG) {\n            if (!this.description.variables.has(variable))\n                throw new Error('Unknown variable');\n            if (this.$hash !== '')\n                throw new Error('Already hashed');\n        }\n        const input = this.input.get(variable);\n        this.input.set(variable, input | VariableInputState.HasPreviousValue);\n    }\n    hasPreviousValue(variable) {\n        return Boolean(this.input.get(variable) & VariableInputState.HasPreviousValue);\n    }\n    hasPreviousValueVars() {\n        return CI(this.description.variables).filter(variable => this.hasPreviousValue(variable));\n    }\n    //---------------------\n    /**\n     * This method sets the [[KeepIfPossible]] flag for the specified variable.\n     *\n     * @param variable\n     */\n    addKeepIfPossibleFlag(variable) {\n        if (DEBUG) {\n            if (!this.description.variables.has(variable))\n                throw new Error('Unknown variable');\n            if (this.$hash !== '')\n                throw new Error('Already hashed');\n        }\n        const input = this.input.get(variable);\n        this.input.set(variable, input | VariableInputState.KeepIfPossible);\n    }\n    keepIfPossible(variable) {\n        return Boolean(this.input.get(variable) & VariableInputState.KeepIfPossible);\n    }\n    keepIfPossibleVars() {\n        return CI(this.description.variables).filter(variable => this.keepIfPossible(variable));\n    }\n}\n__decorate([\n    required\n], CycleResolutionInput.prototype, \"context\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\nexport class WalkState extends Base {\n    constructor() {\n        super(...arguments);\n        this.context = undefined;\n        this.input = undefined;\n        this.previous = undefined;\n        this.activatedFormula = undefined;\n        this.$activatedFormulas = undefined;\n    }\n    get activatedFormulas() {\n        if (this.$activatedFormulas !== undefined)\n            return this.$activatedFormulas;\n        const cache = FormulasCache.new({\n            variables: this.description.variables,\n            formulas: CI(this.thisAndPreviousStates()).map(state => state.activatedFormula).toSet()\n        });\n        return this.$activatedFormulas = cache;\n    }\n    get description() { return this.context.description; }\n    *thisAndPreviousStates() {\n        let current = this;\n        while (current && current.activatedFormula) {\n            yield current;\n            current = current.previous;\n        }\n    }\n    formulaHasProposedValueInInput(formula) {\n        return Array.from(formula.inputs).some(variable => this.input.hasProposedValue(variable));\n    }\n    // this method counts\n    unCoveredInputWeight() {\n        const proposedVars = map(this.input.hasProposedValueVars(), variable => { return { variable, isProposed: true }; });\n        const keepIfPossibleVars = map(this.input.keepIfPossibleVars(), variable => { return { variable, isProposed: false }; });\n        const allInputVars = CI([proposedVars, keepIfPossibleVars]).concat().uniqueOnlyBy(el => el.variable);\n        return allInputVars.reduce((totalWeight, { variable, isProposed }) => {\n            let weight = 0;\n            //-----------------\n            const isOverwrittenByFormulas = this.activatedFormulas.formulasByOutput.get(variable);\n            if (isOverwrittenByFormulas) {\n                const formula = isOverwrittenByFormulas.size === 1 ? Array.from(isOverwrittenByFormulas)[0] : null;\n                // the case, when some user input is overwritten with the default formula should be weighted less than\n                // its overwritten with regular formula\n                if (formula && this.formulaIsDefault(formula) && this.formulaHasProposedValueInInput(formula)) {\n                    if (isProposed)\n                        weight += 1e6;\n                    else\n                        weight += 1e4;\n                }\n                else {\n                    if (isProposed)\n                        weight += 1e7;\n                    else\n                        weight += 1e5;\n                }\n            }\n            //-----------------\n            const usedInFormulas = this.activatedFormulas.formulasByInput.get(variable);\n            if (!(usedInFormulas && usedInFormulas.size > 0)) {\n                if (isProposed)\n                    weight += 1e3;\n                else\n                    weight += 1e2;\n            }\n            return totalWeight + weight;\n        }, 0);\n    }\n    preferFormula(formula1, formula2) {\n        const allInputsHasProposed1 = this.formulaAllInputsHasProposed(formula1);\n        const allInputsHasProposed2 = this.formulaAllInputsHasProposed(formula2);\n        if (allInputsHasProposed1 && !allInputsHasProposed2)\n            return -1;\n        if (allInputsHasProposed2 && !allInputsHasProposed1)\n            return 1;\n        const countInputsWithProposedOrKeep1 = this.formulaCountInputsWithProposedOrKeep(formula1);\n        const countInputsWithProposedOrKeep2 = this.formulaCountInputsWithProposedOrKeep(formula2);\n        if (countInputsWithProposedOrKeep1 > countInputsWithProposedOrKeep2)\n            return -1;\n        if (countInputsWithProposedOrKeep1 < countInputsWithProposedOrKeep2)\n            return 1;\n        if (this.formulaIsDefault(formula1) && !this.formulaIsDefault(formula2))\n            return -1;\n        if (this.formulaIsDefault(formula2) && !this.formulaIsDefault(formula1))\n            return 1;\n        return 0;\n    }\n    formulaIsDefault(formula) {\n        return this.context.defaultResolutionFormulas.has(formula);\n    }\n    formulaCountInputsWithProposedOrKeep(formula) {\n        let count = 0;\n        Array.from(formula.inputs).forEach(variable => {\n            if (this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable))\n                count++;\n        });\n        return count;\n    }\n    formulaAllInputsHasProposedOrKeep(formula) {\n        return Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable));\n    }\n    formulaAllInputsHasProposed(formula) {\n        return Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable));\n    }\n    formulaIsApplicable(formula) {\n        const everyFormulaInputHasValue = Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable)\n            || this.input.hasPreviousValue(variable)\n            || this.activatedFormulas.formulasByOutput.has(variable));\n        const cache = FormulasCache.new({ formulas: new Set(this.activatedFormulas.formulas) });\n        cache.add(formula);\n        return everyFormulaInputHasValue && !cache.isCyclic();\n    }\n    // in general the semantic of this method is very similar to `formulaIsApplicable`\n    formulaIsInsignificant(formula) {\n        const outputVariableAlreadyCalculated = this.activatedFormulas.formulasByOutput.has(formula.output);\n        const outputVariableHasPreviousValue = this.input.hasPreviousValue(formula.output);\n        return outputVariableAlreadyCalculated\n            || outputVariableHasPreviousValue && Array.from(formula.inputs).some(variable => {\n                // so we should ignore the formula, if some of its inputs\n                // does not have value provided (neither previous nor proposed)\n                return !this.input.hasPreviousValue(variable) && !this.input.hasProposedValue(variable)\n                    // ..and we haven't planned calculation of that input via another formula\n                    && !this.activatedFormulas.formulasByOutput.has(variable);\n            });\n    }\n    unvisitedFormulas() {\n        return Array.from(this.description.formulas).filter(formula => !this.activatedFormulas.has(formula));\n    }\n    *next() {\n        const unvisitedFormulas = this.unvisitedFormulas();\n        unvisitedFormulas.sort(this.preferFormula.bind(this));\n        let isFinal = true;\n        for (const formula of unvisitedFormulas) {\n            if (!this.formulaIsApplicable(formula) || this.formulaIsInsignificant(formula))\n                continue;\n            const nextState = WalkState.new({\n                previous: this,\n                context: this.context,\n                input: this.input,\n                activatedFormula: formula\n            });\n            yield* nextState.next();\n            isFinal = false;\n        }\n        if (isFinal)\n            yield this;\n    }\n    asResolution() {\n        return new Map(CI(this.description.variables).map(variable => {\n            const formulas = this.activatedFormulas.formulasByOutput.get(variable);\n            if (formulas) {\n                for (const firstFormula of formulas) {\n                    return [variable, firstFormula.formulaId];\n                }\n            }\n            return [variable, CalculateProposed];\n        }));\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base } from \"../class/Base.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const BreakCurrentStackExecution = Symbol('BreakCurrentStackExecution');\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * The base class for effect. Effect is some value, that can be send to the \"outer\" calculation context, using the\n * effect handler function. Effect handler then will process an effect and return some resulting value.\n *\n * ```ts\n * const identifier  = graph.identifier((Y : SyncEffectHandler) : number => {\n *     const proposedValue : number    = Y(ProposedOrPrevious)\n *\n *     const maxValue : number         = Y(max)\n *\n *     return proposedValue <= maxValue ? proposedValue : maxValue\n * })\n * ```\n */\nexport class Effect extends Base {\n}\n__decorate([\n    prototypeValue(true)\n], Effect.prototype, \"sync\", void 0);\n__decorate([\n    prototypeValue(true)\n], Effect.prototype, \"pure\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedOrPreviousSymbol = Symbol('ProposedOrPreviousSymbol');\n/**\n * The constant that represents a request for either user input (proposed value) or previous value of the\n * identifier, currently being calculated.\n *\n * Important note, is that if an identifier yields a `ProposedOrPrevious` effect and its computed value does not match the value of this effect,\n * it will be re-calculated (computation function called) again on the next read. This is because the value of its `ProposedOrPrevious` input changes.\n *\n * ```ts\n * const graph4 = ChronoGraph.new()\n *\n * const max           = graph4.variable(100)\n *\n * const identifier15  = graph4.identifier((Y) : number => {\n *     const proposedValue : number    = Y(ProposedOrPrevious)\n *\n *     const maxValue : number         = Y(max)\n *\n *     return proposedValue <= maxValue ? proposedValue : maxValue\n * })\n *\n * graph4.write(identifier15, 18)\n *\n * const value15_1 = graph4.read(identifier15) // 18\n *\n * graph4.write(identifier15, 180)\n *\n * const value15_2 = graph4.read(identifier15) // 100\n *\n * graph4.write(max, 50)\n *\n * const value15_3 = graph4.read(identifier15) // 50\n * ```\n */\nexport const ProposedOrPrevious = Effect.new({ handler: ProposedOrPreviousSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const RejectSymbol = Symbol('RejectSymbol');\n/**\n * Class for [[Reject]] effect.\n */\nexport class RejectEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = RejectSymbol;\n    }\n}\n__decorate([\n    prototypeValue(false)\n], RejectEffect.prototype, \"pure\", void 0);\n/**\n * This is constructor for `RejectEffect` class. If this effect will be yielded during computation the current transaction\n * will be [[ChronoGraph.reject|rejected]].\n *\n * @param reason\n * @constructor\n */\nexport const Reject = (reason) => RejectEffect.new({ reason });\n//---------------------------------------------------------------------------------------------------------------------\nexport const TransactionSymbol = Symbol('TransactionSymbol');\nexport const GetTransaction = Effect.new({ handler: TransactionSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const OwnQuarkSymbol = Symbol('OwnQuarkSymbol');\nexport const OwnQuark = Effect.new({ handler: OwnQuarkSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const OwnIdentifierSymbol = Symbol('OwnIdentifierSymbol');\nexport const OwnIdentifier = Effect.new({ handler: OwnIdentifierSymbol });\n//---------------------------------------------------------------------------------------------------------------------\nexport const WriteSymbol = Symbol('WriteSymbol');\nexport class WriteEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = WriteSymbol;\n    }\n}\n__decorate([\n    prototypeValue(false)\n], WriteEffect.prototype, \"pure\", void 0);\nexport const Write = (identifier, proposedValue, ...proposedArgs) => WriteEffect.new({ identifier, proposedArgs: [proposedValue, ...proposedArgs] });\nexport const WriteSeveralSymbol = Symbol('WriteSeveralSymbol');\nexport class WriteSeveralEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = WriteSeveralSymbol;\n    }\n}\n__decorate([\n    prototypeValue(false)\n], WriteSeveralEffect.prototype, \"pure\", void 0);\nexport const WriteSeveral = (writes) => WriteSeveralEffect.new({ writes });\n//---------------------------------------------------------------------------------------------------------------------\nexport const PreviousValueOfSymbol = Symbol('PreviousValueOfSymbol');\nexport class PreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = PreviousValueOfSymbol;\n    }\n}\nexport const PreviousValueOf = (identifier) => PreviousValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedValueOfSymbol = Symbol('ProposedValueOfSymbol');\nexport class ProposedValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = ProposedValueOfSymbol;\n    }\n}\nexport const ProposedValueOf = (identifier) => ProposedValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const HasProposedValueSymbol = Symbol('HasProposedValueSymbol');\nexport class HasProposedValueEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = HasProposedValueSymbol;\n    }\n}\nexport const HasProposedValue = (identifier) => HasProposedValueEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const HasProposedNotPreviousValueSymbol = Symbol('HasProposedNotPreviousValueSymbol');\nexport class HasProposedNotPreviousValueEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = HasProposedNotPreviousValueSymbol;\n    }\n}\nexport const HasProposedNotPreviousValue = (identifier) => HasProposedNotPreviousValueEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedOrPreviousValueOfSymbol = Symbol('ProposedOrPreviousValueOfSymbol');\nexport class ProposedOrPreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = ProposedOrPreviousValueOfSymbol;\n    }\n}\nexport const ProposedOrPreviousValueOf = (identifier) => ProposedOrPreviousValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const ProposedArgumentsOfSymbol = Symbol('ProposedArgumentsOfSymbol');\nexport class ProposedArgumentsOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = ProposedArgumentsOfSymbol;\n    }\n}\nexport const ProposedArgumentsOf = (identifier) => ProposedArgumentsOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const UnsafeProposedOrPreviousValueOfSymbol = Symbol('UnsafeProposedOrPreviousValueOfSymbol');\nexport class UnsafeProposedOrPreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = UnsafeProposedOrPreviousValueOfSymbol;\n    }\n}\nexport const UnsafeProposedOrPreviousValueOf = (identifier) => UnsafeProposedOrPreviousValueOfEffect.new({ identifier });\n//---------------------------------------------------------------------------------------------------------------------\nexport const UnsafePreviousValueOfSymbol = Symbol('UnsafePreviousValueOfSymbol');\nexport class UnsafePreviousValueOfEffect extends Effect {\n    constructor() {\n        super(...arguments);\n        this.handler = UnsafePreviousValueOfSymbol;\n    }\n}\nexport const UnsafePreviousValueOf = (identifier) => UnsafePreviousValueOfEffect.new({ identifier });\n", "import { CycleResolutionInput } from \"../cycle_resolver/CycleResolver.js\";\nimport { HasProposedNotPreviousValue, PreviousValueOf } from \"./Effect.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * A subclass of [[CycleResolutionInput]] with additional convenience method [[collectInfo]].\n */\nexport class CycleResolutionInputChrono extends CycleResolutionInput {\n    /**\n     * This method, given an effect handler, identifier and a variable, will add [[CycleResolutionInput.addPreviousValueFlag|previous value]]\n     * and [[CycleResolutionInput.addProposedValueFlag|proposed value]] flags for that variable.\n     *\n     * @param Y An effect handler function, which is given as a 1st argument of every calculation function\n     * @param identifier\n     * @param symbol\n     */\n    collectInfo(Y, identifier, symbol) {\n        if (Y(PreviousValueOf(identifier)) != null)\n            this.addPreviousValueFlag(symbol);\n        if (Y(HasProposedNotPreviousValue(identifier)))\n            this.addProposedValueFlag(symbol);\n    }\n}\n", "import { Effect, Reject } from \"../chrono/Effect.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { isPromise } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Symbol to denote the synchronous calculation context\n */\nexport const ContextSync = Symbol('ContextSync');\n/**\n * Symbol to denote the generator calculation context\n */\nexport const ContextGen = Symbol('ContextGen');\n//---------------------------------------------------------------------------------------------------------------------\nexport class CalculationGen extends Mixin([], (base) => class CalculationGen extends base {\n    constructor() {\n        super(...arguments);\n        this.iterator = undefined;\n        this.iterationResult = undefined;\n    }\n    isCalculationStarted() {\n        return Boolean(this.iterator || this.iterationResult);\n    }\n    isCalculationCompleted() {\n        return Boolean(this.iterationResult && this.iterationResult.done);\n    }\n    get result() {\n        return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : undefined;\n    }\n    startCalculation(onEffect, ...args) {\n        const iterator = this.iterator = this.calculation.call(this.context || this, onEffect, ...args);\n        return this.iterationResult = iterator.next();\n    }\n    continueCalculation(value) {\n        return this.iterationResult = this.iterator.next(value);\n    }\n    cleanupCalculation() {\n        this.iterationResult = undefined;\n        this.iterator = undefined;\n    }\n    *calculation(onEffect, ...args) {\n        throw new Error(\"Abstract method `calculation` called\");\n    }\n    runSyncWithEffect(onEffect, ...args) {\n        this.startCalculation(onEffect, ...args);\n        while (!this.isCalculationCompleted()) {\n            this.continueCalculation(onEffect(this.iterationResult.value));\n        }\n        // help to garbage collector\n        this.iterator = undefined;\n        return this.result;\n    }\n    async runAsyncWithEffect(onEffect, ...args) {\n        this.startCalculation(onEffect, ...args);\n        while (!this.isCalculationCompleted()) {\n            this.continueCalculation(await onEffect(this.iterationResult.value));\n        }\n        // help to garbage collector\n        this.iterator = undefined;\n        return this.result;\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const SynchronousCalculationStarted = Symbol('SynchronousCalculationStarted');\nconst calculationStartedConstant = { value: SynchronousCalculationStarted };\nexport class CalculationSync extends Mixin([], (base) => class CalculationSync extends base {\n    constructor() {\n        super(...arguments);\n        this.iterationResult = undefined;\n    }\n    isCalculationStarted() {\n        return Boolean(this.iterationResult);\n    }\n    isCalculationCompleted() {\n        return Boolean(this.iterationResult && this.iterationResult.done);\n    }\n    get result() {\n        return this.iterationResult && this.iterationResult.done ? this.iterationResult.value : undefined;\n    }\n    startCalculation(onEffect, ...args) {\n        // this assignment allows other code to observe, that calculation has started\n        this.iterationResult = calculationStartedConstant;\n        return this.iterationResult = {\n            done: true,\n            value: this.calculation.call(this.context || this, onEffect, ...args)\n        };\n    }\n    continueCalculation(value) {\n        throw new Error(\"Can not continue synchronous calculation\");\n    }\n    cleanupCalculation() {\n        this.iterationResult = undefined;\n    }\n    calculation(onEffect, ...args) {\n        throw new Error(\"Abstract method `calculation` called\");\n    }\n    runSyncWithEffect(onEffect, ...args) {\n        this.startCalculation(onEffect, ...args);\n        return this.result;\n    }\n    async runAsyncWithEffect(onEffect, ...args) {\n        throw new Error('Can not run synchronous calculation asynchronously');\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function runGeneratorSyncWithEffect(effect, func, args, scope) {\n    const gen = func.apply(scope || null, args);\n    let iteration = gen.next();\n    while (!iteration.done) {\n        iteration = gen.next(effect(iteration.value));\n    }\n    return iteration.value;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport async function runGeneratorAsyncWithEffect(effect, func, args, scope) {\n    const gen = func.apply(scope || null, args);\n    let iteration = gen.next();\n    while (!iteration.done) {\n        let effectResolution;\n        let repeat = false;\n        do {\n            repeat = false;\n            try {\n                effectResolution = effect(iteration.value);\n            }\n            catch (e) {\n                // this is very bad, or even terrible - the high-level `Effect` class is mentioned in the \"primitives\",\n                // we compare 'resolution' with the magic string 'Cancel' (defined in Engine) and we also use `Reject`\n                // constructor\n                // but, we are trying to shove an async handling in sync computation (impossible by definition)\n                // so we are desperate, and even seems to work...\n                // other piece of this code is in `onComputationCycleHandlerSync` in `Engine/lib/Engine/chrono/Replica.ts`\n                if (e instanceof Effect) {\n                    // @ts-ignore\n                    let resolution = await effect(e);\n                    if (resolution === 'Cancel') {\n                        // @ts-ignore\n                        effect(Reject(e));\n                        return;\n                    }\n                    else {\n                        repeat = true;\n                    }\n                }\n            }\n        } while (repeat);\n        if (isPromise(effectResolution))\n            iteration = gen.next(await effectResolution);\n        else\n            iteration = gen.next(effectResolution);\n    }\n    return iteration.value;\n}\n", "import { MixinAny } from \"../class/Mixin.js\";\nimport { NOT_VISITED } from \"../graph/WalkDepth.js\";\nimport { MAX_SMI, MIN_SMI } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport var EdgeType;\n(function (EdgeType) {\n    EdgeType[EdgeType[\"Normal\"] = 1] = \"Normal\";\n    EdgeType[EdgeType[\"Past\"] = 2] = \"Past\";\n})(EdgeType || (EdgeType = {}));\nlet ORIGIN_ID = 0;\n//---------------------------------------------------------------------------------------------------------------------\nexport class Quark extends MixinAny([Map], (base) => class Quark extends base {\n    constructor() {\n        super(...arguments);\n        // required\n        this.createdAt = undefined;\n        this.identifier = undefined;\n        // quark state\n        this.value = undefined;\n        this.proposedValue = undefined;\n        this.proposedIsPrevious = false;\n        this.proposedArguments = undefined;\n        this.usedProposedOrPrevious = false;\n        // eof quark state\n        this.previous = undefined;\n        this.origin = undefined;\n        this.originId = MIN_SMI;\n        this.needToBuildProposedValue = false;\n        this.edgesFlow = 0;\n        this.visitedAt = NOT_VISITED;\n        this.visitEpoch = 0;\n        this.promise = undefined;\n        this.$outgoingPast = undefined;\n    }\n    static new(props) {\n        const instance = new this();\n        props && Object.assign(instance, props);\n        return instance;\n    }\n    get level() {\n        return this.identifier.level;\n    }\n    get calculation() {\n        return this.identifier.calculation;\n    }\n    get context() {\n        return this.identifier.context || this.identifier;\n    }\n    forceCalculation() {\n        this.edgesFlow = MAX_SMI;\n    }\n    cleanup() {\n        this.cleanupCalculation();\n    }\n    isShadow() {\n        return Boolean(this.origin && this.origin !== this);\n    }\n    resetToEpoch(epoch) {\n        this.visitEpoch = epoch;\n        this.visitedAt = NOT_VISITED;\n        // we were clearing the edgeFlow on epoch change, however see `030_propagation_2.t.ts` for a counter-example\n        if (this.edgesFlow < 0)\n            this.edgesFlow = 0;\n        this.usedProposedOrPrevious = false;\n        this.cleanupCalculation();\n        // if there's no value, then generally should be no outgoing edges\n        // (which indicates that the value has been used somewhere else)\n        // but there might be outgoing \"past\" edges, created if `HasProposedValue`\n        // or similar effect has been used on the identifier\n        // if (this.value !== undefined) this.clearOutgoing()\n        // the `this.value !== undefined` condition above smells very \"monkey-patching\"\n        // it was probably solving some specific problem in Gantt/SchedulerPro\n        // (engine tests seems to pass w/o it)\n        // in general, should always clear the outgoing edges on new epoch\n        this.clearOutgoing();\n        this.promise = undefined;\n        if (this.origin && this.origin === this) {\n            this.proposedArguments = undefined;\n            // only overwrite the proposed value if the actual value has been already calculated\n            // otherwise, keep the proposed value as is\n            if (this.value !== undefined) {\n                this.proposedValue = this.value;\n            }\n            this.value = undefined;\n        }\n        else {\n            this.origin = undefined;\n            this.value = undefined;\n        }\n        if (this.identifier.proposedValueIsBuilt && this.proposedValue !== TombStone) {\n            this.needToBuildProposedValue = true;\n            this.proposedValue = undefined;\n        }\n    }\n    copyFrom(origin) {\n        this.value = origin.value;\n        this.proposedValue = origin.proposedValue;\n        this.proposedArguments = origin.proposedArguments;\n        this.usedProposedOrPrevious = origin.usedProposedOrPrevious;\n    }\n    clearProperties() {\n        this.value = undefined;\n        this.proposedValue = undefined;\n        this.proposedArguments = undefined;\n    }\n    mergePreviousOrigin(latestScope) {\n        const origin = this.origin;\n        if (origin !== this.previous)\n            throw new Error(\"Invalid state\");\n        this.copyFrom(origin);\n        const outgoing = this.getOutgoing();\n        for (const [identifier, quark] of origin.getOutgoing()) {\n            const ownOutgoing = outgoing.get(identifier);\n            if (!ownOutgoing) {\n                const latest = latestScope.get(identifier);\n                if (!latest || latest.originId === quark.originId)\n                    outgoing.set(identifier, latest || quark);\n            }\n        }\n        if (origin.$outgoingPast !== undefined) {\n            const outgoingPast = this.getOutgoingPast();\n            for (const [identifier, quark] of origin.getOutgoingPast()) {\n                const ownOutgoing = outgoingPast.get(identifier);\n                if (!ownOutgoing) {\n                    const latest = latestScope.get(identifier);\n                    if (!latest || latest.originId === quark.originId)\n                        outgoingPast.set(identifier, latest || quark);\n                }\n            }\n        }\n        // changing `origin`, but keeping `originId`\n        this.origin = this;\n        // some help for garbage collector\n        origin.clearProperties();\n        origin.clear();\n    }\n    setOrigin(origin) {\n        this.origin = origin;\n        this.originId = origin.originId;\n    }\n    getOrigin() {\n        if (this.origin)\n            return this.origin;\n        return this.startOrigin();\n    }\n    startOrigin() {\n        this.originId = ORIGIN_ID++;\n        return this.origin = this;\n    }\n    getOutgoing() {\n        return this;\n    }\n    getOutgoingPast() {\n        if (this.$outgoingPast !== undefined)\n            return this.$outgoingPast;\n        return this.$outgoingPast = new Map();\n    }\n    addOutgoingTo(toQuark, type) {\n        const outgoing = type === EdgeType.Normal ? this : this.getOutgoingPast();\n        outgoing.set(toQuark.identifier, toQuark);\n    }\n    clearOutgoing() {\n        this.clear();\n        if (this.$outgoingPast !== undefined)\n            this.$outgoingPast.clear();\n    }\n    getValue() {\n        const origin = this.origin;\n        return origin === this\n            ? this.value\n            : origin\n                ? origin.getValue()\n                : undefined;\n    }\n    setValue(value) {\n        if (this.origin && this.origin !== this)\n            throw new Error('Can not set value to the shadow entry');\n        this.getOrigin().value = value;\n        // // @ts-ignore\n        // if (value !== TombStone) this.identifier.DATA = value\n    }\n    hasValue() {\n        return this.getValue() !== undefined;\n    }\n    hasProposedValue() {\n        if (this.isShadow())\n            return false;\n        return this.hasProposedValueInner();\n    }\n    hasProposedValueInner() {\n        return this.proposedValue !== undefined;\n    }\n    getProposedValue(transaction) {\n        if (this.needToBuildProposedValue) {\n            this.proposedValue = this.identifier.buildProposedValue.call(this.identifier.context || this.identifier, this.identifier, this, transaction);\n            // setting this flag _after_ attempt to build the proposed value, because it might actually throw\n            // (if there's a cycle during sync computation, like during `effectiveDirection`)\n            // in such case, we need to re-enter this block\n            this.needToBuildProposedValue = false;\n        }\n        return this.proposedValue;\n    }\n    outgoingInTheFutureCb(revision, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                if (outgoing.originId === revision.getLatestEntryFor(outgoing.identifier).originId)\n                    forEach(outgoing);\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n    outgoingInTheFutureAndPastCb(revision, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                const latestEntry = revision.getLatestEntryFor(outgoing.identifier);\n                if (latestEntry && outgoing.originId === latestEntry.originId)\n                    forEach(outgoing);\n            }\n            if (current.$outgoingPast !== undefined) {\n                for (const outgoing of current.$outgoingPast.values()) {\n                    const latestEntry = revision.getLatestEntryFor(outgoing.identifier);\n                    if (latestEntry && outgoing.originId === latestEntry.originId)\n                        forEach(outgoing);\n                }\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n    outgoingInTheFutureAndPastTransactionCb(transaction, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                const latestEntry = transaction.getLatestStableEntryFor(outgoing.identifier);\n                if (latestEntry && outgoing.originId === latestEntry.originId)\n                    forEach(outgoing);\n            }\n            if (current.$outgoingPast !== undefined) {\n                for (const outgoing of current.$outgoingPast.values()) {\n                    const latestEntry = transaction.getLatestStableEntryFor(outgoing.identifier);\n                    if (latestEntry && outgoing.originId === latestEntry.originId)\n                        forEach(outgoing);\n                }\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n    // ignores the \"past\" edges by design, as they do not form cycles\n    outgoingInTheFutureTransactionCb(transaction, forEach) {\n        let current = this;\n        while (current) {\n            for (const outgoing of current.getOutgoing().values()) {\n                const latestEntry = transaction.getLatestEntryFor(outgoing.identifier);\n                if (latestEntry && outgoing.originId === latestEntry.originId)\n                    forEach(outgoing);\n            }\n            if (current.isShadow())\n                current = current.previous;\n            else\n                current = null;\n        }\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const TombStone = Symbol('Tombstone');\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base } from \"../class/Base.js\";\nimport { CalculationGen, CalculationSync } from \"../primitives/Calculation.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\nimport { ProposedOrPrevious } from \"./Effect.js\";\nimport { Quark } from \"./Quark.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\nLevels of the [[Identifier|identifiers]] as simple integers. Defines the order of calculation, enforced by the following rule -\nall lower level identifiers should be already calculated before the calculation of the identifier with the higher level starts.\nBecause of this, the lower level identifiers can not depend on higher level identifiers.\nThis rule means that effects from all identifiers of the lower levels will be already processed, when calculating\nan identifier of the higher level.\nNormally you don't need to specify a level for your identifiers.\n*/\nexport var Levels;\n(function (Levels) {\n    // must be sync\n    Levels[Levels[\"UserInput\"] = 0] = \"UserInput\";\n    Levels[Levels[\"DependsOnlyOnUserInput\"] = 1] = \"DependsOnlyOnUserInput\";\n    Levels[Levels[\"DependsOnlyOnDependsOnlyOnUserInput\"] = 2] = \"DependsOnlyOnDependsOnlyOnUserInput\";\n    // asynchronicity starts from here\n    Levels[Levels[\"DependsOnSelfKind\"] = 3] = \"DependsOnSelfKind\";\n})(Levels || (Levels = {}));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * The base class for [[Identifier|identifiers]]. It contains only \"meta\" properties that describes \"abstract\" identifier.\n * The [[Field]] class inherit from this class.\n *\n * To understand the difference between the \"abstract\" identifier and the \"specific\" identifier,\n * imagine a set of instances of the same entity class. Lets say that class has a field \"name\".\n * All of those instances each will have different \"specific\" identifiers for the field \"name\".\n *\n * In the same time, some properties are common for all \"specific\" identifiers, like [[Meta.equality|equality]], [[Meta.lazy|lazy]] etc.\n * Such properties, that does not change between every \"specific\" identifier we will call \"meta\" properties.\n *\n * This class has 2 generic arguments - `ValueT` and `ContextT`. The 1st one defines the type of the identifier's value.\n * The 2nd - the identifier's computation context (synchronous of generator).\n */\nexport class Meta extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the identifiers. Not an id, does not imply uniqueness.\n         */\n        this.name = undefined;\n        /**\n         * Whether this identifier is lazy (`true`) or strict (`false`).\n         *\n         * Lazy identifiers are calculated on-demand (when read from graph or used by another identifiers).\n         *\n         * Strict identifiers will be calculated on read or during the [[ChronoGraph.commit|commit]] call.\n         */\n        this.lazy = false;\n        // no cancels\n        this.total = true;\n        // no \"nested\" writes\n        this.pure = true;\n        this.proposedValueIsBuilt = false;\n    }\n    /**\n     * The calculation function of the identifier. Its returning value has a generic type, that is converted to a specific type,\n     * based on the generic attribute `ContextT`.\n     *\n     * This function will receive a single argument - current calculation context (effects handler).\n     *\n     * When using generators, there's no need to use this handler - one can \"yield\" the value directly, using the `yield` construct.\n     *\n     * Compare:\n     *\n     *     class Author extends Entity.mix(Base) {\n     *         @field()\n     *         firstName       : string\n     *         @field()\n     *         lastName        : string\n     *         @field()\n     *         fullName        : string\n     *\n     *         @calculate('fullName')\n     *         * calculateFullName () : ChronoIterator<string> {\n     *             return (yield this.$.firstName) + ' ' + (yield this.$.lastName)\n     *         }\n     *\n     *         @calculate('fullName')\n     *         calculateFullName (Y) : string {\n     *             return Y(this.$.firstName) + ' ' + Y(this.$.lastName)\n     *         }\n     *     }\n     *\n     * @param Y\n     */\n    calculation(Y) {\n        throw new Error(\"Abstract method `calculation` called\");\n    }\n    /**\n     * The equality check of the identifier. By default is performed with `===`.\n     *\n     * @param v1 First value\n     * @param v2 Second value\n     */\n    equality(v1, v2) {\n        return v1 === v2;\n    }\n}\n__decorate([\n    prototypeValue(Levels.DependsOnSelfKind)\n], Meta.prototype, \"level\", void 0);\n__decorate([\n    prototypeValue(true)\n], Meta.prototype, \"sync\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * The generic \"specific\" identifier class (see [[Meta]] for \"abstract\" properties). This class is generic in the sense that it does not\n * specify the type of the calculation function - it can be either synchronous or generator-based.\n *\n * It is also low-level and generally not supposed to be used directly in the application. Instead, one should\n * declare identifiers as fields (decorated class properties) in the [[Replica|replica]].\n */\nexport class Identifier extends Meta {\n    constructor() {\n        super(...arguments);\n        /**\n         * The scope (`this` value) for the calculation function.\n         */\n        this.context = undefined;\n        // flag to set during the `write` inside the `addIdentifier` call\n        this.isWritingUndefined = false;\n    }\n    newQuark(createdAt) {\n        // micro-optimization - we don't pass a config object to the `new` constructor\n        // but instead assign directly to instance\n        const newQuark = this.quarkClass.new();\n        newQuark.createdAt = createdAt;\n        newQuark.identifier = this;\n        newQuark.needToBuildProposedValue = this.proposedValueIsBuilt;\n        return newQuark;\n    }\n    write(me, transaction, quark, proposedValue, ...args) {\n        quark = quark || transaction.getWriteTarget(me);\n        quark.proposedValue = proposedValue;\n        quark.proposedArguments = args.length > 0 ? args : undefined;\n        quark.proposedIsPrevious = transaction.graph.isWritingPreviousData;\n    }\n    writeToTransaction(transaction, proposedValue, ...args) {\n        transaction.write(this, proposedValue, ...args);\n    }\n    /**\n     * Write a value to this identifier, in the context of `graph`.\n     *\n     * @param graph\n     * @param proposedValue\n     * @param args\n     */\n    writeToGraph(graph, proposedValue, ...args) {\n        graph.write(this, proposedValue, ...args);\n    }\n    /**\n     * Read the value of this identifier, in the context of `graph`, asynchronously\n     * @param graph\n     */\n    readFromGraphAsync(graph) {\n        return graph.readAsync(this);\n    }\n    /**\n     * Read the value of this identifier, in the context of `graph`, synchronously\n     * @param graph\n     */\n    readFromGraph(graph) {\n        return graph.read(this);\n    }\n    readFromTransaction(transaction) {\n        return transaction.read(this);\n    }\n    readFromTransactionAsync(transaction) {\n        return transaction.readAsync(this);\n    }\n    // readFromGraphDirtySync (graph : CheckoutI) : ValueT {\n    //     return graph.readDirty(this)\n    // }\n    buildProposedValue(me, quark, transaction) {\n        return undefined;\n    }\n    /**\n     * Template method, which is called, when this identifier \"enters\" the graph.\n     *\n     * @param graph\n     */\n    enterGraph(graph) {\n    }\n    /**\n     * Template method, which is called, when this identifier \"leaves\" the graph.\n     *\n     * @param graph\n     */\n    leaveGraph(graph) {\n    }\n}\n/**\n * Constructor for the [[Identifier]] class. Used only for typization purposes, to be able to specify the generics arguments.\n */\nexport const IdentifierC = (config) => Identifier.new(config);\n//@ts-ignore\nexport const QuarkSync = Quark.mix(CalculationSync.mix(Map));\n//@ts-ignore\nexport const QuarkGen = Quark.mix(CalculationGen.mix(Map));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Variable is a subclass of [[Identifier]], that does not perform any calculation and instead is always equal to a user-provided value.\n * It is a bit more light-weight\n */\nexport class Variable extends Identifier {\n    calculation(YIELD) {\n        throw new Error(\"The 'calculation' method of the variables should never be called. Instead, the value will be set directly to quark\");\n    }\n    write(me, transaction, quark, proposedValue, ...args) {\n        quark = quark || transaction.getWriteTarget(me);\n        quark.value = proposedValue;\n        quark.proposedArguments = args.length > 0 ? args : undefined;\n    }\n}\n__decorate([\n    prototypeValue(Levels.UserInput)\n], Variable.prototype, \"level\", void 0);\n__decorate([\n    prototypeValue(QuarkSync)\n], Variable.prototype, \"quarkClass\", void 0);\n/**\n * Constructor for the [[Variable]] class. Used only for typization purposes.\n */\nexport function VariableC(...args) {\n    return Variable.new(...args);\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Subclass of the [[Identifier]], representing synchronous computation.\n */\nexport class CalculatedValueSync extends Identifier {\n    calculation(YIELD) {\n        return YIELD(ProposedOrPrevious);\n    }\n}\n__decorate([\n    prototypeValue(QuarkSync)\n], CalculatedValueSync.prototype, \"quarkClass\", void 0);\n/**\n * Constructor for the [[CalculatedValueSync]] class. Used only for typization purposes.\n */\nexport function CalculatedValueSyncC(...args) {\n    return CalculatedValueSync.new(...args);\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Subclass of the [[Identifier]], representing generator-based computation.\n */\nexport class CalculatedValueGen extends Identifier {\n    *calculation(YIELD) {\n        return yield ProposedOrPrevious;\n    }\n}\n__decorate([\n    prototypeValue(QuarkGen)\n], CalculatedValueGen.prototype, \"quarkClass\", void 0);\n/**\n * Constructor for the [[CalculatedValueGen]] class. Used only for typization purposes.\n */\nexport function CalculatedValueGenC(...args) {\n    return CalculatedValueGen.new(...args);\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const throwUnknownIdentifier = (identifier) => { throw new Error(`Unknown identifier ${identifier}`); };\n", "import { Base } from \"../class/Base.js\";\nimport { TombStone } from \"./Quark.js\";\nlet CLOCK = 0;\nexport class Revision extends Base {\n    constructor() {\n        super(...arguments);\n        this.createdAt = CLOCK++;\n        this.name = 'revision-' + this.createdAt;\n        this.previous = undefined;\n        this.scope = new Map();\n        this.reachableCount = 0;\n        this.referenceCount = 0;\n        this.selfDependent = new Set();\n    }\n    getLatestEntryFor(identifier) {\n        let revision = this;\n        while (revision) {\n            const entry = revision.scope.get(identifier);\n            if (entry)\n                return entry;\n            revision = revision.previous;\n        }\n        return null;\n    }\n    hasIdentifier(identifier) {\n        const latestEntry = this.getLatestEntryFor(identifier);\n        return Boolean(latestEntry && latestEntry.getValue() !== TombStone);\n    }\n    *previousAxis() {\n        let revision = this;\n        while (revision) {\n            yield revision;\n            revision = revision.previous;\n        }\n    }\n}\n", "import { MAX_SMI } from \"./Helpers.js\";\n// Leveled LIFO queue\nexport class LeveledQueue {\n    constructor() {\n        this.length = 0;\n        this.levels = [];\n        this.lowestLevel = MAX_SMI;\n    }\n    getLowestLevel() {\n        for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n            if (this.levels[i])\n                return this.lowestLevel = i;\n        }\n        return this.lowestLevel = MAX_SMI;\n    }\n    takeLowestLevel() {\n        for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n            const level = this.levels[i];\n            if (level) {\n                this.length -= level.length;\n                this.levels[i] = null;\n                this.lowestLevel = i + 1;\n                return level;\n            }\n        }\n    }\n    // resetCachedPosition () {\n    //     this.lowestLevel               = MAX_SMI\n    // }\n    // last () {\n    //     for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n    //         const level     = this.levels[ i ]\n    //\n    //         if (level && level.length > 0) {\n    //             this.lowestLevel   = i\n    //\n    //             return level[ level.length - 1 ]\n    //         }\n    //     }\n    // }\n    pop() {\n        for (let i = this.lowestLevel !== MAX_SMI ? this.lowestLevel : 0; i < this.levels.length; i++) {\n            const level = this.levels[i];\n            this.lowestLevel = i;\n            if (level && level.length > 0) {\n                this.length--;\n                return level.pop();\n            }\n        }\n        this.lowestLevel = MAX_SMI;\n    }\n    push(el) {\n        const elLevel = el.level;\n        let level = this.levels[elLevel];\n        if (!level) {\n            // avoid holes in the array\n            for (let i = this.levels.length; i < elLevel; i++)\n                this.levels[i] = null;\n            level = this.levels[elLevel] = [];\n        }\n        level.push(el);\n        this.length++;\n        if (elLevel < this.lowestLevel)\n            this.lowestLevel = elLevel;\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.levels.length; i++) {\n            const level = this.levels[i];\n            if (level)\n                yield* level;\n        }\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { NOT_VISITED, OnCycleAction, WalkContext } from \"../graph/WalkDepth.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport class ComputationCycle extends Base {\n    toString() {\n        const cycleIdentifiers = [];\n        const cycleEvents = [];\n        this.cycle.forEach(({ name, context }) => {\n            cycleIdentifiers.push(name);\n            if (cycleEvents[cycleEvents.length - 1] !== context)\n                cycleEvents.push(context);\n        });\n        return 'events: \\n' +\n            cycleEvents.map(event => '#' + event.id).join(' => ') +\n            '\\n\\nidentifiers: \\n' +\n            cycleIdentifiers.join('\\n');\n        // return this.cycle.map(identifier => {\n        //     return identifier.name\n        //     // //@ts-ignore\n        //     // const sourcePoint : SourceLinePoint      = identifier.SOURCE_POINT\n        //     //\n        //     // if (!sourcePoint) return identifier.name\n        //     //\n        //     // const firstEntry       = sourcePoint.stackEntries[ 0 ]\n        //     //\n        //     // if (firstEntry) {\n        //     //     return `${identifier}\\n    yielded at ${firstEntry.sourceFile}:${firstEntry.sourceLine}:${firstEntry.sourceCharPos || ''}`\n        //     // } else\n        //     //     return identifier.name\n        // }).join(' => \\n')\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class TransactionCycleDetectionWalkContext extends WalkContext {\n    constructor() {\n        // baseRevision    : Revision                  = undefined\n        super(...arguments);\n        this.transaction = undefined;\n    }\n    onCycle(node, stack) {\n        return OnCycleAction.Cancel;\n    }\n    doCollectNext(from, to, toVisit) {\n        let visit = this.visited.get(to);\n        if (!visit) {\n            visit = { visitedAt: NOT_VISITED, visitEpoch: this.currentEpoch };\n            this.visited.set(to, visit);\n        }\n        toVisit.push({ node: to, from, label: undefined });\n    }\n    collectNext(from, toVisit) {\n        const latestEntry = this.transaction.getLatestEntryFor(from);\n        if (latestEntry) {\n            latestEntry.outgoingInTheFutureTransactionCb(this.transaction, outgoingEntry => {\n                this.doCollectNext(from, outgoingEntry.identifier, toVisit);\n            });\n        }\n        // for (const outgoingIdentifier of visitInfo.getOutgoing().keys()) {\n        //     this.doCollectNext(from, outgoingIdentifier, toVisit)\n        // }\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { NOT_VISITED, OnCycleAction, VISITED_TOPOLOGICALLY } from \"../graph/WalkDepth.js\";\nimport { Levels } from \"./Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport class TransactionWalkDepth extends Base {\n    constructor() {\n        super(...arguments);\n        this.visited = new Map();\n        this.transaction = undefined;\n        this.baseRevision = undefined;\n        this.pushTo = undefined;\n        this.toVisit = [];\n        this.currentEpoch = 0;\n    }\n    startFrom(sourceNodes) {\n        this.continueFrom(sourceNodes);\n    }\n    continueFrom(sourceNodes) {\n        this.toVisit.push.apply(this.toVisit, sourceNodes);\n        this.walkDepth();\n    }\n    startNewEpoch() {\n        if (this.toVisit.length)\n            throw new Error(\"Can not start new walk epoch in the middle of the walk\");\n        this.currentEpoch++;\n    }\n    onTopologicalNode(identifier, visitInfo) {\n        if (!identifier.lazy && identifier.level !== Levels.UserInput)\n            this.pushTo.push(visitInfo);\n    }\n    onCycle(node, stack) {\n        return OnCycleAction.Resume;\n    }\n    // it is more efficient (=faster) to create new quarks for yet unvisited identifiers\n    // in batches, using this method, instead of in normal flow in the `walkDepth` method\n    // this is probably because of the CPU context switch between the `this.visited` and `this.baseRevision.getLatestEntryFor`\n    doCollectNext(from, to, toVisit) {\n        let quark = this.visited.get(to);\n        if (!quark) {\n            quark = to.newQuark(this.baseRevision);\n            quark.visitEpoch = this.currentEpoch;\n            this.visited.set(to, quark);\n        }\n        toVisit.push(to);\n    }\n    collectNext(from, toVisit, visitInfo) {\n        const latestEntry = this.baseRevision.getLatestEntryFor(from);\n        if (latestEntry) {\n            // since `collectNext` is called exactly once for every node, all quarks\n            // will have the `previous` property populated\n            visitInfo.previous = latestEntry;\n            latestEntry.outgoingInTheFutureAndPastTransactionCb(this.transaction, outgoingEntry => {\n                this.doCollectNext(from, outgoingEntry.identifier, toVisit);\n            });\n        }\n        for (const outgoingIdentifier of visitInfo.getOutgoing().keys()) {\n            this.doCollectNext(from, outgoingIdentifier, toVisit);\n        }\n        if (visitInfo.$outgoingPast !== undefined)\n            for (const outgoingIdentifier of visitInfo.getOutgoingPast().keys()) {\n                this.doCollectNext(from, outgoingIdentifier, toVisit);\n            }\n    }\n    walkDepth() {\n        const visited = this.visited;\n        const toVisit = this.toVisit;\n        let depth;\n        while (depth = toVisit.length) {\n            const node = toVisit[depth - 1];\n            let visitInfo = visited.get(node);\n            if (visitInfo && visitInfo.visitedAt === VISITED_TOPOLOGICALLY && visitInfo.visitEpoch === this.currentEpoch) {\n                visitInfo.edgesFlow++;\n                toVisit.pop();\n                continue;\n            }\n            if (visitInfo && visitInfo.visitEpoch === this.currentEpoch && visitInfo.visitedAt !== NOT_VISITED) {\n                // it is valid to find itself \"visited\", but only if visited at the current depth\n                // (which indicates stack unwinding)\n                // if the node has been visited at earlier depth - its a cycle\n                if (visitInfo.visitedAt < depth) {\n                    // ONLY resume if explicitly returned `Resume`, cancel in all other cases (undefined, etc)\n                    if (this.onCycle(node, toVisit) !== OnCycleAction.Resume)\n                        break;\n                    visitInfo.edgesFlow++;\n                }\n                else {\n                    visitInfo.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node, visitInfo);\n                }\n                toVisit.pop();\n            }\n            else {\n                const lengthBefore = toVisit.length;\n                if (!visitInfo) {\n                    visitInfo = node.newQuark(this.baseRevision);\n                    visitInfo.visitEpoch = this.currentEpoch;\n                    visited.set(node, visitInfo);\n                }\n                this.collectNext(node, toVisit, visitInfo);\n                if (visitInfo.visitEpoch < this.currentEpoch) {\n                    visitInfo.resetToEpoch(this.currentEpoch);\n                }\n                visitInfo.visitedAt = depth;\n                visitInfo.edgesFlow++;\n                // if there's no outgoing edges, node is at topological position\n                // it would be enough to just continue the `while` loop and the `onTopologicalNode`\n                // would happen on next iteration, but with this \"inlining\" we save one call to `visited.get()`\n                // at the cost of length comparison\n                if (toVisit.length === lengthBefore) {\n                    visitInfo.visitedAt = VISITED_TOPOLOGICALLY;\n                    this.onTopologicalNode(node, visitInfo);\n                    toVisit.pop();\n                }\n            }\n        }\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { DEBUG } from \"../environment/Debug.js\";\nimport { cycleInfo, OnCycleAction } from \"../graph/WalkDepth.js\";\nimport { runGeneratorAsyncWithEffect, SynchronousCalculationStarted } from \"../primitives/Calculation.js\";\nimport { delay, isPromise, MAX_SMI } from \"../util/Helpers.js\";\nimport { LeveledQueue } from \"../util/LeveledQueue.js\";\nimport { BreakCurrentStackExecution, RejectEffect } from \"./Effect.js\";\nimport { Identifier, Levels, throwUnknownIdentifier } from \"./Identifier.js\";\nimport { EdgeType, TombStone } from \"./Quark.js\";\nimport { Revision } from \"./Revision.js\";\nimport { ComputationCycle, TransactionCycleDetectionWalkContext } from \"./TransactionCycleDetectionWalkContext.js\";\nimport { TransactionWalkDepth } from \"./TransactionWalkDepth.js\";\n//---------------------------------------------------------------------------------------------------------------------\n// weird stack overflow on 1300 deep benchmark, when using `EdgeType.Normal` w/o aliasing it to constant first\nexport const EdgeTypeNormal = EdgeType.Normal;\nexport const EdgeTypePast = EdgeType.Past;\n//---------------------------------------------------------------------------------------------------------------------\nexport class Transaction extends Base {\n    constructor() {\n        super(...arguments);\n        this.baseRevision = undefined;\n        this.candidateClass = Revision;\n        this.candidate = undefined;\n        this.graph = undefined;\n        this.isClosed = false;\n        this.walkContext = undefined;\n        this.entries = new Map();\n        // // we use 2 different stacks, because they support various effects\n        // stackSync               : LeveledQueue<Quark>  = new LeveledQueue()\n        // the `stackGen` supports async effects notably\n        this.stackGen = new LeveledQueue();\n        // is used for tracking the active quark entry (quark entry being computed)\n        this.activeStack = [];\n        this.onEffectSync = undefined;\n        this.onEffectAsync = undefined;\n        //---------------------\n        this.propagationStartDate = 0;\n        this.lastProgressNotificationDate = 0;\n        this.startProgressNotificationsAfterMs = 500;\n        this.emitProgressNotificationsEveryMs = 200;\n        this.emitProgressNotificationsEveryCalculations = 100;\n        this.plannedTotalIdentifiersToCalculate = 0;\n        // writes                  : WriteInfo[]           = []\n        this.ongoing = Promise.resolve();\n        this.selfDependedMarked = false;\n        this.rejectedWith = undefined;\n        this.stopped = false;\n        this.hasEntryWithProposedValue = false;\n        this.hasVariableEntry = false;\n    }\n    initialize(...args) {\n        super.initialize(...args);\n        this.walkContext = TransactionWalkDepth.new({\n            visited: this.entries,\n            transaction: this,\n            baseRevision: this.baseRevision,\n            pushTo: this.stackGen\n        });\n        if (!this.candidate)\n            this.candidate = this.candidateClass.new({ previous: this.baseRevision });\n        // the `onEffectSync` should be bound to the `yieldSync` of course, and `yieldSync` should look like:\n        //     yieldSync (effect : YieldableValue) : any {\n        //         if (effect instanceof Identifier) return this.read(effect)\n        //     }\n        // however, the latter consumes more stack frames - every read goes through `yieldSync`\n        // since `read` is the most used effect anyway, we bind `onEffectSync` to `read` and\n        // instead inside of `read` delegate to `yieldSync` for non-identifiers\n        this.onEffectSync = /*this.onEffectAsync =*/ this.read.bind(this);\n        this.onEffectAsync = this.readAsync.bind(this);\n    }\n    get dirty() {\n        return this.entries.size > 0;\n    }\n    markSelfDependent() {\n        if (this.selfDependedMarked)\n            return;\n        this.selfDependedMarked = true;\n        for (const selfDependentIden of this.baseRevision.selfDependent) {\n            const existing = this.entries.get(selfDependentIden);\n            if (existing && existing.getValue() === TombStone)\n                continue;\n            this.touch(selfDependentIden);\n        }\n    }\n    // onNewWrite () {\n    //     this.writes.forEach(writeInfo => {\n    //         const identifier    = writeInfo.identifier\n    //\n    //         identifier.write.call(identifier.context || identifier, identifier, this, null, ...writeInfo.proposedArgs)\n    //     })\n    //\n    //     this.writes.length = 0\n    // }\n    getActiveEntry() {\n        return this.activeStack[this.activeStack.length - 1];\n        // // `stackSync` is always empty, except when the synchronous \"batch\" is being processed\n        // const activeStack   = this.stackSync.length > 0 ? this.stackSync : this.stackGen\n        //\n        // return activeStack.last()\n    }\n    yieldAsync(effect) {\n        if (isPromise(effect))\n            return effect;\n        return this.graph[effect.handler](effect, this);\n    }\n    // see the comment for the `onEffectSync`\n    yieldSync(effect) {\n        if (isPromise(effect)) {\n            throw new Error(\"Can not yield a promise in the synchronous context\");\n        }\n        return this.graph[effect.handler](effect, this);\n    }\n    // this seems to be an optimistic version\n    readAsync(identifier) {\n        // see the comment for the `onEffectSync`\n        if (!(identifier instanceof Identifier))\n            return this.yieldAsync(identifier);\n        let entry;\n        const activeEntry = this.getActiveEntry();\n        if (activeEntry) {\n            entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);\n        }\n        else {\n            entry = this.entries.get(identifier);\n            if (!entry) {\n                const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n                if (!previousEntry)\n                    throwUnknownIdentifier(identifier);\n                entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);\n            }\n        }\n        if (entry.hasValue())\n            return entry.getValue();\n        if (entry.promise)\n            return entry.promise;\n        //----------------------\n        // now need to repeat the logic\n        if (!entry.previous || !entry.previous.hasValue())\n            entry.forceCalculation();\n        return this.ongoing = entry.promise = this.ongoing.then(() => {\n            return (async () => {\n                //----------------------\n                while (this.stackGen.lowestLevel < identifier.level) {\n                    await runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, this.stackGen.takeLowestLevel()], this);\n                }\n                this.markSelfDependent();\n                // entry might be already calculated (in the `ongoing` promise), so no need to calculate it\n                if (entry.getValue() === undefined)\n                    return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [entry]], this);\n            })();\n        }).then(() => {\n            if (this.rejectedWith)\n                throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);\n            // we clear the promise in the `resetToEpoch` should be enough?\n            // entry.promise = undefined\n            if (!entry.hasValue())\n                throw new Error('Computation cycle. Sync');\n            return entry.getValue();\n        });\n    }\n    // `ignoreActiveEntry` should be used when the atom needs to be read outside the currently ongoing transaction context\n    // in such case we still might need to calculate the atom, but should ignore any currently active\n    // calculation of the another atom\n    get(identifier) {\n        // see the comment for the `onEffectSync`\n        if (!(identifier instanceof Identifier))\n            return this.yieldSync(identifier);\n        let entry;\n        const activeEntry = this.getActiveEntry();\n        if (activeEntry) {\n            entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);\n        }\n        else {\n            entry = this.entries.get(identifier);\n            if (!entry) {\n                const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n                if (!previousEntry)\n                    throwUnknownIdentifier(identifier);\n                entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);\n            }\n        }\n        const value1 = entry.getValue();\n        if (value1 === TombStone)\n            throwUnknownIdentifier(identifier);\n        // the `&& entry.hasValue()` part was added to allow KEEP_TRYING_TO_RESOLVE feature for references\n        if (value1 !== undefined && entry.hasValue())\n            return value1;\n        if (entry.promise)\n            return entry.promise;\n        //----------------------\n        // now need to repeat the logic\n        if (!entry.previous || !entry.previous.hasValue())\n            entry.forceCalculation();\n        //----------------------\n        while (this.stackGen.getLowestLevel() < identifier.level) {\n            // here we force the computations for lower level identifiers should be sync\n            this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());\n        }\n        this.markSelfDependent();\n        if (identifier.sync) {\n            this.calculateTransitionsStackSync(this.onEffectSync, [entry]);\n            const value = entry.getValue();\n            if (value === undefined)\n                throw new Error('Cycle during synchronous computation');\n            if (value === TombStone)\n                throwUnknownIdentifier(identifier);\n            return value;\n        }\n        else {\n            const promise = this.ongoing = entry.promise = this.ongoing.then(() => {\n                // entry might be already calculated (in the `ongoing` promise), so no need to calculate it\n                if (entry.getValue() === undefined)\n                    return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [this.onEffectAsync, [entry]], this);\n            }).then(() => {\n                if (this.rejectedWith)\n                    throw new Error(`Transaction rejected: ${String(this.rejectedWith.reason)}`);\n                // we clear the promise in the `resetToEpoch` should be enough?\n                // entry.promise   = undefined\n                const value = entry.getValue();\n                if (value === undefined)\n                    throw new Error('Computation cycle. Async get');\n                if (value === TombStone)\n                    throwUnknownIdentifier(identifier);\n                return value;\n                // \n                // if (!entry.hasValue()) throw new Error('Computation cycle. Async get')\n                //\n                // return entry.getValue()\n            });\n            if (DEBUG) {\n                // @ts-ignore\n                promise.quark = entry;\n            }\n            return promise;\n            // return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitionsStackGen, [ this.onEffectAsync, [ entry ] ], this).then(() => {\n            //     const value     = entry.getValue()\n            //\n            //     \n            //     if (value === undefined) throw new Error('Cycle during synchronous computation')\n            //     if (value === TombStone) throwUnknownIdentifier(identifier)\n            //\n            //     return value\n            // })\n        }\n    }\n    // this seems to be an optimistic version\n    read(identifier) {\n        // see the comment for the `onEffectSync`\n        if (!(identifier instanceof Identifier))\n            return this.yieldSync(identifier);\n        let entry;\n        const activeEntry = this.getActiveEntry();\n        if (activeEntry) {\n            entry = this.addEdge(identifier, activeEntry, EdgeTypeNormal);\n        }\n        else {\n            entry = this.entries.get(identifier);\n            if (!entry) {\n                const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n                if (!previousEntry)\n                    throwUnknownIdentifier(identifier);\n                entry = previousEntry.hasValue() ? previousEntry : this.touch(identifier);\n            }\n        }\n        const value1 = entry.getValue();\n        if (value1 === TombStone)\n            throwUnknownIdentifier(identifier);\n        if (value1 !== undefined)\n            return value1;\n        // if (!identifier.sync) throw new Error(\"Can not calculate asynchronous identifier synchronously\")\n        // now need to repeat the logic\n        if (!entry.previous || !entry.previous.hasValue())\n            entry.forceCalculation();\n        //----------------------\n        while (this.stackGen.getLowestLevel() < identifier.level) {\n            this.calculateTransitionsStackSync(this.onEffectSync, this.stackGen.takeLowestLevel());\n        }\n        //----------------------\n        this.markSelfDependent();\n        this.calculateTransitionsStackSync(this.onEffectSync, [entry]);\n        const value = entry.getValue();\n        if (value === undefined)\n            throw new Error('Cycle during synchronous computation');\n        if (value === TombStone)\n            throwUnknownIdentifier(identifier);\n        return value;\n    }\n    // semantic is actually - read the most-fresh value\n    readCurrentOrProposedOrPrevious(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark) {\n            const value = dirtyQuark.getValue();\n            if (value !== undefined)\n                return value;\n            if (dirtyQuark.proposedValue !== undefined)\n                return dirtyQuark.proposedValue;\n        }\n        return this.readPrevious(identifier);\n    }\n    readCurrentOrProposedOrPreviousAsync(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark) {\n            const value = dirtyQuark.getValue();\n            if (value !== undefined)\n                return value;\n            if (dirtyQuark.proposedValue !== undefined)\n                return dirtyQuark.proposedValue;\n        }\n        return this.readPreviousAsync(identifier);\n    }\n    readPrevious(identifier) {\n        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n        if (!previousEntry)\n            return undefined;\n        const value = previousEntry.getValue();\n        return value !== TombStone ? (value === undefined && identifier.lazy ? this.read(identifier) : value) : undefined;\n    }\n    readPreviousAsync(identifier) {\n        const previousEntry = this.baseRevision.getLatestEntryFor(identifier);\n        if (!previousEntry)\n            return undefined;\n        const value = previousEntry.getValue();\n        return value !== TombStone ? (value !== undefined ? value : this.readAsync(identifier)) : undefined;\n    }\n    readProposedOrPrevious(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark && dirtyQuark.proposedValue !== undefined) {\n            return dirtyQuark.proposedValue;\n        }\n        else {\n            return this.readPrevious(identifier);\n        }\n    }\n    readProposedOrPreviousAsync(identifier) {\n        const dirtyQuark = this.entries.get(identifier);\n        if (dirtyQuark && dirtyQuark.proposedValue !== undefined) {\n            return dirtyQuark.proposedValue;\n        }\n        else {\n            return this.readPreviousAsync(identifier);\n        }\n    }\n    write(identifier, proposedValue, ...args) {\n        if (proposedValue === undefined)\n            proposedValue = null;\n        // this.writes.push(WriteEffect.new({\n        //     identifier      : identifier,\n        //     proposedArgs    : [ proposedValue, ...args ]\n        // }))\n        //\n        // this.onNewWrite()\n        identifier.write.call(identifier.context || identifier, identifier, this, null, /*this.getWriteTarget(identifier),*/ proposedValue, ...args);\n        const entry = this.entries.get(identifier);\n        this.hasVariableEntry = this.hasVariableEntry || (!entry.isShadow() && identifier.level === Levels.UserInput);\n        this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || entry.hasProposedValue();\n    }\n    // acquireQuark<T extends Identifier> (identifier : T) : InstanceType<T[ 'quarkClass' ]> {\n    //     return this.touch(identifier).startOrigin() as InstanceType<T[ 'quarkClass' ]>\n    // }\n    getWriteTarget(identifier) {\n        return this.touch(identifier).startOrigin();\n    }\n    // return quark if it exists and is non-shadowing, otherwise undefined\n    acquireQuarkIfExists(identifier) {\n        const entry = this.entries.get(identifier);\n        return entry && entry.origin === entry ? entry.origin : undefined;\n    }\n    touch(identifier) {\n        const existingEntry = this.entries.get(identifier);\n        if (!existingEntry || existingEntry.visitEpoch < this.walkContext.currentEpoch)\n            this.walkContext.continueFrom([identifier]);\n        const entry = existingEntry || this.entries.get(identifier);\n        entry.forceCalculation();\n        return entry;\n    }\n    // touchInvalidate (identifier : Identifier) : Quark {\n    //     const existingEntry         = this.entries.get(identifier)\n    //\n    //     if (existingEntry && existingEntry.hasValue()) {\n    //         this.walkContext.startNewEpoch()\n    //     }\n    //\n    //     if (!existingEntry || existingEntry.visitEpoch < this.walkContext.currentEpoch) this.walkContext.continueFrom([ identifier ])\n    //\n    //     const entry                 = existingEntry || this.entries.get(identifier)\n    //\n    //     entry.forceCalculation()\n    //\n    //     return entry\n    // }\n    hasIdentifier(identifier) {\n        const activeEntry = this.entries.get(identifier);\n        if (activeEntry && activeEntry.getValue() === TombStone)\n            return false;\n        return Boolean(activeEntry || this.baseRevision.getLatestEntryFor(identifier));\n    }\n    // this is actually an optimized version of `write`, which skips the graph walk phase\n    // (since the identifier is assumed to be new, there should be no dependent quarks)\n    addIdentifier(identifier, proposedValue, ...args) {\n        // however, the identifier may be already in the transaction, for example if the `write` method\n        // of some other identifier writes to this identifier\n        let entry = this.entries.get(identifier);\n        const alreadyHadEntry = Boolean(entry);\n        const isVariable = identifier.level === Levels.UserInput;\n        if (!entry) {\n            entry = identifier.newQuark(this.baseRevision);\n            entry.previous = this.baseRevision.getLatestEntryFor(identifier);\n            entry.forceCalculation();\n            this.entries.set(identifier, entry);\n            if (!identifier.lazy && !isVariable)\n                this.stackGen.push(entry);\n            this.hasVariableEntry = this.hasVariableEntry || (!entry.isShadow() && isVariable);\n            this.hasEntryWithProposedValue = this.hasEntryWithProposedValue || entry.hasProposedValue();\n        }\n        if (proposedValue !== undefined || isVariable) {\n            entry.startOrigin();\n            // we should not write if there's already an entry with some values (and we are trying to add it again)\n            // this means there were some other identifier that has written into this one even before it was added\n            // (probably in its `write` method)\n            const shouldNotWrite = alreadyHadEntry && (entry.proposedValue !== undefined || entry.value !== undefined);\n            // however, if that entry contain TombStone marks, we should always write - means we are\n            // actually re-adding the identifier, which has been removed in the same transaction\n            if (!shouldNotWrite || entry.proposedValue === TombStone || entry.value === TombStone) {\n                identifier.isWritingUndefined = proposedValue === undefined;\n                identifier.write.call(identifier.context || identifier, identifier, this, entry, proposedValue === undefined && isVariable ? null : proposedValue, ...args);\n                identifier.isWritingUndefined = false;\n            }\n        }\n        // if we are re-adding the same identifier in the same transaction, clear the TombStone flag\n        if (entry.getValue() === TombStone)\n            entry.value = undefined;\n        if (entry.proposedValue === TombStone)\n            entry.proposedValue = undefined;\n        identifier.enterGraph(this.graph);\n        return entry;\n    }\n    removeIdentifier(identifier) {\n        identifier.leaveGraph(this.graph);\n        const entry = this.touch(identifier).startOrigin();\n        entry.setValue(TombStone);\n        // removing the identifier from self-dependent, otherwise there will be an attempt to evaluate it\n        this.candidate.selfDependent.delete(identifier);\n    }\n    populateCandidateScopeFromTransitions(candidate, scope) {\n        if (candidate.scope.size === 0) {\n            // in this branch we can overwrite the whole map\n            candidate.scope = scope;\n        }\n        else {\n            // in this branch candidate's scope already has some content - this is the case for calculating lazy values\n            // \n            // entries.forEach((entry : QuarkEntry, identifier : Identifier) => {\n            //     candidate.scope.set(identifier, entry)\n            // })\n            for (const [identifier, quark] of scope) {\n                if (quark.isShadow()) {\n                    const latestEntry = candidate.getLatestEntryFor(identifier);\n                    // and we iterate over the edges from \"origin\" anyway\n                    quark.getOutgoing().forEach((toQuark, toIdentifier) => latestEntry.getOutgoing().set(toIdentifier, toQuark));\n                }\n                else {\n                    candidate.scope.set(identifier, quark);\n                }\n            }\n        }\n    }\n    preCommit(args) {\n        if (this.isClosed)\n            throw new Error('Can not propagate closed revision');\n        this.markSelfDependent();\n        this.isClosed = true;\n        this.propagationStartDate = Date.now();\n        this.plannedTotalIdentifiersToCalculate = this.stackGen.length;\n    }\n    postCommit() {\n        this.populateCandidateScopeFromTransitions(this.candidate, this.entries);\n        // won't be available after next line\n        const entries = this.entries;\n        // for some reason need to cleanup the `walkContext` manually, otherwise the extra revisions hangs in memory\n        this.walkContext = undefined;\n        return { revision: this.candidate, entries, transaction: this };\n    }\n    commit(args) {\n        this.preCommit(args);\n        this.calculateTransitionsSync(this.onEffectSync);\n        // runGeneratorSyncWithEffect(this.onEffectSync, this.calculateTransitionsStackGen, [ this.onEffectSync, stack ], this)\n        return this.postCommit();\n    }\n    reject(rejection = RejectEffect.new()) {\n        this.rejectedWith = rejection;\n        this.walkContext = undefined;\n    }\n    // stops the calculations, but does not reject\n    stop() {\n        this.stopped = true;\n    }\n    clearRejected() {\n        for (const quark of this.entries.values()) {\n            quark.cleanup();\n            // quark.clearOutgoing()\n        }\n        this.entries.clear();\n    }\n    // // propagation that does not use generators at all\n    // propagateSync (args? : PropagateArguments) : TransactionPropagateResult {\n    //     const stack = this.prePropagate(args)\n    //\n    //     this.calculateTransitionsStackSync(this.onEffectSync, stack)\n    //     // runGeneratorSyncWithEffect(this.onEffectSync, this.calculateTransitionsStackGen, [ this.onEffectSync, stack ], this)\n    //\n    //     return this.postPropagate()\n    // }\n    async commitAsync(args) {\n        this.preCommit(args);\n        return this.ongoing = this.ongoing.then(() => {\n            return runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitions, [this.onEffectAsync], this);\n        }).then(() => {\n            return this.postCommit();\n        });\n        // await runGeneratorAsyncWithEffect(this.onEffectAsync, this.calculateTransitions, [ this.onEffectAsync ], this)\n        //\n        // return this.postCommit()\n    }\n    getLatestEntryFor(identifier) {\n        let entry = this.entries.get(identifier) || this.baseRevision.getLatestEntryFor(identifier);\n        if (entry && entry.getValue() === TombStone)\n            return undefined;\n        return entry;\n    }\n    // check the transaction \"entries\" first, but only return an entry\n    // from that, if it is already calculated, otherwise - take it\n    // from the base revision\n    getLatestStableEntryFor(identifier) {\n        let entry = this.entries.get(identifier);\n        if (entry) {\n            const value = entry.getValue();\n            if (value === TombStone)\n                return undefined;\n            return value === undefined ? this.baseRevision.getLatestEntryFor(identifier) : entry;\n        }\n        else {\n            return this.baseRevision.getLatestEntryFor(identifier);\n        }\n    }\n    addEdge(identifierRead, activeEntry, type) {\n        const identifier = activeEntry.identifier;\n        if (identifier.level < identifierRead.level)\n            throw new Error('Identifier can not read from higher level identifier');\n        let entry = this.entries.get(identifierRead);\n        // creating \"shadowing\" entry, to store the new edges\n        if (!entry) {\n            const previousEntry = this.baseRevision.getLatestEntryFor(identifierRead);\n            if (!previousEntry)\n                throwUnknownIdentifier(identifierRead);\n            entry = identifierRead.newQuark(this.baseRevision);\n            entry.setOrigin(previousEntry);\n            entry.previous = previousEntry;\n            this.entries.set(identifierRead, entry);\n        }\n        entry.addOutgoingTo(activeEntry, type);\n        return entry;\n    }\n    onQuarkCalculationCompleted(entry, value) {\n        // cleanup the iterator\n        entry.cleanup();\n        const identifier = entry.identifier;\n        const previousEntry = entry.previous;\n        //--------------------\n        const sameAsPrevious = Boolean(previousEntry && previousEntry.hasValue() && identifier.equality(value, previousEntry.getValue()));\n        if (sameAsPrevious) {\n            previousEntry.outgoingInTheFutureAndPastTransactionCb(this, previousOutgoingEntry => {\n                const outgoingEntry = this.entries.get(previousOutgoingEntry.identifier);\n                if (outgoingEntry)\n                    outgoingEntry.edgesFlow--;\n            });\n            // this is a \"workaround\" for the following problem:\n            // there might be several copies of the same quark in the calculation stack, this is normal\n            // because if quark is requested by some other quark it is just pushed to the stack,\n            // which may already contain this quark\n            // then when the quark is calculated (this code) it propagates the `edgesFlow` decrease\n            // but next time it will be encountered in the stack, its `edgesFlow` might be decreased by other\n            // identifiers, which will trigger another round of `edgesFlow` decrease propagation\n            // so we set the `edgesFlow` to MAX_SMI after decrease been propagated to prevent repeated such propagation\n            entry.edgesFlow = MAX_SMI;\n            entry.setOrigin(previousEntry.origin);\n            // seems not needed anymore?\n            // this is to indicate that this entry should be recalculated (origin removed)\n            // see `resetToEpoch`\n            entry.value = value;\n        }\n        else {\n            entry.startOrigin();\n            entry.setValue(value);\n        }\n        //--------------------\n        let ignoreSelfDependency = false;\n        if (entry.usedProposedOrPrevious) {\n            if (entry.proposedValue !== undefined) {\n                if (identifier.equality(value, entry.proposedValue))\n                    ignoreSelfDependency = true;\n            }\n            else {\n                // ignore the uninitialized atoms (`proposedValue` === undefined && !previousEntry)\n                // which has been calculated to `null` - we don't consider this as a change\n                if (sameAsPrevious || (!previousEntry && value === null))\n                    ignoreSelfDependency = true;\n            }\n            if (!ignoreSelfDependency)\n                this.candidate.selfDependent.add(identifier);\n        }\n    }\n    onReadIdentifier(identifierRead, activeEntry, stack) {\n        const requestedEntry = this.addEdge(identifierRead, activeEntry, EdgeTypeNormal);\n        // this is a workaround for references with failed resolution problem in gantt\n        // those references return `hasValue() === false` even that they actually have value\n        // (which is `null` and needed to be recalculated)\n        if (requestedEntry.hasValue() || requestedEntry.value !== undefined) {\n            const value = requestedEntry.getValue();\n            if (value === TombStone)\n                throwUnknownIdentifier(identifierRead);\n            return activeEntry.continueCalculation(value);\n        }\n        else if (requestedEntry.isShadow()) {\n            // shadow entry is shadowing a quark w/o value - it is still transitioning or lazy\n            // in both cases start new calculation\n            requestedEntry.startOrigin();\n            requestedEntry.forceCalculation();\n            stack.push(requestedEntry);\n            return undefined;\n        }\n        else {\n            if (!requestedEntry.isCalculationStarted()) {\n                stack.push(requestedEntry);\n                if (!requestedEntry.previous || !requestedEntry.previous.hasValue())\n                    requestedEntry.forceCalculation();\n                return undefined;\n            }\n            else {\n                // cycle - the requested quark has started calculation (means it was encountered in the calculation loop before)\n                // but the calculation did not complete yet (even that requested quark is calculated before the current)\n                let cycle;\n                const walkContext = TransactionCycleDetectionWalkContext.new({\n                    transaction: this,\n                    onCycle(node, stack) {\n                        cycle = ComputationCycle.new({\n                            cycle: cycleInfo(stack),\n                            requestedEntry,\n                            activeEntry,\n                        });\n                        return OnCycleAction.Cancel;\n                    }\n                });\n                walkContext.startFrom([requestedEntry.identifier]);\n                return cycle;\n            }\n        }\n    }\n    *calculateTransitions(context) {\n        const queue = this.stackGen;\n        while (queue.length) {\n            // some identifiers from the queue??\n            yield* this.calculateTransitionsStackGen(context, queue.takeLowestLevel());\n        }\n    }\n    calculateTransitionsSync(context) {\n        const queue = this.stackGen;\n        while (queue.length) {\n            this.calculateTransitionsStackSync(context, queue.takeLowestLevel());\n        }\n    }\n    // this method is not decomposed into smaller ones intentionally, as that makes benchmarks worse\n    // it seems that overhead of calling few more functions in such tight loop as this outweighs the optimization\n    *calculateTransitionsStackGen(context, stack) {\n        if (this.rejectedWith || this.stopped)\n            return;\n        this.walkContext.startNewEpoch();\n        const entries = this.entries;\n        const propagationStartDate = this.propagationStartDate;\n        const enableProgressNotifications = this.graph ? this.graph.enableProgressNotifications : false;\n        let counter = 0;\n        const prevActiveStack = this.activeStack;\n        this.activeStack = stack;\n        while (stack.length && !this.rejectedWith && !this.stopped) {\n            if (enableProgressNotifications && !(counter++ % this.emitProgressNotificationsEveryCalculations)) {\n                const now = Date.now();\n                const elapsed = now - propagationStartDate;\n                if (elapsed > this.startProgressNotificationsAfterMs) {\n                    const lastProgressNotificationDate = this.lastProgressNotificationDate;\n                    if (!lastProgressNotificationDate || (now - lastProgressNotificationDate) > this.emitProgressNotificationsEveryMs) {\n                        this.lastProgressNotificationDate = now;\n                        this.graph.onPropagationProgressNotification({\n                            total: this.plannedTotalIdentifiersToCalculate,\n                            remaining: this.stackGen.length + stack.length,\n                            phase: 'propagating'\n                        });\n                        // need to \"exit\" the context of the current transaction for the time of the following `delay()`\n                        // otherwise, any reads from graph during that time will be recorded as the dependencies\n                        // of the currently active atom\n                        this.activeStack = prevActiveStack;\n                        yield delay(0);\n                        this.activeStack = stack;\n                    }\n                }\n            }\n            if (this.rejectedWith || this.stopped)\n                break;\n            const entry = stack[stack.length - 1];\n            const identifier = entry.identifier;\n            const ownEntry = entries.get(identifier);\n            if (ownEntry !== entry) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if (entry.edgesFlow == 0) {\n                // even if we delete the entry there might be other copies in stack, so reduce the `edgesFlow` to -1\n                // to indicate that those are already processed\n                entry.edgesFlow--;\n                const previousEntry = entry.previous;\n                previousEntry && previousEntry.outgoingInTheFutureAndPastTransactionCb(this, outgoing => {\n                    const outgoingEntry = entries.get(outgoing.identifier);\n                    if (outgoingEntry)\n                        outgoingEntry.edgesFlow--;\n                });\n            }\n            // the \"edgesFlow < 0\" indicates that none of the incoming deps of this quark has changed\n            // thus we don't need to calculate it, moreover, we can remove the quark from the `entries`\n            // to expose the value from the previous revision\n            // however, we only do it, when there is a quark from previous revision and it has \"origin\" (some value)\n            if (entry.edgesFlow < 0 && entry.previous && entry.previous.origin) {\n                // even if the entry will be deleted from the transaction, we set the correct origin for it\n                // this is because there might be other references to this entry in the stack\n                // and also the entry may be referenced as dependency of some other quark\n                // in such case the correct `originId` will preserve dependency during revisions compactification\n                entry.setOrigin(entry.previous.origin);\n                // if there's no outgoing edges we remove the quark\n                if (entry.size === 0) {\n                    entries.delete(identifier);\n                }\n                // reduce garbage collection workload\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if ( /*entry.isShadow() ||*/entry.hasValue() || entry.proposedValue === TombStone) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            const startedAtEpoch = entry.visitEpoch;\n            let iterationResult = entry.isCalculationStarted() ? entry.iterationResult : entry.startCalculation(this.onEffectSync);\n            while (iterationResult && !this.rejectedWith && !this.stopped) {\n                const value = iterationResult.value === undefined ? null : iterationResult.value;\n                if (entry.isCalculationCompleted()) {\n                    if (entry.visitEpoch == startedAtEpoch) {\n                        this.onQuarkCalculationCompleted(entry, value);\n                    }\n                    stack.pop();\n                    break;\n                }\n                else if (value instanceof Identifier) {\n                    const onReadIdentifierResult = this.onReadIdentifier(value, entry, stack);\n                    // handle the cycle\n                    if (onReadIdentifierResult instanceof ComputationCycle) {\n                        this.walkContext.startNewEpoch();\n                        yield* this.graph.onComputationCycleHandler(onReadIdentifierResult);\n                        entry.cleanupCalculation();\n                        iterationResult = undefined;\n                    }\n                    else {\n                        iterationResult = onReadIdentifierResult;\n                    }\n                }\n                else if (value === SynchronousCalculationStarted) {\n                    // the fact, that we've encountered `SynchronousCalculationStarted` constant can mean 2 things:\n                    // 1) there's a cycle during synchronous computation (we throw exception in `read` method)\n                    // 2) some other computation is reading synchronous computation, that has already started\n                    //    in such case its safe to just unwind the stack\n                    stack.pop();\n                    break;\n                }\n                else {\n                    // bypass the unrecognized effect to the outer context\n                    const effectResult = yield value;\n                    // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // in such case we can not continue calculation and just exit the inner loop\n                    if (effectResult === BreakCurrentStackExecution)\n                        break;\n                    // // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // // in such case we can not continue calculation and just exit the inner loop\n                    // if (entry.iterationResult)\n                    if (entry.visitEpoch === startedAtEpoch) {\n                        iterationResult = entry.continueCalculation(effectResult);\n                    }\n                    else {\n                        stack.pop();\n                        break;\n                    }\n                    // else\n                    //     iterationResult         = null\n                }\n            }\n        }\n        this.activeStack = prevActiveStack;\n    }\n    // THIS METHOD HAS TO BE KEPT SYNCED WITH THE `calculateTransitionsStackGen` !!!\n    calculateTransitionsStackSync(context, stack) {\n        if (this.rejectedWith || this.stopped)\n            return;\n        this.walkContext.startNewEpoch();\n        const entries = this.entries;\n        const prevActiveStack = this.activeStack;\n        this.activeStack = stack;\n        while (stack.length && !this.rejectedWith && !this.stopped) {\n            const entry = stack[stack.length - 1];\n            const identifier = entry.identifier;\n            const ownEntry = entries.get(identifier);\n            if (ownEntry !== entry) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if (entry.edgesFlow == 0) {\n                // even if we delete the entry there might be other copies in stack, so reduce the `edgesFlow` to -1\n                // to indicate that those are already processed\n                entry.edgesFlow--;\n                const previousEntry = entry.previous;\n                previousEntry && previousEntry.outgoingInTheFutureAndPastTransactionCb(this, outgoing => {\n                    const outgoingEntry = entries.get(outgoing.identifier);\n                    if (outgoingEntry)\n                        outgoingEntry.edgesFlow--;\n                });\n            }\n            // the \"edgesFlow < 0\" indicates that none of the incoming deps of this quark has changed\n            // thus we don't need to calculate it, moreover, we can remove the quark from the `entries`\n            // to expose the value from the previous revision\n            // however, we only do it, when there is a quark from previous revision and it has \"origin\" (some value)\n            if (entry.edgesFlow < 0 && entry.previous && entry.previous.origin) {\n                // even if the entry will be deleted from the transaction, we set the correct origin for it\n                // this is because there might be other references to this entry in the stack\n                // and also the entry may be referenced as dependency of some other quark\n                // in such case the correct `originId` will preserve dependency during revisions compactification\n                entry.setOrigin(entry.previous.origin);\n                // if there's no outgoing edges we remove the quark\n                if (entry.size === 0) {\n                    entries.delete(identifier);\n                }\n                // reduce garbage collection workload\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            if ( /*entry.isShadow() ||*/entry.hasValue() || entry.proposedValue === TombStone) {\n                entry.cleanup();\n                stack.pop();\n                continue;\n            }\n            const startedAtEpoch = entry.visitEpoch;\n            let iterationResult = entry.isCalculationStarted() ? entry.iterationResult : entry.startCalculation(this.onEffectSync);\n            while (iterationResult && !this.rejectedWith && !this.stopped) {\n                const value = iterationResult.value === undefined ? null : iterationResult.value;\n                if (entry.isCalculationCompleted()) {\n                    if (entry.visitEpoch == startedAtEpoch) {\n                        this.onQuarkCalculationCompleted(entry, value);\n                    }\n                    stack.pop();\n                    break;\n                }\n                else if (value instanceof Identifier) {\n                    const onReadIdentifierResult = this.onReadIdentifier(value, entry, stack);\n                    // handle the cycle\n                    if (onReadIdentifierResult instanceof ComputationCycle) {\n                        this.walkContext.startNewEpoch();\n                        this.graph.onComputationCycleHandlerSync(onReadIdentifierResult, this);\n                        entry.cleanupCalculation();\n                        iterationResult = undefined;\n                    }\n                    else {\n                        iterationResult = onReadIdentifierResult;\n                    }\n                }\n                else if (value === SynchronousCalculationStarted) {\n                    // the fact, that we've encountered `SynchronousCalculationStarted` constant can mean 2 things:\n                    // 1) there's a cycle during synchronous computation (we throw exception in `read` method)\n                    // 2) some other computation is reading synchronous computation, that has already started\n                    //    in such case its safe to just unwind the stack\n                    stack.pop();\n                    break;\n                }\n                else {\n                    // bypass the unrecognized effect to the outer context\n                    const effectResult = context(value);\n                    if (isPromise(effectResult))\n                        throw new Error(\"Effect resolved to promise in the synchronous context, check that you marked the asynchronous calculations accordingly\");\n                    // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // in such case we can not continue calculation and just exit the inner loop\n                    if (effectResult === BreakCurrentStackExecution)\n                        break;\n                    // // the calculation can be interrupted (`cleanupCalculation`) as a result of the effect (WriteEffect)\n                    // // in such case we can not continue calculation and just exit the inner loop\n                    // if (entry.iterationResult)\n                    if (entry.visitEpoch === startedAtEpoch) {\n                        iterationResult = entry.continueCalculation(effectResult);\n                    }\n                    else {\n                        stack.pop();\n                        break;\n                    }\n                    // else\n                    //     iterationResult         = null\n                }\n            }\n        }\n        this.activeStack = prevActiveStack;\n    }\n}\n", "import { Base } from \"../class/Base.js\";\nimport { concat } from \"../collection/Iterator.js\";\nimport { warn } from \"../environment/Debug.js\";\nimport { copySetInto, isGeneratorFunction } from \"../util/Helpers.js\";\nimport { BreakCurrentStackExecution, HasProposedNotPreviousValueSymbol, HasProposedValueSymbol, OwnIdentifierSymbol, OwnQuarkSymbol, PreviousValueOfSymbol, ProposedArgumentsOfSymbol, ProposedOrPreviousSymbol, ProposedOrPreviousValueOfSymbol, ProposedValueOfSymbol, RejectEffect, RejectSymbol, TransactionSymbol, UnsafePreviousValueOfSymbol, UnsafeProposedOrPreviousValueOfSymbol, WriteSeveralSymbol, WriteSymbol } from \"./Effect.js\";\nimport { CalculatedValueGen, CalculatedValueGenC, CalculatedValueSyncC, VariableC } from \"./Identifier.js\";\nimport { TombStone } from \"./Quark.js\";\nimport { Revision } from \"./Revision.js\";\nimport { EdgeTypePast, Transaction } from \"./Transaction.js\";\n/**\n * A constant which will be used a commit result, when graph is not available.\n */\nexport const CommitZero = {\n    rejectedWith: null\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport class Listener extends Base {\n    constructor() {\n        super(...arguments);\n        this.handlers = [];\n    }\n    trigger(value) {\n        for (let i = 0; i < this.handlers.length; i++)\n            this.handlers[i](value);\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Generic reactive graph. Consists from [[Identifier]]s, depending on each other. This is a low-level representation\n * of the ChronoGraph dataset, it is not \"aware\" of the entity/relation framework and operates as \"just graph\".\n *\n * For higher-level (and more convenient) representation, please refer to [[Replica]].\n *\n * An example of usage:\n *\n *     const graph      = ChronoGraph.new({ historyLimit : 10 })\n *\n *     const var1       = graph.variable(1)\n *     const var2       = graph.variable(2)\n *     const iden1      = graph.identifier((Y) => Y(var1) + Y(var2))\n *\n *     graph.read(iden1) // 3\n *\n *     graph.commit()\n *\n *     graph.write(var1, 2)\n *\n *     graph.read(iden1) // 4\n *\n *     graph.reject()\n *\n *     graph.read(var1) // 1\n *     graph.read(iden1) // 3\n *\n */\nexport class ChronoGraph extends Base {\n    constructor() {\n        super(...arguments);\n        this.baseRevisionStable = undefined;\n        this.baseRevisionTentative = undefined;\n        this.baseRevision = Revision.new();\n        // the revision to follow to, when performing `redo` operation\n        this.topRevision = undefined;\n        /**\n         * Integer value, indicating how many transactions to keep in memory, to be available for [[undo]] call.\n         * Default value is 0 - previous transaction is cleared immediately.\n         *\n         * Increase this config to opt-in for the [[undo]]/[[redo]] functionality.\n         */\n        this.historyLimit = 0;\n        this.listeners = new Map();\n        // this flag is set when the data being written to the graph is \"undo/redo\" data\n        // in such case, we shouldn't treat it as user input, but instead as a side-effect free\n        // state restoration\n        // this flag is used in the CycleResolverChrono and in general is engine specific\n        this.isWritingPreviousData = false;\n        this.$activeTransaction = undefined;\n        this.isCommitting = false;\n        this.enableProgressNotifications = false;\n        this.ongoing = Promise.resolve();\n        this._isInitialCommit = true;\n        //-------------------------------------\n        // a \"cross-platform\" trick to avoid specifying the type of the `autoCommitTimeoutId` explicitly\n        this.autoCommitTimeoutId = null;\n        /**\n         * If this option is enabled with `true` value, all data modification calls ([[write]], [[addIdentifier]], [[removeIdentifier]]) will trigger\n         * a delayed [[commit]] call (or [[commitAsync]], depending from the [[autoCommitMode]] option).\n         */\n        this.autoCommit = false;\n        /**\n         * Indicates the default commit mode, which is used in [[autoCommit]].\n         */\n        this.autoCommitMode = 'sync';\n        this.autoCommitHandler = null;\n        this.onWriteDuringCommit = 'throw';\n        this.onComputationCycle = 'throw';\n        this.transactionClass = Transaction;\n        this.isJustCleared = false;\n        this.$followingRevision = undefined;\n    }\n    initialize(...args) {\n        super.initialize(...args);\n        if (!this.topRevision)\n            this.topRevision = this.baseRevision;\n        if (this.autoCommit) {\n            this.autoCommitHandler = this.autoCommitMode === 'sync' ? arg => this.commit(arg) : async (arg) => this.commitAsync(arg);\n        }\n        this.markAndSweep();\n    }\n    /**\n     * Returns boolean, indicating whether the auto-commit is pending.\n     */\n    hasPendingAutoCommit() {\n        return this.autoCommitTimeoutId !== null;\n    }\n    get dirty() {\n        return this.activeTransaction.dirty;\n    }\n    clear() {\n        this.reject();\n        this.unScheduleAutoCommit();\n        // some stale state - `clear` called at sensitive time\n        this.baseRevision.scope && this.baseRevision.scope.clear();\n        this.baseRevision.previous = null;\n        this.listeners.clear();\n        this.topRevision = this.baseRevision;\n        this.$followingRevision = undefined;\n        this.$activeTransaction = undefined;\n        this.markAndSweep();\n        this.isJustCleared = true;\n    }\n    *eachReachableRevision() {\n        let isBetweenTopBottom = true;\n        let counter = 0;\n        for (const revision of this.topRevision.previousAxis()) {\n            yield [revision, isBetweenTopBottom || counter < this.historyLimit];\n            if (revision === this.baseRevision) {\n                isBetweenTopBottom = false;\n            }\n            else {\n                if (!isBetweenTopBottom)\n                    counter++;\n            }\n        }\n    }\n    get isInitialCommit() {\n        return this._isInitialCommit;\n    }\n    set isInitialCommit(value) {\n        this._isInitialCommit = value;\n    }\n    markAndSweep() {\n        let lastReferencedRevision;\n        const unreachableRevisions = [];\n        for (const [revision, isReachable] of this.eachReachableRevision()) {\n            if (isReachable) {\n                revision.reachableCount++;\n                lastReferencedRevision = revision;\n            }\n            else\n                unreachableRevisions.push(revision);\n            revision.referenceCount++;\n        }\n        unreachableRevisions.unshift(lastReferencedRevision);\n        for (let i = unreachableRevisions.length - 1; i >= 1 && unreachableRevisions[i].reachableCount === 0; i--) {\n            this.compactRevisions(unreachableRevisions[i - 1], unreachableRevisions[i]);\n        }\n    }\n    compactRevisions(newRev, prevRev) {\n        if (prevRev.reachableCount > 0 || newRev.previous !== prevRev)\n            throw new Error(\"Invalid compact operation\");\n        // we can only shred revision if its being referenced maximum 1 time (from the current Checkout instance)\n        if (prevRev.referenceCount <= 1) {\n            for (const [identifier, entry] of newRev.scope) {\n                if (entry.getValue() === TombStone) {\n                    prevRev.scope.delete(identifier);\n                }\n                else {\n                    const prevQuark = prevRev.scope.get(identifier);\n                    if (entry.origin === entry) {\n                        if (prevQuark) {\n                            prevQuark.clear();\n                            prevQuark.clearProperties();\n                        }\n                    }\n                    else if (prevQuark && entry.origin === prevQuark) {\n                        entry.mergePreviousOrigin(newRev.scope);\n                    }\n                    else if (identifier.lazy && !entry.origin && prevQuark && prevQuark.origin) {\n                        // for lazy quarks, that depends on the `ProposedOrPrevious` effect, we need to save the value or proposed value\n                        // from the previous revision\n                        entry.startOrigin().proposedValue = prevQuark.origin.value !== undefined ? prevQuark.origin.value : prevQuark.origin.proposedValue;\n                    }\n                    entry.previous = undefined;\n                    prevRev.scope.set(identifier, entry);\n                }\n            }\n            copySetInto(newRev.selfDependent, prevRev.selfDependent);\n            // some help for garbage collector\n            // this clears the \"entries\" in the transaction commit result in the \"finalizeCommitAsync\"\n            // newRev.scope.clear()\n            newRev.scope = prevRev.scope;\n            // make sure the previous revision won't be used inconsistently\n            prevRev.scope = null;\n        }\n        // otherwise, we have to copy from it, and keep it intact\n        else {\n            newRev.scope = new Map(concat(prevRev.scope, newRev.scope));\n            newRev.selfDependent = new Set(concat(prevRev.selfDependent, newRev.selfDependent));\n            prevRev.referenceCount--;\n        }\n        // in both cases break the `previous` chain\n        newRev.previous = null;\n    }\n    get followingRevision() {\n        if (this.$followingRevision !== undefined)\n            return this.$followingRevision;\n        const revisions = Array.from(this.topRevision.previousAxis());\n        const entries = [];\n        for (let i = revisions.length - 1; i > 0; i--)\n            entries.push([revisions[i], revisions[i - 1]]);\n        return this.$followingRevision = new Map(entries);\n    }\n    get activeTransaction() {\n        if (this.$activeTransaction)\n            return this.$activeTransaction;\n        return this.$activeTransaction = this.transactionClass.new({\n            baseRevision: this.baseRevisionTentative || this.baseRevision,\n            graph: this\n        });\n    }\n    /**\n     * Creates a new branch of this graph. Only committed data will be \"visible\" in the new branch.\n     *\n     * ```ts\n     * const graph2 = ChronoGraph.new()\n     *\n     * const variable13 : Variable<number> = graph2.variable(5)\n     *\n     * const branch2 = graph2.branch()\n     *\n     * branch2.write(variable13, 10)\n     *\n     * const value13_1 = graph2.read(variable13)  // 5\n     * const value13_2 = branch2.read(variable13) // 10\n     * ```\n     *\n     * When using the branching feature in [[Replica]], you need to reference the field values by yielding their\n     * corresponding identifiers. This is because ChronoGraph need to know in context of which branch\n     * the calculation happens and this information is encoded in the outer context. This may improve in the future.\n     *\n     * ```ts\n     * class Author extends Entity.mix(Base) {\n     *     @calculate('fullName')\n     *     calculateFullName (Y) : string {\n     *         return Y(this.$.firstName) + ' ' + Y(this.$.lastName)\n     *     }\n     *\n     *     @calculate('fullName')\n     *     * calculateFullName (Y) : CalculationIterator<string> {\n     *         return (yield this.$.firstName) + ' ' + (yield this.$.lastName)\n     *     }\n     * }\n     * ```\n     *\n     * @param config Configuration object for the new graph instance.\n     */\n    branch(config) {\n        const Constructor = this.constructor;\n        return Constructor.new(Object.assign({}, config, { baseRevision: this.baseRevision }));\n    }\n    propagate(args) {\n        return this.commit(args);\n    }\n    /**\n     * Rejects the current changes in the graph and revert it to the state of the previous [[commit]].\n     *\n     * See also [[RejectEffect]].\n     *\n     * @param reason Any value, describing why reject has happened\n     */\n    reject(reason) {\n        this.activeTransaction.reject(RejectEffect.new({ reason }));\n        // reject resets the `ongoing` promise (which is possibly rejected because of cycle exception)\n        this.ongoing = Promise.resolve();\n        this.$activeTransaction = undefined;\n        this.baseRevisionTentative = undefined;\n        if (this.baseRevisionStable) {\n            this.baseRevision = this.baseRevisionStable;\n            this.baseRevisionStable = undefined;\n        }\n    }\n    /**\n     * Synchronously commit the state of the graph. All potentially changed [[Identifier.lazy|strict]] identifiers\n     * will be calculated during this call. If any of such identifiers will be [[Identifier.sync|async]], an exception\n     * will be thrown.\n     *\n     * This call marks a \"stable\" state of the graph and a transaction border. Using the [[undo]] call one can revert to the previous\n     * state.\n     *\n     * See also [[reject]].\n     *\n     * @param args\n     */\n    commit(args) {\n        this.isJustCleared = false;\n        this.unScheduleAutoCommit();\n        this.baseRevisionStable = this.baseRevision;\n        const activeTransaction = this.activeTransaction;\n        const transactionCommitResult = activeTransaction.commit(args);\n        this.$activeTransaction = undefined;\n        const result = this.finalizeCommit(transactionCommitResult);\n        this.baseRevisionStable = undefined;\n        this.isInitialCommit = false;\n        return result;\n    }\n    async propagateAsync(args) {\n        return this.commitAsync(args);\n    }\n    /**\n     * Asynchronously commit the state of the replica. All potentially changed strict identifiers (see [[Identifier.lazy]])\n     * will be calculated during this call.\n     *\n     * This call marks a \"stable\" state of the graph and a transaction border. Using the [[undo]] call one can revert to the previous\n     * state.\n     *\n     * See also [[reject]].\n     *\n     * @param args\n     */\n    async commitAsync(args) {\n        if (this.isCommitting)\n            return this.ongoing;\n        this.isJustCleared = false;\n        this.isCommitting = true;\n        this.baseRevisionStable = this.baseRevision;\n        let result;\n        return this.ongoing = this.ongoing.then(() => {\n            return this.doCommitAsync(args);\n        }).then(res => {\n            result = res;\n            return res;\n        }).finally(() => {\n            this.baseRevisionStable = undefined;\n            this.baseRevisionTentative = undefined;\n            this.isInitialCommit = false;\n            this.isCommitting = false;\n        });\n    }\n    async doCommitAsync(args) {\n        this.unScheduleAutoCommit();\n        const activeTransaction = this.activeTransaction;\n        const transactionResult = await activeTransaction.commitAsync(args);\n        const rejectedDuringCommit = Boolean(activeTransaction.rejectedWith);\n        const prevBaseTentative = this.baseRevisionTentative;\n        if (!rejectedDuringCommit)\n            this.baseRevisionTentative = activeTransaction.candidate;\n        this.$activeTransaction = undefined;\n        await this.finalizeCommitAsync(transactionResult);\n        if (this.isJustCleared)\n            return { rejectedWith: RejectEffect.new({ reason: 'Graph cleared' }) };\n        if (activeTransaction.rejectedWith && !rejectedDuringCommit) {\n            this.baseRevisionTentative = prevBaseTentative;\n            this.$activeTransaction = undefined;\n        }\n        const result = this.finalizeCommit(transactionResult);\n        if (activeTransaction.rejectedWith)\n            activeTransaction.clearRejected();\n        if (this.dirty && !activeTransaction.rejectedWith) {\n            await this.doCommitAsync(args);\n        }\n        return result;\n    }\n    finalizeCommit(transactionResult) {\n        const { revision, entries, transaction } = transactionResult;\n        if (!transaction.rejectedWith) {\n            if (revision.previous !== this.baseRevision)\n                throw new Error('Invalid revisions chain');\n            // dereference all revisions\n            for (const [revision, isReachable] of this.eachReachableRevision()) {\n                if (isReachable)\n                    revision.reachableCount--;\n                revision.referenceCount--;\n            }\n            this.baseRevision = this.topRevision = revision;\n            // activating listeners BEFORE the `markAndSweep`, because in that call, `baseRevision`\n            // might be already merged with previous\n            for (const [identifier, quarkEntry] of entries) {\n                quarkEntry.cleanup();\n                // ignore \"shadowing\" and lazy entries\n                if (quarkEntry.isShadow() || !quarkEntry.hasValue())\n                    continue;\n                const listener = this.listeners.get(identifier);\n                if (listener)\n                    listener.trigger(quarkEntry.getValue());\n            }\n            this.$followingRevision = undefined;\n            this.markAndSweep();\n        }\n        else {\n            // `baseRevisionStable` might be already cleared in the `reject` method of the graph\n            if (this.baseRevisionStable)\n                this.baseRevision = this.baseRevisionStable;\n            this.baseRevisionStable = undefined;\n            this.baseRevisionTentative = undefined;\n        }\n        return { rejectedWith: transaction.rejectedWith };\n    }\n    async finalizeCommitAsync(transactionResult) {\n    }\n    *onComputationCycleHandler(cycle) {\n        const exception = new Error(\"Computation cycle:\\n\" + cycle);\n        //@ts-ignore\n        exception.cycle = cycle;\n        switch (this.onComputationCycle) {\n            case 'ignore':\n                console.log(exception.message);\n                const { requestedEntry, activeEntry } = cycle;\n                // if we ignore the cycle we just continue the calculation with the best possible value\n                return activeEntry.continueCalculation(requestedEntry.proposedValue !== undefined ? requestedEntry.proposedValue : requestedEntry.value);\n            case 'throw':\n                throw exception;\n            case 'reject':\n                this.reject(exception);\n                break;\n            case 'warn':\n                warn(exception);\n                break;\n        }\n    }\n    onComputationCycleHandlerSync(cycle, transaction) {\n        const exception = new Error(\"Computation cycle:\\n\" + cycle);\n        //@ts-ignore\n        exception.cycle = cycle;\n        switch (this.onComputationCycle) {\n            case 'ignore':\n                console.log(exception.message);\n                const { requestedEntry, activeEntry } = cycle;\n                // if we ignore the cycle we just continue the calculation with the best possible value\n                return activeEntry.continueCalculation(requestedEntry.proposedValue !== undefined ? requestedEntry.proposedValue : requestedEntry.value);\n            case 'throw':\n                throw exception;\n            case 'reject':\n                this.reject(exception);\n                break;\n            case 'warn':\n                warn(exception);\n                break;\n        }\n    }\n    scheduleAutoCommit() {\n        // the `&& !this.isCommitting` part was added for the conflicts branch\n        // however, it seems to fail several tests\n        // commenting for now, to be reviewed later\n        if (this.autoCommitTimeoutId === null && !this.isCommitting) {\n            this.autoCommitTimeoutId = setTimeout(this.autoCommitHandler, 10);\n        }\n    }\n    unScheduleAutoCommit() {\n        if (this.autoCommitTimeoutId !== null) {\n            clearTimeout(this.autoCommitTimeoutId);\n            this.autoCommitTimeoutId = null;\n        }\n    }\n    /**\n     * Creates a variable identifier with the given initial value and adds it to graph.\n     *\n     * @param value The initial value. The `undefined` value will be converted to `null`\n     */\n    variable(value) {\n        const variable = VariableC();\n        // always initialize variables with `null`\n        return this.addIdentifier(variable, value === undefined ? null : value);\n    }\n    /**\n     * Creates a named variable identifier with the given initial value and adds it to graph.\n     *\n     * @param name The [[Variable.name]] property of the newly created variable\n     * @param value The initial value. The `undefined` value will be converted to `null`\n     */\n    variableNamed(name, value) {\n        const variable = VariableC({ name });\n        // always initialize variables with `null`\n        return this.addIdentifier(variable, value === undefined ? null : value);\n    }\n    /**\n     * Creates an identifier based on the given calculation function and adds it to this graph. Depending form the type of the function\n     * (sync/generator) either [[CalculatedValueGen]] or [[CalculatedValueSync]] will be created.\n     *\n     * To have full control on the identifier creation, instantiate it yourself and add to graph using the [[ChronoGraph.addIdentifier]] call.\n     *\n     * @param calculation The calculation function of the identifier.\n     * @param context The [[Identifier.context|context]] property of the newly created identifier\n     */\n    identifier(calculation, context) {\n        const identifier = isGeneratorFunction(calculation) ?\n            CalculatedValueGenC({ calculation, context })\n            :\n                CalculatedValueSyncC({ calculation, context });\n        return this.addIdentifier(identifier);\n    }\n    /**\n     * Creates a named identifier based on the given calculation function and adds it to this graph. Depending form the type of the function\n     * (sync/generator) either [[CalculatedValueGen]] or [[CalculatedValueSync]] will be created.\n     *\n     * To have full control on the identifier creation, instantiate it yourself and add to graph using the [[ChronoGraph.addIdentifier]] call.\n     *\n     * @param name The [[Identifier.name]] property of the newly created identifier\n     * @param calculation The calculation function of the identifier.\n     * @param context The [[Identifier.context]] property of the newly created identifier\n     */\n    identifierNamed(name, calculation, context) {\n        const identifier = calculation.constructor.name === 'GeneratorFunction' ?\n            CalculatedValueGenC({ name, calculation, context })\n            :\n                CalculatedValueSyncC({ name, calculation, context });\n        return this.addIdentifier(identifier);\n    }\n    /**\n     * Adds an identifier to this graph. Optionally [[write|writes]] the `proposedValue` to it afterwards.\n     *\n     * @param identifier\n     * @param proposedValue\n     * @param args\n     */\n    addIdentifier(identifier, proposedValue, ...args) {\n        if (this.isCommitting) {\n            if (this.onWriteDuringCommit === 'throw')\n                throw new Error('Adding identifier during commit');\n            else if (this.onWriteDuringCommit === 'warn')\n                warn(new Error('Adding identifier during commit'));\n        }\n        this.activeTransaction.addIdentifier(identifier, proposedValue, ...args);\n        if (this.autoCommit)\n            this.scheduleAutoCommit();\n        return identifier;\n    }\n    /**\n     * Removes an identifier from this graph.\n     *\n     * @param identifier\n     */\n    removeIdentifier(identifier) {\n        if (this.isCommitting) {\n            if (this.onWriteDuringCommit === 'throw')\n                throw new Error('Removing identifier during commit');\n            else if (this.onWriteDuringCommit === 'warn')\n                warn(new Error('Removinfg identifier during commit'));\n        }\n        this.activeTransaction.removeIdentifier(identifier);\n        this.listeners.delete(identifier);\n        if (this.autoCommit)\n            this.scheduleAutoCommit();\n    }\n    /**\n     * Tests, whether this graph has given identifier.\n     *\n     * @param identifier\n     */\n    hasIdentifier(identifier) {\n        return this.activeTransaction.hasIdentifier(identifier);\n    }\n    /**\n     * Writes a value to the given `identifier`.\n     *\n     * @param identifier\n     * @param proposedValue\n     * @param args\n     */\n    write(identifier, proposedValue, ...args) {\n        if (this.isCommitting) {\n            if (this.onWriteDuringCommit === 'throw')\n                throw new Error('Write during commit');\n            else if (this.onWriteDuringCommit === 'warn')\n                warn(new Error('Write during commit'));\n        }\n        this.activeTransaction.write(identifier, proposedValue, ...args);\n        if (this.autoCommit)\n            this.scheduleAutoCommit();\n    }\n    // keep if possible?\n    // pin (identifier : Identifier) : Quark {\n    //     return this.activeTransaction.pin(identifier)\n    // }\n    // Synchronously read the \"previous\", \"stable\" value from the graph. If its a lazy entry, it will be calculated\n    // Synchronous read can not calculate lazy asynchronous identifiers and will throw exception\n    // Lazy identifiers supposed to be \"total\" (or accept repeating observes?)\n    readPrevious(identifier) {\n        return this.activeTransaction.readPrevious(identifier);\n    }\n    // Asynchronously read the \"previous\", \"stable\" value from the graph. If its a lazy entry, it will be calculated\n    // Asynchronous read can calculate both synchornous and asynchronous lazy identifiers.\n    // Lazy identifiers supposed to be \"total\" (or accept repeating observes?)\n    readPreviousAsync(identifier) {\n        return this.activeTransaction.readPreviousAsync(identifier);\n    }\n    /**\n     * Synchronously read the value of the given identifier from the graph.\n     *\n     * Synchronous read can not calculate asynchronous identifiers and will throw exception\n     *\n     * @param identifier\n     */\n    read(identifier) {\n        return this.activeTransaction.read(identifier);\n    }\n    /**\n     * Asynchronously read the value of the given identifier from the graph.\n     *\n     * Asynchronous read can calculate both synchronous and asynchronous identifiers\n     *\n     * @param identifier\n     */\n    readAsync(identifier) {\n        return this.activeTransaction.readAsync(identifier);\n    }\n    /**\n     * Read the value of the identifier either synchronously or asynchronously, depending on its type (see [[Identifier.sync]])\n     *\n     * @param identifier\n     */\n    get(identifier) {\n        return this.activeTransaction.get(identifier);\n    }\n    // // read the identifier value, return the proposed value if no \"current\" value is calculated yet\n    // readDirty<T> (identifier : Identifier<T>) : T {\n    //     return this.activeTransaction.readDirty(identifier)\n    // }\n    //\n    //\n    // // read the identifier value, return the proposed value if no \"current\" value is calculated yet\n    // readDirtyAsync<T> (identifier : Identifier<T>) : Promise<T> {\n    //     return this.activeTransaction.readDirtyAsync(identifier)\n    // }\n    observe(observerFunc, onUpdated) {\n        const identifier = this.addIdentifier(CalculatedValueGen.new({\n            // observers are explicitly eager\n            lazy: false,\n            calculation: observerFunc,\n        }));\n        this.addListener(identifier, onUpdated);\n        return identifier;\n    }\n    observeContext(observerFunc, context, onUpdated) {\n        const identifier = this.addIdentifier(CalculatedValueGen.new({\n            // observers are explicitly eager\n            lazy: false,\n            calculation: observerFunc,\n            context: context,\n        }));\n        this.addListener(identifier, onUpdated);\n        return identifier;\n    }\n    addListener(identifier, onUpdated) {\n        let listener = this.listeners.get(identifier);\n        if (!listener) {\n            listener = Listener.new();\n            this.listeners.set(identifier, listener);\n        }\n        listener.handlers.push(onUpdated);\n    }\n    /**\n     * Revert the replica to the state of previous transaction (marked with the [[commit]] call).\n     *\n     * To enable this feature, you need to opt-in using the [[ChronoGraph.historyLimit|historyLimit]] configuration property.\n     *\n     * Returns boolean, indicating whether the state transition actually happened.\n     */\n    undo() {\n        const baseRevision = this.baseRevision;\n        const previous = baseRevision.previous;\n        if (!previous)\n            return false;\n        this.baseRevision = previous;\n        // note: all unpropagated \"writes\" are lost\n        this.$activeTransaction = undefined;\n        return true;\n    }\n    /**\n     * Advance the replica to the state of next transaction (marked with the [[commit]] call). Only meaningful\n     * if a [[ChronoGraph.undo|undo]] call has been made earlier.\n     *\n     * To enable this feature, you need to opt-in using the [[historyLimit]] configuration property.\n     *\n     * Returns boolean, indicating whether the state transition actually happened.\n     */\n    redo() {\n        const baseRevision = this.baseRevision;\n        if (baseRevision === this.topRevision)\n            return false;\n        const nextRevision = this.followingRevision.get(baseRevision);\n        this.baseRevision = nextRevision;\n        // note: all unpropagated \"writes\" are lost\n        this.$activeTransaction = undefined;\n        return true;\n    }\n    onPropagationProgressNotification(notification) {\n    }\n    [ProposedOrPreviousSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        activeEntry.usedProposedOrPrevious = true;\n        const proposedValue = activeEntry.getProposedValue(transaction);\n        if (proposedValue !== undefined)\n            return proposedValue;\n        // newly added identifier\n        if (!activeEntry.previous)\n            return undefined;\n        const identifier = activeEntry.identifier;\n        if (identifier.lazy) {\n            if (activeEntry.previous.hasValue())\n                return activeEntry.previous.getValue();\n            if (activeEntry.previous.hasProposedValue())\n                return activeEntry.previous.getProposedValue(transaction);\n            return null;\n        }\n        return transaction.readPrevious(activeEntry.identifier);\n    }\n    [RejectSymbol](effect, transaction) {\n        this.reject(effect.reason);\n        return BreakCurrentStackExecution;\n    }\n    [TransactionSymbol](effect, transaction) {\n        return transaction;\n    }\n    [OwnQuarkSymbol](effect, transaction) {\n        return transaction.getActiveEntry();\n    }\n    [OwnIdentifierSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        return activeEntry.identifier;\n    }\n    [WriteSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        if (activeEntry.identifier.lazy)\n            throw new Error('Lazy identifiers can not use `Write` effect');\n        const writeToHigherLevel = effect.identifier.level > activeEntry.identifier.level;\n        if (!writeToHigherLevel)\n            transaction.walkContext.startNewEpoch();\n        transaction.write(effect.identifier, ...effect.proposedArgs);\n        // // transaction.writes.push(effect)\n        //\n        // // const writeTo   = effect.identifier\n        // //\n        // // writeTo.write.call(writeTo.context || writeTo, writeTo, transaction, null, ...effect.proposedArgs)\n        //\n        // transaction.onNewWrite()\n        return writeToHigherLevel ? undefined : BreakCurrentStackExecution;\n    }\n    [WriteSeveralSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        if (activeEntry.identifier.lazy)\n            throw new Error('Lazy identifiers can not use `Write` effect');\n        let writeToHigherLevel = true;\n        // effect.writes.forEach(writeInfo => {\n        effect.writes.forEach(writeInfo => {\n            if (writeInfo.identifier.level <= activeEntry.identifier.level && writeToHigherLevel) {\n                transaction.walkContext.startNewEpoch();\n                writeToHigherLevel = false;\n            }\n            transaction.write(writeInfo.identifier, ...writeInfo.proposedArgs);\n        });\n        // const identifier    = writeInfo.identifier\n        //\n        // identifier.write.call(identifier.context || identifier, identifier, transaction, null, ...writeInfo.proposedArgs)\n        // })\n        // transaction.onNewWrite()\n        return writeToHigherLevel ? undefined : BreakCurrentStackExecution;\n    }\n    [PreviousValueOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        return transaction.readPrevious(source);\n    }\n    [ProposedValueOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        const proposedValue = quark && !quark.isShadow() ? quark.getProposedValue(transaction) : undefined;\n        return proposedValue;\n    }\n    [HasProposedValueSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        return quark ? quark.hasProposedValue() : false;\n    }\n    [HasProposedNotPreviousValueSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        return quark ? quark.hasProposedValue() && !quark.proposedIsPrevious : false;\n    }\n    [ProposedOrPreviousValueOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        return transaction.readProposedOrPrevious(source);\n    }\n    [UnsafeProposedOrPreviousValueOfSymbol](effect, transaction) {\n        return transaction.readProposedOrPrevious(effect.identifier);\n    }\n    [UnsafePreviousValueOfSymbol](effect, transaction) {\n        return transaction.readPrevious(effect.identifier);\n    }\n    [ProposedArgumentsOfSymbol](effect, transaction) {\n        const activeEntry = transaction.getActiveEntry();\n        const source = effect.identifier;\n        transaction.addEdge(source, activeEntry, EdgeTypePast);\n        const quark = transaction.entries.get(source);\n        return quark && !quark.isShadow() ? quark.proposedArguments : undefined;\n    }\n}\n", "import { Base } from \"../class/Base.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This class describes an entity. Entity is simply a collection of [[Field]]s. Entity also may have a parent entity,\n * from which it inherit the fields.\n */\nexport class EntityMeta extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the entity\n         */\n        this.name = undefined;\n        this.ownFields = new Map();\n        this.schema = undefined;\n        this.$skeleton = {};\n        this.$allFields = undefined;\n    }\n    /**\n     * Checks whether the entity has a field with given name (possibly inherited from parent entity).\n     *\n     * @param name\n     */\n    hasField(name) {\n        return this.getField(name) !== undefined;\n    }\n    /**\n     * Returns a field with given name (possibly inherited) or `undefined` if there's none.\n     *\n     * @param name\n     */\n    getField(name) {\n        return this.allFields.get(name);\n    }\n    /**\n     * Adds a field to this entity.\n     *\n     * @param field\n     */\n    addField(field) {\n        const name = field.name;\n        if (!name)\n            throw new Error(`Field must have a name`);\n        if (this.ownFields.has(name))\n            throw new Error(`Field with name [${name}] already exists`);\n        field.entity = this;\n        this.ownFields.set(name, field);\n        return field;\n    }\n    forEachParent(func) {\n        let entity = this;\n        while (entity) {\n            func(entity);\n            entity = entity.parentEntity;\n        }\n    }\n    get allFields() {\n        if (this.$allFields !== undefined)\n            return this.$allFields;\n        const allFields = new Map();\n        const visited = new Set();\n        this.forEachParent(entity => {\n            entity.ownFields.forEach((field, name) => {\n                if (!visited.has(name)) {\n                    visited.add(name);\n                    allFields.set(name, field);\n                }\n            });\n        });\n        return this.$allFields = allFields;\n    }\n    /**\n     * Iterator for all fields of this entity (including inherited).\n     *\n     * @param func\n     */\n    forEachField(func) {\n        this.allFields.forEach(func);\n    }\n}\n", "import { ChronoGraph } from \"../chrono/Graph.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nexport var ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"Current\"] = 0] = \"Current\";\n    ReadMode[ReadMode[\"Previous\"] = 1] = \"Previous\";\n    ReadMode[ReadMode[\"ProposedOrPrevious\"] = 2] = \"ProposedOrPrevious\";\n    ReadMode[ReadMode[\"CurrentOrProposedOrPrevious\"] = 3] = \"CurrentOrProposedOrPrevious\";\n})(ReadMode || (ReadMode = {}));\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Reactive graph, operating on the set of entities (see [[Entity]] and [[EntityMeta]]), each having a set of fields (see [[Field]]).\n *\n * Entities are mapped to JS classes and fields - to their properties, decorated with [[field]].\n *\n * The calculation function for some field can be mapped to the class method, using the [[calculate]] decorator.\n *\n * An example of usage:\n *\n * ```ts\n * class Author extends Entity.mix(Base) {\n *     @field()\n *     firstName       : string\n *     @field()\n *     lastName        : string\n *     @field()\n *     fullName        : string\n *\n *     @calculate('fullName')\n *     calculateFullName () : string {\n *         return this.firstName + ' ' + this.lastName\n *     }\n * }\n * ```\n */\nexport class Replica extends Mixin([ChronoGraph], (base) => class Replica extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Replica re-defines the default value of the `autoCommit` property to `true`.\n         */\n        this.autoCommit = true;\n        this.readMode = ReadMode.Current;\n    }\n    /**\n     * Add entity instance to the replica\n     *\n     * @param entity\n     */\n    addEntity(entity) {\n        entity.enterGraph(this);\n    }\n    /**\n     * Add several entity instances to the replica\n     *\n     * @param entity\n     */\n    addEntities(entities) {\n        entities.forEach(entity => this.addEntity(entity));\n    }\n    /**\n     * Remove entity instance from the replica\n     *\n     * @param entity\n     */\n    removeEntity(entity) {\n        entity.leaveGraph(this);\n    }\n    /**\n     * Remove several entity instances from the replica\n     *\n     * @param entity\n     */\n    removeEntities(entities) {\n        entities.forEach(entity => this.removeEntity(entity));\n    }\n}) {\n}\n", "import { CalculatedValueGen, CalculatedValueSync, Identifier, Variable } from \"../chrono/Identifier.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { ReadMode } from \"./Replica.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent a field of the entity. Requires the [[Identifier]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class FieldIdentifier extends Mixin([Identifier], (base) => class FieldIdentifier extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Reference to the [[Field]] this identifier represents\n         */\n        this.field = undefined;\n        /**\n         * Reference to the [[Entity]] this identifier represents\n         */\n        this.self = undefined;\n        // temp storage for value for the phase, when identifier is created, but has not joined any graph\n        // is cleared during the 1st join to the graph\n        this.DATA = undefined;\n    }\n    // standaloneQuark     : InstanceType<this[ 'quarkClass' ]>\n    // readFromGraphDirtySync (graph : Checkout) {\n    //     if (graph)\n    //         return graph.readDirty(this)\n    //     else\n    //         return this.DATA\n    // }\n    // returns the value itself if there were no affecting writes for it\n    // otherwise - promise\n    getFromGraph(graph) {\n        if (graph) {\n            if (graph.readMode === ReadMode.Current)\n                return graph.get(this);\n            if (graph.readMode === ReadMode.Previous)\n                return graph.activeTransaction.readPrevious(this);\n            if (graph.readMode === ReadMode.ProposedOrPrevious)\n                graph.activeTransaction.readProposedOrPrevious(this);\n            return graph.activeTransaction.readCurrentOrProposedOrPrevious(this);\n        }\n        else\n            return this.DATA;\n    }\n    readFromGraph(graph) {\n        if (graph)\n            return graph.read(this);\n        else\n            return this.DATA;\n    }\n    writeToGraph(graph, proposedValue, ...args) {\n        if (graph)\n            graph.write(this, proposedValue, ...args);\n        else\n            this.DATA = proposedValue;\n    }\n    leaveGraph(graph) {\n        const entry = graph.activeTransaction.getLatestStableEntryFor(this);\n        if (entry)\n            this.DATA = entry.getValue();\n        super.leaveGraph(graph);\n    }\n    toString() {\n        return this.name;\n    }\n}) {\n}\nexport class MinimalFieldIdentifierSync extends FieldIdentifier.mix(CalculatedValueSync) {\n}\nexport class MinimalFieldIdentifierGen extends FieldIdentifier.mix(CalculatedValueGen) {\n}\nexport class MinimalFieldVariable extends FieldIdentifier.mix(Variable) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent an entity as a whole. Requires the [[Identifier]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class EntityIdentifier extends Mixin([Identifier], (base) => class EntityIdentifier extends base {\n    constructor() {\n        super(...arguments);\n        /**\n         * [[EntityMeta]] instance of the entity this identifier represents\n         */\n        this.entity = undefined;\n        /**\n         * Reference to the [[Entity]] this identifier represents\n         */\n        this.self = undefined;\n    }\n    // entity atom is considered changed if any of its incoming atoms has changed\n    // this just means if it's calculation method has been called, it should always\n    // assign a new value\n    equality() {\n        return false;\n    }\n    toString() {\n        return `Entity identifier [${this.self}]`;\n    }\n}) {\n}\nexport class MinimalEntityIdentifier extends EntityIdentifier.mix(CalculatedValueGen) {\n}\n", "import { Meta } from \"../chrono/Identifier.js\";\nimport { MinimalFieldIdentifierGen, MinimalFieldIdentifierSync, MinimalFieldVariable } from \"../replica/Identifier.js\";\nimport { isGeneratorFunction } from \"../util/Helpers.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This class describes a field of some [[EntityMeta]].\n */\nexport class Field extends Meta {\n    constructor() {\n        super(...arguments);\n        /**\n         * Boolean flag, indicating whether this field should be persisted\n         */\n        this.persistent = true;\n    }\n    getIdentifierClass(calculationFunction) {\n        if (this.identifierCls)\n            return this.identifierCls;\n        if (!calculationFunction)\n            return MinimalFieldVariable;\n        return isGeneratorFunction(calculationFunction) ? MinimalFieldIdentifierGen : MinimalFieldIdentifierSync;\n    }\n}\n", "import { CommitZero } from \"../chrono/Graph.js\";\nimport { Identifier } from \"../chrono/Identifier.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { DEBUG, debug, SourceLinePoint } from \"../environment/Debug.js\";\nimport { runGeneratorSyncWithEffect } from \"../primitives/Calculation.js\";\nimport { EntityMeta } from \"../schema/EntityMeta.js\";\nimport { Field } from \"../schema/Field.js\";\nimport { defineProperty, uppercaseFirst } from \"../util/Helpers.js\";\nimport { MinimalEntityIdentifier } from \"./Identifier.js\";\nconst isEntityMarker = Symbol('isEntity');\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Entity [[Mixin|mixin]]. When applied to some base class (recommended one is [[Base]]), turns it into entity.\n * Entity may have several fields, which are properties decorated with [[field]] decorator.\n *\n * To apply this mixin use the `Entity.mix` property, which represents the mixin lambda.\n *\n * Another decorator, [[calculate]], marks the method, that will be used to calculate the value of field.\n *\n * Example:\n *\n * ```ts\n * class Author extends Entity.mix(Base) {\n *     @field()\n *     firstName       : string\n *     @field()\n *     lastName        : string\n *     @field()\n *     fullName        : string\n *\n *     @calculate('fullName')\n *     calculateFullName () : string {\n *         return this.firstName + ' ' + this.lastName\n *     }\n * }\n * ```\n *\n */\nexport class Entity extends Mixin([], (base) => {\n    class Entity extends base {\n        // marker in the prototype to identify whether the parent class is Entity mixin itself\n        // it is not used for `instanceof` purposes and not be confused with the [MixinInstanceOfProperty]\n        // (though it is possible to use MixinInstanceOfProperty for this purpose, that would require to\n        // make it public\n        [isEntityMarker]() { }\n        /**\n         * An [[EntityMeta]] instance, representing the \"meta\" information about the entity class. It is shared among all instances\n         * of the class.\n         */\n        get $entity() {\n            // this will lazily create an EntityData instance in the prototype\n            return createEntityOnPrototype(this.constructor.prototype);\n        }\n        /**\n         * An object, which properties corresponds to the ChronoGraph [[Identifier]]s, created for every field.\n         *\n         * For example:\n         *\n         * ```ts\n         * class Author extends Entity.mix(Base) {\n         *     @field()\n         *     firstName       : string\n         *     @field()\n         *     lastName        : string\n         * }\n         *\n         * const author = Author.new()\n         *\n         * // identifier for the field `firstName`\n         * author.$.firstName\n         *\n         * const firstName = replica.read(author.$.firstName)\n         * ```\n         */\n        get $() {\n            const $ = {};\n            this.$entity.forEachField((field, name) => {\n                $[name] = this.createFieldIdentifier(field);\n            });\n            if (DEBUG) {\n                const proxy = new Proxy($, {\n                    get(entity, property, receiver) {\n                        if (!entity[property])\n                            debug(new Error(`Attempt to read a missing field ${String(property)} on ${entity}`));\n                        entity[property].SOURCE_POINT = SourceLinePoint.fromThisCall();\n                        return entity[property];\n                    }\n                });\n                return defineProperty(this, '$', proxy);\n            }\n            else {\n                return defineProperty(this, '$', $);\n            }\n        }\n        /**\n         * A graph identifier, that represents the whole entity.\n         */\n        get $$() {\n            return defineProperty(this, '$$', MinimalEntityIdentifier.new({\n                name: this.$entityName,\n                entity: this.$entity,\n                calculation: this.calculateSelf,\n                context: this,\n                self: this,\n            }));\n        }\n        get $entityName() {\n            return this.constructor.name || this.$entity.name;\n        }\n        *calculateSelf() {\n            return this;\n        }\n        createFieldIdentifier(field) {\n            const name = field.name;\n            const entity = this.$entity;\n            const constructor = this.constructor;\n            const skeleton = entity.$skeleton;\n            if (!skeleton[name])\n                skeleton[name] = constructor.getIdentifierTemplateClass(this, field);\n            const identifier = new skeleton[name]();\n            identifier.context = this;\n            identifier.self = this;\n            identifier.name = `${this.$$.name}.$.${field.name}`;\n            return identifier;\n        }\n        forEachFieldIdentifier(func) {\n            this.$entity.forEachField((field, name) => func(this.$[name], name, field));\n        }\n        /**\n         * This method is called when entity is added to some replica.\n         *\n         * @param replica\n         */\n        enterGraph(replica) {\n            if (this.graph)\n                throw new Error('Already entered replica');\n            this.graph = replica;\n            replica.addIdentifier(this.$$);\n            this.$entity.forEachField((field, name) => {\n                const identifier = this.$[name];\n                replica.addIdentifier(identifier, identifier.DATA);\n                identifier.DATA = undefined;\n            });\n        }\n        /**\n         * This method is called when entity is removed from the replica it's been added to.\n         */\n        leaveGraph(graph) {\n            const ownGraph = this.graph;\n            const removeFrom = graph || ownGraph;\n            if (!removeFrom)\n                return;\n            this.$entity.forEachField((field, name) => removeFrom.removeIdentifier(this.$[name]));\n            removeFrom.removeIdentifier(this.$$);\n            if (removeFrom === ownGraph)\n                this.graph = undefined;\n        }\n        // isPropagating () {\n        //     return this.getGraph().isPropagating\n        // }\n        propagate(arg) {\n            return this.commit(arg);\n        }\n        /**\n         * This is a convenience method, that just delegates to the [[ChronoGraph.commit]] method of this entity's graph.\n         *\n         * If there's no graph (entity has not been added to any replica) a [[CommitZero]] constant will be returned.\n         */\n        commit(arg) {\n            const graph = this.graph;\n            if (!graph)\n                return CommitZero;\n            return graph.commit(arg);\n        }\n        async propagateAsync() {\n            return this.commitAsync();\n        }\n        /**\n         * This is a convenience method, that just delegates to the [[ChronoGraph.commitAsync]] method of this entity's graph.\n         *\n         * If there's no graph (entity has not been added to any replica) a resolved promise with [[CommitZero]] constant will be returned.\n         */\n        async commitAsync(arg) {\n            const graph = this.graph;\n            if (!graph)\n                return Promise.resolve(CommitZero);\n            return graph.commitAsync(arg);\n        }\n        /**\n         * An [[EntityMeta]] instance, representing the \"meta\" information about the entity class. It is shared among all instances\n         * of the class.\n         */\n        static get $entity() {\n            return ensureEntityOnPrototype(this.prototype);\n        }\n        static getIdentifierTemplateClass(me, field) {\n            const name = field.name;\n            const config = {\n                name: `${me.$$.name}.$.${name}`,\n                field: field\n            };\n            //------------------\n            if (field.hasOwnProperty('sync'))\n                config.sync = field.sync;\n            if (field.hasOwnProperty('lazy'))\n                config.lazy = field.lazy;\n            if (field.hasOwnProperty('equality'))\n                config.equality = field.equality;\n            //------------------\n            const calculationFunction = me.$calculations && me[me.$calculations[name]];\n            if (calculationFunction)\n                config.calculation = calculationFunction;\n            //------------------\n            const writeFunction = me.$writes && me[me.$writes[name]];\n            if (writeFunction)\n                config.write = writeFunction;\n            //------------------\n            const buildProposedFunction = me.$buildProposed && me[me.$buildProposed[name]];\n            if (buildProposedFunction) {\n                config.buildProposedValue = buildProposedFunction;\n                config.proposedValueIsBuilt = true;\n            }\n            //------------------\n            const template = field.getIdentifierClass(calculationFunction).new(config);\n            const TemplateClass = function () { };\n            TemplateClass.prototype = template;\n            return TemplateClass;\n        }\n        // unfortunately, the better typing:\n        // run <Name extends AllowedNames<this, AnyFunction>> (methodName : Name, ...args : Parameters<this[ Name ]>)\n        //     : ReturnType<this[ Name ]> extends CalculationIterator<infer Res> ? Res : ReturnType<this[ Name ]>\n        // yields \"types are exceedingly long and possibly infinite on the application side\n        run(methodName, ...args) {\n            const onEffect = (effect) => {\n                if (effect instanceof Identifier)\n                    return this.graph.read(effect);\n                throw new Error(\"Helper methods can not yield effects during computation\");\n            };\n            const transaction = this.graph.activeTransaction;\n            const prevActiveStack = transaction.activeStack;\n            transaction.activeStack = [];\n            const res = runGeneratorSyncWithEffect(onEffect, this[methodName], args, this);\n            transaction.activeStack = prevActiveStack;\n            return res;\n        }\n        static createPropertyAccessorsFor(fieldName) {\n            // idea is to indicate to the v8, that `propertyKey` is a constant and thus\n            // it can optimize access by it\n            const propertyKey = fieldName;\n            const target = this.prototype;\n            Object.defineProperty(target, propertyKey, {\n                get: function () {\n                    return this.$[propertyKey].getFromGraph(this.graph);\n                },\n                set: function (value) {\n                    this.$[propertyKey].writeToGraph(this.graph, value);\n                }\n            });\n        }\n        static createMethodAccessorsFor(fieldName) {\n            // idea is to indicate to the v8, that `propertyKey` is a constant and thus\n            // it can optimize access by it\n            const propertyKey = fieldName;\n            const target = this.prototype;\n            const getterFnName = `get${uppercaseFirst(propertyKey)}`;\n            const setterFnName = `set${uppercaseFirst(propertyKey)}`;\n            const putterFnName = `put${uppercaseFirst(propertyKey)}`;\n            if (!(getterFnName in target)) {\n                target[getterFnName] = function () {\n                    return this.$[propertyKey].getFromGraph(this.graph);\n                };\n            }\n            if (!(setterFnName in target)) {\n                target[setterFnName] = function (value, ...args) {\n                    this.$[propertyKey].writeToGraph(this.graph, value, ...args);\n                    return this.graph\n                        ?\n                            (this.graph.autoCommitMode === 'sync' ? this.graph.commit() : this.graph.commitAsync())\n                        :\n                            Promise.resolve(CommitZero);\n                };\n            }\n            if (!(putterFnName in target)) {\n                target[putterFnName] = function (value, ...args) {\n                    this.$[propertyKey].writeToGraph(this.graph, value, ...args);\n                };\n            }\n        }\n    }\n    return Entity;\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport const createEntityOnPrototype = (proto) => {\n    let parent = Object.getPrototypeOf(proto);\n    // the `hasOwnProperty` condition will be `true` for the `Entity` mixin itself\n    // if the parent is `Entity` mixin, then this is a top-level entity\n    return defineProperty(proto, '$entity', EntityMeta.new({\n        parentEntity: parent.hasOwnProperty(isEntityMarker) ? null : parent.$entity,\n        name: proto.constructor.name\n    }));\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const ensureEntityOnPrototype = (proto) => {\n    if (!proto.hasOwnProperty('$entity'))\n        createEntityOnPrototype(proto);\n    return proto.$entity;\n};\n/*\n * The \"generic\" field decorator, in the sense, that it allows specifying both field config and field class.\n * This means it can create any field instance.\n */\nexport const generic_field = (fieldConfig, fieldCls = Field) => {\n    return function (target, fieldName) {\n        const entity = ensureEntityOnPrototype(target);\n        const field = entity.addField(fieldCls.new(Object.assign(fieldConfig || {}, {\n            name: fieldName\n        })));\n        const cons = target.constructor;\n        cons.createPropertyAccessorsFor(fieldName);\n        cons.createMethodAccessorsFor(fieldName);\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Field decorator. The type signature is:\n *\n * ```ts\n * field : <T extends typeof Field = typeof Field> (fieldConfig? : Partial<InstanceType<T>>, fieldCls : T | typeof Field = Field) => PropertyDecorator\n * ```\n * Its a function, that accepts field config object and optionally a field class (default is [[Field]]) and returns a property decorator.\n *\n * Example:\n *\n * ```ts\n * const ignoreCaseCompare = (a : string, b : string) : boolean => a.toUpperCase() === b.toUpperCase()\n *\n * class MyField extends Field {}\n *\n * class Author extends Entity.mix(Base) {\n *     @field({ equality : ignoreCaseCompare })\n *     firstName       : string\n *\n *     @field({ lazy : true }, MyField)\n *     lastName       : string\n * }\n * ```\n *\n * For every field, there are generated get and set accessors, with which you can read/write the data:\n *\n * ```ts\n * const author     = Author.new({ firstName : 'Mark' })\n *\n * author.firstName // Mark\n * author.lastName  = 'Twain'\n * ```\n *\n * The getters are basically using [[Replica.get]] and setters [[Replica.write]].\n *\n * Note, that if the identifier is asynchronous, reading from it will return a promise. But, immediately after the [[Replica.commit]] call, getter will return\n * plain value. This is a compromise between the convenience and correctness and this behavior may change (or made configurable) in the future.\n *\n * Additionally to the accessors, the getter and setter methods are generated. The getter method's name is formed as `get` followed by the field name\n * with upper-cased first letter. The setter's name is formed in the same way, with `set` prefix.\n *\n * The getter method is an exact equivalent of the get accessor. The setter method, in addition to data write, immediately after that\n * performs a call to [[Replica.commit]] (or [[Replica.commitAsync]], depending from the [[Replica.autoCommitMode]] option)\n * and return its result.\n *\n * ```ts\n * const author     = Author.new({ firstName : 'Mark' })\n *\n * author.getFirstName() // Mark\n * await author.setLastName('Twain') // issues asynchronous commit\n * ```\n */\nexport const field = generic_field;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Decorator for the method, that calculates a value of some field\n *\n * ```ts\n *\n * @entity()\n * class Author extends Entity.mix(Base) {\n *     @field()\n *     firstName       : string\n *     @field()\n *     lastName        : string\n *     @field()\n *     fullName        : string\n *\n *     @calculate('fullName')\n *     calculateFullName () : string {\n *         return this.firstName + ' ' + this.lastName\n *     }\n * }\n * ```\n *\n * @param fieldName The name of the field the decorated method should be \"tied\" to.\n */\nexport const calculate = function (fieldName) {\n    // `target` will be a prototype of the class with Entity mixin\n    return function (target, propertyKey, _descriptor) {\n        ensureEntityOnPrototype(target);\n        let calculations;\n        if (!target.$calculations) {\n            calculations = target.$calculations = {};\n        }\n        else {\n            if (!target.hasOwnProperty('$calculations')) {\n                calculations = target.$calculations = Object.create(target.$calculations);\n            }\n            else\n                calculations = target.$calculations;\n        }\n        calculations[fieldName] = propertyKey;\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const write = function (fieldName) {\n    // `target` will be a prototype of the class with Entity mixin\n    return function (target, propertyKey, _descriptor) {\n        ensureEntityOnPrototype(target);\n        let writes;\n        if (!target.$writes) {\n            writes = target.$writes = {};\n        }\n        else {\n            if (!target.hasOwnProperty('$writes')) {\n                writes = target.$writes = Object.create(target.$writes);\n            }\n            else\n                writes = target.$writes;\n        }\n        writes[fieldName] = propertyKey;\n    };\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport const build_proposed = function (fieldName) {\n    // `target` will be a prototype of the class with Entity mixin\n    return function (target, propertyKey, _descriptor) {\n        ensureEntityOnPrototype(target);\n        let buildProposed;\n        if (!target.$buildProposed) {\n            buildProposed = target.$buildProposed = {};\n        }\n        else {\n            if (!target.hasOwnProperty('$buildProposed')) {\n                buildProposed = target.$buildProposed = Object.create(target.$buildProposed);\n            }\n            else\n                buildProposed = target.$buildProposed;\n        }\n        buildProposed[fieldName] = propertyKey;\n    };\n};\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { CalculatedValueSync, Levels, QuarkSync } from \"../chrono/Identifier.js\";\nimport { isInstanceOf, Mixin } from \"../class/Mixin.js\";\nimport { Field } from \"../schema/Field.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\nimport { Entity, generic_field } from \"./Entity.js\";\nimport { FieldIdentifier } from \"./Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent a reference field of the entity. Requires the [[Field]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class ReferenceField extends Mixin([Field], (base) => class ReferenceField extends base {\n    constructor() {\n        super(...arguments);\n        this.identifierCls = MinimalReferenceIdentifier;\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Specialized version of the [field](_replica_entity_.html#field) decorator, which should be used to mark the references.\n * All it does is replace the default value of the second argument to the [[ReferenceField]].\n *\n * ```ts\n * class Author extends Person {\n *     @bucket()\n *     books           : Set<Book>\n * }\n *\n * class Book extends Entity.mix(Base) {\n *     @reference({ bucket : 'books' })\n *     writtenBy       : Author\n * }\n * ```\n *\n * @param fieldConfig Object with the configuration properties\n * @param fieldCls Optional. Default value has been changed to [[ReferenceField]]\n */\nexport const reference = (fieldConfig, fieldCls = ReferenceField) => generic_field(fieldConfig, fieldCls);\n//---------------------------------------------------------------------------------------------------------------------\nexport class ReferenceIdentifier extends Mixin([FieldIdentifier], (base) => {\n    class ReferenceIdentifier extends base {\n        constructor() {\n            super(...arguments);\n            this.field = undefined;\n            this.proposedValueIsBuilt = true;\n        }\n        hasBucket() {\n            return Boolean(this.field.bucket);\n        }\n        getBucket(entity) {\n            return entity.$[this.field.bucket];\n        }\n        buildProposedValue(me, quark, transaction) {\n            const proposedValue = quark.proposedValue;\n            if (proposedValue === null)\n                return null;\n            const value = isInstanceOf(proposedValue, Entity) ? proposedValue : me.resolve(proposedValue);\n            if (value && me.hasBucket()) {\n                me.getBucket(value).addToBucket(transaction, me.self);\n            }\n            return value;\n        }\n        resolve(locator) {\n            const resolver = this.field.resolver;\n            return resolver ? resolver.call(this.self, locator) : null;\n        }\n        enterGraph(graph) {\n            if (this.hasBucket()) {\n                const value = graph.activeTransaction.readProposedOrPrevious(this);\n                if (value instanceof Entity) {\n                    // should probably involve `touchInvalidate` here\n                    this.getBucket(value).addToBucket(graph.activeTransaction, this.self);\n                }\n            }\n            super.enterGraph(graph);\n        }\n        leaveGraph(graph) {\n            if (this.hasBucket()) {\n                // here we only need to remove from the \"previous\", \"stable\" bucket, because\n                // the calculation for the removed reference won't be called - the possible `proposedValue` of reference will be ignored\n                const value = graph.activeTransaction.readProposedOrPrevious(this);\n                if (value instanceof Entity) {\n                    this.getBucket(value).removeFromBucket(graph.activeTransaction, this.self);\n                }\n            }\n            super.leaveGraph(graph);\n        }\n        write(me, transaction, q, proposedValue, ...args) {\n            const quark = q || transaction.acquireQuarkIfExists(me);\n            if (me.hasBucket()) {\n                if (quark) {\n                    const prevValue = quark.getValue();\n                    if (prevValue instanceof Entity) {\n                        me.getBucket(prevValue).removeFromBucket(transaction, me.self);\n                    }\n                }\n                else if (transaction.baseRevision.hasIdentifier(me)) {\n                    const value = transaction.readPrevious(me);\n                    if (value instanceof Entity) {\n                        me.getBucket(value).removeFromBucket(transaction, me.self);\n                    }\n                }\n            }\n            // we pass the `q` to super and not `quark`, because we don't do `getWriteTarget` (which increment the epoch)\n            // but only `acquireQuarkIfExists` (which does not)\n            super.write(me, transaction, q, proposedValue);\n        }\n    }\n    __decorate([\n        prototypeValue(Levels.DependsOnlyOnUserInput)\n    ], ReferenceIdentifier.prototype, \"level\", void 0);\n    __decorate([\n        prototypeValue(QuarkSync)\n    ], ReferenceIdentifier.prototype, \"quarkClass\", void 0);\n    return ReferenceIdentifier;\n}) {\n}\nexport class MinimalReferenceIdentifier extends ReferenceIdentifier.mix(FieldIdentifier.mix(CalculatedValueSync)) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { CalculatedValueSync, Levels, QuarkSync } from \"../chrono/Identifier.js\";\nimport { Quark, TombStone } from \"../chrono/Quark.js\";\nimport { Mixin } from \"../class/Mixin.js\";\nimport { Field } from \"../schema/Field.js\";\nimport { prototypeValue } from \"../util/Helpers.js\";\nimport { generic_field } from \"./Entity.js\";\nimport { FieldIdentifier } from \"./Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Mixin, for the identifier that represent a reference bucket field of the entity. Requires the [[Field]] (or its subclass)\n * as a base class. See more about mixins: [[Mixin]]\n */\nexport class ReferenceBucketField extends Mixin([Field], (base) => class ReferenceBucketField extends base {\n    constructor() {\n        super(...arguments);\n        this.persistent = false;\n        this.identifierCls = MinimalReferenceBucketIdentifier;\n        // see comment for `ReferenceBucketIdentifier` declaration\n        // identifierCls       : FieldIdentifierConstructor    = ReferenceBucketIdentifier\n    }\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Specialized version of the [field](_replica_entity_.html#field) decorator, which should be used to mark the reference buckets.\n * All it does is replace the default value of the second argument to the [[ReferenceBucketField]].\n *\n * ```ts\n * class Author extends Person {\n *     @bucket()\n *     books           : Set<Book>\n * }\n *\n * class Book extends Entity.mix(Base) {\n *     @reference({ bucket : 'books' })\n *     writtenBy       : Author\n * }\n * ```\n *\n * @param fieldConfig Object with the field configuration properties\n * @param fieldCls Optional. Default value has been changed to [[ReferenceBucketField]]\n */\nexport const bucket = (fieldConfig, fieldCls = ReferenceBucketField) => generic_field(fieldConfig, fieldCls);\nvar BucketMutationType;\n(function (BucketMutationType) {\n    BucketMutationType[\"Add\"] = \"Add\";\n    BucketMutationType[\"Remove\"] = \"Remove\";\n})(BucketMutationType || (BucketMutationType = {}));\n//---------------------------------------------------------------------------------------------------------------------\nexport class ReferenceBucketQuark extends Mixin([Quark], (base) => class ReferenceBucketQuark extends base {\n    constructor() {\n        super(...arguments);\n        this.mutations = [];\n        this.previousValue = undefined;\n    }\n    hasProposedValueInner() {\n        return this.mutations.length > 0;\n    }\n}) {\n}\nexport const MinimalReferenceBucketQuark = ReferenceBucketQuark.mix(QuarkSync);\n//---------------------------------------------------------------------------------------------------------------------\nexport class ReferenceBucketIdentifier extends Mixin([FieldIdentifier], (base) => {\n    // Base class mismatch - should allow subclasses for base class requirements\n    // [ FieldIdentifier, CalculatedValueSync ],\n    // (base : AnyConstructor<FieldIdentifier & CalculatedValueSync, typeof FieldIdentifier & typeof CalculatedValueSync>) => {\n    class ReferenceBucketIdentifier extends base {\n        constructor() {\n            super(...arguments);\n            this.proposedValueIsBuilt = true;\n        }\n        addToBucket(transaction, entity) {\n            const quark = transaction.getWriteTarget(this);\n            quark.mutations.push({ type: BucketMutationType.Add, entity });\n            const baseRevision = transaction.baseRevision;\n            if (!quark.previousValue && baseRevision.hasIdentifier(this))\n                quark.previousValue = transaction.readPrevious(this);\n        }\n        removeFromBucket(transaction, entity) {\n            const preQuark = transaction.entries.get(this);\n            // if bucket is already removed - no need to remove from it\n            if (preQuark && preQuark.getValue() === TombStone)\n                return;\n            const quark = transaction.getWriteTarget(this);\n            quark.mutations.push({ type: BucketMutationType.Remove, entity });\n            const baseRevision = transaction.baseRevision;\n            if (!quark.previousValue && baseRevision.hasIdentifier(this))\n                quark.previousValue = transaction.readPrevious(this);\n        }\n        buildProposedValue(me, quarkArg, transaction) {\n            const quark = quarkArg;\n            const newValue = new Set(quark.previousValue);\n            for (let i = 0; i < quark.mutations.length; i++) {\n                const { type, entity } = quark.mutations[i];\n                if (type === BucketMutationType.Remove) {\n                    newValue.delete(entity);\n                }\n                else if (type === BucketMutationType.Add) {\n                    newValue.add(entity);\n                }\n            }\n            return newValue;\n        }\n        leaveGraph(graph) {\n            super.leaveGraph(graph);\n            this.DATA = undefined;\n        }\n    }\n    __decorate([\n        prototypeValue(Levels.DependsOnlyOnDependsOnlyOnUserInput)\n    ], ReferenceBucketIdentifier.prototype, \"level\", void 0);\n    __decorate([\n        prototypeValue(MinimalReferenceBucketQuark)\n    ], ReferenceBucketIdentifier.prototype, \"quarkClass\", void 0);\n    return ReferenceBucketIdentifier;\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class MinimalReferenceBucketIdentifier extends ReferenceBucketIdentifier.mix(FieldIdentifier.mix(CalculatedValueSync)) {\n}\n// export class MinimalReferenceBucketIdentifier extends ReferenceBucketIdentifier.derive(CalculatedValueSync) {}\n", "import { Base } from \"../class/Base.js\";\nimport { ensureEntityOnPrototype } from \"../replica/Entity.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This class describes a schema. Schemas are not used yet in ChronoGraph.\n *\n * Schema is just a collection of entities ([[EntityMeta]])\n */\nexport class Schema extends Base {\n    constructor() {\n        super(...arguments);\n        this.entities = new Map();\n    }\n    /**\n     * Checks whether the schema has an entity with the given name.\n     *\n     * @param name\n     */\n    hasEntity(name) {\n        return this.entities.has(name);\n    }\n    /**\n     * Returns an entity with the given name or `undefined` if there's no such in this schema\n     *\n     * @param name\n     */\n    getEntity(name) {\n        return this.entities.get(name);\n    }\n    /**\n     * Adds an entity to the schema.\n     * @param entity\n     */\n    addEntity(entity) {\n        const name = entity.name;\n        if (!name)\n            throw new Error(`Entity must have a name`);\n        if (this.hasEntity(name))\n            throw new Error(`Entity with name [${String(name)}] already exists`);\n        entity.schema = this;\n        this.entities.set(name, entity);\n        return entity;\n    }\n    /**\n     * Returns a class decorator which can be used to decorate classes as entities.\n     */\n    getEntityDecorator() {\n        // @ts-ignore : https://github.com/Microsoft/TypeScript/issues/29828\n        return (target) => {\n            const entity = entityDecoratorBody(target);\n            this.addEntity(entity);\n            return target;\n        };\n    }\n}\nexport const entityDecoratorBody = (target) => {\n    const name = target.name;\n    if (!name)\n        throw new Error(`Can't add entity - the target class has no name`);\n    return ensureEntityOnPrototype(target.prototype);\n};\n/**\n * Entity decorator. It is required to be applied only if entity declares no field.\n * If record declares any field, there no strict need to apply this decorator.\n * Its better to do this anyway, for consistency.\n *\n * ```ts\n * @entity()\n * class Author extends Entity.mix(Base) {\n * }\n *\n * @entity()\n * class SpecialAuthor extends Author {\n * }\n * ```\n */\nexport const entity = () => {\n    // @ts-ignore : https://github.com/Microsoft/TypeScript/issues/29828\n    return (target) => {\n        entityDecoratorBody(target);\n        return target;\n    };\n};\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { TombStone } from \"../../ChronoGraph/chrono/Quark.js\";\nimport { isInstanceOf, Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { Entity, generic_field } from \"../../ChronoGraph/replica/Entity.js\";\nimport { FieldIdentifier, MinimalFieldIdentifierGen, MinimalFieldIdentifierSync, MinimalFieldVariable } from \"../../ChronoGraph/replica/Identifier.js\";\nimport { ReferenceField, ReferenceIdentifier } from \"../../ChronoGraph/replica/Reference.js\";\nimport { ReferenceBucketField, ReferenceBucketIdentifier } from \"../../ChronoGraph/replica/ReferenceBucket.js\";\nimport { ReadMode } from \"../../ChronoGraph/replica/Replica.js\";\nimport { Field } from \"../../ChronoGraph/schema/Field.js\";\nimport { isGeneratorFunction, prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport DateHelper from \"../../Core/helper/DateHelper.js\";\nimport { QuarkSync } from \"../../ChronoGraph/chrono/Identifier.js\";\nexport const isSerializableEqual = function (oldValue, newValue) {\n    return oldValue === newValue ||\n        (newValue?.isBase ? this.serialize(newValue) : newValue) === (oldValue?.isBase ? this.serialize(oldValue) : oldValue);\n};\n//---------------------------------------------------------------------------------------------------------------------\nexport class ModelField extends Field {\n    constructor() {\n        super(...arguments);\n        this.modelFieldConfig = {};\n    }\n    getIdentifierClass(calculationFunction) {\n        if (this.identifierCls)\n            return this.identifierCls;\n        if (!calculationFunction)\n            return MinimalChronoModelFieldVariable;\n        return isGeneratorFunction(calculationFunction) ? MinimalChronoModelFieldIdentifierGen : MinimalChronoModelFieldIdentifierSync;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class ModelReferenceField extends ReferenceField.mix(ModelField) {\n    constructor() {\n        super(...arguments);\n        this.identifierCls = ChronoModelReferenceFieldIdentifier;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n// it seems we don't need the buckets as Core fields, the `ModelBucketField` can be removed completely\nexport class ModelBucketField extends ReferenceBucketField.mix(Field) {\n    constructor() {\n        super(...arguments);\n        this.identifierCls = ChronoModelReferenceBucketFieldIdentifier;\n        // initialize (...args) {\n        //     super.initialize(...args)\n        //\n        //     // the default value is actually shared among all instances (which is ok, since its assumed to be immutable)\n        //     this.modelFieldConfig   = Object.assign({ isEqual : () => false, defaultValue : new Set(), persist : false }, this.modelFieldConfig)\n        // }\n    }\n}\n// eof Fields\n// Atoms\nexport const IsChronoModelSymbol = Symbol('IsChronoModelSymbol');\n//---------------------------------------------------------------------------------------------------------------------\nexport class ChronoModelFieldIdentifier extends Mixin([FieldIdentifier], (base) => {\n    const superProto = base.prototype;\n    class ChronoModelFieldIdentifier extends base {\n        [IsChronoModelSymbol]() { }\n        getFromGraph(graph) {\n            if (graph) {\n                if (graph.readMode === ReadMode.CurrentOrProposedOrPrevious) {\n                    const higherLevel = graph.isCommitting && this.level > (graph.activeTransaction.getActiveEntry()?.level ?? Number.MAX_SAFE_INTEGER);\n                    if (this.sync && !this.context.project.isDelayingCalculation && !higherLevel)\n                        return graph.get(this);\n                    else\n                        return graph.activeTransaction.readCurrentOrProposedOrPrevious(this);\n                }\n                return superProto.getFromGraph.call(this, graph);\n            }\n            else\n                return this.DATA;\n        }\n        writeToGraph(graph, proposedValue, ...args) {\n            if (graph) {\n                superProto.writeToGraph.call(this, graph, proposedValue, ...args);\n            }\n            else {\n                this.DATA = proposedValue;\n                // Avoid calling set if we are already setting, or if this is the initial assign of data\n                // (in both cases the underlying data will be correct already)\n                //@ts-ignore\n                if (!this.self.inSetting && !this.self.isConstructing) {\n                    //@ts-ignore\n                    this.self.set(this.field.name, proposedValue, false, false, true);\n                }\n            }\n        }\n        write(me, transaction, quark, proposedValue, ...args) {\n            // convert proposed value if needed\n            proposedValue = me.convert(proposedValue);\n            superProto.write.call(this, me, transaction, quark, proposedValue, ...args);\n        }\n        convert(value) {\n            const field = this.field;\n            const fieldDefinition = this.self.getFieldDefinition(field.name);\n            // use field definition provided \"convert\" function\n            if (fieldDefinition?.convert) {\n                value = fieldDefinition.convert(value, this.context.data, this.context);\n                // fallback to atom defined \"converter\"\n            }\n            else if (field.converter) {\n                value = field.converter(value, field);\n            }\n            return value;\n        }\n        equality(v1, v2) {\n            if ((v1 instanceof Date) && (v2 instanceof Date))\n                return v1.getTime() === v2.getTime();\n            return v1 === v2;\n        }\n    }\n    __decorate([\n        prototypeValue(false)\n    ], ChronoModelFieldIdentifier.prototype, \"sync\", void 0);\n    return ChronoModelFieldIdentifier;\n}) {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class ChronoModelReferenceFieldQuark extends Mixin([QuarkSync], (base) => {\n    const superProto = base.prototype;\n    class ChronoModelReferenceFieldQuark extends base {\n        setValue(value) {\n            superProto.setValue.call(this, value);\n            // keep the copy of value on the identifier itself, to make it available\n            // after the identifier is removed from the graph\n            //@ts-ignore\n            if (value !== TombStone)\n                this.identifier.DATA = value;\n        }\n    }\n    return ChronoModelReferenceFieldQuark;\n}) {\n}\nexport class ChronoModelReferenceFieldIdentifier extends ReferenceIdentifier.mix(ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync)) {\n    buildProposedValue(me, q, transaction) {\n        const quark = q;\n        const proposedValue = quark.proposedValue;\n        if (proposedValue === null || proposedValue === undefined) {\n            transaction.candidate.failedResolutionReferences.delete(quark.identifier);\n            return null;\n        }\n        // ignore the given Entity, if it's not in the graph\n        // (should be treated as unresolved id)\n        if (isInstanceOf(proposedValue, Entity) && proposedValue.graph) {\n            if (me.hasBucket())\n                me.getBucket(proposedValue).addToBucket(transaction, me.self);\n            transaction.candidate.failedResolutionReferences.delete(quark.identifier);\n            return proposedValue;\n        }\n        const resolved = me.resolve(proposedValue);\n        // ignore the given Entity, if it's not in the graph\n        // (should be treated as unresolved id)\n        if (isInstanceOf(resolved, Entity) && resolved.graph) {\n            if (me.hasBucket())\n                me.getBucket(resolved).addToBucket(transaction, me.self);\n            transaction.candidate.failedResolutionReferences.delete(quark.identifier);\n            return resolved;\n        }\n        else {\n            transaction.candidate.failedResolutionReferences.set(quark.identifier, proposedValue);\n            return null;\n        }\n    }\n}\n__decorate([\n    prototypeValue(true)\n], ChronoModelReferenceFieldIdentifier.prototype, \"sync\", void 0);\n__decorate([\n    prototypeValue(ChronoModelReferenceFieldQuark)\n], ChronoModelReferenceFieldIdentifier.prototype, \"quarkClass\", void 0);\n//---------------------------------------------------------------------------------------------------------------------\nexport class ChronoModelReferenceBucketFieldIdentifier extends ReferenceBucketIdentifier.mix(ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync)) {\n}\n__decorate([\n    prototypeValue(true)\n], ChronoModelReferenceBucketFieldIdentifier.prototype, \"sync\", void 0);\nexport class MinimalChronoModelFieldIdentifierSync extends ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierSync) {\n}\nexport class MinimalChronoModelFieldIdentifierGen extends ChronoModelFieldIdentifier.mix(MinimalFieldIdentifierGen) {\n}\nexport class MinimalChronoModelFieldVariable extends ChronoModelFieldIdentifier.mix(MinimalFieldVariable) {\n}\n// eof Atoms\nexport const model_field = function (modelFieldConfig = {}, chronoFieldConfig = {}, chronoFieldClass = ModelField) {\n    return function (target, propertyKey) {\n        const decoratorFn = generic_field({ modelFieldConfig, ...chronoFieldConfig }, chronoFieldClass);\n        decoratorFn(target, propertyKey);\n        injectStaticFieldsProperty(target.constructor);\n    };\n};\nexport const injectStaticFieldsProperty = (prototype) => {\n    if (!prototype.hasOwnProperty('fields')) {\n        Object.defineProperty(prototype, 'fields', {\n            get: function () {\n                return getDecoratedModelFields(this);\n            }\n        });\n    }\n};\nexport const getDecoratedModelFields = (constr) => {\n    const proto = constr.prototype;\n    const result = [];\n    if (proto.hasOwnProperty('$entity')) {\n        proto.$entity.ownFields.forEach((field) => {\n            if (field instanceof ModelField) {\n                const config = field.modelFieldConfig || {};\n                if (!config.convert && field.converter && field.converter !== dateConverter) {\n                    config.convert = field.converter;\n                }\n                result.push(Object.assign(config, {\n                    $chrono: field,\n                    name: field.name\n                }));\n            }\n        });\n    }\n    return result;\n};\nexport const dateConverter = (date, field) => {\n    if (date === null) {\n        return null;\n    }\n    if (!(date instanceof Date)) {\n        date = DateHelper.parse(date, field.modelFieldConfig?.format || field.modelFieldConfig?.dateFormat ||\n            DateHelper.defaultParseFormat);\n    }\n    // if parsing has failed, we would like to return `undefined` to indicate the \"absence\" of data\n    // instead of `null` (presence of \"empty\" data)\n    return date || undefined;\n};\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { Entity } from \"../../ChronoGraph/replica/Entity.js\";\nimport Model from \"../../Core/data/Model.js\";\nimport ObjectHelper from \"../../Core/helper/ObjectHelper.js\";\nimport { ProposedOrPrevious } from \"../../ChronoGraph/chrono/Effect.js\";\nimport { ChronoModelReferenceBucketFieldIdentifier, ChronoModelReferenceFieldIdentifier } from \"./ModelFieldAtom.js\";\n/**\n * This is a base mixin, which mixes together the ChronoGraph's [Entity](https://bryntum.com/products/gantt/docs/engine/modules/_lib_chronograph_replica_entity_.html)\n * and the Bryntum Core [Model](https://bryntum.com/products/grid/docs/api/Core/data/Model)\n *\n * It is used as a very base mixin for all other entities in the project.\n */\nexport class ChronoModelMixin extends Mixin([Entity, Model], (base) => {\n    const superProto = base.prototype;\n    class ChronoModelMixin extends base {\n        // This is a marker for Models which have the Engine API available.\n        get isEntity() {\n            return true;\n        }\n        construct(config, ...args) {\n            // this is to force the fields creation, because we need all fields to be created\n            // for the `this.getFieldDefinition()` to return correct result\n            // @ts-ignore\n            this.constructor.exposeProperties();\n            // Cache original data before we recreate the incoming data here.\n            this.originalData = (config = config || {});\n            // Populate record with all data, it will sort the configs out.\n            // By doing this first, we can feed engine the converted values right away. Needed to satisfy tests that\n            // use standalone stores, otherwise they will be getting the unconverted values since there is no graph.\n            superProto.construct.call(this, config, ...args);\n            // assign Chronograph fields that are not Model fields\n            for (const fieldName in this.originalData) {\n                if (this.$[fieldName] && !this.getFieldDefinition(fieldName)) {\n                    this[fieldName] = config[fieldName];\n                }\n            }\n        }\n        /**\n         * Calculation function that simply returns current ([[ProposedOrPrevious|proposed or previous]]) value of\n         * an identifier.\n         */\n        *userProvidedValue() {\n            return yield ProposedOrPrevious;\n        }\n        copy(newId = null, deep = null) {\n            const copy = superProto.copy.call(this, newId, deep);\n            const { creatingOccurrence } = deep ?? {};\n            // If deep is everything but object - use default behavior, which is to invoke accessors\n            // If deep is an object, check if it has certain field disabled\n            if ((ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers) || !ObjectHelper.isObject(deep)) {\n                this.forEachFieldIdentifier((identifier, fieldName, field) => {\n                    if (!field.lazy &&\n                        // @ts-ignore\n                        this.getFieldDefinition(fieldName)?.type !== 'store' && (!creatingOccurrence\n                        // Only include buckets and references for occurrences, they will not be part of graph and\n                        // will handle their own dates etc\n                        || identifier instanceof ChronoModelReferenceBucketFieldIdentifier\n                        || identifier instanceof ChronoModelReferenceFieldIdentifier)) {\n                        copy[fieldName] = this[fieldName];\n                    }\n                });\n            }\n            return copy;\n        }\n        applyValue(useProp, key, value, skipAccessors, field) {\n            // key is the dataSource, we need to check for the field name instead\n            const chronoField = this.$entity.getField(field?.name || key);\n            if (chronoField)\n                useProp = true;\n            if (skipAccessors)\n                useProp = false;\n            superProto.applyValue.call(this, useProp, useProp ? field?.name ?? key : key, value, skipAccessors, field);\n        }\n        get isInActiveTransaction() {\n            // Might not have joined graph when using delayed calculation\n            const activeTransaction = this.graph?.activeTransaction;\n            return Boolean(activeTransaction?.getLatestEntryFor(this.$$));\n        }\n        get data() {\n            return this._data;\n        }\n        set data(data) {\n            this._data = data;\n            // Have to iterate over defined fields and not keys in supplied data, in case nested mappings are used\n            const { fields, $, graph, generation } = this;\n            for (let i = 0; i < fields.length; i++) {\n                const { name, dataSource, complexMapping } = fields[i];\n                const identifier = $[name];\n                if (identifier) {\n                    const value = complexMapping\n                        ? ObjectHelper.getPath(data, dataSource)\n                        : data[dataSource];\n                    // Avoid hitting setter for fields that have no value in supplied data, or are undefined on initial set\n                    if ((complexMapping || dataSource in data) && (generation != null || value !== undefined)) {\n                        // Use the predefined name for engine (name, startDate)\n                        identifier.writeToGraph(graph, value);\n                    }\n                }\n            }\n        }\n        get $entityName() {\n            const className = this.constructor.name || this.$entity.name;\n            const id = this.id;\n            return `${className}${id != null ? '-' + String(id) : ''}`;\n        }\n    }\n    return ChronoModelMixin;\n}) {\n}\n", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nconst locale = {\n    localeName: 'En',\n    localeDesc: 'English (US)',\n    localeCode: 'en-US',\n    RemoveDependencyCycleEffectResolution: {\n        descriptionTpl: 'Remove dependency'\n    },\n    DeactivateDependencyCycleEffectResolution: {\n        descriptionTpl: 'Deactivate dependency'\n    },\n    CycleEffectDescription: {\n        descriptionTpl: 'A cycle has been found, formed by: {0}'\n    },\n    EmptyCalendarEffectDescription: {\n        descriptionTpl: '\"{0}\" calendar does not provide any working time intervals.'\n    },\n    Use24hrsEmptyCalendarEffectResolution: {\n        descriptionTpl: 'Use 24 hours calendar with non-working Saturdays and Sundays.'\n    },\n    Use8hrsEmptyCalendarEffectResolution: {\n        descriptionTpl: 'Use 8 hours calendar (08:00-12:00, 13:00-17:00) with non-working Saturdays and Sundays.'\n    },\n    ConflictEffectDescription: {\n        descriptionTpl: 'A scheduling conflict has been found: {0} is conflicting with {1}'\n    },\n    ConstraintIntervalDescription: {\n        dateFormat: 'LLL'\n    },\n    ProjectConstraintIntervalDescription: {\n        startDateDescriptionTpl: 'Project start date {0}',\n        endDateDescriptionTpl: 'Project end date {0}'\n    },\n    DependencyType: {\n        long: [\n            'Start-to-Start',\n            'Start-to-Finish',\n            'Finish-to-Start',\n            'Finish-to-Finish'\n        ]\n    },\n    ManuallyScheduledParentConstraintIntervalDescription: {\n        startDescriptionTpl: 'Manually scheduled \"{2}\" forces its children to start no earlier than {0}',\n        endDescriptionTpl: 'Manually scheduled \"{2}\" forces its children to finish no later than {1}'\n    },\n    DisableManuallyScheduledConflictResolution: {\n        descriptionTpl: 'Disable manual scheduling for \"{0}\"'\n    },\n    DependencyConstraintIntervalDescription: {\n        descriptionTpl: 'Dependency ({2}) from \"{3}\" to \"{4}\"'\n    },\n    RemoveDependencyResolution: {\n        descriptionTpl: 'Remove dependency from \"{1}\" to \"{2}\"'\n    },\n    DeactivateDependencyResolution: {\n        descriptionTpl: 'Deactivate dependency from \"{1}\" to \"{2}\"'\n    },\n    DateConstraintIntervalDescription: {\n        startDateDescriptionTpl: 'Task \"{2}\" {3} {0} constraint',\n        endDateDescriptionTpl: 'Task \"{2}\" {3} {1} constraint',\n        constraintTypeTpl: {\n            startnoearlierthan: 'Start-No-Earlier-Than',\n            finishnoearlierthan: 'Finish-No-Earlier-Than',\n            muststarton: 'Must-Start-On',\n            mustfinishon: 'Must-Finish-On',\n            startnolaterthan: 'Start-No-Later-Than',\n            finishnolaterthan: 'Finish-No-Later-Than'\n        }\n    },\n    RemoveDateConstraintConflictResolution: {\n        descriptionTpl: 'Remove \"{1}\" constraint of task \"{0}\"'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import { MAX_DATE, MIN_DATE } from '../util/Constants.js';\nimport { EdgeInclusion } from \"../util/Types.js\";\nimport { Base } from '../../ChronoGraph/class/Base.js';\n/**\n * General purpose date interval. Contains just 2 properties - [[startDate]] and [[endDate]].\n */\nexport class DateInterval extends Base {\n    initialize(...args) {\n        super.initialize(...args);\n        if (!this.startDate)\n            this.startDate = MIN_DATE;\n        if (!this.endDate)\n            this.endDate = MAX_DATE;\n    }\n    equalTo(another) {\n        return this.startDate.getTime() === another.startDate.getTime() && this.endDate.getTime() === another.endDate.getTime();\n    }\n    isInfinite() {\n        return this.startDate.getTime() === MIN_DATE.getTime() && this.endDate.getTime() === MAX_DATE.getTime();\n    }\n    startDateIsFinite() {\n        return !this.isIntervalEmpty() && this.startDate.getTime() !== MIN_DATE.getTime();\n    }\n    endDateIsFinite() {\n        return !this.isIntervalEmpty() && this.endDate.getTime() !== MAX_DATE.getTime();\n    }\n    /**\n     * Test whether the given time point is within this interval. By default interval is considered to be\n     * inclusive on the left side and opened on the right (controlled with `edgeInclusion`).\n     *\n     * @param date\n     * @param edgeInclusion\n     */\n    containsDate(date, edgeInclusion = EdgeInclusion.Left) {\n        return ((edgeInclusion === EdgeInclusion.Left && (date >= this.startDate && date < this.endDate))\n            ||\n                (edgeInclusion === EdgeInclusion.Right && (date > this.startDate && date <= this.endDate)));\n    }\n    isIntervalEmpty() {\n        return this.startDate > this.endDate;\n    }\n    /**\n     * Intersect this interval with another in the immutable way - returns a new interval.\n     * @param another\n     */\n    intersect(another) {\n        const anotherStart = another.startDate;\n        const anotherEnd = another.endDate;\n        const start = this.startDate;\n        const end = this.endDate;\n        // No intersection found\n        if ((end < anotherStart) || (start > anotherEnd)) {\n            // return an empty interval\n            return EMPTY_INTERVAL;\n        }\n        const newStart = new Date(Math.max(start.getTime(), anotherStart.getTime()));\n        const newEnd = new Date(Math.min(end.getTime(), anotherEnd.getTime()));\n        return this.constructor.new({ startDate: newStart, endDate: newEnd });\n    }\n    /**\n     * Intersect this interval with another in the mutable way - updates current interval.\n     * @param another\n     */\n    intersectMut(another, collectIntersectionMeta = false) {\n        const anotherStart = another.startDate;\n        const anotherEnd = another.endDate;\n        const start = this.startDate;\n        const end = this.endDate;\n        // If another interval is an intersection result we keep track of the\n        // initial intersected intervals\n        if (collectIntersectionMeta) {\n            if (!this.intersectionOf)\n                this.intersectionOf = new Set();\n            if (another.intersectionOf?.size > 0) {\n                // this.intersectionOf = new Set([ ...this.intersectionOf, ...another.intersectionOf ])\n                another.intersectionOf.forEach(this.intersectionOf.add, this.intersectionOf);\n                this.intersectedAsEmpty = another.intersectedAsEmpty;\n            }\n            // keep track if the intervals we intersect with\n            else {\n                this.intersectionOf.add(another);\n            }\n        }\n        // Bail out if we are an empty interval\n        if (!this.isIntervalEmpty()) {\n            // No intersection found\n            if ((end < anotherStart) || (start > anotherEnd)) {\n                // return an empty interval\n                this.startDate = MAX_DATE;\n                this.endDate = MIN_DATE;\n                // remember the interval resulted an empty intersection\n                if (collectIntersectionMeta) {\n                    this.intersectedAsEmpty = another;\n                }\n                return this;\n            }\n            this.startDate = new Date(Math.max(start.getTime(), anotherStart.getTime()));\n            this.endDate = new Date(Math.min(end.getTime(), anotherEnd.getTime()));\n        }\n        return this;\n    }\n    getCopyProperties(data) {\n        return data;\n    }\n    copyWith(data) {\n        const copyData = this.getCopyProperties(data);\n        // @ts-ignore\n        return this.constructor.new(copyData);\n    }\n}\nexport const EMPTY_INTERVAL = DateInterval.new({ startDate: MAX_DATE, endDate: MIN_DATE });\n/**\n * Intersects the array of intervals. Returns a new interval with result.\n *\n * @param dateIntervals\n */\nexport const intersectIntervals = (dateIntervals, collectIntersectionMeta = false) => {\n    return dateIntervals.reduce((acc, currentInterval) => acc.intersectMut(currentInterval, collectIntersectionMeta), DateInterval.new());\n};\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Effect } from \"../../ChronoGraph/chrono/Effect.js\";\nimport { prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport Base from \"../../Core/Base.js\";\n/**\n * Type for an effect resolution process.\n */\nexport var EffectResolutionResult;\n(function (EffectResolutionResult) {\n    /**\n     * A chosen resolution is \"do nothing\" so changes should be cancelled.\n     */\n    EffectResolutionResult[\"Cancel\"] = \"Cancel\";\n    /**\n     * A resolution is applied and current transaction should be continued.\n     */\n    EffectResolutionResult[\"Resume\"] = \"Resume\";\n})(EffectResolutionResult || (EffectResolutionResult = {}));\n/**\n * Class implementing a [[SchedulingIssueEffect|scheduling issue]] resolution.\n */\nexport class SchedulingIssueEffectResolution extends Base {\n    /**\n     * Returns the resolution description.\n     */\n    getDescription() {\n        throw new Error('Abstract method');\n    }\n    /**\n     * Resolves the [[SchedulingIssueEffect|scheduling issue]].\n     */\n    resolve(...args) {\n        throw new Error('Abstract method');\n    }\n}\n/**\n * Base class for an [[Effect|effect]] signalizing of a scheduling issue\n * that should be resolved by some application logic or the user.\n * The class provides an array of the case possible [[getResolutions|resolutions]]\n * and the case [[getDescription|description]].\n */\nexport class SchedulingIssueEffect extends Effect {\n    /**\n     * Returns the list of possible effect resolutions.\n     */\n    getResolutions() {\n        return this._resolutions;\n    }\n    getDescriptionBuilderClass() {\n        return this._descriptionBuilderClass;\n    }\n    setDescriptionBuilderClass(cls) {\n        this._descriptionBuilderClass = cls;\n    }\n    /**\n     * Returns the effect human readable description.\n     */\n    getDescription() {\n        return this.getDescriptionBuilderClass().getDescription(this);\n    }\n}\n__decorate([\n    prototypeValue('schedulingIssueEffect')\n], SchedulingIssueEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(false)\n], SchedulingIssueEffect.prototype, \"sync\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport Base from \"../../Core/Base.js\";\nimport DateHelper from \"../../Core/helper/DateHelper.js\";\nimport Localizable from \"../../Core/localization/Localizable.js\";\nimport \"../localization/En.js\";\nimport { DateInterval, intersectIntervals } from \"../scheduling/DateInterval.js\";\nimport { format } from \"../util/Functions.js\";\nimport { SchedulingIssueEffect, SchedulingIssueEffectResolution } from \"./SchedulingIssueEffect.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const ConflictSymbol = Symbol('ConflictSymbol');\n/**\n * Description builder for a [[ConflictEffect|scheduling conflict]].\n */\nexport class ConflictEffectDescription extends Localizable(Base) {\n    static get $name() {\n        return 'ConflictEffectDescription';\n    }\n    /**\n     * Returns the scheduling conflict localized description.\n     * @param conflict Scheduling conflict\n     */\n    static getDescription(conflict) {\n        return format(this.L('L{descriptionTpl}'), conflict.intervals[0].getDescription(), conflict.intervals[1].getDescription());\n    }\n}\n/**\n * Special [[Effect|effect]] indicating a _scheduling conflict_ happened.\n */\nexport class ConflictEffect extends SchedulingIssueEffect {\n    constructor() {\n        super(...arguments);\n        this.handler = ConflictSymbol;\n    }\n    initialize(props) {\n        super.initialize(props);\n        // filter the provided intervals to keep only the conflicting ones\n        this.intervals = this.filterConflictingIntervals(this.intervals);\n    }\n    /**\n     * Returns possible resolutions for the _conflict_.\n     */\n    getResolutions() {\n        if (!this._resolutions) {\n            // collect all possible resolutions\n            this._resolutions = [].concat(...this.intervals.map(interval => interval.getResolutions()));\n        }\n        return this._resolutions;\n    }\n    filterConflictingIntervals(intervals) {\n        const result = [];\n        // filter out infinite intervals ..they don't really restrict anything\n        const intervalsArray = [...intervals].filter(interval => !interval.isInfinite());\n        const affectedInterval = intervalsArray.find(interval => interval.isAffectedByTransaction());\n        // If we've managed to detect the interval being changed in this transaction\n        if (affectedInterval) {\n            // Sort intervals so the one we've found go first..\n            const sorted = intervalsArray.sort((a, b) => a === affectedInterval ? -1 : 0);\n            // ..so when intersecting intervals we find another interval resulting an empty intersection\n            const intersection = intersectIntervals(sorted, true);\n            const conflictingInterval = intersection.intersectedAsEmpty;\n            result.push(conflictingInterval, affectedInterval);\n        }\n        else {\n            result.push(intersectIntervals(intervalsArray, true).intersectedAsEmpty, intersectIntervals(intervalsArray.reverse(), true).intersectedAsEmpty);\n        }\n        return result;\n    }\n}\n__decorate([\n    prototypeValue('schedulingConflict')\n], ConflictEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(ConflictEffectDescription)\n], ConflictEffect.prototype, \"_descriptionBuilderClass\", void 0);\n/**\n * An abstract class for implementing a certain way of resolving a scheduling conflict.\n */\nexport class ConflictResolution extends SchedulingIssueEffectResolution {\n    /**\n     * Resolves the scheduling conflict.\n     */\n    resolve() {\n        throw new Error('Abstract method');\n    }\n}\n/**\n * Base class for an interval _description builder_ - s special class that returns\n * a human readable localized description for a provided interval.\n */\nexport class ConstraintIntervalDescription extends Localizable(Base) {\n    static get $name() {\n        return 'ConstraintIntervalDescription';\n    }\n    /**\n     * Returns the provided interval description.\n     * @param interval Interval to get description of\n     */\n    static getDescription(interval) {\n        return format(this.L('L{descriptionTpl}'), ...this.getDescriptionParameters(interval));\n    }\n    /**\n     * Returns additional parameters to put into the description.\n     * @param interval Interval to get description of\n     */\n    static getDescriptionParameters(interval) {\n        return [\n            DateHelper.format(interval.startDate, this.L('L{dateFormat}')),\n            DateHelper.format(interval.endDate, this.L('L{dateFormat}'))\n        ];\n    }\n}\n/**\n * Base class for implementing an interval that applies a certain constraint on event(s).\n */\nexport class ConstraintInterval extends DateInterval {\n    constructor() {\n        super(...arguments);\n        this.owner = undefined;\n        this.reflectionOf = undefined;\n        this.side = undefined;\n        this.resolutions = undefined;\n    }\n    get isConstraintInterval() {\n        return true;\n    }\n    /**\n     * Returns the interval description.\n     */\n    getDescription() {\n        return this.descriptionBuilderClass.getDescription(this);\n    }\n    /**\n     * Returns possible resolution for the interval when it takes part in a _scheduling conflict_.\n     */\n    getResolutions() {\n        return [];\n    }\n    isAffectedByTransaction(transaction) {\n        return false;\n    }\n    getCopyProperties(data) {\n        const { owner, reflectionOf, side } = this;\n        return Object.assign({ owner, reflectionOf, side }, data);\n    }\n}\n__decorate([\n    prototypeValue(ConstraintIntervalDescription)\n], ConstraintInterval.prototype, \"descriptionBuilderClass\", void 0);\n", "import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"./AbstractPartOfProjectGenericMixin.js\";\n/**\n * This a base generic mixin for every class, that belongs to a chronograph powered project.\n *\n * It just provides getter/setter for the `project` property, along with some convenience methods\n * to access the project's stores.\n */\nexport class ChronoPartOfProjectGenericMixin extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoPartOfProjectGenericMixin extends base {\n        /**\n         * The method to get the `ChronoGraph` instance, this entity belongs to.\n         */\n        getGraph() {\n            const project = this.getProject();\n            return project?.getGraph();\n        }\n        //region Entity getters\n        /**\n         * Convenience method to get the instance of event by its id.\n         */\n        getEventById(id) {\n            return this.getEventStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of dependency by its id.\n         */\n        getDependencyById(id) {\n            return this.getDependencyStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of resource by its id.\n         */\n        getResourceById(id) {\n            return this.getResourceStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of assignment by its id.\n         */\n        getAssignmentById(id) {\n            return this.getAssignmentStore()?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of calendar by its id.\n         */\n        getCalendarById(id) {\n            return this.getCalendarManagerStore()?.getById(id);\n        }\n    }\n    return ChronoPartOfProjectGenericMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nexport class ChronoStoreMixin extends Mixin([Store], (base) => class ChronoStoreMixin extends base {\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoPartOfProjectGenericMixin } from \"../../ChronoPartOfProjectGenericMixin.js\";\nimport { ChronoStoreMixin } from \"./ChronoStoreMixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./AbstractPartOfProjectStoreMixin.js\";\n/**\n * This a base mixin for every Store, that belongs to a ChronoGraph powered project.\n */\nexport class ChronoPartOfProjectStoreMixin extends Mixin([\n    AbstractPartOfProjectStoreMixin,\n    ChronoPartOfProjectGenericMixin,\n    ChronoStoreMixin\n], (base) => {\n    const superProto = base.prototype;\n    class ChronoPartOfProjectStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 0;\n        }\n        setStoreData(data) {\n            // Inform project that a store is being repopulated, to avoid expensive unjoins.\n            // Should not repopulate when using syncDataOnLoad\n            this.project?.repopulateStore(this);\n            superProto.setStoreData.call(this, data);\n        }\n        register(record) {\n            superProto.register.call(this, record);\n            // NOTE: Remove check for `this.project.graph` if we want records added after the initial calculations to also have\n            //       delayed entry into the replica\n            // @ts-ignore\n            !record.isRoot && !this.project?.graph && this.project?.scheduleDelayedCalculation();\n        }\n        onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n            // 1. call will forward value to the chrono, leaving model.data intact\n            // 2. value was changed, so model.afterChange is called too, triggering `update` event on store\n            // 3. autoCommit is scheduled\n            // 4. autoCommit finalizes, calling endBatch\n            // 5. endBatch calls `set` again, passing argument `skipAccessors = true`, which means data will be set to\n            // the `model.data` now\n            // 6. since value differs in chrono and in model.data, `afterChange` will be called once again\n            // Naturally this leads to two identical events being fired for this call:\n            // `dependency.set('type', 0)\n            //\n            // Idea of the fix is to mute events for the first call IF chrono field is in the `wasSet` object\n            // Covered by DependencyEdit.t.js\n            if (!skipAccessors && !(this.syncDataOnLoad && this.isLoadingData) && Object.keys(wasSet).some(key => key !== 'intervals' && record.$entity.getField(key))) {\n                silent = true;\n            }\n            //@ts-ignore\n            super.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);\n        }\n    }\n    return ChronoPartOfProjectStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoModelMixin } from \"../../../chrono/ChronoModelMixin.js\";\nimport { ChronoPartOfProjectGenericMixin } from \"../../ChronoPartOfProjectGenericMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"../../store/mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractPartOfProjectModelMixin } from \"./AbstractPartOfProjectModelMixin.js\";\nimport { isInstanceOf } from '../../../../ChronoGraph/class/Mixin.js';\n/**\n * This a base mixin for every Model that belongs to a ChronoGraph powered project.\n *\n * The model with this mixin, supposes that it will be \"joining\" a store that is already part of a project,\n * so that such model can take a reference to the project from it.\n *\n * It provides 2 template methods [[joinProject]] and [[leaveProject]], which can be overridden in other mixins\n * (they should always call `super` implementation, because it adds/remove the model to/from the ChronoGraph instance)\n */\nexport class ChronoPartOfProjectModelMixin extends Mixin([\n    AbstractPartOfProjectModelMixin,\n    ChronoPartOfProjectGenericMixin,\n    ChronoModelMixin\n], (base) => {\n    const superProto = base.prototype;\n    class ChronoPartOfProjectModelMixin extends base {\n        /**\n         * Template method, which is called when model is joining the project (through joining some store that\n         * has already joined the project)\n         */\n        joinProject() {\n            if (!this.project?.delayEnteringReplica) {\n                if (this.graph && this.graph != this.getGraph()) {\n                    this.graph = null;\n                }\n                this.getGraph().addEntity(this);\n            }\n        }\n        /**\n         * Template method, which is called when model is leaving the project (through leaving some store usually)\n         */\n        leaveProject(isReplacing = false) {\n            superProto.leaveProject.call(this, isReplacing);\n            const replica = this.getGraph();\n            // Because of delayCalculation it might not have joined the graph at all\n            replica?.removeEntity(this);\n            // @ts-ignore\n            this.graph = null;\n        }\n        /**\n         * Returns a [[SchedulerBasicProjectMixin|project]] instance\n         */\n        getProject() {\n            return superProto.getProject.call(this);\n        }\n        calculateProject() {\n            const store = this.stores.find(s => (isInstanceOf(s, ChronoPartOfProjectStoreMixin)) && !!s.getProject());\n            return store?.getProject();\n        }\n        // Report that there is no graph when delaying calculations, to not let anything enter it on reloads\n        get graph() {\n            return this.project?.delayEnteringReplica ? null : this._graph;\n        }\n        set graph(graph) {\n            this._graph = graph;\n        }\n    }\n    return ChronoPartOfProjectModelMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { ChronoPartOfProjectModelMixin } from \"../mixin/ChronoPartOfProjectModelMixin.js\";\nimport { AbstractCalendarMixin } from \"../AbstractCalendarMixin.js\";\nimport { SchedulingIssueEffect, SchedulingIssueEffectResolution } from \"../../../chrono/SchedulingIssueEffect.js\";\nimport Localizable from \"../../../../Core/localization/Localizable.js\";\nimport Base from \"../../../../Core/Base.js\";\nimport { prototypeValue } from \"../../../../ChronoGraph/util/Helpers.js\";\nimport { format } from \"../../../util/Functions.js\";\nconst hasMixin = Symbol('CalendarMixin');\nexport const EmptyCalendarSymbol = Symbol('EmptyCalendarSymbol');\n/**\n * The calendar for project scheduling, it is used to mark certain time intervals as \"non-working\" and ignore them during scheduling.\n *\n * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.\n */\nexport class BaseCalendarMixin extends Mixin([\n    AbstractCalendarMixin,\n    ChronoPartOfProjectModelMixin\n], (base) => {\n    class BaseCalendarMixin extends base {\n        constructor() {\n            super(...arguments);\n            // this field intentionally made \"model field\", so that its updates are going through\n            // all the Core's fields processing (and fires the appropriate events on the store)\n            this.version = 1;\n        }\n        [hasMixin]() { }\n    }\n    __decorate([\n        model_field({}, { persistent: false })\n    ], BaseCalendarMixin.prototype, \"version\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], BaseCalendarMixin.prototype, \"unspecifiedTimeIsWorking\", void 0);\n    __decorate([\n        model_field()\n    ], BaseCalendarMixin.prototype, \"intervals\", void 0);\n    return BaseCalendarMixin;\n}) {\n}\n/**\n * Class providing a human readable localized description of an [[EmptyCalendarEffect]] instance.\n */\nexport class EmptyCalendarEffectDescription extends Localizable(Base) {\n    static get $name() {\n        return 'EmptyCalendarEffectDescription';\n    }\n    static getDescription(effect) {\n        const calendar = effect.getCalendar();\n        return format(this.L('L{descriptionTpl}'), calendar.name || calendar.id);\n    }\n}\n/**\n * Special effect indicating that some calendar or calendars group is misconfigured\n * and do not provide any working period of time which makes its usage\n * impossible.\n */\nexport class EmptyCalendarEffect extends SchedulingIssueEffect {\n    constructor() {\n        super(...arguments);\n        this.handler = EmptyCalendarSymbol;\n    }\n    getResolutions() {\n        const calendar = this.getCalendar();\n        return this._resolutions || (this._resolutions = [\n            Use24hrsEmptyCalendarEffectResolution.new({ calendar }),\n            Use8hrsEmptyCalendarEffectResolution.new({ calendar })\n        ]);\n    }\n    /**\n     * Returns the calendar that does not have any working periods specified.\n     */\n    getCalendar() {\n        const { calendars } = this;\n        if (calendars?.length > 1) {\n            for (const calendar of calendars) {\n                const skippingRes = calendar.skipNonWorkingTime(this.date, this.isForward);\n                if (!(skippingRes instanceof Date)) {\n                    return calendar;\n                }\n            }\n        }\n        return calendars[0];\n    }\n}\n__decorate([\n    prototypeValue('emptyCalendar')\n], EmptyCalendarEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(EmptyCalendarEffectDescription)\n], EmptyCalendarEffect.prototype, \"_descriptionBuilderClass\", void 0);\n/**\n * Base class for [[EmptyCalendarEffect]] resolutions.\n * The class has [[fixCalendarData]] method that pushes preconfigured `calendarData`\n * to the given [[calendar]]. The method is called in [[resolve]] method so for a subclass\n * it's enough just providing [[fixCalendarData|proper data]].\n */\nexport class BaseEmptyCalendarEffectResolution extends Localizable(SchedulingIssueEffectResolution) {\n    static get $name() {\n        return 'BaseEmptyCalendarEffectResolution';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Correct calendar data.\n             * @property calendarData\n             */\n            calendarData: {\n                intervals: [\n                    { isWorking: true }\n                ]\n            }\n        };\n    }\n    getDescription() {\n        const { calendar } = this;\n        return format(this.L('L{descriptionTpl}'), calendar.name || calendar.id);\n    }\n    /**\n     * Fixes the provided calendar data by clearing its intervals\n     * amd then applying data specified in `calendarData` config.\n     * @param calendar\n     */\n    fixCalendarData(calendar) {\n        calendar.clearIntervals(true);\n        // @ts-ignore\n        Object.assign(calendar, this.calendarData);\n        if (calendar.intervals?.length) {\n            calendar.addIntervals(calendar.intervals);\n        }\n    }\n    /**\n     * Resolves the [[calendar]] by removing all its intervals and adding new `calendarData`.\n     */\n    resolve() {\n        const { calendar } = this;\n        this.fixCalendarData(calendar);\n    }\n}\n/**\n * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by\n * replacing its data with standard __24 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.\n */\nexport class Use24hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {\n    static get $name() {\n        return 'Use24hrsEmptyCalendarEffectResolution';\n    }\n    static get configurable() {\n        return {\n            calendarData: {\n                unspecifiedTimeIsWorking: false,\n                intervals: [\n                    {\n                        recurrentStartDate: 'on Mon at 0:00',\n                        recurrentEndDate: 'on Sat at 0:00',\n                        isWorking: true\n                    }\n                ]\n            }\n        };\n    }\n}\n/**\n * Resolution option for [[EmptyCalendarEffect]] that fixes a specified calendar by\n * replacing its data with standard __8 hours/day__ calendar (__Saturday__ and __Sunday__ are non-working days) data.\n */\nexport class Use8hrsEmptyCalendarEffectResolution extends BaseEmptyCalendarEffectResolution {\n    static get $name() {\n        return 'Use8hrsEmptyCalendarEffectResolution';\n    }\n    static get configurable() {\n        return {\n            calendarData: {\n                unspecifiedTimeIsWorking: false,\n                intervals: [\n                    {\n                        recurrentStartDate: 'every weekday at 08:00',\n                        recurrentEndDate: 'every weekday at 12:00',\n                        isWorking: true\n                    },\n                    {\n                        recurrentStartDate: 'every weekday at 13:00',\n                        recurrentEndDate: 'every weekday at 17:00',\n                        isWorking: true\n                    }\n                ]\n            }\n        };\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Reject, RejectSymbol } from \"../../ChronoGraph/chrono/Effect.js\";\nimport { TombStone } from \"../../ChronoGraph/chrono/Quark.js\";\nimport { Revision } from \"../../ChronoGraph/chrono/Revision.js\";\nimport { Transaction } from \"../../ChronoGraph/chrono/Transaction.js\";\nimport { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { Replica } from \"../../ChronoGraph/replica/Replica.js\";\nimport { prototypeValue } from \"../../ChronoGraph/util/Helpers.js\";\nimport Base from \"../../Core/Base.js\";\nimport Localizable from \"../../Core/localization/Localizable.js\";\nimport { EmptyCalendarSymbol } from \"../quark/model/scheduler_basic/BaseCalendarMixin.js\";\nimport { format } from \"../util/Functions.js\";\nimport { ConflictSymbol } from \"./Conflict.js\";\nimport { IsChronoModelSymbol, ModelBucketField } from \"./ModelFieldAtom.js\";\nimport { EffectResolutionResult, SchedulingIssueEffect, SchedulingIssueEffectResolution } from \"./SchedulingIssueEffect.js\";\nexport const CycleSymbol = Symbol('CycleSymbol');\n//---------------------------------------------------------------------------------------------------------------------\nexport class EngineRevision extends Revision {\n    constructor() {\n        super(...arguments);\n        this.failedResolutionReferences = new Map();\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class EngineTransaction extends Transaction {\n    constructor() {\n        super(...arguments);\n        this.candidateClass = EngineRevision;\n    }\n    initialize(props) {\n        // Emit progress earlier and more frequently when using delayCalculation mode, to not lock up UI as much and to\n        // have smoother progress bar updates.\n        // Transactions created to validate deps does not reference project\n        if (props.graph.project?.delayCalculation) {\n            props.startProgressNotificationsAfterMs = 0;\n            props.emitProgressNotificationsEveryMs = 100;\n        }\n        super.initialize(props);\n        this.candidate.failedResolutionReferences = new Map(this.baseRevision.failedResolutionReferences);\n    }\n    addIdentifier(identifier, proposedValue, ...args) {\n        if (this.candidate.failedResolutionReferences.size) {\n            this.candidate.failedResolutionReferences.forEach((failedResolutionValue, identifier) => {\n                this.write(identifier, failedResolutionValue);\n            });\n            this.candidate.failedResolutionReferences.clear();\n        }\n        return super.addIdentifier(identifier, proposedValue, ...args);\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * An extension of [[Replica]], specialized for interaction with [[AbstractProjectMixin|project]].\n */\nexport class EngineReplica extends Mixin([Replica], (base) => {\n    const superProto = base.prototype;\n    class EngineReplica extends base {\n        constructor() {\n            super(...arguments);\n            this.baseRevision = EngineRevision.new();\n            this.transactionClass = EngineTransaction;\n            this.autoCommitMode = 'async';\n            this.onComputationCycle = 'effect';\n            this.cycleEffectClass = CycleEffect;\n            this.silenceInitialCommit = true;\n            this.ignoreInitialCommitComputationCycles = false;\n        }\n        get dirty() {\n            const activeTransaction = this.activeTransaction;\n            return activeTransaction.entries.size > 0 && (activeTransaction.hasVariableEntry || activeTransaction.hasEntryWithProposedValue);\n        }\n        onPropagationProgressNotification(notification) {\n            if (this.enableProgressNotifications && this.project)\n                this.project.trigger?.('progress', notification);\n        }\n        async commitAsync(args) {\n            if (!this.project || this.project.isDestroyed)\n                return;\n            this.project.trigger('beforeCommit');\n            if (this.isInitialCommit && this.ignoreInitialCommitComputationCycles) {\n                // backup onComputationCycle value to restore it after the commit\n                this._onComputationCycle = this._onComputationCycle || this.onComputationCycle;\n                // toggle onComputationCycle to ignore cycles to let the data get into the graph\n                this.onComputationCycle = 'ignore';\n            }\n            const replacedReplicaResult = this.project.beforeCommitAsync();\n            if (replacedReplicaResult)\n                return replacedReplicaResult;\n            return superProto.commitAsync.call(this, args);\n        }\n        get isInitialCommit() {\n            // let the project defined which commit is \"initial\"\n            return this.project.isInitialCommit || super.isInitialCommit;\n        }\n        set isInitialCommit(value) {\n            super.isInitialCommit = value;\n        }\n        write(identifier, proposedValue, ...args) {\n            const fieldName = identifier.field?.name;\n            const record = identifier.self;\n            if (fieldName && record) {\n                // @ts-ignore\n                const beforeHookResult = record.beforeChronoFieldSet?.(fieldName, proposedValue);\n                superProto.write.call(this, identifier, proposedValue, ...args);\n                // @ts-ignore\n                record.afterChronoFieldSet?.(fieldName, proposedValue, beforeHookResult);\n            }\n            else {\n                superProto.write.call(this, identifier, proposedValue, ...args);\n            }\n        }\n        async finalizeCommitAsync(transactionResult) {\n            // the `this.project` may be empty for the branch, where we validate the dependency\n            // because if asyncness project might be destroyed when we get here\n            const { project } = this;\n            if (!project || project.isDestroyed)\n                return;\n            const { entries } = transactionResult;\n            const autoCommitStores = new Set();\n            if (globalThis.DEBUG)\n                console.timeEnd('Time to visible');\n            const { isInitialCommit, silenceInitialCommit } = this;\n            // apply changes silently if this is initial commit and \"silenceInitialCommit\" option is enabled\n            const silenceCommit = isInitialCommit && silenceInitialCommit;\n            if (isInitialCommit) {\n                project.isInitialCommitPerformed = true;\n                // restore onComputationCycle back if we toggled it before committing\n                if (this.ignoreInitialCommitComputationCycles)\n                    this.onComputationCycle = this._onComputationCycle;\n            }\n            project.isWritingData = true;\n            project.hasLoadedDataToCommit = false;\n            // Let progress listeners know we are finalizing\n            if (this.enableProgressNotifications) {\n                project.trigger('progress', {\n                    total: transactionResult.entries.size,\n                    remaining: 0,\n                    phase: 'finalizing'\n                });\n            }\n            const transaction = transactionResult.transaction;\n            // need to reject the data before the `refresh` event, otherwise\n            // the UI will try to refresh the stale data\n            if (transaction.rejectedWith) {\n                project.trigger('commitRejected', { transactionResult, isInitialCommit, silenceCommit });\n            }\n            // It is triggered earlier because on that stage engine is ready and UI can be drawn.\n            // dataReady happens up to like a second later in big datasets. We do not want to wait that long\n            project.trigger('refresh', { isInitialCommit, isCalculated: true });\n            // console.timeEnd('rendered')\n            await new Promise(resolve => {\n                setTimeout(() => {\n                    if (!project.isDestroyed) {\n                        if (!transactionResult.transaction.rejectedWith) {\n                            // @ts-ignore\n                            project.suspendChangesTracking?.();\n                            if (globalThis.DEBUG)\n                                console.time('Finalize propagation');\n                            const records = new Set();\n                            for (const quark of entries.values()) {\n                                const identifier = quark.identifier;\n                                const quarkValue = quark.getValue();\n                                const { field } = identifier;\n                                if (quark.isShadow() || !identifier[IsChronoModelSymbol] || quarkValue === TombStone || field instanceof ModelBucketField)\n                                    continue;\n                                const record = identifier.self;\n                                const store = record.firstStore;\n                                // Begin batch once\n                                if (!records.has(record)) {\n                                    record.beginBatch(true);\n                                    records.add(record);\n                                }\n                                // Avoid committing changes during refresh, commit below instead. Suspend once\n                                if (store?.autoCommit && !autoCommitStores.has(store)) {\n                                    store.suspendAutoCommit();\n                                    autoCommitStores.add(store);\n                                }\n                                // Cheapest possible set\n                                // @ts-ignore\n                                record.meta.batchChanges[field.name] = quarkValue;\n                            }\n                            let prevented = false;\n                            for (const record of records) {\n                                if (!record.triggerBeforeUpdate({ ...record.meta.batchChanges })) {\n                                    prevented = true;\n                                    break;\n                                }\n                            }\n                            if (prevented) {\n                                for (const record of records) {\n                                    record.cancelBatch();\n                                }\n                                transactionResult.transaction.reject();\n                                project.trigger('commitRejected', { transactionResult, isInitialCommit, silenceCommit });\n                                project.trigger('refresh', { isInitialCommit, isCalculated: true });\n                            }\n                            else {\n                                for (const record of records) {\n                                    //@ts-ignore\n                                    record.ignoreBag = silenceCommit || project.ignoreRecordChanges;\n                                    record.generation++;\n                                    record.endBatch(silenceCommit, true, true);\n                                    //@ts-ignore\n                                    record.ignoreBag = false;\n                                }\n                            }\n                            project.ignoreRecordChanges = false;\n                            if (globalThis.DEBUG)\n                                console.timeEnd('Finalize propagation');\n                            // Calendar expects flag to be cleared before dataReady, was mismatch with engine stub\n                            project.isWritingData = false;\n                            if (!prevented) {\n                                project.trigger('dataReady', { records, isInitialCommit });\n                            }\n                            // @ts-ignore\n                            project.resumeChangesTracking?.(silenceCommit);\n                            autoCommitStores.forEach(store => store.resumeAutoCommit());\n                            // clear all changes of the first graph commit\n                            if (silenceCommit) {\n                                project.eventStore.acceptChanges();\n                                project.dependencyStore.acceptChanges();\n                                project.resourceStore.acceptChanges();\n                                project.assignmentStore.acceptChanges();\n                                project.calendarManagerStore.acceptChanges();\n                                project.acceptChanges();\n                            }\n                        }\n                        // transaction rejected\n                        else {\n                            project.isWritingData = false;\n                        }\n                        project.trigger('commitFinalized', { isInitialCommit, transactionResult });\n                    }\n                    resolve();\n                }, 0);\n            });\n        }\n        *onComputationCycleHandler(cycle) {\n            if (this.onComputationCycle === 'effect') {\n                const effect = this.project.cycleEffectClass.new({ cycle });\n                if ((yield effect) === EffectResolutionResult.Cancel) {\n                    yield Reject(effect);\n                }\n            }\n            else {\n                return yield* super.onComputationCycleHandler(cycle);\n            }\n        }\n        async [CycleSymbol](effect, transaction) {\n            // delegate to project\n            return this.project.onCycleSchedulingIssue(effect, transaction);\n        }\n        async [EmptyCalendarSymbol](effect, transaction) {\n            transaction.walkContext.startNewEpoch();\n            // delegate to project\n            return this.project.onEmptyCalendarSchedulingIssue(effect, transaction);\n        }\n        async [ConflictSymbol](effect, transaction) {\n            transaction.walkContext.startNewEpoch();\n            // delegate to project\n            return this.project.onConflictSchedulingIssue(effect, transaction);\n        }\n        [RejectSymbol](effect, transaction) {\n            return super[RejectSymbol](effect, transaction);\n        }\n    }\n    return EngineReplica;\n}) {\n}\n/**\n * A cycle resolution removing one of the [[getDependencies|related dependencies]].\n * The dependency instance should be passed to [[resolve]] method:\n *\n * ```typescript\n * // this call will remove dependencyRecord\n * removalResolution.resolve(dependencyRecord)\n * ```\n */\nexport class RemoveDependencyCycleEffectResolution extends Localizable(SchedulingIssueEffectResolution) {\n    static get $name() {\n        return 'RemoveDependencyCycleEffectResolution';\n    }\n    getDescription() {\n        return this.L('L{descriptionTpl}');\n    }\n    resolve(dependency) {\n        dependency.remove();\n    }\n}\n/**\n * Class providing a human readable localized description ofr a [[CycleEffect]] instance.\n */\nexport class CycleEffectDescription extends Localizable(Base) {\n    static get $name() {\n        return 'CycleEffectDescription';\n    }\n    static getDescription(effect) {\n        return format(this.L('L{descriptionTpl}'), this.getShortDescription(effect));\n    }\n    static getShortDescription(effect) {\n        const events = effect.getEvents().slice();\n        events.push(events[0]);\n        return '\"' + events.map(event => event.name || '#' + event.id).join('\" -> \"') + '\"';\n    }\n}\n/**\n * Class implementing a special effect signalizing of a computation cycle.\n * The class suggests the only [[getResolutions|resolution]] option - removing one of the\n * [[getDependencies|related dependencies]].\n */\nexport class CycleEffect extends SchedulingIssueEffect {\n    constructor() {\n        super(...arguments);\n        this.handler = CycleSymbol;\n    }\n    /**\n     * Returns list of events building the cycle.\n     */\n    getEvents() {\n        if (!this._events) {\n            const result = new Set();\n            this.cycle.cycle.forEach(({ context }) => result.add(context));\n            this._events = [...result];\n        }\n        return this._events;\n    }\n    matchDependencyBySourceAndTargetEvent(dependency, from, to) {\n        return dependency.fromEvent === from && dependency.toEvent === to;\n    }\n    getDependencyForSourceAndTargetEvents(from, to) {\n        const events = this.getEvents();\n        const project = events[0].project;\n        const dependencyStore = project.getDependencyStore();\n        return dependencyStore.find((dependency) => this.matchDependencyBySourceAndTargetEvent(dependency, from, to));\n    }\n    /**\n     * Returns list of dependencies building the cycle.\n     */\n    getDependencies() {\n        if (!this._dependencies) {\n            const result = new Set();\n            const events = this.getEvents();\n            const numberOfEvents = events.length;\n            let prevEvent = events[0], dependency;\n            if (numberOfEvents === 1) {\n                if ((dependency = this.getDependencyForSourceAndTargetEvents(prevEvent, prevEvent))) {\n                    result.add(dependency);\n                }\n            }\n            else {\n                for (const event1 of events) {\n                    for (const event2 of events) {\n                        if ((dependency = this.getDependencyForSourceAndTargetEvents(event1, event2))) {\n                            result.add(dependency);\n                        }\n                        if ((dependency = this.getDependencyForSourceAndTargetEvents(event2, event1))) {\n                            result.add(dependency);\n                        }\n                    }\n                }\n            }\n            this._dependencies = [...result];\n        }\n        return this._dependencies;\n    }\n    /**\n     * Returns list of the cycle possible resolutions.\n     *\n     * The class provides a single parameterized [[RemoveDependencyCycleEffectResolution]] resolution\n     * which implement removal of one of the [[getDependencies|dependencies]].\n     */\n    getResolutions() {\n        if (!this._resolutions) {\n            this._resolutions = [this.removeDependencyCycleEffectResolutionClass.new()];\n        }\n        return this._resolutions;\n    }\n}\n__decorate([\n    prototypeValue('cycle')\n], CycleEffect.prototype, \"type\", void 0);\n__decorate([\n    prototypeValue(CycleEffectDescription)\n], CycleEffect.prototype, \"_descriptionBuilderClass\", void 0);\n__decorate([\n    prototypeValue(RemoveDependencyCycleEffectResolution)\n], CycleEffect.prototype, \"removeDependencyCycleEffectResolutionClass\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { generic_field } from '../../../../ChronoGraph/replica/Entity.js';\nimport { ModelReferenceField, injectStaticFieldsProperty, isSerializableEqual } from '../../../chrono/ModelFieldAtom.js';\nimport { ChronoPartOfProjectModelMixin } from '../mixin/ChronoPartOfProjectModelMixin.js';\n/**\n * Base assignment model class. It just contains references to the [[BaseEventMixin|event]] and [[BaseResourceMixin|resource]] being assigned.\n */\nexport class BaseAssignmentMixin extends Mixin([ChronoPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseAssignmentMixin extends base {\n    }\n    __decorate([\n        generic_field({\n            bucket: 'assigned',\n            resolver: function (id) { return this.getEventById(id); },\n            modelFieldConfig: {\n                serialize: event => event?.id,\n                isEqual: isSerializableEqual,\n                persist: false\n            }\n        }, ModelReferenceField)\n    ], BaseAssignmentMixin.prototype, \"event\", void 0);\n    __decorate([\n        generic_field({\n            bucket: 'assigned',\n            resolver: function (id) { return this.getResourceById(id); },\n            modelFieldConfig: {\n                serialize: resource => resource?.id,\n                isEqual: isSerializableEqual,\n                persist: false\n            }\n        }, ModelReferenceField)\n    ], BaseAssignmentMixin.prototype, \"resource\", void 0);\n    // inject \"fields\" getter override to apply \"modelFieldConfig\" to \"event\" & \"resource\" fields\n    injectStaticFieldsProperty(BaseAssignmentMixin);\n    return BaseAssignmentMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { BaseAssignmentMixin } from \"../model/scheduler_basic/BaseAssignmentMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractAssignmentStoreMixin } from \"./AbstractAssignmentStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all assignments in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoAssignmentStoreMixin extends Mixin([AbstractAssignmentStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoAssignmentStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 100;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: BaseAssignmentMixin\n            };\n        }\n        set data(value) {\n            this.allAssignmentsForRemoval = true;\n            super.data = value;\n            this.allAssignmentsForRemoval = false;\n        }\n    }\n    return ChronoAssignmentStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { BaseCalendarMixin } from \"../model/scheduler_basic/BaseCalendarMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractCalendarManagerStoreMixin } from \"./AbstractCalendarManagerStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all calendars in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoCalendarManagerStoreMixin extends Mixin([AbstractCalendarManagerStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoCalendarManagerStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 500;\n        }\n        static get defaultConfig() {\n            return {\n                tree: true,\n                modelClass: BaseCalendarMixin\n            };\n        }\n    }\n    return ChronoCalendarManagerStoreMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractDependencyStoreMixin } from \"./AbstractDependencyStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all dependencies in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoDependencyStoreMixin extends Mixin([AbstractDependencyStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoDependencyStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 200;\n        }\n        set data(value) {\n            this.allDependenciesForRemoval = true;\n            super.data = value;\n            this.allDependenciesForRemoval = false;\n        }\n    }\n    return ChronoDependencyStoreMixin;\n}) {\n}\n", "import { CycleResolutionInputChrono } from \"../../../../ChronoGraph/chrono/CycleResolver.js\";\nimport { CalculatedValueGen } from \"../../../../ChronoGraph/chrono/Identifier.js\";\nimport { CalculateProposed, CycleDescription, CycleResolution, Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { FieldIdentifier } from \"../../../../ChronoGraph/replica/Identifier.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport var Instruction;\n(function (Instruction) {\n    Instruction[\"KeepDuration\"] = \"KeepDuration\";\n    Instruction[\"KeepStartDate\"] = \"KeepStartDate\";\n    Instruction[\"KeepEndDate\"] = \"KeepEndDate\";\n})(Instruction || (Instruction = {}));\n//---------------------------------------------------------------------------------------------------------------------\nexport const StartDateVar = Symbol('StartDate');\nexport const EndDateVar = Symbol('EndDate');\nexport const DurationVar = Symbol('Duration');\n//---------------------------------------------------------------------------------------------------------------------\nexport const startDateFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([DurationVar, EndDateVar])\n});\nexport const endDateFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([DurationVar, StartDateVar])\n});\nexport const durationFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartDateVar, EndDateVar])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport const SEDGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar]),\n    formulas: new Set([startDateFormula, endDateFormula, durationFormula])\n});\nexport const SEDForwardCycleResolutionContext = CycleResolution.new({\n    description: SEDGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula])\n});\nexport const SEDBackwardCycleResolutionContext = CycleResolution.new({\n    description: SEDGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDDispatcher extends CycleResolutionInputChrono {\n    addInstruction(instruction) {\n        if (instruction === Instruction.KeepStartDate)\n            this.addKeepIfPossibleFlag(StartDateVar);\n        if (instruction === Instruction.KeepEndDate)\n            this.addKeepIfPossibleFlag(EndDateVar);\n        if (instruction === Instruction.KeepDuration)\n            this.addKeepIfPossibleFlag(DurationVar);\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDDispatcherIdentifier extends FieldIdentifier.mix(CalculatedValueGen) {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        const res = resolution1.get(StartDateVar) === resolution2.get(StartDateVar)\n            && resolution1.get(EndDateVar) === resolution2.get(EndDateVar)\n            && resolution1.get(DurationVar) === resolution2.get(DurationVar)\n            || (\n            // https://github.com/bryntum/support/issues/6262\n            // for the unscheduled tasks (missing all 3 values), resolution of the `v1` will be \"keep all proposed\"\n            // which is always different from the default resolution\n            // this leads to the dispatcher identifiers remaining \"self-dependent\" and re-calculated at every commit\n            // process this case specially\n            // note, that this is more a patch, a proper solution would probably be to change this line:\n            // chronograph/src/chrono/CycleResolver.ts\n            //      if (Y(PreviousValueOf(identifier)) != null) this.addPreviousValueFlag(symbol)\n            // to\n            //      if (Y(PreviousValueOf(identifier)) !== undefined) this.addPreviousValueFlag(symbol)\n            // however this breaks normalization tests\n            resolution1.get(StartDateVar) === CalculateProposed\n                && resolution1.get(EndDateVar) === CalculateProposed\n                && resolution1.get(DurationVar) === CalculateProposed);\n        return res;\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field, generic_field, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { CalendarCacheMultiple } from \"../../../calendar/CalendarCacheMultiple.js\";\nimport { injectStaticFieldsProperty, isSerializableEqual, ModelReferenceField } from '../../../chrono/ModelFieldAtom.js';\nimport { stripDuplicates } from \"../../../util/StripDuplicates.js\";\nimport { ChronoPartOfProjectModelMixin } from \"../mixin/ChronoPartOfProjectModelMixin.js\";\nimport { BaseCalendarMixin } from \"./BaseCalendarMixin.js\";\n/**\n * This mixin provides the calendar to any [[ChronoPartOfProjectModelMixin]] it is mixed in.\n *\n * If user provides no calendar, the calendar is taken from the project.\n */\nexport class HasCalendarMixin extends Mixin([ChronoPartOfProjectModelMixin], (base) => {\n    class HasCalendarMixin extends base {\n        writeCalendar(me, transaction, quark, calendar) {\n            const calendarManagerStore = this.getCalendarManagerStore();\n            const cal = calendar;\n            // add calendar to the calendar manager - if the calendar is not there yet\n            if (calendar && calendarManagerStore && calendar instanceof BaseCalendarMixin && !calendarManagerStore.includes(cal)) {\n                calendarManagerStore.add(calendar);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, calendar);\n        }\n        resolveCalendar(locator) {\n            return this.getCalendarManagerStore()?.getById(locator);\n        }\n        /**\n         * Calculation method of the [[effectiveCalendar]]. Takes the calendar from the project, if not provided to the entity explicitly.\n         */\n        *calculateEffectiveCalendar() {\n            let calendar = yield this.$.calendar;\n            if (!calendar) {\n                const project = this.getProject();\n                calendar = yield project.$.effectiveCalendar;\n            }\n            // this will create an incoming edge from the calendar's version atom, which changes on calendar's data update\n            yield calendar.$.version;\n            return calendar;\n        }\n        //region STM hooks\n        shouldRecordFieldChange(fieldName, oldValue, newValue) {\n            if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {\n                return false;\n            }\n            const { project } = this;\n            // If that's a \"calendar\" field change - make sure it does refer to some other record\n            // and not just reacts to old record idChange\n            if (fieldName === 'calendar' && project) {\n                const { calendarManagerStore } = project;\n                return calendarManagerStore.oldIdMap[oldValue] !== calendarManagerStore.getById(newValue);\n            }\n            return true;\n        }\n    }\n    __decorate([\n        field({\n            equality: () => false\n        })\n    ], HasCalendarMixin.prototype, \"effectiveCalendar\", void 0);\n    __decorate([\n        generic_field({\n            modelFieldConfig: {\n                persist: true,\n                // we don't use calendar?.id here since we need to preserve calendar==null value\n                // while optional chaining will result undefined in this case\n                serialize: calendar => calendar === undefined ? undefined : (calendar?.id || null),\n                isEqual: isSerializableEqual\n            },\n            resolver: function (locator) {\n                return this.resolveCalendar(locator);\n            },\n            sync: true\n        }, ModelReferenceField)\n    ], HasCalendarMixin.prototype, \"calendar\", void 0);\n    __decorate([\n        write('calendar')\n    ], HasCalendarMixin.prototype, \"writeCalendar\", null);\n    __decorate([\n        calculate('effectiveCalendar')\n    ], HasCalendarMixin.prototype, \"calculateEffectiveCalendar\", null);\n    // inject \"fields\" getter override to apply \"modelFieldConfig\" to \"event\" & \"resource\" fields\n    injectStaticFieldsProperty(HasCalendarMixin);\n    return HasCalendarMixin;\n}) {\n}\n/**\n * This mixin provides the consuming class with the [[combineCalendars]] method, which can combine several calendars.\n */\nexport class CanCombineCalendarsMixin extends Mixin([], (base) => {\n    class CanCombineCalendars extends base {\n        constructor() {\n            super(...arguments);\n            this.combinedcalendarscache = new Map();\n        }\n        /**\n         * Combines an array of calendars into a single [[CalendarCacheMultiple]], which provides an API similar (but not exactly the same) to [[BaseCalendarMixin]]\n         *\n         * @param calendars\n         */\n        combineCalendars(calendars) {\n            const uniqueOnly = stripDuplicates(calendars);\n            if (uniqueOnly.length === 0)\n                throw new Error(\"No calendars to combine\");\n            uniqueOnly.sort((calendar1, calendar2) => {\n                if (calendar1.internalId < calendar2.internalId)\n                    return -1;\n                else\n                    return 1;\n            });\n            const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');\n            const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');\n            const cached = this.combinedcalendarscache.get(hash);\n            let res;\n            if (cached && cached.versionsHash === versionsHash)\n                res = cached.cache;\n            else {\n                res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache) });\n                this.combinedcalendarscache.set(hash, {\n                    versionsHash: versionsHash,\n                    cache: res\n                });\n            }\n            return res;\n        }\n    }\n    return CanCombineCalendars;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedArgumentsOf, ProposedOrPrevious, ProposedOrPreviousValueOf, Reject, Write } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalculateProposed } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { build_proposed, calculate, field, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\nimport { dateConverter, model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { Direction, TimeUnit } from \"../../../scheduling/Types.js\";\nimport { isNotNumber } from \"../../../util/Functions.js\";\nimport { EmptyCalendarEffect } from \"./BaseCalendarMixin.js\";\nimport { durationFormula, DurationVar, endDateFormula, EndDateVar, Instruction, SEDBackwardCycleResolutionContext, SEDDispatcher, SEDDispatcherIdentifier, SEDForwardCycleResolutionContext, startDateFormula, StartDateVar } from \"./BaseEventDispatcher.js\";\nimport { HasCalendarMixin } from \"./HasCalendarMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Base event entity mixin type.\n *\n * At this level event is only aware about its calendar (which is inherited from project, if not provided).\n * The functionality, related to the dependencies, constraints etc is provided in other mixins.\n *\n * A time interval will be \"counted\" into the event duration, only if the event's calendar has that interval\n * as working. Otherwise the time is skipped and not counted into event's duration.\n *\n */\nexport class BaseEventMixin extends Mixin([HasCalendarMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseEventMixin extends base {\n        *calculateDispatcher(YIELD) {\n            // this value is not used directly, but it contains a default cycle resolution\n            // if we calculate different resolution, dispatcher will be marked dirty\n            // on next revision\n            const proposed = yield ProposedOrPrevious;\n            const cycleDispatcher = yield* this.prepareDispatcher(YIELD);\n            //--------------\n            const startDateProposedArgs = yield ProposedArgumentsOf(this.$.startDate);\n            const startInstruction = startDateProposedArgs ? (startDateProposedArgs[0] ? Instruction.KeepDuration : Instruction.KeepEndDate) : undefined;\n            if (startInstruction)\n                cycleDispatcher.addInstruction(startInstruction);\n            //--------------\n            const endDateProposedArgs = yield ProposedArgumentsOf(this.$.endDate);\n            const endInstruction = endDateProposedArgs ? (endDateProposedArgs[0] ? Instruction.KeepDuration : Instruction.KeepStartDate) : undefined;\n            if (endInstruction)\n                cycleDispatcher.addInstruction(endInstruction);\n            //--------------\n            const directionValue = yield this.$.direction;\n            const durationProposedArgs = yield ProposedArgumentsOf(this.$.duration);\n            let durationInstruction;\n            if (durationProposedArgs) {\n                switch (durationProposedArgs[0]) {\n                    case true:\n                        durationInstruction = Instruction.KeepStartDate;\n                        break;\n                    case false:\n                        durationInstruction = Instruction.KeepEndDate;\n                        break;\n                }\n            }\n            if (!durationInstruction && cycleDispatcher.hasProposedValue(DurationVar)) {\n                durationInstruction = directionValue === Direction.Forward || directionValue === Direction.None ? Instruction.KeepStartDate : Instruction.KeepEndDate;\n            }\n            if (durationInstruction)\n                cycleDispatcher.addInstruction(durationInstruction);\n            return cycleDispatcher;\n        }\n        *prepareDispatcher(Y) {\n            const dispatcherClass = this.dispatcherClass(Y);\n            const cycleDispatcher = dispatcherClass.new({\n                context: this.cycleResolutionContext(Y)\n            });\n            cycleDispatcher.collectInfo(Y, this.$.startDate, StartDateVar);\n            cycleDispatcher.collectInfo(Y, this.$.endDate, EndDateVar);\n            cycleDispatcher.collectInfo(Y, this.$.duration, DurationVar);\n            return cycleDispatcher;\n        }\n        cycleResolutionContext(Y) {\n            const direction = Y(this.$.direction);\n            return direction === Direction.Forward || direction === Direction.None ? SEDForwardCycleResolutionContext : SEDBackwardCycleResolutionContext;\n        }\n        dispatcherClass(Y) {\n            return SEDDispatcher;\n        }\n        buildProposedDispatcher(me, quark, transaction) {\n            const dispatcher = this.dispatcherClass(transaction.onEffectSync).new({\n                context: this.cycleResolutionContext(transaction.onEffectSync)\n            });\n            dispatcher.addPreviousValueFlag(StartDateVar);\n            dispatcher.addPreviousValueFlag(EndDateVar);\n            dispatcher.addPreviousValueFlag(DurationVar);\n            return dispatcher;\n        }\n        /**\n         * The method skips the event non working time starting from the provided `date` and\n         * going either _forward_ or _backward_ in time.\n         * It uses the event [[effectiveCalendar|effective calendar]] to detect which time is not working.\n         * @param date Date to start skipping from\n         * @param isForward Skip direction (`true` to go forward in time, `false` - backwards)\n         */\n        *skipNonWorkingTime(date, isForward) {\n            const calendar = yield this.$.effectiveCalendar;\n            if (!date)\n                return null;\n            const skippingRes = calendar.skipNonWorkingTime(date, isForward);\n            if (skippingRes instanceof Date) {\n                return skippingRes;\n            }\n            else {\n                const effect = EmptyCalendarEffect.new({\n                    calendars: [calendar],\n                    event: this,\n                    date,\n                    isForward\n                });\n                if ((yield effect) === EffectResolutionResult.Cancel) {\n                    yield Reject(effect);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        /**\n         * The method skips the provided amount of the event _working time_\n         * starting from the `date` and going either _forward_ or _backward_ in time.\n         * It uses the event [[effectiveCalendar|effective calendar]] to detect which time is not working.\n         * @param date Date to start skipping from\n         * @param isForward Skip direction (`true` to go forward in time, `false` - backwards)\n         * @param duration Amount of working time to skip\n         * @param unit Units the `duration` value in (if not provided then duration is considered provided in [[durationUnit]])\n         */\n        *skipWorkingTime(date, isForward, duration, unit) {\n            const durationUnit = yield this.$.durationUnit;\n            // Convert duration to duration unit if needed\n            if (unit && unit !== durationUnit) {\n                duration = yield* this.getProject().$convertDuration(duration, unit, durationUnit);\n            }\n            return yield* this.calculateProjectedXDateWithDuration(date, isForward, duration);\n        }\n        // copied generated method, to avoid compilation error when it is overridden in HasDateConstraintMixin\n        /**\n         * Sets the event [[startDate|start date]]\n         *\n         * @param date The new start date to set\n         * @param keepDuration Whether the intention is to keep the `duration` field (`keepDuration = true`) or `endDate` (`keepDuration = false`)\n         */\n        setStartDate(date, keepDuration = true) {\n            const { graph, project } = this;\n            if (graph) {\n                graph.write(this.$.startDate, date, keepDuration);\n                return graph.commitAsync();\n            }\n            else {\n                this.$.startDate.DATA = date;\n                // Possibly about to enter replica, wait for that\n                return project?.delayedCalculationPromise;\n            }\n        }\n        writeStartDate(me, transaction, quark, date, keepDuration = true) {\n            // we use the approach, that when user sets some atom to `null`\n            // that `null` is propagated as a normal valid value through all calculation formulas\n            // turning the result of all calculations to `null`\n            // this works well, except the initial data load case, when don't want to do such propagation\n            // but instead wants to \"normalize\" the data\n            // because of that we ignore the `null` writes, for the initial data load case\n            if (!transaction.baseRevision.hasIdentifier(me) && date == null)\n                return;\n            if (!this.getProject().isStmRestoring) {\n                // this is basically: this.unscheduled = date == null, however it will work with branches\n                this.$.unscheduled.write(this.$.unscheduled, transaction, undefined, date == null);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);\n        }\n        /**\n         * The main calculation method for the [[startDate]] field. Delegates to either [[calculateStartDateProposed]]\n         * or [[calculateStartDatePure]], depending on the information from [[dispatcher]]\n         */\n        *calculateStartDate() {\n            const dispatch = yield this.$.dispatcher;\n            const formulaId = dispatch.resolution.get(StartDateVar);\n            if (formulaId === CalculateProposed) {\n                return yield* this.calculateStartDateProposed();\n            }\n            else if (formulaId === startDateFormula.formulaId) {\n                return yield* this.calculateStartDatePure();\n            }\n            else {\n                throw new Error(\"Unknown formula for `startDate`\");\n            }\n        }\n        /**\n         * The \"pure\" calculation function of the [[startDate]] field. It should calculate the [[startDate]] as if\n         * there's no user input for it and no previous value - \"purely\" based on the values of other fields.\n         *\n         * At this level it delegates to [[calculateProjectedXDateWithDuration]]\n         *\n         * See also [[calculateStartDateProposed]].\n         */\n        *calculateStartDatePure() {\n            return yield* this.calculateProjectedXDateWithDuration(yield this.$.endDate, false, yield this.$.duration);\n        }\n        /**\n         * The \"proposed\" calculation function of the [[startDate]] field. It should calculate the [[startDate]] as if\n         * there's a user input for it or a previous value. It can also use the values of other fields to \"validate\"\n         * the \"proposed\" value.\n         *\n         * See also [[calculateStartDatePure]]\n         */\n        *calculateStartDateProposed() {\n            const project = this.getProject();\n            const startDate = yield ProposedOrPrevious;\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return (!manuallyScheduled || project.skipNonWorkingTimeWhenSchedulingManually) ? yield* this.skipNonWorkingTime(startDate, true) : startDate;\n        }\n        /**\n         * This method calculates the opposite date of the event.\n         *\n         * @param baseDate The base date of the event (start or end date)\n         * @param isForward Boolean flag, indicating whether the given `baseDate` is start date (`true`) or end date (`false`)\n         * @param duration Duration of the event, in its [[durationUnit|durationUnits]]\n         */\n        *calculateProjectedXDateWithDuration(baseDate, isForward, duration) {\n            const durationUnit = yield this.$.durationUnit;\n            const calendar = yield this.$.effectiveCalendar;\n            const project = this.getProject();\n            if (!baseDate || isNotNumber(duration))\n                return null;\n            // calculate forward by default\n            isForward = isForward === undefined ? true : isForward;\n            if (isForward) {\n                return calendar.calculateEndDate(baseDate, yield* project.$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n            }\n            else {\n                return calendar.calculateStartDate(baseDate, yield* project.$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n            }\n        }\n        // copied generated method, to specify the default value for `keepDuration`\n        // and to avoid compilation error when it is overridden in HasDateConstraintMixin\n        /**\n         * Sets the event [[endDate|end date]].\n         *\n         * @param date The new end date to set\n         * @param keepDuration Whether the intention is to keep the `duration` field (`keepDuration = true`) or `startDate` (`keepDuration = false`)\n         */\n        setEndDate(date, keepDuration = false) {\n            const { graph, project } = this;\n            if (graph) {\n                graph.write(this.$.endDate, date, keepDuration);\n                return graph.commitAsync();\n            }\n            else {\n                this.$.endDate.DATA = date;\n                // Possibly about to enter replica, wait for that\n                return project?.delayedCalculationPromise;\n            }\n        }\n        writeEndDate(me, transaction, quark, date, keepDuration = false) {\n            if (!transaction.baseRevision.hasIdentifier(me) && date == null)\n                return;\n            if (!this.getProject().isStmRestoring) {\n                // this is basically: this.unscheduled = date == null, however it will work with branches\n                this.$.unscheduled.write(this.$.unscheduled, transaction, undefined, date == null);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);\n        }\n        /**\n         * The main calculation method for the [[endDate]] field. Delegates to either [[calculateEndDateProposed]]\n         * or [[calculateEndDatePure]], depending on the information from [[dispatcher]]\n         */\n        *calculateEndDate() {\n            const dispatch = yield this.$.dispatcher;\n            const formulaId = dispatch.resolution.get(EndDateVar);\n            if (formulaId === CalculateProposed) {\n                return yield* this.calculateEndDateProposed();\n            }\n            else if (formulaId === endDateFormula.formulaId) {\n                return yield* this.calculateEndDatePure();\n                // the \"new way\" would be\n                // return yield* this.calculateProjectedEndDateWithDuration(yield this.$.startDate, yield this.$.duration)\n            }\n            else {\n                throw new Error(\"Unknown formula for `endDate`\");\n            }\n        }\n        /**\n         * The \"pure\" calculation function of the [[endDate]] field. It should calculate the [[endDate]] as if\n         * there's no user input for it and no previous value - \"purely\" based on the values of other fields.\n         *\n         * At this level it delegates to [[calculateProjectedXDateWithDuration]]\n         *\n         * See also [[calculateEndDateProposed]].\n         */\n        *calculateEndDatePure() {\n            return yield* this.calculateProjectedXDateWithDuration(yield this.$.startDate, true, yield this.$.duration);\n        }\n        /**\n         * The \"proposed\" calculation function of the [[endDate]] field. It should calculate the [[endDate]] as if\n         * there's a user input for it or a previous value. It can also use the values of other fields to \"validate\"\n         * the \"proposed\" value.\n         *\n         * See also [[calculateEndDatePure]]\n         */\n        *calculateEndDateProposed() {\n            const project = this.getProject();\n            const endDate = yield ProposedOrPrevious;\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return (!manuallyScheduled || project.skipNonWorkingTimeWhenSchedulingManually) ? yield* this.skipNonWorkingTime(endDate, false) : endDate;\n        }\n        //endregion\n        //region duration\n        /**\n         * Duration getter. Returns the duration of the event, in the given unit. If unit is not given, returns duration in [[durationUnit]].\n         *\n         * @param unit\n         */\n        getDuration(unit) {\n            const duration = this.duration;\n            return unit !== undefined ? this.getProject().convertDuration(duration, this.durationUnit, unit) : duration;\n        }\n        /**\n         * Duration setter.\n         *\n         * @param duration The new duration to set.\n         * @param unit The unit for new duration. Optional, if missing the [[durationUnit]] value will be used.\n         * @param keepStart A boolean flag, indicating, whether the intention is to keep the start date (`true`) or end date (`false`)\n         */\n        setDuration(duration, unit, keepStart) {\n            const { graph, project } = this;\n            if (graph) {\n                // this check is performed just because the duration editor tries to apply `undefined` when\n                // an input is invalid (and we want to filter that out)\n                // in the same time, we want to allow input of empty string - (task \"unscheduling\")\n                // so for unscheduling case, the editor will apply a `null` value, for invalid - `undefined`\n                // this is a mess of course (if the value is invalid, editor should not be applying anything at all),\n                // but so is life\n                if (duration !== undefined) {\n                    graph.write(this.$.duration, duration, unit, keepStart);\n                    return graph.commitAsync();\n                }\n            }\n            else {\n                const toSet = { duration };\n                this.$.duration.DATA = duration;\n                if (unit != null)\n                    toSet.durationUnit = this.$.durationUnit.DATA = unit;\n                // Also has to make sure record data is updated in case this detached record is displayed elsewhere\n                this.set(toSet);\n                // Possibly about to enter replica, wait for that\n                return project?.delayedCalculationPromise;\n            }\n        }\n        setDurationUnit(_value) {\n            throw new Error(\"Use `setDuration` instead\");\n        }\n        writeDuration(me, transaction, quark, duration, unit, keepStart = undefined) {\n            if (duration < 0)\n                duration = 0;\n            if (!transaction.baseRevision.hasIdentifier(me) && duration == null)\n                return;\n            if (!this.getProject().isStmRestoring) {\n                // this is basically: this.unscheduled = date == null, however it will work with branches\n                this.$.unscheduled.write(this.$.unscheduled, transaction, undefined, duration == null);\n            }\n            me.constructor.prototype.write.call(this, me, transaction, quark, duration, keepStart);\n            if (unit != null)\n                transaction.write(this.$.durationUnit, unit);\n        }\n        /**\n         * The main calculation method for the [[duration]] field. Delegates to either [[calculateDurationProposed]]\n         * or [[calculateDurationPure]], depending on the information from [[dispatcher]]\n         */\n        *calculateDuration() {\n            const dispatch = yield this.$.dispatcher;\n            const formulaId = dispatch.resolution.get(DurationVar);\n            if (formulaId === CalculateProposed) {\n                return yield* this.calculateDurationProposed();\n            }\n            else if (formulaId === durationFormula.formulaId) {\n                return yield* this.calculateDurationPure();\n                // the \"new way\" would be\n                // return yield* this.calculateProjectedDuration(yield this.$.startDate, yield this.$.endDate)\n            }\n            else {\n                throw new Error(\"Unknown formula for `duration`\");\n            }\n        }\n        /**\n         * The \"pure\" calculation function of the [[duration]] field. It should calculate the [[duration]] as if\n         * there's no user input for it and no previous value - \"purely\" based on the values of other fields.\n         *\n         * If start date of event is less or equal then end date (normal case) it delegates to [[calculateProjectedDuration]].\n         * Otherwise, duration is set to 0.\n         *\n         * See also [[calculateDurationProposed]].\n         */\n        *calculateDurationPure() {\n            const startDate = yield this.$.startDate;\n            const endDate = yield this.$.endDate;\n            if (!startDate || !endDate)\n                return null;\n            if (startDate > endDate) {\n                yield Write(this.$.duration, 0, null);\n            }\n            else {\n                return yield* this.calculateProjectedDuration(startDate, endDate);\n            }\n        }\n        /**\n         * The \"proposed\" calculation function of the [[duration]] field. It should calculate the [[duration]] as if\n         * there's a user input for it or a previous value. It can also use the values of other fields to \"validate\"\n         * the \"proposed\" value.\n         *\n         * See also [[calculateDurationPure]]\n         */\n        *calculateDurationProposed() {\n            return yield ProposedOrPrevious;\n        }\n        /**\n         * This method calculates the duration of the given time span, in the provided `durationUnit` or in the [[durationUnit]].\n         *\n         * @param startDate\n         * @param endDate\n         * @param durationUnit\n         */\n        *calculateProjectedDuration(startDate, endDate, durationUnit) {\n            if (!startDate || !endDate)\n                return null;\n            if (!durationUnit)\n                durationUnit = yield this.$.durationUnit;\n            const calendar = yield this.$.effectiveCalendar;\n            const project = this.getProject();\n            return yield* project.$convertDuration(calendar.calculateDurationMs(startDate, endDate), TimeUnit.Millisecond, durationUnit);\n        }\n        // effective duration is either a \"normal\" duration, or, if the duration itself is being calculated\n        // (so that yielding it will cause a cycle)\n        // an \"estimated\" duration, calculated based on proposed/previous start/end date values\n        *calculateEffectiveDuration() {\n            const dispatch = yield this.$.dispatcher;\n            let effectiveDurationToUse;\n            const durationResolution = dispatch.resolution.get(DurationVar);\n            if (durationResolution === CalculateProposed) {\n                effectiveDurationToUse = yield this.$.duration;\n            }\n            else if (durationResolution === durationFormula.formulaId) {\n                effectiveDurationToUse = yield* this.calculateProjectedDuration(yield ProposedOrPreviousValueOf(this.$.startDate), yield ProposedOrPreviousValueOf(this.$.endDate));\n            }\n            return effectiveDurationToUse;\n        }\n        //endregion\n        *calculateEffectiveCalendar() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const project = this.getProject();\n            return manuallyScheduled && !project.skipNonWorkingTimeInDurationWhenSchedulingManually\n                ? project.defaultCalendar\n                : yield* super.calculateEffectiveCalendar();\n        }\n    }\n    __decorate([\n        model_field({ type: 'date' }, { converter: dateConverter })\n    ], BaseEventMixin.prototype, \"startDate\", void 0);\n    __decorate([\n        model_field({ type: 'date' }, { converter: dateConverter })\n    ], BaseEventMixin.prototype, \"endDate\", void 0);\n    __decorate([\n        model_field({ type: 'number', allowNull: true })\n    ], BaseEventMixin.prototype, \"duration\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: TimeUnit.Day }, { converter: (unit) => DateHelper.normalizeUnit(unit) || TimeUnit.Day })\n    ], BaseEventMixin.prototype, \"durationUnit\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: Direction.Forward }, { sync: true })\n    ], BaseEventMixin.prototype, \"direction\", void 0);\n    __decorate([\n        field({ identifierCls: SEDDispatcherIdentifier })\n    ], BaseEventMixin.prototype, \"dispatcher\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: false })\n    ], BaseEventMixin.prototype, \"manuallyScheduled\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: false })\n    ], BaseEventMixin.prototype, \"unscheduled\", void 0);\n    __decorate([\n        calculate('dispatcher')\n    ], BaseEventMixin.prototype, \"calculateDispatcher\", null);\n    __decorate([\n        build_proposed('dispatcher')\n    ], BaseEventMixin.prototype, \"buildProposedDispatcher\", null);\n    __decorate([\n        write('startDate')\n    ], BaseEventMixin.prototype, \"writeStartDate\", null);\n    __decorate([\n        calculate('startDate')\n    ], BaseEventMixin.prototype, \"calculateStartDate\", null);\n    __decorate([\n        write('endDate')\n    ], BaseEventMixin.prototype, \"writeEndDate\", null);\n    __decorate([\n        calculate('endDate')\n    ], BaseEventMixin.prototype, \"calculateEndDate\", null);\n    __decorate([\n        write('duration')\n    ], BaseEventMixin.prototype, \"writeDuration\", null);\n    __decorate([\n        calculate('duration')\n    ], BaseEventMixin.prototype, \"calculateDuration\", null);\n    return BaseEventMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { generic_field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { ModelBucketField } from \"../../../chrono/ModelFieldAtom.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\nimport { AbstractHasAssignmentsMixin } from '../AbstractHasAssignmentsMixin.js';\n/**\n * This is a mixin, which can be applied to the [[BaseEventMixin]]. It provides the collection of all assignments,\n * which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class BaseHasAssignmentsMixin extends Mixin([BaseEventMixin, AbstractHasAssignmentsMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseHasAssignmentsMixin extends base {\n        get assignments() {\n            return this.assigned ? [...this.assigned] : [];\n        }\n    }\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], BaseHasAssignmentsMixin.prototype, \"assigned\", void 0);\n    return BaseHasAssignmentsMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { generic_field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { ModelBucketField } from \"../../../chrono/ModelFieldAtom.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\n/**\n * This is a mixin, providing dependencies \"awareness\" for the event.\n *\n * Doesn't affect scheduling.\n */\nexport class HasDependenciesMixin extends Mixin([BaseEventMixin], (base) => {\n    const superProto = base.prototype;\n    class HasDependenciesMixin extends base {\n        leaveProject() {\n            // if the model is in the graph, so we are able to read its identifiers\n            if (this.isInActiveTransaction) {\n                const activeTransaction = this.graph.activeTransaction;\n                const dependencyStore = this.getDependencyStore();\n                const toRemove = [];\n                // https://github.com/bryntum/support/issues/6099\n                // use only calculated values, avoid triggering calculations\n                // (if calculation is needed, that probably means, that a dependency from the opposite side\n                // has been removed earlier in this transaction)\n                // trigger calculation will start a new epoch in the graph walker\n                // so large part of the graph will be repeatedly marked as dirty\n                // also filter to only existing, not yet removed records, otherwise STM records those as\n                // valid removes(?) and \"excessive rendering\" appears in the \"examples/advanced.t.js\" Gantt test\n                // (also not clear how that is related)\n                for (const dep of activeTransaction.readCurrentOrProposedOrPrevious(this.$.outgoingDeps) ?? [])\n                    if (dependencyStore.includes(dep))\n                        toRemove.push(dep);\n                for (const dep of activeTransaction.readCurrentOrProposedOrPrevious(this.$.incomingDeps) ?? [])\n                    if (dependencyStore.includes(dep))\n                        toRemove.push(dep);\n                this.project.dependencyStore.remove(toRemove);\n            }\n            superProto.leaveProject.call(this);\n        }\n    }\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], HasDependenciesMixin.prototype, \"outgoingDeps\", void 0);\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], HasDependenciesMixin.prototype, \"incomingDeps\", void 0);\n    return HasDependenciesMixin;\n}) {\n}\n", "import { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { BaseEventMixin } from './BaseEventMixin.js';\nimport { BaseHasAssignmentsMixin } from \"./BaseHasAssignmentsMixin.js\";\nimport { HasDependenciesMixin } from './HasDependenciesMixin.js';\n/**\n * This is an event class, [[SchedulerBasicProjectMixin]] is working with.\n * It is constructed as [[BaseEventMixin]], enhanced with [[BaseHasAssignmentsMixin]] and [[HasDependenciesMixin]]\n */\nexport class SchedulerBasicEvent extends Mixin([\n    BaseEventMixin,\n    BaseHasAssignmentsMixin,\n    HasDependenciesMixin\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerBasicEvent extends base {\n    }\n    return SchedulerBasicEvent;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerBasicEvent } from \"../model/scheduler_basic/SchedulerBasicEvent.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractEventStoreMixin } from \"./AbstractEventStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all events in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoEventStoreMixin extends Mixin([AbstractEventStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    class ChronoEventStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 400;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: SchedulerBasicEvent\n            };\n        }\n        set data(value) {\n            super.data = value;\n            this.afterEventRemoval();\n        }\n    }\n    return ChronoEventStoreMixin;\n}) {\n}\n/**\n * The tree store version of [[ChronoEventStoreMixin]].\n */\nexport class ChronoEventTreeStoreMixin extends Mixin([ChronoEventStoreMixin], (base) => {\n    class ChronoEventTreeStoreMixin extends base {\n        buildRootNode() {\n            return this.getProject() || {};\n        }\n        static get defaultConfig() {\n            return {\n                tree: true\n            };\n        }\n    }\n    return ChronoEventTreeStoreMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { generic_field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { ModelBucketField } from '../../../chrono/ModelFieldAtom.js';\nimport { ChronoPartOfProjectModelMixin } from '../mixin/ChronoPartOfProjectModelMixin.js';\nimport { HasCalendarMixin } from './HasCalendarMixin.js';\n/**\n * This is a base resource entity.\n */\nexport class BaseResourceMixin extends Mixin([HasCalendarMixin, ChronoPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseResourceMixin extends base {\n        get assignments() {\n            return [...this.assigned];\n        }\n        leaveProject(isReplacing = false) {\n            // `this.assigned` will be empty if model is added to project and then removed immediately\n            // w/o any propagations\n            // when replacing a resource, the assignments should be left intact\n            if (!this.isStmRestoring && this.assigned && !isReplacing) {\n                const resourceStore = this.getResourceStore();\n                // to batch the assignments removal, we don't remove the assignments right away, but instead\n                // add them for the batched removal to the `assignmentsForRemoval` property of the event store\n                this.assigned.forEach(assignment => resourceStore.assignmentsForRemoval.add(assignment));\n            }\n            superProto.leaveProject.call(this);\n        }\n        // resource model should support the \"tree mode\" in the same way as event model\n        static get fields() {\n            return [\n                { name: 'parentId' },\n                { name: 'children', persist: false }\n            ];\n        }\n    }\n    __decorate([\n        generic_field({}, ModelBucketField)\n    ], BaseResourceMixin.prototype, \"assigned\", void 0);\n    return BaseResourceMixin;\n}) {\n}\n", "import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { BaseResourceMixin } from \"../model/scheduler_basic/BaseResourceMixin.js\";\nimport { ChronoPartOfProjectStoreMixin } from \"./mixin/ChronoPartOfProjectStoreMixin.js\";\nimport { AbstractResourceStoreMixin } from \"./AbstractResourceStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all resources in the [[SchedulerBasicProjectMixin|project]].\n */\nexport class ChronoResourceStoreMixin extends Mixin([AbstractResourceStoreMixin, ChronoPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoResourceStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.removalOrder = 300;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: BaseResourceMixin\n            };\n        }\n    }\n    return ChronoResourceStoreMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field } from \"../../ChronoGraph/replica/Entity.js\";\nimport { ChronoModelMixin } from \"../chrono/ChronoModelMixin.js\";\nimport { model_field } from \"../chrono/ModelFieldAtom.js\";\n/**\n * This mixin provides the duration converting functionality - the [[convertDuration]] method. It requires (inherit from) [[ChronoModelMixin]].\n */\nexport class DurationConverterMixin extends Mixin([ChronoModelMixin], (base) => {\n    const superProto = base.prototype;\n    class DurationConverterMixin extends base {\n        *calculateUnitsInMs() {\n            const hoursPerDay = yield this.$.hoursPerDay;\n            const daysPerWeek = yield this.$.daysPerWeek;\n            const daysPerMonth = yield this.$.daysPerMonth;\n            return {\n                millisecond: 1,\n                second: 1000,\n                minute: 60 * 1000,\n                hour: 60 * 60 * 1000,\n                day: hoursPerDay * 60 * 60 * 1000,\n                week: daysPerWeek * hoursPerDay * 60 * 60 * 1000,\n                month: daysPerMonth * hoursPerDay * 60 * 60 * 1000,\n                quarter: 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1000,\n                year: 4 * 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1000\n            };\n        }\n        /**\n         * Converts duration value from one time unit to another\n         * @param duration Duration value\n         * @param fromUnit Duration value time unit\n         * @param toUnit   Target time unit to convert the value to\n         */\n        convertDuration(duration, fromUnit, toUnit) {\n            let result = duration;\n            if (fromUnit !== toUnit) {\n                result = duration * this.unitsInMs[fromUnit] / this.unitsInMs[toUnit];\n            }\n            return result;\n        }\n        *$convertDuration(duration, fromUnit, toUnit) {\n            if (!fromUnit || !toUnit)\n                throw new Error(\"Conversion unit not provided\");\n            const unitsInMs = yield this.$.unitsInMs;\n            let result = duration;\n            if (fromUnit !== toUnit) {\n                result = duration * unitsInMs[fromUnit] / unitsInMs[toUnit];\n            }\n            return result;\n        }\n    }\n    __decorate([\n        field()\n    ], DurationConverterMixin.prototype, \"unitsInMs\", void 0);\n    __decorate([\n        model_field({ type: 'number', defaultValue: 24 })\n    ], DurationConverterMixin.prototype, \"hoursPerDay\", void 0);\n    __decorate([\n        model_field({ type: 'number', defaultValue: 7 })\n    ], DurationConverterMixin.prototype, \"daysPerWeek\", void 0);\n    __decorate([\n        model_field({ type: 'number', defaultValue: 30 })\n    ], DurationConverterMixin.prototype, \"daysPerMonth\", void 0);\n    __decorate([\n        calculate('unitsInMs')\n    ], DurationConverterMixin.prototype, \"calculateUnitsInMs\", null);\n    return DurationConverterMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { generic_field } from '../../../../ChronoGraph/replica/Entity.js';\nimport { model_field, ModelReferenceField, isSerializableEqual } from '../../../chrono/ModelFieldAtom.js';\nimport { DependencyType } from '../../../scheduling/Types.js';\nimport { ChronoPartOfProjectModelMixin } from '../mixin/ChronoPartOfProjectModelMixin.js';\n/**\n * Base dependency entity mixin type\n */\nexport class BaseDependencyMixin extends Mixin([ChronoPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class BaseDependencyMixin extends base {\n        get isValid() {\n            const { $, graph } = this;\n            // In case the dependency is added but causes a conflict, fromEvent/toEvent are not in the graph. Thus\n            // reading them causes an exception which we want to avoid.\n            // This is caught sporadically by 10_handling.t.js in SchedulerPro\n            if (graph && (!graph.hasIdentifier($.fromEvent) || !graph.hasIdentifier($.toEvent))) {\n                return false;\n            }\n            return super.isValid;\n        }\n    }\n    __decorate([\n        generic_field({\n            bucket: 'outgoingDeps',\n            resolver: function (id) { return this.getEventById(id); },\n            modelFieldConfig: {\n                persist: true,\n                serialize: event => event?.id,\n                isEqual: isSerializableEqual\n            },\n        }, ModelReferenceField)\n    ], BaseDependencyMixin.prototype, \"fromEvent\", void 0);\n    __decorate([\n        generic_field({\n            bucket: 'incomingDeps',\n            resolver: function (id) { return this.getEventById(id); },\n            modelFieldConfig: {\n                persist: true,\n                serialize: event => event?.id,\n                isEqual: isSerializableEqual\n            },\n        }, ModelReferenceField)\n    ], BaseDependencyMixin.prototype, \"toEvent\", void 0);\n    __decorate([\n        model_field({ type: 'int', defaultValue: DependencyType.EndToStart })\n    ], BaseDependencyMixin.prototype, \"type\", void 0);\n    __decorate([\n        model_field({ type: 'string' })\n    ], BaseDependencyMixin.prototype, \"fromSide\", void 0);\n    __decorate([\n        model_field({ type: 'string' })\n    ], BaseDependencyMixin.prototype, \"toSide\", void 0);\n    return BaseDependencyMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ChronoModelMixin } from \"../../../chrono/ChronoModelMixin.js\";\nimport { ConflictEffect } from \"../../../chrono/Conflict.js\";\nimport { AbstractProjectMixin } from \"../AbstractProjectMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\n/**\n * This is an abstract project, which just lists the available stores.\n *\n * The actual project classes are [[SchedulerBasicProjectMixin]], [[SchedulerProProjectMixin]], [[GanttProjectMixin]].\n */\nexport class ChronoAbstractProjectMixin extends Mixin([ChronoModelMixin, AbstractProjectMixin], (base) => {\n    const superProto = base.prototype;\n    class ChronoAbstractProjectMixin extends base {\n        // External flag, toggled late in finalization when already entered replica\n        get isDelayingCalculation() {\n            return Boolean(this.delayEnteringReplica || this.delayedCalculationPromise);\n        }\n        getGraph() {\n            return this.replica;\n        }\n        beforeCommitAsync() { return null; }\n        enterReplica(enterRecords) { }\n        acceptChanges() { }\n        // If we are delaying calculations, return its promise which will be resolved when calculations are finished.\n        // As part of that process it will commit replica\n        async commitAsync() {\n            return this.delayedCalculationPromise || this.replica?.commitAsync();\n        }\n        getSchedulingIssueEventArguments(schedulingIssue, transaction, resolve, reject) {\n            const result = [\n                schedulingIssue.type,\n                {\n                    continueWithResolutionResult: resolve,\n                    schedulingIssue\n                }\n            ];\n            // For scheduling conflict public API expects to have \"conflict\" property w/ the ConflictEffect instance\n            if (schedulingIssue instanceof ConflictEffect)\n                result[1].conflict = schedulingIssue;\n            return result;\n        }\n        async onSchedulingIssueCall(schedulingIssue, transaction) {\n            // is there is a \"schedulingConflict\" event listener we expect resolution option will be picked there\n            if (schedulingIssue.type && this.hasListener(schedulingIssue.type)) {\n                return new Promise((resolve, reject) => {\n                    this.trigger(...this.getSchedulingIssueEventArguments(schedulingIssue, transaction, resolve, reject));\n                });\n            }\n            // by default we cancel the committed changes\n            return EffectResolutionResult.Cancel;\n        }\n        async onCycleSchedulingIssue(schedulingIssue, transaction) {\n            return this.onSchedulingIssueCall(schedulingIssue, transaction);\n        }\n        async onEmptyCalendarSchedulingIssue(schedulingIssue, transaction) {\n            return this.onSchedulingIssueCall(schedulingIssue, transaction);\n        }\n        async onConflictSchedulingIssue(schedulingIssue, transaction) {\n            return this.onSchedulingIssueCall(schedulingIssue, transaction);\n        }\n        setModelCalculations(model, calculations) {\n            if (!calculations)\n                return;\n            const oldValues = {};\n            // backup current calculations\n            for (const field in calculations) {\n                oldValues[field] = model.prototype.$calculations[field];\n            }\n            // Patch model prototype settings\n            Object.assign(model.prototype.$calculations, calculations);\n            return oldValues;\n        }\n        setRecordCalculations(record, calculations) {\n            const oldValues = this.setModelCalculations(record.constructor, calculations);\n            const skeleton = record.$entity.$skeleton;\n            Object.keys(calculations).forEach(field => {\n                skeleton[field].prototype.calculation = record[calculations[field]];\n            });\n            return oldValues;\n        }\n        setStoreCalculations(store, calculations) {\n            if (!calculations)\n                return;\n            // Rebuild corresponding identifiers\n            const record = store.first;\n            if (record) {\n                return this.setRecordCalculations(record, calculations);\n            }\n            else {\n                return this.setModelCalculations(store.modelClass, calculations);\n            }\n        }\n        /**\n         * Overrides the project owned store identifiers calculation.\n         * @param calculations Object providing new identifier calculation function names.\n         * The object is grouped by store identifiers. For example below code\n         * overrides event `startDate`, `endDate` and `duration` calculation so\n         * the fields will always simply return their current values:\n         *\n         * ```typescript\n         * // event startDate, endDate and duration will use their userProvidedValue method\n         * // which simply returns their current values as-is\n         * const oldCalculations = await project.setCalculations({\n         *     events : {\n         *         startDate : \"userProvidedValue\",\n         *         endDate   : \"userProvidedValue\",\n         *         duration  : \"userProvidedValue\"\n         *     }\n         * })\n         * ```\n         * @returns Promise that resolves with an object having the overridden calculations.\n         * The object can be used to toggle the calculations back in the future:\n         * ```typescript\n         * // override event duration calculation\n         * const oldCalculations = await project.setCalculations({\n         *     events : {\n         *         duration  : \"userProvidedValue\"\n         *     }\n         * })\n         * // revert the duration calculation back\n         * project.setCalculations(oldCalculations)\n         * ```\n         */\n        async setCalculations(calculations) {\n            // Graph might not be created if using delayed calculations\n            this.replica && await this.commitAsync();\n            const oldCalculations = {};\n            const stores = {\n                tasks: this.eventStore,\n                events: this.eventStore,\n                dependencies: this.dependencyStore,\n                resources: this.resourceStore,\n                assignments: this.assignmentStore,\n                calendars: this.calendarManagerStore\n            };\n            Object.keys(stores).forEach(id => {\n                // Apply calculation change to every owned store\n                if (calculations[id]) {\n                    oldCalculations[id] = this.setStoreCalculations(stores[id], calculations[id]);\n                }\n            });\n            // Apply calculation changes to the project if provided\n            let projectCalculations = calculations.project;\n            if (projectCalculations) {\n                oldCalculations.project = this.setRecordCalculations(this, projectCalculations);\n            }\n            // Repopulate replica w/ updated identifiers\n            //@ts-ignore\n            this.replica && this.repopulateReplica.now();\n            this.replica && await this.commitAsync();\n            // return previous calculation settings\n            return oldCalculations;\n        }\n    }\n    return ChronoAbstractProjectMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { MAX_DATE, MIN_DATE } from \"../../../util/Constants.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\n// this mixin can be better named `ScheduledBySubEvents`\n// it can also be defined as \"HasChildrenOnly\" - ie has child events, but does not have parent (not part of the tree structure)\n// then the `HasChildrenMixin` would be `HasParent`\n/**\n * This mixin provides the notion of \"sub events\" for the [[BaseEventMixin]], which is a bit more general concept\n * of the \"child\" events. This special notion is required, because the event store can be a flat store, not providing\n * any tree structuring. In the same time, we treat the project instance as a \"parent\" event for all events in the flat\n * event store - so it accumulates the same aggregation information as other \"regular\" parent events.\n *\n * The event with this mixin is scheduled according to the \"sub events\" information - it starts at the earliest date\n * among all sub events and ends at the latest. If there's no \"sub events\" - it delegates to previous behaviour.\n *\n * Scheduling by children can be disabled by setting [[manuallyScheduled]] flag to `true` which will\n * result [[startDate]] and [[endDate]] fields will keep their provided values.\n */\nexport class HasSubEventsMixin extends Mixin([BaseEventMixin], (base) => {\n    const superProto = base.prototype;\n    class HasSubEventsMixin extends base {\n        static get $name() {\n            return 'HasSubEventsMixin';\n        }\n        /**\n         * The abstract method which should indicate whether this event has sub events\n         */\n        *hasSubEvents() {\n            throw new Error(\"Abstract method `hasSubEvents` has been called\");\n        }\n        /**\n         * The abstract method which should return an Iterable of [[BaseEventMixin]]\n         */\n        *subEventsIterable() {\n            throw new Error(\"Abstract method `subEventsIterable` has been called\");\n        }\n        *calculateStartDatePure() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateMinChildrenStartDate();\n            }\n            else {\n                return yield* superProto.calculateStartDatePure.call(this);\n            }\n        }\n        *calculateEndDatePure() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateMaxChildrenEndDate();\n            }\n            else {\n                return yield* superProto.calculateEndDatePure.call(this);\n            }\n        }\n        *calculateStartDateProposed() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateStartDatePure();\n            }\n            else {\n                return yield* superProto.calculateStartDateProposed.call(this);\n            }\n        }\n        *calculateEndDateProposed() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateEndDatePure();\n            }\n            else {\n                return yield* superProto.calculateEndDateProposed.call(this);\n            }\n        }\n        *calculateDurationProposed() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const hasSubEvents = yield* this.hasSubEvents();\n            if (!manuallyScheduled && hasSubEvents) {\n                return yield* this.calculateDurationPure();\n            }\n            else {\n                return yield* superProto.calculateDurationProposed.call(this);\n            }\n        }\n        /**\n         * The method defines wether the provided child event should be\n         * taken into account when calculating this summary event [[startDate]].\n         * Child events roll up their [[startDate]] values to their summary tasks.\n         * So a summary task [[startDate|start]] date gets equal to\n         * its minimal child [[startDate|start]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default the method returns `true` to include all child events data.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildStartDate(child) {\n            return true;\n        }\n        /**\n         * Calculates the minimal sub-events [[startDate]].\n         * The method is used for calculating the event [[startDate]].\n         */\n        *calculateMinChildrenStartDate() {\n            const children = yield* this.subEventsIterable();\n            let timestamp = MAX_DATE.getTime();\n            for (const child of children) {\n                if (yield* this.shouldRollupChildStartDate(child)) {\n                    let date = yield child.$.startDate;\n                    // if the child has endDate only - use that value\n                    if (!date) {\n                        date = yield child.$.endDate;\n                    }\n                    if (date && date.getTime() < timestamp) {\n                        timestamp = date.getTime();\n                    }\n                }\n            }\n            if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime())\n                return null;\n            return new Date(timestamp);\n        }\n        /**\n         * The method defines wether the provided child event should be\n         * taken into account when calculating this summary event [[endDate]].\n         * Child events roll up their [[endDate]] values to their summary tasks.\n         * So a summary task [[endDate|end]] gets equal to its maximal child [[endDate|end]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default the method returns `true` to include all child events data.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildEndDate(child) {\n            return true;\n        }\n        /**\n         * Calculates the maximum sub-events [[endDate]].\n         * The method is used for calculating the event [[endDate]].\n         */\n        *calculateMaxChildrenEndDate() {\n            const children = yield* this.subEventsIterable();\n            let timestamp = MIN_DATE.getTime();\n            for (const child of children) {\n                if (yield* this.shouldRollupChildEndDate(child)) {\n                    let date = yield child.$.endDate;\n                    if (!date) {\n                        date = yield child.$.startDate;\n                    }\n                    if (date && date.getTime() > timestamp) {\n                        timestamp = date.getTime();\n                    }\n                }\n            }\n            if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime())\n                return null;\n            return new Date(timestamp);\n        }\n    }\n    return HasSubEventsMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { reference } from \"../../../../ChronoGraph/replica/Reference.js\";\nimport { bucket } from \"../../../../ChronoGraph/replica/ReferenceBucket.js\";\nimport { HasSubEventsMixin } from \"./HasSubEventsMixin.js\";\n/**\n * Specialized version of the [[HasSubEventsMixin]]. The event becomes part of the tree structure.\n * It now has reference to the [[parentEvent]] and a collection of [[childEvents]].\n *\n * The abstract methods from the [[HasSubEventsMixin]] are defined to operate on the [[childEvents]] collection.\n */\nexport class HasChildrenMixin extends Mixin([HasSubEventsMixin], (base) => {\n    const superProto = base.prototype;\n    class HasChildrenMixin extends base {\n        /**\n         * Returns `true` if the event has nested sub-events.\n         */\n        *hasSubEvents() {\n            const childEvents = yield this.$.childEvents;\n            return childEvents.size > 0;\n        }\n        /**\n         * Returns iterable object listing the event nested sub-events.\n         * ```typescript\n         * const subEventsIterator : Iterable<HasChildrenMixin> = yield* event.subEventsIterable()\n         *\n         * for (let childEvent of subEventsIterator) {\n         *     // ..do something..\n         * }\n         * ```\n         */\n        *subEventsIterable() {\n            return yield this.$.childEvents;\n        }\n        get parent() {\n            return this._parent;\n        }\n        set parent(value) {\n            this._parent = value;\n            this.parentEvent = value;\n        }\n    }\n    __decorate([\n        reference({ bucket: 'childEvents' })\n    ], HasChildrenMixin.prototype, \"parentEvent\", void 0);\n    __decorate([\n        bucket()\n    ], HasChildrenMixin.prototype, \"childEvents\", void 0);\n    return HasChildrenMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { MixinAny } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { ReadMode, Replica } from \"../../../../ChronoGraph/replica/Replica.js\";\nimport { Schema } from \"../../../../ChronoGraph/schema/Schema.js\";\nimport { delay } from \"../../../../ChronoGraph/util/Helpers.js\";\nimport StateTrackingManager from \"../../../../Core/data/stm/StateTrackingManager.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nimport { model_field, ModelReferenceField, IsChronoModelSymbol, ModelBucketField } from \"../../../chrono/ModelFieldAtom.js\";\nimport { EngineReplica, CycleEffect } from \"../../../chrono/Replica.js\";\nimport { DurationConverterMixin } from \"../../../scheduling/DurationConverterMixin.js\";\nimport { ProjectType } from \"../../../scheduling/Types.js\";\nimport { ChronoAssignmentStoreMixin } from \"../../store/ChronoAssignmentStoreMixin.js\";\nimport { ChronoCalendarManagerStoreMixin } from \"../../store/ChronoCalendarManagerStoreMixin.js\";\nimport { ChronoDependencyStoreMixin } from \"../../store/ChronoDependencyStoreMixin.js\";\nimport { ChronoEventStoreMixin } from \"../../store/ChronoEventStoreMixin.js\";\nimport { ChronoResourceStoreMixin } from \"../../store/ChronoResourceStoreMixin.js\";\nimport { ChronoAbstractProjectMixin } from \"./ChronoAbstractProjectMixin.js\";\nimport { BaseAssignmentMixin } from \"./BaseAssignmentMixin.js\";\nimport { BaseCalendarMixin } from \"./BaseCalendarMixin.js\";\nimport { BaseDependencyMixin } from \"./BaseDependencyMixin.js\";\nimport { BaseEventMixin } from \"./BaseEventMixin.js\";\nimport { BaseResourceMixin } from \"./BaseResourceMixin.js\";\nimport { CanCombineCalendarsMixin, HasCalendarMixin } from \"./HasCalendarMixin.js\";\nimport { HasSubEventsMixin } from \"./HasSubEventsMixin.js\";\nimport { SchedulerBasicEvent } from \"./SchedulerBasicEvent.js\";\nimport ObjectHelper from \"../../../../Core/helper/ObjectHelper.js\";\n/**\n * Basic Scheduler project mixin type. At this level, events have assignments and dependencies, which both are, however,\n * only visual and do not affect the scheduling.\n */\nexport class SchedulerBasicProjectMixin extends MixinAny([\n    ChronoAbstractProjectMixin,\n    BaseEventMixin,\n    HasSubEventsMixin,\n    HasCalendarMixin,\n    DurationConverterMixin,\n    CanCombineCalendarsMixin\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerBasicProjectMixin extends base {\n        construct(config = {}) {\n            this.delayCalculation = config.delayCalculation !== false;\n            this.enableProgressNotifications = config.enableProgressNotifications || config.delayCalculation !== false;\n            // Expand project by default to make getRange to work\n            if (!('expanded' in config)) {\n                // @ts-ignore\n                config.expanded = true;\n            }\n            if (this.delayCalculation) {\n                this.delayEnteringReplica = true;\n            }\n            if (!('skipNonWorkingTimeWhenSchedulingManually' in config)) {\n                config.skipNonWorkingTimeWhenSchedulingManually = false;\n            }\n            superProto.construct.call(this, config);\n            this.repopulateStores = new Set();\n            this.ignoreInitialCommitComputationCycles = ('ignoreInitialCommitComputationCycles' in config) ? config.ignoreInitialCommitComputationCycles : false;\n            if (this.ignoreInitialCommitComputationCycles) {\n                console.warn('Project \"ignoreInitialCommitComputationCycles\" option is deprecated and will be dropped in the next major release');\n            }\n            if (!this.eventModelClass)\n                this.eventModelClass = this.getDefaultEventModelClass();\n            if (!this.eventStoreClass)\n                this.eventStoreClass = this.getDefaultEventStoreClass();\n            if (!this.dependencyModelClass)\n                this.dependencyModelClass = this.getDefaultDependencyModelClass();\n            if (!this.dependencyStoreClass)\n                this.dependencyStoreClass = this.getDefaultDependencyStoreClass();\n            if (!this.resourceModelClass)\n                this.resourceModelClass = this.getDefaultResourceModelClass();\n            if (!this.resourceStoreClass)\n                this.resourceStoreClass = this.getDefaultResourceStoreClass();\n            if (!this.assignmentModelClass)\n                this.assignmentModelClass = this.getDefaultAssignmentModelClass();\n            if (!this.assignmentStoreClass)\n                this.assignmentStoreClass = this.getDefaultAssignmentStoreClass();\n            if (!this.calendarModelClass)\n                this.calendarModelClass = this.getDefaultCalendarModelClass();\n            if (!this.calendarManagerStoreClass)\n                this.calendarManagerStoreClass = this.getDefaultCalendarManagerStoreClass();\n            if (!this.cycleEffectClass)\n                this.cycleEffectClass = this.getDefaultCycleEffectClass();\n            this.initializeStm();\n            // NOTE, default calendar is assumed to be 24/7/365, because it is used for manually scheduled events\n            // not part of the CalendarManagerStore intentionally, not persisted\n            this.defaultCalendar = new this.calendarModelClass({\n                unspecifiedTimeIsWorking: this.unspecifiedTimeIsWorking\n            });\n            this.defaultCalendar.project = this;\n            if (!this.delayEnteringReplica)\n                this.enterReplica(false);\n            this.setCalendarManagerStore(this.calendarManagerStore);\n            this.setEventStore(this.eventStore);\n            this.setDependencyStore(this.dependencyStore);\n            this.setResourceStore(this.resourceStore);\n            this.setAssignmentStore(this.assignmentStore);\n            const hasInlineData = Boolean(this.calendarsData || this.eventsData || this.dependenciesData || this.resourcesData || this.assignmentsData);\n            if (hasInlineData) {\n                // this branch has `scheduleDelayedCalculation` call inside `loadInlineData`\n                this.loadInlineData({\n                    calendarsData: this.calendarsData,\n                    eventsData: this.eventsData,\n                    dependenciesData: this.dependenciesData,\n                    resourcesData: this.resourcesData,\n                    assignmentsData: this.assignmentsData\n                });\n                delete this.calendarsData;\n                delete this.eventsData;\n                delete this.dependenciesData;\n                delete this.resourcesData;\n                delete this.assignmentsData;\n            }\n            else {\n                // on this branch need to call it manually\n                // avoid calling `scheduleDelayedCalculation` unless absolutely necessary\n                // this is to avoid having 2 commits in the project - 1st with empty data\n                // 2nd with real data\n                // we have special behavior tied to the 1st commit, like state restoring (previously selected record)\n                if (this.delayCalculation && this.hasDataInStores)\n                    this.scheduleDelayedCalculation();\n            }\n        }\n        get hasDataInStores() {\n            return [\n                this.calendarManagerStore,\n                this.eventStore,\n                this.dependencyStore,\n                this.resourceStore,\n                this.assignmentStore\n            ].some(store => store.allCount > 0);\n        }\n        enterReplica(enterRecords) {\n            const me = this;\n            if (!me.replica) {\n                me.replica = me.createReplica();\n                me.replica.addEntity(me);\n                me.replica.addEntity(me.defaultCalendar);\n                me.trigger('graphReady');\n            }\n            // In delayCalculation mode no records entered the graph on construction,\n            // instead we enter them now after first draw\n            if (enterRecords && !me.isRepopulatingStores) {\n                // Only enter \"new\" records, we are called when records are added later on\n                me.calendarManagerStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.eventStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.resourceStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.dependencyStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n                me.assignmentStore.forEach(r => { !r.graph && r.joinProject(); }, undefined, { includeFilteredOutRecords: true });\n            }\n        }\n        resetStmQueue() {\n            const wasDisabled = this.stm.disabled;\n            this.stm.disable();\n            this.stm.resetQueue();\n            if (!wasDisabled) {\n                this.stm.enable();\n            }\n        }\n        doDestroy() {\n            const me = this;\n            me.eventStore?.destroy();\n            me.dependencyStore?.destroy();\n            me.assignmentStore?.destroy();\n            me.resourceStore?.destroy();\n            me.calendarManagerStore?.destroy();\n            me.defaultCalendar?.destroy();\n            me.replica?.clear();\n            me.stm?.destroy();\n            superProto.doDestroy.call(this);\n        }\n        getReplicaConfig() {\n            return {\n                project: this,\n                schema: Schema.new(),\n                enableProgressNotifications: this.enableProgressNotifications,\n                silenceInitialCommit: this.silenceInitialCommit,\n                ignoreInitialCommitComputationCycles: this.ignoreInitialCommitComputationCycles,\n                cycleEffectClass: this.cycleEffectClass,\n                onWriteDuringCommit: 'ignore',\n                readMode: ReadMode.CurrentOrProposedOrPrevious\n            };\n        }\n        // Creates a new Replica, used during construction and when repopulating\n        createReplica() {\n            return EngineReplica.mix(Replica).new(this.getReplicaConfig());\n        }\n        *hasSubEvents() {\n            return this.getEventStore().count > 0;\n        }\n        *subEventsIterable() {\n            return this.getEventStore().getRange();\n        }\n        getType() {\n            return ProjectType.SchedulerBasic;\n        }\n        get enableProgressNotifications() {\n            return this._enableProgressNotifications;\n        }\n        /**\n         * Enables/disables the calculation progress notifications.\n         */\n        set enableProgressNotifications(value) {\n            this._enableProgressNotifications = value;\n            if (this.replica)\n                this.replica.enableProgressNotifications = value;\n        }\n        getDefaultCycleEffectClass() {\n            return CycleEffect;\n        }\n        /**\n         * Returns the default event model class to use\n         */\n        getDefaultEventModelClass() {\n            return SchedulerBasicEvent;\n        }\n        /**\n         * Returns the default event store class to use\n         */\n        getDefaultEventStoreClass() {\n            return ChronoEventStoreMixin;\n        }\n        /**\n         * Returns the default dependency model class to use\n         */\n        getDefaultDependencyModelClass() {\n            return BaseDependencyMixin;\n        }\n        /**\n         * Returns the default dependency store class to use\n         */\n        getDefaultDependencyStoreClass() {\n            return ChronoDependencyStoreMixin;\n        }\n        /**\n         * Returns the default resource model class to use\n         */\n        getDefaultResourceModelClass() {\n            return BaseResourceMixin;\n        }\n        /**\n         * Returns the default resource store class to use\n         */\n        getDefaultResourceStoreClass() {\n            return ChronoResourceStoreMixin;\n        }\n        /**\n         * Returns the default assignment model class to use\n         */\n        getDefaultAssignmentModelClass() {\n            return BaseAssignmentMixin;\n        }\n        /**\n         * Returns the default assignment store class to use\n         */\n        getDefaultAssignmentStoreClass() {\n            return ChronoAssignmentStoreMixin;\n        }\n        /**\n         * Returns the default calendar model class to use\n         */\n        getDefaultCalendarModelClass() {\n            return BaseCalendarMixin;\n        }\n        /**\n         * Returns the default calendar manager store class to use\n         */\n        getDefaultCalendarManagerStoreClass() {\n            return ChronoCalendarManagerStoreMixin;\n        }\n        usingSyncDataOnLoad() {\n            return [this.eventStore, this.resourceStore, this.dependencyStore, this.assignmentStore].some(s => s.syncDataOnLoad);\n        }\n        /**\n         * This method loads the \"raw\" data into the project. The loading is basically happening by\n         * assigning the individual data entries to the `data` property of the corresponding store.\n         *\n         * @param data\n         */\n        async loadInlineData(data) {\n            const { calendarManagerStore, eventStore, dependencyStore, assignmentStore, resourceStore, replica } = this;\n            if (!this.isInitialCommitPerformed) {\n                // Prevent initial commit from happening before inline data is loaded\n                replica?.unScheduleAutoCommit();\n            }\n            else {\n                // We want to be very sure that calculations are complete before we plug new data in.\n                // For a scenario where a client plugged new datasets in on every store change, thus multiple times\n                // during a single commit()\n                while (this.replica.isCommitting) {\n                    await this.commitAsync();\n                }\n            }\n            if (replica?.enableProgressNotifications && !this.delayCalculation) {\n                // First delay needed to allow assignment of Project -> Gantt to happen before carrying on,\n                // to make sure progress listener is in place\n                await delay(0);\n                // wait till the current propagation completes (if any)\n                // otherwise the mask shown due to the next line call will be\n                // destroyed as the propagation gets done\n                await this.commitAsync();\n                replica.onPropagationProgressNotification({ total: 0, remaining: 0, phase: 'storePopulation' });\n                // Second delay needed to allow mask to appear, not clear why delay(0) is not enough, it works in other\n                // places\n                await delay(50);\n            }\n            this.isInitialCommitPerformed = false;\n            this.isLoadingInlineData = true;\n            if (globalThis.DEBUG) {\n                console.log(`%cInitializing project`, 'font-weight:bold;color:darkgreen;text-transform:uppercase;margin-top: 2em');\n                console.time('Time to visible');\n                console.time('Populating project');\n            }\n            // Prevent records from entering replica on reload, schedule delayed entering / calculation\n            if (this.delayCalculation && !this.delayedCalculationPromise && !this.usingSyncDataOnLoad()) {\n                this.scheduleDelayedCalculation();\n            }\n            if (data.calendarsData) {\n                this.repopulateStore(calendarManagerStore);\n                calendarManagerStore.data = data.calendarsData;\n            }\n            if (data.eventsData || data.tasksData) {\n                this.repopulateStore(eventStore);\n                eventStore.data = data.eventsData || data.tasksData;\n            }\n            if (data.dependenciesData) {\n                this.repopulateStore(dependencyStore);\n                dependencyStore.data = data.dependenciesData;\n            }\n            if (data.resourcesData) {\n                this.repopulateStore(resourceStore);\n                resourceStore.data = data.resourcesData;\n            }\n            if (data.assignmentsData) {\n                this.repopulateStore(assignmentStore);\n                assignmentStore.data = data.assignmentsData;\n            }\n            if (data.project) {\n                //@ts-ignore\n                this.applyProjectResponse(data.project);\n            }\n            if (globalThis.DEBUG)\n                console.timeEnd('Populating project');\n            const result = await this.commitLoad();\n            this.isLoadingInlineData = false;\n            return result;\n        }\n        // Called from scheduleDelayedCalculation() & setAssignmentStore to set up indices used to look events and\n        // resources up before calculations has finished\n        setupTemporaryIndices() {\n            const { storage } = this.assignmentStore || {};\n            // First delayed calculation starts before assignmentStore is created => no storage\n            if (storage) {\n                // Set up indices to mimic buckets (removed again in below)\n                storage.addIndex({ property: 'event', unique: false });\n                storage.addIndex({ property: 'resource', unique: false });\n            }\n        }\n        removeTemporaryIndices() {\n            const { storage } = this.assignmentStore;\n            // Indices mimicking buckets are no longer needed now, get rid of them\n            storage.removeIndex('event');\n            storage.removeIndex('resource');\n        }\n        async internalDelayCalculation(resolve) {\n            const me = this;\n            me.delayEnteringReplica = true;\n            me.setupTemporaryIndices();\n            // If listeners are defined on project, we have to wait until after construction before they can\n            // catch any events\n            await delay(0);\n            if (me.isDestroyed) {\n                resolve();\n                return;\n            }\n            me.trigger('delayCalculationStart');\n            // In delayCalculation mode, we trigger refresh before calculating to let UI draw early\n            me.trigger('refresh', { isCalculated: false });\n            await delay(0);\n            if (me.isDestroyed) {\n                resolve();\n                return;\n            }\n            me.delayEnteringReplica = false;\n            // After triggering (and thus drawing) we let everything enter the graph, either by repopulating\n            // a new replica or by entering the existing (or a new from scratch the first time)\n            if (me.isRepopulatingStores) {\n                // @ts-ignore\n                me.repopulateReplica.now();\n            }\n            else {\n                // this triggers the re-application of the `responseData.project`\n                // to the project instance, which might be delayed due to the\n                // `delayEnteringReplica` flag\n                me.trigger('recordsUnlinked');\n                me.enterReplica(true);\n            }\n            const result = await me.replica.commitAsync();\n            if (me.isDestroyed) {\n                resolve();\n                return;\n            }\n            resolve(result);\n            me.delayedCalculationPromise = null;\n            me.trigger('delayCalculationEnd');\n            me.removeTemporaryIndices();\n        }\n        scheduleDelayedCalculation() {\n            if (this.delayedCalculationPromise) {\n                return this.delayedCalculationPromise;\n            }\n            if (this.delayCalculation !== false) {\n                return this.delayedCalculationPromise = new Promise(resolve => \n                // Cannot use async code directly in Promise executor, because it hides errors\n                this.internalDelayCalculation(resolve).then());\n            }\n        }\n        async commitLoad() {\n            // if (globalThis.DEBUG) console.time('Initial propagation')\n            const result = await this.commitAsync();\n            // Might have been destroyed during the async operation above\n            if (!this.isDestroyed)\n                this.trigger('load');\n            return result;\n        }\n        initializeStm() {\n            const stmClass = this.stmClass || StateTrackingManager;\n            // @ts-ignore\n            if (!(this.stm instanceof StateTrackingManager))\n                this.setStm(stmClass.new({ disabled: true }, this.stm));\n            if (this.resetUndoRedoQueuesAfterLoad) {\n                this.ion({\n                    load: this.resetStmQueue,\n                    thisObj: this\n                });\n            }\n            this.ion({\n                beforeCommit: this.onCommitInitialization,\n                commitFinalized: this.onCommitFinalization,\n                commitRejected: this.onCommitRejection,\n                thisObj: this\n            });\n        }\n        removeRejectedRecordsAdd({ transactionResult, silenceCommit }) {\n            const recordsToDrop = new Map();\n            for (const quark of transactionResult.entries.values()) {\n                const identifier = quark.identifier;\n                const { field } = identifier;\n                if (quark.isShadow() || !identifier[IsChronoModelSymbol] || field instanceof ModelBucketField)\n                    continue;\n                const record = identifier.self;\n                const store = record.firstStore;\n                // collect records w/ atoms not having a previous value\n                if (store && !quark.previous && !transactionResult.transaction.getLatestStableEntryFor(record.$$)?.previous) {\n                    if (!recordsToDrop.has(store)) {\n                        recordsToDrop.set(store, new Set([record]));\n                    }\n                    else if (!recordsToDrop.get(store).has(record)) {\n                        recordsToDrop.get(store).add(record);\n                    }\n                }\n            }\n            // @ts-ignore\n            this.suspendChangesTracking?.();\n            const stores = Array.from(recordsToDrop.keys()).sort((a, b) => a.removalOrder - b.removalOrder);\n            // remove the collected records\n            stores.forEach(store => store.remove(recordsToDrop.get(store)));\n            // @ts-ignore\n            this.resumeChangesTracking?.(silenceCommit);\n            if (silenceCommit) {\n                this.eventStore.acceptChanges();\n                this.dependencyStore.acceptChanges();\n                this.resourceStore.acceptChanges();\n                this.assignmentStore.acceptChanges();\n                this.calendarManagerStore.acceptChanges();\n            }\n        }\n        onCommitRejection(event) {\n            // if STM is disabled we're trying to revert changes w/o it\n            if (this._stmDisabled) {\n                this.replica.isWritingPreviousData = true;\n                this.isRestoringData = true;\n                this.removeRejectedRecordsAdd(event);\n                this.isRestoringData = false;\n                this.replica.isWritingPreviousData = false;\n            }\n            // reject last transaction STM has\n            else {\n                this.rejectStmTransaction();\n            }\n        }\n        // https://github.com/bryntum/support/issues/1270\n        onCommitInitialization() {\n            const { stm } = this;\n            this._stmDisabled = stm.disabled;\n            if (stm.isRecording && stm.autoRecord) {\n                this._stmAutoRecord = true;\n                // If auto recording is enabled when we are entering a commit, we need to move autoRecording\n                // state to Recording in order to make sure all changes from the project will become a single\n                // transaction\n                stm.autoRecord = false;\n            }\n        }\n        onCommitFinalization() {\n            if (this._stmAutoRecord) {\n                // This will restore autoRecording state and trigger timer to stop transaction after a delay\n                this.stm.autoRecord = true;\n                this._stmAutoRecord = false;\n            }\n        }\n        onSTMRestoringStart({ source: stm }) {\n            if (this.replica)\n                this.replica.isWritingPreviousData = true;\n        }\n        // Propagate on undo/redo\n        async onSTMRestoringStop({ source }) {\n            if (this.replica)\n                this.replica.isWritingPreviousData = false;\n            const stm = source;\n            // Disable STM meanwhile to not pick it up as a new STM transaction\n            stm.disable();\n            await this.commitAsync();\n            if (!this.isDestroyed) {\n                stm.enable();\n                this.trigger('stateRestoringDone');\n            }\n        }\n        //region Repopulate\n        // defers the call to given function with given arguments until the `repopulateReplica` event\n        // (if replica is scheduled for repopulation, otherwise calls immediately)\n        // between the multiple defers with the same `deferId`, only the latest one is called\n        deferUntilRepopulationIfNeeded(deferId, func, args) {\n            if (this.isRepopulatingStores) {\n                this.detachListeners(deferId);\n                this.ion({\n                    name: deferId,\n                    repopulateReplica: {\n                        fn: async () => {\n                            await this.commitAsync();\n                            if (!this.isDestroyed) {\n                                func(...args);\n                            }\n                        },\n                        once: true\n                    }\n                });\n            }\n            else {\n                func(...args);\n            }\n        }\n        get isRepopulatingStores() {\n            return Boolean(this.repopulateStores?.size);\n        }\n        // Remember which stores are being repopulated, they don't have to care about un-joining the graph later\n        repopulateStore(store) {\n            const me = this;\n            if (me.repopulateOnDataset && store.allCount && !store.syncDataOnLoad) {\n                me.replica?.activeTransaction.stop();\n                if (!me.repopulateStores)\n                    me.repopulateStores = new Set();\n                me.repopulateStores.add(store);\n                // Trigger buffered repopulate of replica\n                me.repopulateReplica();\n            }\n        }\n        // Creates a new replica, populating it with data from the stores\n        repopulateReplica() {\n            const me = this;\n            // Will repopulate as part of scheduled delayed calculations\n            if (me.delayEnteringReplica) {\n                return;\n            }\n            const { calendarManagerStore, eventStore, dependencyStore, assignmentStore, resourceStore, replica: oldReplica } = me;\n            if (oldReplica) {\n                // Unlink all old records that are going to be re-entered into new replica\n                me.unlinkStoreRecords(calendarManagerStore, eventStore, dependencyStore, resourceStore, assignmentStore);\n                me.unlinkRecord(me);\n                me.unlinkRecord(me.defaultCalendar);\n                me.trigger('recordsUnlinked');\n                oldReplica.clear();\n            }\n            else {\n                me.trigger('recordsUnlinked');\n            }\n            const replica = me.replica = me.createReplica();\n            // Now enter all new and old reused records into the new replica\n            replica.addEntity(me);\n            replica.addEntity(me.defaultCalendar);\n            me.joinStoreRecords(calendarManagerStore, true);\n            me.joinStoreRecords(eventStore, true);\n            me.joinStoreRecords(dependencyStore, true);\n            me.joinStoreRecords(resourceStore, true);\n            me.joinStoreRecords(assignmentStore, true);\n            me.repopulateStores.clear();\n            me.trigger('repopulateReplica');\n        }\n        // If there is a commit when we are supposed to replace the replica, we hijack that and commit the new replica\n        beforeCommitAsync() {\n            //@ts-ignore\n            if (this.repopulateReplica.isPending && !this.isDelayingCalculation) {\n                //@ts-ignore\n                this.repopulateReplica.now();\n                return this.replica.commitAsync();\n            }\n            return null;\n        }\n        // Unlinks a single record from the graph, writing back identifiers values from the graph to DATA to allow them\n        // to enter another replica\n        unlinkRecord(record) {\n            // Might not have entered replica yet when using delayed calculation\n            if (record?.graph) {\n                const { activeTransaction } = this.replica;\n                const { $ } = record;\n                const keys = Object.keys($);\n                // Write current values to identifier.DATA, to have correct value entering new replica later\n                for (let i = 0; i < keys.length; i++) {\n                    const key = keys[i];\n                    const identifier = $[key];\n                    const entry = activeTransaction.getLatestEntryFor(identifier);\n                    if (entry) {\n                        let value = entry.getValue();\n                        if (value === undefined)\n                            value = entry.proposedValue;\n                        if (value !== undefined) {\n                            identifier.DATA = identifier.field instanceof ModelReferenceField\n                                ? value?.id ?? value\n                                : value;\n                        }\n                    }\n                }\n                // Cut the link, to enable joining another replica\n                record.graph = null;\n            }\n        }\n        // Unlinks all records from a store, unless the store has been repopulated\n        unlinkStoreRecords(...stores) {\n            stores.forEach(store => {\n                // Unlink records only in stores that are not repopulated\n                // or if store has syncDataOnLoad (in this case records stay in the store so need to unlink them)\n                if (!this.repopulateStores.has(store) || store.syncDataOnLoad) {\n                    store.traverse((record) => {\n                        this.unlinkRecord(record);\n                    }, false, false, {\n                        // Must pass includeFilteredOutRecords and includeCollapsedGroupRecords as true\n                        // so that we work on full, unfiltered dataset\n                        includeFilteredOutRecords: true,\n                        includeCollapsedGroupRecords: true\n                    });\n                }\n            });\n        }\n        //endregion\n        getGraph() {\n            return this.replica;\n        }\n        // keep this private\n        async addEvents(events) {\n            this.eventStore.add(events);\n            return this.commitAsync();\n        }\n        // keep this private\n        async addEvent(event) {\n            this.eventStore.add(event);\n            return this.commitAsync();\n        }\n        // keep this private\n        includeEvent(event) {\n            this.eventStore.add(event);\n        }\n        // keep this private\n        async removeEvents(events) {\n            this.eventStore.remove(events);\n            return this.commitAsync();\n        }\n        // keep this private\n        excludeEvent(event) {\n            this.eventStore.remove(event);\n        }\n        // keep this private\n        async removeEvent(event) {\n            this.eventStore.remove(event);\n            return this.commitAsync();\n        }\n        getStm() {\n            return this.stm;\n        }\n        setStm(stm) {\n            this.stm = stm;\n            this.stm.ion({\n                restoringStart: this.onSTMRestoringStart,\n                restoringStop: this.onSTMRestoringStop,\n                thisObj: this\n            });\n        }\n        calculateProject() {\n            return this;\n        }\n        *calculateEffectiveCalendar() {\n            let calendar = yield this.$.calendar;\n            if (calendar) {\n                // this will create an incoming edge from the calendar's version atom, which changes on calendar's data update\n                yield calendar.$.version;\n            }\n            else {\n                calendar = this.defaultCalendar;\n            }\n            return calendar;\n        }\n        joinStoreRecords(store, skipRoot = false) {\n            const fn = (record) => {\n                record.setProject(this);\n                record.joinProject();\n            };\n            // Both iteration methods must pass includeFilteredOutRecords as true\n            // so that we work on full, unfiltered dataset\n            if (store.rootNode) {\n                store.rootNode.traverse(fn, skipRoot, true);\n            }\n            else {\n                store.forEach(fn, null, {\n                    includeFilteredOutRecords: true,\n                    includeCollapsedGroupRecords: true\n                });\n            }\n        }\n        unjoinStoreRecords(store) {\n            const fn = (record) => {\n                record.leaveProject();\n                record.setProject(this);\n            };\n            // Both iteration methods must pass includeFilteredOutRecords as true\n            // so that we work on full, unfiltered dataset\n            if (store.rootNode) {\n                store.rootNode.traverse(node => {\n                    // do not unjoin/leave project for the root node, which is the project itself\n                    if (node !== store.rootNode)\n                        fn(node);\n                }, false, true);\n            }\n            else {\n                store.forEach(fn, null, {\n                    includeFilteredOutRecords: true,\n                    includeCollapsedGroupRecords: true\n                });\n            }\n        }\n        /**\n         * This method sets the event store instance for the project.\n         * @param store\n         */\n        setEventStore(store) {\n            const oldEventStore = this.eventStore;\n            if (oldEventStore && this.stm.hasStore(oldEventStore)) {\n                this.stm.removeStore(oldEventStore);\n                this.unjoinStoreRecords(oldEventStore);\n                this.detachStore(oldEventStore);\n                const assignmentsForRemoval = oldEventStore.assignmentsForRemoval;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldEvent = assignment.event;\n                    if (oldEvent) {\n                        const newEvent = store.getById(oldEvent.id);\n                        if (newEvent) {\n                            assignment.event = newEvent;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldEventStore.afterEventRemoval();\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.eventStoreClass;\n                this.eventStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.eventModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.eventStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                // we've been given an event store from the outside\n                // need to change its root node to be the project\n                if (store.tree && store.rootNode !== this) {\n                    this.appendChild(store.rootNode.children || []);\n                    // Assigning a new root will make all children join store\n                    store.rootNode = this;\n                }\n                else {\n                    this.joinStoreRecords(store);\n                }\n            }\n            this.attachStore(this.eventStore);\n            this.trigger('eventStoreChange', { store: this.eventStore });\n        }\n        /**\n         * This method sets the dependency store instance for the project.\n         * @param store\n         */\n        setDependencyStore(store) {\n            const oldDependencyStore = this.dependencyStore;\n            if (oldDependencyStore && this.stm.hasStore(oldDependencyStore)) {\n                this.stm.removeStore(oldDependencyStore);\n                this.detachStore(oldDependencyStore);\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.dependencyStoreClass;\n                this.dependencyStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.dependencyModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.dependencyStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                this.joinStoreRecords(store);\n            }\n            this.attachStore(this.dependencyStore);\n            this.trigger('dependencyStoreChange', { store: this.dependencyStore });\n        }\n        /**\n         * This method sets the resource store instance for the project.\n         * @param store\n         */\n        setResourceStore(store) {\n            const oldResourceStore = this.resourceStore;\n            if (oldResourceStore && this.stm.hasStore(oldResourceStore)) {\n                this.stm.removeStore(oldResourceStore);\n                this.unjoinStoreRecords(oldResourceStore);\n                this.detachStore(oldResourceStore);\n                const assignmentsForRemoval = oldResourceStore.assignmentsForRemoval;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldResource = assignment.resource;\n                    if (oldResource) {\n                        const newResource = store.getById(oldResource.id);\n                        if (newResource) {\n                            assignment.resource = newResource;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldResourceStore.afterResourceRemoval();\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.resourceStoreClass;\n                this.resourceStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.resourceModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.resourceStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                this.joinStoreRecords(store);\n            }\n            this.attachStore(this.resourceStore);\n            this.trigger('resourceStoreChange', { store: this.resourceStore });\n        }\n        /**\n         * This method sets the assignment store instance for the project.\n         * @param store\n         */\n        setAssignmentStore(store) {\n            const oldAssignmentStore = this.assignmentStore;\n            if (oldAssignmentStore && this.stm.hasStore(oldAssignmentStore)) {\n                this.stm.removeStore(oldAssignmentStore);\n                this.unjoinStoreRecords(oldAssignmentStore);\n                this.detachStore(oldAssignmentStore);\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.assignmentStoreClass;\n                this.assignmentStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.assignmentModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.assignmentStore = store;\n                store.setProject(this);\n                this.stm.addStore(store);\n                this.joinStoreRecords(store);\n            }\n            this.isDelayingCalculation && this.setupTemporaryIndices();\n            this.attachStore(this.assignmentStore);\n            this.trigger('assignmentStoreChange', { store: this.assignmentStore });\n        }\n        /**\n         * This method sets the calendar manager store instance for the project.\n         * @param store\n         */\n        setCalendarManagerStore(store) {\n            const oldCalendarManagerStore = this.calendarManagerStore;\n            if (oldCalendarManagerStore && this.stm.hasStore(oldCalendarManagerStore)) {\n                this.stm.removeStore(oldCalendarManagerStore);\n                this.detachStore(oldCalendarManagerStore);\n            }\n            if (!store || !(store instanceof Store)) {\n                const storeClass = store?.storeClass || this.calendarManagerStoreClass;\n                this.calendarManagerStore = new storeClass(ObjectHelper.assign({\n                    modelClass: this.calendarModelClass,\n                    project: this,\n                    stm: this.stm\n                }, store || {}));\n            }\n            else {\n                this.calendarManagerStore = store;\n                if (store) {\n                    store.setProject(this);\n                    this.stm.addStore(store);\n                    this.joinStoreRecords(store);\n                }\n            }\n            this.attachStore(this.calendarManagerStore);\n            this.trigger('calendarManagerStoreChange', { store: this.calendarManagerStore });\n        }\n        // this does not account for possible scheduling conflicts\n        async isValidDependency(...args) {\n            return true;\n        }\n        rejectStmTransaction(stm) {\n            stm = stm || this.stm;\n            if (stm.transaction) {\n                if (stm.transaction.length) {\n                    stm.forEachStore(s => s.beginBatch());\n                    stm.rejectTransaction();\n                    stm.forEachStore(s => s.endBatch());\n                }\n                else {\n                    stm.stopTransaction();\n                }\n            }\n        }\n        async tryPropagateWithChanges(changerFn) {\n            const stm = this.stm, \n            // remember STM initial settings\n            stmInitiallyDisabled = stm.disabled, stmInitiallyAutoRecord = stm.autoRecord;\n            // if STM is disabled we turn it on so we could revert changes later\n            if (stmInitiallyDisabled) {\n                stm.enable();\n            }\n            // if it's enabled\n            else {\n                // if auto-recording is enabled - disable it\n                if (stmInitiallyAutoRecord) {\n                    stm.autoRecord = false;\n                }\n                // stop the current transaction to not mess it\n                if (stm.isRecording) {\n                    stm.stopTransaction();\n                }\n            }\n            // start a new transaction\n            stm.startTransaction();\n            // In case anything in, or called by the changerFn attempts to propagate.\n            // We must only propagate after the changes have been made.\n            // this.suspendPropagate()\n            changerFn();\n            // Resume propagation, but do *not* propagate if any propagate calls were attempted during suspension.\n            // this.resumePropagate(false)\n            let result = true;\n            try {\n                const commitResult = await this.commitAsync();\n                // setting \"result\" to false if the propagation was rejected\n                result = !commitResult.rejectedWith;\n            }\n            catch (e) {\n                // rethrow non-cycle exception\n                if (!/cycle/i.test(e))\n                    throw e;\n                result = false;\n            }\n            // if the transaction succeed\n            if (result) {\n                stm.stopTransaction();\n                // if STM is not used - reset its queue\n                if (stmInitiallyDisabled) {\n                    stm.resetQueue();\n                }\n            }\n            // reject the failed transaction changes\n            else {\n                this.replica.reject();\n                this.rejectStmTransaction(stm);\n            }\n            // restore STM settings\n            stm.disabled = stmInitiallyDisabled;\n            stm.autoRecord = stmInitiallyAutoRecord;\n            return result;\n        }\n        isEngineReady() {\n            const { replica } = this;\n            return this.delayEnteringReplica\n                || (!this.isRepopulatingStores\n                    && (replica\n                        ? !(replica.dirty && (replica.hasPendingAutoCommit() || replica.isCommitting))\n                        : true));\n        }\n        // Needed to separate configs from data, for tests to pass. Normally handled in ProjectModel outside of engine\n        static get defaultConfig() {\n            return {\n                assignmentsData: null,\n                calendarsData: null,\n                dependenciesData: null,\n                eventsData: null,\n                resourcesData: null,\n                // need to distinguish the stores from fields\n                // https://bryntum.com/products/gantt/examples/advanced/\n                // bryntum.gantt.ObjectHelper.isEqual({}, new bryntum.gantt.Store()) // true\n                eventStore: null,\n                resourceStore: null,\n                assignmentStore: null,\n                dependencyStore: null,\n                calendarManagerStore: null,\n                eventModelClass: null,\n                resourceModelClass: null,\n                assignmentModelClass: null,\n                dependencyModelClass: null,\n                calendarModelClass: null,\n                repopulateOnDataset: true\n            };\n        }\n        static get delayable() {\n            return {\n                repopulateReplica: 10\n            };\n        }\n    }\n    SchedulerBasicProjectMixin.applyConfigs = true;\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerBasicProjectMixin.prototype, \"unspecifiedTimeIsWorking\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: false })\n    ], SchedulerBasicProjectMixin.prototype, \"skipNonWorkingTimeWhenSchedulingManually\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerBasicProjectMixin.prototype, \"skipNonWorkingTimeInDurationWhenSchedulingManually\", void 0);\n    return SchedulerBasicProjectMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Reject } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { calculate, field } from '../../../../ChronoGraph/replica/Entity.js';\nimport { ConflictEffect, ConstraintInterval } from \"../../../chrono/Conflict.js\";\nimport { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { intersectIntervals } from '../../../scheduling/DateInterval.js';\nimport { Direction, ConstraintIntervalSide } from '../../../scheduling/Types.js';\nimport { isDateFinite, MAX_DATE, MIN_DATE } from \"../../../util/Constants.js\";\nimport { HasSubEventsMixin } from \"../scheduler_basic/HasSubEventsMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const calculateEffectiveStartDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration, collectIntersectionMeta) {\n    if (endDateIntervalIntersection.isIntervalEmpty())\n        return endDateIntervalIntersection; //EMPTY_INTERVAL\n    // If intersection details collecting is enabled (need this when preparing a scheduling conflict info)\n    if (collectIntersectionMeta && endDateIntervalIntersection.intersectionOf) {\n        const reflectedIntervals = new Set();\n        // Iterate over the intervals that took part in \"endDateIntervalIntersection\" building\n        // and reflect each of them to task \"End\" side.\n        // So we could compare each interval one by one.\n        for (const interval of endDateIntervalIntersection.intersectionOf) {\n            if (interval.isInfinite()) {\n                reflectedIntervals.add(interval);\n            }\n            else {\n                const startDate = interval.startDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.startDate, false, duration)\n                    :\n                        interval.startDate;\n                const endDate = interval.endDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.endDate, false, duration)\n                    :\n                        interval.endDate;\n                const originInterval = interval;\n                reflectedIntervals.add(originInterval.copyWith({\n                    reflectionOf: originInterval,\n                    side: originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,\n                    startDate,\n                    endDate,\n                }));\n            }\n        }\n        // override intersectionOf with reflected intervals\n        endDateIntervalIntersection.intersectionOf = reflectedIntervals;\n    }\n    const startDate = endDateIntervalIntersection.startDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.startDate, false, duration)\n        :\n            null;\n    const endDate = endDateIntervalIntersection.endDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.endDate, false, duration)\n        :\n            null;\n    return intersectIntervals([\n        startDateIntervalIntersection,\n        ConstraintInterval.new({\n            intersectionOf: endDateIntervalIntersection.intersectionOf,\n            startDate,\n            endDate\n        })\n    ], collectIntersectionMeta);\n};\nexport const calculateEffectiveEndDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration, collectIntersectionMeta) {\n    if (startDateIntervalIntersection.isIntervalEmpty())\n        return startDateIntervalIntersection; //EMPTY_INTERVAL\n    // If intersection details collecting is enabled (need this when preparing a scheduling conflict info)\n    if (collectIntersectionMeta) {\n        const reflectedIntervals = new Set();\n        // Iterate over the intervals that took part in \"startDateIntervalIntersection\" building\n        // and reflect each of them to task \"End\" side.\n        // So we could compare each interval one by one.\n        for (const interval of startDateIntervalIntersection.intersectionOf) {\n            // no need to reflect infinite intervals\n            if (interval.isInfinite()) {\n                reflectedIntervals.add(interval);\n            }\n            // reflect finite interval\n            else {\n                const startDate = interval.startDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.startDate, true, duration)\n                    :\n                        interval.startDate;\n                const endDate = interval.endDateIsFinite()\n                    ?\n                        yield* event.calculateProjectedXDateWithDuration(interval.endDate, true, duration)\n                    :\n                        interval.endDate;\n                const originInterval = interval;\n                // Make a reflection of the interval\n                reflectedIntervals.add(originInterval.copyWith({\n                    reflectionOf: originInterval,\n                    side: originInterval.side === ConstraintIntervalSide.Start ? ConstraintIntervalSide.End : ConstraintIntervalSide.Start,\n                    startDate,\n                    endDate,\n                }));\n            }\n        }\n        // override intersectionOf with reflected intervals\n        startDateIntervalIntersection.intersectionOf = reflectedIntervals;\n    }\n    const startDate = startDateIntervalIntersection.startDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.startDate, true, duration)\n        :\n            null;\n    const endDate = startDateIntervalIntersection.endDateIsFinite()\n        ?\n            yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.endDate, true, duration)\n        :\n            null;\n    return intersectIntervals([\n        endDateIntervalIntersection,\n        ConstraintInterval.new({\n            reflectionOf: startDate || endDate ? startDateIntervalIntersection : undefined,\n            intersectionOf: startDate || endDate ? startDateIntervalIntersection.intersectionOf : undefined,\n            startDate,\n            endDate\n        }),\n    ], collectIntersectionMeta);\n};\nexport const EarlyLateLazyness = true;\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin provides the constraint-based scheduling. Event is scheduled according to the set of _constraints_\n * which can be applied to start date or end date.\n *\n * Scheduling by constraints for an event can be disabled by setting its [[manuallyScheduled]] flag to `true`, which will delegate to previous behavior.\n *\n * The constraint is represented with the [[DateInterval]] class, which indicates the \"allowed\" interval for the\n * point being constrained.\n *\n * Scheduling by constraints algorithm\n * ---------------------------------\n *\n * Constraints for start date are accumulated in the [[earlyStartDateConstraintIntervals]] and [[startDateConstraintIntervals]] fields.\n * Constraints for end date are accumulated in the [[earlyEndDateConstraintIntervals]] and [[endDateConstraintIntervals]] fields.\n *\n * This mixin does not define where the constraints for the event comes from. The constraints are calculated in the field\n * calculation methods, (like [[calculateEarlyStartDateConstraintIntervals]]) which just return empty arrays. Some other mixins\n * may override those methods and can generate actual constraints (the [[ScheduledByDependenciesEarlyEventMixin]] is an example).\n * The \"early\" fields contains the constraints which are related to scheduling event in the as-soon-as-possible manner.\n * The fields w/o \"early\" prefix contains the constraints which do not related to the ASAP scheduling.\n *\n * \"Early\" and \"normal\" constraints for every date are combined, then intersected, which gives \"combined\" constraining interval.\n *\n * So at this point we have a \"combined\" constraining interval for start date and for end date.\n *\n * Then, the interval for start date is shifted on the event duration to the right and this gives an additional constraint for the\n * end date. The similar operation is done with the interval for the end date.\n *\n * After intersection with those additional intervals we receive the final constraining interval for both dates. Since we\n * are using the ASAP scheduling, we just pick the earliest possible date.\n *\n * If any of intervals is empty then we consider it as scheduling conflict, and [[EngineReplica.reject|reject]] the transaction.\n *\n */\nexport class ConstrainedEarlyEventMixin extends Mixin([HasSubEventsMixin], (base) => {\n    const superProto = base.prototype;\n    class ConstrainedEarlyEventMixin extends base {\n        // Skips non-working time if it's needed to the event\n        *maybeSkipNonWorkingTime(date, isForward = true) {\n            // We don't really need to skip non-working time for a summary task start/end dates.\n            // It just reflects corresponding min/max values of its children\n            if (yield* this.hasSubEvents())\n                return date;\n            let duration = yield* this.calculateEffectiveDuration();\n            return date && duration > 0 ? yield* this.skipNonWorkingTime(date, isForward) : date;\n        }\n        *calculateEffectiveConstraintInterval(isStartDate, startDateConstraintIntervals, endDateConstraintIntervals, collectIntersectionMeta = false) {\n            const effectiveDurationToUse = yield* this.calculateEffectiveDuration();\n            if (effectiveDurationToUse == null) {\n                return null;\n            }\n            const calculateIntervalFn = (isStartDate ? calculateEffectiveStartDateConstraintInterval : calculateEffectiveEndDateConstraintInterval);\n            const effectiveInterval = yield* calculateIntervalFn(this, intersectIntervals(startDateConstraintIntervals, collectIntersectionMeta), intersectIntervals(endDateConstraintIntervals, collectIntersectionMeta), effectiveDurationToUse, collectIntersectionMeta);\n            return effectiveInterval;\n        }\n        /**\n         * Calculation method for the [[startDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the start date.\n         */\n        *calculateStartDateConstraintIntervals() {\n            return [];\n        }\n        /**\n         * Calculation method for the [[endDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the end date.\n         */\n        *calculateEndDateConstraintIntervals() {\n            return [];\n        }\n        /**\n         * Calculation method for the [[earlyStartDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the start date during the ASAP scheduling.\n         */\n        *calculateEarlyStartDateConstraintIntervals() {\n            return [];\n        }\n        /**\n         * Calculation method for the [[earlyEndDateConstraintIntervals]]. Returns empty array by default.\n         * Override this method to return some extra constraints for the end date during the ASAP scheduling.\n         */\n        *calculateEarlyEndDateConstraintIntervals() {\n            return [];\n        }\n        *doCalculateEarlyEffectiveStartDateInterval(collectIntersectionMeta = false) {\n            const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;\n            const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;\n            return yield* this.calculateEffectiveConstraintInterval(true, \n            // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is\n            // used as storage for `this.$.earlyStartDateConstraintIntervals`\n            startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals), collectIntersectionMeta);\n        }\n        *calculateEarlyEffectiveStartDateInterval() {\n            return yield* this.doCalculateEarlyEffectiveStartDateInterval();\n        }\n        *doCalculateEarlyEffectiveEndDateInterval(collectIntersectionMeta = false) {\n            const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;\n            const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;\n            return yield* this.calculateEffectiveConstraintInterval(false, \n            // need to use concat instead of directly mutating the `startDateConstraintIntervals` since that is\n            // used as storage for `this.$.earlyStartDateConstraintIntervals`\n            startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals), collectIntersectionMeta);\n        }\n        *calculateEarlyEffectiveEndDateInterval() {\n            return yield* this.doCalculateEarlyEffectiveEndDateInterval();\n        }\n        /**\n         * The method defines whether the provided child event should be\n         * taken into account when calculating this summary event [[earlyStartDate]].\n         * Child events roll up their [[earlyStartDate]] values to their summary tasks.\n         * So a summary task [[earlyStartDate]] date gets equal to its minimal child [[earlyStartDate]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default, the method returns `true` to include all child events data.\n         * @param child Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildEarlyStartDate(child) {\n            return true;\n        }\n        *calculateMinChildrenEarlyStartDate() {\n            let result = MAX_DATE;\n            const subEventsIterator = yield* this.subEventsIterable();\n            for (let childEvent of subEventsIterator) {\n                let childDate;\n                if (!(yield* this.shouldRollupChildEarlyStartDate(childEvent)))\n                    continue;\n                if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {\n                    childDate = yield childEvent.$.minChildrenEarlyStartDate;\n                }\n                childDate = childDate || (yield childEvent.$.earlyStartDate);\n                if (childDate && childDate < result)\n                    result = childDate;\n            }\n            return result.getTime() - MAX_DATE.getTime() ? result : null;\n        }\n        /**\n         * The method defines whether the provided child event should be\n         * taken into account when calculating this summary event [[earlyEndDate]].\n         * Child events roll up their [[earlyEndDate]] values to their summary tasks.\n         * So a summary task [[earlyEndDate]] gets equal to its maximal child [[earlyEndDate]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default, the method returns `true` to include all child events data.\n         * @param child Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildEarlyEndDate(child) {\n            return true;\n        }\n        *calculateMaxChildrenEarlyEndDate() {\n            let result = MIN_DATE;\n            const subEventsIterator = yield* this.subEventsIterable();\n            for (let childEvent of subEventsIterator) {\n                let childDate;\n                if (!(yield* this.shouldRollupChildEarlyEndDate(childEvent)))\n                    continue;\n                if ((yield childEvent.$.manuallyScheduled) && (yield* childEvent.hasSubEvents())) {\n                    childDate = yield childEvent.$.maxChildrenEarlyEndDate;\n                }\n                childDate = childDate || (yield childEvent.$.earlyEndDate);\n                if (childDate && childDate > result)\n                    result = childDate;\n            }\n            return result.getTime() - MIN_DATE.getTime() ? result : null;\n        }\n        *calculateEarlyStartDateRaw() {\n            // Manually scheduled task treat its current start date as its early start date\n            // in case of forward scheduling.\n            // Late dates in that case are calculated the same way it happens for automatic tasks\n            if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === Direction.Forward) {\n                return yield this.$.startDate;\n            }\n            // Parent task calculate its early start date as minimal early start date of its children\n            if (yield* this.hasSubEvents()) {\n                return yield this.$.minChildrenEarlyStartDate;\n            }\n            if (!(yield* this.isConstrainedEarly())) {\n                return yield this.$.startDate;\n            }\n            let effectiveInterval = yield this.$.earlyEffectiveStartDateInterval;\n            if (effectiveInterval === null) {\n                return null;\n            }\n            else if (effectiveInterval.isIntervalEmpty()) {\n                // re-calculate effective resulting interval gathering intersection history\n                effectiveInterval = yield* this.doCalculateEarlyEffectiveStartDateInterval(true);\n                const conflict = ConflictEffect.new({\n                    intervals: [...effectiveInterval.intersectionOf]\n                });\n                if ((yield conflict) === EffectResolutionResult.Cancel) {\n                    yield Reject(conflict);\n                }\n                else {\n                    return null;\n                }\n            }\n            return isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null;\n        }\n        *calculateEarlyStartDate() {\n            const date = yield this.$.earlyStartDateRaw;\n            return yield* this.maybeSkipNonWorkingTime(date, true);\n        }\n        *calculateEarlyEndDateRaw() {\n            // Manually scheduled task treat its current end date as its early end date\n            // in case of forward scheduling.\n            // Late dates in that case are calculated the same way it happens for automatic tasks\n            if ((yield this.$.manuallyScheduled) && (yield this.$.direction) === Direction.Forward) {\n                return yield this.$.endDate;\n            }\n            // Parent task calculate its early end date as maximum early end date of its children\n            if (yield* this.hasSubEvents()) {\n                return yield this.$.maxChildrenEarlyEndDate;\n            }\n            if (!(yield* this.isConstrainedEarly())) {\n                return yield this.$.endDate;\n            }\n            let effectiveInterval = yield this.$.earlyEffectiveEndDateInterval;\n            if (effectiveInterval === null) {\n                return null;\n            }\n            else if (effectiveInterval.isIntervalEmpty()) {\n                // re-calculate effective resulting interval gathering intersection history\n                effectiveInterval = yield* this.doCalculateEarlyEffectiveEndDateInterval(true);\n                const conflict = ConflictEffect.new({\n                    intervals: [...effectiveInterval.intersectionOf]\n                });\n                if ((yield conflict) === EffectResolutionResult.Cancel) {\n                    yield Reject(conflict);\n                }\n                else {\n                    return null;\n                }\n            }\n            return isDateFinite(effectiveInterval.startDate) ? effectiveInterval.startDate : null;\n        }\n        *calculateEarlyEndDate() {\n            return yield this.$.earlyEndDateRaw;\n        }\n        *isConstrainedEarly() {\n            const startDateIntervals = yield this.$.startDateConstraintIntervals;\n            const endDateIntervals = yield this.$.endDateConstraintIntervals;\n            const earlyStartDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;\n            const earlyEndDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;\n            return Boolean(startDateIntervals?.length || endDateIntervals?.length || earlyStartDateConstraintIntervals?.length || earlyEndDateConstraintIntervals?.length);\n        }\n        *calculateStartDatePure() {\n            const direction = yield this.$.direction;\n            if (direction === Direction.Forward) {\n                // early exit if this mixin is not applicable, but only after(!) the direction check\n                // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                // depending on the direction\n                if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                    return yield* superProto.calculateStartDatePure.call(this);\n                }\n                return (yield this.$.earlyStartDate) || (yield* superProto.calculateStartDatePure.call(this));\n            }\n            else {\n                return yield* superProto.calculateStartDatePure.call(this);\n            }\n        }\n        *calculateStartDateProposed() {\n            const direction = yield this.$.direction;\n            switch (direction) {\n                case Direction.Forward:\n                    // early exit if this mixin is not applicable, but only after(!) the direction check\n                    // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                    // depending on the direction\n                    if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                        return yield* superProto.calculateStartDateProposed.call(this);\n                    }\n                    const autoStartDate = yield this.$.earlyStartDate;\n                    if (autoStartDate) {\n                        if (isDateFinite(autoStartDate))\n                            return autoStartDate;\n                        const baseSchedulingStartDate = yield* superProto.calculateStartDateProposed.call(this);\n                        const earlyEffectiveStartDateInterval = yield this.$.earlyEffectiveStartDateInterval;\n                        if (earlyEffectiveStartDateInterval.containsDate(baseSchedulingStartDate))\n                            return baseSchedulingStartDate;\n                        return isDateFinite(earlyEffectiveStartDateInterval.endDate) ? earlyEffectiveStartDateInterval.endDate : baseSchedulingStartDate;\n                    }\n                    else {\n                        return yield* superProto.calculateStartDateProposed.call(this);\n                    }\n                default:\n                    return yield* superProto.calculateStartDateProposed.call(this);\n            }\n        }\n        *calculateEndDatePure() {\n            const direction = yield this.$.direction;\n            if (direction === Direction.Forward) {\n                // early exit if this mixin is not applicable, but only after(!) the direction check\n                // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                // depending on the direction\n                if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                    return yield* superProto.calculateEndDatePure.call(this);\n                }\n                return (yield this.$.earlyEndDate) || (yield* superProto.calculateEndDatePure.call(this));\n            }\n            else {\n                return yield* superProto.calculateEndDatePure.call(this);\n            }\n        }\n        *calculateEndDateProposed() {\n            const direction = yield this.$.direction;\n            switch (direction) {\n                case Direction.Forward:\n                    // early exit if this mixin is not applicable, but only after(!) the direction check\n                    // this is because the `isConstrainedEarly` yield early constraint intervals, which are generally lazy,\n                    // depending on the direction\n                    if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled) || (yield this.$.unscheduled)) {\n                        return yield* superProto.calculateEndDateProposed.call(this);\n                    }\n                    const autoEndDate = yield this.$.earlyEndDate;\n                    if (autoEndDate) {\n                        if (isDateFinite(autoEndDate))\n                            return autoEndDate;\n                        const baseSchedulingEndDate = yield* superProto.calculateEndDateProposed.call(this);\n                        const earlyEffectiveEndDateInterval = yield this.$.earlyEffectiveEndDateInterval;\n                        if (earlyEffectiveEndDateInterval.containsDate(baseSchedulingEndDate))\n                            return baseSchedulingEndDate;\n                        return isDateFinite(earlyEffectiveEndDateInterval.endDate) ? earlyEffectiveEndDateInterval.endDate : baseSchedulingEndDate;\n                    }\n                    else {\n                        return yield* superProto.calculateEndDateProposed.call(this);\n                    }\n                default:\n                    return yield* superProto.calculateEndDateProposed.call(this);\n            }\n        }\n        *calculateDirection() {\n            const project = this.getProject();\n            return yield project.$.direction;\n        }\n    }\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"minChildrenEarlyStartDate\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyStartDateRaw\", void 0);\n    __decorate([\n        model_field({ type: 'date', persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyStartDate\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"maxChildrenEarlyEndDate\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEndDateRaw\", void 0);\n    __decorate([\n        model_field({ type: 'date', persist: false }, { lazy: EarlyLateLazyness, converter: dateConverter, persistent: false })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEndDate\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"startDateConstraintIntervals\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"endDateConstraintIntervals\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyStartDateConstraintIntervals\", void 0);\n    __decorate([\n        field({ lazy: EarlyLateLazyness })\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEndDateConstraintIntervals\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEffectiveStartDateInterval\", void 0);\n    __decorate([\n        field()\n    ], ConstrainedEarlyEventMixin.prototype, \"earlyEffectiveEndDateInterval\", void 0);\n    __decorate([\n        calculate('startDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateStartDateConstraintIntervals\", null);\n    __decorate([\n        calculate('endDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEndDateConstraintIntervals\", null);\n    __decorate([\n        calculate('earlyStartDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyStartDateConstraintIntervals\", null);\n    __decorate([\n        calculate('earlyEndDateConstraintIntervals')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEndDateConstraintIntervals\", null);\n    __decorate([\n        calculate('earlyEffectiveStartDateInterval')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEffectiveStartDateInterval\", null);\n    __decorate([\n        calculate('earlyEffectiveEndDateInterval')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEffectiveEndDateInterval\", null);\n    __decorate([\n        calculate('minChildrenEarlyStartDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateMinChildrenEarlyStartDate\", null);\n    __decorate([\n        calculate('maxChildrenEarlyEndDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateMaxChildrenEarlyEndDate\", null);\n    __decorate([\n        calculate('earlyStartDateRaw')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyStartDateRaw\", null);\n    __decorate([\n        calculate('earlyStartDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyStartDate\", null);\n    __decorate([\n        calculate('earlyEndDateRaw')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEndDateRaw\", null);\n    __decorate([\n        calculate('earlyEndDate')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateEarlyEndDate\", null);\n    __decorate([\n        calculate('direction')\n    ], ConstrainedEarlyEventMixin.prototype, \"calculateDirection\", null);\n    return ConstrainedEarlyEventMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious, ProposedOrPreviousValueOf } from '../../../../ChronoGraph/chrono/Effect.js';\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { calculate } from '../../../../ChronoGraph/replica/Entity.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Localizable from '../../../../Core/localization/Localizable.js';\nimport { ConflictResolution, ConstraintInterval, ConstraintIntervalDescription } from '../../../chrono/Conflict.js';\nimport { dateConverter, model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { ConstraintIntervalSide, ConstraintType, Direction } from '../../../scheduling/Types.js';\nimport { format } from '../../../util/Functions.js';\nimport { HasChildrenMixin } from '../scheduler_basic/HasChildrenMixin.js';\nimport { ConstrainedEarlyEventMixin } from './ConstrainedEarlyEventMixin.js';\nimport \"../../../localization/En.js\";\nimport { prototypeValue } from '../../../../ChronoGraph/util/Helpers.js';\n/**\n * This mixin implements a date-based based constraint for the event.\n * It provides the following constraint types:\n *\n * - _Start no earlier than (SNET)_ - restricts the event to start on or after the specified date.\n * - _Finish no earlier than (FNET)_ - restricts the event to finish on or after the specified date.\n * - _Start no later than (SNLT)_ - restricts the event to start before (or on) the specified date.\n * - _Finish no later than (FNLT)_ - restricts the event to finish before (or on) the specified date.\n * - _Must start on (MSO)_ - restricts the event to start on the specified date.\n * - _Must finish on (MFO)_ - restricts the event to finish on the specified date.\n *\n * The type of constraint is defined by the [[constraintType]] property. Types has self-descriptive names.\n * There's also [[constraintDate]] with a constraint date.\n *\n * **Please note** that [[manuallyScheduled|manually scheduled]] events ignore their constraints.\n */\nexport class HasDateConstraintMixin extends Mixin([ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class HasDateConstraint extends base {\n        constructor() {\n            super(...arguments);\n            // This flag allows to ignore setting pinning constraint when writing start date\n            this.ignorePinningConstraint = false;\n        }\n        writeStartDate(me, transaction, quark, date, keepDuration = true) {\n            // get constraint type that should be used to enforce start date or\n            // null if the change cannot be enforced (happens when the task is manually scheduled so no need for enforcement or\n            // some constraint is already set)\n            const project = this.getProject();\n            // `writeStartDate` will be called for initial write to the `startDate` at the point of adding it to graph\n            // at that time there possibly be no `direction` identifier yet\n            // it seems this line relies on the fact, that `direction` field is declared after the `startDate`\n            if (project?.addConstraintOnDateSet\n                && transaction.graph.hasIdentifier(this.$.direction)\n                && !project?.eventStore.isSyncingDataOnLoad\n                && !this.isReverting\n                && !project?.getStm().isRestoring) {\n                const constrainType = this.getStartDatePinConstraintType();\n                if (constrainType) {\n                    this.constraintType = constrainType;\n                    this.constraintDate = date;\n                }\n            }\n            return superProto.writeStartDate.call(this, me, transaction, quark, date, keepDuration);\n        }\n        writeEndDate(me, transaction, quark, date, keepDuration = false) {\n            // get constraint type that should be used to enforce End date or\n            // null if the change cannot be enforced (happens when the task is manually scheduled so no need for enforcement or\n            // some constraint is already set)\n            const project = this.getProject();\n            if (project?.addConstraintOnDateSet\n                && transaction.graph.hasIdentifier(this.$.direction)\n                && keepDuration\n                && !project?.eventStore.isSyncingDataOnLoad\n                && !project?.getStm().isRestoring) {\n                const constrainType = this.getEndDatePinConstraintType();\n                if (constrainType) {\n                    this.constraintType = constrainType;\n                    this.constraintDate = date;\n                }\n            }\n            return superProto.writeEndDate.call(this, me, transaction, quark, date, keepDuration);\n        }\n        *calculateConstraintType() {\n            let constraintType = yield ProposedOrPrevious;\n            // use proposed constraint type if provided and is applicable to the event\n            if (!(yield* this.isConstraintTypeApplicable(constraintType))) {\n                constraintType = null;\n            }\n            return constraintType;\n        }\n        *calculateConstraintDate(Y) {\n            let constraintDate = yield ProposedOrPrevious;\n            const constraintType = yield this.$.constraintType;\n            if (!constraintType) {\n                constraintDate = null;\n            }\n            // use proposed constraint date if provided\n            else if (!constraintDate) {\n                // fill constraint date based on constraint type provided\n                constraintDate = this.getConstraintTypeDefaultDate(Y, constraintType);\n            }\n            return constraintDate;\n        }\n        getStartDatePinConstraintType() {\n            const { direction } = this;\n            if (!this.isTaskPinnableWithConstraint())\n                return null;\n            switch (direction) {\n                case Direction.Forward: return ConstraintType.StartNoEarlierThan;\n                case Direction.Backward: return ConstraintType.StartNoLaterThan;\n            }\n        }\n        getEndDatePinConstraintType() {\n            const { direction } = this;\n            if (!this.isTaskPinnableWithConstraint())\n                return null;\n            switch (direction) {\n                case Direction.Forward: return ConstraintType.FinishNoEarlierThan;\n                case Direction.Backward: return ConstraintType.FinishNoLaterThan;\n            }\n        }\n        /**\n         * Indicates if the task can be pinned with a constraint\n         * to enforce its start/end date changes.\n         * @private\n         */\n        isTaskPinnableWithConstraint() {\n            const { manuallyScheduled, ignorePinningConstraint, constraintType } = this;\n            let result = false;\n            // we should not pin manually scheduled tasks\n            if (!manuallyScheduled && !ignorePinningConstraint) {\n                if (constraintType) {\n                    switch (constraintType) {\n                        case ConstraintType.StartNoEarlierThan:\n                        case ConstraintType.StartNoLaterThan:\n                        case ConstraintType.FinishNoEarlierThan:\n                        case ConstraintType.FinishNoLaterThan:\n                            result = true;\n                    }\n                }\n                // no constraints -> we can pin\n                else {\n                    result = true;\n                }\n            }\n            return result;\n        }\n        applyChangeset(rawChanges, phantomIdField, remote) {\n            // Raise a flag on the record to avoid engine setting pinning constraint when writing start date. We need to\n            // avoid pinning constraint in case remote dataset only contains start date for the parent record. If local\n            // parent record start date is different, start date will be written to the engine and constraint will be set.\n            // We don't need to do that here, dataset is supposed to complete so parent ends up with the same start date\n            // without unnecessary constraint\n            // https://github.com/bryntum/support/issues/5086\n            this.ignorePinningConstraint = remote;\n            //@ts-ignore\n            const result = super.applyChangeset(rawChanges, phantomIdField, remote);\n            this.ignorePinningConstraint = false;\n            return result;\n        }\n        /**\n         * Returns default constraint date value for the constraint type provided\n         * (either start or end date of the event).\n         */\n        getConstraintTypeDefaultDate(Y, constraintType) {\n            switch (constraintType) {\n                case ConstraintType.StartNoEarlierThan:\n                case ConstraintType.StartNoLaterThan:\n                case ConstraintType.MustStartOn:\n                    return Y(ProposedOrPreviousValueOf(this.$.startDate));\n                case ConstraintType.FinishNoEarlierThan:\n                case ConstraintType.FinishNoLaterThan:\n                case ConstraintType.MustFinishOn:\n                    return Y(ProposedOrPreviousValueOf(this.$.endDate));\n            }\n            return null;\n        }\n        /**\n         * Returns true if the provided constraint type is applicable to the event.\n         *\n         * @param {ConstraintType} constraintType Constraint type.\n         * @returns `True` if the provided constraint type is applicable (`false` otherwise).\n         */\n        *isConstraintTypeApplicable(constraintType) {\n            // Take into account if the event is leaf\n            const hasSubEvents = yield* this.hasSubEvents();\n            switch (constraintType) {\n                // these constraints are applicable to leaves only\n                case ConstraintType.FinishNoEarlierThan:\n                case ConstraintType.StartNoLaterThan:\n                case ConstraintType.MustFinishOn:\n                case ConstraintType.MustStartOn:\n                    return !hasSubEvents;\n            }\n            return true;\n        }\n        /**\n         * Sets the constraint type (if applicable) and constraining date to the task.\n         * @param {ConstraintType}  constraintType   Constraint type.\n         * @param {Date}            [constraintDate] Constraint date.\n         * @returns Promise<PropagateResult>\n         */\n        async setConstraint(constraintType, constraintDate) {\n            this.constraintType = constraintType;\n            if (constraintDate !== undefined) {\n                this.constraintDate = constraintDate;\n            }\n            return this.commitAsync();\n        }\n        *calculateEndDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateEndDateConstraintIntervals.call(this);\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const constraintType = yield this.$.constraintType;\n            const constraintDate = yield this.$.constraintDate;\n            const dateConstraintIntervalClass = this.project.dateConstraintIntervalClass;\n            // manually scheduled task ignores its constraints\n            if (!manuallyScheduled && constraintType && constraintDate) {\n                // if constraint type is\n                switch (constraintType) {\n                    case ConstraintType.MustFinishOn:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.End,\n                            startDate: constraintDate,\n                            endDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.FinishNoEarlierThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.End,\n                            startDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.FinishNoLaterThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.End,\n                            endDate: constraintDate\n                        }));\n                        break;\n                }\n            }\n            return intervals;\n        }\n        *calculateStartDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateStartDateConstraintIntervals.call(this);\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const constraintType = yield this.$.constraintType;\n            const constraintDate = yield this.$.constraintDate;\n            const dateConstraintIntervalClass = this.project.dateConstraintIntervalClass;\n            // manually scheduled task ignores its constraints\n            if (!manuallyScheduled && constraintType && constraintDate) {\n                // if constraint type is\n                switch (constraintType) {\n                    case ConstraintType.MustStartOn:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.Start,\n                            startDate: constraintDate,\n                            endDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.StartNoEarlierThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.Start,\n                            startDate: constraintDate\n                        }));\n                        break;\n                    case ConstraintType.StartNoLaterThan:\n                        intervals.unshift(dateConstraintIntervalClass.new({\n                            owner: this,\n                            side: ConstraintIntervalSide.Start,\n                            endDate: constraintDate\n                        }));\n                        break;\n                }\n            }\n            return intervals;\n        }\n    }\n    __decorate([\n        model_field({ type: 'string' }, { sync: true })\n    ], HasDateConstraint.prototype, \"constraintType\", void 0);\n    __decorate([\n        model_field({ type: 'date' }, { converter: dateConverter, sync: true })\n    ], HasDateConstraint.prototype, \"constraintDate\", void 0);\n    __decorate([\n        calculate('constraintType')\n    ], HasDateConstraint.prototype, \"calculateConstraintType\", null);\n    __decorate([\n        calculate('constraintDate')\n    ], HasDateConstraint.prototype, \"calculateConstraintDate\", null);\n    return HasDateConstraint;\n}) {\n}\n/**\n * Class implements resolving a scheduling conflict happened due to a task constraint.\n * It resolves the conflict by removing the constraint.\n */\nexport class RemoveDateConstraintConflictResolution extends Localizable(ConflictResolution) {\n    static get $name() {\n        return 'RemoveDateConstraintConflictResolution';\n    }\n    construct() {\n        super.construct(...arguments);\n        this.event = this.interval.owner;\n    }\n    getDescription() {\n        const { event } = this;\n        return format(this.L('L{descriptionTpl}'), event.name || event.id, this.interval.getConstraintName(event.constraintType));\n    }\n    /**\n     * Resolves the conflict by removing the event constraint.\n     */\n    resolve() {\n        this.event.constraintType = null;\n    }\n}\n/**\n * Description builder for an [[DateConstraintInterval|event constraint interval]].\n */\nexport class DateConstraintIntervalDescription extends ConstraintIntervalDescription {\n    static get $name() {\n        return 'DateConstraintIntervalDescription';\n    }\n    /**\n     * Returns description for the provided event constraint interval.\n     * @param interval Constraint interval\n     */\n    static getDescription(interval) {\n        let tpl;\n        switch (interval.owner.constraintType) {\n            case ConstraintType.StartNoEarlierThan:\n            case ConstraintType.FinishNoEarlierThan:\n            case ConstraintType.MustStartOn:\n            case ConstraintType.MustFinishOn:\n                tpl = this.L('L{startDateDescriptionTpl}');\n                break;\n            case ConstraintType.StartNoLaterThan:\n            case ConstraintType.FinishNoLaterThan:\n                tpl = this.L('L{endDateDescriptionTpl}');\n                break;\n        }\n        return format(tpl, ...this.getDescriptionParameters(interval));\n    }\n    /**\n     * Returns localized constraint name.\n     * @param constraintType Type of constraint\n     */\n    static getConstraintName(constraintType) {\n        return this.L('L{constraintTypeTpl}')[constraintType];\n    }\n    static getDescriptionParameters(interval) {\n        const event = interval.owner;\n        return [\n            DateHelper.format(interval.startDate, this.L('L{dateFormat}')),\n            DateHelper.format(interval.endDate, this.L('L{dateFormat}')),\n            event.name || event.id,\n            this.getConstraintName(event.constraintType)\n        ];\n    }\n}\n/**\n * Class implements an interval applied by an event [[constraintType|constraint]].\n * The interval suggests the only resolution option - removing the constraint.\n */\nexport class DateConstraintInterval extends ConstraintInterval {\n    getConstraintName(constraintType) {\n        return this.descriptionBuilderClass.getConstraintName(constraintType || this.owner.constraintType);\n    }\n    getDescription() {\n        return this.descriptionBuilderClass.getDescription(this);\n    }\n    isAffectedByTransaction(transaction) {\n        const event = this.owner;\n        transaction = transaction || event.graph.activeTransaction;\n        const constraintDateQuark = transaction.entries.get(event.$.constraintDate), constraintTypeQuark = transaction.entries.get(event.$.constraintType);\n        // new constrained event or modified constraint\n        return !transaction.baseRevision.hasIdentifier(event.$$) ||\n            constraintDateQuark && !constraintDateQuark.isShadow() ||\n            constraintTypeQuark && !constraintTypeQuark.isShadow();\n    }\n    /**\n     * Returns possible resolution options for cases when\n     * the interval takes part in a conflict.\n     *\n     * The interval suggests the only resolution option - removing the constraint.\n     */\n    getResolutions() {\n        return this.resolutions || (this.resolutions = [\n            this.removeDateConstraintConflictResolutionClass.new({ interval: this })\n        ]);\n    }\n}\n__decorate([\n    prototypeValue(RemoveDateConstraintConflictResolution)\n], DateConstraintInterval.prototype, \"removeDateConstraintConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DateConstraintIntervalDescription)\n], DateConstraintInterval.prototype, \"descriptionBuilderClass\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { isAtomicValue, prototypeValue } from '../../../../ChronoGraph/util/Helpers.js';\nimport { DependencyType, TimeUnit } from '../../../scheduling/Types.js';\nimport { HasDependenciesMixin } from \"../scheduler_basic/HasDependenciesMixin.js\";\nimport { ConstrainedEarlyEventMixin } from './ConstrainedEarlyEventMixin.js';\nimport { ConstraintInterval, ConflictResolution, ConstraintIntervalDescription } from '../../../chrono/Conflict.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport { format } from '../../../util/Functions.js';\nimport Localizable from '../../../../Core/localization/Localizable.js';\nimport \"../../../localization/En.js\";\nimport { model_field } from '../../../chrono/ModelFieldAtom.js';\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin adds support for scheduling event ASAP, by dependencies. All it does is\n * create the constraint interval for every incoming dependency. See [[ConstrainedEarlyEventMixin]] for\n * more details about constraint-based scheduling.\n *\n * The supported dependency types are listed in this enum: [[DependencyType]]\n */\nexport class ScheduledByDependenciesEarlyEventMixin extends Mixin([ConstrainedEarlyEventMixin, HasDependenciesMixin], (base) => {\n    const superProto = base.prototype;\n    class ScheduledByDependenciesEarlyEventMixin extends base {\n        /**\n         * The method defines wether the provided dependency should constrain the successor or not.\n         * If the method returns `true` the dependency constrains the successor and does not do that when `false` returned.\n         * By default the method returns `true` if the dependency is [[SchedulerProDependencyMixin.active|active]]\n         * and if this event is [[inactive|active]] (or both this event and the successor are [[inactive]]).\n         *\n         * This is used when calculating [[earlyStartDateConstraintIntervals]].\n         * @param dependency Dependency to consider.\n         * @returns `true` if the dependency should constrain successor, `false` if not.\n         */\n        *shouldPredecessorAffectScheduling(dependency) {\n            const fromEvent = yield dependency.$.fromEvent;\n            // ignore missing from events and inactive dependencies\n            return fromEvent && !isAtomicValue(fromEvent) && (yield dependency.$.active)\n                // ignore inactive predecessor (unless we both are inactive)\n                && (!(yield fromEvent.$.inactive) || (yield this.$.inactive));\n        }\n        *calculateEarlyStartDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateEarlyStartDateConstraintIntervals.call(this);\n            const project = this.getProject();\n            const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;\n            for (const dependency of (yield this.$.incomingDeps)) {\n                // ignore missing from events and inactive predecessors/dependencies\n                if (!(yield* this.shouldPredecessorAffectScheduling(dependency)))\n                    continue;\n                const predecessor = yield dependency.$.fromEvent;\n                let predecessorDate;\n                switch (yield dependency.$.type) {\n                    case DependencyType.EndToStart:\n                        predecessorDate = yield predecessor.$.earlyEndDateRaw;\n                        break;\n                    case DependencyType.StartToStart:\n                        predecessorDate = yield predecessor.$.earlyStartDateRaw;\n                        break;\n                }\n                if (predecessorDate) {\n                    const lag = yield dependency.$.lag;\n                    const lagUnit = yield dependency.$.lagUnit;\n                    const calendar = yield dependency.$.calendar;\n                    // this \"subscribes\" on the calendar's `version` field (which is incremented\n                    // every time when the intervals of the calendar changes)\n                    yield calendar.$.version;\n                    const interval = dependencyConstraintIntervalClass.new({\n                        owner: dependency,\n                        startDate: calendar.calculateEndDate(predecessorDate, yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond)),\n                        endDate: null\n                    });\n                    intervals.unshift(interval);\n                }\n            }\n            return intervals;\n        }\n        *calculateEarlyEndDateConstraintIntervals() {\n            const intervals = yield* superProto.calculateEarlyEndDateConstraintIntervals.call(this);\n            const project = this.getProject();\n            const dependencyConstraintIntervalClass = project.dependencyConstraintIntervalClass;\n            for (const dependency of (yield this.$.incomingDeps)) {\n                // ignore missing from events and inactive dependencies\n                if (!(yield* this.shouldPredecessorAffectScheduling(dependency)))\n                    continue;\n                const predecessor = yield dependency.$.fromEvent;\n                let predecessorDate;\n                switch (yield dependency.$.type) {\n                    case DependencyType.EndToEnd:\n                        predecessorDate = yield predecessor.$.earlyEndDateRaw;\n                        break;\n                    case DependencyType.StartToEnd:\n                        predecessorDate = yield predecessor.$.earlyStartDateRaw;\n                        break;\n                }\n                if (predecessorDate) {\n                    const lag = yield dependency.$.lag;\n                    const lagUnit = yield dependency.$.lagUnit;\n                    const calendar = yield dependency.$.calendar;\n                    // this \"subscribes\" on the calendar's `version` field (which is incremented\n                    // every time when the intervals of the calendar changes)\n                    yield calendar.$.version;\n                    const interval = dependencyConstraintIntervalClass.new({\n                        owner: dependency,\n                        startDate: calendar.calculateEndDate(predecessorDate, yield* project.$convertDuration(lag, lagUnit, TimeUnit.Millisecond)),\n                        endDate: null\n                    });\n                    intervals.unshift(interval);\n                }\n            }\n            return intervals;\n        }\n    }\n    __decorate([\n        model_field({ type: 'boolean' })\n    ], ScheduledByDependenciesEarlyEventMixin.prototype, \"inactive\", void 0);\n    return ScheduledByDependenciesEarlyEventMixin;\n}) {\n}\n/**\n * Base class for dependency interval resolutions.\n */\nexport class BaseDependencyResolution extends Localizable(ConflictResolution) {\n    static get $name() {\n        return 'BaseDependencyResolution';\n    }\n    getDescription() {\n        const { dependency } = this, { type, fromEvent, toEvent } = dependency;\n        return format(this.L('L{descriptionTpl}'), this.L('L{DependencyType.long}')[type], fromEvent.name || fromEvent.id, toEvent.name || toEvent.id);\n    }\n}\n/**\n * Dependency resolution removing the dependency.\n */\nexport class RemoveDependencyResolution extends BaseDependencyResolution {\n    static get $name() {\n        return 'RemoveDependencyResolution';\n    }\n    /**\n     * Resolves the conflict by removing the dependency.\n     */\n    resolve() {\n        this.dependency.remove();\n    }\n}\n/**\n * Dependency resolution deactivating the dependency.\n */\nexport class DeactivateDependencyResolution extends BaseDependencyResolution {\n    static get $name() {\n        return 'DeactivateDependencyResolution';\n    }\n    /**\n     * Resolves the conflict by deactivating the dependency.\n     */\n    resolve() {\n        this.dependency.active = false;\n    }\n}\n/**\n * Description builder for a [[DependencyConstraintInterval|dependency constraint interval]].\n */\nexport class DependencyConstraintIntervalDescription extends ConstraintIntervalDescription {\n    static get $name() {\n        return 'DependencyConstraintIntervalDescription';\n    }\n    static getDescriptionParameters(interval) {\n        const dependency = interval.owner;\n        return [\n            DateHelper.format(interval.startDate, this.L('L{dateFormat}')),\n            DateHelper.format(interval.endDate, this.L('L{dateFormat}')),\n            this.L('L{DependencyType.long}')[dependency.type],\n            dependency.fromEvent.name,\n            dependency.toEvent.name\n        ];\n    }\n}\n/**\n * Constraint interval applied by a dependency.\n *\n * In case for a conflict the class [[getResolutions|suggests]] two resolution options:\n * either [[RemoveDependencyResolution|removing]] or [[DeactivateDependencyResolution|deactivating]] the dependency.\n */\nexport class DependencyConstraintInterval extends ConstraintInterval {\n    isAffectedByTransaction(transaction) {\n        const dependency = this.owner;\n        transaction = transaction || dependency.graph.activeTransaction;\n        const { entries } = transaction, \n        // dependency identifiers to check\n        { fromEvent, toEvent, lag, lagUnit, type } = dependency.$, fromEventQuark = entries.get(fromEvent), toEventQuark = entries.get(toEvent), lagQuark = entries.get(lag), lagUnitQuark = entries.get(lagUnit), typeQuark = entries.get(type);\n        // new or modified dependency\n        return !transaction.baseRevision.hasIdentifier(dependency.$$) ||\n            fromEventQuark && !fromEventQuark.isShadow() ||\n            toEventQuark && !toEventQuark.isShadow() ||\n            lagQuark && !lagQuark.isShadow() ||\n            lagUnitQuark && !lagUnitQuark.isShadow() ||\n            typeQuark && !typeQuark.isShadow();\n    }\n    /**\n     * Returns the interval resolution options.\n     * There are two resolutions:\n     * - [[RemoveDependencyResolution|removing the dependency]]\n     * - [[DeactivateDependencyResolution|deactivating the dependency]].\n     */\n    getResolutions() {\n        return this.resolutions || (this.resolutions = [\n            this.deactivateDependencyConflictResolutionClass.new({ dependency: this.owner }),\n            this.removeDependencyConflictResolutionClass.new({ dependency: this.owner })\n        ]);\n    }\n}\n__decorate([\n    prototypeValue(RemoveDependencyResolution)\n], DependencyConstraintInterval.prototype, \"removeDependencyConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DeactivateDependencyResolution)\n], DependencyConstraintInterval.prototype, \"deactivateDependencyConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DependencyConstraintIntervalDescription)\n], DependencyConstraintInterval.prototype, \"descriptionBuilderClass\", void 0);\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from '../../../../ChronoGraph/chrono/Effect.js';\nimport { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { BaseAssignmentMixin } from '../scheduler_basic/BaseAssignmentMixin.js';\nimport { calculate, field } from '../../../../ChronoGraph/replica/Entity.js';\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * A mixin for the assignment entity at the Scheduler Pro level.\n */\nexport class SchedulerProAssignmentMixin extends Mixin([BaseAssignmentMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProAssignmentMixin extends base {\n        *calculateUnits() {\n            const event = yield this.$.event;\n            // if event of assignment presents - we always delegate to it\n            // (so that various assignment logic can be overridden by single event mixin)\n            if (event)\n                return yield* event.calculateAssignmentUnits(this);\n            // otherwise use proposed or current consistent value\n            return yield ProposedOrPrevious;\n        }\n        *calculateEffort() {\n            const event = yield this.$.event;\n            if (event) {\n                const startDate = yield event.$.startDate;\n                const endDate = yield event.$.endDate;\n                const calendar = yield event.$.effectiveCalendar;\n                if (startDate && endDate) {\n                    const map = new Map();\n                    map.set(calendar, [this]);\n                    return yield* event.calculateProjectedEffort(startDate, endDate, map);\n                }\n            }\n            return null;\n        }\n        *calculateActualDate() {\n            const event = yield this.$.event;\n            if (event) {\n                const startDate = yield event.$.startDate;\n                const duration = yield event.$.duration;\n                const percentDone = yield event.$.percentDone;\n                return yield* event.calculateProjectedXDateWithDuration(startDate, true, duration * 0.01 * percentDone);\n            }\n            return null;\n        }\n        *calculateActualEffort() {\n            const event = yield this.$.event;\n            if (event) {\n                const startDate = yield event.$.startDate;\n                const calendar = yield event.$.effectiveCalendar;\n                const actualDate = yield this.$.actualDate;\n                const assignmentsByCalendar = new Map();\n                assignmentsByCalendar.set(calendar, [this]);\n                return yield* event.calculateProjectedEffort(startDate, actualDate, assignmentsByCalendar);\n            }\n            return null;\n        }\n    }\n    __decorate([\n        model_field({ type: 'number', defaultValue: 100 })\n    ], SchedulerProAssignmentMixin.prototype, \"units\", void 0);\n    __decorate([\n        calculate('units')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateUnits\", null);\n    __decorate([\n        field({ lazy: true })\n    ], SchedulerProAssignmentMixin.prototype, \"effort\", void 0);\n    __decorate([\n        field({ lazy: true })\n    ], SchedulerProAssignmentMixin.prototype, \"actualDate\", void 0);\n    __decorate([\n        field({ lazy: true })\n    ], SchedulerProAssignmentMixin.prototype, \"actualEffort\", void 0);\n    __decorate([\n        calculate('effort')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateEffort\", null);\n    __decorate([\n        calculate('actualDate')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateActualDate\", null);\n    __decorate([\n        calculate('actualEffort')\n    ], SchedulerProAssignmentMixin.prototype, \"calculateActualEffort\", null);\n    return SchedulerProAssignmentMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field, write } from '../../../../ChronoGraph/replica/Entity.js';\nimport { isAtomicValue } from '../../../../ChronoGraph/util/Helpers.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport { model_field } from '../../../chrono/ModelFieldAtom.js';\nimport { DependenciesCalendar, TimeUnit } from '../../../scheduling/Types.js';\nimport { BaseDependencyMixin } from '../scheduler_basic/BaseDependencyMixin.js';\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * A mixin for the dependency entity at the Scheduler Pro level. It adds [[lag]] and [[lagUnit]] fields.\n *\n * The calendar according to which the lag time is calculated is defined with the\n * [[SchedulerProProjectMixin.dependenciesCalendar|dependenciesCalendar]] config of the project.\n */\nexport class SchedulerProDependencyMixin extends Mixin([BaseDependencyMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProDependencyMixin extends base {\n        *calculateCalendar() {\n            const project = this.getProject();\n            const dependenciesCalendar = yield project.$.dependenciesCalendar;\n            let calendar;\n            switch (dependenciesCalendar) {\n                case DependenciesCalendar.Project:\n                    calendar = yield project.$.effectiveCalendar;\n                    break;\n                case DependenciesCalendar.FromEvent:\n                    const fromEvent = yield this.$.fromEvent;\n                    calendar = fromEvent && !isAtomicValue(fromEvent) ? yield fromEvent.$.effectiveCalendar : null;\n                    break;\n                case DependenciesCalendar.ToEvent:\n                    const toEvent = yield this.$.toEvent;\n                    calendar = toEvent && !isAtomicValue(toEvent) ? yield toEvent.$.effectiveCalendar : null;\n                    break;\n            }\n            // the only case when there will be no calendar is when there's no either from/to event\n            // what to return in such case? use project calendar as \"defensive\" approach\n            if (!calendar)\n                calendar = yield project.$.effectiveCalendar;\n            return calendar;\n        }\n        /**\n         * Setter for the [[lag]]. Can also set [[lagUnit]] if second argument is provided.\n         *\n         * @param lag\n         * @param unit\n         */\n        async setLag(lag, unit) {\n            if (this.graph) {\n                this.graph.write(this.$.lag, lag, unit);\n                return this.graph.commitAsync();\n            }\n            else {\n                this.$.lag.DATA = lag;\n                if (unit != null)\n                    this.$.lagUnit.DATA = unit;\n            }\n        }\n        writeLag(me, transaction, quark, lag, unit = undefined) {\n            me.constructor.prototype.write.call(this, me, transaction, quark, lag);\n            if (unit != null)\n                transaction.write(this.$.lagUnit, unit);\n        }\n    }\n    __decorate([\n        model_field({ type: 'number', defaultValue: 0 })\n    ], SchedulerProDependencyMixin.prototype, \"lag\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: TimeUnit.Day }, { converter: DateHelper.normalizeUnit })\n    ], SchedulerProDependencyMixin.prototype, \"lagUnit\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProDependencyMixin.prototype, \"calendar\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true, persist: true })\n    ], SchedulerProDependencyMixin.prototype, \"active\", void 0);\n    __decorate([\n        calculate('calendar')\n    ], SchedulerProDependencyMixin.prototype, \"calculateCalendar\", null);\n    __decorate([\n        write('lag')\n    ], SchedulerProDependencyMixin.prototype, \"writeLag\", null);\n    return SchedulerProDependencyMixin;\n}) {\n}\n// /**\n//  * Dependency entity mixin type\n//  */\n// export type SchedulerProDependencyMixin = Mixin<typeof SchedulerProDependencyMixin>\n//\n// export interface SchedulerProDependencyMixinI extends Mixin<typeof SchedulerProDependencyMixin> {}\n//\n// export const BuildSchedulerProDependency = (base) => SchedulerProDependencyMixin(BuildMinimalBaseDependency(base))\n//\n// export class MinimalSchedulerProDependency extends SchedulerProDependencyMixin(MinimalBaseDependency) {}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { HasChildrenMixin } from \"../scheduler_basic/HasChildrenMixin.js\";\n/**\n * This mixin provides [[percentDone]] field for the event and methods for its calculation.\n *\n * For the parent events percent done is calculated based on the child events (ignores user input).\n * This behavior is controlled with the [[SchedulerProProjectMixin.autoCalculatePercentDoneForParentTasks]] config option.\n * The calculation is implemented in [[calculatePercentDone]] method.\n */\nexport class HasPercentDoneMixin extends Mixin([HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class HasPercentDoneMixin extends base {\n        /**\n         * Method calculates the task [[percentDone]] field value.\n         * For a summary task it calculates the value based on the task children if the project\n         * [[SchedulerProProjectMixin.autoCalculatePercentDoneForParentTasks|autoCalculatePercentDoneForParentTasks]] is true (default).\n         * And for a regular (leaf) task it just returns the field provided value as-is.\n         */\n        *calculatePercentDone() {\n            const childEvents = yield this.$.childEvents;\n            const project = this.getProject();\n            const autoCalculatePercentDoneForParentTasks = yield project.$.autoCalculatePercentDoneForParentTasks;\n            if (childEvents.size && autoCalculatePercentDoneForParentTasks) {\n                const summaryData = yield this.$.percentDoneSummaryData;\n                if (summaryData.totalDuration > 0) {\n                    return summaryData.completedDuration / summaryData.totalDuration;\n                }\n                else if (summaryData.milestonesNum > 0) {\n                    return summaryData.milestonesTotalPercentDone / summaryData.milestonesNum;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return yield ProposedOrPrevious;\n            }\n        }\n        /**\n         * The method defines whether the provided child event should be\n         * taken into account when calculating this summary event [[percentDone]].\n         *\n         * If the method returns `true` the child event is taken into account\n         * and if the method returns `false` it's not.\n         * By default the method returns `true` to include all child events data.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event should be taken into account, `false` if not.\n         */\n        *shouldRollupChildPercentDoneSummaryData(childEvent) {\n            return true;\n        }\n        *calculatePercentDoneSummaryData() {\n            const childEvents = yield this.$.childEvents;\n            if (childEvents.size) {\n                let summary = {\n                    totalDuration: 0,\n                    completedDuration: 0,\n                    milestonesNum: 0,\n                    milestonesTotalPercentDone: 0\n                };\n                for (const childEvent of childEvents) {\n                    if (!(yield* this.shouldRollupChildPercentDoneSummaryData(childEvent)))\n                        continue;\n                    const childSummaryData = yield childEvent.$.percentDoneSummaryData;\n                    if (childSummaryData) {\n                        summary.totalDuration += childSummaryData.totalDuration;\n                        summary.completedDuration += childSummaryData.completedDuration;\n                        summary.milestonesNum += childSummaryData.milestonesNum;\n                        summary.milestonesTotalPercentDone += childSummaryData.milestonesTotalPercentDone;\n                    }\n                }\n                return summary;\n            }\n            else {\n                const duration = yield this.$.duration;\n                if (typeof duration == 'number') {\n                    const durationInMs = yield* this.getProject().$convertDuration(duration, yield this.$.durationUnit, TimeUnit.Millisecond);\n                    const percentDone = yield this.$.percentDone;\n                    return {\n                        totalDuration: durationInMs,\n                        completedDuration: durationInMs * percentDone,\n                        milestonesNum: durationInMs === 0 ? 1 : 0,\n                        milestonesTotalPercentDone: durationInMs === 0 ? percentDone : 0,\n                    };\n                    // we can't calculate w/o duration\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    __decorate([\n        model_field({ type: 'number', defaultValue: 0 })\n    ], HasPercentDoneMixin.prototype, \"percentDone\", void 0);\n    __decorate([\n        field()\n    ], HasPercentDoneMixin.prototype, \"percentDoneSummaryData\", void 0);\n    __decorate([\n        calculate('percentDone')\n    ], HasPercentDoneMixin.prototype, \"calculatePercentDone\", null);\n    __decorate([\n        calculate('percentDoneSummaryData')\n    ], HasPercentDoneMixin.prototype, \"calculatePercentDoneSummaryData\", null);\n    return HasPercentDoneMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasProposedValue } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Reject } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { CalendarIteratorResult } from \"../../../calendar/CalendarCache.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { EmptyCalendarEffect } from \"../scheduler_basic/BaseCalendarMixin.js\";\nimport { BaseHasAssignmentsMixin } from \"../scheduler_basic/BaseHasAssignmentsMixin.js\";\nimport { EffectResolutionResult } from \"../../../chrono/SchedulingIssueEffect.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixins enhances the purely visual [[BaseHasAssignmentsMixin]] with scheduling according\n * to the calendars of the assigned resources.\n *\n * A time interval will be \"counted\" into the event duration, only if at least one assigned\n * resource has that interval as working time, and the event's own calendar also has that interval\n * as working. Otherwise the time is skipped and not counted into event's duration.\n */\nexport class SchedulerProHasAssignmentsMixin extends Mixin([BaseHasAssignmentsMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProHasAssignmentsMixin extends base {\n        *hasProposedValueForUnits() {\n            const assignments = yield this.$.assigned;\n            for (const assignment of assignments) {\n                const resource = yield assignment.$.resource;\n                if (resource && (yield HasProposedValue(assignment.$.units)))\n                    return true;\n            }\n            return false;\n        }\n        /**\n         * A method which assigns a resource to the current event\n         */\n        async assign(resource, units = 100) {\n            const assignmentCls = this.getProject().assignmentStore.modelClass;\n            this.addAssignment(new assignmentCls({\n                event: this,\n                resource: resource,\n                units: units\n            }));\n            return this.commitAsync();\n        }\n        *forEachAvailabilityInterval(options, func) {\n            const calendar = yield this.$.effectiveCalendar;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;\n            const ignoreResourceCalendar = (yield this.$.ignoreResourceCalendar) || options.ignoreResourceCalendar || !assignmentsByCalendar.size;\n            const maxRange = this.getProject().maxCalendarRange;\n            if (maxRange) {\n                options = Object.assign({ maxRange }, options);\n            }\n            return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {\n                const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                if (calendarsStatus.get(calendar)\n                    &&\n                        (ignoreResourceCalendar || workCalendars.some((calendar) => assignmentsByCalendar.has(calendar)))) {\n                    return func(startDate, endDate, calendarCacheIntervalMultiple);\n                }\n            });\n        }\n        *calculateEffectiveCalendarsCombination() {\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const project = this.getProject();\n            const calendars = [yield this.$.effectiveCalendar];\n            if (!manuallyScheduled || project.skipNonWorkingTimeInDurationWhenSchedulingManually) {\n                const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n                calendars.push(...assignmentsByCalendar.keys());\n            }\n            return this.getProject().combineCalendars(calendars);\n        }\n        *calculateAssignmentsByCalendar() {\n            const assignments = yield this.$.assigned;\n            const result = new Map();\n            for (const assignment of assignments) {\n                const resource = yield assignment.$.resource;\n                if (resource) {\n                    const resourceCalendar = yield resource.$.effectiveCalendar;\n                    let assignments = result.get(resourceCalendar);\n                    if (!assignments) {\n                        assignments = [];\n                        result.set(resourceCalendar, assignments);\n                    }\n                    assignments.push(assignment);\n                }\n            }\n            return result;\n        }\n        *getBaseOptionsForDurationCalculations() {\n            return { ignoreResourceCalendar: false };\n        }\n        *useEventAvailabilityIterator() {\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            return assignmentsByCalendar.size > 0;\n        }\n        *skipNonWorkingTime(date, isForward = true, iteratorOptions) {\n            if (!date)\n                return null;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const ignoreResourceCalendar = yield this.$.ignoreResourceCalendar;\n            if (yield* this.useEventAvailabilityIterator()) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: date, isForward } : { endDate: date, isForward }, iteratorOptions);\n                let workingDate;\n                const skipRes = yield* this.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {\n                    workingDate = isForward ? startDate : endDate;\n                    return false;\n                });\n                if (skipRes === CalendarIteratorResult.MaxRangeReached || skipRes === CalendarIteratorResult.FullRangeIterated) {\n                    const calendars = [yield this.$.effectiveCalendar];\n                    // if we take resource calendars into account collect them\n                    // and provide to EmptyCalendarEffect instance\n                    if (!options.ignoreResourceCalendar && !ignoreResourceCalendar) {\n                        calendars.push(...assignmentsByCalendar.keys());\n                    }\n                    const effect = EmptyCalendarEffect.new({\n                        event: this,\n                        calendars,\n                        date,\n                        isForward\n                    });\n                    if ((yield effect) === EffectResolutionResult.Cancel) {\n                        yield Reject(effect);\n                    }\n                    else {\n                        return null;\n                    }\n                }\n                return new Date(workingDate);\n            }\n            else {\n                return yield* superProto.skipNonWorkingTime.call(this, date, isForward);\n            }\n        }\n        *calculateProjectedDuration(startDate, endDate, durationUnit, iteratorOptions) {\n            if (!startDate || !endDate) {\n                return null;\n            }\n            if (yield* this.useEventAvailabilityIterator()) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), { startDate, endDate, isForward: true }, iteratorOptions);\n                const adjustDurationToDST = this.getProject().adjustDurationToDST;\n                let result = 0;\n                yield* this.forEachAvailabilityInterval(options, (startDate, endDate) => {\n                    result += endDate.getTime() - startDate.getTime();\n                    if (adjustDurationToDST) {\n                        const dstDiff = startDate.getTimezoneOffset() - endDate.getTimezoneOffset();\n                        result += dstDiff * 60 * 1000;\n                    }\n                });\n                if (!durationUnit)\n                    durationUnit = yield this.$.durationUnit;\n                return yield* this.getProject().$convertDuration(result, TimeUnit.Millisecond, durationUnit);\n            }\n            else {\n                return yield* superProto.calculateProjectedDuration.call(this, startDate, endDate, durationUnit);\n            }\n        }\n        *calculateProjectedXDateWithDuration(baseDate, isForward = true, duration, durationUnit, iteratorOptions) {\n            if (duration == null || isNaN(duration) || baseDate == null)\n                return null;\n            if (duration == 0)\n                return baseDate;\n            durationUnit = durationUnit || (yield this.$.durationUnit);\n            const durationMS = yield* this.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond);\n            let resultN = baseDate.getTime();\n            let leftDuration = durationMS;\n            const calendar = yield this.$.effectiveCalendar;\n            if (yield* this.useEventAvailabilityIterator()) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: baseDate, isForward } : { endDate: baseDate, isForward }, iteratorOptions);\n                const adjustDurationToDST = this.getProject().adjustDurationToDST;\n                const iterationRes = yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                    const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                    if (intervalDuration >= leftDuration) {\n                        if (adjustDurationToDST) {\n                            const dstDiff = isForward\n                                ? intervalStart.getTimezoneOffset() - (new Date(intervalStartN + leftDuration)).getTimezoneOffset()\n                                : (new Date(intervalEndN - leftDuration)).getTimezoneOffset() - intervalEnd.getTimezoneOffset();\n                            leftDuration -= dstDiff * 60 * 1000;\n                        }\n                        resultN = isForward ? intervalStartN + leftDuration : intervalEndN - leftDuration;\n                        return false;\n                    }\n                    else {\n                        leftDuration -= intervalDuration;\n                        if (adjustDurationToDST) {\n                            const dstDiff = intervalStart.getTimezoneOffset() - intervalEnd.getTimezoneOffset();\n                            leftDuration -= dstDiff * 60 * 1000;\n                        }\n                    }\n                });\n                // this will cause the method to return `null` if there's some problem with iterator\n                // easier to debug than a wrong number\n                return iterationRes === CalendarIteratorResult.StoppedByIterator ? new Date(resultN) : null;\n            }\n            else {\n                return calendar.accumulateWorkingTime(baseDate, durationMS, isForward).finalDate;\n            }\n        }\n    }\n    __decorate([\n        field()\n    ], SchedulerProHasAssignmentsMixin.prototype, \"effectiveCalendarsCombination\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProHasAssignmentsMixin.prototype, \"assignmentsByCalendar\", void 0);\n    __decorate([\n        model_field({ type: 'boolean' })\n    ], SchedulerProHasAssignmentsMixin.prototype, \"ignoreResourceCalendar\", void 0);\n    __decorate([\n        calculate('effectiveCalendarsCombination')\n    ], SchedulerProHasAssignmentsMixin.prototype, \"calculateEffectiveCalendarsCombination\", null);\n    __decorate([\n        calculate('assignmentsByCalendar')\n    ], SchedulerProHasAssignmentsMixin.prototype, \"calculateAssignmentsByCalendar\", null);\n    return SchedulerProHasAssignmentsMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasProposedValue, PreviousValueOf, ProposedArgumentsOf, ProposedOrPrevious, ProposedOrPreviousValueOf } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { CalculatedValueGen } from \"../../../../ChronoGraph/chrono/Identifier.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalculateProposed, CycleDescription, CycleResolution, Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { calculate, field, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { FieldIdentifier } from \"../../../../ChronoGraph/replica/Identifier.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { DurationVar, EndDateVar, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { BaseEventMixin } from \"../scheduler_basic/BaseEventMixin.js\";\nexport const MasterStartDateVar = Symbol('MasterStartDateVar');\nexport const MasterEndDateVar = Symbol('MasterEndDateVar');\nexport const MasterDurationVar = Symbol('MasterDurationVar');\nexport const MasterTotalDurationVar = Symbol('MasterTotalDurationVar');\nexport const StartOffsetVar = Symbol('StartOffsetVar');\nexport const EndOffsetVar = Symbol('EndOffsetVar');\nexport const durationByOffsetsFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartOffsetVar, EndOffsetVar])\n});\nexport const startDateByMasterStartAndStartOffsetFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([StartOffsetVar, MasterStartDateVar])\n});\nexport const endDateByMasterStartAndEndOffsetFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([EndOffsetVar, MasterStartDateVar])\n});\nexport const startOffsetByMasterStartAndStartDateFormula = Formula.new({\n    output: StartOffsetVar,\n    inputs: new Set([StartDateVar, MasterStartDateVar])\n});\nexport const endOffsetByMasterStartAndEndDateFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([EndDateVar, MasterStartDateVar])\n});\nexport const startOffsetByEndOffsetAndDurationFormula = Formula.new({\n    output: StartOffsetVar,\n    inputs: new Set([EndOffsetVar, DurationVar])\n});\nexport const endOffsetByStartOffsetAndDurationFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([StartOffsetVar, DurationVar])\n});\nexport const endOffsetByMasterTotalDurationAndStartOffsetFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([StartOffsetVar, MasterTotalDurationVar])\n});\nexport const endOffsetByMasterDurationAndStartOffsetFormula = Formula.new({\n    output: EndOffsetVar,\n    inputs: new Set([StartOffsetVar, MasterDurationVar])\n});\n// export const endOffsetByMasterEndDateAndStartOffsetFormula = Formula.new({\n//     output      : EndOffsetVar,\n//     inputs      : new Set([ StartOffsetVar, MasterEndDateVar ])\n// })\nexport const durationByMasterEndDateFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartOffsetVar, MasterEndDateVar])\n});\nexport const segmentCycleDescription = CycleDescription.new({\n    variables: new Set([\n        StartDateVar,\n        EndDateVar,\n        DurationVar,\n        MasterStartDateVar,\n        MasterEndDateVar,\n        MasterDurationVar,\n        MasterTotalDurationVar,\n        StartOffsetVar,\n        EndOffsetVar\n    ]),\n    formulas: new Set([\n        // the order of formulas is important here - the earlier ones are preferred\n        durationByOffsetsFormula,\n        startDateByMasterStartAndStartOffsetFormula,\n        endDateByMasterStartAndEndOffsetFormula,\n        startOffsetByEndOffsetAndDurationFormula,\n        startOffsetByMasterStartAndStartDateFormula,\n        endOffsetByStartOffsetAndDurationFormula,\n        endOffsetByMasterTotalDurationAndStartOffsetFormula,\n        endOffsetByMasterDurationAndStartOffsetFormula,\n        // endOffsetByMasterEndDateAndStartOffsetFormula,\n        endOffsetByMasterStartAndEndDateFormula,\n        durationByMasterEndDateFormula\n    ])\n});\nexport const segmentCycleResolution = CycleResolution.new({\n    description: segmentCycleDescription,\n    defaultResolutionFormulas: new Set([\n        endDateByMasterStartAndEndOffsetFormula,\n        endOffsetByMasterStartAndEndDateFormula,\n        endOffsetByStartOffsetAndDurationFormula\n    ])\n});\nexport class SegmentSEDDispatcherIdentifier extends FieldIdentifier.mix(CalculatedValueGen) {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        return resolution1.get(StartDateVar) === resolution2.get(StartDateVar)\n            && resolution1.get(EndDateVar) === resolution2.get(EndDateVar)\n            && resolution1.get(DurationVar) === resolution2.get(DurationVar)\n            && resolution1.get(MasterStartDateVar) === resolution2.get(MasterStartDateVar)\n            && resolution1.get(MasterEndDateVar) === resolution2.get(MasterEndDateVar)\n            && resolution1.get(MasterDurationVar) === resolution2.get(MasterDurationVar)\n            && resolution1.get(MasterTotalDurationVar) === resolution2.get(MasterTotalDurationVar)\n            && resolution1.get(StartOffsetVar) === resolution2.get(StartOffsetVar)\n            && resolution1.get(EndOffsetVar) === resolution2.get(EndOffsetVar);\n    }\n}\n/**\n * This is the segment class [[SchedulerProProjectMixin]] works with.\n */\nexport class SchedulerProEventSegment extends Mixin([BaseEventMixin], (base) => {\n    class SchedulerProEventSegment extends base {\n        get isEventSegment() {\n            return true;\n        }\n        get stm() {\n            // use main event StateTrackingManager\n            return this.event?.stm;\n        }\n        set stm(value) {\n        }\n        writeStartDate(me, transaction, quark, date, keepDuration = true) {\n            const event = this.event;\n            const project = this.getProject();\n            // if it's the very first segment and it's not data loading or part of STM undo/redo\n            if (event && !this.previousSegment && transaction.baseRevision.hasIdentifier(me) && !(project && project.getStm().isRestoring)) {\n                event.$.startDate.constructor.prototype.write.call(this, event.$.startDate, transaction, null, date, keepDuration);\n            }\n            else {\n                me.constructor.prototype.write.call(this, me, transaction, quark, date, keepDuration);\n            }\n            // if we have next segment(s) and we have to respect and not overlap them\n            if (keepDuration && this.nextSegment) {\n                const shift = this.endOffset - this.nextSegment.startOffset;\n                if (shift > 0) {\n                    let segment = this;\n                    // push next segments forward by the lag duration\n                    while ((segment = segment.nextSegment)) {\n                        segment.startOffset += shift;\n                        segment.endOffset += shift;\n                    }\n                }\n            }\n        }\n        shouldRecordFieldChange(fieldName, oldValue, newValue) {\n            return (fieldName === 'startOffset' || fieldName === 'endOffset') || super.shouldRecordFieldChange(fieldName, oldValue, newValue);\n        }\n        *calculateStartOffset() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(StartOffsetVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (resolution === CalculateProposed) {\n                result = yield ProposedOrPrevious;\n            }\n            else if (resolution === startOffsetByEndOffsetAndDurationFormula.formulaId) {\n                result = yield* this.calculateStartOffsetByEndOffsetAndDuration();\n            }\n            else if (resolution === startOffsetByMasterStartAndStartDateFormula.formulaId) {\n                const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);\n                const startDate = yield ProposedOrPreviousValueOf(this.$.startDate);\n                result = yield* this.event.calculateProjectedDuration(masterStartDate, startDate, TimeUnit.Millisecond, { ignoreSegments: true });\n            }\n            return result;\n        }\n        *calculateEndOffset() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(EndOffsetVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (resolution === CalculateProposed) {\n                result = yield ProposedOrPrevious;\n            }\n            else if (resolution === endOffsetByStartOffsetAndDurationFormula.formulaId) {\n                result = yield* this.calculateEndOffsetByStartOffsetAndDuration();\n            }\n            else if (resolution === endOffsetByMasterStartAndEndDateFormula.formulaId) {\n                const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);\n                const endDate = yield ProposedOrPreviousValueOf(this.$.endDate);\n                result = yield* this.event.calculateProjectedDuration(masterStartDate, endDate, TimeUnit.Millisecond, { ignoreSegments: true });\n            }\n            else if (resolution === endOffsetByMasterDurationAndStartOffsetFormula.formulaId) {\n                result = yield* this.calculateEndOffsetByMasterDurationAndStartOffset();\n            }\n            else if (resolution === endOffsetByMasterTotalDurationAndStartOffsetFormula.formulaId) {\n                result = yield* this.calculateEndOffsetByMasterTotalDurationAndStartOffset();\n            }\n            return result;\n        }\n        *calculateStartDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const formula = dispatcher.resolution.get(StartDateVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (formula === startDateByMasterStartAndStartOffsetFormula.formulaId) {\n                result = yield* this.calculateStartDateByMasterStartAndStartOffset();\n            }\n            else {\n                result = yield* super.calculateStartDate();\n            }\n            return result;\n        }\n        *calculateEndDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const formula = dispatcher.resolution.get(EndDateVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (formula === endDateByMasterStartAndEndOffsetFormula.formulaId) {\n                result = yield* this.calculateEndDateByMasterStartAndEndOffset();\n            }\n            else {\n                result = yield* super.calculateEndDate();\n            }\n            return result;\n        }\n        *calculateDuration() {\n            const dispatcher = yield this.$.dispatcher;\n            const formula = dispatcher.resolution.get(DurationVar);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            let result;\n            if (formula === durationByOffsetsFormula.formulaId) {\n                result = yield* this.calculateDurationByOffsets();\n            }\n            else if (formula === durationByMasterEndDateFormula.formulaId) {\n                result = yield* this.calculateDurationByOffsets();\n            }\n            else {\n                result = yield* super.calculateDuration();\n            }\n            return result;\n        }\n        buildProposedDispatcher(me, quark, transaction) {\n            const dispatcher = super.buildProposedDispatcher(me, quark, transaction);\n            dispatcher.addPreviousValueFlag(MasterStartDateVar);\n            dispatcher.addPreviousValueFlag(StartOffsetVar);\n            dispatcher.addPreviousValueFlag(EndOffsetVar);\n            return dispatcher;\n        }\n        *prepareDispatcher(YIELD) {\n            const dispatcher = yield* super.prepareDispatcher(YIELD);\n            // return last value if the segment is detached\n            if (!this.event) {\n                return dispatcher; //yield ProposedOrPrevious\n            }\n            // ProposedValueOf(this.event.$.startDate)\n            if (YIELD(PreviousValueOf(this.event.$.startDate)) != null)\n                dispatcher.addPreviousValueFlag(MasterStartDateVar);\n            if (YIELD(HasProposedValue(this.event.$.startDate)))\n                dispatcher.addProposedValueFlag(MasterStartDateVar);\n            if (!YIELD(HasProposedValue(this.event.$.segments))) {\n                dispatcher.collectInfo(YIELD, this.event.$.duration, MasterDurationVar);\n                if (YIELD(HasProposedValue(this.event.$.endDate))) {\n                    const masterEndDateArgs = YIELD(ProposedArgumentsOf(this.event.$.endDate));\n                    if (!masterEndDateArgs?.[0]) {\n                        dispatcher.addProposedValueFlag(MasterEndDateVar);\n                    }\n                }\n                const masterDispatcher = YIELD(this.event.$.dispatcher);\n                if (masterDispatcher.resolution.get(StartDateVar) === CalculateProposed &&\n                    masterDispatcher.resolution.get(EndDateVar) === CalculateProposed) {\n                    dispatcher.addProposedValueFlag(MasterTotalDurationVar);\n                }\n            }\n            dispatcher.collectInfo(YIELD, this.$.startOffset, StartOffsetVar);\n            dispatcher.collectInfo(YIELD, this.$.endOffset, EndOffsetVar);\n            return dispatcher;\n        }\n        cycleResolutionContext(Y) {\n            return segmentCycleResolution;\n        }\n        // endOffsetByMasterDurationAndStartOffsetFormula\n        *calculateEndOffsetByMasterDurationAndStartOffset() {\n            const masterDuration = yield ProposedOrPreviousValueOf(this.event.$.duration); //yield this.event.$.duration\n            const masterDurationUnit = yield this.event.$.durationUnit;\n            const startOffset = yield this.$.startOffset;\n            const nextSegment = this.nextSegment;\n            let result;\n            let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);\n            const segments = [];\n            let segment = this;\n            while ((segment = segment.previousSegment)) {\n                segments.push(segment);\n            }\n            for (let i = segments.length - 1; i >= 0; i--) {\n                const segment = segments[i];\n                const segmentStartOffset = yield ProposedOrPreviousValueOf(segment.$.startOffset);\n                const segmentEndOffset = yield ProposedOrPreviousValueOf(segment.$.endOffset);\n                const segmentDurationMs = segmentEndOffset - segmentStartOffset;\n                masterDurationMs -= segmentDurationMs;\n            }\n            if (masterDurationMs > 0) {\n                if (!nextSegment) {\n                    result = startOffset + masterDurationMs;\n                }\n                else {\n                    result = startOffset + Math.min(masterDurationMs, (yield ProposedOrPreviousValueOf(this.$.endOffset)) - startOffset);\n                }\n            }\n            // return start offset in case we have no duration left for this segment\n            // then it will have start offset === end offset\n            else {\n                result = startOffset;\n            }\n            return result;\n        }\n        // endOffsetByMasterDurationAndStartOffsetFormula\n        *calculateEndOffsetByMasterTotalDurationAndStartOffset() {\n            const masterStartDate = yield ProposedOrPreviousValueOf(this.event.$.startDate);\n            const masterEndDate = yield ProposedOrPreviousValueOf(this.event.$.endDate);\n            const masterTotalDurationMs = yield* this.event.calculateProjectedDuration(masterStartDate, masterEndDate, TimeUnit.Millisecond, { ignoreSegments: true });\n            const startOffset = yield ProposedOrPreviousValueOf(this.$.startOffset);\n            let endOffset = yield ProposedOrPreviousValueOf(this.$.endOffset);\n            let nextSegment = this.nextSegment;\n            if (startOffset <= masterTotalDurationMs) {\n                // if the segment is inside master event time span\n                if (endOffset <= masterTotalDurationMs) {\n                    // if that's the last one (either by index or by the fact the next segment is ouside of the event range)\n                    // make its end === master end\n                    if (!nextSegment || (yield ProposedOrPreviousValueOf(nextSegment.$.startOffset)) >= masterTotalDurationMs) {\n                        return masterTotalDurationMs;\n                    }\n                    // otherwise keep existing value\n                    return endOffset;\n                }\n                // if the segment finishes later than the master event - make its end === master end\n                else {\n                    return masterTotalDurationMs;\n                }\n            }\n            // if the segment is outside of the master event - make its duration zero\n            return yield this.$.startOffset;\n        }\n        // startOffsetByEndOffsetAndDurationFormula\n        *calculateStartOffsetByEndOffsetAndDuration() {\n            const duration = yield this.$.duration;\n            const durationUnit = yield this.$.durationUnit;\n            const endOffset = yield this.$.endOffset;\n            return endOffset - (yield* this.event.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n        }\n        // endOffsetByStartOffsetAndDurationFormula\n        *calculateEndOffsetByStartOffsetAndDuration() {\n            const duration = yield this.$.duration;\n            const durationUnit = yield this.$.durationUnit;\n            const startOffset = yield this.$.startOffset;\n            return startOffset + (yield* this.event.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond));\n        }\n        // endDateByMasterStartAndEndOffsetFormula\n        *calculateEndDateByMasterStartAndEndOffset() {\n            const masterStartDate = yield this.event.$.startDate;\n            const endOffset = yield this.$.endOffset;\n            const rawDate = yield* this.event.calculateProjectedXDateWithDuration(masterStartDate, true, endOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                ? rawDate\n                : yield* this.event.skipNonWorkingTime(rawDate, false);\n        }\n        // startDateByMasterStartAndStartOffsetFormula\n        *calculateStartDateByMasterStartAndStartOffset() {\n            const masterStartDate = yield this.event.$.startDate;\n            const startOffset = yield this.$.startOffset;\n            const rawDate = yield* this.event.calculateProjectedXDateWithDuration(masterStartDate, true, startOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            return manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                ? rawDate\n                : yield* this.event.skipNonWorkingTime(rawDate);\n        }\n        // durationByOffsetsFormula\n        *calculateDurationByOffsets() {\n            const startOffset = yield this.$.startOffset;\n            const endOffset = yield this.$.endOffset;\n            const durationUnit = yield this.$.durationUnit;\n            return yield* this.getProject().$convertDuration(endOffset - startOffset, TimeUnit.Millisecond, durationUnit);\n        }\n        *calculatePercentDone() {\n            let result = 0;\n            // return last value if the segment is detached\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            const segments = yield this.event.$.segments;\n            if (segments) {\n                const masterPercentDone = yield this.event.$.percentDone;\n                const masterDuration = yield this.event.$.duration;\n                const masterDurationUnit = yield this.event.$.durationUnit;\n                let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);\n                let completeMasterDurationMs = masterPercentDone * 0.01 * masterDurationMs;\n                for (const segment of segments) {\n                    const segmentStartOffset = segment.startOffset;\n                    const segmentEndOffset = segment.endOffset;\n                    const segmentDurationMs = segmentEndOffset - segmentStartOffset;\n                    if (segment === this) {\n                        if (completeMasterDurationMs >= segmentDurationMs)\n                            return 100;\n                        else if (completeMasterDurationMs > 0)\n                            return 100 * completeMasterDurationMs / segmentDurationMs;\n                        else\n                            return 0;\n                    }\n                    completeMasterDurationMs -= segmentDurationMs;\n                }\n            }\n            return result;\n        }\n        *calculateMinPercent() {\n            const previousSegment = this.previousSegment;\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            if (previousSegment) {\n                return yield previousSegment.$.endPercentDone;\n            }\n            return 0;\n        }\n        *calculateMaxPercent() {\n            if (!this.event) {\n                return yield ProposedOrPrevious;\n            }\n            const masterDuration = yield this.event.$.duration;\n            const masterDurationUnit = yield this.event.$.durationUnit;\n            let masterDurationMs = yield* this.getProject().$convertDuration(masterDuration, masterDurationUnit, TimeUnit.Millisecond);\n            const startOffset = yield this.$.startOffset;\n            const endOffset = yield this.$.endOffset;\n            const minPercent = yield this.$.startPercentDone;\n            return minPercent + 100 * (endOffset - startOffset) / masterDurationMs;\n        }\n        // @override\n        *calculateProjectedXDateWithDuration(baseDate, isForward, duration, durationUnit) {\n            if (!durationUnit)\n                durationUnit = yield this.$.durationUnit;\n            return yield* this.event.calculateProjectedXDateWithDuration(baseDate, isForward, duration, durationUnit, { ignoreSegments: true });\n        }\n        // @override\n        *calculateProjectedDuration(startDate, endDate, durationUnit) {\n            if (!durationUnit)\n                durationUnit = yield this.$.durationUnit;\n            return yield* this.event.calculateProjectedDuration(startDate, endDate, durationUnit, { ignoreSegments: true });\n        }\n        *calculateManuallyScheduled() {\n            if (this.event) {\n                return yield this.event.$.manuallyScheduled;\n            }\n            else {\n                return yield ProposedOrPrevious;\n            }\n        }\n    }\n    __decorate([\n        field({ identifierCls: SegmentSEDDispatcherIdentifier })\n    ], SchedulerProEventSegment.prototype, \"dispatcher\", void 0);\n    __decorate([\n        model_field({ persist: false })\n    ], SchedulerProEventSegment.prototype, \"startOffset\", void 0);\n    __decorate([\n        model_field({ persist: false })\n    ], SchedulerProEventSegment.prototype, \"endOffset\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProEventSegment.prototype, \"percentDone\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProEventSegment.prototype, \"startPercentDone\", void 0);\n    __decorate([\n        field()\n    ], SchedulerProEventSegment.prototype, \"endPercentDone\", void 0);\n    __decorate([\n        write('startDate')\n    ], SchedulerProEventSegment.prototype, \"writeStartDate\", null);\n    __decorate([\n        calculate('startOffset')\n    ], SchedulerProEventSegment.prototype, \"calculateStartOffset\", null);\n    __decorate([\n        calculate('endOffset')\n    ], SchedulerProEventSegment.prototype, \"calculateEndOffset\", null);\n    __decorate([\n        calculate('percentDone')\n    ], SchedulerProEventSegment.prototype, \"calculatePercentDone\", null);\n    __decorate([\n        calculate('startPercentDone')\n    ], SchedulerProEventSegment.prototype, \"calculateMinPercent\", null);\n    __decorate([\n        calculate('endPercentDone')\n    ], SchedulerProEventSegment.prototype, \"calculateMaxPercent\", null);\n    __decorate([\n        calculate('manuallyScheduled')\n    ], SchedulerProEventSegment.prototype, \"calculateManuallyScheduled\", null);\n    return SchedulerProEventSegment;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasProposedValue, PreviousValueOf, ProposedArgumentsOf, ProposedOrPrevious, ProposedOrPreviousValueOf, ProposedValueOf, WriteSeveral } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { CalculatedValueGen } from \"../../../../ChronoGraph/chrono/Identifier.js\";\nimport { TombStone } from \"../../../../ChronoGraph/chrono/Quark.js\";\nimport { Mixin } from '../../../../ChronoGraph/class/Mixin.js';\nimport { CycleDescription, CycleResolution, Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { calculate, field, write } from '../../../../ChronoGraph/replica/Entity.js';\nimport { FieldIdentifier } from \"../../../../ChronoGraph/replica/Identifier.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { Direction, TimeUnit } from '../../../scheduling/Types.js';\nimport { MAX_DATE } from \"../../../util/Constants.js\";\nimport { durationFormula, DurationVar, endDateFormula, EndDateVar, startDateFormula, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { HasPercentDoneMixin } from \"./HasPercentDoneMixin.js\";\nimport { SchedulerProEventSegment } from './SchedulerProEventSegment.js';\nimport { SchedulerProHasAssignmentsMixin } from \"./SchedulerProHasAssignmentsMixin.js\";\nexport const SegmentsVar = Symbol('SegmentsVar');\nexport const segmentsConverter = (value, data, record) => record.processSegmentsValue(value);\nexport const startDateByEndDateAndSegmentsFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([EndDateVar, SegmentsVar])\n});\nexport const endDateByStartDateAndSegmentsFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([StartDateVar, SegmentsVar])\n});\nexport const durationByStartDateAndEndDateAndSegmentsFormula = Formula.new({\n    output: DurationVar,\n    inputs: new Set([StartDateVar, EndDateVar, SegmentsVar])\n});\nexport const SEDSGGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar, SegmentsVar]),\n    formulas: new Set([\n        endDateByStartDateAndSegmentsFormula,\n        startDateByEndDateAndSegmentsFormula,\n        // durationByStartDateAndEndDateAndSegmentsFormula,\n        startDateFormula,\n        endDateFormula,\n        durationFormula\n    ])\n});\nexport const SEDSGForwardCycleResolution = CycleResolution.new({\n    description: SEDSGGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula, endDateByStartDateAndSegmentsFormula])\n});\nexport const SEDSGBackwardCycleResolution = CycleResolution.new({\n    description: SEDSGGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula, startDateByEndDateAndSegmentsFormula])\n});\nexport class SEDSGDispatcherIdentifier extends FieldIdentifier.mix(CalculatedValueGen) {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        return resolution1.get(StartDateVar) === resolution2.get(StartDateVar)\n            && resolution1.get(EndDateVar) === resolution2.get(EndDateVar)\n            && resolution1.get(DurationVar) === resolution2.get(DurationVar)\n            && resolution1.get(SegmentsVar) === resolution2.get(SegmentsVar);\n    }\n}\nexport function compareSegmentsArray(a, b) {\n    if (!a && !b)\n        return true;\n    if (this._skipSegmentsIsEqual)\n        return false;\n    if (!a && b || a && !b)\n        return false;\n    if (a.length !== b.length)\n        return false;\n    return a.every((segment, index) => compareSegments(segment, b[index]));\n}\nexport const compareSegments = (a, b) => {\n    if (a === b)\n        return true;\n    const segmentModel = a.isModel ? a : b;\n    const fieldMap = segmentModel.fieldMap;\n    const aStart = a.startDate instanceof Date ? a.startDate.getTime() : fieldMap.startDate.convert(a.startDate).getTime();\n    const bStart = b.startDate instanceof Date ? b.startDate.getTime() : fieldMap.startDate.convert(b.startDate).getTime();\n    const aEnd = a.endDate instanceof Date ? a.endDate.getTime() : fieldMap.endDate.convert(a.endDate).getTime();\n    const bEnd = b.endDate instanceof Date ? b.endDate.getTime() : fieldMap.endDate.convert(b.endDate).getTime();\n    return aStart === bStart && aEnd === bEnd;\n};\nexport class SplitEventMixin extends Mixin([SchedulerProHasAssignmentsMixin, HasPercentDoneMixin], (base) => {\n    class SplitEventMixin extends base {\n        constructor() {\n            super(...arguments);\n            this._segmentGeneration = {};\n        }\n        static get $name() {\n            return 'SplitEventMixin';\n        }\n        construct() {\n            this.segmentModelClass = this.getDefaultSegmentModelClass();\n            super.construct(...arguments);\n        }\n        get rawModifications() {\n            let data = super.rawModifications;\n            // include segment changes\n            if (this.segments && (!data || !('segments' in data))) {\n                for (const segment of this.segments) {\n                    if (segment.rawModifications) {\n                        data = data || {};\n                        data.segments = this.getFieldPersistentValue('segments');\n                        break;\n                    }\n                }\n            }\n            return data;\n        }\n        clearChanges(includeDescendants, removeFromStoreChanges, changes) {\n            for (const segment of this.segments || []) {\n                segment.clearChanges(includeDescendants, removeFromStoreChanges, null);\n            }\n            super.clearChanges(includeDescendants, removeFromStoreChanges, changes);\n        }\n        getDefaultSegmentModelClass() {\n            return SchedulerProEventSegment;\n        }\n        *prepareDispatcher(YIELD) {\n            const dispatcher = yield* super.prepareDispatcher(YIELD);\n            if (yield* this.hasSegmentChangesProposed()) {\n                dispatcher.addProposedValueFlag(SegmentsVar);\n            }\n            return dispatcher;\n        }\n        cycleResolutionContext(Y) {\n            const direction = Y(this.$.direction);\n            return direction === Direction.Forward || direction === Direction.None ? SEDSGForwardCycleResolution : SEDSGBackwardCycleResolution;\n        }\n        *hasSegmentChangesProposed() {\n            const proposedSegments = yield ProposedValueOf(this.$.segments);\n            let result = false;\n            if (yield HasProposedValue(this.$.segments)) {\n                result = Boolean(proposedSegments);\n            }\n            const segments = yield ProposedOrPreviousValueOf(this.$.segments);\n            if (!segments)\n                return false;\n            for (const segment of segments) {\n                const startDateProposed = yield HasProposedValue(segment.$.startDate);\n                const endDateProposed = yield HasProposedValue(segment.$.endDate);\n                const durationProposed = yield HasProposedValue(segment.$.duration);\n                if (startDateProposed || endDateProposed || durationProposed)\n                    result = true;\n            }\n            return result;\n        }\n        writeSegments(me, transaction, quark, value) {\n            // if (!transaction.baseRevision.hasIdentifier(me) && value == null) return\n            const oldSegmentsQuarkValue = transaction.getLatestEntryFor(me)?.getValue();\n            const oldSegments = oldSegmentsQuarkValue !== TombStone ? oldSegmentsQuarkValue ?? [] : [];\n            const oldSegmentsSet = new Set(oldSegments);\n            const newSegments = value ?? [];\n            const newSegmentsSet = new Set(newSegments);\n            this.project.ion({\n                // remove them from the graph, only the ones not listed in the new segments array,\n                // and only after commit finalization, otherwise test fails\n                // we don't know why, possibly because in the `calculateSegments` we use `previousValue` of `segments` atom\n                commitFinalized: () => graph.removeEntities(oldSegments.filter(segment => !newSegmentsSet.has(segment))),\n                once: true\n            });\n            me.constructor.prototype.write.call(this, me, transaction, quark, value);\n            this.$.isSegmented.write.call(this, this.$.isSegmented, transaction, null, Boolean(value?.length));\n            const project = this.project;\n            const graph = project.replica;\n            for (const newSegment of newSegments) {\n                if (!oldSegmentsSet.has(newSegment) && newSegment.graph !== graph) {\n                    newSegment.setProject(project);\n                    graph.addEntity(newSegment);\n                }\n            }\n        }\n        *doWriteSegments(segments, writes) {\n            writes = writes || [];\n            // if one or zero segments left after above merging\n            if (segments.length <= 1) {\n                // calculate the segment duration\n                const duration = segments.length\n                    ? yield* this.getProject().$convertDuration(segments[0].endOffset - segments[0].startOffset, TimeUnit.Millisecond, yield this.$.durationUnit)\n                    : 0;\n                // Apply the event \"duration\" taken from the segment and \"segments\" field as NULL\n                // (w/o pushing the duration value the code will tend to recalculate end date instead\n                // using exiting duration value on the event)\n                writes.push({\n                    identifier: this.$.duration,\n                    proposedArgs: [duration, null]\n                });\n                segments = null;\n            }\n            writes.push({\n                identifier: this.$.segments,\n                proposedArgs: [segments]\n            });\n            yield WriteSeveral(writes);\n        }\n        *calculateSegments() {\n            const dispatcher = yield this.$.dispatcher;\n            const { graph, project } = this;\n            const previousValue = yield PreviousValueOf(this.$.segments);\n            let segments = yield ProposedOrPrevious;\n            const toRemove = [];\n            let hasChanges = false;\n            if (segments) {\n                const result = new Set();\n                let previousSegment = null;\n                let keepDuration = false;\n                const { baseRevision } = graph.$activeTransaction;\n                for (const segment of segments) {\n                    const startOffset = yield segment.$.startOffset;\n                    const endOffset = yield segment.$.endOffset;\n                    // detect segment moving ..but ignore data loading stage\n                    const startDateProposedArgs = baseRevision.hasIdentifier(segment.$.startDate)\n                        && (yield ProposedArgumentsOf(segment.$.startDate));\n                    const endDateProposedArgs = baseRevision.hasIdentifier(segment.$.endDate)\n                        && (yield ProposedArgumentsOf(segment.$.endDate));\n                    keepDuration = keepDuration || startDateProposedArgs?.[0] || endDateProposedArgs?.[0];\n                    // get rid of zero duration segment\n                    if (startOffset === endOffset) {\n                        toRemove.push(segment);\n                    }\n                    // if a segment overlaps the previous one\n                    else if (previousSegment && startOffset <= (previousSegment.endOffset)) {\n                        const prevEndOffset = previousSegment.endOffset;\n                        // remove the segment we'll make a new one representing the segments union\n                        toRemove.push(segment);\n                        // if previous one is in the graph (not a \"union\" we just made)\n                        if (previousSegment.graph) {\n                            // remove it\n                            toRemove.push(previousSegment);\n                            const previousSegmentStartOffset = previousSegment.startOffset;\n                            const previousSegmentEndOffset = keepDuration\n                                // if moving a segment then move its further neighbours\n                                ? endOffset + prevEndOffset - startOffset\n                                // otherwise just combine intersected segments by building a new [min start, max end] segment\n                                : Math.max(endOffset, prevEndOffset);\n                            // @ts-ignore\n                            const cls = previousSegment.cls;\n                            // make a new segment\n                            previousSegment = this.segmentModelClass.new({\n                                event: this,\n                                cls: cls,\n                                startOffset: previousSegmentStartOffset,\n                                endOffset: previousSegmentEndOffset\n                            });\n                        }\n                        else {\n                            previousSegment.endOffset = keepDuration\n                                // if moving a segment then move its further neighbours\n                                ? endOffset + previousSegment.endOffset - startOffset\n                                // otherwise just combine intersected segments by building a new [min start, max end] segment\n                                : Math.max(endOffset, previousSegment.endOffset);\n                        }\n                    }\n                    // a valid segment\n                    else {\n                        if (previousSegment) {\n                            result.add(previousSegment);\n                        }\n                        previousSegment = segment;\n                    }\n                }\n                if (previousSegment) {\n                    result.add(previousSegment);\n                }\n                if (result.size === 1) {\n                    toRemove.push(...result);\n                }\n                hasChanges = toRemove.length > 0;\n                if (hasChanges) {\n                    segments = Array.from(result);\n                }\n                // fill previousSegment/nextSegment properties\n                segments.reduce((previousSegment, segment, index) => {\n                    if (previousSegment) {\n                        previousSegment.nextSegment = segment;\n                    }\n                    segment.previousSegment = previousSegment;\n                    segment.segmentIndex = index;\n                    return segment;\n                }, null);\n                if (segments.length) {\n                    segments[segments.length - 1].nextSegment = null;\n                }\n            }\n            // If we used to have segments - need to remove them from the graph\n            else if (previousValue) {\n                toRemove.push(...previousValue);\n            }\n            // if we got segments to cleanup\n            if (toRemove.length) {\n                // detach segments that are meant to get removed from the graph\n                toRemove.forEach(segment => segment.event = null);\n                project.ion({\n                    commitFinalized: () => graph.removeEntities(toRemove),\n                    once: true\n                });\n            }\n            // If we have changed segments\n            if (hasChanges) {\n                yield* this.doWriteSegments(segments);\n            }\n            segments = segments?.length > 1 ? segments : null;\n            return segments;\n        }\n        *calculateAdjustedSegments() {\n            const dispatcher = yield this.$.dispatcher;\n            let segments = yield this.$.segments;\n            const startDate = yield this.$.startDate;\n            const endDate = yield this.$.endDate;\n            const duration = yield this.$.duration;\n            let value = yield ProposedOrPrevious;\n            if (segments) {\n                const project = this.project;\n                const graph = this.graph;\n                const toRemove = [];\n                const toWrite = [];\n                let spliceIndex = -1;\n                // Iterate segments starting from trailing ones\n                for (let i = segments.length - 1; i >= 0; i--) {\n                    const segment = segments[i];\n                    const segmentStartDate = yield segment.$.startDate;\n                    const segmentEndDate = yield segment.$.endDate;\n                    // If the segment starts after the event finishes - cut the segment\n                    if (segmentStartDate > endDate) {\n                        toRemove.push(segment);\n                        spliceIndex = i;\n                    }\n                    else {\n                        // If last segment end is not aligned with the event end - adjust it\n                        if (segmentEndDate.getTime() !== endDate.getTime()) {\n                            const durationMs = segment.endOffset + (endDate.getTime() - segmentEndDate.getTime()) - segment.startOffset;\n                            const duration = yield* project.$convertDuration(durationMs, TimeUnit.Millisecond, yield segment.$.durationUnit);\n                            // write new duration, endDate and endOffset to the segment\n                            toWrite.push({\n                                identifier: segment.$.duration,\n                                proposedArgs: [duration, null]\n                            }, {\n                                identifier: segment.$.endDate,\n                                proposedArgs: [endDate, false]\n                            }, {\n                                identifier: segment.$.endOffset,\n                                proposedArgs: [segment.endOffset + (endDate.getTime() - segmentEndDate.getTime())]\n                            });\n                        }\n                        // stop iteration\n                        break;\n                    }\n                }\n                let hasChanges = false;\n                // if we have trailing segment(s) to cut\n                if (spliceIndex > -1) {\n                    hasChanges = true;\n                    segments.splice(spliceIndex);\n                    if (segments.length) {\n                        segments[segments.length - 1].nextSegment = null;\n                    }\n                    // Will remove the segment(s) from the graph later ..to avoid exceptions\n                    project.ion({\n                        commitFinalized: () => graph.removeEntities(toRemove),\n                        once: true\n                    });\n                }\n                let segmentsSnapshot = '';\n                if (segments) {\n                    segmentsSnapshot = this.getSegmentsSnapshot(segments);\n                }\n                if ( /*this._lastSegmentsSnapshot &&*/segmentsSnapshot !== this._lastSegmentsSnapshot) {\n                    hasChanges = true;\n                    segments = segments ? segments.slice() : segments;\n                    this._lastSegmentsSnapshot = segmentsSnapshot;\n                }\n                // this._lastSegmentsSnapshot  = segmentsSnapshot\n                // If we have changes to write\n                if (hasChanges) {\n                    yield* this.doWriteSegments(segments, toWrite);\n                }\n            }\n            return value;\n        }\n        getSegmentsSnapshot(segments) {\n            segments = segments || this.segments;\n            return segments?.map(segment => '' + segment.startOffset + '-' + segment.startDate?.getTime() + '-' + segment.endOffset + '-' + segment.endDate?.getTime()).join(';');\n        }\n        processSegmentsValue(value) {\n            // by default return the value as is\n            let result = value;\n            // if segments are specified for the task\n            if (value) {\n                // for (let segment of value) {\n                for (let i = 0; i < value.length; i++) {\n                    const segment = value[i];\n                    const record = (segment.isModel ? segment : this.segmentModelClass.new(segment));\n                    // don't overwrite the existing property, because this method\n                    // is called as part of the `copy()` call, where\n                    //     copy['segments'] = this['segments']\n                    // happens and `copy` event is assigned back to segments from the source\n                    if (!record.event)\n                        record.event = this;\n                    value[i] = record;\n                }\n            }\n            return result;\n        }\n        *calculateStartDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(StartDateVar);\n            let result;\n            if (resolution === startDateByEndDateAndSegmentsFormula.formulaId) {\n                result = yield* this.calculateStartDateBySegments();\n            }\n            else {\n                result = yield* super.calculateStartDate();\n            }\n            return result;\n        }\n        *calculateStartDateBySegments() {\n            const dispatcher = yield this.$.dispatcher;\n            const segments = yield this.$.segments;\n            const endDate = yield this.$.endDate;\n            let result;\n            if (segments) {\n                const lastSegment = segments[segments.length - 1];\n                const lastSegmentEndOffset = yield lastSegment.$.endOffset;\n                const rawDate = yield* this.calculateProjectedXDateWithDuration(endDate, false, lastSegmentEndOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n                const manuallyScheduled = yield this.$.manuallyScheduled;\n                result = manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                    ? rawDate\n                    : yield* this.skipNonWorkingTime(rawDate, true);\n            }\n            return result;\n        }\n        *calculateEndDateBySegments() {\n            const dispatcher = yield this.$.dispatcher;\n            const segments = yield this.$.segments;\n            const startDate = yield this.$.startDate;\n            let result;\n            if (segments) {\n                const lastSegment = segments[segments.length - 1];\n                const lastSegmentEndOffset = yield lastSegment.$.endOffset;\n                const rawDate = yield* this.calculateProjectedXDateWithDuration(startDate, true, lastSegmentEndOffset, TimeUnit.Millisecond, { ignoreSegments: true });\n                const manuallyScheduled = yield this.$.manuallyScheduled;\n                result = manuallyScheduled && !this.getProject().skipNonWorkingTimeWhenSchedulingManually\n                    ? rawDate\n                    : yield* this.skipNonWorkingTime(rawDate, false);\n            }\n            return result;\n        }\n        *calculateEndDate() {\n            const dispatcher = yield this.$.dispatcher;\n            const resolution = dispatcher.resolution.get(EndDateVar);\n            let result;\n            if (resolution === endDateByStartDateAndSegmentsFormula.formulaId) {\n                result = yield* this.calculateEndDateBySegments();\n            }\n            else {\n                result = yield* super.calculateEndDate();\n            }\n            return result;\n        }\n        *calculateDurationProposed() {\n            let result;\n            if (yield* this.hasSegmentChangesProposed()) {\n                result = yield* this.calculateDurationBySegments();\n            }\n            else {\n                result = yield* super.calculateDurationProposed();\n            }\n            return result;\n        }\n        *skipNonWorkingTime(date, isForward = true, iteratorOptions) {\n            if (!date)\n                return null;\n            iteratorOptions = Object.assign({ ignoreSegments: true }, iteratorOptions);\n            return yield* super.skipNonWorkingTime(date, isForward, iteratorOptions);\n        }\n        *calculateDurationBySegments() {\n            let duration;\n            const dispatcher = yield this.$.dispatcher;\n            const durationUnit = yield this.$.durationUnit;\n            const segments = yield this.$.segments;\n            if (segments) {\n                let durationMs = 0;\n                // collect segments duration in milliseconds\n                for (const segment of segments) {\n                    durationMs += segment.endOffset - segment.startOffset;\n                }\n                duration = yield* this.getProject().$convertDuration(durationMs, TimeUnit.Millisecond, durationUnit);\n            }\n            return duration;\n        }\n        *forEachAvailabilityInterval(options, func) {\n            const calendar = yield this.$.effectiveCalendar;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;\n            const isForward = options.isForward !== false;\n            const ignoreResourceCalendar = (yield this.$.ignoreResourceCalendar) || options.ignoreResourceCalendar || !assignmentsByCalendar.size;\n            const maxRange = this.getProject().maxCalendarRange;\n            let ignoreSegments = options.ignoreSegments;\n            let sign = 1;\n            let currentSegment, currentOffsetMs, currentSegmentDurationMs, segments, currentSegmentEndOffset;\n            if (!ignoreSegments) {\n                segments = yield this.$.segments;\n                ignoreSegments = ignoreSegments || !segments;\n                if (!ignoreSegments) {\n                    // clone segment array since we're going to call shift()/pop() on it\n                    segments = segments.slice();\n                    if (isForward) {\n                        currentSegment = segments.shift();\n                        currentOffsetMs = 0;\n                        sign = 1;\n                        // open the last segment end border\n                        currentSegmentEndOffset = currentSegment.nextSegment ? currentSegment.endOffset : MAX_DATE.getTime();\n                    }\n                    else {\n                        currentSegment = segments.pop();\n                        currentOffsetMs = currentSegment.endOffset;\n                        sign = -1;\n                        currentSegmentEndOffset = currentSegment.endOffset;\n                    }\n                    currentSegmentDurationMs = currentSegmentEndOffset - currentSegment.startOffset;\n                }\n            }\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            const project = this.getProject();\n            return effectiveCalendarsCombination.forEachAvailabilityInterval(Object.assign({ maxRange }, options), (intervalStartDate, intervalEndDate, calendarCacheIntervalMultiple) => {\n                const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                if (calendarsStatus.get(calendar)\n                    && (ignoreResourceCalendar\n                        || workCalendars.some((calendar) => assignmentsByCalendar.has(calendar))\n                        || (manuallyScheduled && !project.skipNonWorkingTimeInDurationWhenSchedulingManually))) {\n                    if (ignoreSegments) {\n                        return func(intervalStartDate, intervalEndDate, calendarCacheIntervalMultiple);\n                    }\n                    // take segments into account while iterating\n                    else {\n                        const startDateN = intervalStartDate.getTime();\n                        let intervalDuration = intervalEndDate.getTime() - intervalStartDate.getTime();\n                        if (this.getProject().adjustDurationToDST) {\n                            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                            intervalDuration += dstDiff * 60 * 1000;\n                        }\n                        let intervalStartOffset, intervalEndOffset;\n                        if (isForward) {\n                            intervalStartOffset = currentOffsetMs;\n                            intervalEndOffset = currentOffsetMs + intervalDuration;\n                        }\n                        else {\n                            intervalStartOffset = currentOffsetMs - intervalDuration;\n                            intervalEndOffset = currentOffsetMs;\n                        }\n                        while (currentSegment && intervalStartOffset <= currentSegmentEndOffset && intervalEndOffset > currentSegment.startOffset) {\n                            // get the intersection of the current segment w/ the current interval\n                            const callStartOffset = Math.max(intervalStartOffset, currentSegment.startOffset);\n                            const callEndOffset = Math.min(intervalEndOffset, currentSegmentEndOffset);\n                            const callStartDate = new Date(startDateN + callStartOffset - intervalStartOffset);\n                            const callEndDate = new Date(startDateN + callEndOffset - intervalStartOffset);\n                            const callResult = func(callStartDate, callEndDate, calendarCacheIntervalMultiple);\n                            if (callResult === false)\n                                return false;\n                            // reduce the segment duration left by the intersection duration\n                            currentSegmentDurationMs -= callEndDate.getTime() - callStartDate.getTime();\n                            // if no segment duration left\n                            if (!currentSegmentDurationMs) {\n                                // get next segment\n                                currentSegment = isForward ? segments.shift() : segments.pop();\n                                if (currentSegment) {\n                                    // the last segment end border should not be taken into account (in forward mode)\n                                    currentSegmentEndOffset = !isForward || currentSegment.nextSegment ? currentSegment.endOffset : MAX_DATE.getTime();\n                                    // get its duration to distribute\n                                    currentSegmentDurationMs = currentSegmentEndOffset - currentSegment.startOffset;\n                                }\n                            }\n                            // if there is undistributed duration left of the current segment => iterate to the next interval\n                            else {\n                                break;\n                            }\n                        }\n                        currentOffsetMs += sign * intervalDuration;\n                    }\n                }\n            });\n        }\n        *useEventAvailabilityIterator() {\n            const isSegmented = yield this.$.isSegmented;\n            if (isSegmented)\n                return true;\n            const manuallyScheduled = yield this.$.manuallyScheduled;\n            // always use availability iterator, unless the event is manually scheduled\n            return !manuallyScheduled;\n        }\n        /**\n         * Returns a segment that is ongoing on the provided date.\n         * @param  date Date to find an ongoing segment on\n         * @param  [segments] List of segments to check. When not provided the event segments is used\n         * @return Ongoing segment\n         */\n        getSegmentByDate(date, segments) {\n            segments = segments || this.getSegments();\n            if (segments) {\n                const index = this.getSegmentIndexByDate(date, segments);\n                return segments[index];\n            }\n        }\n        getSegmentIndexByDate(date, segments) {\n            segments = segments || this.getSegments();\n            return segments ? segments.findIndex(segment => date >= segment.startDate && date < segment.endDate) : -1;\n        }\n        /**\n         * The event first segment or null if the event is not segmented.\n         */\n        get firstSegment() {\n            const segments = this.getSegments();\n            return segments ? segments[0] : null;\n        }\n        /**\n         * The event last segment or null if the event is not segmented.\n         */\n        get lastSegment() {\n            const segments = this.getSegments();\n            return segments ? segments[segments.length - 1] : null;\n        }\n        /**\n         * Returns a segment by its index.\n         * @param index The segment index (zero based value).\n         * @return The segment matching the provided index.\n         */\n        getSegment(index) {\n            const segments = this.getSegments();\n            return segments?.[index];\n        }\n        /**\n         * Splits the event.\n         * @param from The date to split this event at.\n         * @param [lag=1] Split duration.\n         * @param [lagUnit] Split duration unit.\n         */\n        async splitToSegments(from, lag = 1, lagUnit) {\n            const project = this.getProject();\n            await project.commitAsync();\n            const me = this;\n            // cannot split:\n            // - if no split date specified\n            // - a summary event\n            // @ts-ignore\n            if (!from || (me.isHasSubEventsMixin && me.childEvents?.size))\n                return;\n            const duration = me.duration;\n            const durationUnit = me.durationUnit;\n            const startDate = me.startDate;\n            const endDate = me.endDate;\n            lagUnit = lagUnit ? DateHelper.normalizeUnit(lagUnit) : durationUnit;\n            // - not scheduled event\n            // - provided date violates the event interval\n            // - a zero duration event\n            if (!startDate || !endDate || (startDate >= from) || (from >= endDate) || !duration)\n                return;\n            const isSegmented = me.isSegmented;\n            let segments = me.segments || [];\n            let segmentToSplit, segmentToSplitIndex;\n            if (isSegmented) {\n                segmentToSplitIndex = me.getSegmentIndexByDate(from, segments);\n                segmentToSplit = segments[segmentToSplitIndex];\n                if (!segmentToSplit)\n                    return;\n            }\n            const splitTarget = segmentToSplit || me;\n            const splitTargetStart = segmentToSplit ? splitTarget.startDate : startDate;\n            const splitTargetDuration = splitTarget.duration;\n            const splitTargetDurationUnit = splitTarget.durationUnit;\n            const prevSegmentDuration = me.run('calculateProjectedDuration', splitTargetStart, from, splitTargetDurationUnit, { ignoreSegments: true });\n            const nextSegmentDuration = splitTargetDuration - prevSegmentDuration;\n            const lagInMs = project.run('$convertDuration', lag, lagUnit, TimeUnit.Millisecond);\n            const nextSegmentStartOffset = lagInMs + me.run('calculateProjectedDuration', startDate, from, TimeUnit.Millisecond, { ignoreSegments: true });\n            // split existing segment\n            if (segmentToSplit) {\n                // adjust its duration\n                segmentToSplit.duration = prevSegmentDuration;\n                const newSegment = this.segmentModelClass.new({\n                    duration: nextSegmentDuration,\n                    durationUnit: splitTargetDurationUnit,\n                    startOffset: nextSegmentStartOffset\n                });\n                segments = segments.slice(0);\n                segments.splice(segmentToSplitIndex + 1, 0, newSegment);\n                me.segments = segments;\n                me.duration = duration;\n                // push next segments forward by the lag duration\n                for (let i = segmentToSplitIndex + 2, l = segments.length; i < l; i++) {\n                    const segment = segments[i];\n                    if (segment) {\n                        segment.startOffset += lagInMs;\n                        segment.endOffset += lagInMs;\n                    }\n                }\n            }\n            // split not segmented event\n            else {\n                const previousSegment = this.segmentModelClass.new({\n                    duration: prevSegmentDuration,\n                    durationUnit: splitTargetDurationUnit,\n                    startOffset: 0\n                });\n                const newSegment = this.segmentModelClass.new({\n                    duration: duration - prevSegmentDuration,\n                    durationUnit: splitTargetDurationUnit,\n                    startOffset: nextSegmentStartOffset\n                });\n                me.duration = duration;\n                me.segments = [previousSegment, newSegment];\n            }\n            return project.commitAsync();\n        }\n        /**\n         * Merges the event segments.\n         * The method merges two provided event segments (and all the segment between them if any).\n         * @param [segment1] First segment to merge.\n         * @param [segment2] Second segment to merge.\n         */\n        async mergeSegments(segment1, segment2) {\n            if (!this.isSegmented)\n                return;\n            segment1 = segment1 || this.firstSegment;\n            segment2 = segment2 || this.lastSegment;\n            if (segment1.startOffset > segment2.startOffset) {\n                let tmp = segment2;\n                segment2 = segment1;\n                segment1 = tmp;\n            }\n            // merging itself will be done automatically inside `calculateSegments`\n            segment1.endDate = segment2.startDate;\n            return this.getProject().commitAsync();\n        }\n        // Override storeFieldChange to support revertChanges for segments field\n        storeFieldChange(key, oldValue) {\n            // if we store segments old value\n            if (key === 'segments' && oldValue) {\n                const result = [];\n                for (const segment of oldValue) {\n                    // get the segment persistable data\n                    const segmentData = segment.toJSON();\n                    // if the segment was changes since the last time we stored segment oldValue\n                    if (!this._segmentGeneration[segment.internalId] || segment.generation > this._segmentGeneration[segment.internalId]) {\n                        // let's use the segment old values\n                        Object.assign(segmentData, segment.meta.modified);\n                    }\n                    result.push(segmentData);\n                    // keep the version of the segment\n                    this._segmentGeneration[segment.internalId] = segment.generation;\n                }\n                oldValue = result;\n            }\n            super.storeFieldChange(key, oldValue);\n        }\n        leaveProject() {\n            const segments = this.segments;\n            if (segments) {\n                this.graph.removeEntities(segments);\n            }\n            super.leaveProject();\n        }\n        endBatch(...args) {\n            this.fieldMap.segments._skipSegmentsIsEqual++;\n            super.endBatch(...args);\n            this.fieldMap.segments._skipSegmentsIsEqual--;\n        }\n        copy(newId = null, deep = null) {\n            const copy = super.copy(newId, deep);\n            // need to clean the `segments` in `data`, otherwise it will be\n            // picked up as \"old value\" by STM during set to `segments`\n            // @ts-ignore\n            copy.data.segments = undefined;\n            if (copy.segments) {\n                copy.segments = copy.segments.map(seg => Object.assign(seg.copy(), { event: copy }));\n            }\n            return copy;\n        }\n    }\n    __decorate([\n        field({ identifierCls: SEDSGDispatcherIdentifier })\n    ], SplitEventMixin.prototype, \"dispatcher\", void 0);\n    __decorate([\n        model_field({\n            type: 'array',\n            isEqual: compareSegmentsArray,\n            convert: segmentsConverter,\n            // @ts-ignore\n            _skipSegmentsIsEqual: 0\n        })\n    ], SplitEventMixin.prototype, \"segments\", void 0);\n    __decorate([\n        field()\n    ], SplitEventMixin.prototype, \"adjustedSegments\", void 0);\n    __decorate([\n        field()\n    ], SplitEventMixin.prototype, \"isSegmented\", void 0);\n    __decorate([\n        write('segments')\n    ], SplitEventMixin.prototype, \"writeSegments\", null);\n    __decorate([\n        calculate('segments')\n    ], SplitEventMixin.prototype, \"calculateSegments\", null);\n    __decorate([\n        calculate('adjustedSegments')\n    ], SplitEventMixin.prototype, \"calculateAdjustedSegments\", null);\n    return SplitEventMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, write } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { TimeUnit } from \"../../../scheduling/Types.js\";\nimport { HasChildrenMixin } from \"../scheduler_basic/HasChildrenMixin.js\";\nimport { SchedulerProHasAssignmentsMixin } from \"./SchedulerProHasAssignmentsMixin.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin provides an `effort` field which does not affect scheduling.\n * It also provides various generic methods to schedule task based on effort information. Those are\n * used in other mixins.\n */\nexport class HasEffortMixin extends Mixin([SchedulerProHasAssignmentsMixin, HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class HasEffortMixin extends base {\n        /**\n         * Getter for the effort. Can return effort in given unit, or will use [[effortUnit]].\n         *\n         * @param unit\n         */\n        getEffort(unit) {\n            const effort = this.effort;\n            return unit ? this.getProject().convertDuration(effort, this.effortUnit, unit) : effort;\n        }\n        writeEffort(me, transaction, quark, effort, unit) {\n            if (effort < 0)\n                effort = 0;\n            if (!transaction.baseRevision.hasIdentifier(me) && effort == null)\n                return;\n            if (unit != null && unit !== this.effortUnit) {\n                this.$.effortUnit.write.call(this, this.$.effortUnit, transaction, null, unit);\n            }\n            me.constructor.prototype.write(me, transaction, quark, effort);\n        }\n        setEffortUnit(_value) {\n            throw new Error(\"Use `setEffort` instead\");\n        }\n        /**\n         * The method defines wether the provided child event should roll up its [[effort]] to this summary event or not.\n         * If the method returns `true` the child event [[effort]] is summed up\n         * when calculating this summary event [[effort]].\n         * And if the method returns `false` the child effort is not taken into account.\n         * By default the method returns `true` to include all child event [[effort]] values.\n         * @param childEvent Child event to consider.\n         * @returns `true` if the provided event [[effort]] should be included, `false` if not.\n         */\n        *shouldRollupChildEffort(childEvent) {\n            return true;\n        }\n        /**\n         * Helper method to calculate the total effort of all child events.\n         */\n        *calculateTotalChildrenEffort() {\n            const childEvents = yield this.$.childEvents;\n            const project = this.getProject();\n            let totalEffortMs = 0;\n            for (const childEvent of childEvents) {\n                if (!(yield* this.shouldRollupChildEffort(childEvent)))\n                    continue;\n                const childEventEffortUnit = yield childEvent.$.effortUnit;\n                totalEffortMs += yield* project.$convertDuration(yield childEvent.$.effort, childEventEffortUnit, TimeUnit.Millisecond);\n            }\n            return yield* project.$convertDuration(totalEffortMs, TimeUnit.Millisecond, yield this.$.effortUnit);\n        }\n        *calculateEffort() {\n            const childEvents = yield this.$.childEvents;\n            if (childEvents.size > 0)\n                return yield* this.calculateTotalChildrenEffort();\n            else {\n                const proposed = yield ProposedOrPrevious;\n                return proposed !== undefined ? proposed : yield* this.calculateEffortPure();\n            }\n        }\n        *calculateEffortPure() {\n            const childEvents = yield this.$.childEvents;\n            if (childEvents.size > 0)\n                return yield* this.calculateTotalChildrenEffort();\n            else {\n                return yield* this.calculateProjectedEffort(yield this.$.startDate, yield this.$.endDate);\n            }\n        }\n        *calculateEffortProposed() {\n            return yield ProposedOrPrevious;\n        }\n        *calculateAssignmentUnits(assignment) {\n            return yield* this.calculateAssignmentUnitsProposed(assignment);\n        }\n        *calculateAssignmentUnitsPure(assignment) {\n            return yield* this.calculateUnitsByStartEndAndEffort(assignment);\n        }\n        *calculateAssignmentUnitsProposed(assignment) {\n            return yield ProposedOrPrevious;\n        }\n        *getBaseOptionsForEffortCalculations() {\n            return { ignoreResourceCalendar: false };\n        }\n        *calculateProjectedEffort(startDate, endDate, assignmentsByCalendar) {\n            if (startDate == null || endDate == null || startDate > endDate)\n                return null;\n            if (!assignmentsByCalendar) {\n                assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            }\n            const totalUnitsByCalendar = new Map();\n            for (const [calendar, assignments] of assignmentsByCalendar) {\n                let intervalUnits = 0;\n                for (const assignment of assignments) {\n                    intervalUnits += (yield assignment.$.units);\n                }\n                totalUnitsByCalendar.set(calendar, intervalUnits);\n            }\n            //----------------------\n            let resultN = 0;\n            const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), { startDate, endDate });\n            // if event has no assignments we treat that as it has a special, \"virtual\" assignment with 100 units and\n            // the calendar matching the calendar of the task\n            // we need to ignore resource calendars in this case, since there's no assigned resources\n            if (totalUnitsByCalendar.size === 0) {\n                totalUnitsByCalendar.set(yield this.$.effectiveCalendar, 100);\n                options.ignoreResourceCalendar = true;\n            }\n            yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                let intervalUnits = 0;\n                for (const workingCalendar of workCalendars) {\n                    // the calendar of the event itself will be in the `workCalendars`, but it\n                    // will be missing in the `totalUnitsByCalendar` map, which is fine\n                    intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;\n                }\n                // Effort = Units * Duration\n                resultN += intervalUnits * intervalDuration * 0.01;\n            });\n            return yield* this.getProject().$convertDuration(resultN, TimeUnit.Millisecond, yield this.$.effortUnit);\n        }\n        *calculateUnitsByStartEndAndEffort(_assignment) {\n            const effort = yield this.$.effort, effortUnit = yield this.$.effortUnit, effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);\n            let collectedEffort = 0;\n            const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), { startDate: yield this.$.startDate, endDate: yield this.$.endDate });\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                for (const workingCalendar of workCalendars) {\n                    collectedEffort +=\n                        (assignmentsByCalendar.has(workingCalendar) ? assignmentsByCalendar.get(workingCalendar).length : 0) * intervalDuration;\n                }\n            });\n            return collectedEffort ? 100 * effortMS / collectedEffort : 100;\n        }\n        *calculateProjectedXDateByEffort(baseDate, isForward = true, effort, effortUnit) {\n            effort = effort !== undefined ? effort : yield this.$.effort;\n            effortUnit = effortUnit !== undefined ? effortUnit : yield this.$.effortUnit;\n            const effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);\n            if (baseDate == null || effort == null)\n                return null;\n            let resultN = baseDate.getTime();\n            let leftEffort = effortMS;\n            // early exit if effort is 0\n            if (leftEffort === 0)\n                return new Date(resultN);\n            const calendar = yield this.$.effectiveCalendar;\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            const totalUnitsByCalendar = new Map();\n            // this flag indicates that there are assignments with non-zero units\n            // if there's no such - event should be scheduled by the simple\n            // `accumulateWorkingTime` call\n            let hasUnits = false;\n            for (const [calendar, assignments] of assignmentsByCalendar) {\n                let intervalUnits = 0;\n                for (const assignment of assignments) {\n                    intervalUnits += yield assignment.$.units;\n                }\n                totalUnitsByCalendar.set(calendar, intervalUnits);\n                if (intervalUnits > 0)\n                    hasUnits = true;\n            }\n            if (hasUnits && (yield* this.useEventAvailabilityIterator())) {\n                const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? { startDate: baseDate, isForward } : { endDate: baseDate, isForward });\n                yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {\n                    const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();\n                    const intervalStartN = intervalStart.getTime(), intervalEndN = intervalEnd.getTime(), intervalDuration = intervalEndN - intervalStartN;\n                    let intervalUnits = 0;\n                    for (const workingCalendar of workCalendars) {\n                        // the calendar of the event itself will be in the `workCalendars`, but it\n                        // will be missing in the `totalUnitsByCalendar` map, which is fine\n                        intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;\n                    }\n                    // Effort = Units * Duration\n                    const intervalEffort = intervalUnits * intervalDuration * 0.01;\n                    if (intervalEffort >= leftEffort) {\n                        // the case where `leftEffort` is 0 initially is covered with the early exit above\n                        // so `leftEffort` is always > 0 here, this means `intervalEffort` has to be > 0 too,\n                        // this in turn means, that to enter the branch `intervalUnits` has to be !== 0,\n                        // so division by it is safe, see below\n                        // resulting date is interval start plus left duration (Duration = Effort / Units)\n                        resultN = isForward\n                            ? intervalStartN + leftEffort / (0.01 * intervalUnits)\n                            : intervalEndN - leftEffort / (0.01 * intervalUnits);\n                        // exit the loop\n                        return false;\n                    }\n                    else {\n                        leftEffort -= intervalEffort;\n                    }\n                });\n                return new Date(resultN);\n            }\n            else {\n                return calendar.accumulateWorkingTime(baseDate, effortMS, isForward).finalDate;\n            }\n        }\n    }\n    __decorate([\n        model_field({ 'type': 'number' /*, defaultValue : 0*/ })\n    ], HasEffortMixin.prototype, \"effort\", void 0);\n    __decorate([\n        model_field({ 'type': 'string', defaultValue: TimeUnit.Hour }, { converter: (unit) => DateHelper.normalizeUnit(unit) || TimeUnit.Hour })\n    ], HasEffortMixin.prototype, \"effortUnit\", void 0);\n    __decorate([\n        write('effort')\n    ], HasEffortMixin.prototype, \"writeEffort\", null);\n    __decorate([\n        calculate('effort')\n    ], HasEffortMixin.prototype, \"calculateEffort\", null);\n    return HasEffortMixin;\n}) {\n}\n", "import { Formula } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { EndDateVar, SEDDispatcher, SEDDispatcherIdentifier, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { TombStone } from \"../../../../ChronoGraph/chrono/Quark.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const EffortVar = Symbol('EffortVar');\nexport const UnitsVar = Symbol('UnitsVar');\n//---------------------------------------------------------------------------------------------------------------------\nexport const effortFormula = Formula.new({\n    output: EffortVar,\n    inputs: new Set([StartDateVar, EndDateVar, UnitsVar])\n});\nexport const unitsFormula = Formula.new({\n    output: UnitsVar,\n    inputs: new Set([StartDateVar, EndDateVar, EffortVar])\n});\nexport const endDateByEffortFormula = Formula.new({\n    output: EndDateVar,\n    inputs: new Set([StartDateVar, EffortVar, UnitsVar])\n});\nexport const startDateByEffortFormula = Formula.new({\n    output: StartDateVar,\n    inputs: new Set([EndDateVar, EffortVar, UnitsVar])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDWUDispatcher extends SEDDispatcher {\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport class SEDWUDispatcherIdentifier extends SEDDispatcherIdentifier {\n    equality(v1, v2) {\n        const resolution1 = v1.resolution;\n        const resolution2 = v2.resolution;\n        // @ts-ignore\n        return (v1 !== TombStone || v2 === TombStone)\n            // @ts-ignore\n            && (v1 === TombStone || v2 !== TombStone)\n            && resolution1.get(EffortVar) === resolution2.get(EffortVar)\n            && resolution1.get(UnitsVar) === resolution2.get(UnitsVar)\n            && super.equality(v1, v2);\n    }\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious, ProposedOrPreviousValueOf } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalculateProposed } from \"../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { calculate, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { SchedulingMode } from \"../../../scheduling/Types.js\";\nimport { durationFormula, DurationVar, EndDateVar, StartDateVar } from \"../scheduler_basic/BaseEventDispatcher.js\";\nimport { effortFormula, EffortVar, endDateByEffortFormula, SEDWUDispatcher, SEDWUDispatcherIdentifier, startDateByEffortFormula, unitsFormula, UnitsVar } from \"./HasEffortDispatcher.js\";\nimport { HasEffortMixin } from \"./HasEffortMixin.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin serves as a \"base class\" for the individual scheduling modes mixins: [[FixedDurationMixin]], [[FixedEffortMixin]]\n * and [[FixedUnitsMixin]].\n *\n * Scheduling mode indicates, in which order the duration, effort and assignment units are changed. All these variables\n * are tied together with this invariant (in pseudo-code):\n *\n * ```javascript\n * Effort = Duration * Units\n * ```\n *\n * For example, if we've doubled the effort of the task, we have the choice - we can either double its duration,\n * or double the assignment units, to keep the invariant.\n *\n * We have the same choices for every variable. The scheduling mode\n * basically defines the order in which the \"duration\", \"effort\" and \"units\" variables are updated when one of them changes.\n */\nexport class HasSchedulingModeMixin extends Mixin([HasEffortMixin], (base) => {\n    const superProto = base.prototype;\n    class HasSchedulingModeMixin extends base {\n        *calculateSchedulingMode() {\n            return (yield ProposedOrPrevious) || SchedulingMode.Normal;\n        }\n        *effectiveSchedulingMode() {\n            const assignmentsByCalendar = yield this.$.assignmentsByCalendar;\n            return assignmentsByCalendar.size > 0 ? yield this.$.schedulingMode : SchedulingMode.Normal;\n        }\n        effectiveSchedulingModeSync(Y) {\n            const assignmentsByCalendar = Y(this.$.assignmentsByCalendar);\n            return assignmentsByCalendar.size > 0 ? Y(this.$.schedulingMode) : SchedulingMode.Normal;\n        }\n        *prepareDispatcher(YIELD) {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);\n                cycleDispatcher.collectInfo(YIELD, this.$.effort, EffortVar);\n                if (yield* this.hasProposedValueForUnits())\n                    cycleDispatcher.addProposedValueFlag(UnitsVar);\n                // units are always available\n                cycleDispatcher.addPreviousValueFlag(UnitsVar);\n                return cycleDispatcher;\n            }\n            else {\n                return yield* superProto.prepareDispatcher.call(this, YIELD);\n            }\n        }\n        dispatcherClass(Y) {\n            const schedulingMode = this.effectiveSchedulingModeSync(Y);\n            if (schedulingMode !== SchedulingMode.Normal) {\n                return SEDWUDispatcher;\n            }\n            else {\n                return superProto.dispatcherClass.call(this, Y);\n            }\n        }\n        buildProposedDispatcher(me, quark, transaction) {\n            const dispatcher = superProto.buildProposedDispatcher.call(this, me, quark, transaction);\n            dispatcher.addPreviousValueFlag(EffortVar);\n            dispatcher.addPreviousValueFlag(UnitsVar);\n            return dispatcher;\n        }\n        *calculateAssignmentUnits(assignment) {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(UnitsVar);\n                if (formulaId === CalculateProposed) {\n                    return yield* this.calculateAssignmentUnitsProposed(assignment);\n                }\n                else if (formulaId === unitsFormula.formulaId) {\n                    return yield* this.calculateAssignmentUnitsPure(assignment);\n                }\n                else {\n                    throw new Error(\"Unknown formula for `units`\");\n                }\n            }\n            else {\n                return yield* superProto.calculateAssignmentUnits.call(this, assignment);\n            }\n        }\n        *calculateEffort() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(EffortVar);\n                if (formulaId === CalculateProposed) {\n                    return yield* this.calculateEffortProposed();\n                }\n                else if (formulaId === effortFormula.formulaId) {\n                    return yield* this.calculateEffortPure();\n                }\n                else {\n                    throw new Error(\"Unknown formula for `effort`\");\n                }\n            }\n            else {\n                return yield* superProto.calculateEffort.call(this);\n            }\n        }\n        *calculateStartDate() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(StartDateVar);\n                if (formulaId === startDateByEffortFormula.formulaId) {\n                    return yield* this.calculateProjectedXDateByEffort(yield this.$.endDate, false);\n                }\n                else {\n                    return yield* superProto.calculateStartDate.call(this);\n                }\n            }\n            else {\n                return yield* superProto.calculateStartDate.call(this);\n            }\n        }\n        *calculateEndDate() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode !== SchedulingMode.Normal) {\n                const dispatch = yield this.$.dispatcher;\n                const formulaId = dispatch.resolution.get(EndDateVar);\n                if (formulaId === endDateByEffortFormula.formulaId) {\n                    return yield* this.calculateProjectedXDateByEffort(yield this.$.startDate, true);\n                }\n                else {\n                    return yield* superProto.calculateEndDate.call(this);\n                }\n            }\n            else {\n                return yield* superProto.calculateEndDate.call(this);\n            }\n        }\n        *calculateEffectiveDuration() {\n            const dispatch = yield this.$.dispatcher;\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            const durationResolution = dispatch.resolution.get(DurationVar);\n            const effortResolution = dispatch.resolution.get(EffortVar);\n            let effectiveDurationToUse;\n            if (durationResolution === durationFormula.formulaId && schedulingMode != SchedulingMode.Normal) {\n                const proposedOrPreviousStartDate = yield ProposedOrPreviousValueOf(this.$.startDate);\n                const proposedOrPreviousEndDate = yield ProposedOrPreviousValueOf(this.$.endDate);\n                const startDateResolution = dispatch.resolution.get(StartDateVar);\n                const endDateResolution = dispatch.resolution.get(EndDateVar);\n                const effortDriven = yield this.$.effortDriven;\n                if (proposedOrPreviousEndDate && startDateResolution === startDateByEffortFormula.formulaId) {\n                    effectiveDurationToUse = yield* this.calculateProjectedDuration(yield* this.calculateProjectedXDateByEffort(proposedOrPreviousEndDate, false), proposedOrPreviousEndDate);\n                }\n                else if (proposedOrPreviousStartDate && endDateResolution === endDateByEffortFormula.formulaId) {\n                    effectiveDurationToUse = yield* this.calculateProjectedDuration(proposedOrPreviousStartDate, yield* this.calculateProjectedXDateByEffort(proposedOrPreviousStartDate, true));\n                }\n                else if (proposedOrPreviousStartDate && proposedOrPreviousEndDate\n                    || !proposedOrPreviousStartDate && !proposedOrPreviousEndDate) {\n                    effectiveDurationToUse = yield* superProto.calculateEffectiveDuration.call(this);\n                }\n            }\n            else\n                effectiveDurationToUse = yield* superProto.calculateEffectiveDuration.call(this);\n            return effectiveDurationToUse;\n        }\n    }\n    __decorate([\n        model_field({ 'type': 'boolean', defaultValue: false })\n    ], HasSchedulingModeMixin.prototype, \"effortDriven\", void 0);\n    __decorate([\n        model_field({ type: 'string', defaultValue: SchedulingMode.Normal }, { sync: true })\n    ], HasSchedulingModeMixin.prototype, \"schedulingMode\", void 0);\n    __decorate([\n        field({ identifierCls: SEDWUDispatcherIdentifier })\n    ], HasSchedulingModeMixin.prototype, \"dispatcher\", void 0);\n    __decorate([\n        calculate('schedulingMode')\n    ], HasSchedulingModeMixin.prototype, \"calculateSchedulingMode\", null);\n    __decorate([\n        calculate('effort')\n    ], HasSchedulingModeMixin.prototype, \"calculateEffort\", null);\n    __decorate([\n        calculate('startDate')\n    ], HasSchedulingModeMixin.prototype, \"calculateStartDate\", null);\n    __decorate([\n        calculate('endDate')\n    ], HasSchedulingModeMixin.prototype, \"calculateEndDate\", null);\n    return HasSchedulingModeMixin;\n}) {\n}\n", "import { CycleResolution, CycleDescription } from \"../../../../../ChronoGraph/cycle_resolver/CycleResolver.js\";\nimport { durationFormula, DurationVar, endDateFormula, EndDateVar, startDateFormula, StartDateVar } from \"../../scheduler_basic/BaseEventDispatcher.js\";\nimport { effortFormula, EffortVar, unitsFormula, UnitsVar } from \"../HasEffortDispatcher.js\";\n//---------------------------------------------------------------------------------------------------------------------\nexport const fixedDurationSEDWUGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),\n    formulas: new Set([\n        startDateFormula,\n        endDateFormula,\n        durationFormula,\n        unitsFormula,\n        effortFormula,\n    ])\n});\nexport const fixedDurationAndEffortSEDWUGraphDescription = CycleDescription.new({\n    variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),\n    formulas: new Set([\n        startDateFormula,\n        endDateFormula,\n        durationFormula,\n        unitsFormula,\n    ])\n});\n//---------------------------------------------------------------------------------------------------------------------\nexport const fixedDurationSEDWUForwardNonEffortDriven = CycleResolution.new({\n    description: fixedDurationSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula, effortFormula])\n});\nexport const fixedDurationSEDWUForwardEffortDriven = CycleResolution.new({\n    description: fixedDurationAndEffortSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([endDateFormula, unitsFormula])\n});\nexport const fixedDurationSEDWUBackwardNonEffortDriven = CycleResolution.new({\n    description: fixedDurationSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula, effortFormula])\n});\nexport const fixedDurationSEDWUBackwardEffortDriven = CycleResolution.new({\n    description: fixedDurationAndEffortSEDWUGraphDescription,\n    defaultResolutionFormulas: new Set([startDateFormula, unitsFormula])\n});\n", "import { HasProposedValue } from \"../../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../../ChronoGraph/class/BetterMixin.js\";\nimport { Direction, SchedulingMode } from \"../../../../scheduling/Types.js\";\nimport { EffortVar, UnitsVar } from \"../HasEffortDispatcher.js\";\nimport { HasSchedulingModeMixin } from \"../HasSchedulingModeMixin.js\";\nimport { fixedDurationSEDWUBackwardEffortDriven, fixedDurationSEDWUBackwardNonEffortDriven, fixedDurationSEDWUForwardEffortDriven, fixedDurationSEDWUForwardNonEffortDriven } from \"./FixedDurationDispatcher.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This mixin provides the fixed duration scheduling mode facility. The scheduling mode is controlled with the\n * [[HasSchedulingModeMixin.schedulingMode]] field.\n *\n * See [[HasSchedulingModeMixin]] for more details.\n *\n * In this mode, the duration of the task remains \"fixed\" as the name suggest. It is changed only if there's no other options,\n * for example if both \"effort\" and \"units\" has changed. In other cases, some other variable is updated.\n *\n * If the [[HasSchedulingModeMixin.effortDriven]] flag is enabled, effort variable becomes \"fixed\" as well, so normally the \"units\"\n * variable will change. If that flag is disabled, then \"effort\" will be changed.\n */\nexport class FixedDurationMixin extends Mixin([HasSchedulingModeMixin], (base) => {\n    const superProto = base.prototype;\n    class FixedDurationMixin extends base {\n        *prepareDispatcher(YIELD) {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode === SchedulingMode.FixedDuration) {\n                const cycleDispatcher = yield* superProto.prepareDispatcher.call(this, YIELD);\n                const effortDriven = yield this.$.effortDriven;\n                if (effortDriven)\n                    cycleDispatcher.addKeepIfPossibleFlag(EffortVar);\n                if (yield HasProposedValue(this.$.assigned)) {\n                    // for effort driven case, we treat adding/removing of assignments as changing effort\n                    // instead of units (this will trigger both, but units formula will win in presence of effort change)\n                    if (effortDriven) {\n                        cycleDispatcher.addProposedValueFlag(EffortVar);\n                    }\n                    else {\n                        cycleDispatcher.addProposedValueFlag(UnitsVar);\n                    }\n                }\n                return cycleDispatcher;\n            }\n            else {\n                return yield* superProto.prepareDispatcher.call(this, YIELD);\n            }\n        }\n        cycleResolutionContext(Y) {\n            const schedulingMode = this.effectiveSchedulingModeSync(Y);\n            if (schedulingMode === SchedulingMode.FixedDuration) {\n                const direction = Y(this.$.direction);\n                const effortDriven = Y(this.$.effortDriven);\n                if (direction === Direction.Forward || direction === Direction.None) {\n                    return effortDriven ? fixedDurationSEDWUForwardEffortDriven : fixedDurationSEDWUForwardNonEffortDriven;\n                }\n                else {\n                    return effortDriven ? fixedDurationSEDWUBackwardEffortDriven : fixedDurationSEDWUBackwardNonEffortDriven;\n                }\n            }\n            else {\n                return superProto.cycleResolutionContext.call(this, Y);\n            }\n        }\n        *getBaseOptionsForDurationCalculations() {\n            const schedulingMode = yield* this.effectiveSchedulingMode();\n            if (schedulingMode === SchedulingMode.FixedDuration) {\n                return { ignoreResourceCalendar: true };\n            }\n            else {\n                return yield* superProto.getBaseOptionsForDurationCalculations.call(this);\n            }\n        }\n    }\n    return FixedDurationMixin;\n}) {\n}\n", "import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerBasicEvent } from \"../scheduler_basic/SchedulerBasicEvent.js\";\nimport { ConstrainedEarlyEventMixin } from \"./ConstrainedEarlyEventMixin.js\";\nimport { HasDateConstraintMixin } from \"./HasDateConstraintMixin.js\";\nimport { HasPercentDoneMixin } from \"./HasPercentDoneMixin.js\";\nimport { ScheduledByDependenciesEarlyEventMixin } from \"./ScheduledByDependenciesEarlyEventMixin.js\";\nimport { SchedulerProHasAssignmentsMixin } from \"./SchedulerProHasAssignmentsMixin.js\";\nimport { SplitEventMixin } from \"./SplitEventMixin.js\";\nimport { HasEffortMixin } from \"./HasEffortMixin.js\";\nimport { HasSchedulingModeMixin } from \"./HasSchedulingModeMixin.js\";\nimport { FixedDurationMixin } from \"./scheduling_modes/FixedDurationMixin.js\";\n// import { ConstrainedByParentMixin } from \"../gantt/ConstrainedByParentMixin.js\"\n/**\n * This is an event class, [[SchedulerProProjectMixin]] is working with.\n * It is constructed as [[SchedulerBasicEvent]], enhanced with extra functionality.\n */\nexport class SchedulerProEvent extends Mixin([\n    SchedulerBasicEvent,\n    HasDateConstraintMixin,\n    HasPercentDoneMixin,\n    SchedulerProHasAssignmentsMixin,\n    HasEffortMixin,\n    HasSchedulingModeMixin,\n    FixedDurationMixin,\n    ConstrainedEarlyEventMixin,\n    ScheduledByDependenciesEarlyEventMixin,\n    SplitEventMixin,\n], (base) => {\n    class SchedulerProEvent extends base {\n    }\n    return SchedulerProEvent;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Base, Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { calculate, Entity, field } from \"../../../../ChronoGraph/replica/Entity.js\";\nimport { CalendarIntervalMixin } from \"../../../calendar/CalendarIntervalMixin.js\";\nimport { CalendarIntervalStore } from \"../../../calendar/CalendarIntervalStore.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { BaseCalendarMixin } from \"../scheduler_basic/BaseCalendarMixin.js\";\nimport { BaseResourceMixin } from \"../scheduler_basic/BaseResourceMixin.js\";\nexport class ResourceAllocationEventRangeCalendarIntervalMixin extends CalendarIntervalMixin {\n    // @model_field({ type : 'boolean', defaultValue : true })\n    // isWorking : boolean\n    // Calendar classes not entering graph, thus not using @model_field\n    static get fields() {\n        return [\n            { name: 'isWorking', type: 'boolean', defaultValue: true }\n        ];\n    }\n}\nexport class ResourceAllocationEventRangeCalendarIntervalStore extends CalendarIntervalStore {\n    static get defaultConfig() {\n        return {\n            modelClass: ResourceAllocationEventRangeCalendarIntervalMixin\n        };\n    }\n}\nexport class ResourceAllocationEventRangeCalendar extends BaseCalendarMixin {\n    get intervalStoreClass() {\n        return ResourceAllocationEventRangeCalendarIntervalStore;\n    }\n}\n__decorate([\n    model_field({ type: 'boolean', defaultValue: false })\n], ResourceAllocationEventRangeCalendar.prototype, \"unspecifiedTimeIsWorking\", void 0);\nexport class BaseAllocationInterval extends Base {\n    constructor() {\n        super(...arguments);\n        /**\n         * Effort in the [[tick|interval]] in milliseconds.\n         */\n        this.effort = 0;\n        /**\n         * Utilization level of the resource (or the assignment if the interval represents the one) in percent.\n         */\n        this.units = 0;\n    }\n}\nexport class AssignmentAllocationInterval extends BaseAllocationInterval {\n}\n/**\n * Resource allocation information for a certain tick.\n */\nexport class ResourceAllocationInterval extends BaseAllocationInterval {\n    constructor() {\n        super(...arguments);\n        /**\n         * Maximum possible effort in the [[tick|interval]] in milliseconds.\n         */\n        this.maxEffort = 0;\n        /**\n         * Indicates that the resource (or the assignment if the interval represents the one) is over-allocated in the [[tick|interval]].\n         * So `true` when [[effort]] is more than [[maxEffort|possible maximum]].\n         */\n        this.isOverallocated = false;\n        /**\n         * Indicates that the resource (or assignment if the interval represents the one) is under-allocated in the [[tick|interval]].\n         * So `true` when [[effort]] is less than [[maxEffort|possible maximum]].\n         */\n        this.isUnderallocated = false;\n        /**\n         * Resource assignments ingoing in the [[tick|interval]].\n         */\n        this.assignments = null;\n        this.assignmentIntervals = null;\n    }\n}\nexport class BaseAllocationInfo extends Entity.mix(Base) {\n    getDefaultAllocationIntervalClass() {\n        return BaseAllocationInterval;\n    }\n    initialize(props) {\n        props = Object.assign({\n            includeInactiveEvents: false,\n            allocationIntervalClass: this.getDefaultAllocationIntervalClass()\n        }, props);\n        super.initialize(props);\n    }\n}\n__decorate([\n    field()\n], BaseAllocationInfo.prototype, \"includeInactiveEvents\", void 0);\n__decorate([\n    field()\n], BaseAllocationInfo.prototype, \"allocation\", void 0);\n/**\n * Class implementing _resource allocation report_ - a data representing the provided [[resource]]\n * utilization in the provided period of time.\n * The data is grouped by the provided [[ticks|time intervals]]\n */\nexport class ResourceAllocationInfo extends BaseAllocationInfo {\n    enterGraph(graph) {\n        super.enterGraph(graph);\n    }\n    leaveGraph(graph) {\n        super.leaveGraph(graph);\n        if (this.resource) {\n            this.resource.entities.delete(this);\n        }\n    }\n    getDefaultAllocationIntervalClass() {\n        return ResourceAllocationInterval;\n    }\n    *shouldIncludeAssignmentInAllocation(assignment) {\n        const event = yield assignment.$.event, units = yield assignment.$.units, includeInactiveEvents = yield this.$.includeInactiveEvents, inactive = event && (yield event.$.inactive), // includeInactiveEvents\n        startDate = event && (yield event.$.startDate), endDate = event && (yield event.$.endDate);\n        return Boolean(event && units && startDate && endDate && (includeInactiveEvents || !inactive));\n    }\n    *calculateAllocation() {\n        const total = [], ticksCalendar = yield this.ticks, resource = yield this.$.resource, includeInactiveEvents = yield this.$.includeInactiveEvents, assignments = yield resource.$.assigned, calendar = yield resource.$.effectiveCalendar, assignmentsByCalendar = new Map(), eventRanges = [], assignmentTicksData = new Map(), byAssignments = new Map();\n        let hasIgnoreResourceCalendarEvent = false;\n        // collect the resource assignments into assignmentsByCalendar map\n        for (const assignment of assignments) {\n            // skip missing or unscheduled event assignments\n            if (!(yield* this.shouldIncludeAssignmentInAllocation(assignment)))\n                continue;\n            // we're going to need up-to-date assignment \"units\" below in this method ..so we yield it here\n            yield assignment.$.units;\n            const event = yield assignment.$.event;\n            const ignoreResourceCalendar = yield event.$.ignoreResourceCalendar;\n            const startDate = yield event.$.startDate;\n            const endDate = yield event.$.endDate;\n            const segments = yield event.$.segments;\n            const eventCalendar = yield event.$.effectiveCalendar;\n            hasIgnoreResourceCalendarEvent = hasIgnoreResourceCalendarEvent || ignoreResourceCalendar;\n            // if the event is segmented collect segment ranges\n            if (segments) {\n                for (const segment of segments) {\n                    const startDate = yield segment.$.startDate;\n                    const endDate = yield segment.$.endDate;\n                    eventRanges.push({ startDate, endDate, assignment });\n                }\n            }\n            else {\n                eventRanges.push({ startDate, endDate, assignment });\n            }\n            let assignments = assignmentsByCalendar.get(eventCalendar);\n            if (!assignments) {\n                assignments = [];\n                assignmentsByCalendar.set(eventCalendar, assignments);\n            }\n            assignmentTicksData.set(assignment, new Map());\n            byAssignments.set(assignment, []);\n            assignments.push(assignment);\n        }\n        const eventRangesCalendar = new ResourceAllocationEventRangeCalendar({ intervals: eventRanges });\n        // Provide extra calendars:\n        // 1) a calendar containing list of ticks to group the resource allocation by\n        // 2) a calendar containing list of assigned event start/end ranges\n        // 3) assigned task calendars\n        const calendars = [ticksCalendar, eventRangesCalendar, ...assignmentsByCalendar.keys()];\n        const ticksData = new Map();\n        // Initialize the resulting array with empty items\n        ticksCalendar.intervalStore.forEach(tick => {\n            const tickData = ResourceAllocationInterval.new({ tick, resource });\n            ticksData.set(tick, tickData);\n            total.push(tickData);\n            assignmentTicksData.forEach((ticksData, assignment) => {\n                const assignmentTickData = AssignmentAllocationInterval.new({ tick, assignment });\n                ticksData.set(tick, assignmentTickData);\n                byAssignments.get(assignment).push(assignmentTickData);\n            });\n        });\n        let weightedUnitsSum, weightsSum;\n        const startDate = total[0].tick.startDate, endDate = total[total.length - 1].tick.endDate, iterationOptions = {\n            startDate,\n            endDate,\n            calendars,\n            includeNonWorkingIntervals: hasIgnoreResourceCalendarEvent,\n        }, ticksTotalDuration = endDate.getTime() - startDate.getTime();\n        // provide extended maxRange if total ticks duration is greater than it\n        if (ticksTotalDuration > resource.getProject().maxCalendarRange) {\n            iterationOptions.maxRange = ticksTotalDuration;\n        }\n        yield* resource.forEachAvailabilityInterval(iterationOptions, (intervalStartDate, intervalEndDate, intervalData) => {\n            const isWorkingCalendar = intervalData.getCalendarsWorkStatus();\n            // We are inside a tick interval and it's a working time according\n            // to a resource calendar\n            if (isWorkingCalendar.get(ticksCalendar)) {\n                const tick = intervalData.intervalsByCalendar.get(ticksCalendar)[0], intervalDuration = intervalEndDate.getTime() - intervalStartDate.getTime(), tickData = ticksData.get(tick), tickAssignments = tickData.assignments || new Set(), tickAssignmentIntervals = tickData.assignmentIntervals || new Map();\n                if (!tickData.assignments) {\n                    weightedUnitsSum = 0;\n                    weightsSum = 0;\n                }\n                let units = 0, intervalHasAssignments = false, duration;\n                // for each event intersecting the interval\n                intervalData.intervalsByCalendar.get(eventRangesCalendar).forEach((interval) => {\n                    const assignment = interval.assignment;\n                    const event = assignment?.event;\n                    // if event is performing in the interval\n                    if (event &&\n                        isWorkingCalendar.get(event.effectiveCalendar) &&\n                        (!hasIgnoreResourceCalendarEvent || event.ignoreResourceCalendar || isWorkingCalendar.get(calendar))) {\n                        // constrain the event start/end with the tick borders\n                        const workingStartDate = Math.max(intervalStartDate.getTime(), assignment.event.startDate.getTime());\n                        const workingEndDate = Math.min(intervalEndDate.getTime(), assignment.event.endDate.getTime());\n                        intervalHasAssignments = true;\n                        duration = workingEndDate - workingStartDate;\n                        const assignmentInterval = assignmentTicksData.get(assignment).get(tick);\n                        const assignmentEffort = duration * assignment.units / 100;\n                        assignmentInterval.effort += assignmentEffort;\n                        assignmentInterval.units = assignment.units;\n                        tickData.effort += assignmentEffort;\n                        // collect total resource usage percent in the current interval\n                        units += assignment.units;\n                        tickAssignments.add(assignment);\n                        tickAssignmentIntervals.set(assignment, assignmentInterval);\n                    }\n                });\n                // maxEffort represents the resource calendar intervals\n                if (isWorkingCalendar.get(calendar)) {\n                    tickData.maxEffort += intervalDuration;\n                }\n                // if we have assignments running in the interval - calculate average allocation %\n                if (units) {\n                    if (duration) {\n                        // keep weightedUnitsSum & weightsSum since there might be another intervals in the tick\n                        weightedUnitsSum += duration * units;\n                        weightsSum += duration;\n                        // \"units\" weighted arithmetic mean w/ duration values as weights\n                        tickData.units = weightedUnitsSum / weightsSum;\n                    }\n                    else if (!weightedUnitsSum) {\n                        tickData.units = units;\n                    }\n                }\n                if (intervalHasAssignments) {\n                    tickData.assignments = tickAssignments;\n                    tickData.assignmentIntervals = tickAssignmentIntervals;\n                    tickData.isOverallocated = tickData.isOverallocated || tickData.effort > tickData.maxEffort || tickData.units > 100;\n                    tickData.isUnderallocated = tickData.effort < tickData.maxEffort || tickData.units < 100;\n                }\n            }\n        });\n        return {\n            total,\n            byAssignments\n        };\n    }\n}\n__decorate([\n    field()\n], ResourceAllocationInfo.prototype, \"resource\", void 0);\n__decorate([\n    calculate('allocation')\n], ResourceAllocationInfo.prototype, \"calculateAllocation\", null);\n/**\n * A mixin for the resource entity at the Scheduler Pro level.\n */\nexport class SchedulerProResourceMixin extends Mixin([BaseResourceMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProResourceMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.observers = new Set();\n            this.entities = new Set();\n        }\n        addObserver(observer) {\n            this.graph.addIdentifier(observer);\n            this.observers.add(observer);\n        }\n        removeObserver(observer) {\n            if (this.graph) {\n                this.graph.removeIdentifier(observer);\n            }\n            this.observers.delete(observer);\n        }\n        addEntity(entity) {\n            this.graph.addEntity(entity);\n            this.entities.add(entity);\n        }\n        removeEntity(entity) {\n            if (this.graph) {\n                this.graph.removeEntity(entity);\n            }\n            this.entities.delete(entity);\n        }\n        leaveGraph(replica) {\n            const { graph } = this;\n            for (const observer of this.observers) {\n                this.removeObserver(observer);\n            }\n            for (const entity of this.entities) {\n                this.removeEntity(entity);\n            }\n            superProto.leaveGraph.call(this, replica);\n        }\n        *forEachAvailabilityInterval(options, func) {\n            const project = this.getProject();\n            const calendar = yield this.$.effectiveCalendar;\n            const effectiveCalendarsCombination = project.combineCalendars([calendar].concat(options.calendars || []));\n            const maxRange = project.maxCalendarRange;\n            const includeNonWorkingIntervals = options.includeNonWorkingIntervals;\n            if (maxRange) {\n                options = Object.assign({ maxRange }, options);\n            }\n            return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {\n                const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();\n                if (includeNonWorkingIntervals || calendarsStatus.get(calendar)) {\n                    return func(startDate, endDate, calendarCacheIntervalMultiple);\n                }\n            });\n        }\n    }\n    return SchedulerProResourceMixin;\n}) {\n}\n", "var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ProposedOrPrevious } from \"../../../../ChronoGraph/chrono/Effect.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CI } from \"../../../../ChronoGraph/collection/Iterator.js\";\nimport { prototypeValue } from \"../../../../ChronoGraph/util/Helpers.js\";\nimport Localizable from \"../../../../Core/localization/Localizable.js\";\nimport { model_field } from \"../../../chrono/ModelFieldAtom.js\";\nimport { CycleEffect } from \"../../../chrono/Replica.js\";\nimport { SchedulingIssueEffectResolution } from \"../../../chrono/SchedulingIssueEffect.js\";\nimport { DependenciesCalendar, DependencyValidationResult, ProjectType } from \"../../../scheduling/Types.js\";\nimport { ChronoEventStoreMixin } from \"../../store/ChronoEventStoreMixin.js\";\nimport { HasChildrenMixin } from \"../scheduler_basic/HasChildrenMixin.js\";\nimport { SchedulerBasicProjectMixin } from \"../scheduler_basic/SchedulerBasicProjectMixin.js\";\nimport { ConstrainedEarlyEventMixin } from \"./ConstrainedEarlyEventMixin.js\";\nimport { DateConstraintInterval } from \"./HasDateConstraintMixin.js\";\nimport { DeactivateDependencyResolution, DependencyConstraintInterval, RemoveDependencyResolution } from \"./ScheduledByDependenciesEarlyEventMixin.js\";\nimport { SchedulerProAssignmentMixin } from \"./SchedulerProAssignmentMixin.js\";\nimport { SchedulerProDependencyMixin } from \"./SchedulerProDependencyMixin.js\";\nimport { SchedulerProEvent } from \"./SchedulerProEvent.js\";\nimport { SchedulerProEventSegment } from \"./SchedulerProEventSegment.js\";\nimport { ResourceAllocationInfo, SchedulerProResourceMixin } from \"./SchedulerProResourceMixin.js\";\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * Scheduler Pro project mixin type. At this level, events are scheduled according to the incoming dependencies\n * and calendars of the assigned resources.\n *\n * The base event class for this level is [[SchedulerProEvent]]. The base dependency class is [[SchedulerProDependencyMixin]]\n */\nexport class SchedulerProProjectMixin extends Mixin([SchedulerBasicProjectMixin, ConstrainedEarlyEventMixin, HasChildrenMixin], (base) => {\n    const superProto = base.prototype;\n    class SchedulerProProjectMixin extends base {\n        construct(config = {}) {\n            this.eventSegmentModelClass = config.eventSegmentModelClass || this.getDefaultEventSegmentModelClass();\n            superProto.construct.call(this, config);\n            if (!this.resourceAllocationInfoClass)\n                this.resourceAllocationInfoClass = this.getDefaultResourceAllocationInfoClass();\n        }\n        getDefaultEventStoreClass() {\n            return ChronoEventStoreMixin;\n        }\n        getDefaultEventSegmentModelClass() {\n            return SchedulerProEventSegment;\n        }\n        getDefaultResourceAllocationInfoClass() {\n            return ResourceAllocationInfo;\n        }\n        *calculateDirection() {\n            return yield ProposedOrPrevious;\n        }\n        afterConfigure() {\n            superProto.afterConfigure.apply(this, arguments);\n            this.dateConstraintIntervalClass = this.dateConstraintIntervalClass || DateConstraintInterval;\n            this.dependencyConstraintIntervalClass = this.dependencyConstraintIntervalClass || DependencyConstraintInterval;\n        }\n        getType() {\n            return ProjectType.SchedulerPro;\n        }\n        getDefaultCycleEffectClass() {\n            return SchedulerProCycleEffect;\n        }\n        getDefaultEventModelClass() {\n            return SchedulerProEvent;\n        }\n        getDefaultDependencyModelClass() {\n            return SchedulerProDependencyMixin;\n        }\n        getDefaultAssignmentModelClass() {\n            return SchedulerProAssignmentMixin;\n        }\n        getDefaultResourceModelClass() {\n            return SchedulerProResourceMixin;\n        }\n        /**\n         * Validates a hypothetical dependency with provided parameters.\n         *\n         * ```typescript\n         * // let's check if a EndToStart dependency linking event1 with event2 will be valid\n         * const validationResult = await project.validateDependency(event1, event2, DependencyType.EndToStart);\n         *\n         * switch (validationResult) {\n         *     const DependencyValidationResult.CyclicDependency :\n         *         console.log('Dependency builds a cycle');\n         *         break;\n         *\n         *     const DependencyValidationResult.DuplicatingDependency :\n         *         console.log('Such dependency already exists');\n         *         break;\n         *\n         *     const DependencyValidationResult.NoError :\n         *         console.log('Dependency is valid');\n         * }\n         * ```\n         *\n         * See also [[isValidDependency]] method for more basic usage.\n         *\n         * @param fromEvent The dependency predecessor\n         * @param toEvent The dependency successor\n         * @param type The dependency type\n         * @param ignoreDependency Dependencies to ignore while validating. This parameter can be used for example if one plans to change\n         * an existing dependency properties and wants to know if the change will lead to an error:\n         *\n         * ```typescript\n         * // let's check if changing of the dependency predecessor to newPredecessor will make it invalid\n         * const validationResult = await project.validateDependency(newPredecessor, dependency.toEvent, dependency.type, dependency);\n         *\n         * if (validationResult !== DependencyValidationResult.NoError) console.log(\"The dependency is invalid\");\n         * ```\n         * @return The validation result\n         */\n        async validateDependency(fromEvent, toEvent, type, ignoreDependency) {\n            let ingoredDependencies;\n            if (ignoreDependency) {\n                ingoredDependencies = Array.isArray(ignoreDependency) ? ignoreDependency : [ignoreDependency];\n            }\n            const alreadyLinked = CI(fromEvent.outgoingDeps).some((dependency) => dependency.toEvent === toEvent && !ingoredDependencies?.includes(dependency));\n            if (alreadyLinked)\n                return DependencyValidationResult.DuplicatingDependency;\n            if (await this.isDependencyCyclic(fromEvent, toEvent, type, ingoredDependencies)) {\n                return DependencyValidationResult.CyclicDependency;\n            }\n            return DependencyValidationResult.NoError;\n        }\n        /**\n         * Validates a hypothetical dependency with provided parameters.\n         *\n         * ```typescript\n         * // let's check if a EndToStart dependency linking event1 with event2 will be valid\n         * if (await project.isValidDependency(event1, event2, DependencyType.EndToStart)) {\n         *     console.log('Dependency is valid');\n         * } else {\n         *     console.log('Dependency is invalid');\n         * }\n         * ```\n         *\n         * See also [[validateDependency]] method for more detailed validation results.\n         *\n         * @param fromEvent The dependency predecessor\n         * @param toEvent The dependency successor\n         * @param type The dependency type\n         * @param ignoreDependency Dependencies to ignore while validating. This parameter can be used for example if one plans to change\n         * an existing dependency properties and wants to know if the change will lead to an error:\n         *\n         * ```typescript\n         * // let's check if changing of the dependency predecessor to newPredecessor will make it invalid\n         * if (await project.isValidDependency(newPredecessor, dependency.toEvent, dependency.type, dependency)) console.log(\"The dependency is valid\");\n         * ```\n         * @return The validation result\n         */\n        // this does not account for possible scheduling conflicts\n        async isValidDependency(fromEvent, toEvent, type, ignoreDependency) {\n            const validationResult = await this.validateDependency(fromEvent, toEvent, type, ignoreDependency);\n            return validationResult === DependencyValidationResult.NoError;\n        }\n        getDependencyCycleDetectionIdentifiers(fromEvent, toEvent) {\n            return [\n                // @ts-ignore\n                toEvent.$.earlyStartDateConstraintIntervals,\n                // @ts-ignore\n                toEvent.$.earlyEndDateConstraintIntervals\n            ];\n        }\n        async isDependencyCyclic(fromEvent, toEvent, type, ignoreDependency) {\n            const dependencyClass = this.getDependencyStore().modelClass;\n            const dependency = new dependencyClass({ fromEvent, toEvent, type });\n            const branch = this.replica.branch({ autoCommit: false, onComputationCycle: 'throw' });\n            if (ignoreDependency) {\n                if (!Array.isArray(ignoreDependency)) {\n                    ignoreDependency = [ignoreDependency];\n                }\n                ignoreDependency.forEach(dependency => branch.removeEntity(dependency));\n            }\n            branch.addEntity(dependency);\n            dependency.project = this;\n            // search for identifiers reading of which finds a cycle\n            // for (const i of Object.keys(toEvent.$)) {\n            //     try {\n            //         await branch.readAsync(toEvent.$[i])\n            //     } catch (e) {\n            //         if (/cycle/i.test(e)) {\n            //             // dump found identifier names to console\n            //             console.log(i)\n            //         }\n            //         else\n            //             throw e\n            //     }\n            // }\n            try {\n                await Promise.all(this.getDependencyCycleDetectionIdentifiers(fromEvent, toEvent).map(i => branch.readAsync(i)));\n                return false;\n            }\n            catch (e) {\n                // return true for the cycle exception and re-throw all others\n                if (/cycle/i.test(e))\n                    return true;\n                // We don't throw on conflicts here ..it's supposed to happen when the changes really reach the graph\n                if (!/conflict/i.test(e)) {\n                    throw e;\n                }\n            }\n        }\n        // work in progress\n        // This method validates changes (e.g. type) for existing dependencies (which are already in the store)\n        async isValidDependencyModel(dependency, ignoreDependencies) {\n            return this.isValidDependency(dependency.fromEvent, dependency.toEvent, dependency.type, ignoreDependencies);\n        }\n    }\n    __decorate([\n        model_field({ type: 'string', defaultValue: DependenciesCalendar.ToEvent })\n    ], SchedulerProProjectMixin.prototype, \"dependenciesCalendar\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerProProjectMixin.prototype, \"autoCalculatePercentDoneForParentTasks\", void 0);\n    __decorate([\n        model_field({ type: 'boolean', defaultValue: true })\n    ], SchedulerProProjectMixin.prototype, \"addConstraintOnDateSet\", void 0);\n    return SchedulerProProjectMixin;\n}) {\n}\n/**\n * A cycle resolution deactivating one of the [[getDependencies|related dependencies]].\n * The dependency instance should be passed to [[resolve]] method:\n *\n * ```typescript\n * // this call will deactivate dependencyRecord\n * removalResolution.resolve(dependencyRecord)\n * ```\n */\nexport class DeactivateDependencyCycleEffectResolution extends Localizable(SchedulingIssueEffectResolution) {\n    static get $name() {\n        return 'DeactivateDependencyCycleEffectResolution';\n    }\n    getDescription() {\n        return this.L('L{descriptionTpl}');\n    }\n    resolve(dependency) {\n        dependency.active = false;\n    }\n}\n/**\n * Class implementing a special effect signalizing of a computation cycle.\n * The class suggests two [[getResolutions|resolutions]] - either removing or deactivating one of\n * the [[getDependencies|related dependencies]].\n */\nexport class SchedulerProCycleEffect extends CycleEffect {\n    /**\n     * Returns dependencies taking part in the cycle that are treated as invalid.\n     * For example a \"parent-child\" dependency or a dependency linking a task to itself.\n     */\n    getInvalidDependencies() {\n        if (!this._invalidDependencies) {\n            const dependencies = this.getDependencies();\n            this._invalidDependencies = dependencies.filter(dependency => \n            // @ts-ignore\n            dependency.fromEvent === dependency.toEvent || (dependency.fromEvent.contains(dependency.toEvent) || dependency.toEvent.contains(dependency.fromEvent)));\n        }\n        return this._invalidDependencies;\n    }\n    buildInvalidDependencyResolutions(config) {\n        return [\n            this.removeDependencyConflictResolutionClass.new(config),\n            this.deactivateDependencyConflictResolutionClass.new(config)\n        ];\n    }\n    matchDependencyBySourceAndTargetEvent(dependency, from, to) {\n        return dependency.active && super.matchDependencyBySourceAndTargetEvent(dependency, from, to);\n    }\n    getResolutions() {\n        if (!this._resolutions) {\n            const invalidDependencies = this.getInvalidDependencies();\n            const result = [];\n            for (const dependency of invalidDependencies) {\n                result.push(...this.buildInvalidDependencyResolutions({ dependency }));\n            }\n            // If we have invalid dependencies we do not suggest other dependency resolutions\n            // to force resolving the invalid ones first\n            if (!invalidDependencies.length) {\n                result.push(this.deactivateDependencyCycleEffectResolutionClass.new(), ...super.getResolutions());\n            }\n            this._resolutions = result;\n        }\n        return this._resolutions;\n    }\n}\n__decorate([\n    prototypeValue(DeactivateDependencyCycleEffectResolution)\n], SchedulerProCycleEffect.prototype, \"deactivateDependencyCycleEffectResolutionClass\", void 0);\n__decorate([\n    prototypeValue(RemoveDependencyResolution)\n], SchedulerProCycleEffect.prototype, \"removeDependencyConflictResolutionClass\", void 0);\n__decorate([\n    prototypeValue(DeactivateDependencyResolution)\n], SchedulerProCycleEffect.prototype, \"deactivateDependencyConflictResolutionClass\", void 0);\n", "import Objects from './Objects.js';\nimport StringHelper from '../StringHelper.js';\n/**\n * @module Core/helper/util/DomClassList\n */\nconst\n    // Presence of '[' is likely an \"[object Object]\" or other bogus stringification\n    invalidClsRe  = /\\[|undefined|null/,\n    valueSymbol   = Symbol('value'),\n    lengthSymbol  = Symbol('length');\n/**\n * This class encapsulates a list of CSS classes which can be set as the `className`\n * on an `HTMLElement`.\n *\n * Properties names set on this class equate to *adding* a class if the property's value\n * is _truthy_, or removing a class if the value is _falsy_.\n *\n * ```javascript\n * const myClassList = new DomClassList('b-test-button');\n *\n * myClassList.add('test-class');\n * myClassList.important = 1;\n *\n * myHtmlElement.className = myClassList; // Sets it to \"b-test-button test-class important\"\n * ```\n */\nexport default class DomClassList {\n    static change(cls, add, remove, as = 'string') {\n        remove = DomClassList.normalize(remove, 'object');\n        const after = DomClassList.normalize(cls, 'array').filter(c => !remove[c]);\n        if (add) {\n            add = DomClassList.normalize(add, 'array');\n            for (let i = 0; i < add.length; ++i) {\n                if (!after.includes(add[i])) {\n                    after.push(add[i]);\n                }\n            }\n        }\n        return DomClassList.normalize(after, as);\n    }\n    static from(classes, returnEmpty) {\n        if (classes) {\n            if (classes.isDomClassList) {\n                returnEmpty = returnEmpty ?? true;\n            }\n            else {\n                returnEmpty = returnEmpty ?? (Objects.isObject(classes) && !Objects.isEmpty(classes));\n                classes = new DomClassList(classes);\n            }\n            if (!classes.value && !returnEmpty) {\n                classes = null;\n            }\n        }\n        return classes || (returnEmpty ? new DomClassList() : null);\n    }\n    /**\n     * Converts a class name of any understood type to a desired form.\n     * @param {String|String[]|Object|Set|Map|HTMLElement} cls\n     * @param {String} as Pass `'object'` to return an object with the class names as its keys (all keys will have a\n     * value of `true`), or pass `'array'` to return an array of class names, or pass `'string'` (the default) to\n     * return a space-separated string of class names.\n     * @returns {String|String[]|Object}\n     * @internal\n     */\n    static normalize(cls, as = 'string') {\n        cls = cls || '';  // promote null to '' to avoid typeof snag\n        const\n            type = typeof cls,\n            asArray = as === 'array',\n            asObject = as === 'object',\n            asString = !asArray && !asObject;\n        let isString = type === 'string',\n            c, i, ret;\n        if (type === 'object') {\n            if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === 'function') {\n                cls = cls.getAttribute('class') || '';  // cannot use className for SVG el's\n                isString = true;\n            }\n            else if (cls?.isDomClassList) {\n                cls = cls.values;\n            }\n            else if (cls instanceof DOMTokenList) {\n                cls = Array.from(cls);\n            }\n            else if (cls instanceof Map) {\n                cls = Array.from(cls.keys()).filter(k => cls.get(k));\n            }\n            else if (cls instanceof Set) {\n                cls = Array.from(cls);\n            }\n            else if (!Array.isArray(cls)) {\n                cls = Objects.getTruthyKeys(cls);\n            }\n        }\n        if (isString) {\n            // Pass through Set to ensure only unique class names\n            cls = [...new Set(StringHelper.split(cls))];\n        }\n        // cls is now an array\n        for (i = cls.length; i-- > 0; /* empty */) {\n            c = cls[i];\n            if (!c.length) {\n                cls.splice(i, 1);\n            }\n            else if (c.includes(' ')) {\n                cls.splice(i, 1, ...StringHelper.split(c));\n            }\n        }\n        if (asArray) {\n            ret = cls;\n        }\n        else if (asString) {\n            ret = cls.join(' ');\n        }\n        else {\n            ret = Object.create(null);\n            for (i = 0; i < cls.length; ++i) {\n                ret[cls[i]] = true;\n            }\n        }\n        return  ret;\n    }\n    /**\n     * Initializes a new DomClassList.\n     * @param {...String|Object} classes The CSS classes as strings or objects.\n     * @function constructor\n     */\n    constructor(...classes) {\n        this.process(1, classes);\n    }\n    /**\n     * Clears all class names from this DomClassList instance.\n     * @returns {Core.helper.util.DomClassList} this DomClassList.\n     */\n    clear() {\n        // Keep internal class same shape. Do not delete members.\n        for (const key in this) {\n            this[key] = false;\n        }\n        return this;\n    }\n    /**\n     * Sets this DomClassList instance to represent the classes passed as either strings or objects.\n     * @returns {Core.helper.util.DomClassList} this DomClassList.\n     */\n    set(...classes) {\n        return this.clear().process(1, classes);\n    }\n    // To gain some speed in DomHelper.sync(), faster than instanceof etc\n    get isDomClassList() {\n        return true;\n    }\n    /**\n     * Returns a clone of this DomClassList with all the same keys set.\n     * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.\n     */\n    clone() {\n        return new DomClassList(this);\n    }\n    /**\n     * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.\n     * @param {String} className CSS class name to check\n     * @returns {Boolean} true if this ClassList contains the passed CSS class name, false otherwise\n     */\n    contains(className) {\n        if (typeof className === 'string' && className) {\n            return Boolean(this[className]);\n        }\n        return false;\n    }\n    // An instance of this class may be assigned directly to an element's className\n    // it will be coerced to a string value using this method.\n    toString() {\n        // Adding space at the end if there is content to make concatenation code simpler in renderers.\n        return this.length ? `${this.value} ` : '';\n    }\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.\n     * @returns {String} A concatenated string value of all the class names in this `DomClassList`\n     * separated by spaces.\n     */\n    trim() {\n        return this.value;\n    }\n    /**\n     * Compares this DomClassList to another DomClassList (or class name string of space separated classes).\n     * If the same class names (regardless of order) are present, the two are considered equal.\n     *\n     * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`\n     * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.\n     * @returns {Boolean} `true` if the two contain the same class names.\n     */\n    isEqual(other) {\n        const\n            otherClasses = DomClassList.normalize(other, 'array'),\n            len = otherClasses.length;\n        if (this.length === len) {\n            for (let i = 0; i < len; i++) {\n                if (!this[otherClasses[i]]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get/set string value.\n     * Class names separated with space.\n     * @property {String}\n     */\n    get value() {\n        let value = this[valueSymbol],\n            keys;\n        if (value == null) {\n            keys = Objects.getTruthyKeys(this);\n            this[lengthSymbol] = keys.length;\n            this[valueSymbol] = value = keys.join(' ');\n        }\n        return value;\n    }\n    set value(value) {\n        const\n            me = this,\n            keys = Object.keys(me),\n            len = keys.length;\n        for (let i = 0; i < len; i++) {\n            delete me[keys[i]];\n        }\n        if (value) {\n            me.process(1, [value]);\n        }\n        else {\n            // String value needs recalculating\n            delete me[valueSymbol];\n        }\n    }\n    /**\n     * Returns string values as an array.\n     * @readonly\n     * @property {String[]}\n     */\n    get values() {\n        return Objects.getTruthyKeys(this);\n    }\n    get length() {\n        // Maintainer: We MUST access the value getter to force\n        // the value to be calculated if it's currently dirty.\n        return this.value ? this[lengthSymbol] : 0;\n    }\n    process(value, classes) {\n        for (let cls, k, i = 0; i < classes.length; i++) {\n            if (classes[i]) {\n                cls = classes[i];\n                if (cls.isDomClassList || Objects.isObject(cls)) {\n                    // preserve all keys, even falsy ones\n                    for (k in cls) {\n                        this[k] = value ? cls[k] : !cls[k];\n                    }\n                }\n                else {\n                    cls = DomClassList.normalize(classes[i], 'array');\n                    for (k = 0; k < cls.length; ++k) {\n                        this[cls[k]] = value;\n                    }\n                }\n            }\n        }\n        // String value needs recalculating\n        delete this[valueSymbol];\n        return this;\n    }\n    /**\n     * Adds/removes class names according to the passed object's properties.\n     *\n     * Properties with truthy values are added.\n     * Properties with falsy values are removed.\n     * @param {Object} classList Object containing properties to set/clear\n     */\n    assign(classList) {\n        for (const cls in classList) {\n            if (!this[cls] !== !classList[cls]) {\n                this[cls] = classList[cls];\n                // String value needs recalculating\n                delete this[valueSymbol];\n            }\n        }\n        return this;\n    }\n    /**\n     * Adds/removes this objects classes to the passed `classList` or element.\n     *\n     * Properties with truthy values are added.\n     * Properties with falsy values are removed.\n     * @param {HTMLElement|DOMTokenList} element The element or the element's `classList` to be updated.\n     */\n    assignTo(element) {\n        const\n            classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element,\n            temp      = DomClassList.from(classList);\n        temp.add(this);\n        classList.value = temp.value;\n    }\n    /**\n     * Add CSS class(es)\n     * ```\n     * myClassList.add('bold', 'small');\n     * ```javascript\n     * @param {String|String[]|Object} classes CSS classes to add\n     */\n    add(...classes) {\n        return this.process(1, classes);\n    }\n    /**\n     * Remove CSS class(es)\n     * ```javascript\n     * myClassList.remove('bold', 'small');\n     * ```\n     * @param {String} classes CSS classes to remove\n     */\n    remove(...classes) {\n        return this.process(0, classes);\n    }\n    /**\n     * Toggles the passed CSS class name.\n     *\n     * If the `force` parameter is passed, `true` means add the class name, `false` means remove it.\n     *\n     * ```javascript\n     * myClassList.toggle('bold', isImportant);\n     * ```\n     * @param {String} className CSS class to toggle\n     * @param {Boolean} [force] `true` to add the class, `false` to remove it.\n     * @returns {Boolean} `true` if the operation changed the value.\n     */\n    toggle(className, flag = Boolean(!this[className])) {\n        flag = Boolean(flag);\n        // Only disturb the set classwes if we need to.\n        if (Boolean(this[className]) !== flag) {\n            this[className] = flag;\n            // String value needs recalculating\n            delete this[valueSymbol];\n            return true;\n        }\n    }\n    /**\n     * Analogous to the `String#split` method, but with no delimiter\n     * parameter. This method returns an array containing the individual\n     * CSS class names set.\n     * @returns {String[]} The individual class names in this `DomClassList`\n     */\n    split() {\n        return Objects.getTruthyKeys(this);\n    }\n    forEach(fn) {\n        return Objects.getTruthyKeys(this).forEach(fn);\n    }\n};\n// We put this on the prototype and delete it from instances to mark dirty state. This maintains the same shape for\n// the instance to help the JIT\nDomClassList.prototype[valueSymbol] = null;\nDomClassList._$name = 'DomClassList';", "import Store from './Store.js';\nimport AjaxHelper from '../helper/AjaxHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\n/**\n * @module Core/data/AjaxStore\n */\n/**\n * Http methods used by the AjaxStore in restful mode.\n * @typedef {Object} HttpMethods\n * @property {'POST'|'PUT'} create\n * @property {'GET'|'POST'} read\n * @property {'PATCH'|'POST'|'PUT'} update\n * @property {'DELETE'|'POST'} delete\n */\nconst\n    processParamEntry = (paramArray, entry) => {\n        if (Array.isArray(entry[1])) {\n            entry[1].forEach(value => paramArray.push(encodeURIComponent(entry[0]) + '=' + encodeURIComponent(value)));\n        }\n        else {\n            paramArray.push(encodeURIComponent(entry[0]) + '=' + encodeURIComponent(entry[1]));\n        }\n        return paramArray;\n    },\n    immediatePromise  = Promise.resolve(),\n    prependZeros = num => {\n        return String(num).padStart(2, '0');\n    },\n    dateToString = date => {\n        return `${ date.getFullYear() }-${ prependZeros(date.getMonth() + 1) }-${ prependZeros(date.getDate()) }T${ prependZeros(date.getHours()) }:${ prependZeros(date.getMinutes()) }:${ prependZeros(date.getSeconds()) }.${ date.getMilliseconds() }`;\n    };\n/**\n * Store that uses the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) to read data\n * from a remote server, and optionally sends synchronization requests to the server containing information about\n * locally created, modified and deleted records.\n *\n * ## Create\n * Posts array of JSON data for newly added records to {@link #config-createUrl}, expects response containing an array\n * of JSON objects in same order with id set (uses Model#idField as id).\n *\n * ## Read\n * Reads array of JSON data from the data packet returned from the {@link #config-readUrl}. Unique id for each row is\n * required.\n *\n * By default looks in field 'id' but can be configured by setting {@link Core.data.Model#property-idField-static}.\n *\n * ## Update\n * Posts array of JSON data containing modified records to {@link #config-updateUrl}. By default, only changed fields\n * and any fields configured with {@link Core.data.field.DataField#config-alwaysWrite} are sent.\n * If you want all fields to always be sent, please see {@link #config-writeAllFields}\n *\n * ## Delete\n * Posts to {@link #config-deleteUrl} with removed records ids (for example id=1,4,7).\n *\n * ```javascript\n * new AjaxStore({\n *   createUrl  : 'php/create',\n *   readUrl    : 'php/read',\n *   updateUrl  : 'php/update',\n *   deleteUrl  : 'php/delete',\n *   modelClass : Customer\n * });\n * ```\n *\n * ## Pagination\n * Configuring an `AjaxStore` with {@link #config-pageParamName} or {@link #config-pageStartParamName} means that the\n * store requests **pages** of data from the remote source, sending the configured {@link #config-pageParamName} or\n * {@link #config-pageStartParamName} to request the page along with the {@link #config-pageSizeParamName}.\n *\n * If `pageParamName` is set, that is passed with the requested page number **(one based)**, along with the\n * {@link #config-pageSizeParamName}.\n *\n * If `pageStartParamName` is set, that is passed with the requested page starting record index **(zero based)**, along\n * with the {@link #config-pageSizeParamName}.\n *\n * ## Remote filtering\n * To specify that filtering is the responsibility of the server, configure the store with\n * `{@link #config-filterParamName}: 'nameOfFilterParameter'`\n *\n * When this is set, any {@link Core.data.mixin.StoreFilter#function-filter} operation causes the store to reload\n * itself, encoding the filters as JSON representations in the {@link #config-filterParamName} HTTP parameter.\n *\n * The filters will look like this:\n * ```javascript\n * {\n *     \"field\": \"country\",\n *     \"operator\": \"=\",\n *     \"value\": \"sweden\",\n *     \"caseSensitive\": false\n * }\n * ```\n *\n * If the value of the filter is a date - it is serialized as a local time, using the format: `YYYY-MM-DDThh:mm:ss.ms`\n *\n * The encoding may be overridden by configuring an implementation of {@link #function-encodeFilterParams}\n * into the store which returns the value for the {@link #config-filterParamName} when passed an _Iterable_ of filters.\n *\n * ## Remote sorting\n * To specify that sorting is the responsibility of the server, configure the store with\n * `{@link #config-sortParamName}: 'nameOfSortParameter'`\n *\n * When this is set, any {@link Core.data.mixin.StoreSort#function-sort} operation causes the store to\n * reload itself, encoding the sorters as JSON representations in the {@link #config-sortParamName} HTTP\n * parameter.\n *\n * The sorters will look like this:\n * ```javascript\n * {\n *     \"field\": \"name\",\n *     \"ascending\": true\n * }\n * ```\n *\n * The encoding may be overridden by configuring an implementation of {@link #function-encodeSorterParams}\n * into the store which returns the value for the {@link #config-sortParamName} when passed an _Iterable_ of sorters.\n *\n * ## Passing HTTP headers\n * As mentioned above `AjaxStore` uses the Fetch API under the hood. Specify {@link #config-fetchOptions} and/or\n * {@link #config-headers} to have control over the options passed with all fetch calls. For example to pass along an\n * authorization header:\n *\n * ```javascript\n * const store = new AjaxStore({\n *    headers : {\n *        Authorization : 'auth-contents-goes-here'\n *    }\n * });\n * ```\n *\n * Learn more about the Fetch API over at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).\n *\n * @extends Core/data/Store\n */\nexport default class AjaxStore extends Store {\n    static $name = 'AjaxStore';\n    // region Events\n    /**\n     * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid\n     * response.\n     *\n     * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual\n     * operation, `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit\n     * operation will also trigger an `exception` event when all the operations have finished, so if exceptions are\n     * going to be handled gracefully, the event's `action` property must be examined, and the constituent operations of\n     * the event must be examined.\n     * @event exception\n     * @param {Core.data.Store} source This Store\n     * @param {Boolean} exception `true`\n     * @param {'create'|'read'|'update'|'delete'|'commit'} action Action that failed, `'create'`, `'read'`,\n     * `'update'` or `'delete'`. May also be fired with '`commit'` to indicate the failure of an aggregated `create`,\n     * `update` and `delete` operation. In this case, the event will contain a property for each operation of the commit\n     * named `'create'`, `'update'` and `'delete'`, each containing the individual `exception` events.\n     * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`\n     * @param {Response} response the `Response` object\n     * @param {Object} json The decoded response object *if the exceptionType is `'server'`*\n     */\n    /**\n     * Fired after committing added records\n     * @event commitAdded\n     * @param {Core.data.Store} source This Store\n     */\n    /**\n     * Fired after committing modified records\n     * @event commitModified\n     * @param {Core.data.Store} source This Store\n     */\n    /**\n     * Fired on successful load\n     * @event load\n     * @param {Core.data.Store} source This Store\n     * @param {Object[]} data Data loaded\n     * @param {Response} response the `Response` object\n     * @param {Object} json The decoded response object.\n     */\n    /**\n     * Fired on successful load of remote child nodes for a tree node.\n     * @event loadChildren\n     * @param {Core.data.Store} source This Store\n     * @param {Object[]} data Data loaded\n     * @param {Object} json The decoded response object.\n     */\n    /**\n     * Fired after committing removed records\n     * @event commitRemoved\n     * @param {Core.data.Store} source This Store\n     */\n    /**\n     * Fired before loading starts. Allows altering parameters and is cancelable\n     * @event beforeLoad\n     * @preventable\n     * @param {Core.data.Store} source This Store\n     * @param {Object} params An object containing property/name pairs which are the parameters.\n     * This may be mutated to affect the parameters used in the Ajax request.\n     */\n    /**\n     * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable\n     * @event beforeLoadChildren\n     * @preventable\n     * @param {Core.data.Store} source This Store\n     * @param {Object} params An object containing property/name pairs which are the parameters.\n     * This may be mutated to affect the parameters used in the Ajax request.\n     */\n    /**\n     * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable\n     * @event beforeLoadPage\n     * @preventable\n     * @param {Core.data.Store} source This Store\n     * @param {Object} params An object containing property/name pairs which are the parameters.\n     * This may be mutated to affect the parameters used in the Ajax request.\n     */\n    /**\n     * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be\n     * mutated at this stage.\n     * @event loadStart\n     * @param {Core.data.Store} source This Store\n     * @param {Object} params An object containing property/name pairs which are the parameters.\n     * This may be mutated to affect the parameters used in the Ajax request.\n     */\n    /**\n     * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the\n     * event may still be mutated at this stage.\n     * @event loadChildrenStart\n     * @param {Core.data.Store} source This Store\n     * @param {Object} params An object containing property/name pairs which are the parameters.\n     * This may be mutated to affect the parameters used in the Ajax request.\n     */\n    /**\n     * Fired before any remote request is initiated.\n     * @event beforeRequest\n     * @param {Core.data.Store} source This Store\n     * @param {Object} params An object containing key/value pairs that are passed on the request query string\n     * @param {Object} body The body of the request to be posted to the server.\n     * @param {'create'|'read'|'update'|'delete'} action Action that is making the request, `'create'`,\n     * `'read'`, `'update'` or `'delete'`\n     */\n    /**\n     * Fired after any remote request has finished whether successfully or unsuccessfully.\n     * @event afterRequest\n     * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*\n     * @param {'create'|'read'|'update'|'delete'} action Action that has finished, `'create'`, `'read'`,\n     * `'update'` or `'delete'`\n     * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`. *Only present\n     * if the request triggered an exception.*\n     * @param {Response} response The `Response` object\n     * @param {Object} json The decoded response object if there was no `'network'` exception.\n     */\n    // endregion\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * A string keyed object containing the HTTP headers to add to each server request issued by this store.\n             *\n             * `AjaxStore` uses the Fetch API under the hood, read more about headers on\n             * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#headers)\n             *\n             * Example usage:\n             *\n             * ```javascript\n             * const store = new AjaxStore({\n             *    headers : {\n             *        Authorization : 'auth-contents-goes-here'\n             *    }\n             * });\n             * ```\n             *\n             * @config {Object<String,String>}\n             * @category Remote\n             */\n            headers : null,\n            /**\n             * An object containing the Fetch options to pass to each server request issued by this store. Use this to\n             * control if credentials are sent and other options, read more at\n             * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options).\n             *\n             * Example usage:\n             *\n             * ```javascript\n             * const store = new AjaxStore({\n             *    fetchOptions : {\n             *        credentials : 'omit',\n             *        redirect    : 'error'\n             *    }\n             * });\n             * ```\n             *\n             * @config {Object}\n             * @category Remote\n             */\n            fetchOptions : null,\n            /**\n             * Specify `true` to send payloads as form data, `false` to send as regular JSON.\n             * @config {Boolean}\n             * @default false\n             * @category Remote\n             */\n            sendAsFormData : null,\n            /**\n             * Specify `true` to send all model fields when committing modified records (as opposed to just the\n             * modified fields)\n             * @config {Boolean}\n             * @default false\n             * @category Remote\n             */\n            writeAllFields : null,\n            /**\n             * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id`\n             * to load when loading child nodes on demand if the node being expanded was created with data containing\n             * `children: true`.\n             * @config {String}\n             * @default\n             * @category Remote\n             */\n            parentIdParamName : 'id',\n            /**\n             * The optional property name in JSON responses from the server that contains a boolean\n             * success/fail status.\n             * ```json\n             * {\n             *   \"responseMeta\" : {\n             *   {\n             *     \"success\" : true,\n             *     \"count\" : 100\n             *   },\n             *   // The property name used here should match that of 'responseDataProperty'\n             *   \"data\" : [\n             *     ...\n             *   ]\n             * }\n             * ```\n             *\n             * The store would be configured with:\n             * ```javascript\n             *  {\n             *      ...\n             *      successDataProperty : 'responseMeta.success',\n             *      responseTotalProperty : 'responseMeta.count'\n             *      ...\n             *  }\n             *\n             * ```\n             * @config {String}\n             * @default\n             * @category Remote\n             */\n            responseSuccessProperty : 'success',\n            /**\n             * The property name in JSON responses from the server that contains the data for the records\n             * ```json\n             * {\n             *   \"success\" : true,\n             *   // The property name used here should match that of 'responseDataProperty'\n             *   \"data\" : [\n             *     ...\n             *   ]\n             * }\n             * ```\n             * @config {String}\n             * @default\n             * @category Remote\n             */\n            responseDataProperty : 'data',\n            /**\n             * The property name in JSON responses from the server that contains the dataset total size\n             * **when this store {@link #property-isPaged is paged}**\n             * ```json\n             * {\n             *   \"success\" : true,\n             *   // The property name used here should match that of 'responseDataProperty'\n             *   \"data\" : [\n             *     ...\n             *   ],\n             *   // The property name used here should match that of 'responseTotalProperty'\n             *   \"total\" : 65535\n             * }\n             * ```\n             * @config {String}\n             * @default\n             * @category Remote\n             */\n            responseTotalProperty : 'total',\n            /**\n             * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a\n             * filtered response is required.\n             *\n             * **Note:** When this is set, filters must be defined using a field name, an operator and a value\n             * to compare, **not** a comparison function.\n             * @config {String}\n             * @category Remote\n             */\n            filterParamName : null,\n            /**\n             * Set this flag to true if you are filtering remote using restful URLs (e.g.\n             * https://nominatim.openstreetmap.org/search/paris?format=json)\n             *\n             * **Note:** When this is set, the filter string is appended to the readUrl.\n             * @config {Boolean}\n             * @category Remote\n             */\n            restfulFilter : false,\n            /**\n             * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a\n             * sorted response is required.\n             *\n             * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,\n             * **not** a sort function.\n             * @config {String}\n             * @category Remote\n             */\n            sortParamName : null,\n            /**\n             * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number\n             * required.\n             * @config {String}\n             * @category Paging\n             */\n            pageParamName : null,\n            /**\n             * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the\n             * required page's starting record.\n             * @config {String}\n             * @category Paging\n             */\n            pageStartParamName : null,\n            /**\n             * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the\n             * required page's starting record.\n             * @config {String}\n             * @default\n             * @category Paging\n             */\n            pageSizeParamName : 'pageSize',\n            /**\n             * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the\n             * {@link #config-pageStartParamName}, this is the value to send in the {@link #config-pageSizeParamName}.\n             * @config {Number}\n             * @default\n             * @category Paging\n             */\n            pageSize : 50,\n            /**\n             * Set to \u00B4true\u00B4 to use restful {@link #config-httpMethods}\n             * @config {Boolean}\n             * @default false\n             * @category Remote\n             */\n            useRestfulMethods : null,\n            /**\n             * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.\n             *\n             * ```javascript\n             * new AjaxStore({\n             *    useRestfulMethods : true,\n             *    httpMethods : {\n             *        create : 'POST',\n             *        read   : 'POST',\n             *        update : 'PATCH',\n             *        delete : 'DELETE'\n             *    }\n             * });\n             *\n             * ```\n             * @config {HttpMethods}\n             * @default\n             * @category Remote\n             */\n            httpMethods : {\n                create : 'POST',\n                read   : 'GET',\n                update : 'PUT',\n                delete : 'DELETE'\n            }\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * An object containing key/value pairs that are passed on the request query string.\n             * @member {Object} params\n             * @category Remote\n             */\n            /**\n             * An object containing key/value pairs that are passed on the request query string.\n             * @config {Object}\n             * @category Remote\n             */\n            params : null\n        };\n    }\n    /**\n     * Url to post newly created records to.\n     *\n     * The response must be in the form:\n     *\n     *     {\n     *         \"success\": true,\n     *         \"data\": [{\n     *             \"id\": 0, \"name\": \"General Motors\"\n     *         }, {\n     *             \"id\": 1, \"name\": \"Apple\"\n     *         }]\n     *     }\n     *\n     * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the\n     * server.\n     *\n     * If the server encountered an error, the packet would look like this:\n     *\n     *     {\n     *         \"success\": false,\n     *         \"message\": \"Some kind of database error\"\n     *     }\n     *\n     * And that packet would be available in the {@link #event-exception} handler in the `response` property of the\n     * event.\n     *\n     * The `success` property may be omitted, it defaults to `true`.\n     *\n     * @prp {String} createUrl\n     * @category CRUD\n     */\n    /**\n     * Url to read data from.\n     *\n     * The response must be in the form:\n     *\n     *     {\n     *         \"success\": true,\n     *         \"data\": [{\n     *             \"id\": 0, \"name\": \"General Motors\"\n     *         }, {\n     *             \"id\": 1, \"name\": \"Apple\"\n     *         }]\n     *     }\n     *\n     * If the store {@link #property-isPaged is paged}, the total dataset size must be returned in the\n     * {@link #config-responseTotalProperty} property:\n     *\n     *     {\n     *         \"success\": true,\n     *         \"data\": [{\n     *             \"id\": 0, \"name\": \"General Motors\"\n     *         }, {\n     *             \"id\": 1, \"name\": \"Apple\"\n     *         }],\n     *         \"total\": 65535\n     *     }\n     *\n     * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the\n     * server.\n     *\n     * If the server encountered an error, the packet would look like this:\n     *\n     *     {\n     *         \"success\": false,\n     *         \"message\": \"Some kind of database error\"\n     *     }\n     *\n     * And that packet would be available in the {@link #event-exception} handler in the `response` property of the\n     * event.\n     *\n     * The `success` property may be omitted, it defaults to `true`.\n     *\n     * @prp {String} readUrl\n     * @category CRUD\n     */\n    /**\n     * Url to post record modifications to.\n     *\n     * The response must be in the form:\n     *\n     *     {\n     *         \"success\": true,\n     *         \"data\": [{\n     *             \"id\": 0, \"name\": \"General Motors\"\n     *         }, {\n     *             \"id\": 1, \"name\": \"Apple\"\n     *         }]\n     *     }\n     *\n     * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the\n     * server.\n     *\n     * If the server encountered an error, the packet would look like this:\n     *\n     *     {\n     *         \"success\": false,\n     *         \"message\": \"Some kind of database error\"\n     *     }\n     *\n     * And that packet would be available in the {@link #event-exception} handler in the `response` property of the\n     * event.\n     *\n     * The `success` property may be omitted, it defaults to `true`.\n     *\n     * @prp {String} updateUrl\n     * @category CRUD\n     */\n    /**\n     * Url for deleting records.\n     *\n     * The response must be in the form:\n     *\n     *     {\n     *         \"success\": true\n     *     }\n     *\n     * If the server encountered an error, the packet would look like this:\n     *\n     *     {\n     *         \"success\": false,\n     *         \"message\": \"Some kind of database error\"\n     *     }\n     *\n     * And that packet would be available in the {@link #event-exception} handler in the `response` property of the\n     * event.\n     *\n     * The `success` property may be omitted, it defaults to `true`.\n     *\n     * @prp {String} deleteUrl\n     * @category CRUD\n     */\n    /**\n     * True to initiate a load when the store is instantiated\n     * @config {Boolean} autoLoad\n     * @category Common\n     */\n    //endregion\n    afterConstruct(config) {\n        super.afterConstruct(config);\n        if (this.autoLoad) {\n            this.load().catch(() => {});\n        }\n    }\n    /**\n     * Returns a truthy value if the Store is currently loading.\n     *\n     * A load operation is initiated by a load call, but the network request is not sent until\n     * after a delay until the next event loop because of allowing all operations which may\n     * request a load to coalesce into one call.\n     *\n     * If the loading request is in this waiting state, the value will be `1`,\n     *\n     * If the network request is in flight, the value will be `2`\n     * @property {Boolean|Number}\n     * @readonly\n     * @category CRUD\n     */\n    get isLoading() {\n        return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;\n    }\n    /**\n     * Returns true if the Store is currently committing\n     * @property {Boolean}\n     * @readonly\n     * @category CRUD\n     */\n    get isCommitting() {\n        return Boolean(this.commitPromise);\n    }\n    set pageParamName(pageParamName) {\n        if (this.tree) {\n            throw new Error('Paging cannot be supported for tree stores');\n        }\n        if (this.pageStartParamName) {\n            throw new Error('Configs pageStartParamName and pageParamName are mutually exclusive');\n        }\n        this._pageParamName = pageParamName;\n    }\n    get pageParamName() {\n        return this._pageParamName;\n    }\n    set pageStartParamName(pageStartParamName) {\n        if (this.tree) {\n            throw new Error('Paging cannot be supported for tree stores');\n        }\n        if (this.pageParamName) {\n            throw new Error('Configs pageParamName and pageStartParamName are mutually exclusive');\n        }\n        this._pageStartParamName = pageStartParamName;\n    }\n    get pageStartParamName() {\n        return this._pageStartParamName;\n    }\n    /**\n     * Yields true if this Store is loaded page by page. This yields `true` if either of the\n     * {@link #config-pageParamName} of {@link #config-pageStartParamName} configs are set.\n     * @property {Boolean}\n     * @readonly\n     * @category Paging\n     */\n    get isPaged() {\n        return this.pageParamName || this.pageStartParamName;\n    }\n    /**\n     * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value\n     * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is\n     * the number of records in the store's underlying storage collection.\n     * @property {Number}\n     * @readonly\n     * @category Paging\n     */\n    get allCount() {\n        return ('remoteTotal' in this) ? this.remoteTotal : super.allCount;\n    }\n    /**\n     * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated\n     * from the {@link #config-responseTotalProperty}\n     * returned in the last page data block loaded.\n     * @property {Number}\n     * @readonly\n     * @category Paging\n     */\n    get lastPage() {\n        if (this.isPaged) {\n            return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);\n        }\n    }\n    buildQueryString(url, ...paramObjects) {\n        const\n            hasParamsInUrl = url.includes('?'),\n            queryString    = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join('&');\n        return queryString ? (hasParamsInUrl ? '&' : '?') + queryString : '';\n    }\n    /**\n     * Internal sort method.\n     * Should not be used in application code directly.\n     * @param silent\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @internal\n     */\n    async performSort(silent) {\n        const me = this;\n        if (me.remoteSort && !me.isRemoteDataLoading) {\n            me.isRemoteDataLoading = true;\n            const result           = await me.internalLoad({}, '', event => {\n                me.data = event.data;\n                me.afterPerformSort(silent);\n            });\n            me.isRemoteDataLoading = false;\n            return result;\n        }\n        else {\n            super.performSort(silent);\n        }\n    }\n    /**\n     * Internal filter method.\n     * Should not be used in application code directly.\n     * @param silent\n     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`\n     * which is resolved after data is loaded from remote server, otherwise it returns `null`\n     * @async\n     * @internal\n     */\n    async performFilter(silent) {\n        const\n            me = this;\n        // For remote filtering, the dataset cannot be preserved. The size may be completely different.\n        // This is a reload operation.\n        if (me.remoteFilter) {\n            me.loadingPromise?.abort();\n            // Flag store data loading state to not get into loop when data is sorted internally after request\n            me.isRemoteDataLoading = true;\n            const\n                oldCount    = me.count,\n                { filters } = me;\n            // load should default to page 1\n            me.currentPage         = 1;\n            const result           = await me.internalLoad({}, '', event => {\n                me.data = event.data;\n                event   = silent\n                    ? null\n                    : {\n                        action  : 'filter',\n                        filters,\n                        oldCount,\n                        records : me.storage.values\n                    };\n                me.afterPerformFilter(event);\n                me.trigger('refresh', event);\n            });\n            me.isRemoteDataLoading = false;\n            return result;\n        }\n        else {\n            super.performFilter(silent);\n        }\n    }\n    /**\n     * A provided function which creates an array of values for the {@link #config-filterParamName} to pass\n     * any filters to the server upon load.\n     *\n     * By default, this creates a JSON string containing the following properties:\n     *\n     * ```javascript\n     *    [{\n     *        field         : <theFieldName>\n     *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`\n     *        value         : The value to compare\n     *        caseSensitive : true for case sensitive comparisons\n     *    }]\n     * ```\n     * @param {Core.util.CollectionFilter[]} filters The filters to encode.\n     */\n    encodeFilterParams(filters) {\n        const\n            result = [];\n        for (const { property, operator, value, caseSensitive } of filters) {\n            result.push({\n                field : property,\n                operator,\n                value,\n                caseSensitive\n            });\n        }\n        return JSON.stringify(result, function(key, value) {\n            return key === ''\n                ? value\n                : this[key] instanceof Date ? dateToString(this[key]) : value;\n        });\n    }\n    /**\n     * A provided function which creates an array of values for the {#config-sortParamName} to pass\n     * any sorters to the server upon load.\n     *\n     * By default, this creates a JSON string containing the following properties:\n     *\n     * ```javascript\n     *    [{\n     *        field     : <theFieldName>\n     *        ascending : true/false\n     *    }]\n     * ```\n     *\n     * @param {Sorter[]} sorters The sorters to encode.\n     */\n    encodeSorterParams(sorters) {\n        return JSON.stringify(sorters.filter(sorter => !sorter.sortFn).map(sorter => sorter));\n    }\n    buildReadUrl() {\n        const { readUrl } = this;\n        if (this.restfulFilter && this.filters.count) {\n            const url = readUrl.endsWith('/') ? readUrl : (readUrl + '/');\n            return url + this.filters.first.value;\n        }\n        return readUrl;\n    }\n    /**\n     * Internal data loading method.\n     * @returns {Promise}\n     * @internal\n     */\n    internalLoad(params, eventName, successFn, delay = 0) {\n        // Accumulate all configured parameters\n        params = ObjectHelper.assign({}, this.params, params);\n        const\n            me    = this,\n            url   = me.buildReadUrl(),\n            event = { action : 'read' + eventName, params, url };\n        if (!url) {\n            throw new Error('No load url specified');\n        }\n        if (me.trigger('beforeLoad' + eventName, event) === false) {\n            throw false;  // eslint-disable-line no-throw-literal\n        }\n        me.loadArgs = [url, event, params, eventName, successFn];\n        if (delay === false) {\n            return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));\n        }\n        return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {\n            me.setTimeout({\n                delay,\n                fn                : 'sendLoadRequest',\n                args              : [resolve, reject],\n                cancelOutstanding : true\n            });\n        }));\n    }\n    // Send the request for the internalLoad.\n    // This is called on a timeout 1ms after the internalLoad call.\n    async sendLoadRequest(resolve, reject) {\n        const\n            me = this,\n            [\n                url,\n                event,\n                params,\n                eventName,\n                successFn\n            ]  = me.loadArgs;\n        // As soon as it kicks off, new load requests can be made which will result in another load\n        me.loadTriggerPromise = null;\n        if (url) {\n            me._isLoading = true;\n            // This may look redundant, but it allows for two levels of event listening.\n            // Granular, where the observer observes only the events of interest, and\n            // catch-all, where the observer is interested in all requests.\n            me.trigger(`load${eventName}Start`, event);\n            me.trigger('beforeRequest', event);\n            // Add filter information to the request parameters\n            if (me.filterParamName && me.isFiltered) {\n                params[me.filterParamName] = me.encodeFilterParams(me.filters.values);\n            }\n            // Add sorter information to the request parameters.\n            // isSorted includes grouping in its evaluation.\n            if (me.remoteSort && me.isSorted) {\n                params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);\n            }\n            // Ensure our next page is passed to the server in the params if not already set.\n            // Ensure our page size is always passed.\n            if (me.isPaged) {\n                if (!((me.pageParamName in params) || (me.pageStartParamName in params))) {\n                    const\n                        page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);\n                    if (me.pageParamName) {\n                        params[me.pageParamName] = page;\n                    }\n                    else {\n                        params[me.pageStartParamName] = (page - 1) * me.pageSize;\n                    }\n                }\n                params[me.pageSizeParamName] = me.pageSize;\n            }\n            const options = { headers : me.headers, parseJson : true };\n            if (me.useRestfulMethods) {\n                options.method = me.httpMethods.read;\n                // user might define body in case of using custom restful method\n                if (event.body) {\n                    options.body = JSON.stringify(event.body);\n                }\n            }\n            try {\n                const\n                    promise     = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)),\n                    response    = await promise,\n                    data        = response.parsedJson,\n                    isArray     = Array.isArray(data),\n                    success     = isArray || (data && (ObjectHelper.getPath(data, me.responseSuccessProperty) !== false)),\n                    remoteTotal = isArray ? null : ObjectHelper.getPath(data, me.responseTotalProperty);\n                if (me.isDestroyed) {\n                    return;\n                }\n                me.loadingPromise = null;\n                me._isLoading  = false;\n                event.response = response;\n                event.json     = data;\n                if (success) {\n                    if (remoteTotal != null) {\n                        me.remoteTotal = parseInt(remoteTotal, 10);\n                    }\n                    // If we are issuing paged requests, work out what page we are on based\n                    // on the requested page and the size of the dataset declared.\n                    if (me.isPaged) {\n                        if (me.remoteTotal >= 0) {\n                            const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;\n                            me.currentPage      = Math.min(requestedPage, me.lastPage);\n                        }\n                        else {\n                            throw new Error('A paged store must receive its responseTotalProperty in each data packet');\n                        }\n                    }\n                    event.data = isArray ? data : ObjectHelper.getPath(data, me.responseDataProperty);\n                    await successFn(event);\n                    !me.isDestroyed && me.trigger('load' + eventName, event);\n                    resolve(event);\n                }\n                else {\n                    Object.assign(event, {\n                        exception     : true,\n                        exceptionType : 'server',\n                        error         : data?.error\n                    });\n                    !me.isDestroyed && me.trigger('exception', event);\n                    reject(event);\n                }\n                // finally\n                !me.isDestroyed && me.trigger('afterRequest', event);\n            }\n            catch (responseOrError) {\n                me._isLoading = false;\n                event.exception = true;\n                if (responseOrError instanceof Response) {\n                    event.exceptionType = responseOrError.ok ? 'server' : 'network';\n                    event.response      = responseOrError;\n                    event.error         = responseOrError.error;\n                }\n                else {\n                    event.exceptionType = 'server';\n                    event.error         = responseOrError;\n                }\n                !me.isDestroyed && me.trigger('exception', event);\n                reject(event);\n                // finally\n                !me.isDestroyed && me.trigger('afterRequest', event);\n            }\n        }\n    }\n    /**\n     * Load data from the {@link #config-readUrl}.\n     * @param {Object} [params] A hash of parameters to append to querystring (will also append Store#params)\n     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is\n     * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.\n     * The resolved function is passed the event object passed to any event handlers.\n     * The rejected function is passed the {@link #event-exception} event if an exception occurred,\n     * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.\n     * @fires beforeLoad\n     * @fires loadStart\n     * @fires beforeRequest\n     * @fires load\n     * @fires exception\n     * @fires afterRequest\n     * @category CRUD\n     */\n    async load(params) {\n        const\n            me = this;\n        if (me.isPaged) {\n            return me.loadPage(me.currentPage || 1, params);\n        }\n        else {\n            return me.internalLoad(params, '', (event) => {\n                // The set Data setter will trigger the refresh event with { action: 'dataset' }\n                me.data = event.data;\n            });\n        }\n    }\n    /**\n     * Loads children into specified parent record. Parent records id is sent as a param (param name configured with\n     * {@link #config-parentIdParamName}.\n     * @param {Core.data.Model} parentRecord Parent record\n     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is\n     * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.\n     * The resolved function is passed the event object passed to any event handlers.\n     * The rejected function is passed the {@link #event-exception} event if an exception occurred,\n     * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.\n     * @fires beforeLoadChildren\n     * @fires loadChildrenStart\n     * @fires beforeRequest\n     * @fires loadChildren\n     * @fires exception\n     * @fires afterRequest\n     * @category CRUD\n     */\n    async loadChildren(parentRecord) {\n        // Immediate call to sendLoadRequest because we can make multiple, concurrent requests\n        // to load many tree nodes at once, so pass delay parameter as false.\n        return this.readUrl ? this.internalLoad({ [this.parentIdParamName] : parentRecord.id }, 'Children', event => {\n            event.parentRecord = parentRecord;\n            if (parentRecord.children.length) {\n                parentRecord.clearChildren(true);\n            }\n            // Append received children\n            parentRecord.data[parentRecord.constructor.childrenField] = event.data;\n            parentRecord.processChildren(parentRecord.stores);\n        }, false) : this.immediatePromise;\n    }\n    /**\n     * Loads a page of data from the {@link #config-readUrl}.\n     * @param {Number} page The *one based* page number to load.\n     * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)\n     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is\n     * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.\n     * The resolved function is passed the event object passed to any event handlers.\n     * The rejected function is passed the {@link #event-exception} event if an exception occurred,\n     * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.\n     * @fires beforeLoadPage\n     * @fires loadPageStart\n     * @fires beforeRequest\n     * @fires loadPage\n     * @fires exception\n     * @fires afterRequest\n     * @category CRUD\n     */\n    async loadPage(page, params) {\n        if (this.allCount) {\n            page = Math.min(page, this.lastPage);\n        }\n        const\n            me        = this,\n            pageParam = me.pageParamName\n                ? {\n                    [me.pageParamName] : page\n                }\n                : {\n                    [me.pageStartParamName] : (page - 1) * me.pageSize\n                };\n        pageParam[me.pageSizeParamName] = me.pageSize;\n        return me.internalLoad(ObjectHelper.assign(pageParam, params), 'Page', (event) => {\n            // We go directly to loadPage because paging a tree store is unsupportable.\n            // loadPage will trigger the refresh event with { action: 'pageLoad' }\n            me.loadData(event.data, 'pageLoad');\n        });\n    }\n    /**\n     * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}\n     * then this will load the next page of data.\n     * @fires beforeLoadPage\n     * @fires loadPageStart\n     * @fires beforeRequest\n     * @fires loadPage\n     * @fires exception\n     * @fires afterRequest\n     * @category CRUD\n     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.\n     */\n    async nextPage(params) {\n        const me = this;\n        return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise;\n    }\n    /**\n     * If this store {@link #property-isPaged is paged}, and is not already at the first page\n     * then this will load the previous page of data.\n     * @fires beforeLoadPage\n     * @fires loadPageStart\n     * @fires beforeRequest\n     * @fires loadPage\n     * @fires exception\n     * @fires afterRequest\n     * @category CRUD\n     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.\n     */\n    async previousPage(params) {\n        return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise;\n    }\n    /**\n     * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},\n     * {@link #config-updateUrl} and {@link #config-deleteUrl})\n     * @fires beforeCommit\n     * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete)\n     * successfully resolve. Both the resolve and reject functions are passed a `commitState` object which is stored the\n     * {@link #event-afterRequest} event for each request. Each event contains the `exception`, `request` and `response`\n     * properties eg:\n     *\n     * ```javascript\n     * {\n     *      // If *all* commits succeeded\n     *      success: true,\n     *      changes: {\n     *          added: [records...],\n     *          modified: [records...],\n     *          removed: [records...],\n     *      },\n     *      added: {\n     *          source: theStore,\n     *\n     *          // Only if the add request triggered an exception\n     *          exception: true,\n     *\n     *          // Only if the add request triggered an exception\n     *          exceptionType: 'server', // Or 'network'\n     *\n     *          response: Response,\n     *          json: parsedResponseObject\n     *      },\n     *      // Same format as added\n     *      modified: {},\n     *      removed: {}\n     * }\n     * ```\n     *\n     * If there were no pending changes, the resolve and reject functions are passed no parameters.\n     *\n     * Returns `false` if a commit operation is already in progress.\n     * The resolved function is passed the event object passed to any event handlers.\n     * The rejected function is passed the {@link #event-exception} event if an exception occurred,\n     * @category CRUD\n     */\n    async commit() {\n        const\n            me          = this,\n            { changes } = me,\n            allPromises = [];\n        // not allowing additional commits while in progress\n        if (me.commitPromise) {\n            return false;\n        }\n        // No outstanding changes, return a Promise that resolves immediately.\n        if (!changes) {\n            // Special handling of modified. If only non-persistable fields have been modified, it won't count among\n            // `changes`, but still needs to be cleared\n            if (me.modified.count) {\n                me.modified.forEach(record => record.clearChanges(true, false));\n                me.modified.clear();\n            }\n            return immediatePromise;\n        }\n        if (me.trigger('beforeCommit', { changes }) !== false) {\n            // Flag all affected records as being committed\n            [...changes.added, ...changes.modified, ...changes.removed].forEach(record => record.meta.committing = true);\n            // Commit was not prevented in beforeCommit listener, so we begin the commit\n            me.trigger('commitStart', { changes });\n            const\n                commitState = {\n                    action    : 'commit',\n                    exception : false,\n                    changes\n                };\n            let p = me.commitRemoved(commitState);\n            if (p) {\n                allPromises.push(p);\n            }\n            p = me.commitAdded(commitState);\n            if (p) {\n                allPromises.push(p);\n            }\n            p = me.commitModified(commitState);\n            if (p) {\n                allPromises.push(p);\n            }\n            // If there were no urls configured, behave as a local store\n            if (!allPromises.length) {\n                me.modified.forEach(r => r.clearChanges(true, false));\n                me.modified.clear();\n                me.added.forEach(r => r.clearChanges(true, false));\n                me.added.clear();\n                me.removed.clear();\n                me.trigger('commit', { changes });\n                return immediatePromise;\n            }\n            // The Promises from the commit methods all resolve whether the request\n            // succeeded or not. They each contribute their afterrequest event to the\n            // commitState which can be used to detect overall success or failure\n            // and granular inspection of which operations succeeded or failed.\n            // If there's only one operation, wait for it.\n            // If there's more than one operation, we have to wait for allPromises to resolve.\n            p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);\n            return me.commitPromise = new Promise((resolve, reject) => {\n                p.then(() => {\n                    me.commitPromise = null;\n                    if (commitState.exception) {\n                        me.trigger('exception', commitState);\n                        reject(commitState);\n                    }\n                    else {\n                        me.trigger('commit', { changes });\n                        resolve(commitState);\n                    }\n                }).catch(() => {\n                    me.commitPromise = null;\n                    reject(commitState);\n                });\n            });\n        }\n    }\n    // Performs background autocommit with reject checking\n    doAutoCommit() {\n        if (this.suspendCount <= 0) {\n            this.commit().catch(commitState => {\n                const { response } = commitState;\n                // Skip throw if response is `ok` or `status` is 500 or 404 and request is successfully parsed\n                // These errors are notified by API events\n                if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {\n                    throw commitState;\n                }\n            });\n        }\n    }\n    /**\n     * Commits added records by posting to {@link #config-createUrl}.\n     * Server should return a JSON object with a 'success' property indicating whether the operation was successful.\n     * @param {Object} commitState An object into which is added a `delete` property being the\n     * {@link #event-afterRequest} event.\n     * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit\n     * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`\n     * parameter. If there are no added records, `null` is returned.\n     * The resolved function is passed the event object passed to any event handlers.\n     * @async\n     * @private\n     * @fires beforeRequest\n     * @fires commitAdded\n     * @fires refresh\n     * @fires exception\n     * @fires afterRequest\n     */\n    commitAdded(commitState) {\n        const\n            me    = this,\n            added = me.added,\n            event = { action : 'create', params : me.params };\n        return added.count && me.createUrl ? new Promise((resolve) => {\n            const toAdd        = added.values.map(r => r.persistableData);\n            commitState.create = event;\n            event.body = { data : toAdd };\n            me.trigger('beforeRequest', event);\n            let dataToSend = event.body;\n            if (me.sendAsFormData) {\n                const\n                    formData = new FormData();\n                formData.append('data', JSON.stringify(toAdd));\n                dataToSend = formData;\n            }\n            const\n                options = { headers : me.headers, parseJson : true },\n                url     = me.createUrl + me.buildQueryString(me.createUrl, me.params);\n            if (me.useRestfulMethods) {\n                options.method = me.httpMethods.create;\n            }\n            AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then(response => {\n                const\n                    data    = response.parsedJson,\n                    isArray = Array.isArray(data),\n                    success = isArray || (data && (data.success !== false));\n                commitState.response = response;\n                event.json           = data;\n                event.response       = response;\n                if (success) {\n                    // Copy updated fields and updated ID back into records.\n                    // This also calls clearChanges on each record.\n                    me.processReturnedData(added.values, isArray ? data : ObjectHelper.getPath(data, me.responseDataProperty));\n                    // Clear down added records cache\n                    added.clear();\n                    me.trigger('commitAdded');\n                    // We must signal a full refresh because any number of records could have received any number of field updates\n                    // back from the server, so a refresh is more efficient than picking through the received updates.\n                    me.trigger('refresh', event);\n                    resolve(commitState);\n                }\n                else {\n                    // Clear committing flag\n                    added.forEach(r => r.meta.committing = false);\n                    commitState.exception = event.exception = true;\n                    commitState.exceptionType = event.exceptionType = 'server';\n                    me.trigger('exception', event);\n                    resolve(commitState);\n                }\n                // finally\n                me.trigger('afterRequest', event);\n            }).catch(responseOrError => {\n                // Clear committing flag\n                added.forEach(r => r.meta.committing = false);\n                commitState.exception = event.exception = true;\n                if (responseOrError instanceof Response) {\n                    commitState.response = responseOrError;\n                    event.exceptionType  = responseOrError.ok ? 'server' : 'network';\n                    event.response       = responseOrError;\n                    event.error          = responseOrError.error;\n                }\n                else {\n                    event.exceptionType = 'server';\n                    event.error         = responseOrError;\n                }\n                me.trigger('exception', event);\n                resolve(commitState);\n                // finally\n                me.trigger('afterRequest', event);\n            });\n        }) : null;\n    }\n    /**\n     * Commits modified records by posting to {@link #config-updateUrl}.\n     * Server should return a JSON object with a 'success' property indicating whether the operation was successful.\n     * @param {Object} commitState An object into which is added a `delete` property being the\n     * {@link #event-afterRequest} event.\n     * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit\n     * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`\n     * parameter. If there are no added records, `null` is returned.\n     * The resolved function is passed the event object passed to any event handlers.\n     * @async\n     * @private\n     * @fires beforeRequest\n     * @fires commitModified\n     * @fires refresh\n     * @fires exception\n     * @fires afterRequest\n     */\n    commitModified(commitState) {\n        const\n            me           = this,\n            // Only include persistable changes\n            { modified } = me.changes,\n            event        = { action : 'update', params : me.params },\n            result       = modified.length && me.updateUrl ? new Promise(resolve => {\n                // Use the record's modificationData, not modifications.\n                // modifications returns a map using *field names*\n                // The server will expect a map using the original dataSource properties.\n                const\n                    modifications = modified.map(record => {\n                        if (me.writeAllFields) {\n                            return record.persistableData;\n                        }\n                        else {\n                            return record.modificationDataToWrite;\n                        }\n                    }).filter(el => !ObjectHelper.isEmpty(el));\n                // Check if modifications are empty and don't make request\n                if (modifications.length === 0) {\n                    me.modified.clear();\n                    modified.forEach(r => r.meta.committing = false);\n                    resolve();\n                    return;\n                }\n                commitState.update = event;\n                event.body = { data : modifications };\n                me.trigger('beforeRequest', event);\n                let dataToSend = event.body;\n                if (me.sendAsFormData) {\n                    const\n                        formData = new FormData();\n                    formData.append('data', JSON.stringify(modifications));\n                    dataToSend = formData;\n                }\n                const\n                    options = { headers : me.headers, parseJson : true };\n                if (me.useRestfulMethods) {\n                    options.method = me.httpMethods.update;\n                }\n                AjaxHelper.post(\n                    me.updateUrl + me.buildQueryString(me.updateUrl, me.params),\n                    dataToSend,\n                    ObjectHelper.assign(options, me.fetchOptions)\n                ).then(response => {\n                    const\n                        data    = response.parsedJson,\n                        isArray = Array.isArray(data),\n                        success = isArray || (data && (data.success !== false));\n                    commitState.response = response;\n                    event.json           = data;\n                    event.response       = response;\n                    if (success) {\n                        // Copy updated fields and updated ID back into records.\n                        // This also calls clearChanges on each record.\n                        me.processReturnedData(modified, isArray ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);\n                        // Clear down modified records cache\n                        me.modified.clear();\n                        me.trigger('commitModified');\n                        // We must signal a full refresh because any number of records could have received any number of\n                        // field updates back from the server, so a refresh is more efficient than picking through the\n                        // received updates.\n                        me.trigger('refresh', event);\n                        resolve(commitState);\n                    }\n                    else {\n                        // Clear committing flag\n                        modified.forEach(r => r.meta.committing = false);\n                        commitState.exception = event.exception = true;\n                        event.exceptionType   = 'server';\n                        me.trigger('exception', event);\n                        resolve(commitState);\n                    }\n                    // finally\n                    me.trigger('afterRequest', event);\n                }).catch(responseOrError => {\n                    // Clear committing flag\n                    modified.forEach(r => r.meta.committing = false);\n                    commitState.exception = event.exception = true;\n                    if (responseOrError instanceof Response) {\n                        commitState.response = responseOrError;\n                        event.exceptionType  = responseOrError.ok ? 'server' : 'network';\n                        event.response       = responseOrError;\n                        event.error          = responseOrError.error;\n                    }\n                    else {\n                        event.exceptionType = 'server';\n                        event.error         = responseOrError;\n                    }\n                    me.trigger('exception', event);\n                    resolve(commitState);\n                    // finally\n                    me.trigger('afterRequest', event);\n                });\n            }) : null;\n        // Also clear non-persistable changes\n        if (!modified.length && me.modified.count) {\n            me.modified.clear();\n        }\n        return result;\n    }\n    processReturnedData(localRecords, returnedData, isUpdating = false) {\n        const\n            me           = this,\n            Model        = me.modelClass,\n            idDataSource = Model.fieldMap.id.dataSource;\n        returnedData.forEach((recData, i) => {\n            const\n                record = localRecords[i];\n            // Must clear changed state before syncId goes through store.onModelChange\n            record.clearChanges(true, false);\n            // Using syncId to update record's id with no flagging the property as modified.\n            record.syncId(recData[idDataSource]);\n            // When updating, only want to apply the actual changes and not reapply defaults. When adding, also\n            // apply the defaults\n            Object.assign(localRecords[i].data, Model.processData(recData, isUpdating, me, record));\n        });\n    }\n    /**\n     * Commits removed records by posting to {@link #config-deleteUrl}.\n     * Server should return a JSON object with a 'success' property indicating whether the operation was successful.\n     * @param {Object} commitState An object into which is added a `delete` property being the\n     * {@link #event-afterRequest} event.\n     * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit\n     * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`\n     * parameter. If there are no added records, `null` is returned.\n     * The resolved function is passed the event object passed to any event handlers.\n     * @async\n     * @private\n     * @fires beforerequest\n     * @fires commitremoved\n     * @fires refresh\n     * @fires exception\n     * @fires afterrequest\n     */\n    commitRemoved(commitState) {\n        const\n            me      = this,\n            removed = me.removed,\n            event   = { action : 'delete', params : me.params };\n        return removed.count && me.deleteUrl ? new Promise((resolve) => {\n            commitState.delete = event;\n            event.body = { ids : removed.map(r => r.id) };\n            me.trigger('beforeRequest', event);\n            let dataToSend = event.body;\n            if (me.sendAsFormData) {\n                const\n                    formData = new FormData();\n                formData.append('id', JSON.stringify(dataToSend.ids));\n                dataToSend = formData;\n            }\n            const\n                options = { headers : me.headers, parseJson : true };\n            if (me.useRestfulMethods) {\n                options.method = me.httpMethods.delete;\n            }\n            AjaxHelper.post(\n                me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params),\n                dataToSend,\n                ObjectHelper.assign(options, me.fetchOptions)\n            ).then(response => {\n                const\n                    data    = response.parsedJson,\n                    isArray = Array.isArray(data),\n                    success = isArray || (data && (data.success !== false));\n                commitState.response = response;\n                event.json           = data;\n                event.response       = response;\n                if (success) {\n                    removed.forEach(record => record.meta.committing = false); // In case used by other store etc.\n                    removed.clear();\n                    me.trigger('commitRemoved');\n                    me.trigger('refresh', event);\n                    resolve(commitState);\n                }\n                else {\n                    // Clear committing flag\n                    removed.forEach(r => r.meta.committing = false);\n                    commitState.exception = event.exception = true;\n                    event.exceptionType = 'server';\n                    me.trigger('exception', event);\n                    resolve(commitState);\n                }\n                // finally\n                me.trigger('afterRequest', event);\n            }).catch(responseOrError => {\n                // Clear committing flag\n                removed.forEach(r => r.meta.committing = false);\n                commitState.exception = event.exception = true;\n                if (responseOrError instanceof Response) {\n                    commitState.response = responseOrError;\n                    event.exceptionType  = responseOrError.ok ? 'server' : 'network';\n                    event.response       = responseOrError;\n                    event.error          = responseOrError.error;\n                }\n                else {\n                    event.exceptionType = 'server';\n                    event.error         = responseOrError;\n                }\n                me.trigger('exception', event);\n                resolve(commitState);\n                // finally\n                me.trigger('afterRequest', event);\n            });\n        }) : null;\n    }\n    get remoteFilter() {\n        return Boolean(this.filterParamName || this.restfulFilter);\n    }\n    get remoteSort() {\n        return Boolean(this.sortParamName);\n    }\n}\nAjaxStore._$name = 'AjaxStore';", "/**\n * @module Core/data/DomDataStore\n */\n/**\n * Stores data on a dom element (by setting element._domData).\n * Instead of using HTML5:s element.dataset, which turned out to be slow.\n * @internal\n */\nexport default class DomDataStore {\n    /**\n     * Get data that is connected to specified element.\n     * @param {HTMLElement} element DOM element\n     * @param {String} [key] The name of the property in the element data to return\n     * @returns {Object} Data\n     */\n    static get(element, key) {\n        const result = (element._domData || (element._domData = {}));\n        return (key != null) ? result[key] :  result;\n    }\n    /**\n     * Remove data connected to specified element.\n     * @param {HTMLElement} element DOM element\n     * @param {String} key The name of the property in the element data to remove.\n     */\n    static remove(element, key) {\n        const\n            { _domData } = element,\n            was = _domData?.[key];\n        delete _domData?.[key];\n        return was;\n    }\n    /**\n     * Set data connected to specified element (completely replacing any existing).\n     * To update data, use DomDataStore#assign instead.\n     * @param {HTMLElement} element DOM element\n     * @param {Object|String} data Data object to set, or property name to set\n     * @param {*} [value] If the previous parameter was a property name, this is the value to set.\n     */\n    static set(element, data, value) {\n        if (arguments.length === 3) {\n            (element._domData || (element._domData = {}))[data] = value;\n        }\n        else {\n            element._domData = data;\n        }\n    }\n    /**\n     * Updates data connected to specified element.\n     * @param {HTMLElement} element DOM element\n     * @param {Object} data Data to assign\n     */\n    static assign(element, data) {\n        Object.assign((element._domData || (element._domData = {})), data);\n    }\n}\nDomDataStore._$name = 'DomDataStore';", "/**\n * @module SchedulerPro/model/changelog/ChangeLogEntity\n */\n/**\n * An immutable, serializable object that describes an entity instance (for example, a single task).\n * ChangeLogEntity instances appear in change log entries to indicate which entity was affected by\n * a {@link SchedulerPro/model/changelog/ChangeLogAction}.\n */\nexport default class ChangeLogEntity {\n    static $name = 'ChangeLogEntity';\n    constructor({ model, type }) {\n        Object.assign(this, {\n            /**\n             * @member {String} id The unique id of the entity instance, e.g. 'TaskModel-1'.\n             * @readonly\n             * @category Common\n             */\n            id : model.id ?? model.$entityName,\n            /**\n             * @member {String} type The name of the Model type of the entity, e.g. 'TaskModel'.\n             * @readonly\n             * @category Common\n             */\n            type : type?.$$name ?? model.constructor.name,\n            /**\n             * @member {String} name A user-friendly name for the entity instance, e.g. 'My important task'.\n             * @readonly\n             * @category Common\n             */\n            name : model.name ?? model.$entityName\n        });\n        if (new.target === ChangeLogEntity) {\n            Object.freeze(this);\n        }\n    }\n}\nChangeLogEntity._$name = 'ChangeLogEntity';", "import Model from '../../Core/data/Model.js';\n/**\n * @module Grid/data/GridRowModel\n */\n/**\n * Model extended with some fields related to grid rendering. Used as default model type in the grids store if nothing\n * else is specified.\n *\n * Using this model is optional. If you use a custom model instead and need the functionality of any of the fields\n * below, you just have to remember to add fields with the same name to your model.\n *\n * @extends Core/data/Model\n */\nexport default class GridRowModel extends Model {\n    static get fields() {\n        return [\n            /**\n             * Icon for row (used automatically in tree, feel free to use it in renderer in other cases)\n             * @field {String} iconCls\n             * @category Styling\n             */\n            {\n                name     : 'iconCls',\n                internal : true\n            },\n            /**\n             * CSS class (or several classes divided by space) to append to row elements\n             * @field {String} cls\n             * @category Styling\n             */\n            {\n                name     : 'cls',\n                internal : true\n            },\n            /**\n             * Used by the default implementation of {@link Grid.view.GridBase#config-getRowHeight} to determine row\n             * height. Set it to use another height than the default for a the records row.\n             * @field {Number} rowHeight\n             * @category Styling\n             */\n            {\n                name     : 'rowHeight',\n                internal : true\n            },\n            /**\n             * A link to use for this record when rendered into a {@link Grid.column.TreeColumn}.\n             * @field {String} href\n             * @category Tree\n             */\n            {\n                name     : 'href',\n                internal : true\n            },\n            /**\n             * The target to use if this tree node provides a value for the {@link #field-href} field.\n             * @field {'_self'|'_blank'|'_parent'|'_top'|null} target\n             * @category Tree\n             */\n            {\n                name     : 'target',\n                internal : true\n            }\n        ];\n    }\n}\nGridRowModel.exposeProperties();\nGridRowModel._$name = 'GridRowModel';", "/**\n * @module Scheduler/crud/mixin/AbstractCrudManagerValidation\n */\n/**\n * Mixin proving responses validation API to Crud Manager.\n * @mixin\n */\nexport default Target => class AbstractCrudManagerValidation extends Target {\n    static get $name() {\n        return 'AbstractCrudManagerValidation';\n    }\n    static get configurable() {\n        return {\n            /**\n             * This config validates the response structure for requests made by the Crud Manager.\n             * When `true`, the Crud Manager checks every parsed response structure for errors\n             * and if the response format is invalid, a warning is logged to the browser console.\n             *\n             * The config is intended to help developers implementing backend integration.\n             *\n             * @config {Boolean}\n             * @default\n             * @category CRUD\n             */\n            validateResponse : true,\n            /**\n             * When `true` treats parsed responses without `success` property as successful.\n             * In this mode a parsed response is treated as invalid if it has explicitly set `success : false`.\n             * @config {Boolean}\n             * @default\n             * @category CRUD\n             */\n            skipSuccessProperty : true,\n            crudLoadValidationWarningPrefix : 'CrudManager load response error(s):',\n            crudSyncValidationWarningPrefix : 'CrudManager sync response error(s):',\n            supportShortSyncResponseNote : 'Note: Please consider enabling \"supportShortSyncResponse\" option to allow less detailed sync responses (https://bryntum.com/products/scheduler/docs/api/Scheduler/crud/AbstractCrudManagerMixin#config-supportShortSyncResponse)',\n            disableValidationNote : 'Note: To disable this validation please set the \"validateResponse\" config to false'\n        };\n    }\n    get crudLoadValidationMandatoryStores() {\n        return [];\n    }\n    getStoreLoadResponseWarnings(storeInfo, responded, expectedResponse) {\n        const\n            messages        = [],\n            { storeId }     = storeInfo,\n            mandatoryStores = this.crudLoadValidationMandatoryStores,\n            result          = { [storeId] : {} };\n        // if the store section is responded\n        if (responded) {\n            if (!responded.rows) {\n                messages.push(`- \"${storeId}\" store section should have a \"rows\" property with an array of the store records.`);\n                result[storeId].rows = ['...'];\n            }\n        }\n        // if the store is mandatory\n        else if (mandatoryStores?.includes(storeId)) {\n            messages.push(`- No \"${storeId}\" store section found. It should contain the store data.`);\n            result[storeId].rows = ['...'];\n        }\n        // extend expected response w/ this store part\n        if (messages.length) {\n            Object.assign(expectedResponse, result);\n        }\n        return messages;\n    }\n    getLoadResponseWarnings(response) {\n        const\n            messages         = [],\n            expectedResponse = {};\n        if (!this.skipSuccessProperty) {\n            expectedResponse.success = true;\n        }\n        // iterate stores to check properties validity\n        this.forEachCrudStore((store, storeId, storeInfo) => {\n            messages.push(...this.getStoreLoadResponseWarnings(storeInfo, response?.[storeId], expectedResponse));\n        });\n        if (messages.length) {\n            messages.push('Please adjust your response to look like this:\\n' +\n                JSON.stringify(expectedResponse, null, 4).replace(/\"\\.\\.\\.\"/g, '...'));\n            messages.push(this.disableValidationNote);\n        }\n        return messages;\n    }\n    validateLoadResponse(response) {\n        const messages = this.getLoadResponseWarnings(response);\n        if (messages.length) {\n            console.warn(this.crudLoadValidationWarningPrefix + '\\n' + messages.join('\\n'));\n        }\n    }\n    getStoreSyncResponseWarnings(storeInfo, requested, responded, expectedResponse) {\n        const\n            messages         = [],\n            missingRows      = [],\n            missingRemoved   = [],\n            { storeId }      = storeInfo,\n            result           = { [storeId] : {} },\n            phantomIdField   = storeInfo.phantomIdField || this.phantomIdField,\n            { modelClass }   = storeInfo.store,\n            { idField }      = modelClass,\n            respondedRows    = responded?.rows || [],\n            respondedRemoved = responded?.removed || [];\n        let showSupportShortSyncResponseNote = false;\n        // if added records were passed in the request they should be mentioned in the response\n        if (requested?.added) {\n            missingRows.push(\n                ...requested.added.filter(record => {\n                    return !respondedRows.find(row => row[phantomIdField] == record[phantomIdField]) &&\n                        !respondedRemoved.find(row => row[phantomIdField] == record[phantomIdField] || row[idField] == record[phantomIdField]);\n                }).map(record => ({ [phantomIdField] : record[phantomIdField], [idField] : '...' }))\n            );\n            if (missingRows.length) {\n                const missingIds = missingRows.map(row => '#' + row[phantomIdField]).join(', ');\n                messages.push(`- \"${storeId}\" store \"rows\" section should mention added record(s) ${missingIds} sent in the request. ` +\n                    'It should contain the added records identifiers (both phantom and \"real\" ones assigned by the backend).');\n            }\n        }\n        // if short responses are enabled\n        if (this.supportShortSyncResponse) {\n            // if the data is not object, will return error\n            if (!missingRows.length && responded) {\n                if (typeof responded !== 'object' || Array.isArray(responded)) {\n                    messages.push(`- \"${storeId}\" store section should be an Object.`);\n                    result[storeId]['...'] = '...';\n                }\n                // for request to edit records, if rows is present, it must be an array\n                if (responded.rows && !Array.isArray(responded.rows)) {\n                    messages.push(`- \"${storeId}\" store \"rows\" section should be an array`);\n                    missingRows.push('...');\n                }\n                // removed if presented must be an array\n                if (responded.removed && !Array.isArray(responded.removed)) {\n                    messages.push(`- \"${storeId}\" store \"removed\" section should be an array:`);\n                    missingRemoved.push('...');\n                }\n            }\n        }\n        // if short responses are disabled\n        else {\n            // if updated records were passed in the request they should be mentioned in the response\n            if (requested?.updated) {\n                const missingUpdatedRows = requested.updated.filter(record => !respondedRows.find(row => row[idField] == record[idField]))\n                    .map(record => ({ [idField] : record[idField] }));\n                missingRows.push(...missingUpdatedRows);\n                if (missingUpdatedRows.length) {\n                    const missingIds = missingUpdatedRows.map(row => '#' + row[idField]).join(', ');\n                    messages.push(`- \"${storeId}\" store \"rows\" section should mention updated record(s) ${missingIds} sent in the request. ` +\n                        `It should contain the updated record identifiers.`);\n                    showSupportShortSyncResponseNote = true;\n                }\n            }\n            if (missingRows.length) {\n                missingRows.push('...');\n            }\n            // if removed records were passed in the request they should be mentioned in the response\n            if (requested?.removed) {\n                missingRemoved.push(\n                    ...requested.removed.filter(record => !respondedRows.find(row => row[idField] == record[idField]))\n                        .map(record => ({ [idField] : record[idField] }))\n                );\n                if (missingRemoved.length) {\n                    const missingIds = missingRemoved.map(row => '#' + row[idField]).join(', ');\n                    messages.push(`- \"${storeId}\" store \"removed\" section should mention removed record(s) ${missingIds} sent in the request. ` +\n                        `It should contain the removed record identifiers.`);\n                    result[storeId].removed = missingRemoved;\n                    missingRemoved.push('...');\n                    showSupportShortSyncResponseNote = true;\n                }\n            }\n        }\n        if (missingRows.length) {\n            result[storeId].rows = missingRows;\n        }\n        // get rid of store section if no rows/removed there\n        if (!messages.length) {\n            delete result[storeId];\n        }\n        // extend expected response w/ this store part\n        Object.assign(expectedResponse, result);\n        return { messages, showSupportShortSyncResponseNote };\n    }\n    getSyncResponseWarnings(response, requestDesc) {\n        const\n            messages         = [],\n            expectedResponse = {},\n            request          = requestDesc.pack;\n        if (!this.skipSuccessProperty) {\n            expectedResponse.success = true;\n        }\n        let showSupportShortSyncResponseNote = false;\n        // iterate stores to check properties validity\n        this.forEachCrudStore((store, storeId, storeInfo) => {\n            const warnings = this.getStoreSyncResponseWarnings(storeInfo, request?.[storeId], response[storeId], expectedResponse);\n            showSupportShortSyncResponseNote = showSupportShortSyncResponseNote || warnings.showSupportShortSyncResponseNote;\n            messages.push(...warnings.messages);\n        });\n        if (messages.length) {\n            messages.push('Please adjust your response to look like this:\\n' +\n                JSON.stringify(expectedResponse, null, 4).replace(/\"\\.\\.\\.\":\\s*\"\\.\\.\\.\"/g, ',,,').replace(/\"\\.\\.\\.\"/g, '...'));\n            if (showSupportShortSyncResponseNote) {\n                messages.push(this.supportShortSyncResponseNote);\n            }\n            messages.push(this.disableValidationNote);\n        }\n        return messages;\n    }\n    validateSyncResponse(response, request) {\n        const messages = this.getSyncResponseWarnings(response, request);\n        if (messages.length) {\n            console.warn(this.crudSyncValidationWarningPrefix + '\\n' + messages.join('\\n'));\n        }\n    }\n};\n", "import Store from '../../Core/data/Store.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport Base from '../../Core/Base.js';\nimport Events from '../../Core/mixin/Events.js';\nimport AbstractCrudManagerValidation from './mixin/AbstractCrudManagerValidation.js';\n/**\n * @module Scheduler/crud/AbstractCrudManagerMixin\n */\nexport class AbstractCrudManagerError extends Error {}\nexport class CrudManagerRequestError extends AbstractCrudManagerError {\n    constructor(cfg = {}) {\n        super(cfg.message || cfg.request && StringHelper.capitalize(cfg.request?.type) + ' failed' || 'Crud Manager request failed');\n        Object.assign(this, cfg);\n        this.action = this.request?.type;\n    }\n}\nconst\n    storeSortFn     = function(lhs, rhs, sortProperty) {\n        if (lhs.store) {\n            lhs = lhs.store;\n        }\n        if (rhs.store) {\n            rhs = rhs.store;\n        }\n        lhs = lhs[sortProperty] || 0;\n        rhs = rhs[sortProperty] || 0;\n        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);\n    },\n    // Sorter function to keep stores in loadPriority order\n    storeLoadSortFn = function(lhs, rhs) {\n        return storeSortFn(lhs, rhs, 'loadPriority');\n    },\n    // Sorter function to keep stores in syncPriority order\n    storeSyncSortFn = function(lhs, rhs) {\n        return storeSortFn(lhs, rhs, 'syncPriority');\n    };\n/**\n * An abstract mixin that supplies most of the CrudManager functionality.\n * It implements basic mechanisms of collecting stores to organize batch communication with a server.\n * It does not contain methods related to _data transfer_ nor _encoding_.\n * These methods are to be provided in sub-classes.\n * Out of the box there are mixins implementing {@link Scheduler/crud/transport/AjaxTransport support of AJAX for data transferring}\n * and {@link Scheduler/crud/encoder/JsonEncoder JSON for data encoding system}.\n * For example this is how we make a model that will implement CrudManager protocol and use AJAX/JSON to pass the data\n * to the server:\n *\n * ```javascript\n * class SystemSettings extends JsonEncode(AjaxTransport(AbstractCrudManagerMixin(Model))) {\n *     ...\n * }\n * ```\n *\n * ## Data transfer and encoding methods\n *\n * These are methods that must be provided by subclasses of this class:\n *\n * - {@link #function-sendRequest}\n * - {@link #function-cancelRequest}\n * - {@link #function-encode}\n * - {@link #function-decode}\n *\n * @mixin\n * @mixes Core/mixin/Delayable\n * @mixes Core/mixin/Events\n * @mixes Scheduler/crud/mixin/AbstractCrudManagerValidation\n * @abstract\n */\nexport default Target => {\n    // Trigger $meta calculation to get up-to-date is \"isXXX\" flags\n    // (kinky construction to avoid production minification faced in Angular https://github.com/bryntum/support/issues/2889)\n    Target.$$meta = Target.$meta;\n    const mixins = [];\n    // These two mixins are mixed in the Scheduling Engine code ..but in its own way\n    // so that Base.mixin() cannot understand that they are already there and applies them 2nd time\n    if (!Target.isEvents) {\n        mixins.push(Events);\n    }\n    if (!Target.isDelayable) {\n        mixins.push(Delayable);\n    }\n    mixins.push(AbstractCrudManagerValidation);\n    return class AbstractCrudManagerMixin extends (Target || Base).mixin(...mixins) {\n        /**\n         * Fires before server response gets applied to the stores. Return `false` to prevent data applying.\n         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.\n         * @event beforeResponseApply\n         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n         * @param {'sync'|'load'} requestType The request type (`sync` or `load`).\n         * @param {Object} response The decoded server response object.\n         */\n        /**\n         * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.\n         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.\n         * @event beforeLoadApply\n         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n         * @param {Object} response The decoded server response object.\n         * @param {Object} options Options provided to the {@link #function-load} method.\n         */\n        /**\n         * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.\n         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.\n         * @event beforeSyncApply\n         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n         * @param {Object} response The decoded server response object.\n         */\n        static get $name() {\n            return 'AbstractCrudManagerMixin';\n        }\n        //region Default config\n        static get defaultConfig() {\n            return {\n                /**\n                 * The server revision stamp.\n                 * The _revision stamp_ is a number which should be incremented after each server-side change.\n                 * This property reflects the current version of the data retrieved from the server and gets updated\n                 * after each {@link #function-load} and {@link #function-sync} call.\n                 * @property {Number}\n                 * @readonly\n                 * @category CRUD\n                 */\n                crudRevision : null,\n                /**\n                 * A list of registered stores whose server communication will be collected into a single batch.\n                 * Each store is represented by a _store descriptor_.\n                 * @member {CrudManagerStoreDescriptor[]} crudStores\n                 * @category CRUD\n                 */\n                /**\n                 * Sets the list of stores controlled by the CRUD manager.\n                 *\n                 * When adding a store to the CrudManager, make sure the server response format is correct for `load`\n                 * and `sync` requests. Learn more in the\n                 * [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.\n                 *\n                 * Store can be provided by itself, its storeId or as a _store descriptor_.\n                 * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}\n                 * @category CRUD\n                 */\n                crudStores : [],\n                /**\n                 * Name of a store property to retrieve store identifiers from. Make sure you have an instance of a\n                 * store to use it by id. Store identifier is used as a container name holding corresponding store data\n                 * while transferring them to/from the server. By default, `storeId` property is used. And in case a\n                 * container identifier has to differ this config can be used:\n                 *\n                 * ```javascript\n                 * class CatStore extends Store {\n                 *     static configurable = {\n                 *         // store id is \"meow\" but for sending/receiving store data\n                 *         // we want to have \"cats\" container in JSON, so we create a new property \"storeIdForCrud\"\n                 *         id             : 'meow',\n                 *         storeIdForCrud : 'cats'\n                 *     }\n                 * });\n                 *\n                 * // create an instance to use a store by id\n                 * new CatStore();\n                 *\n                 * class MyCrudManager extends CrudManager {\n                 *     ...\n                 *     crudStores           : ['meow'],\n                 *     // crud manager will get store identifier from \"storeIdForCrud\" property\n                 *     storeIdProperty  : 'storeIdForCrud'\n                 * });\n                 * ```\n                 * The `storeIdProperty` property can also be specified directly on a store:\n                 *\n                 * ```javascript\n                 * class CatStore extends Store {\n                 *     static configurable = {\n                 *         // storeId is \"meow\" but for sending/receiving store data\n                 *         // we want to have \"cats\" container in JSON\n                 *         id              : 'meow',\n                 *         // so we create a new property \"storeIdForCrud\"..\n                 *         storeIdForCrud  : 'cats',\n                 *         // and point CrudManager to use it as the store identifier source\n                 *         storeIdProperty  : 'storeIdForCrud'\n                 *     }\n                 * });\n                 *\n                 * class DogStore extends Store {\n                 *     static configurable = {\n                 *         // storeId is \"dogs\" and it will be used as a container name for the store data\n                 *         storeId : 'dogs',\n                 *         // id is set to get a store by identifier\n                 *         id      : 'dogs'\n                 *     }\n                 * });\n                 *\n                 * // create an instance to use a store by id\n                 * new CatStore();\n                 * new DogStore();\n                 *\n                 * class MyCrudManager extends CrudManager {\n                 *     ...\n                 *     crudStores : ['meow', 'dogs']\n                 * });\n                 * ```\n                 * @config {String}\n                 * @category CRUD\n                 */\n                storeIdProperty : 'storeId',\n                crudFilterParam : 'filter',\n                /**\n                 * Sends request to the server.\n                 * @function sendRequest\n                 * @param {Object} request The request to send. An object having following properties:\n                 * @param {'load'|'sync'} request.type Request type, can be either `load` or `sync`\n                 * @param {String} request.data {@link #function-encode Encoded} request.\n                 * @param {Function} request.success Callback to be started on successful request transferring\n                 * @param {Function} request.failure Callback to be started on request transfer failure\n                 * @param {Object} request.thisObj `this` reference for the above `success` and `failure` callbacks\n                 * @returns {Promise} The request promise.\n                 * @abstract\n                 */\n                /**\n                 * Cancels request to the server.\n                 * @function cancelRequest\n                 * @param {Promise} promise The request promise to cancel (a value returned by corresponding\n                 * {@link #function-sendRequest} call).\n                 * @param {Function} reject Reject handle of the corresponding promise\n                 * @abstract\n                 */\n                /**\n                 * Encodes request to the server.\n                 * @function encode\n                 * @param {Object} request The request to encode.\n                 * @returns {String} The encoded request.\n                 * @abstract\n                 */\n                /**\n                 * Decodes response from the server.\n                 * @function decode\n                 * @param {String} response The response to decode.\n                 * @returns {Object} The decoded response.\n                 * @abstract\n                 */\n                transport : {},\n                /**\n                 * When `true` forces the CRUD manager to process responses depending on their `type` attribute.\n                 * So `load` request may be responded with `sync` response for example.\n                 * Can be used for smart server logic allowing the server to decide when it's better to respond with a\n                 * complete data set (`load` response) or it's enough to return just a delta (`sync` response).\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                trackResponseType : false,\n                /**\n                 * When `true` the Crud Manager does not require all updated and removed records to be mentioned in the\n                 * *sync* response. In this case response should include only server side changes.\n                 *\n                 * **Please note that added records should still be mentioned in response to provide real identifier\n                 * instead of the phantom one.**\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                supportShortSyncResponse : true,\n                /**\n                 * Field name to be used to transfer a phantom record identifier.\n                 * @config {String}\n                 * @default\n                 * @category CRUD\n                 */\n                phantomIdField : '$PhantomId',\n                /**\n                 * Field name to be used to transfer a phantom parent record identifier.\n                 * @config {String}\n                 * @default\n                 * @category CRUD\n                 */\n                phantomParentIdField : '$PhantomParentId',\n                /**\n                 * Specify `true` to automatically call {@link #function-load} method on the next frame after creation.\n                 *\n                 * Called on the next frame to allow a Scheduler (or similar) linked to a standalone CrudManager to\n                 * register its stores before loading starts.\n                 *\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                autoLoad : false,\n                /**\n                 * The timeout in milliseconds to wait before persisting changes to the server.\n                 * Used when {@link #config-autoSync} is set to `true`.\n                 * @config {Number}\n                 * @default\n                 * @category CRUD\n                 */\n                autoSyncTimeout : 100,\n                /**\n                 * `true` to automatically persist store changes after edits are made in any of the stores monitored.\n                 * Please note that sync request will not be invoked immediately but only after\n                 * {@link #config-autoSyncTimeout} interval.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                autoSync : false,\n                /**\n                 * `True` to reset identifiers (defined by `idField` config) of phantom records before submitting them\n                 * to the server.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                resetIdsBeforeSync : true,\n                /**\n                 * @member {CrudManagerStoreDescriptor[]} syncApplySequence\n                 * An array of stores presenting an alternative sync responses apply order.\n                 * Each store is represented by a _store descriptor_.\n                 * @category CRUD\n                 */\n                /**\n                 * An array of store identifiers sets an alternative sync responses apply order.\n                 * By default, the order in which sync responses are applied to the stores is the same as they\n                 * registered in. But in case of some tricky dependencies between stores this order can be changed:\n                 *\n                 *```javascript\n                 * class MyCrudManager extends CrudManager {\n                 *     // register stores (will be loaded in this order: 'store1' then 'store2' and finally 'store3')\n                 *     crudStores : ['store1', 'store2', 'store3'],\n                 *     // but we apply changes from server to them in an opposite order\n                 *     syncApplySequence : ['store3', 'store2', 'store1']\n                 * });\n                 *```\n                 * @config {String[]}\n                 * @category CRUD\n                 */\n                syncApplySequence : [],\n                orderedCrudStores : [],\n                /**\n                 * `true` to write all fields from the record to the server.\n                 * If set to `false` it will only send the fields that were modified.\n                 * Note that any fields that have {@link Core/data/field/DataField#config-persist} set to `false` will\n                 * still be ignored and fields having {@link Core/data/field/DataField#config-alwaysWrite} set to `true`\n                 * will always be included.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                writeAllFields : false,\n                crudIgnoreUpdates : 0,\n                autoSyncSuspendCounter : 0,\n                // Flag that shows if crud manager performed successful load request\n                crudLoaded : false,\n                applyingLoadResponse : false,\n                applyingSyncResponse : false,\n                callOnFunctions : true\n            };\n        }\n        static configurable = {\n            /**\n             * Convenience shortcut to set only the url to load from, when you do not need to supply any other config\n             * options in the `load` section of the `transport` config.\n             *\n             * Using `loadUrl`:\n             * ```javascript\n             * {\n             *     loadUrl : 'read.php\n             * }\n             * ```\n             *\n             * Equals the following `transport` config:\n             * ```javascript\n             * {\n             *     transport : {\n             *         load : {\n             *             url : 'read.php'\n             *         }\n             *     }\n             * }\n             * ```\n             *\n             * When read at runtime, it will return the value from `transport.load.url`.\n             *\n             * @prp {String}\n             */\n            loadUrl : null,\n            /**\n             * Convenience shortcut to set only the url to sync to, when you do not need to supply any other config\n             * options in the `sync` section of the `transport` config.\n             *\n             * Using `loadUrl`:\n             * ```javascript\n             * {\n             *     syncUrl : 'sync.php\n             * }\n             * ```\n             *\n             * Equals the following `transport` config:\n             * ```javascript\n             * {\n             *     transport : {\n             *         load : {\n             *             url : 'sync.php'\n             *         }\n             *     }\n             * }\n             * ```\n             *\n             * When read at runtime, it will return the value from `transport.sync.url`.\n             *\n             * @prp {String}\n             */\n            syncUrl : null,\n            /**\n             * Specify as `true` to force sync requests to be sent when calling `sync()`, even if there are no local\n             * changes. Useful in a polling scenario, to keep client up to date with the backend.\n             * @prp {Boolean}\n             */\n            forceSync : null\n        };\n        static delayable = {\n            // Postponed to next frame, to allow Scheduler created after CrudManager to inject its stores\n            // (timeRanges, resourceTimeRanges)\n            doAutoLoad : 'raf'\n        };\n        get isCrudManager() {\n            return true;\n        }\n        //endregion\n        //region Init\n        construct(config = {}) {\n            this._requestId = 0;\n            this.activeRequests = {};\n            this.crudStoresIndex = {};\n            super.construct(config);\n        }\n        afterConstruct() {\n            super.afterConstruct();\n            if (this.autoLoad) {\n                this._autoLoadPromise = this.doAutoLoad();\n            }\n        }\n        //endregion\n        //region Configs\n        get loadUrl() {\n            return this.transport?.load?.url;\n        }\n        updateLoadUrl(url) {\n            ObjectHelper.setPath(this, 'transport.load.url', url);\n        }\n        get syncUrl() {\n            return this.transport?.sync?.url;\n        }\n        updateSyncUrl(url) {\n            ObjectHelper.setPath(this, 'transport.sync.url', url);\n        }\n        //endregion\n        //region Store descriptors & index\n        /**\n         * Returns a registered store descriptor.\n         * @param {String|Core.data.Store} storeId The store identifier or registered store instance.\n         * @returns {CrudManagerStoreDescriptor} The descriptor of the store.\n         * @category CRUD\n         */\n        getStoreDescriptor(storeId) {\n            if (!storeId) return null;\n            if (storeId instanceof Store) return this.crudStores.find(storeDesc => storeDesc.store === storeId);\n            if (typeof storeId === 'object') return this.crudStoresIndex[storeId.storeId];\n            return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));\n        }\n        fillStoreDescriptor(descriptor) {\n            const\n                { store } = descriptor,\n                {\n                    storeIdProperty = this.storeIdProperty,\n                    modelClass\n                }         = store;\n            if (!descriptor.storeId) {\n                descriptor.storeId = store[storeIdProperty] || store.id;\n            }\n            if (!descriptor.idField) {\n                descriptor.idField = modelClass.idField;\n            }\n            if (!descriptor.phantomIdField) {\n                descriptor.phantomIdField = modelClass.phantomIdField;\n            }\n            if (!descriptor.phantomParentIdField) {\n                descriptor.phantomParentIdField = modelClass.phantomParentIdField;\n            }\n            if (!('writeAllFields' in descriptor)) {\n                descriptor.writeAllFields = store.writeAllFields;\n            }\n            return descriptor;\n        }\n        updateCrudStoreIndex() {\n            const\n                crudStoresIndex = this.crudStoresIndex = {};\n            this.crudStores.forEach(store => store.storeId && (crudStoresIndex[store.storeId] = store));\n        }\n        //endregion\n        //region Store collection (add, remove, get & iterate)\n        /**\n         * Returns a registered store.\n         * @param {String} storeId Store identifier.\n         * @returns {Core.data.Store} Found store instance.\n         * @category CRUD\n         */\n        getCrudStore(storeId) {\n            const storeDescriptor = this.getStoreDescriptor(storeId);\n            return storeDescriptor?.store;\n        }\n        forEachCrudStore(fn, thisObj = this) {\n            if (!fn) {\n                throw new Error('Iterator function must be provided');\n            }\n            this.crudStores.every(store =>\n                fn.call(thisObj, store.store, store.storeId, store) !== false\n            );\n        }\n        set crudStores(stores) {\n            this._crudStores = [];\n            this.addCrudStore(stores);\n            // Ensure preconfigured stores stay stable at the start of the array when\n            // addPrioritizedStore attempts to insert in order. Only featured gantt/scheduler stores\n            // must participate in the ordering. If they were configured in, they must not move.\n            for (const store of this._crudStores) {\n                store.loadPriority = store.syncPriority = 0;\n            }\n        }\n        get crudStores() {\n            return this._crudStores;\n        }\n        get orderedCrudStores() {\n            return this._orderedCrudStores;\n        }\n        set orderedCrudStores(stores) {\n            return this._orderedCrudStores = stores;\n        }\n        set syncApplySequence(stores) {\n            this._syncApplySequence = [];\n            this.addStoreToApplySequence(stores);\n        }\n        get syncApplySequence() {\n            return this._syncApplySequence;\n        }\n        internalAddCrudStore(store) {\n            const\n                me = this;\n            let storeInfo;\n            // if store instance provided\n            if (store instanceof Store) {\n                storeInfo = { store };\n            }\n            else if (typeof store === 'object') {\n                if (!store.store) {\n                    // not a store descriptor, assume it is a store config\n                    store = {\n                        storeId : store.id,\n                        store   : new Store(store)\n                    };\n                }\n                storeInfo = store;\n            }\n            // if it's a store identifier\n            else {\n                storeInfo = { store : Store.getStore(store) };\n            }\n            me.fillStoreDescriptor(storeInfo);\n            // store instance\n            store = storeInfo.store;\n            // if the store has \"setCrudManager\" hook - use it\n            if (store.setCrudManager) {\n                store.setCrudManager(me);\n            }\n            // otherwise decorate the store w/ \"crudManager\" property\n            else {\n                store.crudManager = me;\n            }\n            // Stores have a defaultConfig for pageSize. CrudManager does not support that.\n            store.pageSize = null;\n            // Prevent AjaxStores from performing their own CRUD operations if CrudManager is configured with an URL\n            if (me.loadUrl || me.syncUrl) {\n                store.autoCommit = false;\n                store.autoLoad = false;\n                if (store.createUrl || store.updateUrl || store.deleteUrl || store.readUrl) {\n                    console.warn('You have configured an URL on a Store that is handled by a CrudManager that is also configured with an URL. The Store URL\\'s should be removed.');\n                }\n            }\n            // listen to store changes\n            me.bindCrudStoreListeners(store);\n            return storeInfo;\n        }\n        /**\n         * Adds a store to the collection.\n         *\n         *```javascript\n         * // append stores to the end of collection\n         * crudManager.addCrudStore([\n         *     store1,\n         *     // storeId\n         *     'bar',\n         *     // store descriptor\n         *     {\n         *         storeId : 'foo',\n         *         store   : store3\n         *     },\n         *     {\n         *         storeId         : 'bar',\n         *         store           : store4,\n         *         // to write all fields of modified records\n         *         writeAllFields  : true\n         *     }\n         * ]);\n         *```\n         *\n         * **Note:** Order in which stores are kept in the collection is very essential sometimes.\n         * Exactly in this order the loaded data will be put into each store.\n         *\n         * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`\n         * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.\n         *\n         * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store\n         * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.\n         * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position\n         * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.\n         * Otherwise, it will be just a position in stores collection.\n         *\n         * ```javascript\n         * // insert stores store4, store5 to the start of collection\n         * crudManager.addCrudStore([ store4, store5 ], 0);\n         * ```\n         *\n         * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position\n         * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of\n         * {@link #function-getStoreDescriptor} call).\n         *\n         * ```javascript\n         * // insert store6 just before a store having storeId equal to 'foo'\n         * crudManager.addCrudStore(store6, 0, 'foo');\n         *\n         * // insert store7 just after store3 store\n         * crudManager.addCrudStore(store7, 1, store3);\n         * ```\n         * @category CRUD\n         */\n        addCrudStore(store, position, fromStore) {\n            store = ArrayHelper.asArray(store);\n            if (!store?.length) {\n                return;\n            }\n            const\n                me     = this,\n                stores = store.map(me.internalAddCrudStore, me);\n            // if no position specified then append stores to the end\n            if (typeof position === 'undefined') {\n                me.crudStores.push(...stores);\n            }\n            // if position specified\n            else {\n                // if specified the store relative to which we should insert new one(-s)\n                if (fromStore) {\n                    if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);\n                    // get its position\n                    position += me.crudStores.indexOf(fromStore);\n                }\n                // insert new store(-s)\n                me.crudStores.splice(position, 0, ...stores);\n            }\n            me.orderedCrudStores.push(...stores);\n            me.updateCrudStoreIndex();\n        }\n        // Adds configured scheduler stores to the store collection ensuring correct order\n        // unless they're already registered.\n        addPrioritizedStore(store) {\n            const me = this;\n            if (!me.hasCrudStore(store)) {\n                me.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));\n            }\n            if (!me.hasApplySequenceStore(store)) {\n                me.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));\n            }\n        }\n        hasCrudStore(store) {\n            return this.crudStores?.some(s => s === store || s.store === store || s.storeId === store);\n        }\n        /**\n         * Removes a store from collection. If the store was registered in alternative sync sequence list\n         * it will be removed from there as well.\n         *\n         * ```javascript\n         * // remove store having storeId equal to \"foo\"\n         * crudManager.removeCrudStore(\"foo\");\n         *\n         * // remove store3\n         * crudManager.removeCrudStore(store3);\n         * ```\n         *\n         * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store\n         * descriptor, store identifier or store itself.\n         * @category CRUD\n         */\n        removeCrudStore(store) {\n            const\n                me         = this,\n                stores     = me.crudStores,\n                foundStore = stores.find(s => s === store || s.store === store || s.storeId === store);\n            if (foundStore) {\n                // unbind store listeners\n                me.unbindCrudStoreListeners(foundStore.store);\n                delete me.crudStoresIndex[foundStore.storeId];\n                ArrayHelper.remove(stores, foundStore);\n                if (me.syncApplySequence) {\n                    me.removeStoreFromApplySequence(store);\n                }\n            }\n            else {\n                throw new Error('Store not found in stores collection');\n            }\n        }\n        //endregion\n        //region Store listeners\n        bindCrudStoreListeners(store) {\n            store.ion({\n                name : store.id,\n                // When a tentatively added record gets confirmed as permanent, this signals a change\n                addConfirmed : 'onCrudStoreChange',\n                change       : 'onCrudStoreChange',\n                destroy      : 'onCrudStoreDestroy',\n                thisObj      : this\n            });\n        }\n        unbindCrudStoreListeners(store) {\n            this.detachListeners(store.id);\n        }\n        //endregion\n        //region Apply sequence\n        /**\n         * Adds a store to the alternative sync responses apply sequence.\n         * By default, the order in which sync responses are applied to the stores is the same as they registered in.\n         * But this order can be changes either on construction step using {@link #config-syncApplySequence} option\n         * or by calling this method.\n         *\n         * **Please note**, that if the sequence was not initialized before this method call then\n         * you will have to do it yourself like this for example:\n         *\n         * ```javascript\n         * // alternative sequence was not set for this crud manager\n         * // so let's fill it with existing stores keeping the same order\n         * crudManager.addStoreToApplySequence(crudManager.crudStores);\n         *\n         * // and now we can add our new store\n         *\n         * // we will load its data last\n         * crudManager.addCrudStore(someNewStore);\n         * // but changes to it will be applied first\n         * crudManager.addStoreToApplySequence(someNewStore, 0);\n         * ```\n         * add registered stores to the sequence along with the store(s) you want to add\n         *\n         * @param {Core.data.Store|CrudManagerStoreDescriptor|Core.data.Store[]|CrudManagerStoreDescriptor[]} store The\n         * store to add or its _descriptor_ (or array of stores or descriptors).\n         * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position\n         * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.\n         * Otherwise, it will be just a position in stores collection.\n         *\n         * ```javascript\n         * // insert stores store4, store5 to the start of sequence\n         * crudManager.addStoreToApplySequence([ store4, store5 ], 0);\n         * ```\n         * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position\n         * should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of\n         * {@link #function-getStoreDescriptor} call).\n         *\n         * ```javascript\n         * // insert store6 just before a store having storeId equal to 'foo'\n         * crudManager.addStoreToApplySequence(store6, 0, 'foo');\n         *\n         * // insert store7 just after store3 store\n         * crudManager.addStoreToApplySequence(store7, 1, store3);\n         * ```\n         * @category CRUD\n         */\n        addStoreToApplySequence(store, position, fromStore) {\n            if (!store) {\n                return;\n            }\n            store = ArrayHelper.asArray(store);\n            const\n                me   = this,\n                // loop over list of stores to add\n                data = store.reduce((collection, store) => {\n                    const s = me.getStoreDescriptor(store);\n                    s && collection.push(s);\n                    return collection;\n                }, []);\n            // if no position specified then append stores to the end\n            if (typeof position === 'undefined') {\n                me.syncApplySequence.push(...data);\n                // if position specified\n            }\n            else {\n                let pos = position;\n                // if specified the store relative to which we should insert new one(-s)\n                if (fromStore) {\n                    if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);\n                    // get its position\n                    pos += me.syncApplySequence.indexOf(fromStore);\n                }\n                // insert new store(-s)\n                //me.syncApplySequence.splice.apply(me.syncApplySequence, [].concat([pos, 0], data));\n                me.syncApplySequence.splice(pos, 0, ...data);\n            }\n            const sequenceKeys = me.syncApplySequence.map(({ storeId }) => storeId);\n            me.orderedCrudStores = [...me.syncApplySequence];\n            me.crudStores.forEach(storeDesc => {\n                if (!sequenceKeys.includes(storeDesc.storeId)) {\n                    me.orderedCrudStores.push(storeDesc);\n                }\n            });\n        }\n        /**\n         * Removes a store from the alternative sync sequence.\n         *\n         * ```javascript\n         * // remove store having storeId equal to \"foo\"\n         * crudManager.removeStoreFromApplySequence(\"foo\");\n         * ```\n         *\n         * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store\n         * descriptor, store identifier or store itself.\n         * @category CRUD\n         */\n        removeStoreFromApplySequence(store) {\n            const index = this.syncApplySequence.findIndex(s => s === store || s.store === store || s.storeId === store);\n            if (index > -1) {\n                this.syncApplySequence.splice(index, 1);\n                // ordered crud stores list starts with syncApplySequence, we can use same index\n                this.orderedCrudStores.splice(index, 1);\n            }\n        }\n        hasApplySequenceStore(store) {\n            return this.syncApplySequence.some(s => s === store || s.store === store || s.storeId === store);\n        }\n        //endregion\n        //region Events\n        // Remove stores that are destroyed, to not try and apply response changes etc. to them\n        onCrudStoreDestroy({ source : store }) {\n            this.removeCrudStore(store);\n        }\n        onCrudStoreChange(event) {\n            const me = this;\n            if (me.crudIgnoreUpdates) {\n                return;\n            }\n            /**\n             * Fires when data in any of the registered data stores is changed.\n             * ```javascript\n             *     crudManager.on('hasChanges', function (crud) {\n             *         // enable persist changes button when some store gets changed\n             *         saveButton.enable();\n             *     });\n             * ```\n             * @event hasChanges\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n             */\n            if (me.crudStoreHasChanges(event?.source)) {\n                me.trigger('hasChanges');\n                if (me.autoSync) {\n                    me.scheduleAutoSync();\n                }\n            }\n            else {\n                me.trigger('noChanges');\n            }\n        }\n        /**\n         * Suspends automatic sync upon store changes. Can be called multiple times (it uses an internal counter).\n         * @category CRUD\n         */\n        suspendAutoSync() {\n            this.autoSyncSuspendCounter++;\n        }\n        /**\n         * Resumes automatic sync upon store changes. Will schedule a sync if the internal counter is 0.\n         * @param {Boolean} [doSync=true] Pass `true` to schedule a sync after resuming (if there are pending\n         * changes) and `false` to not persist the changes.\n         * @category CRUD\n         */\n        resumeAutoSync(doSync = true) {\n            const me = this;\n            me.autoSyncSuspendCounter--;\n            if (me.autoSyncSuspendCounter <= 0) {\n                me.autoSyncSuspendCounter = 0;\n                // if configured to trigger persisting and there are changes\n                if (doSync && me.autoSync && me.crudStoreHasChanges()) {\n                    me.scheduleAutoSync();\n                }\n            }\n        }\n        get isAutoSyncSuspended() {\n            return this.autoSyncSuspendCounter > 0;\n        }\n        scheduleAutoSync() {\n            const me = this;\n            // add deferred call if it's not scheduled yet\n            if (!me.hasTimeout('autoSync') && !me.isAutoSyncSuspended) {\n                me.setTimeout({\n                    name : 'autoSync',\n                    fn   : () => {\n                        me.sync().catch(error => {\n                        });\n                    },\n                    delay : me.autoSyncTimeout\n                });\n            }\n        }\n        async triggerFailedRequestEvents(request, response, responseText, fetchOptions) {\n            const { options, type : requestType } = request;\n            /**\n             * Fires when a request fails.\n             * @event requestFail\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.\n             * @param {'sync'|'load'} requestType The request type (`sync` or `load`).\n             * @param {Object} response The decoded server response object.\n             * @param {String} responseText The raw server response text\n             * @param {Object} responseOptions The response options.\n             */\n            this.trigger('requestFail', { requestType, response, responseText, responseOptions : fetchOptions });\n            /**\n             * Fires when a {@link #function-load load request} fails.\n             * @event loadFail\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.\n             * @param {Object} response The decoded server response object.\n             * @param {String} responseText The raw server response text\n             * @param {Object} responseOptions The response options.\n             * @params {Object} options Options provided to the {@link #function-load} method.\n             */\n            /**\n             * Fires when a {@link #function-sync sync request} fails.\n             * @event syncFail\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.\n             * @param {Object} response The decoded server response object.\n             * @param {String} responseText The raw server response text\n             * @param {Object} responseOptions The response options.\n             */\n            this.trigger(requestType + 'Fail', { response, responseOptions : fetchOptions, responseText, options });\n        }\n        async internalOnResponse(request, responseText, fetchOptions) {\n            const\n                me                              = this,\n                response                        = responseText ? me.decode(responseText) : null,\n                { options, type : requestType } = request;\n            if (responseText && !response) {\n                console.error('Failed to parse response: ' + responseText);\n            }\n            if (!response || (me.skipSuccessProperty ? response.success === false : !response.success)) {\n                me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);\n            }\n            else if (\n                me.trigger('beforeResponseApply', { requestType, response }) !== false &&\n                me.trigger(`before${StringHelper.capitalize(requestType)}Apply`, { response, options }) !== false\n            ) {\n                me.crudRevision = response.revision;\n                await me.applyResponse(request, response, options);\n                // Might have been destroyed while applying response\n                if (me.isDestroyed) {\n                    return;\n                }\n                /**\n                 * Fires on successful request completion after data gets applied to the stores.\n                 * @event requestDone\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {'sync'|'load'} requestType The request type (`sync` or `load`).\n                 * @param {Object} response The decoded server response object.\n                 * @param {Object} responseOptions The server response options.\n                 */\n                me.trigger('requestDone', { requestType, response, responseOptions : fetchOptions });\n                /**\n                 * Fires on successful {@link #function-load load request} completion after data gets loaded to the stores.\n                 * @event load\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} response The decoded server response object.\n                 * @param {Object} responseOptions The server response options.\n                 * @params {Object} options Options provided to the {@link #load} method.\n                 */\n                /**\n                 * Fires on successful {@link #function-sync sync request} completion.\n                 * @event sync\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} response The decoded server response object.\n                 * @param {Object} responseOptions The server response options.\n                 */\n                me.trigger(requestType, { response, responseOptions : fetchOptions, options });\n                if (requestType === 'load' || !me.crudStoreHasChanges()) {\n                    /**\n                     * Fires when registered stores get into state when they don't have any\n                     * not persisted change. This happens after {@link #function-load} or {@link #function-sync} request\n                     * completion. Or this may happen after a record update which turns its fields back to their original state.\n                     *\n                     * ```javascript\n                     * crudManager.on('nochanges', function (crud) {\n                     *     // disable persist changes button when there is no changes\n                     *     saveButton.disable();\n                     * });\n                     * ```\n                     *\n                     * @event noChanges\n                     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                     */\n                    me.trigger('noChanges');\n                    if (requestType === 'load') {\n                        me.emitCrudStoreEvents(request.pack.stores, 'afterRequest');\n                    }\n                }\n            }\n            return response;\n        }\n        //endregion\n        //region Changes tracking\n        suspendChangesTracking() {\n            this.crudIgnoreUpdates++;\n        }\n        resumeChangesTracking(skipChangeCheck) {\n            if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates && !skipChangeCheck) {\n                this.onCrudStoreChange();\n            }\n        }\n        get isBatchingChanges() {\n            return this.crudIgnoreUpdates > 0;\n        }\n        /**\n         * Returns `true` if any of registered stores (or some particular store) has non persisted changes.\n         *\n         * ```javascript\n         * // if we have any unsaved changes\n         * if (crudManager.crudStoreHasChanges()) {\n         *     // persist them\n         *     crudManager.sync();\n         * // otherwise\n         * } else {\n         *     alert(\"There are no unsaved changes...\");\n         * }\n         * ```\n         *\n         * @param {String|Core.data.Store} [storeId] The store identifier or store instance to check changes for.\n         * If not specified then will check changes for all of the registered stores.\n         * @returns {Boolean} `true` if there are not persisted changes.\n         * @category CRUD\n         */\n        crudStoreHasChanges(storeId) {\n            return storeId\n                ? this.isCrudStoreDirty(this.getCrudStore(storeId))\n                : this.crudStores.some(config => this.isCrudStoreDirty(config.store));\n        }\n        isCrudStoreDirty(store) {\n            return Boolean(store.changes);\n        }\n        //endregion\n        //region Load\n        doAutoLoad() {\n            return this.load().catch(error => {\n            });\n        }\n        emitCrudStoreEvents(stores, eventName, eventParams) {\n            const event = { action : 'read' + eventName, ...eventParams };\n            for (const store of this.crudStores) {\n                if (stores.includes(store.storeId)) {\n                    store.store.trigger(eventName, event);\n                }\n            }\n        }\n        getLoadPackage(options) {\n            const\n                pack        = {\n                    type      : 'load',\n                    requestId : this.requestId\n                },\n                stores      = this.crudStores,\n                optionsCopy = Object.assign({}, options);\n            // This is a special option which does not apply to a store.\n            // It's used as options to the AjaxTransport#sendRequest method\n            delete optionsCopy.request;\n            pack.stores = stores.map(store => {\n                const\n                    opts     = optionsCopy?.[store.storeId],\n                    pageSize = store.pageSize || store.store?.pageSize;\n                if (opts || pageSize) {\n                    const\n                        params = Object.assign({\n                            storeId : store.storeId,\n                            page    : 1\n                        }, opts);\n                    if (pageSize) {\n                        params.pageSize = pageSize;\n                    }\n                    store.currentPage = params.page;\n                    // Remove from common request options\n                    if (opts) {\n                        delete optionsCopy[store.storeId];\n                    }\n                    return params;\n                }\n                return store.storeId;\n            });\n            // Apply common request options\n            Object.assign(pack, optionsCopy);\n            return pack;\n        }\n        loadCrudStore(store, data, options) {\n            const rows = data?.rows;\n            if (options?.append || data?.append) {\n                store.add(rows);\n            }\n            else {\n                store.data = rows;\n            }\n            store.trigger('load', { data : rows });\n        }\n        loadDataToCrudStore(storeDesc, data, options) {\n            const\n                store = storeDesc.store,\n                rows  = data?.rows;\n            store.__loading = true;\n            if (rows) {\n                this.loadCrudStore(store, data, options, storeDesc);\n            }\n            store.__loading = false;\n        }\n        /**\n         * Loads data to the Crud Manager\n         * @param {Object} response A simple object representing the data.\n         * The object structure matches the decoded `load` response structure:\n         *\n         * ```js\n         * // load static data into crudManager\n         * crudManager.loadCrudManagerData({\n         *     success   : true,\n         *     resources : {\n         *         rows : [\n         *             { id : 1, name : 'John' },\n         *             { id : 2, name : 'Abby' }\n         *         ]\n         *     }\n         * });\n         * ```\n         * @param {Object} [options] Extra data loading options.\n         * @category CRUD\n         */\n        loadCrudManagerData(response, options = {}) {\n            // we don't want to react to store changes during loading of them\n            this.suspendChangesTracking();\n            // we load data to the stores in the order they're kept in this.stores array\n            this.crudStores.forEach(storeDesc => {\n                const\n                    storeId = storeDesc.storeId,\n                    data    = response[storeId];\n                if (data) {\n                    this.loadDataToCrudStore(storeDesc, data, options[storeId]);\n                }\n            });\n            this.resumeChangesTracking(true);\n        }\n        /**\n         * Returns true if the crud manager is currently loading data\n         * @property {Boolean}\n         * @readonly\n         * @category CRUD\n         */\n        get isCrudManagerLoading() {\n            return Boolean(this.activeRequests.load || this.applyingLoadResponse);\n        }\n        /**\n         * Returns true if the crud manager is currently syncing data\n         * @property {Boolean}\n         * @readonly\n         * @category CRUD\n         */\n        get isCrudManagerSyncing() {\n            return Boolean(this.activeRequests.sync || this.applyingSyncResponse);\n        }\n        get isLoadingOrSyncing() {\n            return Boolean(this.isCrudManagerLoading || this.isCrudManagerSyncing);\n        }\n        /**\n         * Loads data to the stores registered in the crud manager. For example:\n         *\n         * ```javascript\n         * crudManager.load(\n         *     // here are request parameters\n         *     {\n         *         store1 : { append : true, page : 3, smth : 'foo' },\n         *         store2 : { page : 2, bar : '!!!' }\n         *     }\n         * ).then(\n         *     () => alert('OMG! It works!'),\n         *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)\n         * );\n         * ```\n         *\n         * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by calling {@link #function-cancelRequest}.\n         * @param {Object|String} [options] The request parameters or a URL.\n         * @param {Object} [options.request] An object which contains options to merge\n         * into the options which are passed to {@link Scheduler/crud/transport/AjaxTransport#function-sendRequest}.\n         * ```javascript\n         * {\n         *     store1 : { page : 3, append : true, smth : 'foo' },\n         *     store2 : { page : 2, bar : '!!!' },\n         *     request : {\n         *         params : {\n         *             startDate : '2021-01-01'\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * Omitting request arg:\n         * ```javascript\n         * crudManager.load().then(\n         *     () => alert('OMG! It works!'),\n         *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)\n         * );\n         * ```\n         *\n         * When presented it should be an object where keys are store Ids and values are, in turn, objects\n         * of parameters related to the corresponding store. These parameters will be transferred in each\n         * store's entry in the `stores` property of the POST data.\n         *\n         * Additionally, for flat stores `append: true` can be specified to add loaded records to the existing records,\n         * default is to remove corresponding store's existing records first.\n         * **Please note** that for delta loading you can also use an {@link #config-trackResponseType alternative approach}.\n         * @param {'sync'|'load'} [options.request.type] The request type. Either `load` or `sync`.\n         * @param {String} [options.request.url] The URL for the request. Overrides the URL defined in the `transport`\n         * object\n         * @param {String} [options.request.data] The encoded _Crud Manager_ request data.\n         * @param {Object} [options.request.params] An object specifying extra HTTP params to send with the request.\n         * @param {Function} [options.request.success] A function to be started on successful request transferring.\n         * @param {String} [options.request.success.rawResponse] `Response` object returned by the\n         * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n         * @param {Function} [options.request.failure] A function to be started on request transfer failure.\n         * @param {String} [options.request.failure.rawResponse] `Response` object returned by the\n         * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n         * @param {Object} [options.request.thisObj] `this` reference for the above `success` and `failure` functions.\n         * @returns {Promise} Promise, which is resolved if request was successful.\n         * Both the resolve and reject functions are passed a `state` object. State object has following structure:\n         *\n         * ```\n         * {\n         *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected\n         *     rawResponse     : String,  // raw response from ajax request, either response xml or text\n         *     rawResponseText : String,  // raw response text as String from ajax request\n         *     response        : Object,  // processed response in form of object\n         *     options         : Object   // options, passed to load request\n         * }\n         * ```\n         *\n         * If promise was rejected by {@link #event-beforeLoad} event, `state` object will have the following structure:\n         *\n         * ```\n         * {\n         *     cancelled : true\n         * }\n         * ```\n         * @category CRUD\n         * @async\n         */\n        load(options) {\n            if (typeof options === 'string') {\n                options = {\n                    request : {\n                        url : options\n                    }\n                };\n            }\n            const\n                me   = this,\n                pack = me.getLoadPackage(options);\n            me._autoLoadPromise = null;\n            return new Promise((resolve, reject) => {\n                /**\n                 * Fires before {@link #function-load load request} is sent. Return `false` to cancel load request.\n                 * @event beforeLoad\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} pack The data package which contains data for all stores managed by the crud manager.\n                 */\n                if (me.trigger('beforeLoad', { pack }) !== false) {\n                    // if another load request is in progress let's cancel it\n                    const { load } = me.activeRequests;\n                    if (load) {\n                        me.cancelRequest(load.desc, load.reject);\n                        me.trigger('loadCanceled', { pack });\n                    }\n                    const request = Objects.assign({\n                        id      : pack.requestId,\n                        data    : me.encode(pack),\n                        type    : 'load',\n                        success : me.onCrudRequestSuccess,\n                        failure : me.onCrudRequestFailure,\n                        thisObj : me\n                    }, options?.request);\n                    me.activeRequests.load = {\n                        type : 'load',\n                        options,\n                        pack,\n                        resolve,\n                        reject(...args) {\n                            // sendRequest will start a fetch promise, which we cannot reject from here. In fact what we\n                            // need to do, is to make fetch.then() to not call any real handlers. Which is what we do here.\n                            request.success = request.failure = null;\n                            reject(...args);\n                        },\n                        id   : pack.requestId,\n                        desc : me.sendRequest(request)\n                    };\n                    me.emitCrudStoreEvents(pack.stores, 'loadStart');\n                    me.trigger('loadStart', { pack });\n                }\n                else {\n                    /**\n                     * Fired after {@link #function-load load request} was canceled by some {@link #event-beforeLoad}\n                     * listener or due to incomplete prior load request.\n                     * @event loadCanceled\n                     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                     * @param {Object} pack The data package which contains data for all stores managed by the crud\n                     * manager.\n                     */\n                    me.trigger('loadCanceled', { pack });\n                    reject({ cancelled : true });\n                }\n            });\n        }\n        getActiveCrudManagerRequest(requestType) {\n            let request = this.activeRequests[requestType];\n            if (!request && this.trackResponseType) {\n                request = Object.values(this.activeRequests)[0];\n            }\n            return request;\n        }\n        //endregion\n        //region Changes (prepare, process, get)\n        prepareAddedRecordData(record, storeInfo) {\n            const\n                me                   = this,\n                { store }            = storeInfo,\n                { isTree }           = store,\n                phantomIdField       = storeInfo.phantomIdField || me.phantomIdField,\n                phantomParentIdField = storeInfo.phantomParentIdField || me.phantomParentIdField,\n                subStoreFields       = store.modelClass.allFields.filter(field => field.subStore),\n                cls                  = record.constructor,\n                data                 = Object.assign(record.persistableData, {\n                    [phantomIdField] : record.id\n                });\n            if (isTree) {\n                const { parent } = record;\n                if (parent && !parent.isRoot && parent.isPhantom) {\n                    data[phantomParentIdField] = parent.id;\n                }\n            }\n            if (me.resetIdsBeforeSync) {\n                ObjectHelper.deletePath(data, cls.idField);\n            }\n            // If we have store fields that should be persisted w/ Crud Manager protocol\n            subStoreFields.forEach(field => {\n                const subStore = record.get(field.name);\n                if (subStore.allCount) {\n                    data[field.dataSource] = {\n                        added : subStore.getRange()\n                            .map(record => me.prepareAddedRecordData(record, { store : subStore }))\n                    };\n                }\n            });\n            return data;\n        }\n        prepareAdded(list, storeInfo) {\n            return list.filter(record => record.isValid).map(record => this.prepareAddedRecordData(record, storeInfo));\n        }\n        prepareUpdated(list, storeInfo) {\n            const\n                { store }            = storeInfo,\n                { isTree }           = store,\n                writeAllFields       = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && this.writeAllFields),\n                phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField,\n                subStoreFields       = store.modelClass.allFields.filter(field => field.subStore);\n            if (storeInfo.store.tree) {\n                const rootNode = storeInfo.store.rootNode;\n                list = list.filter(record => record !== rootNode);\n            }\n            return list.filter(record => record.isValid).reduce((data, record) => {\n                let recordData;\n                // write all fields\n                if (writeAllFields) {\n                    recordData = record.persistableData;\n                }\n                else {\n                    recordData = record.modificationDataToWrite;\n                }\n                if (isTree) {\n                    const { parent } = record;\n                    if (parent && !parent.isRoot && parent.isPhantom) {\n                        recordData[phantomParentIdField] = parent.id;\n                    }\n                }\n                // If we have store fields that should be persisted w/ Crud Manager protocal\n                subStoreFields.forEach(field => {\n                    const subStore = record.get(field.name);\n                    recordData[field.dataSource] = this.getCrudStoreChanges({ store : subStore });\n                });\n                // recordData can be null\n                if (!ObjectHelper.isEmpty(recordData)) {\n                    data.push(recordData);\n                }\n                return data;\n            }, []);\n        }\n        prepareRemoved(list) {\n            return list.map(record => {\n                const cls = record.constructor;\n                return ObjectHelper.setPath({}, cls.idField, record.id);\n            });\n        }\n        getCrudStoreChanges(storeDescriptor) {\n            const { store } = storeDescriptor;\n            let { added = [], modified : updated = [], removed = [] } = (store.changes || {}),\n                result;\n            if (added.length) added = this.prepareAdded(added, storeDescriptor);\n            if (updated.length) updated = this.prepareUpdated(updated, storeDescriptor);\n            if (removed.length) removed = this.prepareRemoved(removed);\n            // if this store has changes\n            if (added.length || updated.length || removed.length) {\n                result = {};\n                if (added.length) result.added = added;\n                if (updated.length) result.updated = updated;\n                if (removed.length) result.removed = removed;\n            }\n            return result;\n        }\n        getChangesetPackage() {\n            const { changes } = this;\n            return changes || this.forceSync\n                ? {\n                    type      : 'sync',\n                    requestId : this.requestId,\n                    revision  : this.crudRevision,\n                    ...changes\n                } : null;\n        }\n        //endregion\n        //region Apply\n        /**\n         * Returns current changes as an object consisting of added/modified/removed arrays of records for every\n         * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:\n         *\n         * ```javascript\n         * {\n         *     resources : {\n         *         added    : [{ name : 'New guy' }],\n         *         modified : [{ id : 2, name : 'Mike' }],\n         *         removed  : [{ id : 3 }]\n         *     },\n         *     events : {\n         *         modified : [{  id : 12, name : 'Cool task' }]\n         *     },\n         *     ...\n         * }\n         * ```\n         *\n         * @property {Object}\n         * @readonly\n         * @category CRUD\n         */\n        get changes() {\n            const data = {};\n            this.crudStores.forEach(store => {\n                const changes = this.getCrudStoreChanges(store);\n                if (changes) {\n                    data[store.storeId] = changes;\n                }\n            });\n            return Object.keys(data).length > 0 ? data : null;\n        }\n        getRowsToApplyChangesTo({ store, storeId }, storeResponse, storePack) {\n            const\n                me             = this,\n                { modelClass } = store,\n                idDataSource   = modelClass.idField,\n                // request data\n                {\n                    updated : requestUpdated,\n                    removed : requestRemoved\n                }              = storePack || {};\n            let rows, removed, remote;\n            // If the response contains the store section\n            if (storeResponse) {\n                remote = true;\n                const respondedIds = {};\n                // responded record changes/removals\n                rows    = storeResponse.rows?.slice() || [];\n                removed = storeResponse.removed?.slice() || [];\n                // Collect hash w/ identifiers of responded records\n                [...rows, ...removed].forEach(responseRecord => {\n                    const id = ObjectHelper.getPath(responseRecord, idDataSource);\n                    respondedIds[id] = true;\n                });\n                // If it's told to support providing server changes only in response\n                // CrudManager should collect other records to commit from current requested data\n                if (me.supportShortSyncResponse) {\n                    // append records requested to update (if not there already)\n                    requestUpdated?.forEach(data => {\n                        const id = ObjectHelper.getPath(data, idDataSource);\n                        // if response doesn't include\n                        if (!respondedIds[id]) {\n                            rows.push({ [idDataSource] : id });\n                        }\n                    });\n                    // append records requested to remove (if not there already)\n                    requestRemoved?.forEach(data => {\n                        const id = ObjectHelper.getPath(data, idDataSource);\n                        // if response doesn't include\n                        if (!respondedIds[id]) {\n                            removed.push({ [idDataSource] : id });\n                        }\n                    });\n                }\n            }\n            // If there is no this store section we use records mentioned in the current request\n            else if (requestUpdated || requestRemoved) {\n                remote  = false;\n                rows    = requestUpdated;\n                removed = requestRemoved;\n            }\n            // return nullish \"rows\"/\"removed\" if no entries\n            rows    = rows?.length ? rows : null;\n            removed = removed?.length ? removed : null;\n            return {\n                rows,\n                removed,\n                remote\n            };\n        }\n        applyChangesToStore(storeDesc, storeResponse, storePack) {\n            const\n                me                = this,\n                phantomIdField    = storeDesc.phantomIdField || me.phantomIdField,\n                { store }         = storeDesc,\n                idField           = store.modelClass.getFieldDataSource('id'),\n                subStoreFields    = store.modelClass.allFields.filter(field => field.subStore),\n                // collect records we need to process\n                { rows, removed, remote } = me.getRowsToApplyChangesTo(storeDesc, storeResponse, storePack),\n                added = [],\n                updated = [];\n            // Convert to the { updated, added } format accepted by stores\n            if (rows) {\n                for (const data of rows) {\n                    // Existing records are updated\n                    if (store.getById(data[phantomIdField] ?? data[idField])) {\n                        updated.push(data);\n                    }\n                    // Others added\n                    else {\n                        added.push(data);\n                    }\n                }\n            }\n            const extraLogEntries = [];\n            // Handle sub-stores (if any)\n            if (updated.length && subStoreFields.length) {\n                updated.forEach(updateData => {\n                    const\n                        record = store.getById(updateData[phantomIdField] ?? updateData[idField]),\n                        // find the request portion related to the record\n                        recordRequest = storePack.added?.find(t => t[phantomIdField] == updateData[phantomIdField]) ||\n                            storePack.updated?.find(t => t[idField] == updateData[idField]);\n                    const extraLogInfo = {};\n                    subStoreFields.forEach(field => {\n                        const store = record.get(field.name);\n                        me.applyChangesToStore({ store }, updateData[field.dataSource],\n                            recordRequest?.[field.dataSource]\n                        );\n                        // We're putting the store field entry to the log\n                        // just to indicate the fact it was actually changed.\n                        // The value will not be used for comparison so we can use any.\n                        extraLogInfo[field.dataSource] = 'foo';\n                        delete updateData[field.dataSource];\n                    });\n                    extraLogEntries.push([record, extraLogInfo]);\n                });\n            }\n            // process added/updated records\n            const log = store.applyChangeset({ removed, added, updated }, null, phantomIdField, remote, true);\n            extraLogEntries.forEach(([record, logEntry]) => Object.assign(log.get(record.id), logEntry));\n            return log;\n        }\n        applySyncResponse(response, request) {\n            const\n                me     = this,\n                stores = me.orderedCrudStores;\n            me.applyingChangeset = me.applyingSyncResponse = true;\n            me.suspendChangesTracking();\n            for (const store of stores) {\n                me.applyChangesToStore(store, response[store.storeId], request?.pack?.[store.storeId]);\n            }\n            me.resumeChangesTracking(true);\n            me.applyingChangeset = me.applyingSyncResponse = false;\n        }\n        applyLoadResponse(response, options) {\n            this.applyingLoadResponse = true;\n            this.loadCrudManagerData(response, options);\n            this.applyingLoadResponse = false;\n        }\n        async applyResponse(request, response, options) {\n            const\n                me = this,\n                // in trackResponseType mode we check response type before deciding how to react on the response\n                responseType = me.trackResponseType && response.type || request.type;\n            switch (responseType) {\n                case 'load' :\n                    if (me.validateResponse) {\n                        me.validateLoadResponse(response);\n                    }\n                    me.applyLoadResponse(response, options);\n                    break;\n                case 'sync' :\n                    if (me.validateResponse) {\n                        me.validateSyncResponse(response, request);\n                    }\n                    me.applySyncResponse(response, request);\n                    break;\n            }\n        }\n        /**\n         * Applies a set of changes, as an object keyed by store id, to the affected stores. This function is intended\n         * to use in apps that handle their own data syncing, it is not needed when using the CrudManager approach.\n         *\n         * Example of a changeset:\n         * ```javascript\n         * project.applyChangeset({\n         *     events : {\n         *         added : [\n         *             { id : 10, name : 'Event 10', startDate : '2022-06-07' }\n         *         ],\n         *         updated : [\n         *             { id : 5, name : 'Changed' }\n         *         ],\n         *         removed : [\n         *             { id : 1 }\n         *         ]\n         *     },\n         *     resources : { ... },\n         *     ...\n         * });\n         * ```\n         *\n         * Optionally accepts a `transformFn` to convert an incoming changeset to the expected format.\n         * See {@link Core/data/Store#function-applyChangeset} for more details.\n         *\n         * @param {Object} changes Changeset to apply, an object keyed by store id where each value follows the\n         * format described in {@link Core/data/Store#function-applyChangeset}\n         * @param {Function} [transformFn] Optional function used to preprocess a changeset per store in a different\n         * format, should return an object with the format expected by {@link Core/data/Store#function-applyChangeset}\n         * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a\n         * proper id instead of a phantom id\n         */\n        applyChangeset(changes, transformFn = null, phantomIdField, logChanges = false) {\n            const\n                me  = this,\n                log = logChanges ? new Map() : undefined;\n            me.suspendAutoSync();\n            me.suspendChangesTracking();\n            for (const { store, phantomIdField } of me.orderedCrudStores) {\n                if (changes[store.id]) {\n                    const storeLog = store.applyChangeset(\n                        changes[store.id],\n                        transformFn,\n                        phantomIdField || me.phantomIdField,\n                        // mark this changeset as remote to enforce it\n                        true,\n                        logChanges\n                    );\n                    if (storeLog) {\n                        log.set(store.id, storeLog);\n                    }\n                }\n            }\n            me.resumeChangesTracking(true);\n            me.resumeAutoSync(false);\n            return log;\n        }\n        //endregion\n        /**\n         * Generates unique request identifier.\n         * @internal\n         * @template\n         * @returns {Number} The request identifier.\n         * @category CRUD\n         */\n        get requestId() {\n            return Number.parseInt(`${Date.now()}${(this._requestId++)}`);\n        }\n        /**\n         * Persists changes made on the registered stores to the server and/or receives changes made on the backend.\n         * Usage:\n         *\n         * ```javascript\n         * // persist and run a callback on request completion\n         * crud.sync().then(\n         *     () => console.log(\"Changes saved...\"),\n         *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)\n         * );\n         * ```\n         *\n         * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it\n         * until previous request completion.\n         * In this case {@link #event-syncDelayed} event will be fired.\n         *\n         * ** Note: ** Please take a look at {@link #config-autoSync} config. This option allows to persist changes\n         * automatically after any data modification.\n         *\n         * ** Note: ** By default a sync request is only sent if there are any local {@link #property-changes}. To\n         * always send a request when calling this function, configure {@link #config-forceSync} as `true`.\n         *\n         * @returns {Promise} Promise, which is resolved if request was successful.\n         * Both the resolve and reject functions are passed a `state` object. State object has the following structure:\n         * ```\n         * {\n         *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected\n         *     rawResponse     : String,  // raw response from ajax request, either response xml or text\n         *     rawResponseText : String,  // raw response text as String from ajax request\n         *     response        : Object,  // processed response in form of object\n         * }\n         * ```\n         * If promise was rejected by the {@link #event-beforeSync} event, `state` object will have this structure:\n         * ```\n         * {\n         *     cancelled : true\n         * }\n         * ```\n         * @category CRUD\n         * @async\n         */\n        sync() {\n            const me = this;\n            // A direct call to sync cancels any outstanding autoSync\n            me.clearTimeout('autoSync');\n            if (me.activeRequests.sync) {\n                // let's delay this call and start it only after server response\n                /**\n                 * Fires after {@link #function-sync sync request} was delayed due to incomplete previous one.\n                 * @event syncDelayed\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} arguments The arguments of {@link #function-sync} call.\n                 */\n                me.trigger('syncDelayed');\n                // Queue sync request after current one\n                return me.activeSyncPromise = me.activeSyncPromise.finally(() => me.sync());\n            }\n            // Store current request promise. While this one is pending, all following sync requests will create chain\n            // of sequential promises\n            return me.activeSyncPromise = new Promise((resolve, reject) => {\n                // get current changes set package\n                const pack = me.getChangesetPackage();\n                // if no data to persist we resolve immediately\n                if (!pack) {\n                    resolve(null);\n                    return;\n                }\n                /**\n                 * Fires before {@link #function-sync sync request} is sent. Return `false` to cancel sync request.\n                 *\n                 * ```javascript\n                 * crudManager.on('beforesync', function() {\n                 *     // cannot persist changes before at least one record is added\n                 *     // to the `someStore` store\n                 *     if (!someStore.getCount()) return false;\n                 * });\n                 * ```\n                 * @event beforeSync\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} pack The data package which contains data for all stores managed by the crud manager.\n                 */\n                if (me.trigger('beforeSync', { pack }) !== false) {\n                    me.trigger('syncStart', { pack });\n                    // keep active request details\n                    me.activeRequests.sync = {\n                        type : 'sync',\n                        pack,\n                        resolve,\n                        reject,\n                        id   : pack.requestId,\n                        desc : me.sendRequest({\n                            id      : pack.requestId,\n                            data    : me.encode(pack),\n                            type    : 'sync',\n                            success : me.onCrudRequestSuccess,\n                            failure : me.onCrudRequestFailure,\n                            thisObj : me\n                        })\n                    };\n                }\n                else {\n                    /**\n                     * Fires after {@link #function-sync sync request} was canceled by some {@link #event-beforeSync} listener.\n                     * @event syncCanceled\n                     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                     * @param {Object} pack The data package which contains data for all stores managed by the crud manager.\n                     */\n                    me.trigger('syncCanceled', { pack });\n                    reject({ cancelled : true });\n                }\n            }).catch(error => {\n                // If the request was not cancelled in beforeSync listener, forward the error so the user's `catch` handler can catch it\n                if (error && !error.cancelled) {\n                    throw error;\n                }\n                // Pass the error object as a param to the next `then` chain\n                return error;\n            });\n        }\n        async onCrudRequestSuccess(rawResponse, fetchOptions, request) {\n            const\n                me = this,\n                {\n                    type : requestType,\n                    id   : requestId\n                }  = request;\n            if (me.isDestroyed) return;\n            let responseText = '';\n            request = me.activeRequests[requestType];\n            // we throw exception below to let events trigger first in internalOnResponse() call\n            try {\n                responseText = await rawResponse.text();\n            }\n            catch (e) {\n            }\n            // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n            if (me.isDestroyed) return;\n            // This situation should never occur.\n            // In the load() method, if a load is called while there is a load\n            // ongoing, the ongoing Transport request is cancelled and loadCanceled triggered.\n            // But having got here, it's too late to cancel a Transport request, so\n            // the operation is unregistered below.\n            // In the sync() method, if a sync is called while there is a sync\n            // ongoing, it waits until completion, before syncing.\n            // The activeRequest for any operation should NEVER be able to be\n            // replaced while this operation is ongoing, so this must be fatal.\n            if (request?.id !== requestId) {\n                throw new Error(`Interleaved ${requestType} operation detected`);\n            }\n            // Reset the active request info before we enter async code which could allow\n            // application code to run which could potentially call another request.\n            // It is too late for this request to be canceled - the activeRequest represented\n            // the Transport object and that has completed now.\n            me.activeRequests[requestType] = null;\n            const response = await me.internalOnResponse(request, responseText, fetchOptions);\n            // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n            if (me.isDestroyed) return;\n            if (!response || (me.skipSuccessProperty ? response?.success === false : !response?.success)) {\n                const error = {\n                    rawResponse,\n                    response,\n                    request\n                };\n                if (response?.message) {\n                    error.message = response.message;\n                }\n                request.reject(new CrudManagerRequestError(error));\n            }\n            // Successful request type done flag (this.crudLoaded or this.crudSynced)..\n            me['crud' + StringHelper.capitalize(request.type) + 'ed'] = true;\n            request.resolve({ response, rawResponse, responseText, request });\n        }\n        async onCrudRequestFailure(rawResponse, fetchOptions, request) {\n            const me = this;\n            if (me.isDestroyed) return;\n            request = me.activeRequests[request.type];\n            const\n                signal      = fetchOptions?.abortController?.signal,\n                wasAborted  = Boolean(signal?.aborted);\n            if (!wasAborted) {\n                let response,\n                    responseText = '';\n                try {\n                    responseText = await rawResponse.text();\n                    response = me.decode(responseText);\n                }\n                catch (e) {\n                }\n                // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n                if (me.isDestroyed) return;\n                me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);\n                // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n                if (me.isDestroyed) return;\n                request.reject(new CrudManagerRequestError({\n                    rawResponse,\n                    request\n                }));\n            }\n            // reset the active request info\n            me.activeRequests[request.type] = null;\n        }\n        /**\n         * Accepts all changes in all stores, resets the modification tracking:\n         * * Clears change tracking for all records\n         * * Clears added\n         * * Clears modified\n         * * Clears removed\n         * Leaves the store in an \"unmodified\" state.\n         * @category CRUD\n         */\n        acceptChanges() {\n            this.crudStores.forEach(store => store.store.acceptChanges());\n        }\n        /**\n         * Reverts all changes in all stores and re-inserts any records that were removed locally. Any new uncommitted\n         * records will be removed.\n         * @category CRUD\n         */\n        revertChanges() {\n            // the method aliases revertCrudStoreChanges\n            this.revertCrudStoreChanges();\n        }\n        revertCrudStoreChanges() {\n            const { usesSingleAssignment } = this.eventStore;\n            // Ignore assignment store if using single assignment, otherwise reverting changes will undo changes from\n            // reverting the event store after reassignment\n            this.orderedCrudStores.forEach(({ store }) => (!store.isAssignmentStore || !usesSingleAssignment) && store.revertChanges());\n        }\n        /**\n         * Removes all stores and cancels active requests.\n         * @category CRUD\n         * @internal\n         */\n        doDestroy() {\n            const\n                me             = this,\n                { load, sync } = me.activeRequests;\n            load && me.cancelRequest(load.desc, load.reject);\n            sync && me.cancelRequest(sync.desc, sync.reject);\n            while (me.crudStores.length > 0) {\n                me.removeCrudStore(me.crudStores[0]);\n            }\n            super.doDestroy && super.doDestroy();\n        }\n    };\n};\n", "import Base from '../../Core/Base.js';\nimport AbstractCrudManagerMixin from './AbstractCrudManagerMixin.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Scheduler/crud/AbstractCrudManager\n */\n/**\n * @typedef {Object} CrudManagerStoreDescriptor\n * @property {String} storeId Unique store identifier. Store related requests/responses will be sent under this name.\n * @property {Core.data.Store} store The store itself.\n * @property {String} [phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.\n * @property {String} [idField] id field name, if it's not specified then class will try to get it from store model.\n * @property {Boolean} [writeAllFields] Set to true to write all fields from modified records\n */\n/**\n * This is an abstract class serving as the base for the {@link Scheduler.data.CrudManager} class.\n * It implements basic mechanisms to organize batch communication with a server.\n * Yet it does not contain methods related to _data transfer_ nor _encoding_.\n * These methods are to be provided in sub-classes by consuming the appropriate mixins.\n *\n * For example, this is how the class can be used to implement an JSON encoding system:\n *\n * ```javascript\n * // let's make new CrudManager using AJAX as a transport system and JSON for encoding\n * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {\n *\n * }\n * ```\n *\n * ## Data transfer and encoding methods\n *\n * These are methods that must be provided by subclasses of this class:\n *\n * - [#sendRequest](#Scheduler/crud/AbstractCrudManagerMixin#function-sendRequest)\n * - [#cancelRequest](#Scheduler/crud/AbstractCrudManagerMixin#function-cancelRequest)\n * - [#encode](#Scheduler/crud/AbstractCrudManagerMixin#function-encode)\n * - [#decode](#Scheduler/crud/AbstractCrudManagerMixin#function-decode)\n *\n * @extends Core/Base\n * @mixes Scheduler/crud/AbstractCrudManagerMixin\n * @abstract\n */\nexport default class AbstractCrudManager extends Base.mixin(AbstractCrudManagerMixin) {\n    //region Default config\n    /**\n     * The server revision stamp.\n     * The _revision stamp_ is a number which should be incremented after each server-side change.\n     * This property reflects the current version of the data retrieved from the server and gets updated after each\n     * {@link Scheduler/crud/AbstractCrudManagerMixin#function-load} and {@link Scheduler/crud/AbstractCrudManagerMixin#function-sync} call.\n     * @property {Number}\n     * @readonly\n     */\n    get revision() {\n        return this.crudRevision;\n    }\n    set revision(value) {\n        this.crudRevision = value;\n    }\n    /**\n     * Get or set data of {@link #property-crudStores} as a JSON string.\n     *\n     * Get a JSON string:\n     * ```javascript\n     *\n     * const jsonString = scheduler.crudManager.json;\n     *\n     * // returned jsonString:\n     * '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n     *\n     * // object representation of the returned jsonString:\n     * {\n     *     resourcesData    : [...],\n     *     eventsData       : [...],\n     *     assignmentsData  : [...],\n     *     dependenciesData : [...],\n     *     timeRangesData   : [...],\n     *     // data from other stores\n     * }\n     * ```\n     *\n     * Set a JSON string (to populate the CrudManager stores):\n     *\n     * ```javascript\n     * scheduler.crudManager.json = '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n     * ```\n     *\n     * @property {String}\n     */\n    get json() {\n        return StringHelper.safeJsonStringify(this);\n    }\n    set json(json) {\n        if (typeof json === 'string') {\n            json = StringHelper.safeJsonParse(json);\n        }\n        this.forEachCrudStore(store => {\n            const dataName = `${store.storeId}Data`;\n            if (json[dataName]) {\n                store.data = json[dataName];\n            }\n        });\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Sets the list of stores controlled by the CRUD manager.\n             *\n             * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync` requests.\n             * Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.\n             *\n             * Store can be provided as in instance, using its `storeId` or as an {@link #typedef-CrudManagerStoreDescriptor}\n             * object.\n             * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}\n             */\n            stores : null\n            /**\n             * Encodes request to the server.\n             * @function encode\n             * @param {Object} request The request to encode.\n             * @returns {String} The encoded request.\n             * @abstract\n             */\n            /**\n             * Decodes response from the server.\n             * @function decode\n             * @param {String} response The response to decode.\n             * @returns {Object} The decoded response.\n             * @abstract\n             */\n        };\n    }\n    //endregion\n    //region Init\n    construct(config = {}) {\n        if (config.stores) {\n            config.crudStores = config.stores;\n            delete config.stores;\n        }\n        super.construct(config);\n    }\n    //endregion\n    //region inline data\n    /**\n     * Returns the data from all CrudManager `crudStores` in a format that can be consumed by `inlineData`.\n     *\n     * Used by JSON.stringify to correctly convert this CrudManager to json.\n     *\n     * The returned data is identical to what {@link Scheduler/crud/AbstractCrudManager#property-inlineData} contains.\n     *\n     * ```javascript\n     *\n     * const json = scheduler.crudManager.toJSON();\n     *\n     * // json:\n     * {\n     *     eventsData : [...],\n     *     resourcesData : [...],\n     *     dependenciesData : [...],\n     *     assignmentsData : [...],\n     *     timeRangesData : [...],\n     *     resourceTimeRangesData : [...],\n     *     // ... other stores data\n     * }\n     * ```\n     *\n     * Output can be consumed by `inlineData`.\n     *\n     * ```javascript\n     * const json = scheduler.crudManager.toJSON();\n     *\n     * // Plug it back in later\n     * scheduler.crudManager.inlineData = json;\n     * ```\n     *\n     * @function toJSON\n     * @returns {Object}\n     * @category JSON\n     */\n    toJSON() {\n        // Collect data from crudStores\n        const result = {};\n        this.forEachCrudStore((store, storeId) => result[`${storeId}Data`] = store.toJSON());\n        return result;\n    }\n    /**\n     * Get or set data of CrudManager stores. The returned data is identical to what\n     * {@link Scheduler/crud/AbstractCrudManager#function-toJSON} returns:\n     *\n     * ```javascript\n     *\n     * const data = scheduler.crudManager.inlineData;\n     *\n     * // data:\n     * {\n     *     eventsData : [...],\n     *     resourcesData : [...],\n     *     dependenciesData : [...],\n     *     assignmentsData : [...],\n     *     timeRangesData : [...],\n     *     resourceTimeRangesData : [...],\n     *     ... other stores data\n     * }\n     *\n     *\n     * // Plug it back in later\n     * scheduler.crudManager.inlineData = data;\n     * ```\n     *\n     * @property {Object}\n     */\n    get inlineData() {\n        return this.toJSON();\n    }\n    set inlineData(data) {\n        this.json = data;\n    }\n    //endregion\n    //region Store collection (add, remove, get & iterate)\n    set stores(stores) {\n        if (stores !== this.crudStores) {\n            this.crudStores = stores;\n        }\n    }\n    /**\n     * A list of registered stores whose server communication will be collected into a single batch.\n     * Each store is represented by a _store descriptor_.\n     * @member {CrudManagerStoreDescriptor[]} stores\n     */\n    get stores() {\n        return this.crudStores;\n    }\n    //endregion\n    /**\n     * Returns true if the crud manager is currently loading data\n     * @property {Boolean}\n     * @readonly\n     * @category CRUD\n     */\n    get isLoading() {\n        return this.isCrudManagerLoading;\n    }\n    /**\n     * Adds a store to the collection.\n     *\n     *```javascript\n     * // append stores to the end of collection\n     * crudManager.addStore([\n     *     store1,\n     *     // storeId\n     *     'bar',\n     *     // store descriptor\n     *     {\n     *         storeId : 'foo',\n     *         store   : store3\n     *     },\n     *     {\n     *         storeId         : 'bar',\n     *         store           : store4,\n     *         // to write all fields of modified records\n     *         writeAllFields  : true\n     *     }\n     * ]);\n     *```\n     *\n     * **Note:** Order in which stores are kept in the collection is very essential sometimes.\n     * Exactly in this order the loaded data will be put into each store.\n     *\n     * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`\n     * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.\n     *\n     * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store\n     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.\n     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position will be\n     * taken relative to it.\n     * If not specified then store(s) will be appended to the end of collection.\n     * Otherwise, it will be an index in stores collection.\n     *\n     * ```javascript\n     * // insert stores store4, store5 to the start of collection\n     * crudManager.addStore([ store4, store5 ], 0);\n     * ```\n     *\n     * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position\n     * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of\n     * {@link Scheduler/crud/AbstractCrudManagerMixin#function-getStoreDescriptor} call).\n     *\n     * ```javascript\n     * // insert store6 just before a store having storeId equal to 'foo'\n     * crudManager.addStore(store6, 0, 'foo');\n     *\n     * // insert store7 just after store3 store\n     * crudManager.addStore(store7, 1, store3);\n     * ```\n     */\n    addStore(...args) {\n        return this.addCrudStore(...args);\n    }\n    removeStore(...args) {\n        return this.removeCrudStore(...args);\n    }\n    getStore(...args) {\n        return this.getCrudStore(...args);\n    }\n    hasChanges(...args) {\n        return this.crudStoreHasChanges(...args);\n    }\n    loadData(...args) {\n        return this.loadCrudManagerData(...args);\n    }\n}\nAbstractCrudManager._$name = 'AbstractCrudManager';", "import Base from '../../../Core/Base.js';\nimport AjaxHelper from '../../../Core/helper/AjaxHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\n/**\n * @module Scheduler/crud/transport/AjaxTransport\n */\n/**\n * Implements data transferring functional that can be used for {@link Scheduler.crud.AbstractCrudManager} super classing.\n * Uses the fetch API for transport, https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n *\n * @example\n * // create a new CrudManager using AJAX as a transport system and JSON for encoding\n * class MyCrudManager extends AjaxTransport(JsonEncode(AbstractCrudManager)) {}\n *\n * @abstract\n * @mixin\n */\nexport default Target => class AjaxTransport extends (Target || Base) {\n    static get $name() {\n        return 'AjaxTransport';\n    }\n    /**\n     * Configuration of the AJAX requests used by _Crud Manager_ to communicate with a server-side.\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url       : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName : 'data',\n     *         // pass extra HTTP request parameter\n     *         params    : {\n     *             foo : 'bar'\n     *         }\n     *     },\n     *     sync : {\n     *         url     : 'http://mycool-server.com/sync.php',\n     *         // specify Content-Type for requests\n     *         headers : {\n     *             'Content-Type' : 'application/json'\n     *         }\n     *     }\n     * }\n     *```\n     * Since the class uses Fetch API you can use\n     * any its [Request interface](https://developer.mozilla.org/en-US/docs/Web/API/Request) options:\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url         : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName   : 'data',\n     *         // pass few Fetch API options\n     *         method      : 'GET',\n     *         credentials : 'include',\n     *         cache       : 'no-cache'\n     *     },\n     *     sync : {\n     *         url         : 'http://mycool-server.com/sync.php',\n     *         // specify Content-Type for requests\n     *         headers     : {\n     *             'Content-Type' : 'application/json'\n     *         },\n     *         credentials : 'include'\n     *     }\n     * }\n     *```\n     *\n     * An object where you can set the following possible properties:\n     * @config {Object} transport\n     * @property {Object} transport.load Load requests configuration:\n     * @property {String} transport.load.url URL to request for data loading.\n     * @property {String} [transport.load.method='GET'] HTTP method to be used for load requests.\n     * @property {String} [transport.load.paramName='data'] Name of the parameter that will contain a serialized `load`\n     * request. The value is mandatory for requests using `GET` method (default for `load`) so if the value is not\n     * provided `data` string is used as default.\n     * This value is optional for HTTP methods like `POST` and `PUT`, the request body will be used for data\n     * transferring in these cases.\n     * @property {Object} [transport.load.params] An object containing extra HTTP parameters to pass to the server when\n     * sending a `load` request.\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url       : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName : 'data',\n     *         // pass extra HTTP request parameter\n     *         // so resulting URL will look like: http://mycool-server.com/load.php?userId=123456&data=...\n     *         params    : {\n     *             userId : '123456'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object<String,String>} [transport.load.headers] An object containing headers to pass to each server request.\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url       : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName : 'data',\n     *         // specify Content-Type for \"load\" requests\n     *         headers   : {\n     *             'Content-Type' : 'application/json'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.load.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on\n     * the upper configuration level:\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url          : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName    : 'data',\n     *         // Fetch API options\n     *         method       : 'GET',\n     *         credentials  : 'include'\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.load.requestConfig] **DEPRECATED:** The config options can be defined on the upper\n     * configuration level.\n     * @property {Object} transport.sync Sync requests (`sync` in further text) configuration:\n     * @property {String} transport.sync.url URL to request for `sync`.\n     * @property {String} [transport.sync.method='POST'] HTTP request method to be used for `sync`.\n     * @property {String} [transport.sync.paramName=undefined] Name of the parameter in which `sync` data will be\n     * transferred. This value is optional for requests using methods like `POST` and `PUT`, the request body will be\n     * used for data transferring in this case (default for `sync`). And the value is mandatory for requests using `GET`\n     * method (if the value is not provided `data` string will be used as fallback).\n     * @property {Object} [transport.sync.params] HTTP parameters to pass with an HTTP request handling `sync`.\n     *\n     * ```javascript\n     * transport : {\n     *     sync : {\n     *         url    : 'http://mycool-server.com/sync.php',\n     *         // extra HTTP request parameter\n     *         params : {\n     *             userId : '123456'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object<String,String>} [transport.sync.headers] HTTP headers to pass with an HTTP request handling `sync`.\n     *\n     * ```javascript\n     * transport : {\n     *     sync : {\n     *         url     : 'http://mycool-server.com/sync.php',\n     *         // specify Content-Type for \"sync\" requests\n     *         headers : {\n     *             'Content-Type' : 'application/json'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.sync.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on\n     * the upper configuration level:\n     * ```javascript\n     * transport : {\n     *     sync : {\n     *         url         : 'http://mycool-server.com/sync.php',\n     *         credentials : 'include'\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.sync.requestConfig] **DEPRECATED:** The config options can be defined on the upper\n     * configuration level.\n     * @category CRUD\n     */\n    static get defaultMethod() {\n        return {\n            load : 'GET',\n            sync : 'POST'\n        };\n    }\n    /**\n     * Cancels a sent request.\n     * @param {Promise} requestPromise The Promise object wrapping the Request to be cancelled.\n     * The _requestPromise_ is the value returned from the corresponding {@link #function-sendRequest} call.\n     * @category CRUD\n     */\n    cancelRequest(requestPromise, reject) {\n        requestPromise.abort?.();\n        if (!this.isDestroying) {\n            reject({ cancelled : true });\n        }\n    }\n    shouldUseBodyForRequestData(packCfg, method, paramName) {\n        return !(method === 'HEAD' || method === 'GET') && !paramName;\n    }\n    /**\n     * Sends a _Crud Manager_ request to the server.\n     * @param {Object} request The request configuration object having following properties:\n     * @param {'load'|'sync'} request.type The request type. Either `load` or `sync`.\n     * @param {String} request.url The URL for the request. Overrides the URL defined in the `transport` object\n     * @param {String} request.data The encoded _Crud Manager_ request data.\n     * @param {Object} request.params An object specifying extra HTTP params to send with the request.\n     * @param {Function} request.success A function to be started on successful request transferring.\n     * @param {String} request.success.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n     * @param {Function} request.failure A function to be started on request transfer failure.\n     * @param {String} request.failure.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n     * @param {Object} request.thisObj `this` reference for the above `success` and `failure` functions.\n     * @returns {Promise} The fetch Promise object.\n     * @fires beforeSend\n     * @async\n     * @category CRUD\n     */\n    sendRequest(request) {\n        const\n            me              = this,\n            { data }        = request,\n            transportConfig = me.transport[request.type] || {},\n            // clone parameters defined for this type of request\n            requestConfig   = Objects.assign({}, transportConfig, transportConfig.requestConfig);\n        if (request.url) {\n            requestConfig.url = request.url;\n        }\n        requestConfig.method = requestConfig.method || AjaxTransport.defaultMethod[request.type];\n        requestConfig.params = Objects.assign(requestConfig.params || {}, request.params);\n        let { paramName } = requestConfig;\n        // transfer package in the request body for some types of HTTP requests\n        if (me.shouldUseBodyForRequestData(transportConfig, requestConfig.method, paramName)) {\n            requestConfig.body = data;\n            // for requests having body we set Content-Type to 'application/json' by default\n            requestConfig.headers = requestConfig.headers || {};\n            requestConfig.headers['Content-Type'] = requestConfig.headers['Content-Type'] || 'application/json';\n        }\n        else {\n            // when we don't use body paramName is mandatory so fallback to 'data' as name\n            paramName = paramName || 'data';\n            requestConfig.params[paramName] = data;\n        }\n        if (!requestConfig.url) {\n            throw new Error('Trying to request without URL specified');\n        }\n        // sanitize request config\n        delete requestConfig.requestConfig;\n        delete requestConfig.paramName;\n        let ajaxPromise, resultPromise;\n        function performSend() {\n            // AjaxHelper.fetch call it \"queryParams\"\n            requestConfig.queryParams = requestConfig.params;\n            delete requestConfig.params;\n            let cancelled = false;\n            const fetchOptions = Objects.assign({}, requestConfig, requestConfig.fetchOptions);\n            ajaxPromise  = AjaxHelper.fetch(requestConfig.url, fetchOptions);\n            return ajaxPromise.catch(error => {\n                ajaxPromise.done = true;\n                me.trigger?.('responseReceived', { success : false });\n                const signal = fetchOptions.abortController?.signal;\n                if (signal) {\n                    cancelled = signal.aborted;\n                    if (!cancelled) {\n                        console.warn(error);\n                    }\n                }\n                return { error, cancelled };\n            }).then(response => {\n                ajaxPromise.done = true;\n                me.trigger?.('responseReceived', { success : Boolean(response?.ok) });\n                const callback = response?.ok ? request.success : request.failure;\n                return callback?.call(request.thisObj || me, response, fetchOptions, request);\n            });\n        }\n        /**\n         * Fires before a request is sent to the server.\n         *\n         * ```javascript\n         * crudManager.on('beforeSend', function ({ params, type }) {\n         *     // let's set \"sync\" request parameters\n         *     if (type == 'sync') {\n         *         // dynamically depending on \"flag\" value\n         *         if (flag) {\n         *             params.foo = 'bar';\n         *         }\n         *         else {\n         *             params.foo = 'smth';\n         *         }\n         *     }\n         * });\n         * ```\n         * @event beforeSend\n         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.\n         * @param {Object} params HTTP request params to be passed in the request URL.\n         * @param {'sync'|'load'} requestType CrudManager request type (`load`/`sync`)\n         * @param {Object} requestConfig Configuration object for Ajax request call\n         * @async\n         */\n        const beforeSendResult = me.trigger('beforeSend', {\n            params      : requestConfig.params,\n            requestType : request.type,\n            requestConfig,\n            config      : request\n        });\n        if (Objects.isPromise(beforeSendResult)) {\n            resultPromise = beforeSendResult.then(performSend);\n        }\n        else {\n            resultPromise = performSend();\n        }\n        resultPromise.abort = () => {\n            if (!ajaxPromise.done) {\n                ajaxPromise.abort?.();\n            }\n        };\n        return resultPromise;\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n/**\n * @module Scheduler/crud/encoder/JsonEncoder\n */\n/**\n * Implements data encoding functional that should be mixed to a {@link Scheduler.crud.AbstractCrudManager} sub-class.\n * Uses _JSON_ as an encoding system.\n *\n * @example\n * // create a new CrudManager using AJAX as a transport system and JSON for encoding\n * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {}\n *\n * @mixin\n */\nexport default Target => class JsonEncoder extends (Target || Base) {\n    static get $name() {\n        return 'JsonEncoder';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Configuration of the JSON encoder used by the _Crud Manager_.\n             *\n             * @config {Object}\n             * @property {Object} encoder.requestData Static data to send with the data request.\n             *\n             * ```js\n             * new CrudManager({\n             *     // add static \"foo\" property to all requests data\n             *     encoder : {\n             *         requestData : {\n             *             foo : 'Bar'\n             *         }\n             *     },\n             *     ...\n             * });\n             * ```\n             *\n             * The above snippet will result adding \"foo\" property to all requests data:\n             *\n             * ```json\n             *     {\n             *         \"requestId\"   : 756,\n             *         \"type\"        : \"load\",\n             *\n             *         \"foo\"         : \"Bar\",\n             *\n             *         \"stores\"      : [\n             *             ...\n             * ```\n             * @category CRUD\n             */\n            encoder : {}\n        };\n    }\n    /**\n     * Encodes a request object to _JSON_ encoded string. If encoding fails (due to circular structure), it returns null.\n     * Supposed to be overridden in case data provided by the _Crud Manager_ has to be transformed into format requested by server.\n     * @param {Object} requestData The request to encode.\n     * @returns {String} The encoded request.\n     * @category CRUD\n     */\n    encode(requestData) {\n        requestData = Object.assign({}, this.encoder?.requestData, requestData);\n        return StringHelper.safeJsonStringify(requestData);\n    }\n    /**\n     * Decodes (parses) a _JSON_ response string to an object. If parsing fails, it returns null.\n     * Supposed to be overridden in case data provided by server has to be transformed into format requested by the _Crud Manager_.\n     * @param {String} responseText The response text to decode.\n     * @returns {Object} The decoded response.\n     * @category CRUD\n     */\n    decode(responseText) {\n        return StringHelper.safeJsonParse(responseText);\n    }\n};\n", "import TimeSpan from '../TimeSpan.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/model/mixin/TimeZonedDatesMixin\n */\nconst dateFieldsToConvert = {\n    startDate      : 1,\n    endDate        : 1,\n    constraintDate : 1,\n    deadlineDate   : 1\n};\n/**\n * This mixin class overrides default Model functionality to provide support for time zone converted dates\n * @mixin\n * @mixinbase TimeSpan\n */\nexport default Target => class TimeZonedDatesMixin extends (Target || TimeSpan) {\n    static $name = 'TimeZonedDatesMixin';\n    static fields  = [\n        /**\n         * The current timeZone this record is converted to. Used internally to keep track of time zone conversions.\n         *\n         * Can also be used to create a new record with dates in a specific non-local timezone. That is useful for\n         * example when replacing a store dataset. That would be interpreted as a new load, and all dates would be\n         * converted to the configured timezone.\n         *\n         * For more information about timezone conversion, se {@link Scheduler.model.ProjectModel#config-timeZone}.\n         *\n         * This field will not {@link Core.data.field.DataField#config-persist} by default.\n         *\n         * @field {String|Number} timeZone\n         * @category Advanced\n         */\n        {\n            name    : 'timeZone',\n            persist : false\n        }\n    ];\n    get timeZone() {\n        return this.getData('timeZone');\n    }\n    set timeZone(timeZone) {\n        this.setData('timeZone', timeZone);\n    }\n    setLocalDate(field, date) {\n        this.set(field, this.timeZone != null ? TimeZoneHelper.toTimeZone(date, this.timeZone) : date, true);\n        // Need to set data to fool engine that the dates havn't changed\n        this.data[field] = this[field];\n    }\n    getLocalDate(field) {\n        if (this.timeZone != null && this[field]) {\n            return TimeZoneHelper.fromTimeZone(this[field], this.timeZone);\n        }\n        return this[field];\n    }\n    applyChangeset(rawChanges) {\n        // When a sync response arrives from backend, the data will need to be converted to time zone before applied.\n        if (this.timeZone != null) {\n            for (const field in dateFieldsToConvert) {\n                if (rawChanges[field]) {\n                    this.setLocalDate(field, new Date(rawChanges[field]));\n                    delete rawChanges[field];\n                }\n            }\n        }\n        return super.applyChangeset(...arguments);\n    }\n    getFieldPersistentValue(field) {\n        if (this.timeZone != null) {\n            const fieldName = field?.field ?? field?.name ?? field;\n            // Used when saving/syncing. Returns local system dates\n            if (dateFieldsToConvert[fieldName]) {\n                return this.getLocalDate(fieldName);\n            }\n        }\n        return super.getFieldPersistentValue(field);\n    }\n    // Converts current record into a timeZone\n    convertToTimeZone(timeZone) {\n        const\n            me            = this,\n            metaModified  = { ...me.meta.modified },\n            convertFields = { ...dateFieldsToConvert };\n        // Do not convert start and end dates on task unless manually scheduled\n        if (me.isTask && !me.manuallyScheduled) {\n            delete convertFields.startDate;\n            delete convertFields.endDate;\n        }\n        // Collect values\n        for (const field in convertFields) {\n            // Only convert if field has value\n            if (me[field] != null) {\n                convertFields[field] = me[field];\n                // If already converted, restore to local system time zone\n                if (me.timeZone != null) {\n                    convertFields[field] = me.getLocalDate(field);\n                    // Restore value in meta modified as well\n                    if (metaModified[field]) {\n                        metaModified[field] = TimeZoneHelper.fromTimeZone(metaModified[field], me.timeZone);\n                    }\n                }\n            }\n            else {\n                delete convertFields[field];\n            }\n        }\n        // Change time zone\n        me.timeZone = timeZone;\n        // Set values\n        for (const field in convertFields) {\n            // Convert and set field date silently\n            me.setLocalDate(field, convertFields[field], false);\n            convertFields[field] = 1; // For clearing changes below\n            // Convert value in meta modified as well\n            if (me.timeZone != null && metaModified[field]) {\n                metaModified[field] = TimeZoneHelper.toTimeZone(metaModified[field], me.timeZone);\n            }\n        }\n        // Clear modification metadata\n        me.clearChanges(true, true, convertFields);\n        // If old modification metadata, restore them to record and store\n        if (!ObjectHelper.isEmpty(metaModified)) {\n            me.meta.modified = metaModified;\n            me.stores.forEach(store => store.modified.add(me));\n        }\n    }\n};\n", "import Model from '../../Core/data/Model.js';\nimport TimeZonedDatesMixin from './mixin/TimeZonedDatesMixin.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Duration from '../../Core/data/Duration.js';\n/**\n * @module Scheduler/model/TimeSpan\n */\n/**\n * This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.\n *\n * It's a subclass of {@link Core.data.Model}.\n * Please refer to documentation of those classes to become familiar with the base interface of this class.\n *\n * A TimeSpan has the following fields:\n *\n * - {@link #field-startDate}    - start date of the task in the ISO 8601 format\n * - {@link #field-endDate}      - end date of the task in the ISO 8601 format (not inclusive)\n * - {@link #field-duration}     - duration, time between start date and end date\n * - {@link #field-durationUnit} - unit used to express the duration\n * - {@link #field-name}         - an optional name of the range\n * - {@link #field-cls}          - an optional CSS class to be associated with the range.\n *\n * The data source of any field can be customized in the subclass. Please refer to {@link Core.data.Model} for details. To specify\n * another date format:\n *\n * ```javascript\n * class MyTimeSpan extends TimeSpan {\n *   static get fields() {\n *      { name: 'startDate', type: 'date', dateFormat: 'DD/MM/YY' }\n *   }\n * }\n * ```\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/TimeZonedDatesMixin\n */\nexport default class TimeSpan extends Model.mixin(TimeZonedDatesMixin) {\n    static get $name() {\n        return 'TimeSpan';\n    }\n    //region Field definitions\n    static get fields() {\n        return [\n            /**\n             * The start date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} startDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            {\n                name : 'startDate',\n                type : 'date'\n            },\n            /**\n             * The end date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} endDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            {\n                name : 'endDate',\n                type : 'date'\n            },\n            /**\n             * The numeric part of the timespan's duration (the number of units).\n             * @field {Number} duration\n             * @category Scheduling\n             */\n            {\n                name      : 'duration',\n                type      : 'number',\n                allowNull : true,\n                internal  : true\n            },\n            /**\n             * The unit part of the TimeSpan duration, defaults to \"d\" (days). Valid values are:\n             *\n             * - \"millisecond\" - Milliseconds\n             * - \"second\" - Seconds\n             * - \"minute\" - Minutes\n             * - \"hour\" - Hours\n             * - \"day\" - Days\n             * - \"week\" - Weeks\n             * - \"month\" - Months\n             * - \"quarter\" - Quarters\n             * - \"year\"- Years\n             *\n             * This field is readonly after creation, to change durationUnit use #setDuration().\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit\n             * @category Scheduling\n             */\n            {\n                type         : 'durationunit',\n                name         : 'durationUnit',\n                defaultValue : 'd',\n                internal     : true\n            },\n            /**\n             * Calculated field which encapsulates the duration's magnitude and unit. This field will not be persisted,\n             * setting it will update the {@link #field-duration} and {@link #field-durationUnit} fields.\n             *\n             * @field {DurationConfig|Core.data.Duration} fullDuration\n             * @category Scheduling\n             */\n            {\n                name    : 'fullDuration',\n                persist : false,\n                column  : {\n                    type : 'duration'\n                }\n            },\n            /**\n             * An encapsulation of the CSS classes to add to the rendered time span element.\n             *\n             * Always returns a {@link Core.helper.util.DomClassList}, but may still be treated as a string. For\n             * granular control of adding and removing individual classes, it is recommended to use the\n             * {@link Core.helper.util.DomClassList} API.\n             *\n             * @field {Core.helper.util.DomClassList} cls\n             * @accepts {Core.helper.util.DomClassList|String|String[]|Object}\n             *\n             * @category Styling\n             */\n            {\n                name         : 'cls',\n                defaultValue : '',\n                internal     : true\n            },\n            /**\n             * CSS class specifying an icon to apply to the rendered time span element.\n             * **Note**: In case event is a milestone, using `iconCls` with dependency feature might slightly decrease\n             * performance because feature will refer to the DOM to get exact size of the element.\n             * @field {String} iconCls\n             * @category Styling\n             */\n            {\n                name     : 'iconCls',\n                internal : true\n            },\n            /**\n             * A CSS style string (applied to `style.cssText`) or object (applied to `style`)\n             * ```\n             * record.style = 'color: red;font-weight: 800';\n             * ```\n             *\n             * @field {String} style\n             * @category Styling\n             */\n            {\n                name     : 'style',\n                type     : 'object',\n                internal : true\n            },\n            /**\n             * The name of the time span (or Event / Task)\n             * @field {String} name\n             * @category Common\n             */\n            {\n                name         : 'name',\n                type         : 'string',\n                defaultValue : ''\n            }\n        ];\n    }\n    //endregion\n    //region Init\n    construct(data, ...args) {\n        // fullDuration is a \"calculated field\", but convenient to allow supplying it in the data\n        if (data?.fullDuration) {\n            const { magnitude, unit } = data.fullDuration;\n            data.duration = magnitude;\n            data.unit = unit;\n            delete data.fullDuration;\n        }\n        super.construct(data, ...args);\n        this.normalize();\n    }\n    /**\n     * Returns the event store this event is part of, if any.\n     *\n     * @property {Scheduler.data.EventStore}\n     * @readonly\n     * @category Misc\n     */\n    get eventStore() {\n        const me = this;\n        // If we are an occurrence, return our base recurring event's store\n        if (me.isOccurrence) {\n            return me.recurringTimeSpan.eventStore;\n        }\n        if (!me._eventStore) {\n            me._eventStore = me.stores?.find(s => s.isEventStore);\n        }\n        return me._eventStore;\n    }\n    normalize() {\n        const\n            me                                             = this,\n            { startDate, endDate, duration, durationUnit } = me,\n            hasDuration                                    = duration != null;\n        // need to calculate duration (checking first since seemed most likely to happen)\n        if (startDate && endDate && !hasDuration) {\n            me.setData('duration', DH.diff(startDate, endDate, durationUnit, true));\n        }\n        // need to calculate endDate?\n        else if (startDate && !endDate && hasDuration) {\n            me.setData('endDate', DH.add(startDate, duration, durationUnit));\n        }\n        // need to calculate startDate\n        else if (!startDate && endDate && hasDuration) {\n            me.setData('startDate', DH.add(endDate, -duration, durationUnit));\n        }\n    }\n    //endregion\n    //region Getters & Setters\n    updateInternalCls(cls) {\n        if (this._cls) {\n            this._cls.value = cls;\n        }\n        else {\n            this._cls = new DomClassList(cls);\n        }\n    }\n    set internalCls(cls) {\n        this.updateInternalCls(cls);\n        this.set('cls', this._cls.value);\n    }\n    get internalCls() {\n        const { cls } = this;\n        // `cls` getter can be overriden so return `cls` value if it is DomClassList or assign it to `this._cls`\n        if (cls?.isDomClassList) {\n            return cls;\n        }\n        this.internalCls = cls;\n        return this._cls;\n    }\n    get cls() {\n        if (!this._cls) {\n            this._cls = new DomClassList(super.get('cls'));\n        }\n        return this._cls;\n    }\n    set cls(cls) {\n        this.internalCls = cls;\n    }\n    get startDate() {\n        return this.get('startDate');\n    }\n    set startDate(date) {\n        this.setStartDate(date);\n    }\n    get endDate() {\n        return this.get('endDate');\n    }\n    set endDate(date) {\n        this.setEndDate(date);\n    }\n    get endingDate() {\n        const\n            me = this,\n            {\n                endDate,\n                startDate\n            }  = me;\n        if (endDate) {\n            // Special case of startDate===endDate for allDay event:\n            // if (Number(endDate) === Number(startDate) && me.allDay) {\n            //     return DH.add(startDate, 1, 'd');\n            // }\n            // Nope... the above works fine except when the day start time is shifted. In this case we want the\n            // event to appear as \"all day\" on the shifted day, but the above will push the endingDate beyond the\n            // end of the shifted day.\n            return endDate;\n        }\n        return DH.add(startDate, me.duration, me.durationUnit);\n    }\n    get duration() {\n        return this.get('duration');\n    }\n    set duration(duration) {\n        this.setDuration(duration, this.durationUnit);\n    }\n    get durationUnit() {\n        return this.get('durationUnit');\n    }\n    /**\n     * Sets duration and durationUnit in one go. Only allowed way to change durationUnit, the durationUnit field is\n     * readonly after creation\n     * @param {Number} duration Duration value\n     * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit Unit for\n     * specified duration value, see {@link #field-durationUnit} for valid values\n     * @category Scheduling\n     */\n    setDuration(duration, durationUnit = this.durationUnit) {\n        // Must be a number\n        duration = parseFloat(duration);\n        this.set({\n            duration,\n            durationUnit,\n            ...this.updateDatesFromDuration(duration, durationUnit)\n        });\n    }\n    updateDatesFromDuration(magnitude, unit, startDate = this.startDate, endDate = this.endDate) {\n        const result = {};\n        if (startDate) {\n            result.endDate = DH.add(startDate, magnitude, unit);\n        }\n        else if (endDate) {\n            result.startDate = DH.add(endDate, -magnitude, unit);\n        }\n        return result;\n    }\n    /**\n     * Returns duration of the event in given unit. This is a wrapper for {@link Core.helper.DateHelper#function-getDurationInUnit-static}\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit\n     * @param {Boolean} [doNotRound]\n     * @private\n     * @returns {Number}\n     */\n    getDurationInUnit(unit, doNotRound) {\n        const me = this;\n        if (me.startDate && me.endDate) {\n            return DH.getDurationInUnit(me.startDate, me.endDate, unit, doNotRound);\n        }\n        else {\n            return DH.as(unit, me.duration, me.durationUnit);\n        }\n    }\n    get fullDuration() {\n        // Used for formatting during export\n        return new Duration({\n            unit      : this.durationUnit,\n            magnitude : this.duration\n        });\n    }\n    set fullDuration(duration) {\n        if (typeof duration === 'string') {\n            duration = DH.parseDuration(duration, true, this.durationUnit);\n        }\n        this.setDuration(duration.magnitude, duration.unit);\n    }\n    /**\n     * Sets the range start date\n     *\n     * @param {Date} date The new start date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task (\"move\" the event), `false` to change the duration (\"resize\" the event).\n     * Defaults to `true`\n     * @category Scheduling\n     */\n    setStartDate(date, keepDuration = true) {\n        const\n            me    = this,\n            toSet = {\n                startDate : date\n            };\n        if (date) {\n            let calcEndDate;\n            if (keepDuration) {\n                calcEndDate = me.duration != null;\n            }\n            else {\n                if (me.endDate) {\n                    toSet.duration = DH.diff(date, me.endDate, me.durationUnit, true);\n                    if (toSet.duration < 0) throw new Error('Negative duration');\n                }\n                else {\n                    calcEndDate = this.duration != null;\n                }\n            }\n            if (calcEndDate) {\n                // Use hours to set end date in order to correctly process DST crossings\n                toSet.endDate = DH.add(date, me.getDurationInUnit('h'), 'h');\n            }\n        }\n        else {\n            toSet.duration = null;\n        }\n        me.set(toSet);\n    }\n    /**\n     * Sets the range end date\n     *\n     * @param {Date} date The new end date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task (\"move\" the event), `false` to change the duration (\"resize\" the event).\n     * Defaults to `false`\n     * @category Scheduling\n     */\n    setEndDate(date, keepDuration = false) {\n        const\n            me    = this,\n            toSet = {\n                endDate : date\n            };\n        if (date) {\n            let calcStartDate;\n            if (keepDuration === true) {\n                calcStartDate = me.duration != null;\n            }\n            else {\n                if (me.startDate) {\n                    toSet.duration = DH.diff(me.startDate, date, me.durationUnit, true);\n                    if (toSet.duration < 0) throw new Error('Negative duration');\n                }\n                else {\n                    calcStartDate = this.duration != null;\n                }\n            }\n            if (calcStartDate) {\n                toSet.startDate = DH.add(date, -me.duration, me.durationUnit);\n            }\n        }\n        me.set(toSet);\n    }\n    /**\n     * Sets the event start and end dates\n     *\n     * @param {Date} start The new start date\n     * @param {Date} end The new end date\n     * @param {Boolean} [silent] Pass `true` to not trigger events\n     * @category Scheduling\n     */\n    setStartEndDate(start, end, silent) {\n        this.set({\n            startDate : start,\n            endDate   : end\n        }, null, silent);\n    }\n    /**\n     * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.\n     * @readonly\n     * @property {Date[]}\n     * @category Scheduling\n     */\n    get dates() {\n        const\n            dates     = [],\n            startDate = DH.startOf(this.startDate, 'day'),\n            endDate   = this.endDate;\n        for (let date = startDate; date < endDate; date = DH.add(date, 1, 'day')) {\n            dates.push(date);\n        }\n        return dates;\n    }\n    get startDateMS() {\n        return (this.batching && this.hasBatchedChange('startDate') ? this.get('startDate') : this.startDate)?.getTime();\n    }\n    get endDateMS() {\n        return (this.batching && this.hasBatchedChange('endDate') ? this.get('endDate') : this.endDate)?.getTime();\n    }\n    /**\n     * Returns the duration of this Event in milliseconds.\n     * @readonly\n     * @property {Number}\n     * @category Scheduling\n     */\n    get durationMS() {\n        const { endDateMS, startDateMS } = this;\n        if (endDateMS && startDateMS) {\n            return endDateMS - startDateMS;\n        }\n        else {\n            return DH.asMilliseconds(this.duration || 0, this.durationUnit);\n        }\n    }\n    /**\n     * Returns true if record is a milestone.\n     * @readonly\n     * @property {Boolean}\n     * @category Scheduling\n     */\n    get isMilestone() {\n        return this.duration === 0;\n    }\n    inSetNormalize(field) {\n        if (typeof field !== 'string') {\n            // If user is updating multiple properties in one go using an object, we help out\n            // by filling out missing schedule related data\n            let { startDate, endDate, duration, durationUnit = this.durationUnit } = field;\n            // Conversion is usually handled in inSet, but we are normalizing prior to that and have to handle it here\n            if (typeof startDate === 'string') {\n                startDate = this.getFieldDefinition('startDate').convert(startDate);\n            }\n            if (typeof endDate === 'string') {\n                endDate = this.getFieldDefinition('endDate').convert(endDate);\n            }\n            if ('duration' in field) {\n                if (startDate && !endDate) {\n                    endDate = DH.add(startDate, duration, durationUnit, true, true);\n                }\n                if (!startDate && endDate) {\n                    startDate = DH.add(endDate, -duration, durationUnit, true, true);\n                }\n            }\n            else if (startDate && endDate) {\n                // Calculate duration in hours and covert to target duration unit in order to avoid extra DST conversion\n                duration = DH.as(durationUnit, DH.diff(startDate, endDate, 'h', true), 'h');\n            }\n            // A framework (React tested) may freeze passed field object, so clone it in that case\n            const fieldOrClone = Object.isFrozen(field) ? ObjectHelper.clone(field) : field;\n            startDate && (fieldOrClone.startDate = startDate);\n            endDate && (fieldOrClone.endDate = endDate);\n            duration != null && (fieldOrClone.duration = duration);\n            return fieldOrClone;\n        }\n    }\n    fieldToKeys(field, value) {\n        const result = super.fieldToKeys(field, value);\n        // Replace fullDuration with duration and durationUnit in calls to `set()`\n        if (result.fullDuration) {\n            const { magnitude, unit } = result.fullDuration;\n            result.duration     = magnitude;\n            result.durationUnit = unit;\n        }\n        // Engine handles this for event & tasks\n        if (!this.isEventModel && !this.isTaskModel) {\n            // Recalculate start/end date if duration is set with only one of them\n            if (('duration' in result || result.durationUnit) && !(result.startDate && result.endDate)) {\n                Object.assign(\n                    result,\n                    this.updateDatesFromDuration(\n                        result.duration ?? this.duration,\n                        result.durationUnit ?? this.durationUnit,\n                        result.startDate,\n                        result.endDate\n                    )\n                );\n            }\n        }\n        return result;\n    }\n    inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly) {\n        if (!skipAccessors) {\n            field = this.inSetNormalize(field) || field;\n        }\n        return super.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly);\n    }\n    // Cls requires special handling since it is converted to a DomClassList\n    applyValue(useProp, key, value, skipAccessors, field) {\n        if (key === 'cls') {\n            this.updateInternalCls(value);\n        }\n        // When setting fullDuration with record.set()\n        if (key === 'fullDuration') {\n            this[key] = value;\n        }\n        super.applyValue(useProp, key, value, skipAccessors, field);\n    }\n    //endregion\n    //region Iteration\n    /**\n     * Iterates over the {@link #property-dates}\n     * @param {Function} func The function to call for each date\n     * @param {Object} thisObj `this` reference for the function\n     * @category Scheduling\n     */\n    forEachDate(func, thisObj) {\n        return this.dates.forEach(func.bind(thisObj));\n    }\n    //endregion\n    /**\n     * Checks if the range record has both start and end dates set and start <= end\n     *\n     * @property {Boolean}\n     * @category Scheduling\n     */\n    get isScheduled() {\n        const { startDateMS, endDateMS } = this;\n        return endDateMS - startDateMS >= 0;\n    }\n    // Simple check if end date is greater than start date\n    get isValid() {\n        const { startDate, endDate } = this;\n        return !startDate || !endDate || (endDate - startDate >= 0);\n    }\n    /**\n     * Shift the dates for the date range by the passed amount and unit\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}\n     * for more information on valid formats.\n     * @param {Number} amount The amount to shift\n     */\n    shift(amount, unit = this.durationUnit) {\n        if (typeof amount === 'string') {\n            const u = amount;\n            amount = unit;\n            unit = u;\n        }\n        return this.setStartDate(DH.add(this.startDate, amount, unit, true), true);\n    }\n    /**\n     * Returns the WBS code of this model (e.g '2.1.3'). Only relevant when part of a tree store, as in the Gantt chart.\n     * @property {String}\n     * @category Parent & children\n     */\n    get wbsCode() {\n        return this._wbsCode || this.indexPath.join('.');\n    }\n    set wbsCode(value) {\n        // wbsCode needs to be writable to interop w/TaskModel and Baselines which copy this field value\n        this._wbsCode = value;\n    }\n    fullCopy() {\n        //NOT PORTED\n        return this.copy.apply(this, arguments);\n    }\n    intersects(timeSpan) {\n        return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);\n    }\n    intersectsRange(start, end) {\n        const\n            myStart = this.startDate,\n            myEnd   = this.endDate;\n        return myStart && myEnd && DH.intersectSpans(myStart, myEnd, start, end);\n    }\n    /**\n     * Splits this event into two pieces at the desired position.\n     *\n     * @param {Number|String} splitPoint The duration point at which to split this event.\n     *\n     * If less then `1`, this indicates the relative position at which it will be split.\n     * 0.5 means cut it in half.\n     *\n     * If greater than `1`, this indicates the new duration in the current duration units of this event before the split.\n     *\n     * If this is a string, it will be a duration description as described in\n     * {@link Core.helper.DateHelper#function-parseDuration-static}, for example `'15 min'`\n     *\n     * @returns {Scheduler.model.TimeSpan} The newly created split section of the timespan\n     * @category Scheduling\n     */\n    split(splitPoint = 0.5) {\n        const\n            me             = this,\n            clone          = me.copy(),\n            {\n                fullDuration,\n                eventStore,\n                assignmentStore\n            }              = me,\n            oldDuration    = new Duration(fullDuration),\n            cloneDuration  = new Duration(fullDuration);\n        let ownNewDuration,\n            unitsChanged;\n        if (typeof splitPoint === 'string') {\n            ownNewDuration = new Duration(splitPoint);\n            // New duration specified in same time units as current duration\n            if (ownNewDuration.unit === oldDuration.unit) {\n                cloneDuration.magnitude -= ownNewDuration.magnitude;\n            }\n            // New duration is in different units, so convert clone's duration to match\n            else {\n                cloneDuration.magnitude = DH.as(ownNewDuration.unit, oldDuration) - ownNewDuration.magnitude;\n                cloneDuration.unit = ownNewDuration.unit;\n                unitsChanged = true;\n            }\n        }\n        else {\n            ownNewDuration = new Duration(splitPoint > 1 ? splitPoint : me.duration * splitPoint, me.durationUnit);\n            cloneDuration.magnitude -= ownNewDuration.magnitude;\n        }\n        clone.startDate = DH.add(me.startDate, ownNewDuration.magnitude, ownNewDuration.unit);\n        if (unitsChanged) {\n            clone.fullDuration = cloneDuration;\n            me.fullDuration = ownNewDuration;\n        }\n        else {\n            clone.duration = cloneDuration.magnitude;\n            me.duration = ownNewDuration.magnitude;\n        }\n        if (eventStore) {\n            eventStore.add(clone);\n            if (assignmentStore && !eventStore.usesSingleAssignment) {\n                assignmentStore.add(\n                    me.assignments.map(assignment => {\n                        const clonedData = Object.assign({}, assignment.data, {\n                            eventId  : clone.id,\n                            // From engine\n                            event    : null,\n                            resource : null\n                        });\n                        delete clonedData.id;\n                        return clonedData;\n                    })\n                );\n            }\n        }\n        return clone;\n    }\n    toICSString(icsEventConfig = {}) {\n        if (!this.isScheduled) {\n            return '';\n        }\n        const\n            {\n                startDate,\n                endDate\n            }         = this,\n            // To allow testing using a fixed timestamp value\n            timestamp = icsEventConfig.DTSTAMP || DH.format(new Date(), 'uu');\n        delete icsEventConfig.DTSTAMP;\n        let startEnd = {};\n        if (this.allDay) {\n            startEnd = {\n                'DTSTART;VALUE=DATE' : DH.format(startDate, 'u'),\n                'DTEND;VALUE=DATE'   : DH.format(endDate, 'u')\n            };\n        }\n        else {\n            startEnd = {\n                DTSTART : DH.format(startDate, 'uu'),\n                DTEND   : DH.format(endDate, 'uu')\n            };\n        }\n        const\n            version       = (VersionHelper.scheduler && VersionHelper.getVersion('scheduler')) || (VersionHelper.calendar && VersionHelper.getVersion('calendar')) || '',\n            icsWrapConfig = {\n                BEGIN    : 'VCALENDAR',\n                VERSION  : '2.0',\n                CALSCALE : 'GREGORIAN',\n                PRODID   : `-//Bryntum AB//Bryntum Scheduler ${version} //EN`,\n                END      : 'VCALENDAR'\n            },\n            eventConfig   = {\n                BEGIN   : 'VEVENT',\n                UID     : this.id + '@bryntum.com',\n                CLASS   : 'PUBLIC',\n                SUMMARY : this.name,\n                DTSTAMP : timestamp,\n                ...startEnd,\n                ...(this.recurrenceRule ? { RRULE : this.recurrenceRule } : {}),\n                ...icsEventConfig,\n                END     : 'VEVENT'\n            },\n            icsItems      = Object.keys(icsWrapConfig).map(key => `${key}:${icsWrapConfig[key]}`),\n            eventItems    = Object.keys(eventConfig).map(key => `${key}:${eventConfig[key]}`);\n        // Inject event details before the closing VCALENDAR entry\n        icsItems.splice(icsItems.length - 1, 0, ...eventItems);\n        return icsItems.join('\\n');\n    }\n    /**\n     * Triggers a download of this time span in ICS format (for import in Outlook etc.)\n     *\n     * ```javascript\n     * timeSpan.downloadAsICS({\n     *      LOCATION : timeSpan.location\n     *  });\n     * ```\n     * @param {Object<String,String>} [icsEventConfig] A config object with properties to be added in to `BEGIN:VEVENT`\n     * section of the exported event.\n     * @category Misc\n     */\n    exportToICS(icsEventConfig) {\n        if (this.isScheduled) {\n            const blob = new Blob([this.toICSString(icsEventConfig)], { type : 'text/calendar' });\n            BrowserHelper.downloadBlob(blob, (this.name || 'Event') + '.ics');\n        }\n    }\n    /**\n     * Defines if the given event field should be manually editable in UI.\n     * You can override this method to provide your own logic.\n     *\n     * By default the method defines all the event fields as editable.\n     *\n     * @param {String} fieldName Name of the field\n     * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the model has no such field.\n     */\n    isEditable(fieldName) {\n        // return undefined for unknown fields\n        return this.getFieldDefinition(fieldName) ? true : undefined;\n    }\n    isFieldModified(fieldName) {\n        if (fieldName === 'fullDuration') {\n            return super.isFieldModified('duration') || super.isFieldModified('durationUnit');\n        }\n        return super.isFieldModified(fieldName);\n    }\n}\nTimeSpan._$name = 'TimeSpan';", "import Base from '../../../../Core/Base.js';\nconst dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\nconst days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nexport default class RecurrenceDayRuleEncoder extends Base {\n    static decodeDay(rawDay) {\n        let parsedDay,\n            result;\n        if ((parsedDay = dayParseRegExp.exec(rawDay))) {\n            result = [days.indexOf(parsedDay[2])];\n            // optional position number\n            if (parsedDay[1]) {\n                parsedDay[1] = parseInt(parsedDay[1], 10);\n                result.push(parsedDay[1]);\n            }\n        }\n        return result;\n    }\n    static encodeDay(day) {\n        let position;\n        // support decodeDay() result format\n        if (Array.isArray(day)) {\n            [day, position] = day;\n        }\n        return (position ? position.toString() : '') + days[day];\n    }\n    // Turns days values provided as an array of strings (like [`-1MO`, `SU`, `+3FR`])\n    // into an array of [ dayIndex, position ] elements, where:\n    //\n    // - `dayIndex` - zero-based week day index value (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)\n    // - `position` - (optional) 1-based position of the day (integer value (can be both positive and negative))\n    static decode(rawDays) {\n        const result = [];\n        let parsedDay;\n        if (rawDays) {\n            for (let i = 0; i < rawDays.length; i++) {\n                if ((parsedDay = this.decodeDay(rawDays[i]))) {\n                    result.push(parsedDay);\n                }\n            }\n        }\n        return result;\n    }\n    static encode(days) {\n        const result = [];\n        let day;\n        if (days) {\n            for (let i = 0; i < days.length; i++) {\n                if ((day = this.encodeDay(days[i]))) {\n                    result.push(day);\n                }\n            }\n        }\n        return result;\n    }\n};\nRecurrenceDayRuleEncoder._$name = 'RecurrenceDayRuleEncoder';", "import Base from '../../../../Core/Base.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\n/**\n * @module Scheduler/data/util/recurrence/AbstractRecurrenceIterator\n * @private\n */\nconst\n    frequencyToUnitRe = /ly$/i,\n    frequencyToUnit = frequency => {\n        const result = frequency.replace(frequencyToUnitRe, '');\n        return result === 'DAI' ? 'DAY' : result;\n    },\n    fn = (date, counter, isFirst, timeSpan) => timeSpan.buildOccurrence(date, isFirst),\n    captureLastOccurrence = date => lastOccurrenceDate = date;\nlet lastOccurrenceDate;\nexport default class AbstractRecurrenceIterator extends Base {\n    static frequency = 'NONE';\n    static MAX_OCCURRENCES_COUNT = 1000000;\n    static processIterationConfig(config) {\n        const\n            { recurrence } = config,\n            {\n                frequency,\n                interval,\n                timeSpan,\n                endDate : until,\n                count\n            } = recurrence;\n        // Force the correction of the event to be in sync with its recurrence rule\n        // before performing iteration. For example, if the event's configured startDate\n        // is 1st January 2020, and the rule dictates that the event will take place\n        // monthly, every Monday, then the first event is not until Monday 6th January, 2020.\n        if (!config.syncingStartDate && !timeSpan.meta.isSyncedWithRule) {\n            // Do not generate occurrences outside of the specified range\n            const\n                intervalEndDate = DateHelper.add(timeSpan.startDate, interval, frequencyToUnit(frequency)),\n                endDate = DateHelper.min(\n                    intervalEndDate,\n                    config.endDate || intervalEndDate\n                );\n            this.forEachDate({\n                syncingStartDate : true,\n                startDate        : timeSpan.startDate,\n                endDate,\n                recurrence,\n                fn\n            });\n        }\n        // Capture the start after its been synced with its recurrence rule\n        const timeSpanStart = timeSpan.startDate;\n        // Extract the endDate from the config, defaulting to the recurrence UNTIL date\n        let {\n            startDate = timeSpanStart,\n            endDate   = until\n        } = config;\n        // No point in starting the iteration before the event starts\n        if (startDate < timeSpanStart) {\n            startDate = timeSpanStart;\n        }\n        // The recurrence's stop date overrides the configured endDate.\n        if (until) {\n            if (!endDate || endDate > until) {\n                endDate = until;\n            }\n        }\n        // If we are limiting using count and we are not starting from the\n        // first occurrence, then we have to calculate a stop date.\n        // This is because for date ranges in the future we cannot calculate how many\n        // preceding occurrences there may have been.\n        else if (count && startDate > timeSpanStart) {\n            // Iterate the occurrences from the start to capture the last one\n            this.forEachDate({\n                recurrence,\n                fn : captureLastOccurrence\n            });\n            // The date of the last occurrence in the count sequence overrides the configured endDate.\n            if (!endDate || endDate > lastOccurrenceDate) {\n                // since endDate of the provided interval is exclusive add 1 millisecond\n                endDate = new Date(lastOccurrenceDate.getTime() + 1);\n            }\n        }\n        // Preserve the requested start of requested visits.\n        const earliestVisibleDate = startDate;\n        // Unless we are only asked for events which *start* within the time range. we must make\n        // a best attempt to include any occurrences which span the start date.\n        // So if we are asking for events from the 1st of the month, and there's an event\n        // which runs every 2 months from the 15th to the 5th, we must include it. Start the\n        // iteration <interval> full frequency quanta before the requested start.\n        // This will only cause <interval> extra iterations.\n        // We cannot step back to before the event's starting date though.\n        if (!config.startOnly) {\n            startDate = new Date(DateHelper.max(DateHelper.add(startDate, -interval, frequencyToUnit(frequency)), timeSpanStart));\n        }\n        return Object.assign({\n            extraArgs : [],\n            // Only check start date for time spans with 0 duration\n            startOnly : !Boolean(timeSpan.durationMS)\n        }, config, {\n            startDate,\n            endDate,\n            timeSpan,\n            timeSpanStart,\n            earliestVisibleDate,\n            endDateMS             : endDate?.getTime(),\n            timeSpanStartMS       : timeSpanStart.getTime(),\n            earliestVisibleDateMS : earliestVisibleDate.getTime(),\n            durationMS            : timeSpan.durationMS,\n            spansStart            : startDate <= timeSpanStart && endDate > timeSpanStart\n        });\n    }\n    static getOccurrenceIndex(event) {\n        if (event.isOccurrence) {\n            return DateHelper.diff(event.recurringTimeSpan.startDate, event.startDate, frequencyToUnit(event.recurringTimeSpan.recurrence.frequency));\n        }\n    }\n    /**\n     * Returns Nth occurrence of a week day in the provided period of time.\n     * @param  {Date} startDate Period start date.\n     * @param  {Date} endDate   Period end date.\n     * @param  {Number} day    Week day (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)\n     * @param  {Number} index  Index to find.\n     * @returns {Date}           Returns the found date or null if there is no `index`th entry.\n     * @private\n     */\n    static getNthDayInPeriod(startDate, endDate, day, index) {\n        let result, sign, borderDate;\n        if (index) {\n            if (index > 0) {\n                sign = 1;\n                borderDate = startDate;\n            }\n            else {\n                sign = -1;\n                borderDate = endDate;\n            }\n            // delta between requested day and border day\n            const delta = day - borderDate.getDay();\n            // if the requested day goes after (before, depending on borderDate used (start/end))\n            // we adjust index +/-1\n            if (sign * delta < 0) {\n                index += sign;\n            }\n            // measure \"index\" weeks forward (or backward) ..take delta into account\n            // result = new Date(borderDate.getTime() + ((index - sign) * 7 + delta) * 24*60*60*1000);\n            // Per https://github.com/bryntum/support/issues/3413 - don't do that ^^ because DST makes days/week\n            // alternatingly shorter or longer depending on going in/out of DST:\n            result = new Date(borderDate);\n            result.setDate(borderDate.getDate() + (index - sign) * 7 + delta);\n            // if resulting date is outside of the provided range there is no \"index\"-th entry\n            // of the day\n            if (result < startDate || result > endDate) {\n                result = null;\n            }\n        }\n        return result;\n    }\n    static buildDate(year, month, date) {\n        const dt = new Date(year, month, date);\n        if (dt.getFullYear() === year && dt.getMonth() === month && dt.getDate() === date) {\n            return dt;\n        }\n    }\n    static isValidPosition(position) {\n        return Boolean(position);\n    }\n    static forEachDateAtPositions(dates, positions, fn, scope) {\n        const datesLength = dates.length,\n            processed     = {};\n        for (let i = 0; i < positions.length; i++) {\n            const index = positions[i];\n            if (this.isValidPosition(index)) {\n                const date = index > 0 ? dates[index - 1] : dates[datesLength + index];\n                if (date && !processed[date.getTime()]) {\n                    // remember that we've returned the date\n                    processed[date.getTime()] = true;\n                    // return false if it's time to stop recurring\n                    if (fn.call(scope, date) === false) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    static isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan) {\n        return (\n            startOnly\n                ? occurrenceDate >= earliestVisibleDate\n                : occurrenceDate.valueOf() + durationMS > earliestVisibleDate\n        ) && !timeSpan.hasException(occurrenceDate);\n    }\n    // Slightly faster version of ^, used by Daily & Weekly iterators\n    static isInViewMS(startOnly, occurenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan) {\n        return (\n            startOnly\n                ? occurrenceDateMS >= earliestVisibleDateMS\n                : occurrenceDateMS + durationMS > earliestVisibleDateMS\n        ) && !timeSpan.hasException(occurenceDate);\n    }\n}\nAbstractRecurrenceIterator._$name = 'AbstractRecurrenceIterator';", "/**\n * @module Scheduler/data/util/recurrence/DailyRecurrenceIterator\n */\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class DailyRecurrenceIterator extends AbstractRecurrenceIterator {\n    static frequency = 'DAILY';\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts a recurring event which matches the passed recurrence rule and overlaps the start and end dates\n     * and is not an {@link Scheduler.model.mixin.RecurringTimeSpan#field-exceptionDates exceptionDate}\n     * in the recurring event.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDate,\n                endDateMS,\n                timeSpan,\n                timeSpanStart,\n                earliestVisibleDateMS,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }                = this.processIterationConfig(config),\n            { interval }     = recurrence,\n            delay            = startDate - timeSpanStart,\n            // recurrence interval duration in ms (86400000 is a single day duration in ms)\n            intervalDuration = interval * 86400000,\n            delayInIntervals = Math.floor(delay / intervalDuration);\n        let { count }       = recurrence,\n            counter         = 0,\n            occurrenceDate  = DateHelper.add(timeSpanStart, delayInIntervals * interval, 'day'),\n            occurrenceDateMS = occurrenceDate.getTime();\n        if (!endDate && !count) {\n            count = this.MAX_OCCURRENCES_COUNT;\n        }\n        while (!endDateMS || occurrenceDateMS < endDateMS) {\n            const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);\n            counter++;\n            if (inView &&\n                ((endDateMS && occurrenceDateMS > endDateMS) || fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || (count && counter >= count))\n            ) {\n                break;\n            }\n            // shift to the next day\n            occurrenceDate = DateHelper.add(occurrenceDate, interval, 'day');\n            occurrenceDateMS = occurrenceDate.getTime();\n        }\n    }\n}\nDailyRecurrenceIterator._$name = 'DailyRecurrenceIterator';", "/**\n * @module Scheduler/data/util/recurrence/WeeklyRecurrenceIterator\n */\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class WeeklyRecurrenceIterator extends AbstractRecurrenceIterator {\n    static frequency = 'WEEKLY';\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts an event which matches the passed recurrence rule and overlaps the start and end dates.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDateMS,\n                timeSpan,\n                timeSpanStart,\n                timeSpanStartMS,\n                earliestVisibleDateMS,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }                     = this.processIterationConfig(config),\n            {\n                interval,\n                days\n            }                     = recurrence,\n            { weekStartDay }      = DateHelper,\n            startHours            = timeSpanStart.getHours(),\n            startMinutes          = timeSpanStart.getMinutes(),\n            startSeconds          = timeSpanStart.getSeconds(),\n            startMS               = timeSpanStart.getMilliseconds();\n        let counter    = 0,\n            { count }  = recurrence,\n            weekDays   = DayRuleEncoder.decode(days),\n            weekStartDate, occurrenceDate;\n        // \"Days\" might be skipped then we use the event start day\n        if (!weekDays?.length) {\n            weekDays = [[timeSpanStart.getDay()]];\n        }\n        // If week start day is not zero (Sunday)\n        // we need to normalize weekDays array since its values are used\n        // to calculate real dates as: date = week_start_date + weekDay_entry\n        // which does not work when week starts on non-Sunday\n        if (weekStartDay > 0) {\n            for (let i = 0; i < weekDays.length; i++) {\n                if (weekStartDay > weekDays[i][0]) {\n                    weekDays[i][0] = 7 - weekStartDay - weekDays[i][0];\n                }\n                else {\n                    weekDays[i][0] -= weekStartDay;\n                }\n            }\n        }\n        // days could be provided in any order so it's important to sort them\n        weekDays.sort((a, b) => a[0] - b[0]);\n        // if the recurrence is limited w/ \"Count\" or not every interval should match\n        // we need to 1st count passed occurrences so we always start iteration from the event start date\n        weekStartDate = DateHelper.getNext(count || interval > 1 ? timeSpanStart : startDate, 'week', 0);\n        if (!endDateMS && !count) {\n            count = this.MAX_OCCURRENCES_COUNT;\n        }\n        while (!endDateMS || weekStartDate.getTime() < endDateMS) {\n            for (let i = 0; i < weekDays.length; i++) {\n                // Faster than chaining multiple DateHelper calls\n                occurrenceDate = new Date(\n                    weekStartDate.getFullYear(),\n                    weekStartDate.getMonth(),\n                    weekStartDate.getDate() + weekDays[i][0],\n                    startHours,\n                    startMinutes,\n                    startSeconds,\n                    startMS\n                );\n                const occurrenceDateMS = occurrenceDate.getTime();\n                if (occurrenceDateMS >= timeSpanStartMS) {\n                    const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);\n                    counter++;\n                    if (inView &&\n                        ((endDateMS && occurrenceDateMS >= endDateMS) ||\n                        (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) ||\n                        (count && counter >= count))\n                    ) {\n                        return;\n                    }\n                }\n            }\n            // get next week start\n            weekStartDate = DateHelper.getNext(weekStartDate, 'week', interval);\n        }\n    }\n}\nWeeklyRecurrenceIterator._$name = 'WeeklyRecurrenceIterator';", "/**\n * @module Scheduler/data/util/recurrence/MonthlyRecurrenceIterator\n */\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class MonthlyRecurrenceIterator extends AbstractRecurrenceIterator {\n    static frequency = 'MONTHLY';\n    static getNthDayOfMonth(date, dayNum) {\n        const daysInMonth = DateHelper.daysInMonth(date);\n        let result = null;\n        if (dayNum && Math.abs(dayNum) <= daysInMonth) {\n            result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);\n        }\n        return result;\n    }\n    static isValidPosition(position) {\n        return position && Math.abs(position) > 0 && Math.abs(position) <= 31;\n    }\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts an event which matches the passed recurrence rule and overlaps the start and end dates.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDate,\n                timeSpan,\n                timeSpanStart,\n                earliestVisibleDate,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }              = this.processIterationConfig(config),\n            {\n                interval,\n                days,\n                count,\n                positions\n            } = recurrence,\n            weekDays       = DayRuleEncoder.decode(days),\n            hasPositions   = positions && positions.length,\n            processedDate  = {};\n        let\n            { monthDays }  = recurrence,\n            counter        = 0,\n            weekDayPosition,\n            monthStartDate, monthEndDate,\n            dates, occurrenceDate, i;\n        // if the recurrence is limited w/ \"Count\" or not every interval should match\n        // we need to 1st count passed occurrences so we always start iteration from the event start date\n        monthStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, 'month');\n        monthEndDate   = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);\n        // If no month days nor week days are provided let's use event start date month day\n        if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {\n            monthDays = [timeSpanStart.getDate()];\n        }\n        if (weekDays && weekDays.length) {\n            // Collect hash of positions indexed by week days\n            weekDays.forEach(day => {\n                if (day[1]) {\n                    weekDayPosition         = weekDayPosition || {};\n                    weekDayPosition[day[0]] = day[1];\n                }\n            });\n        }\n        while ((!endDate || endDate > monthStartDate) && (!count || counter < count)) {\n            dates = [];\n            if (weekDays && weekDays.length) {\n                weekDays.forEach(day => {\n                    const weekDay = day[0];\n                    let from    = 1,\n                        till    = 53;\n                    // if position provided\n                    if (day[1]) {\n                        from = till = day[1];\n                    }\n                    for (i = from; i <= till; i++) {\n                        if ((occurrenceDate = this.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i))) {\n                            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);\n                            if (!processedDate[occurrenceDate.getTime()]) {\n                                // remember we processed the date\n                                processedDate[occurrenceDate.getTime()] = true;\n                                dates.push(occurrenceDate);\n                            }\n                        }\n                    }\n                });\n                dates.sort((a, b) => a - b);\n                if (!hasPositions) {\n                    for (i = 0; i < dates.length; i++) {\n                        occurrenceDate = dates[i];\n                        if (occurrenceDate >= timeSpanStart) {\n                            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);\n                            counter++;\n                            if (inView &&\n                                ((endDate && occurrenceDate >= endDate) || (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) || (count && counter >= count))\n                            ) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                const sortedMonthDates = [];\n                for (i = 0; i < monthDays.length; i++) {\n                    // check if the date wasn't iterated over yet\n                    if ((occurrenceDate = this.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[occurrenceDate.getTime()]) {\n                        processedDate[occurrenceDate.getTime()] = true;\n                        sortedMonthDates.push(occurrenceDate);\n                    }\n                }\n                // it's important to sort the dates to iterate over them in the proper order\n                sortedMonthDates.sort((a, b) => a - b);\n                for (i = 0; i < sortedMonthDates.length; i++) {\n                    occurrenceDate = DateHelper.copyTimeValues(sortedMonthDates[i], timeSpanStart);\n                    if (hasPositions) {\n                        dates.push(occurrenceDate);\n                    }\n                    else if (occurrenceDate >= timeSpanStart) {\n                        const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);\n                        counter++;\n                        if (inView &&\n                            ((endDate && occurrenceDate > endDate) || (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) || (count && counter >= count))\n                        ) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (hasPositions && dates.length) {\n                this.forEachDateAtPositions(dates, positions, occurrenceDate => {\n                    if (occurrenceDate >= timeSpanStart) {\n                        const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);\n                        counter++;\n                        // Ignore dates outside of the [startDate, endDate] range\n                        if (inView && (!endDate || occurrenceDate <= endDate) &&\n                            // return false if it's time to stop recurring\n                            (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || (count && counter >= count))\n                        ) {\n                            return false;\n                        }\n                    }\n                });\n            }\n            // get next month start\n            monthStartDate = DateHelper.getNext(monthStartDate, 'month', interval);\n            monthEndDate   = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);\n        }\n    }\n}\nMonthlyRecurrenceIterator._$name = 'MonthlyRecurrenceIterator';", "/**\n * @module Scheduler/data/util/recurrence/YearlyRecurrenceIterator\n */\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class YearlyRecurrenceIterator extends AbstractRecurrenceIterator {\n    static frequency = 'YEARLY';\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts an event which matches the passed recurrence rule and overlaps the start and end dates.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDate,\n                timeSpan,\n                timeSpanStart,\n                earliestVisibleDate,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }              = this.processIterationConfig(config),\n            {\n                interval,\n                days,\n                count,\n                positions\n            } = recurrence,\n            weekDays       = DayRuleEncoder.decode(days),\n            hasPositions   = positions && positions.length,\n            processedDate  = {};\n        let\n            { months }     = recurrence,\n            counter        = 0,\n            i, occurrenceDate, dates, yearStartDate, yearEndDate, weekDayPosition;\n        // if the recurrence is limited w/ \"Count\" or not every interval should match\n        // we need to 1st count passed occurrences so we always start iteration from the event start date\n        yearStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, 'year');\n        yearEndDate   = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);\n        months && months.sort((a, b) => a - b);\n        // if no months provided let's use the event month\n        if (!(months && months.length) && !(weekDays && weekDays.length)) {\n            months = [timeSpanStart.getMonth() + 1];\n        }\n        if (weekDays && weekDays.length) {\n            // Collect hash of positions indexed by week days\n            weekDays.forEach(day => {\n                if (day[1]) {\n                    weekDayPosition         = weekDayPosition || {};\n                    weekDayPosition[day[0]] = day[1];\n                }\n            });\n        }\n        while ((!endDate || endDate > yearStartDate) && (!count || counter < count)) {\n            dates = [];\n            if (weekDays && weekDays.length) {\n                weekDays.forEach(day => {\n                    const weekDay = day[0];\n                    let\n                        from = 1,\n                        till = 53;\n                    // if position provided\n                    if (day[1]) {\n                        from = till = day[1];\n                    }\n                    for (i = from; i <= till; i++) {\n                        if ((occurrenceDate = this.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i))) {\n                            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);\n                            if (!processedDate[occurrenceDate.getTime()]) {\n                                // remember we processed the date\n                                processedDate[occurrenceDate.getTime()] = true;\n                                dates.push(occurrenceDate);\n                            }\n                        }\n                    }\n                });\n                dates.sort((a, b) => a - b);\n                if (!hasPositions) {\n                    for (i = 0; i < dates.length; i++) {\n                        occurrenceDate = dates[i];\n                        if (occurrenceDate >= timeSpanStart) {\n                            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);\n                            counter++;\n                            if (inView &&\n                                ((endDate && occurrenceDate >= endDate) ||\n                                (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) ||\n                                (count && counter >= count))\n                            ) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                for (i = 0; i < months.length; i++) {\n                    if ((occurrenceDate = this.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate()))) {\n                        occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);\n                        // check if the date wasn't iterated over yet\n                        if (!processedDate[occurrenceDate.getTime()]) {\n                            processedDate[occurrenceDate.getTime()] = true;\n                            if (hasPositions) {\n                                dates.push(occurrenceDate);\n                            }\n                            else if (occurrenceDate >= timeSpanStart) {\n                                const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);\n                                counter++;\n                                if (inView &&\n                                    ((endDate && occurrenceDate >= endDate) ||\n                                    (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) ||\n                                    (count && counter >= count))\n                                ) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (hasPositions && dates.length) {\n                this.forEachDateAtPositions(dates, positions, occurrenceDate => {\n                    if (occurrenceDate >= timeSpanStart) {\n                        const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);\n                        counter++;\n                        // Ignore dates outside of the [startDate, endDate] range\n                        if (inView && (!endDate || occurrenceDate < endDate)) {\n                            // return false if it's time to stop recurring\n                            if (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || (count && counter >= count)) {\n                                return false;\n                            }\n                        }\n                    }\n                });\n            }\n            // get next month start\n            yearStartDate = DateHelper.getNext(yearStartDate, 'year', interval);\n            yearEndDate   = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);\n        }\n    }\n}\nYearlyRecurrenceIterator._$name = 'YearlyRecurrenceIterator';", "import Model from '../../Core/data/Model.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport RecurrenceDayRuleEncoder from '../data/util/recurrence/RecurrenceDayRuleEncoder.js';\nimport DailyRecurrenceIterator from '../data/util/recurrence/DailyRecurrenceIterator.js';\nimport WeeklyRecurrenceIterator from '../data/util/recurrence/WeeklyRecurrenceIterator.js';\nimport MonthlyRecurrenceIterator from '../data/util/recurrence/MonthlyRecurrenceIterator.js';\nimport YearlyRecurrenceIterator from '../data/util/recurrence/YearlyRecurrenceIterator.js';\n/**\n * @module Scheduler/model/RecurrenceModel\n */\nconst recurrenceIterators = {};\n[DailyRecurrenceIterator, WeeklyRecurrenceIterator, MonthlyRecurrenceIterator, YearlyRecurrenceIterator].forEach(it => {\n    recurrenceIterators[it.frequency] = it;\n});\nfunction convertStringOfIntegerItemsValue(value) {\n    if (value) {\n        if (typeof value == 'string') {\n            value = value.split(',').map(item => parseInt(item, 10));\n        }\n    }\n    else {\n        value = null;\n    }\n    return value;\n}\nfunction convertStringOfItemsValue(value) {\n    if (value) {\n        if (typeof value == 'string') {\n            value = value.split(',');\n        }\n    }\n    else {\n        value = null;\n    }\n    return value;\n}\nfunction isEqualAsString(value1, value2) {\n    return String(value1) === String(value2);\n}\nfunction convertInteger(value) {\n    if (this.defaultValue && value === undefined) {\n        return this.defaultValue;\n    }\n    if (this.allowNull && value == null) {\n        return null;\n    }\n    value = parseInt(value);\n    return isNaN(value) ? undefined : value;\n}\n/**\n * This class represents a timespan recurrence settings.\n * It is a subclass of {@link Core.data.Model} class.\n * Please refer to the documentation for that class to become familiar with the base interface of this class.\n *\n * The data source for these fields can be customized by subclassing this class.\n *\n * @extends Core/data/Model\n */\nexport default class RecurrenceModel extends Model {\n    static get $name() {\n        return 'RecurrenceModel';\n    }\n    /**\n     * Indicates that this is a `RecurrenceModel` class instance\n     * (allows to avoid using `instanceof`).\n     * @property {Boolean}\n     * @readonly\n     */\n    get isRecurrenceModel() {\n        return true;\n    }\n    //region Fields\n    static get fields() {\n        return [\n            /**\n             * Field defines the recurrence frequency. Supported values are: `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.\n             * @field {'DAILY'|'WEEKLY'|'MONTHLY'|'YEARLY'} frequency\n             */\n            { name : 'frequency', defaultValue : 'DAILY' },\n            /**\n             * Field defines how often the recurrence repeats.\n             * For example, if the recurrence is weekly its interval is 2, then the timespan repeats every two weeks.\n             * @field {Number} interval\n             */\n            { name : 'interval', defaultValue : 1, convert : convertInteger },\n            /**\n             * End date of the recurrence. Specifies when the recurrence ends.\n             * The value is optional, the recurrence can as well be stopped using {@link #field-count} field value.\n             * @field {Date} endDate\n             */\n            { name : 'endDate', type : 'date' },\n            /**\n             * Specifies the number of occurrences after which the recurrence ends.\n             * The value includes the associated timespan itself so values less than 2 make no sense.\n             * The field is optional, the recurrence as well can be stopped using {@link #field-endDate} field value.\n             * @field {Number} count\n             */\n            { name : 'count', allowNull : true, convert : convertInteger },\n            /**\n             * Specifies days of the week on which the timespan should occur.\n             * An array of string values `SU`, `MO`, `TU`, `WE`, `TH`, `FR`, `SA`\n             * corresponding to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday days of the week.\n             * Each value can also be preceded by a positive (+n) or negative (-n) integer.\n             * If present, this indicates the nth occurrence of a specific day within the monthly or yearly recurrence.\n             *\n             * **Not applicable** for daily {@link #field-frequency}.\n             * @field {String[]} days\n             */\n            {\n                name    : 'days',\n                convert : convertStringOfItemsValue,\n                isEqual : isEqualAsString\n            },\n            /**\n             * Specifies days of the month on which the timespan should occur.\n             * An array of integer values (-31..-1 - +1..+31, negative values mean counting backwards from the month end).\n             * **Applicable only** for monthly {@link #field-frequency}.\n             * @field {Number[]} monthDays\n             */\n            {\n                name    : 'monthDays',\n                convert : convertStringOfIntegerItemsValue,\n                isEqual : isEqualAsString\n            },\n            /**\n             * Specifies months of the year on which the timespan should occur.\n             * An array of integer values (1 - 12).\n             * **Applicable only** for yearly {@link #field-frequency}.\n             * @field {Number[]} months\n             */\n            {\n                name    : 'months',\n                convert : convertStringOfIntegerItemsValue,\n                isEqual : isEqualAsString\n            },\n            /**\n             * The positions to include in the recurrence. The values operate on a set of recurrence instances **in one interval** of the recurrence rule.\n             * An array of integer values (valid values are 1 to 366 or -366 to -1, negative values mean counting backwards from the end of the built list of occurrences).\n             * **Not applicable** for daily {@link #field-frequency}.\n             * @field {Number} positions\n             */\n            {\n                name    : 'positions',\n                convert : convertStringOfIntegerItemsValue,\n                isEqual : isEqualAsString\n            }\n        ];\n    }\n    get dateFormat() {\n        return this._dateFormat || 'YYYYMMDDTHHmmss';\n    }\n    set dateFormat(format) {\n        this._dateFormat = format;\n    }\n    get recurrenceIterator() {\n        return recurrenceIterators[this.frequency];\n    }\n    /**\n     * The timespan this recurrence is associated with.\n     * @property {Scheduler.model.TimeSpan}\n     */\n    get timeSpan() {\n        return this._timeSpan;\n    }\n    set timeSpan(value) {\n        this._timeSpan = value;\n    }\n    /**\n     * The recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format\n     * (\"RRULE\" expression).\n     * @property {String}\n     */\n    get rule() {\n        const\n            me     = this,\n            result = [];\n        if (me.frequency) {\n            result.push(`FREQ=${me.frequency}`);\n            if (me.interval > 1) {\n                result.push(`INTERVAL=${me.interval}`);\n            }\n            if (me.days && me.days.length) {\n                result.push('BYDAY=' + me.days.join(','));\n            }\n            if (me.monthDays && me.monthDays.length) {\n                result.push('BYMONTHDAY=' + me.monthDays.join(','));\n            }\n            if (me.months && me.months.length) {\n                result.push('BYMONTH=' + me.months.join(','));\n            }\n            if (me.count) {\n                result.push(`COUNT=${me.count}`);\n            }\n            if (me.endDate) {\n                result.push('UNTIL=' + DateHelper.format(me.endDate, me.dateFormat));\n            }\n            if (me.positions && me.positions.length) {\n                result.push('BYSETPOS=' + me.positions.join(','));\n            }\n        }\n        return result.join(';');\n    }\n    set rule(rule) {\n        const\n            me     = this,\n            values = {\n                frequency : null,\n                interval  : null,\n                count     : null,\n                endDate   : null,\n                days      : null,\n                monthDays : null,\n                months    : null,\n                positions : null\n            };\n        me.beginBatch();\n        if (rule) {\n            const parts = rule.split(';');\n            for (let i = 0, len = parts.length; i < len; i++) {\n                const\n                    part = parts[i].split('='),\n                    value  = part[1];\n                switch (part[0]) {\n                    case 'FREQ':\n                        values.frequency = value;\n                        break;\n                    case 'INTERVAL':\n                        values.interval = value;\n                        break;\n                    case 'COUNT':\n                        values.count = value;\n                        values.until = null;\n                        break;\n                    case 'UNTIL':\n                        if (value) {\n                            values.endDate = DateHelper.parse(value, me.dateFormat);\n                        }\n                        else {\n                            values.endDate = null;\n                        }\n                        values.count = null;\n                        break;\n                    case 'BYDAY':\n                        values.days = value;\n                        break;\n                    case 'BYMONTHDAY':\n                        values.monthDays = value;\n                        break;\n                    case 'BYMONTH':\n                        values.months = value;\n                        break;\n                    case 'BYSETPOS':\n                        values.positions = value;\n                        break;\n                }\n            }\n        }\n        me.set(values);\n        if (rule) {\n            me.sanitize();\n        }\n        me.endBatch();\n    }\n    construct(data = {}) {\n        const\n            me                 = this,\n            { rule, timeSpan } = data;\n        me._suspendedTimeSpanNotifying = 0;\n        delete data.timeSpan;\n        delete data.rule;\n        super.construct(...arguments);\n        if (rule) {\n            me.suspendTimeSpanNotifying();\n            me.rule = rule;\n            me.resumeTimeSpanNotifying();\n        }\n        me.timeSpan = timeSpan;\n    }\n    /**\n     * Iterate occurrences for the owning timespan across the specified date range. This method can be called even\n     * if the timespan is not yet a member of a store, however, the occurrences returned will not be cached across\n     * subsequent calls to this method.\n     * @param {Date} startDate The start date of the iteration.\n     * @param {Date} endDate The end date of the iteration.\n     * @param {Function} fn The function to call for each occurrence.\n     * @param {Scheduler.model.TimeSpan} fn.occurrence The occurrence.\n     * @param {Boolean} fn.first A flag which is `true` for the first occurrence of this recurrence.\n     * @param {Number} fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Date} fn.date The occurrence date.\n     * @internal\n     */\n    forEachOccurrence(startDate, endDate, fn) {\n        if (this.timeSpan.startDate) {\n            this.recurrenceIterator.forEachDate({\n                recurrence : this,\n                startDate,\n                endDate,\n                fn(date, counter, first, timeSpan) {\n                    return fn(timeSpan.buildOccurrence(date, first), first, counter, date);\n                }\n            });\n        }\n    }\n    /**\n     * Cleans up fields that do not makes sense for the current {@link #field-frequency} value.\n     * @private\n     */\n    sanitize() {\n        const\n            me                = this,\n            timeSpanStartDate = me.timeSpan?.startDate,\n            values            = {};\n        me.isSanitizing = true;\n        switch (me.frequency) {\n            case 'DAILY' :\n                values.positions    = null;\n                values.days         = null;\n                values.monthDays    = null;\n                values.months       = null;\n                break;\n            case 'WEEKLY' : {\n                values.positions = null;\n                values.monthDays = null;\n                values.months = null;\n                const { days } = me;\n                if (timeSpanStartDate && days?.length === 1 && days[0] === RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {\n                    values.days = null;\n                }\n                break;\n            }\n            case 'MONTHLY' : {\n                if (me.monthDays?.length) {\n                    values.positions = null;\n                    values.days = null;\n                }\n                values.months = null;\n                const { monthDays } = me;\n                if (timeSpanStartDate && monthDays?.length === 1 && monthDays[0] === timeSpanStartDate.getDate()) {\n                    values.monthDays = null;\n                }\n                break;\n            }\n            case 'YEARLY' : {\n                values.monthDays = null;\n                const { months } = me;\n                if (timeSpanStartDate && months?.length === 1 && months[0] === timeSpanStartDate.getMonth() + 1) {\n                    values.months = null;\n                }\n                break;\n            }\n        }\n        me.set(values);\n        me.isSanitizing = false;\n    }\n    copy(...args) {\n        const result = super.copy(...args);\n        result.dateFormat = this.dateFormat;\n        result.timeSpan   = this.timeSpan;\n        return result;\n    }\n    afterChange(toSet, wasSet, silent) {\n        const\n            result       = super.afterChange(toSet, wasSet, silent),\n            { timeSpan } = this;\n        if (!this.isSanitizing) {\n            // cleanup data to match the chosen frequency\n            this.sanitize();\n        }\n        if (timeSpan) {\n            timeSpan.sanitizeRecurrenceData(this);\n            if (!this.isTimeSpanNotifyingSuspended) {\n                timeSpan.onRecurrenceChanged();\n            }\n        }\n        return result;\n    }\n    set(field, value, ...args) {\n        const values = typeof field === 'object' ? field : { [field] : value };\n        // reset \"endDate\" field if \"count\" is being set\n        if (values.count) {\n            values.endDate = null;\n        }\n        // reset \"count\" field if \"endDate\" is being set\n        else if (values.endDate) {\n            values.count = null;\n        }\n        super.set(values, undefined, ...args);\n    }\n    get isTimeSpanNotifyingSuspended() {\n        return Boolean(this._suspendedTimeSpanNotifying);\n    }\n    suspendTimeSpanNotifying() {\n        this._suspendedTimeSpanNotifying++;\n    }\n    resumeTimeSpanNotifying() {\n        if (this._suspendedTimeSpanNotifying) this._suspendedTimeSpanNotifying--;\n    }\n}\nRecurrenceModel._$name = 'RecurrenceModel';", "import TimeSpan from '../TimeSpan.js';\nimport RecurrenceModel from '../RecurrenceModel.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AbstractRecurrenceIterator from '../../data/util/recurrence/AbstractRecurrenceIterator.js';\nfunction convertExceptionDatesValue(value) {\n    const\n        result         = {},\n        { dateFormat } = this;\n    if (value) {\n        value = typeof value == 'string' ? value.split(',') : ArrayHelper.asArray(value);\n        value.forEach(item => {\n            if (typeof item == 'string') {\n                item = DateHelper.parse(item, dateFormat);\n            }\n            // If we've got a valid date out of the incoming item, add an exception key\n            if (!isNaN(item)) {\n                result[DateHelper.makeKey(item)] = 1;\n            }\n        });\n    }\n    return result;\n}\nfunction serializeExceptionDatesValue(value) {\n    const\n        result         = [],\n        { dateFormat } = this;\n    for (const date in value) {\n        if (value[date]) {\n            result.push(DateHelper.format(DateHelper.parseKey(date), dateFormat));\n        }\n    }\n    return result;\n}\nconst emptyArray = [];\n/**\n * @module Scheduler/model/mixin/RecurringTimeSpan\n */\n/**\n * This mixin class provides recurrence related fields and methods to a {@link Scheduler.model.TimeSpan timespan model}.\n *\n * The mixin introduces two types of timespans: __recurring timespan__ and its __occurrences__.\n * __Recurring timespan__ is a timespan having {@link #field-recurrenceRule recurrence rule} specified and its __occurrences__ are \"fake\" dynamically generated timespans.\n * Their set depends on the scheduler visible timespan and changes upon the timespan change.\n *\n * There are few methods allowing to distinguish a recurring event and an occurrence: {@link #property-isRecurring}, {@link #property-isOccurrence}\n * and {@link #property-recurringTimeSpan} (returns the event this record is an occurrence of).\n *\n * The {@link #field-recurrenceRule recurrence rule} defined for the event is parsed and\n * represented with {@link Scheduler.model.RecurrenceModel RecurrenceModel} class (can be changed by setting {@link #property-recurrenceModel} property) instance.\n * See: {@link #property-recurrence} property.\n * @mixin\n * @mixinbase TimeSpan\n */\nexport default Target => class RecurringTimeSpan extends (Target || TimeSpan) {\n    static get $name() {\n        return 'RecurringTimeSpan';\n    }\n    /**\n     * Returns `true` if this timespan supports recurring.\n     * @property {Boolean}\n     * @category Recurrence\n     */\n    get supportsRecurring() {\n        return true;\n    }\n    static get fields() {\n        return [\n            /**\n             * The timespan recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10)\n             * described format (\"RRULE\" expression).\n             * @field {String} recurrenceRule\n             * @category Scheduling\n             */\n            {\n                name     : 'recurrenceRule',\n                internal : true\n            },\n            /**\n             * A string (either a single date or multiple dates separated by comma) or an array of strings containing\n             * the timespan exception dates. The dates that must be skipped when generating occurrences for a repeating\n             * timespan. This is used to modify only individual occurrences of the timespan so the further regenerations\n             * won't create another copy of this occurrence again.\n             *\n             * ```javascript\n             * {\n             *     id: 7,\n             *     startDate: '2021-10-12T14:00:00',\n             *     endDate: '2021-10-12T15:00:00',\n             *     name: 'Lunch',\n             *     resourceId: 'hotel',\n             *     recurrenceRule: 'FREQ=DAILY;COUNT=5',\n             *     exceptionDates: ['2021-10-14']\n             * }\n             * ```\n             *\n             * Use {@link #function-addExceptionDate} method to add an individual entry to the dates array:\n             *\n             * ```javascript\n             * // Break the link between the occurrence and its base.\n             * // This also adds the occurrence date as an exception date\n             * // so that the base timespan knows that this date should be skipped when regenerating its occurrences.\n             * occurrence.recurringTimeSpan = null;\n             *\n             * // now the occurrence is an individual record that can be changed & persisted freely\n             * occurrence.setStartEndDate(new Date(2018, 6, 2), new Date(2018, 6, 3));\n             * ```\n             * **Note:** The dates in this field get automatically removed when the event changes its {@link Scheduler.model.TimeSpan#field-startDate start date}.\n             *\n             * @field {String|String[]} exceptionDates\n             * @category Scheduling\n             */\n            {\n                name      : 'exceptionDates',\n                convert   : convertExceptionDatesValue,\n                serialize : serializeExceptionDatesValue,\n                internal  : true\n            }\n        ];\n    }\n    /**\n     * Override of {@link Core/data/Model}'s method. If an {@link #property-isOccurrence}\n     * is passed, it is detached from its parent recurring event. If it still has a recurrence\n     * then the recurring event is changed to stop at the occurrence date. If it has no recurrence\n     * an exception is added at the occurrence date.\n     * @category Recurrence\n     */\n    remove() {\n        if (this.isOccurrence) {\n            const\n                me = this,\n                { recurringTimeSpan } = me;\n            me.cancelBatch();\n            recurringTimeSpan.beginBatch();\n            me.detachFromRecurringEvent();\n            recurringTimeSpan.endBatch();\n        }\n        else {\n            return super.remove(...arguments);\n        }\n    }\n    get eventStore() {\n        let result = this.isOccurrence ? this.recurringEvent.eventStore : super.eventStore;\n        // Recurrence methods are called on `eventStore`, but in case we have a regular\n        // store with recurrence mixin, we won't event store and should return own\n        // store instead\n        if (!result && this.firstStore?.isRecurringTimeSpansMixin) {\n            result = this.firstStore;\n        }\n        return result;\n    }\n    /**\n     * Name of the class representing the recurrence model, defaults to {@link Scheduler.model.RecurrenceModel}\n     * @property {String}\n     * @category Recurrence\n     */\n    get recurrenceModel() {\n        return this._recurrenceModel || RecurrenceModel;\n    }\n    set recurrenceModel(model) {\n        this._recurrenceModel = model;\n    }\n    /**\n     * Sets a recurrence for the timespan with a given frequency, interval, and end.\n     * @param {RecurrenceModelConfig|String|Scheduler.model.RecurrenceModel} recurrence A data object for an instance of\n     * {@link Scheduler.model.RecurrenceModel}. May also be the frequency string: `DAILY`, `WEEKLY`, `MONTHLY`, or\n     * `YEARLY`.\n     *\n     * ```javascript\n     * // repeat the event every other week till Jan 2 2039\n     * event.setRecurrence({\n     *     frequency : \"WEEKLY\",\n     *     interval  : 2,\n     *     endDate   : new Date(2039, 0, 2)\n     * });\n     * ```\n     *\n     * Also a {@link Scheduler.model.RecurrenceModel recurrence model} can be provided as the only argument for this\n     * method:\n     *\n     * ```javascript\n     * const recurrence = new RecurrenceModel({ frequency : 'DAILY', interval : 5 });\n     *\n     * event.setRecurrence(recurrence);\n     * ```\n     *\n     * or\n     *\n     * ```javascript\n     * event.setRecurrence(\"WEEKLY\", 2, new Date(2039, 0, 2));\n     * ```\n     * @param {Number} [interval] The interval between occurrences (instances of this recurrence). For example, a daily\n     * recurrence with an interval of 2 occurs every other day. Must be greater than 0.\n     * @param {Number|Date} [recurrenceEnd] The end of the recurrence. The value can be specified by a date or by a\n     * maximum count of occurrences (has to greater than 1, since 1 means the event itself).\n     * @category Recurrence\n     */\n    setRecurrence(recurrence, interval, recurrenceEnd) {\n        const me = this;\n        let recurrenceRule;\n        if (recurrence) {\n            if (!recurrence.isRecurrenceModel) {\n                if (typeof recurrence === 'string') {\n                    recurrence = {\n                        frequency : recurrence\n                    };\n                    if (interval) {\n                        recurrence.interval = interval;\n                    }\n                    // If the recurrence is limited\n                    if (recurrenceEnd) {\n                        if (recurrenceEnd instanceof Date) {\n                            recurrence.endDate = recurrenceEnd;\n                        }\n                        else {\n                            recurrence.count = recurrenceEnd;\n                        }\n                    }\n                }\n                recurrence = new me.recurrenceModel(recurrence);\n            }\n            // The RecurrenceModel has a reference to its owning recurring event.\n            // It uses this to remove the owning event's exceptions after its new endDate\n            // whenever its endDate is changed.\n            recurrence.timeSpan = me;\n            recurrenceRule = recurrence.rule;\n        }\n        me.recurrence     = recurrence;\n        me.recurrenceRule = recurrenceRule;\n    }\n    /**\n     * The recurrence model used for the timespan.\n     * @property {Scheduler.model.RecurrenceModel}\n     * @category Recurrence\n     */\n    get recurrence() {\n        const\n            me = this,\n            rule = me.recurrenceRule;\n        if (!me._recurrence && rule) {\n            me._recurrence = new me.recurrenceModel({ rule, timeSpan : me, id : `${me.id}-recurrence` });\n        }\n        return me._recurrence;\n    }\n    set recurrence(recurrence) {\n        const me = this;\n        me._recurrence = recurrence;\n        if (recurrence) {\n            // bind recurrence instance to the model\n            recurrence.timeSpan = me;\n            me.recurrenceRule   = recurrence.rule;\n        }\n        else {\n            // If this is being done to an occurrence, it's a signal that we are being\n            // mutated into an exception. Apply the change immediately, directly to the data.\n            if (me.isOccurrence) {\n                me.setData('recurrenceRule', null);\n            }\n            else {\n                me.recurrenceRule = null;\n            }\n        }\n    }\n    /**\n     * Indicates if the timespan is recurring.\n     * @property {Boolean}\n     * @readonly\n     * @category Recurrence\n     */\n    get isRecurring() {\n        // MUST evaluate in this order so that if it is an occurrence,\n        // the recurrence getter does not refresh the rule\n        return Boolean(!this.isOccurrence && this.recurrence);\n    }\n    /**\n     * Indicates if the timespan is an occurrence of another recurring timespan.\n     * @property {Boolean}\n     * @readonly\n     * @category Recurrence\n     */\n    get isOccurrence() {\n        return Boolean(this.recurringTimeSpan);\n    }\n    /**\n     * The \"main\" timespan this model is an occurrence of. For non-occurrences returns `null`.\n     * @property {Scheduler.model.TimeSpan}\n     * @readonly\n     * @internal\n     * @category Recurrence\n     */\n    get recurringTimeSpan() {\n        return this._recurringTimeSpan;\n    }\n    get isPersistable() {\n        return super.isPersistable && (!this.supportsRecurring || !this.isOccurrence);\n    }\n    set recurringTimeSpan(recurringTimeSpan) {\n        this._recurringTimeSpan = recurringTimeSpan;\n    }\n    /**\n     * Returns the occurrences of this event over the specified time range. If the first\n     * occurrence is in the time range `*this*` record is included in that position.\n     * @param {Date} startDate The start date of the range for which to include occurrences.\n     * @param {Date} [endDate] The end date of the range for which to include occurrences.\n     * Defaults to the startDate.\n     * @returns {Scheduler.model.TimeSpan[]} The array of occurrences which occur over the specified range.\n     * @category Recurrence\n     */\n    getOccurrencesForDateRange(startDate, endDate = startDate) {\n        return this.eventStore.getOccurrencesForTimeSpan(this, startDate, endDate);\n    }\n    /**\n     * Array of this recurring timespan's cached occurrences. __Not including the owning recurring\n     * event__.\n     *\n     * Empty if the timespan is not recurring.\n     *\n     * __Note that this is an internal accessor and is cleared whenever changes are made to the\n     * owning recurring event__.\n     * @property {Scheduler.model.TimeSpan[]}\n     * @readonly\n     * @internal\n     * @category Recurrence\n     */\n    get occurrences() {\n        if (this.isRecurring) {\n            const result = [];\n            // The occurrencesMap contains entries for each occurrence date.\n            this.occurrenceMap.forEach(occurrence => {\n                if (occurrence !== this) {\n                    result.push(occurrence);\n                }\n            });\n            return result;\n        }\n        return emptyArray;\n    }\n    /**\n     * A Map, keyed by each date an occurrence intersects, of occurrences of this event.\n     * @property {Map}\n     * @readonly\n     * @internal\n     * @category Recurrence\n     */\n    get occurrenceMap() {\n        return this._occurrencesMap || (this._occurrencesMap = new Map());\n    }\n    /**\n     * Removes an occurrence from this recurring timespan's cached occurrences.\n     * @param dateOrTimeSpan occurrence date or occurrence TimeSpan\n     * @internal\n     * @category Recurrence\n     */\n    removeOccurrence(dateOrTimeSpan) {\n        const date = dateOrTimeSpan.isTimeSpan ? dateOrTimeSpan.occurrenceDate : dateOrTimeSpan;\n        // Clear the occurrences *is* we are in an EventStore.\n        this.eventStore?.globalOccurrences.delete(this.createRecurrenceKey(date));\n        // Remove occurrence from its by-startDate cache\n        this.occurrenceMap.delete(DateHelper.makeKey(date));\n    }\n    /**\n     * Removes all cached occurrences on or after the passed date from this recurring timespan's cached occurrences.\n     * @internal\n     * @category Recurrence\n     */\n    removeOccurrencesFrom(date) {\n        this.occurrenceMap.forEach((occurrence, dateKey) => {\n            if (DateHelper.parseKey(dateKey) >= date) {\n                this.removeOccurrence(occurrence);\n            }\n        });\n    }\n    /**\n     * Removes this recurring timespan's cached occurrences.\n     * @internal\n     * @category Recurrence\n     */\n    removeOccurrences() {\n        // This recurring event must also be removed from the occurrenceMap if it's there\n        // So insert it as the first element. Can also be found from the store's global occurrence\n        // Map using [...this.eventStore.globalOccurrences.keys()].filter(e => e.startsWith(`_generated:${this.id}`))\n        [this, ...this.occurrences].forEach(occurrence => this.removeOccurrence(occurrence));\n    }\n    /**\n     * The method is triggered when the timespan recurrence settings get changed.\n     * It updates the {@link #field-recurrenceRule} field in this case.\n     * @internal\n     * @category Recurrence\n     */\n    onRecurrenceChanged() {\n        this.recurrenceRule = this.recurrence?.rule || null;\n    }\n    sanitizeRecurrenceData(recurrence = this.recurrence) {\n        // Remove all exceptionsDates that our owning timeSpan had that are\n        // now after our end date and therefore redundant.\n        if (recurrence.endDate) {\n            const\n                endDate            = DateHelper.clearTime(recurrence.endDate),\n                { exceptionDates } = this;\n            // Clear any now-invalid cached occurrences\n            this.removeOccurrencesFrom(endDate);\n            // If we had any exceptions on or after this date, remove them.\n            if (exceptionDates) {\n                for (const dateKey in exceptionDates) {\n                    const exceptionDate = DateHelper.parseKey(dateKey);\n                    if (exceptionDate >= endDate) {\n                        delete exceptionDates[dateKey];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * The original {@lScheduler.model.TimeSpan#field-startDate startDate} of this event before any modifications\n     * took place. Used by {@link #function-removeOccurrence} and {@link #function-detachFromRecurringEvent}\n     * @internal\n     * @readonly\n     * @category Recurrence\n     */\n    get occurrenceDate() {\n        return this.meta.modified?.startDate || this.startDate;\n    }\n    /**\n     * If this event is an {@link #property-isOccurrence occurrence} of a recurring event, then this\n     * property yields its zero-based occurrence index in the sequence.\n     * @property {Number}\n     * @readonly\n     * @category Recurrence\n     */\n    get occurrenceIndex() {\n        return AbstractRecurrenceIterator.getOccurrenceIndex(this);\n    }\n    /**\n     * Builds an occurrence of this recurring event by cloning the timespan data.\n     * The method is used internally by the __RecurringTimeSpans__ mixin.\n     * Override it if you need to customize the generated occurrences.\n     *\n     * If the date requested is the start date of the event sequence, `this`\n     * record is returned. All runs of recurring events begin with the base record.\n     * @param  {Date} occurrenceDate The occurrence start date.\n     * @param  {Boolean} isFirst `true` if this is the first occurrence.\n     * @returns {Scheduler.model.TimeSpan} The occurrence.\n     * @internal\n     * @category Recurrence\n     */\n    buildOccurrence(occurrenceDate, isFirst) {\n        const\n            me                    = this,\n            {\n                occurrenceMap,\n                recurrence,\n                meta\n            }                     = me,\n            globalOccurrences     = me.eventStore?.globalOccurrences,\n            occurrenceKey         = DateHelper.makeKey(occurrenceDate),\n            id                    = me.createRecurrenceKey(occurrenceDate, occurrenceKey),\n            onStartDate           = !(occurrenceDate - me.startDate),\n            { fieldMap }          = me.constructor;\n        // An occurrence has a unique ID which identifies it by its base recurring event and its time.\n        let occurrence   = globalOccurrences?.get(id),\n            { duration } = me;\n        // If there's no duration, or it's an all day event (which makes the event ceil and floor its\n        // start and end dates, but does *NOT* as of 27/5/2020 adjust its duration) then\n        // we calculate the duration of the occurrence.\n        if (me.endDate && (me.allDay || !duration)) {\n            duration = DateHelper.as(me.durationUnit, me.endDate.getTime() - me.startDate.getTime());\n        }\n        // Don't let NaN in record data\n        const occurrenceEndDate = duration !== undefined ? DateHelper.add(occurrenceDate, duration, me.durationUnit) : undefined;\n        if (!occurrence) {\n            // If this is the first occurrence (start times may not match), or it's right on the start\n            // then this recurring event *IS* the occurrence\n            if (isFirst || onStartDate) {\n                occurrence = me;\n                // We are the first occurrence.\n                // But if our start time is not as the rule requires, adjust ourself *silently*\n                if (!onStartDate) {\n                    me.setStartEndDate(occurrenceDate, occurrenceEndDate, true);\n                    // Since we've changed the event start date the recurrence \"Days\"/\"MonthDays\"/\"Months\"\n                    // might get redundant in case the event start date matches the fields values\n                    // Calling recurrence sanitize() will clean the fields in this case.\n                    recurrence.suspendTimeSpanNotifying();\n                    recurrence.sanitize();\n                    recurrence.resumeTimeSpanNotifying();\n                }\n                // Either way, because of adjustment above, or initial correctness, we are in sync\n                // with our recurrence rule. A RecurrenceIterator is now able to calculate a correct\n                // UNTIL date from a COUNT value. See AbstractRecurrenceIterator#processIterationConfig\n                meta.isSyncedWithRule = true;\n            }\n            // Generate an occurrence which references this as its parent\n            else {\n                occurrence = me.copy(\n                    {\n                        [fieldMap.id.dataSource]        : id,\n                        [fieldMap.startDate.dataSource] : occurrenceDate,\n                        [fieldMap.endDate.dataSource]   : occurrenceEndDate,\n                        [fieldMap.duration.dataSource]  : duration,\n                        constraintDate                  : null,\n                        constraintType                  : null\n                    },\n                    { creatingOccurrence : true }\n                );\n                occurrence.recurringTimeSpan = me;\n            }\n            globalOccurrences?.set(id, occurrence);\n            // A recurring timespan keeps a by-startDate index of occurrences.\n            // And itself will be among those.\n            occurrenceMap.set(occurrenceKey, occurrence);\n        }\n        return occurrence;\n    }\n    createRecurrenceKey(date = this.startDate, dateKey = null) {\n        return `_generated:${this.id}:${dateKey || DateHelper.makeKey(date)}`;\n    }\n    // Converts this occurrence to a new \"master\" event\n    convertToRealEvent(wasSet, silent) {\n        if (!this.isOccurrence) {\n            return;\n        }\n        const\n            me = this,\n            {\n                recurringTimeSpan,\n                resource,\n                occurrenceIndex,\n                recurrence\n            }               = me,\n            count           = recurrence && recurringTimeSpan.recurrence.count,\n            // resourceRecords is a temporary property of occurrence events to handle cases\n            // if only resources has been updated. (change only resources won't mark record as dirty)\n            newResource     = wasSet?.resourceRecords?.value || me.data.newResource;\n        recurringTimeSpan.beginBatch();\n        me.detachFromRecurringEvent();\n        me.clearChanges();\n        // Must silently set our own ID, not be the key generated from our parent id and occurrence date.\n        // Must not result in the id field being in the modified state.\n        me.setData('id', me.generateId(recurringTimeSpan.eventStore));\n        if (newResource) {\n            // clear resourceId to avoid auto-adding to assignmentStore, it is handled manually bellow\n            delete me.data.resourceId;\n        }\n        // The impending changes to the former parent recurring event trigger a full refresh.\n        recurringTimeSpan.eventStore.add(me, silent);\n        // Ensure that the original count is honoured.\n        // If we are the 8th occurrence of 10, OUR repeat count must be 3.\n        if (count) {\n            me.recurrence.count = count - occurrenceIndex;\n        }\n        if (newResource || resource) {\n            me.assign(newResource || resource);\n        }\n        // remove data after apply\n        if (newResource) {\n            delete me.data.resourceRecords;\n        }\n        if (wasSet) {\n            delete wasSet.resourceRecords;\n        }\n        // Any change to a recurring events triggers a store refresh event.\n        recurringTimeSpan.endBatch();\n    }\n    afterChange(toSet, wasSet, silent, ...args) {\n        const\n            me             = this,\n            { eventStore } = me;\n        // reset cached recurrence instance in case \"recurrenceRule\" is changed\n        if ('recurrenceRule' in wasSet) {\n            me._recurrence = null;\n            // If we are a recurring event, we must be in the recurringEvents cache.\n            // If we are *not* a recurring event, we must *not* be in there.\n            // An event not yet in a store (eg dragging to create) won't have an eventStore.\n            eventStore?.recurringEvents[wasSet.recurrenceRule.value ? 'add' : 'delete'](me);\n        }\n        // Any change to an occurrence adds it to an event store, at which point\n        // it ceases to be an occurrence.\n        //\n        // If it has a recurrenceRule it becomes the start of a new recurring event series,\n        // and the old owning recurring event stops on the day before.\n        //\n        // If it has no recurrenceRule, it becomes an exception to its owning recurring event.\n        if (me.isOccurrence) {\n            me.convertToRealEvent(wasSet, silent);\n        }\n        // Setting a newException date must mark the exceptionDates as modified\n        else if ('newExceptionDate' in wasSet) {\n            me.meta.modified.exceptionDates = true;\n            delete me.meta.modified.newExceptionDate;\n            // Remove any occurrence on that date from our by-startDate cache\n            // and from the global occurrences cache\n            me.removeOccurrence(wasSet.newExceptionDate.value);\n        }\n        return super.afterChange(toSet, wasSet, silent, ...args);\n    }\n    /**\n     * Detaches an occurrence from its owning recurring event so that it can be added to the eventStore\n     * either as an exception, or as the start of a new recurring sequence.\n     * @internal\n     * @category Recurrence\n     */\n    detachFromRecurringEvent() {\n        const\n            me                                    = this,\n            // For access further down, breaking the link involves engine if trying to get the occurrenceDate later,\n            // resulting in the wrong date\n            { recurringTimeSpan, occurrenceDate, startDate } = me;\n        // Break the link\n        me.recurringTimeSpan = null;\n        // The occurrenceDate is injected into the data when an occurrence is created.\n        // the recurringTimeSpan's afterChange will remove any cache occurrence\n        // for this date; see above\n        recurringTimeSpan.addExceptionDate(occurrenceDate);\n        // If we still have a recurrenceRule, we're being promoted to be a new recurring event.\n        // The recurrence setter applies the rule immediately to occurrences, so this will\n        // always be correct.\n        if (me.recurrenceRule) {\n            // The RecurrenceModel removes occurrences and exceptions after this date\n            recurringTimeSpan.recurrence.endDate = DateHelper.add(startDate, -1, 'minute');\n        }\n    }\n    /**\n     * The setter used by Model#inSet when {@link #function-addExceptionDate} is called.\n     * Adding an exception must trigger change processing in a recurring event, so it must\n     * be changed through a {@link Core.data.Model#function-set} call. Also, the change must be batchable\n     * with other changes.\n     * @private\n     * @readonly\n     * @category Recurrence\n     */\n    set newExceptionDate(date) {\n        if (date) {\n            const exceptionDates = this.exceptionDates || (this.exceptionDates = {});\n            exceptionDates[DateHelper.makeKey(date)] = 1;\n        }\n    }\n    /**\n     * Adds an exception date that should be skipped when generating occurrences for the timespan.\n     * The methods adds an entry to the array kept in {@link #field-exceptionDates} field.\n     * @param {Date} date Exception date.\n     * @internal\n     * @category Recurrence\n     */\n    addExceptionDate(newExceptionDate) {\n        return this.set({\n            newExceptionDate\n        });\n    }\n    /**\n     * Does this recurring event have an exception on the passed date.\n     * @param {Date} date The date to find an exception for.\n     * @returns {Boolean} `true` if the event has an exception starting on the passed date.\n     * @category Recurrence\n     */\n    hasException(date) {\n        return this.exceptionDates?.[DateHelper.makeKey(date)];\n    }\n};\n", "import TimeSpan from './TimeSpan.js';\nimport RecurringTimeSpan from './mixin/RecurringTimeSpan.js';\n/**\n * @module Scheduler/model/ResourceTimeRangeModel\n */\n/**\n * This class represent a single resource time range in your schedule.\n * To style the rendered elements, use {@link Scheduler.model.TimeSpan#field-cls} or {@link #field-timeRangeColor} field.\n * The class is used by the {@link Scheduler.feature.ResourceTimeRanges} feature.\n *\n * ## Recurring ranges support\n *\n * You can also make ranges recurring by adding a `recurrenceRule` to the range data.\n *\n * ```javascript\n *\n * // Make new store that supports time ranges recurrence\n * const store = new ResourceTimeRangeStore({\n *     data : [{        {\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Coffee break',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n * ```\n *\n * @extends Scheduler/model/TimeSpan\n */\nexport default class ResourceTimeRangeModel extends TimeSpan.mixin(RecurringTimeSpan) {\n    static $name = 'ResourceTimeRangeModel';\n    //region Fields\n    static fields = [\n        /**\n         * Id of the resource this time range is associated with\n         * @field {String|Number} resourceId\n         */\n        'resourceId',\n        /**\n         * Controls this time ranges primary color, defaults to using current themes default time range color.\n         * @field {String} timeRangeColor\n         */\n        'timeRangeColor'\n    ];\n    static relations = {\n        /**\n         * The associated resource, retrieved using a relation to a ResourceStore determined by the value assigned\n         * to `resourceId`. The relation also lets you access all time ranges on a resource through\n         * `ResourceModel#timeRanges`.\n         * @member {Scheduler.model.ResourceModel} resource\n         */\n        resource : {\n            foreignKey            : 'resourceId',\n            foreignStore          : 'resourceStore',\n            relatedCollectionName : 'timeRanges',\n            nullFieldOnRemove     : true\n        }\n    };\n    static domIdPrefix = 'resourcetimerange';\n    get domId() {\n        return `${this.constructor.domIdPrefix}-${this.id}`;\n    }\n    //endregion\n    // Used internally to differentiate between Event and ResourceTimeRange\n    get isResourceTimeRange() {\n        return true;\n    }\n    // To match EventModel API\n    get resources() {\n        return this.resource ? [this.resource] : [];\n    }\n    // To match EventModel API\n    get $linkedResources() {\n        return this.resources;\n    }\n}\nResourceTimeRangeModel._$name = 'ResourceTimeRangeModel';", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/data/mixin/RecurringTimeSpansMixin\n */\nconst\n    emptyArray = Object.freeze([]);\n/**\n * This mixin provides recurrence functionality to a store containing {@link Scheduler.model.TimeSpan TimeSpan} models.\n * Normally you don't need to interact with this mixin directly.\n * @mixin\n */\nexport default Target => class RecurringTimeSpansMixin extends (Target || Base) {\n    static get $name() {\n        return 'RecurringTimeSpansMixin';\n    }\n    construct(...args) {\n        const me = this;\n        // We store all generated occurrences keyed by `_generated_${recurringTimeSpan.id}:${occurrenceStartDate}`\n        // So that when asked to generate an occurrence for a date, an already generated one can be returned.\n        me.globalOccurrences = new Map();\n        // All recurring events added to the store are accessible through this Set. It's used\n        // to generate occurrences.\n        me.recurringEvents = new Set();\n        super.construct(...args);\n    }\n    // Override to refreshRecurringEventsCache on initial load\n    afterLoadData() {\n        // All cached occurrences are now potentially invalid.\n        // A store reload might imply any number of changes which invalidate any occurrence.\n        this.globalOccurrences.clear();\n        // Clear and rebuild the recurring events cache\n        this.refreshRecurringEventsCache('clear');\n        this.refreshRecurringEventsCache('splice', this.storage.allValues);\n        super.afterLoadData && super.afterLoadData();\n    }\n    /**\n     * Responds to mutations of the underlying storage Collection.\n     *\n     * Maintain indices for fast finding of events by date.\n     * @param {Object} event\n     * @private\n     */\n    onDataChange({ action, added, removed, replaced }) {\n        // Recurring events cache must be refreshed before responding to change\n        this.refreshRecurringEventsCache(action, added, removed, replaced);\n        super.onDataChange(...arguments);\n    }\n    refreshRecurringEventsCache(action, added = emptyArray, removed = emptyArray, replaced) {\n        const\n            me                  = this,\n            { recurringEvents } = me,\n            replacedCount       = replaced?.length;\n        switch (action) {\n            case 'clear':\n                recurringEvents.clear();\n                break;\n            // Add and remove\n            case 'splice': {\n                // Handle replacement of records by instances with same ID\n                if (replacedCount) {\n                    added = added.slice();\n                    removed = removed.slice();\n                    for (let i = 0; i < replacedCount; i++) {\n                        removed.push(replaced[i][0]);\n                        added.push(replaced[i][1]);\n                    }\n                }\n                const\n                    addedCount   = added.length,\n                    removedCount = removed.length;\n                // Track the recurring events we contain\n                if (removedCount && recurringEvents.size) {\n                    for (let i = 0; i < removedCount; i++) {\n                        // If it's being removed, remove it from the recurring events cache.\n                        // If it's not a recurring event, it doesn't matter, it won't be in there.\n                        recurringEvents.delete(removed[i]);\n                    }\n                }\n                // Track the recurring events we contain\n                if (addedCount) {\n                    for (let i = 0; i < addedCount; i++) {\n                        const newEvent = added[i];\n                        // Allow easy access to recurring events\n                        if (newEvent.isRecurring) {\n                            recurringEvents.add(newEvent);\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n    getById(id) {\n        let result = super.getById(id);\n        // If the id is not found in the Store, then it could be one of our generated occurrences\n        if (!result) {\n            result = this.globalOccurrences.get(this.modelClass.asId(id));\n        }\n        return result;\n    }\n    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {\n        const isRecurrenceRelatedFieldChange = !silent && this.isRecurrenceRelatedFieldChange(record, wasSet);\n        // If this is the base of a recurring sequence, then any reactors to events from\n        // the super call must regenerate occurrences, so must be done at top.\n        // If silent is true, occurrences won't be recalculated. Do not remove occurrences from cache in such case.\n        if (isRecurrenceRelatedFieldChange) {\n            record.removeOccurrences();\n        }\n        super.onModelChange(...arguments);\n        // If this is the base of a recurring sequence, then the EventStore must\n        // trigger a refresh event so that UIs refresh themselves.\n        // This could be at the tail end of the creation of an exception\n        // or a new recurring base.\n        if (isRecurrenceRelatedFieldChange) {\n            const event = { action : 'batch', records : this.storage.values };\n            this.trigger('refresh', event);\n            this.trigger('change', event);\n        }\n    }\n    /**\n     * The method restricts which field modifications should trigger timespan occurrences building.\n     * By default, any field change of a recurring timespan causes the rebuilding.\n     * @param  {Scheduler.model.TimeSpan} timeSpan The modified timespan.\n     * @param  {Object} wasSet Object containing the change set.\n     * @returns {Boolean} `True` if the fields modification should trigger the timespan occurrences rebuilding.\n     * @internal\n     * @category Recurrence\n     */\n    isRecurrenceRelatedFieldChange(timeSpan, wasSet) {\n        return timeSpan.isRecurring || 'recurrenceRule' in wasSet;\n    }\n    /**\n     * Builds occurrences for the provided timespan across the provided date range.\n     * @private\n     * @category Recurrence\n     */\n    getOccurrencesForTimeSpan(timeSpan, startDate, endDate) {\n        const result = [];\n        if (timeSpan.isRecurring) {\n            timeSpan.recurrence.forEachOccurrence(startDate, endDate, r => result.push(r));\n        }\n        return result;\n    }\n    set data(data) {\n        // All cached occurrences are now invalid with a new dataset\n        this.globalOccurrences.clear();\n        super.data = data;\n    }\n    /**\n     * Returns all the recurring timespans.\n     * @returns {Scheduler.model.TimeSpan[]} Array of recurring events.\n     * @category Recurrence\n     */\n    getRecurringTimeSpans() {\n        return [...this.recurringEvents];\n    }\n};\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport ResourceTimeRangeModel from '../model/ResourceTimeRangeModel.js';\nimport RecurringTimeSpansMixin from './mixin/RecurringTimeSpansMixin.js';\n/**\n * @module Scheduler/data/ResourceTimeRangeStore\n */\n/**\n * A class representing a collection of resource time ranges.\n * Contains a collection of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModel} records.\n * The class is used by the {@link Scheduler.feature.ResourceTimeRanges ResourceTimeRanges} feature.\n *\n * ## Recurring ranges support\n *\n * By default, the class doesn't support recurrence. In order to add its support\n * please use {@link Scheduler.data.mixin.RecurringTimeSpansMixin RecurringTimeSpansMixin} mixin\n * (the store model in turn should be mixed with {@link Scheduler/model/mixin/RecurringTimeSpan RecurringTimeSpan} class):\n *\n * ```js\n * // Mix RecurringTimeSpan (which adds recurrence support) to ResourceTimeRangeModel\n * class MyResourceTimeRange extends RecurringTimeSpan(ResourceTimeRangeModel) {};\n *\n * // Mix RecurringTimeSpansMixin (which adds recurrence support) to ResourceTimeRangeStore\n * class MyResourceTimeRangeStore extends RecurringTimeSpansMixin(ResourceTimeRangeStore) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyResourceTimeRange\n *         };\n *     }\n * };\n *\n * // Make new store that supports time ranges recurrence\n * const store = new MyResourceTimeRangeStore({\n *     data : [{        {\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Coffee break',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n * ```\n *\n * @extends Core/data/AjaxStore\n */\nexport default class ResourceTimeRangeStore extends AjaxStore.mixin(RecurringTimeSpansMixin) {\n    static $name = 'ResourceTimeRangeStore';\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 500,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 500,\n            /**\n             * This store should be linked to a ResourceStore to link the time ranges to resources\n             * @config {Scheduler.data.ResourceStore}\n             */\n            resourceStore : null,\n            modelClass : ResourceTimeRangeModel,\n            storeId    : 'resourceTimeRanges'\n        };\n    }\n    set resourceStore(store) {\n        this._resourceStore = store;\n        // If store is assigned after configuration we need to init relations\n        if (!this.isConfiguring) {\n            this.initRelations(true);\n        }\n    }\n    get resourceStore() {\n        return this._resourceStore;\n    }\n    // Matching signature in EventStore to allow reusage of SchedulerStores#onInternalEventStoreChange()\n    getResourcesForEvent(resourceTimeRange) {\n        return [resourceTimeRange.resource];\n    }\n    /**\n     * Get resource time ranges intersecting the specified date range for a resource.\n     *\n     * The result is sorted by `startDate`.\n     *\n     * @param {Object} options Options\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord Resource record\n     * @param {Date} options.startDate Start date of the range\n     * @param {Date} options.endDate End date of the range\n     * @returns {Scheduler.model.ResourceTimeRangeModel[]}\n     */\n    getRanges({ resourceRecord, startDate, endDate }) {\n        const rangesInDateRange = resourceRecord.timeRanges.flatMap(range => {\n            if (range.supportsRecurring) {\n                return range.getOccurrencesForDateRange(startDate, endDate);\n            }\n            if (range.intersectsRange(startDate, endDate)) {\n                return range;\n            }\n            return [];\n        });\n        return rangesInDateRange.sort((span1, span2) => span1.startDate - span2.startDate);\n    }\n}\nResourceTimeRangeStore._$name = 'ResourceTimeRangeStore';", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/data/mixin/PartOfProject\n */\n/**\n * This is a mixin, included in all models and stores of the Scheduler project. It provides a common API for accessing\n * all stores of the project.\n *\n * @mixin\n */\nexport default Target => class PartOfProject extends (Target || Base) {\n    /**\n     * Returns the project this entity belongs to.\n     *\n     * @member {Scheduler.model.ProjectModel} project\n     * @readonly\n     * @category Project\n     */\n    /**\n     * Returns the event store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.EventStore} eventStore\n     * @readonly\n     * @category Project\n     */\n    /**\n     * Returns the dependency store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @readonly\n     * @category Project\n     */\n    /**\n     * Returns the assignment store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @readonly\n     * @category Project\n     */\n    /**\n     * Returns the resource store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @readonly\n     * @category Project\n     */\n    static get $name() {\n        return 'PartOfProject';\n    }\n};\n", "/**\n * @module Scheduler/model/mixin/AssignmentModelMixin\n */\n/**\n * Mixin that holds configuration shared between assignments in Scheduler and Scheduler Pro.\n * @mixin\n */\nexport default Target => class AssignmentModelMixin extends Target {\n    static get $name() {\n        return 'AssignmentModelMixin';\n    }\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     *\n     * ```javascript\n     * assignment.set('resourceId', 2);\n     * // assignment.resource is not yet resolved\n     *\n     * await assignment.setAsync('resourceId', 2);\n     * // assignment.resource is resolved\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n    //region Fields\n    static get fields() {\n        return [\n            /**\n             * Id for the resource to assign to\n             * @field {String|Number} resourceId\n             * @category Common\n             */\n            'resourceId',\n            /**\n             * Id for the event to assign\n             * @field {String|Number} eventId\n             * @category Common\n             */\n            'eventId',\n            /**\n             * Specify `false` to opt out of drawing dependencies from/to this assignment\n             * @field {Boolean} drawDependencies\n             * @category Common\n             */\n            { name : 'drawDependencies', type : 'boolean' },\n            'event',\n            'resource'\n        ];\n    }\n    //endregion\n    construct(data, ...args) {\n        data = data || {};\n        const\n            { fieldMap }    = this,\n            eventIdField    = fieldMap.eventId.dataSource,\n            resourceIdField = fieldMap.resourceId.dataSource,\n            eventField      = fieldMap.event.dataSource,\n            resourceField   = fieldMap.resource.dataSource,\n            eventId         = data[eventIdField],\n            resourceId      = data[resourceIdField],\n            event           = data[eventField],\n            resource        = data[resourceField];\n        // Engine expects event and resource, not eventId and resourceId. We need to support both\n        if (eventId != null) {\n            data[eventField] = eventId;\n        }\n        else if (event != null) {\n            data[eventIdField] = event.isModel ? event.id : event;\n        }\n        if (resourceId != null) {\n            data[resourceField] = resourceId;\n        }\n        else if (resource != null) {\n            data[resourceIdField] = resource.isModel ? resource.id : resource;\n        }\n        super.construct(data, ...args);\n    }\n    //region Event & resource\n    /**\n     * A key made up from the event id and the id of the resource assigned to.\n     * @property eventResourceKey\n     * @readonly\n     * @internal\n     */\n    get eventResourceKey() {\n        return this.buildEventResourceKey(this.event, this.resource);\n    }\n    buildEventResourceKey(event, resource) {\n        let eventKey, resourceKey;\n        if (event) {\n            eventKey = event.isModel ? event.id : event;\n        }\n        else {\n            eventKey = this.internalId;\n        }\n        if (resource) {\n            resourceKey = resource.isModel ? resource.id : resource;\n        }\n        else {\n            resourceKey = this.internalId;\n        }\n        return `${eventKey}-${resourceKey}`;\n    }\n    buildIndexKey({ event, resource }) {\n        return this.buildEventResourceKey(event, resource);\n    }\n    set(field, value, ...args) {\n        const toSet = this.fieldToKeys(field, value);\n        // If resource was set, store its id as resourceId and announce it\n        if ('resource' in toSet) {\n            if (toSet.resource?.id !== undefined) {\n                toSet.resourceId = toSet.resource.id;\n            }\n        }\n        // If resourceId was set, we need to replace resource to have it re-referenced in engine\n        else if ('resourceId' in toSet && this.constructor.isProAssignmentModel) {\n            toSet.resource = toSet.resourceId;\n        }\n        // Same for event\n        if ('event' in toSet) {\n            if (toSet.event?.id !== undefined) {\n                toSet.eventId = toSet.event.id;\n            }\n        }\n        else if ('eventId' in toSet && this.constructor.isProAssignmentModel) {\n            toSet.event = toSet.eventId;\n        }\n        return super.set(toSet, null, ...args);\n    }\n    afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n        const me = this;\n        // Make sure Core Engine implementation notices \"resourceId\" change\n        // and updates \"resource\" field value respectively\n        if (!me.constructor.isProAssignmentModel && wasSet?.resourceId &&\n            me.resource?.id !== wasSet.resourceId.value) {\n            me.resource = wasSet.resourceId.value;\n        }\n        // If that's non-Core Engine and we have \"eventId\" indicated as just set\n        // and there was also \"event\" passed to set but it was not set\n        // and if that happens when propagating after sync-response applied\n        // - this means an event has changed its identifier\n        // (this fixes 11_backend.t.js in the Gantt)\n        else if (me.constructor.isProAssignmentModel && me.project?.propagatingSyncChanges &&\n            wasSet?.eventId && !wasSet?.event &&\n            (toSet.event.value === wasSet.eventId.value || toSet.event.value.id === wasSet.eventId.value)\n        ) {\n            // sanitize both wasSet and meta.modified\n            delete wasSet.eventId;\n            delete me.meta.modified.eventId;\n        }\n        return super.afterChange(...arguments);\n    }\n    // Settings resourceId relays to `resource`. Underlying data will be updated in `afterChange()` above\n    set resourceId(value) {\n        const { resource } = this;\n        // When assigning a new id to a resource, it will update the resourceId of the assignment. But the assignments\n        // resource is still the same so we need to announce here\n        if (resource?.isModel && resource.id === value) {\n            this.set('resourceId', value);\n        }\n        else {\n            this.resource = value;\n        }\n    }\n    get resourceId() {\n        // If assigned using `resource` and not `resourceId` there will be no resourceId\n        return this.resource?.id ?? this.get('resourceId');\n    }\n    // Same for event as for resourceId\n    set eventId(value) {\n        const { event } = this;\n        // When assigning a new id to an event, it will update the eventId of the assignment. But the assignments\n        // event is still the same so we need to announce here\n        if (event?.isModel && event.id === value) {\n            this.set('eventId', value);\n        }\n        else {\n            this.event = value;\n        }\n    }\n    get eventId() {\n        // If assigned using `event` and not `eventId` there will be no eventId\n        return this.event?.id ?? this.get('eventId');\n    }\n    /**\n     * Convenience property to get the name of the associated event.\n     * @property {String}\n     * @readonly\n     */\n    get eventName() {\n        return this.event?.name;\n    }\n    /**\n     * Convenience property to get the name of the associated resource.\n     * @property {String}\n     * @readonly\n     */\n    get resourceName() {\n        return this.resource?.name;\n    }\n    /**\n     * Returns the resource associated with this assignment.\n     *\n     * @returns {Scheduler.model.ResourceModel} Instance of resource\n     */\n    getResource() {\n        return this.resource;\n    }\n    //endregion\n    // Convenience getter to not have to check `instanceof AssignmentModel`\n    get isAssignment() {\n        return true;\n    }\n    /**\n     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')\n     *\n     * @property {Boolean}\n     */\n    get isPersistable() {\n        const\n            {\n                event,\n                resource,\n                unjoinedStores,\n                assignmentStore\n            }           = this,\n            crudManager = assignmentStore?.crudManager;\n        let result;\n        if (assignmentStore) {\n            // If the owning event is not persistable, this assignment is also not persistable.\n            // if crud manager is used it can deal with phantom event/resource since it persists all records in one batch\n            // if no crud manager used we have to wait till event/resource are persisted\n            result = this.isValid && event.isPersistable && (crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);\n        }\n        // if we remove the record\n        else {\n            result = !this.isPhantom && Boolean(unjoinedStores[0]);\n        }\n        // Records not yet fully created cannot be persisted\n        return result && super.isPersistable && !this.event?.isCreating;\n    }\n    get isValid() {\n        return this.resource != null && this.event != null;\n    }\n    /**\n     * Returns a textual representation of this assignment (e.g. Mike 50%).\n     * @returns {String}\n     */\n    toString() {\n        if (this.resourceName) {\n            return `${this.resourceName} ${Math.round(this.units)}%`;\n        }\n        return '';\n    }\n    //region STM hooks\n    shouldRecordFieldChange(fieldName, oldValue, newValue) {\n        if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {\n            return false;\n        }\n        if (fieldName === 'event' || fieldName === 'eventId') {\n            const eventStore = this.project?.eventStore;\n            if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {\n                return false;\n            }\n        }\n        if (fieldName === 'resource' || fieldName === 'resourceId') {\n            const resourceStore = this.project?.resourceStore;\n            if (resourceStore && resourceStore.oldIdMap[oldValue] === resourceStore.getById(newValue)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //endregion\n};\n", "import Model from '../../Core/data/Model.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport AssignmentModelMixin from './mixin/AssignmentModelMixin.js';\nimport { CoreAssignmentMixin } from '../../Engine/quark/model/scheduler_core/CoreAssignmentMixin.js';\nconst EngineMixin = CoreAssignmentMixin;\n/**\n * @module Scheduler/model/AssignmentModel\n */\n/**\n * This model represents a single assignment of a resource to an event in the scheduler, usually added to a\n * {@link Scheduler.data.AssignmentStore}.\n *\n * It is a subclass of the {@link Core.data.Model} class. Please refer to the documentation for that class to become\n * familiar with the base interface of this class.\n *\n * ## Fields and references\n *\n * An Assignment has the following fields:\n * - `id` - The id of the assignment\n * - `resourceId` - The id of the resource assigned (optionally replaced with `resource` for load)\n * - `eventId` - The id of the event to which the resource is assigned (optionally replaced with `event` for load)\n *\n * The data source for these fields can be customized by subclassing this class:\n *\n * ```javascript\n * class MyAssignment extends AssignmentModel {\n *   static get fields() {\n *       return [\n *          { name : 'resourceId', dataSource : 'linkedResource' }\n *       ];\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `event` - The linked event record\n * - `resource` - The linked resource record\n *\n * ## Async resolving of references\n *\n * As described above, an assignment links an event to a resource. It holds references to an event record and a resource\n * record. These references are populated async, using the calculation engine of the project that the assignment via\n * its store is a part of. Because of this asyncness, references cannot be used immediately after modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // assignment.resource is not yet available\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // assignment.resource is available\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // assignment.resource is available\n * ```\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/AssignmentModelMixin\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class AssignmentModel extends AssignmentModelMixin(PartOfProject(EngineMixin.derive(Model))) {\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n    /**\n     * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after\n     * load it will be populated with the actual event and not its id. This field is not persistable.\n     * @field {Scheduler.model.EventModel} event\n     * @accepts {String|Number|Scheduler.model.EventModel}\n     * @category Common\n     */\n    /**\n     * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after\n     * load it will be populated with the actual resource and not its id. This field is not persistable.\n     * @field {Scheduler.model.ResourceModel} resource\n     * @accepts {String|Number|Scheduler.model.ResourceModel}\n     * @category Common\n     */\n    static get $name() {\n        return 'AssignmentModel';\n    }\n}\nAssignmentModel.exposeProperties();\nAssignmentModel._$name = 'AssignmentModel';", "import Model from '../../../Core/data/Model.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/data/mixin/AssignmentStoreMixin\n */\n/**\n * This is a mixin, containing functionality related to managing assignments.\n *\n * It is consumed by the regular {@link Scheduler.data.AssignmentStore} class and Scheduler Pros counterpart.\n *\n * @mixin\n */\nexport default Target => class AssignmentStoreMixin extends Target {\n    static get $name() {\n        return 'AssignmentStoreMixin';\n    }\n    /**\n     * Add assignments to the store.\n     *\n     * NOTE: References (event, resource) on the assignments are determined async by a calculation engine. Thus they\n     * cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * const [assignment] = assignmentStore.add({ eventId, resourceId });\n     * // assignment.event is not yet available\n     * ```\n     *\n     * To guarantee references are set up, wait for calculations for finish:\n     *\n     * ```javascript\n     * const [assignment] = assignmentStore.add({ eventId, resourceId });\n     * await assignmentStore.project.commitAsync();\n     * // assignment.event is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });\n     * // assignment.event is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.AssignmentModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n    /**\n     * Add assignments to the store and triggers calculations directly after. Await this function to have up to date\n     * references on the added assignments.\n     *\n     * ```javascript\n     * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });\n     * // assignment.event is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.AssignmentModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n    /**\n     * Applies a new dataset to the AssignmentStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: References (assignments, resources) on the assignments are determined async by a calculation engine. Thus\n     * they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * assignmentStore.data = [{ eventId, resourceId }];\n     * // assignmentStore.first.event is not yet available\n     * ```\n     *\n     * To guarantee references are available, wait for calculations for finish:\n     *\n     * ```javascript\n     * assignmentStore.data = [{ eventId, resourceId  }];\n     * await assignmentStore.project.commitAsync();\n     * // assignmentStore.first.event is available\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);\n     * // assignmentStore.first.event is available\n     * ```\n     *\n     * @member {AssignmentModelConfig[]} data\n     * @category Records\n     */\n    /**\n     * Applies a new dataset to the AssignmentStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);\n     * // assignmentStore.first.event is available\n     * ```\n     *\n     * @param {AssignmentModelConfig[]} data Array of AssignmentModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 300,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 300,\n            storeId : 'assignments'\n        };\n    }\n    add(newAssignments, ...args) {\n        newAssignments = ArrayHelper.asArray(newAssignments);\n        for (let i = 0; i < newAssignments.length; i++) {\n            let assignment = newAssignments[i];\n            if (!(assignment instanceof Model)) {\n                newAssignments[i] = assignment = this.createRecord(assignment);\n            }\n            if (!this.isSyncingDataOnLoad && this.storage.findIndex('eventResourceKey', assignment.eventResourceKey, true) !== -1) {\n                throw new Error(`Duplicate assignment Event: ${assignment.eventId} to resource: ${assignment.resourceId}`);\n            }\n            if (assignment.event?.isCreating) {\n                assignment.isCreating = true;\n            }\n        }\n        return super.add(newAssignments, ...args);\n    }\n    includesAssignment(eventId, resourceId) {\n        return this.storage.findIndex('eventResourceKey', `${eventId}-${resourceId}`, true) !== -1;\n    }\n    setStoreData(data) {\n        if (this.usesSingleAssignment) {\n            throw new Error('Data loading into AssignmentStore (multi-assignment mode) cannot be combined EventStore data containing resourceId (single-assignment mode)');\n        }\n        super.setStoreData(data);\n    }\n    //region Init & destroy\n    // This index fixes poor performance when you add large number of events to an event store with large number of\n    // events - if cache is missing existing records are iterated n\u00B2 times.\n    // https://github.com/bryntum/support/issues/3154#issuecomment-881336588\n    set storage(storage) {\n        super.storage = storage;\n        // This allows a map based, fast lookup of assignments by their eventResourceKey.\n        // This is so that the test for duplicate assignment adding is fast.\n        this.storage.addIndex({ property : 'eventResourceKey', dependentOn : { event : true, resource : true } });\n    }\n    get storage() {\n        // Micro optimization to avoid expensive super call\n        return this._storage || super.storage;\n    }\n    //endregion\n    //region Stores\n    // To not have to do instanceof checks\n    get isAssignmentStore() {\n        return true;\n    }\n    //endregion\n    //region Recurrence\n    /**\n     * Returns a \"fake\" assignment used to identify a certain occurrence of a recurring event.\n     * If passed the original event, it returns `originalAssignment`.\n     * @param {Scheduler.model.AssignmentModel} originalAssignment\n     * @param {Scheduler.model.EventModel} occurrence\n     * @returns {Object} Temporary assignment\n     * @internal\n     */\n    getOccurrence(originalAssignment, occurrence) {\n        // Pass along the original assignment for non occurrence related calls\n        if (!originalAssignment || !occurrence?.isOccurrence) {\n            return originalAssignment;\n        }\n        // Not for saving chars, needed in fn below\n        const me = this;\n        return {\n            id                     : `${occurrence.id}:a${originalAssignment.id}`,\n            event                  : occurrence,\n            resource               : originalAssignment.resource,\n            eventId                : occurrence.id,\n            resourceId             : originalAssignment.resource.id,\n            isAssignment           : true,\n            // This field is required to distinguish this fake assignment when event is being removed from UI\n            isOccurrenceAssignment : true,\n            // Not being an actual record, instanceMeta is stored on the store instead\n            instanceMeta(instanceOrId) {\n                return me.occurrenceInstanceMeta(this, instanceOrId);\n            }\n        };\n    }\n    // Per fake assignment instance meta, stored on store since fakes are always generated on demand\n    occurrenceInstanceMeta(occurrenceAssignment, instanceOrId) {\n        const\n            me         = this,\n            instanceId = instanceOrId.id || instanceOrId,\n            { id }     = occurrenceAssignment;\n        let { occurrenceMeta } = me;\n        if (!occurrenceMeta) {\n            occurrenceMeta = me.occurrenceMeta = {};\n        }\n        if (!occurrenceMeta[id]) {\n            occurrenceMeta[id] = {};\n        }\n        return occurrenceMeta[id][instanceId] || (occurrenceMeta[id][instanceId] = {});\n    }\n    //endregion\n    //region Mapping\n    /**\n     * Maps over event assignments.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @param {Function} [fn]\n     * @param {Function} [filterFn]\n     * @returns {Scheduler.model.EventModel[]|Array}\n     * @category Assignments\n     */\n    mapAssignmentsForEvent(event, fn, filterFn) {\n        event = this.eventStore.getById(event);\n        const\n            fnSet           = Boolean(fn),\n            filterFnSet     = Boolean(filterFn);\n        if (fnSet || filterFnSet) {\n            return event.assignments.reduce((result, assignment) => {\n                const mapResult = fnSet ? fn(assignment) : assignment;\n                if (!filterFnSet || filterFn(mapResult)) {\n                    result.push(mapResult);\n                }\n                return result;\n            }, []);\n        }\n        return event.assignments;\n    }\n    /**\n     * Maps over resource assignments.\n     *\n     * @param {Scheduler.model.ResourceModel|Number|String} resource\n     * @param {Function} [fn]\n     * @param {Function} [filterFn]\n     * @returns {Scheduler.model.ResourceModel[]|Array}\n     * @category Assignments\n     */\n    mapAssignmentsForResource(resource, fn, filterFn) {\n        resource = this.resourceStore.getById(resource);\n        const\n            fnSet           = Boolean(fn),\n            filterFnSet     = Boolean(filterFn);\n        if (fnSet || filterFnSet) {\n            return resource.assignments.reduce((result, assignment) => {\n                const mapResult = fnSet ? fn(assignment) : assignment;\n                if (!filterFnSet || filterFn(mapResult)) {\n                    result.push(mapResult);\n                }\n                return result;\n            }, []);\n        }\n        return resource.assignments;\n    }\n    /**\n     * Returns all assignments for a given event.\n     *\n     * @param {Scheduler.model.TimeSpan} event\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignments\n     */\n    getAssignmentsForEvent(event) {\n        return event.assignments;\n    }\n    /**\n     * Removes all assignments for given event\n     *\n     * @param {Scheduler.model.TimeSpan} event\n     * @category Assignments\n     */\n    removeAssignmentsForEvent(event) {\n        return this.remove(event.assignments);\n    }\n    /**\n     * Returns all assignments for a given resource.\n     *\n     * @param {Scheduler.model.ResourceModel} resource\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignments\n     */\n    getAssignmentsForResource(resource) {\n        resource = this.resourceStore.getById(resource);\n        return resource.assignments;\n    }\n    /**\n     * Removes all assignments for given resource\n     *\n     * @param {Scheduler.model.ResourceModel|*} resource\n     * @category Assignments\n     */\n    removeAssignmentsForResource(resource) {\n        this.remove(this.getAssignmentsForResource(resource));\n    }\n    /**\n     * Returns all resources assigned to an event.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Scheduler.model.ResourceModel[]}\n     * @category Assignments\n     */\n    getResourcesForEvent(event) {\n        return event.resources;\n    }\n    /**\n     * Returns all events assigned to a resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @returns {Scheduler.model.TimeSpan[]}\n     * @category Assignments\n     */\n    getEventsForResource(resource) {\n        resource = this.resourceStore.getById(resource);\n        return resource?.events;\n    }\n    /**\n     * Creates and adds assignment record(s) for a given event and resource(s).\n     *\n     * @param {Scheduler.model.TimeSpan} event\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} resources The resource(s) to assign to the event\n     * @param {Function} [assignmentSetupFn] A hook function which takes an assignment as its argument and must return an assignment.\n     * @param {Boolean} [removeExistingAssignments] `true` to remove assignments for other resources\n     * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)\n     * @category Assign\n     */\n    assignEventToResource(event, resources, assignmentSetupFn = null, removeExistingAssignments = false) {\n        const\n            me       = this,\n            toRemove = removeExistingAssignments ? new Set(event.assignments) : null;\n        resources = ArrayHelper.asArray(resources).map(r => r.$original ?? r);\n        if (me.eventStore?.usesSingleAssignment) {\n            // Use same code path as other single assignments if already assigned\n            if (event.assignments?.length) {\n                if (!me.isEventAssignedToResource(event, resources[0])) {\n                    event.resource = resources[0];\n                }\n                return [];\n            }\n            // otherwise - set \"resourceId\" and proceed to assignment creation\n            else {\n                event.resourceId = resources[0].id;\n            }\n        }\n        let newAssignments = [];\n        me.suspendAutoCommit();\n        // Assign\n        resources.forEach(resource => {\n            const existingAssignment = me.getAssignmentForEventAndResource(event, resource);\n            if (!existingAssignment) {\n                const assignment = {\n                    event,\n                    resource\n                };\n                newAssignments.push(assignmentSetupFn?.(assignment) ?? assignment);\n            }\n            else if (removeExistingAssignments) {\n                toRemove.delete(existingAssignment);\n            }\n        });\n        newAssignments = me.add(newAssignments);\n        if (removeExistingAssignments) {\n            me.remove(Array.from(toRemove));\n        }\n        // If true, will trigger a commit\n        me.resumeAutoCommit();\n        return newAssignments;\n    }\n    /**\n     * Removes assignment record for a given event and resource.\n     *\n     * @param {Scheduler.model.TimeSpan|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number} [resources] The resource to unassign the event from. If omitted, all resources of the events will be unassigned\n     * @returns {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]}\n     * @category Assign\n     */\n    unassignEventFromResource(event, resources) {\n        const\n            me = this,\n            assignmentsToRemove = [];\n        if (!resources) {\n            return me.removeAssignmentsForEvent(event);\n        }\n        resources = ArrayHelper.asArray(resources);\n        for (let i = 0; i < resources.length; i++) {\n            if (me.isEventAssignedToResource(event, resources[i])) {\n                assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));\n            }\n        }\n        return me.remove(assignmentsToRemove);\n    }\n    /**\n     * Checks whether an event is assigned to a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event Event record or id\n     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource record or id\n     * @returns {Boolean}\n     * @category Assignments\n     */\n    isEventAssignedToResource(event, resource) {\n        return Boolean(this.getAssignmentForEventAndResource(event, resource));\n    }\n    /**\n     * Returns an assignment record for a given event and resource\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event The event or its id\n     * @param {Scheduler.model.ResourceModel|String|Number} resource The resource or its id\n     * @returns {Scheduler.model.AssignmentModel}\n     * @category Assignments\n     */\n    getAssignmentForEventAndResource(event, resource) {\n        let assignments;\n        // Note: In order to not evaluate conditions which do not have to be evaluated each condition is assigned to a\n        // variable within the condition.\n        if (\n            !(event = this.eventStore.getById(event)) ||\n            !(assignments = event.assignments) ||\n            // Also note that resources are looked for in the master store if chained, to handle dragging between\n            // schedulers using chained versions of the same resource store. Needed since assignmentStore is shared and\n            // might point to wrong resourceStore (can only point to one)\n            !(resource = this.resourceStore.$master.getById(resource))\n        ) {\n            return null;\n        }\n        return this.getOccurrence(assignments.find(a => a.resource?.$original === resource.$original), event);\n    }\n    //endregion\n};\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport AssignmentModel from '../model/AssignmentModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\nimport AssignmentStoreMixin from './mixin/AssignmentStoreMixin.js';\nimport { CoreAssignmentStoreMixin } from '../../Engine/quark/store/CoreAssignmentStoreMixin.js';\nconst EngineMixin = PartOfProject(CoreAssignmentStoreMixin.derive(AjaxStore));\n/**\n * @module Scheduler/data/AssignmentStore\n */\n/**\n * A store representing a collection of assignments between events in the {@link Scheduler.data.EventStore} and resources\n * in the {@link Scheduler.data.ResourceStore}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.AssignmentModel}.\n *\n * An AssignmentStore is usually connected to a project, which binds it to other related stores (EventStore,\n * ResourceStore and DependencyStore). The project also handles references (event, resource) to related records for the\n * records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * assignmentStore.data = [{ eventId, resourceId }, ...];\n *\n * // references (event, resource) not resolved yet\n *\n * await assignmentStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await assignmentStore.loadDataAsync([{ eventId, resourceId }, ...]);\n *\n * // references (event, resource) are resolved\n * ```\n *\n * @mixes Scheduler/data/mixin/AssignmentStoreMixin\n * @mixes Scheduler/data/mixin/PartOfProject\n * @extends Core/data/AjaxStore\n */\nexport default class AssignmentStore extends AssignmentStoreMixin(EngineMixin) {\n    static $name = 'AssignmentStore';\n    static get defaultConfig() {\n        return {\n            modelClass : AssignmentModel\n        };\n    }\n}\nAssignmentStore._$name = 'AssignmentStore';", "import Base from '../../../Core/Base.js';\nimport Model from '../../../Core/data/Model.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport FunctionHelper from '../../../Core/helper/FunctionHelper.js';\n/**\n * @module Scheduler/data/mixin/EventStoreMixin\n */\n/**\n * This is a mixin, containing functionality related to managing events.\n *\n * It is consumed by the regular {@link Scheduler.data.EventStore} class and the Scheduler Pro's `EventStore` class.\n *\n * @mixin\n */\nexport default Target => class EventStoreMixin extends (Target || Base) {\n    static get $name() {\n        return 'EventStoreMixin';\n    }\n    //region Init & destroy\n    construct(config) {\n        super.construct(config);\n        this.autoTree = true;\n    }\n    //endregion\n    //region Events records, iteration etc.\n    set filtersFunction(filtersFunction) {\n        super.filtersFunction = filtersFunction;\n    }\n    get filtersFunction() {\n        // Generate the real filterFn.\n        const result = super.filtersFunction;\n        // We always filter *in* records which are being created by the UI.\n        if (result && result !== FunctionHelper.returnTrue) {\n            return r => r.isCreating || result(r);\n        }\n        return result;\n    }\n    /**\n     * Returns a `Map`, keyed by `YYYY-MM-DD` date keys containing event counts for all the days\n     * between the passed `startDate` and `endDate`. Occurrences of recurring events are included.\n     *\n     * Example:\n     *\n     * ```javascript\n     *  eventCounts = eventStore.getEventCounts({\n     *      startDate : scheduler.timeAxis.startDate,\n     *      endDate   : scheduler.timeAxis.endDate\n     *  });\n     * ```\n     *\n     * @param {Object} options An options object determining which events to return\n     * @param {Date} options.startDate The start date for the range of events to include.\n     * @param {Date} [options.endDate] The end date for the range of events to include.\n     * @category Events\n     */\n    getEventCounts(options) {\n        const\n            me     = this,\n            {\n                filtersFunction,\n                added\n            }      = me,\n            // Must use getEvents so that the loadDateRange event is triggered.\n            result = me.getEvents({\n                ...options,\n                storeFilterFn : me.isFiltered ? (me.reapplyFilterOnAdd ? filtersFunction : eventRecord => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord)) : null,\n                dateMap       : options.dateMap || true\n            });\n        result.forEach((value, key) => result.set(key, value.length));\n        return result;\n    }\n    /**\n     * Calls the supplied iterator function once for every scheduled event, providing these arguments\n     * - event : the event record\n     * - startDate : the event start date\n     * - endDate : the event end date\n     *\n     * Returning false cancels the iteration.\n     *\n     * @param {Function} fn iterator function\n     * @param {Object} [thisObj] `this` reference for the function\n     * @category Events\n     */\n    forEachScheduledEvent(fn, thisObj = this) {\n        this.forEach(event => {\n            const { startDate, endDate } = event;\n            if (startDate && endDate) {\n                return fn.call(thisObj, event, startDate, endDate);\n            }\n        });\n    }\n    /**\n     * Returns an object defining the earliest start date and the latest end date of all the events in the store.\n     *\n     * @returns {Object} An object with 'startDate' and 'endDate' properties (or null values if data is missing).\n     * @category Events\n     */\n    getTotalTimeSpan() {\n        let earliest = new Date(9999, 0, 1),\n            latest   = new Date(0);\n        this.forEach(event => {\n            if (event.startDate) {\n                earliest = DateHelper.min(event.startDate, earliest);\n            }\n            if (event.endDate) {\n                latest = DateHelper.max(event.endDate, latest);\n            }\n        });\n        earliest = earliest < new Date(9999, 0, 1) ? earliest : null;\n        latest   = latest > new Date(0) ? latest : null;\n        // keep last calculated value to be able to track total timespan changes\n        return (this.lastTotalTimeSpan = {\n            startDate : earliest || null,\n            endDate   : latest || earliest || null\n        });\n    }\n    /**\n     * Checks if given event record is persistable. By default it always is, override EventModels `isPersistable` if you\n     * need custom logic.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Boolean}\n     * @category Events\n     */\n    isEventPersistable(event) {\n        return event.isPersistable;\n    }\n    //endregion\n    //region Resource\n    /**\n     * Checks if a date range is allocated or not for a given resource.\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)\n     * @param {Scheduler.model.ResourceModel} resource The resource\n     * @returns {Boolean} True if the timespan is available for the resource\n     * @category Resource\n     */\n    isDateRangeAvailable(start, end, excludeEvent, resource) {\n        // NOTE: Also exists in TaskStore.js\n        // Cannot assign anything to generated parents\n        if (resource.data.generatedParent) {\n            return false;\n        }\n        // This should be a collection of unique event records\n        const allEvents = new Set(this.getEventsForResource(resource));\n        // In private mode we can pass an AssignmentModel. In this case, we assume that multi-assignment is used.\n        // So we need to make sure that other resources are available for this time too.\n        // No matter if the event retrieved from the assignment belongs to the target resource or not.\n        // We gather all events from the resources the event is assigned to except of the one from the assignment record.\n        // Note, events from the target resource are added above.\n        if (excludeEvent?.isAssignment) {\n            const\n                currentEvent = excludeEvent.event,\n                resources    = currentEvent.resources;\n            resources.forEach(resource => {\n                // Ignore events for the resource which is passed as an AssignmentModel to excludeEvent\n                if (resource.id !== excludeEvent.resourceId) {\n                    this.getEventsForResource(resource).forEach(event => allEvents.add(event));\n                }\n            });\n        }\n        if (excludeEvent) {\n            const eventToRemove = excludeEvent.isAssignment ? excludeEvent.event : excludeEvent;\n            allEvents.delete(eventToRemove);\n        }\n        return !Array.from(allEvents).some(event => event.isScheduled && DateHelper.intersectSpans(start, end, event.startDate, event.endDate));\n    }\n    /**\n     * Filters the events associated with a resource, based on the function provided. An array will be returned for those\n     * events where the passed function returns true.\n     * @param {Scheduler.model.ResourceModel} resource\n     * @param {Function} fn The function\n     * @param {Object} [thisObj] `this` reference for the function\n     * @returns {Scheduler.model.EventModel[]} the events in the time span\n     * @private\n     * @category Resource\n     */\n    filterEventsForResource(resource, fn, thisObj = this) {\n        return resource.getEvents(this).filter(fn.bind(thisObj));\n    }\n    /**\n     * Returns all resources assigned to an event.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @returns {Scheduler.model.ResourceModel[]}\n     * @category Resource\n     */\n    getResourcesForEvent(event) {\n        // If we are sent an occurrence, use its parent\n        if (event.isOccurrence) {\n            event = event.recurringTimeSpan;\n        }\n        return this.assignmentStore.getResourcesForEvent(event);\n    }\n    /**\n     * Returns all events assigned to a resource.\n     * *NOTE:* this does not include occurrences of recurring events. Use the\n     * {@link Scheduler/data/mixin/GetEventsMixin#function-getEvents} API to include occurrences of recurring events.\n     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource or resource id.\n     * @returns {Scheduler.model.EventModel[]}\n     * @category Resource\n     */\n    getEventsForResource(resource) {\n        return this.assignmentStore.getEventsForResource(resource);\n    }\n    //endregion\n    //region Assignment\n    /**\n     * Returns all assignments for a given event.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignment\n     */\n    getAssignmentsForEvent(event) {\n        return this.assignmentStore.getAssignmentsForEvent(event) || [];\n    }\n    /**\n     * Returns all assignments for a given resource.\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignment\n     */\n    getAssignmentsForResource(resource) {\n        return this.assignmentStore.getAssignmentsForResource(resource) || [];\n    }\n    /**\n     * Creates and adds assignment record for a given event and a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource The resource(s) to assign to the event\n     * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments\n     * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)\n     * @category Assignment\n     */\n    assignEventToResource(event, resource, removeExistingAssignments = false) {\n        return this.assignmentStore.assignEventToResource(event, resource, undefined, removeExistingAssignments);\n    }\n    /**\n     * Removes assignment record for a given event and a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @category Assignment\n     */\n    unassignEventFromResource(event, resource) {\n        this.assignmentStore.unassignEventFromResource(event, resource);\n    }\n    /**\n     * Reassigns an event from an old resource to a new resource\n     *\n     * @param {Scheduler.model.EventModel}    event    An event or id of the event to reassign\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} oldResource A resource or id to unassign from\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} newResource A resource or id to assign to\n     * @category Assignment\n     */\n    reassignEventFromResourceToResource(event, oldResource, newResource) {\n        const\n            me            = this,\n            newResourceId = Model.asId(newResource),\n            assignment    = me.assignmentStore.getAssignmentForEventAndResource(event, oldResource);\n        if (assignment) {\n            assignment.resourceId = newResourceId;\n        }\n        else {\n            me.assignmentStore.assignEventToResource(event, newResource);\n        }\n    }\n    /**\n     * Checks whether an event is assigned to a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @returns {Boolean}\n     * @category Assignment\n     */\n    isEventAssignedToResource(event, resource) {\n        return this.assignmentStore.isEventAssignedToResource(event, resource);\n    }\n    /**\n     * Removes all assignments for given event\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @category Assignment\n     */\n    removeAssignmentsForEvent(event) {\n        this.assignmentStore.removeAssignmentsForEvent(event);\n    }\n    /**\n     * Removes all assignments for given resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @category Assignment\n     */\n    removeAssignmentsForResource(resource) {\n        this.assignmentStore.removeAssignmentsForResource(resource);\n    }\n    //endregion\n};\n", "import DateHelper from '../../../Core/helper/DateHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\n/**\n * @module Scheduler/data/mixin/GetEventsMixin\n */\nconst\n    returnTrue   = () => true,\n    notRecurring = event => !event.isRecurring;\n/**\n * Mixing containing functionality for retrieving a range of events, mainly used during rendering.\n *\n * Consumed by EventStore in Calendar, Scheduler & Scheduler Pro and TaskStore in Gantt.\n *\n * @mixin\n */\nexport default Target => class GetEventsMixin extends Target {\n    static $name = 'GetEventsMixin';\n    /**\n     * Returns an array of events for the date range specified by the `startDate` and `endDate` options.\n     *\n     * By default, for any date, this includes any event which *intersects* that date.\n     *\n     * To only include events that are fully contained *within* the date range, pass the `allowPartial`\n     * option as `false`.\n     *\n     * By default, any occurrences of recurring events are included in the resulting array (not applicable in Gantt). If\n     * that is not required, pass the `includeOccurrences` option as `false`. **Note that if `includeOccurrences` is\n     * `true`, the start date and end date options are mandatory. The method must know what range of occurrences needs\n     * to be generated and returned.**\n     *\n     * Example:\n     *\n     * ```javascript\n     *  visibleEvents = eventStore.getEvents({\n     *      resourceRecord : myResource,\n     *      startDate      : scheduler.timeAxis.startDate,\n     *      endDate        : scheduler.timeAxis.endDate\n     *  });\n     * ```\n     *\n     * @param {Object} options An options object determining which events to return\n     * @param {Date} [options.date] If only one date is required, pass this option instead of the\n     * `startDate` and `endDate` options.\n     * @param {Date} options.startDate The start date for the range of events to include.\n     * @param {Date} [options.endDate] The end date for the range of events to include.\n     * @param {Scheduler.model.ResourceModel} [options.resourceRecord] Pass a resource to only return events assigned to\n     *   this resource. Not supported when using the `dateMap` option (see below)\n     * @param {Function} [options.filter] A function to filter out events which are not required.\n     * @param {Boolean} [options.ignoreFilters] By default, store filters are honoured. Pass this\n     * as `true` to include filtered out events.\n     * @param {Boolean} [options.includeOccurrences=true] Occurrences of recurring events are included by default.\n     * @param {Boolean} [options.allowPartial=true] Events which start before or after the range, but *intersect* the\n     *   range are included by default.\n     * @param {Boolean} [options.startOnly] Pass `true` to only include events which *start on* each date in the range.\n     * @param {Boolean} [options.onlyAssigned] Pass `true` to only include events that are assigned to a resource\n     * @param {Boolean|Map} [options.dateMap] Populates the passed `Map`, or if passed as `true`, creates and\n     * returns a new `Map`. The keys are `YYYY-MM-DD` date strings and the entries are arrays of\n     * {@link Scheduler.model.EventModel EventModel}s.\n     * @returns {Scheduler.model.EventModel[]|Map} Events which match the passed configuration.\n     * @category Events\n     */\n    getEvents({\n        filter,\n        date,\n        startDate,                  // Events which intersect the startDate/endDate\n        endDate,                    // will be returned\n        startOnly,                  // Only events which start on each date will be returned\n        includeOccurrences,         // Interpolate occurrences into the returned event set\n        allowPartial,               // Include events which *intersect* the date range\n        onlyAssigned = false,       // Only include events that are assigned to a resource\n        dateMap = false,            // Return a Map keyed by date each value being an array of events\n        dayTime = null,\n        // Private option. Select which date index to look up events in depending on the date\n        // we are examining in the date iteration process. Some callers may want to use\n        // different indices depending on the stage through the date iteration.\n        // See Calendar package for usage.\n        getDateIndex\n    }) {\n        const\n            me                = this,\n            options           = arguments[0],\n            {\n                lastDateRange,\n                added,\n                filtersFunction\n            } = me,\n            passedFilter      = filter;\n        // Add filtering for only assigned events if requested.\n        if (onlyAssigned) {\n            options.filter = passedFilter ? e => passedFilter(e) && e.resources.length : e => e.resources.length;\n        }\n        // Note that we cannot use defaulting in the argument block because we pass\n        // the incoming options object down into implementations.\n        if (!('startDate' in options)) {\n            startDate = options.startDate = date;\n        }\n        if (!('includeOccurrences' in options)) {\n            includeOccurrences = options.includeOccurrences = true;\n        }\n        if (!('allowPartial' in options)) {\n            allowPartial = options.allowPartial = !startOnly;\n        }\n        // We can't use me.filtersFunction if reapplyFilterOnAdd is false because there may be newly\n        // added events which may not be subject to the filter. Records which are still in\n        // the added bag must be tested for presence using indexOf so as to be always in sync\n        // with the store being refiltered. Parens help readability.\n        // Don't use the store's filtering function if we were asked to ignore filters.\n        // eslint-disable-next-line no-extra-parens\n        options.storeFilterFn = me.isFiltered && !options.ignoreFilters ? (me.reapplyFilterOnAdd ? filtersFunction : (eventRecord => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord))) : null;\n        // Default to a one day range if only startDate passed\n        if (!endDate) {\n            if (startDate) {\n                endDate = options.endDate = DateHelper.clearTime(startDate);\n                endDate.setDate(endDate.getDate() + 1);\n            }\n            // If no dates passed, the dateFilter will include all.\n            else {\n                // We need to know what occurrences to generate.\n                if (includeOccurrences) {\n                    throw new Error('getEvents MUST be passed startDate and endDate if recurring occurrences are requested');\n                }\n                options.dateFilter = returnTrue;\n            }\n        }\n        if (!options.dateFilter) {\n            // Must start in the date range\n            if (startOnly) {\n                options.dateFilter = e => {\n                    // Avoid hitting getter twice. Use batched value if present.\n                    const eventStartDate = e.hasBatchedChange('startDate') ? e.get('startDate') : e.startDate;\n                    return eventStartDate && !(DateHelper.clearTime(eventStartDate) - startDate);\n                };\n            }\n            // Any intersection with our date range\n            else if (allowPartial) {\n                options.dateFilter = e => {\n                    // Avoid hitting getter twice. Use batched value if present.\n                    const\n                        eventStartDate = e.hasBatchedChange('startDate') ? e.get('startDate') : e.startDate,\n                        eventEndDate   = e.hasBatchedChange('endDate') ? e.get('endDate') : e.endDate || eventStartDate,\n                        isMilestone    = !(eventStartDate - eventEndDate);\n                    return eventStartDate && (isMilestone ? DateHelper.betweenLesserEqual(eventStartDate, startDate, endDate) : DateHelper.intersectSpans(eventStartDate, eventEndDate, startDate, endDate));\n                };\n            }\n            // Must be wholly contained with the our range\n            else {\n                options.dateFilter = e => {\n                    // Avoid hitting getter twice. Use batched value if present.\n                    const\n                        eventStartDate = e.hasBatchedChange('startDate') ? e.get('startDate') : e.startDate,\n                        eventEndDate   = e.hasBatchedChange('endDate') ? e.get('endDate') : e.endDate || eventStartDate;\n                    return eventStartDate && eventStartDate >= startDate && eventEndDate <= endDate;\n                };\n            }\n        }\n        const newDateRange = {\n            startDate,\n            endDate\n        };\n        // Ensure the listeners are present\n        me.processConfiguredListeners();\n        /**\n         * Fired when a range of events is requested from the {@link #function-getEvents} method.\n         *\n         * <div class=\"note\">\n         * This event fires <span style=\"font-weight:bold\">every time</span> a range of events is\n         * requested from the store.\n         * </div>\n         *\n         * An application may have one of two levels of interest in events being read from a store.<br>\n         *\n         * 1.  To be notified when <span style=\"font-weight:bold\">any</span> event block is requested regardless of what the\n         * date range is.\n         * 2.  To be notified when a <span style=\"font-weight:bold\">new date range</span> is requested.\n         *\n         * This event allows both types of application to be written. The `changed` property is\n         * set if a different date range is requested.\n         *\n         * ```javascript\n         * new Scheduler({\n         *     eventStore : {\n         *         listeners : {\n         *             loadDateRange({ new : { startDate, endDate }, changed }) {\n         *                 // Load new data if user is requesting a different time window.\n         *                 if (changed) {\n         *                     fetch(...);\n         *                 }\n         *             }\n         *         }\n         *     },\n         *     ...\n         * });\n         * ```\n         *\n         * @event loadDateRange\n         * @param {Scheduler.data.EventStore} source This EventStore\n         * @param {Object} old The old date range\n         * @param {Date} old.startDate the old start date.\n         * @param {Date} old.endDate the old end date.\n         * @param {Object} new The new date range\n         * @param {Date} new.startDate the new start date.\n         * @param {Date} new.endDate the new end date.\n         * @param {Boolean} changed `true` if the date range is different from the last time a request was made.\n         */\n        me.trigger('loadDateRange', {\n            old     : lastDateRange || {},\n            new     : Objects.clone(newDateRange),\n            changed : Boolean(!lastDateRange || (lastDateRange.startDate - newDateRange.startDate || lastDateRange.endDate - newDateRange.endDate))\n        });\n        // Dates are mutable, so we must keep our own copy.\n        me.lastDateRange = Objects.clone(newDateRange);\n        return dateMap ? me.getEventsAsMap(options) : me.getEventsAsArray(options);\n    }\n    /**\n     * Internal implementation for {@link #function-getEvents} to use when not using dateMap.\n     * @private\n     */\n    getEventsAsArray({\n        filter,\n        date,\n        resourceRecord,\n        startDate = date,           // Events which intersect the startDate/endDate\n        endDate,                    // will be returned\n        startOnly,                  // Only events which start on each date will be returned\n        includeOccurrences = true,  // Interpolate occurrences into the returned event set\n        dayTime = null,\n        // Injected by the getEvents master method\n        dateFilter,\n        storeFilterFn,\n        // Private option. Select which date index to look up events in depending on the date\n        // we are examining in the date iteration process. Some callers may want to use\n        // different indices depending on the stage through the date iteration.\n        // See Calendar package for usage.\n        getDateIndex\n    }) {\n        const\n            me     = this,\n            events = [],\n            count  = storeFilterFn ? me.count : me.allCount;\n        if (count) {\n            let candidateEvents = resourceRecord ? me.getEventsForResource(resourceRecord) : null;\n            // If there *was* a resourceRecord, candidateEvents will already be set up using me.getEventsForResource.\n            // If no resourceRecord specified, we are gathering by date, so use the indices.\n            if (!resourceRecord) {\n                const\n                    dateIndex = me.useDayIndex(dayTime),\n                    eventSet  = new Set(),\n                    indexName = startOnly ? 'startDate' : 'date';\n                // Add all recurring events which started on or before our date range.\n                me.recurringEvents.forEach(e => {\n                    if (dateIndex.dayTime.startOfDay(e.startDate) <= startDate) {\n                        eventSet.add(e);\n                    }\n                });\n                // Iterate the date range, using the indices to find qualified events.\n                for (const date = new Date(startDate); date < endDate; date.setDate(date.getDate() + 1)) {\n                    const coincidingEvents = dateIndex.get(getDateIndex ? getDateIndex(date) : indexName, date);\n                    coincidingEvents?.forEach(e => eventSet.add(e));\n                }\n                // We gathered all events which *coincide* with each date.\n                // We also added in all recurring events which started on or before our date range.\n                // All these were made unique by the Set.\n                // Return it to array form.\n                candidateEvents = [...eventSet];\n            }\n            // Events found from the date indices won't be filtered.\n            // On the other side, when using getEventForResource we will get all events for\n            // the resource even if the EventStore is filtered, handle this by excluding \"invisible\" events here\n            if (storeFilterFn) {\n                candidateEvents = candidateEvents.filter(storeFilterFn);\n            }\n            // Go through candidates.\n            // For a recurring event, and we are including recurrences, add date-qualifying occurrences.\n            // For a non-recurring event, add it if it's date-qualified.\n            for (let i = 0, { length } = candidateEvents; i < length; i++) {\n                const e = candidateEvents[i];\n                // For recurring events, add date-qualifying occurrences, not the base\n                if (includeOccurrences && e.isRecurring) {\n                    events.push.apply(events, e.getOccurrencesForDateRange(startDate, endDate).filter(dateFilter));\n                }\n                // For ordinary events, add if it's date-qualified\n                else if (dateFilter(e)) {\n                    events.push(e);\n                }\n            }\n        }\n        return filter ? events.filter(filter) : events;\n    }\n    /**\n     * Internal implementation for {@link #function-getEvents} to use when using dateMap.\n     * @private\n     */\n    getEventsAsMap({\n        filter : passedFilter,\n        date,\n        resourceRecord,             // Not supported yet. Will add if ever requested.\n        startDate = date,           // Events which intersect the startDate/endDate\n        endDate,                    // will be returned\n        startOnly,                  // Only events which start on each date will be returned\n        includeOccurrences = true,  // Interpolate occurrences into the returned event set\n        dateMap,                    // Return a Map keyed by date each value being an array of events\n        dayTime = null,\n        storeFilterFn,\n        // Private option. Select which date index to look up events in depending on the date\n        // we are examining in the date iteration process. Some callers may want to use\n        // different indices depending on the stage through the date iteration.\n        // See Calendar package for usage.\n        getDateIndex\n    }) {\n        const me = this;\n        // Convert `true` to a Map.\n        if (dateMap?.clear) {\n            dateMap.clear();\n        }\n        else {\n            dateMap = new Map();\n        }\n        if (me.count) {\n            const\n                dateIndex       = me.useDayIndex(dayTime),\n                indexName       = startOnly ? 'startDate' : 'date',\n                recurringEvents = [],\n                filter          = e => (!passedFilter || passedFilter(e)) && (!storeFilterFn || storeFilterFn(e)),\n                baseEventFilter = e => notRecurring(e) && filter(e);\n            dayTime = dateIndex.dayTime;  // dayTime=null becomes DayTime instance for midnight\n            // We can't yet do this for just a resource.\n            if (resourceRecord) {\n                throw new Error('Querying for events for a resource and returning a date-keyed Map is not supported');\n            }\n            else {\n                // Add all recurring events which started before the end of our date range.\n                // There are none in Gantt projects\n                me.recurringEvents?.forEach(e => {\n                    if (dayTime.startOfDay(e.startDate) < endDate) {\n                        recurringEvents.push(e);\n                    }\n                });\n                // Iterate the date range, using the indices to find qualified events.\n                for (const date = new Date(startDate); date < endDate; date.setDate(date.getDate() + 1)) {\n                    let [coincidingEvents, key] = dateIndex.get(getDateIndex ? getDateIndex(date) : indexName, date, true);\n                    // The index entry may be there, but it could be empty.\n                    if (coincidingEvents?.size) {\n                        // Convert Set which index holds into an Array.\n                        // A recurring event doesn't go into the Map, its occurrences do.\n                        // Then filter by the passed filter and this Store's filter function\n                        // because events found from the date indices won't be filtered.\n                        coincidingEvents = [...coincidingEvents].filter(baseEventFilter);\n                        // Only create the entry for the day if there are events found\n                        if (coincidingEvents.length) {\n                            (dateMap.get(key) || (dateMap.set(key, []).get(key))).push(...coincidingEvents);\n                        }\n                    }\n                }\n            }\n            // Go through matching recurring events.\n            for (let i = 0, { length } = recurringEvents; i < length; i++) {\n                const\n                    e = recurringEvents[i],\n                    // For each recurring event, add occurrences if we are including occurrences else, add the base.\n                    // Then filter by the passed filter and this Store's filter function\n                    // because events found from the date indices won't be filtered.\n                    occurrences = (includeOccurrences ? e.getOccurrencesForDateRange(startDate, endDate) : [e]).filter(filter),\n                    lastDate    = DateHelper.add(endDate, 1, 'day');\n                // Add occurrences to dateMap\n                for (let bucket, i = 0, { length } = occurrences; i < length; i++) {\n                    const\n                        occurrence = occurrences[i],\n                        date = dayTime.startOfDay(occurrence.startDate),\n                        indexName = getDateIndex ? getDateIndex(date) : (startOnly ? 'startDate' : 'date'),\n                        lastIntersectingDate = (indexName === 'startDate') || !occurrence.durationMS\n                            ? DateHelper.add(date, 1, 'day')\n                            : DateHelper.min(occurrence.endDate || DateHelper.add(occurrence.startDate, occurrence.duration, occurrence.durationUnit), lastDate);\n                    // Loop through covered dates, adding to dateMap if required\n                    for (; date < lastIntersectingDate; date.setDate(date.getDate() + 1)) {\n                        const key = dayTime.dateKey(date);\n                        (bucket = dateMap.get(key)) || dateMap.set(key, bucket = []);\n                        bucket.push(occurrence);\n                    }\n                }\n            }\n        }\n        return dateMap;\n    }\n};\n", "import DH from '../../Core/helper/DateHelper.js';\n/**\n * @module Core/util/DayTime\n */\nconst\n    MILLIS_PER_MINUTE = 60 * 1000,\n    MILLIS_PER_HOUR   = 60 * MILLIS_PER_MINUTE,\n    MILLIS_PER_DAY    = 24 * MILLIS_PER_HOUR,\n    timeRe            = /(\\d+)?:?(\\d*)/;\n/**\n * This class encapsulates time of day calculations.\n *\n * The goal is to describe a \"day\" (a 24-hour period) that starts at a specific time (other than midnight). In a\n * calendar day view, this would look like this:\n *\n * ```text\n *              startShift=0                          startShift='12:00'\n *       00:00  +-------+                      12:00  +-------+\n *              |       |                             |       |\n *       01:00  |- - - -|                      13:00  |- - - -|\n *                 ...                                   ...\n *              |       |                             |       |\n *       08:00  |- - - -|   <-- timeStart -->  20:00  |- - - -|\n *              |       |                             |       |\n *       09:00  |- - - -|                      21:00  |- - - -|\n *              |       |                             |       |\n *       10:00  |- - - -|                      22:00  |- - - -|\n *              |       |                             |       |\n *       11:00  |- - - -|                      23:00  |- - - -|\n *              |       |                             |       |\n *       12:00  |- - - -|                      00:00  |- - - -|\n *              |       |                             |       |\n *       13:00  |- - - -|                      01:00  |- - - -|\n *              |       |                             |       |\n *       14:00  |- - - -|                      02:00  |- - - -|\n *              |       |                             |       |\n *       15:00  |- - - -|                      03:00  |- - - -|\n *              |       |                             |       |\n *       16:00  |- - - -|                      04:00  |- - - -|\n *              |       |                             |       |\n *       17:00  |- - - -|    <-- timeEnd -->   05:00  |- - - -|\n *              |       |                             |       |\n *                 ...                                   ...\n *              |       |                             |       |\n *       23:00  |- - - -|                      11:00  |- - - -|\n *              |       |                             |       |\n *       00:00  +-------+                      12:00  +-------+\n * ```\n *\n * In a horizontal format with X for times to render:\n *\n * ```text\n *  startShift = 0\n *\n *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n *      |   |   |  ...  |   |XXX|XXX|  ...  |XXX|XXX|   |  ...  |   |\n *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n *      00  01  02      07  08  09  10      15  16  17  18      23  00\n *                          ^                       ^\n *                      timeStart               timeEnd\n *\n *  startShift = '12:00'\n *\n *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n *      |   |   |  ...  |   |XXX|XXX|X ... X|XXX|XXX|   |  ...  |   |\n *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n *      12  13  14      19  20  21  22      03  04  05  06      11  12\n *                          ^                       ^\n *                      timeStart               timeEnd\n * ```\n *\n * When the day wraps over midnight, it is describing this (note timeEnd < timeStart):\n *\n * ```text\n *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n *      |XXX|XXX|X ... X|XXX|   |   |  ...  |   |   |XXX|X ... X|XXX|\n *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n *      00  01  02      04  05  06  07      18  19  20  21      23  00\n *                          ^                       ^\n *                      timeEnd                 timeStart\n * ```\n *\n * @internal\n */\nexport default class DayTime {\n    /**\n     * Returns a string of \"HH:MM\" for a given time of day in milliseconds.\n     * @param {Number} timeOfDay The time of day in milliseconds.\n     * @returns {String}\n     * @private\n     */\n    static format(timeOfDay) {\n        const\n            h = Math.floor(timeOfDay / MILLIS_PER_HOUR),\n            m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;\n        return `${h}:${m < 10 ? '0' : ''}${m}`;\n    }\n    /**\n     * Parses a time of day which may be a number (0-24 for the hour of the day) or a string in \"H:MM\" format and\n     * returns the time of day as a number of milliseconds.\n     *\n     * If `time` is a `Date` instance, its time of day is returned.\n     * @param {Date|Number|String} time\n     * @returns {Number}\n     * @private\n     */\n    static parse(time) {\n        const type = typeof time;\n        if (type === 'string') {\n            const match = timeRe.exec(time);\n            time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;\n        }\n        else if (type !== 'number') {\n            time = DH.getTimeOfDay(time);\n        }\n        else if (time <= 24) {  // if number of hours (as provided during config)\n            time *= MILLIS_PER_HOUR;\n        }\n        return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);\n    }\n    constructor(config) {\n        let startShift = 0,\n            startTime, endTime;\n        if (config?.isDayView) {\n            // These are raw configs in hrs or 'HH:MM' on construction and millis after:\n            startShift = config.dayStartShift;\n            startTime = config.dayStartTime;\n            endTime = config.dayEndTime;\n        }\n        else if (typeof config === 'number') {\n            startShift = startTime = endTime = config;\n        }\n        else if (config) {\n            /**\n             * Either the hour number or a *24 hour* `HH:MM` string denoting the start time for the day. This is\n             * midnight by default.\n             * @config {Number|String} startShift\n             * @default 0\n             */\n            startShift = config.startShift;\n            /**\n             * Either the hour number or a *24 hour* `HH:MM` string denoting the first visible time of day. You can also\n             * set this value to a ms timestamp representing time from midnight.\n             * @config {Number|String} timeStart\n             * @default 0\n             */\n            startTime = config.timeStart;\n            /**\n             * Either the hour number or a *24 hour* `HH:MM` string denoting the last visible time of day. You can also\n             * set this value to a ms timestamp representing time from midnight.\n             * @config {Number|String} timeEnd\n             * @default 24\n             */\n            endTime = config.timeEnd;\n        }\n        this.startShift = startShift = DayTime.parse(startShift || 0);\n        this.timeEnd    = ((endTime == null)\n            ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY\n            : DayTime.parse(endTime)) || MILLIS_PER_DAY;\n        this.timeStart  = (startTime == null) ? startShift : DayTime.parse(startTime);\n    }\n    get startHour() {\n        return Math.floor(this.timeStart / MILLIS_PER_HOUR);\n    }\n    get endHour() {\n        return Math.floor(this.timeEnd / MILLIS_PER_HOUR);\n    }\n    /**\n     * The number of milliseconds from the day's `startShift` to its `timeStart`.\n     * @member {Number}\n     */\n    get startTimeOffsetMs() {\n        const { startShift, timeStart } = this;\n        return (timeStart < startShift) ? MILLIS_PER_DAY - startShift + timeStart : (timeStart - startShift);\n    }\n    /**\n     * The `Date` object for the most recently started, shifted day. The time of this `Date` will be the `startShift`.\n     * It is possible for this date to be yesterday on a midnight-based calendar. For example, if the `startShift` is\n     * 6PM and the current time is 6AM on May 20, this value will be 6PM of May 19 (the most recently started day).\n     * @member {Date}\n     */\n    get today() {\n        return this.startOfDay(new Date());\n    }\n    /**\n     * Returns `Date` object for the nearest (shifted) day ending after the given `date`. The time of this `Date` will\n     * be the `startShift`.\n     *\n     * It is possible for this date to be in the next day on a midnight-based calendar. For example, if the `startShift`\n     * is 6PM and `date` is 7PM on May 20, this method will return 6PM of May 21 (the nearest day ending).\n     * @param {Date} date The date for which to find the nearest day ending.\n     * @returns {Date}\n     */\n    ceil(date) {\n        const ret = this.startOfDay(date);\n        if (ret < date) {\n            ret.setDate(ret.getDate() + 1);\n        }\n        return ret;\n    }\n    /**\n     * Returns `true` if the time of day for the given `date` is between `timeStart` and `timeEnd`.\n     * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.\n     * @returns {Boolean}\n     */\n    contains(date) {\n        return !this.outside(date);\n    }\n    /**\n     * Returns a \"YYYY-MM-DD\" string for the given `date`. This value will match the `date` if the time of day is at or\n     * after `startShift`, but will be the prior date otherwise.\n     * @param {Date|Number} date The date from which to compute the 'YYYY-MM-DD' key.\n     * @returns {String}\n     */\n    dateKey(date) {\n        date = this.shiftDate(date, -1);\n        return DH.makeKey(date);\n    }\n    /**\n     * Returns a `Date` instance with `startShift` as the time of day and the Y/M/D of the given `date`.\n     * @param {Date} date The date's year, month, and day values.\n     * @returns {Date}\n     */\n    dayOfDate(date) {\n        return this.shiftDate(DH.clearTime(date));  // return the Date w/the matching YYYY-MM-DD value\n    }\n    /**\n     * Returns the day of week (0-8) for the given `date`. This value will match the `date` if the time of day is at or\n     * after `startShift`, but will be the prior day otherwise.\n     * @param {Date|Number} date The date from which to compute the day of week.\n     * @returns {Number}\n     */\n    dayOfWeek(date) {\n        date = this.shiftDate(date, -1);\n        return date.getDay();\n    }\n    /**\n     * Returns the difference between the time of day of the given `date` and `timeStart` in the specified time `unit`.\n     * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance.\n     * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).\n     * @returns {Number}\n     */\n    delta(date, unit = 'ms') {\n        const\n            { timeStart } = this,\n            time = DayTime.parse(date),\n            t = ((this.startShift && time < timeStart) ? time + MILLIS_PER_DAY : time) - timeStart;\n        return (unit === 'ms') ? t : DH.as(unit, t, 'ms');\n    }\n    /**\n     * Returns the duration of the visible day (between `timeStart` and `timeEnd`) in the specified time `unit`.\n     * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).\n     * @returns {Number}\n     */\n    duration(unit = 'ms') {\n        const\n            { timeStart, timeEnd } = this,\n            millis = (timeStart < timeEnd) ? timeEnd - timeStart : (MILLIS_PER_DAY - timeStart + timeEnd);\n        return (unit === 'ms') ? millis : DH.as(unit, millis, 'ms');\n    }\n    /**\n     * Returns `true` if this instance describes the same day as the `other`.\n     * @param {Core.util.DayTime} other The other instance to which `this` instance should be tested for equality.\n     * @returns {Boolean}\n     */\n    equals(other) {\n        // we only need on \"?.\" operator since we short-circuit\n        return this.startShift === other?.startShift && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;\n    }\n    /**\n     * Returns `true` if the times of day described by `startDate` and `endDate` intersect the visible time of this day.\n     * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate\n     * fields.\n     * @param {Date} [endDate] The end date if `startDate` is not an event record.\n     * @returns {Boolean}\n     */\n    intersects(startDate, endDate) {\n        const\n            me                     = this,\n            { timeStart, timeEnd } = me,\n            [date0, date1]         = me._dateRangeArgs(startDate, endDate),\n            [start, end]           = me.timeRange(date0, date1);\n        if (timeStart < timeEnd) {\n            if (start < end) {\n                return start < timeEnd && timeStart <= end;\n            }\n            return start < timeEnd || timeStart <= end;\n        }\n        return !(start < end) || start < timeEnd || timeStart <= end;\n    }\n    /**\n     * Returns `true` if the given date range is contained within one day.\n     * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate\n     * fields.\n     * @param {Date} [endDate] The end date if `startDate` is not an event record.\n     * @returns {Boolean}\n     */\n    isIntraDay(startDate, endDate) {\n        const\n            me             = this,\n            [date0, date1] = me._dateRangeArgs(startDate, endDate),\n            dayStart       = me.startOfDay(date0),\n            diff           = MILLIS_PER_DAY - DH.diff(dayStart, date1, 'ms');\n        // Not <= to match isInterDay\n        if (diff < 0) {\n            return false;\n        }\n        // diff > 0 means less than 24hrs, so intraDay... diff==0 means date1 was EOD so we are intraDay if date0 is not\n        // also at EOD.\n        return diff > 0 || dayStart < date0;\n    }\n    /**\n     * Returns `true` if the given date range or event crosses the day boundary.\n     * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate\n     * fields.\n     * @param {Date} [endDate] The end date if `startDate` is not an event record.\n     * @returns {Boolean}\n     */\n    isInterDay(timeSpan) {\n        return timeSpan.allDay || !this.isIntraDay(...arguments);\n    }\n    /**\n     * Returns -1, 0, or 1 based on whether the time of day for the given `date` is before `timeStart` (-1), or after\n     * `timeEnd` (1), or between these times (0).\n     * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.\n     * @returns {Number}\n     */\n    outside(date) {\n        const\n            { startShift, timeStart, timeEnd } = this,\n            time = DayTime.parse(date);\n        if (timeStart < timeEnd) {\n            /*\n             *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n             *      |   |   |  ...  |   |XXX|XXX|  ...  |XXX|XXX|   |  ...  |   |\n             *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n             *      00  01  02      07  08  09  10      15  16  17  18      23  00\n             *                          ^                       ^\n             *                      timeStart               timeEnd\n             */\n            if (time < timeStart) {\n                return (time < startShift) ? 1 : -1;\n            }\n            if (time < timeEnd) {\n                return 0;\n            }\n            return (time < startShift) ? -1 : 1;\n        }\n        /*\n         *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n         *      |XXX|XXX|X ... X|XXX|   |   |  ...  |   |   |XXX|X ... X|XXX|\n         *      +---+---+---  --+---+---+---+--   --+---+---+---+--   --+---+\n         *      00  01  02      04  05  06  07      18  19  20  21      23  00\n         *                          ^                       ^\n         *                      timeEnd                 timeStart\n         */\n        if (time < timeEnd || time >= timeStart) {\n            return 0;\n        }\n        return (time < startShift) ? 1 : -1;\n    }\n    parseKey(key) {\n        return this.dayOfDate(DH.parseKey(key));\n    }\n    /**\n     * Returns the given `date` shifted forward (`direction` > 0) or backward (`direction` < 0) by the `startShift`.\n     * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch.\n     * @param {Number} direction A value > 0 to shift `date` forward, or < 0 to shift it backwards.\n     * @returns {Date}\n     */\n    shiftDate(date, direction = 1) {\n        const\n            { startShift } = this,\n            type = typeof date;\n        date = (type === 'number') ? new Date(date) : (type === 'string' ? DH.parse(date) : new Date(date.getTime()));\n        // Not this:\n        // return (direction && startShift) ? DH.add(date, (direction > 0) ? startShift : -startShift, 'ms') : date;\n        // the DH.add() goes via UTC timestamp and so will not end on the correct time of day when DST is hit\n        if (direction && startShift) {\n            date.setMilliseconds((direction > 0) ? startShift : -startShift);\n        }\n        return date;\n    }\n    /**\n     * Sorts the given set of `events` by the maximum of `startDate` and `startOfDay` for the given `date`, followed\n     * by `duration` in case of a tie.\n     * @param {Date} date The day for which events are to be sorted.\n     * @param {Object[]} events The events to sort, typically an `Scheduler.model.EventModel[]` but any objects with\n     * both `startDate` and `endDate` fields are acceptable.\n     * @returns {Object[]} The passed `events` array.\n     * @internal\n     */\n    sortEvents(date, events) {\n        const startOfDay = this.startOfDay(date);\n        return events?.sort((event1, event2) => {\n            event1 = event1.eventRecord || event1;\n            event2 = event2.eventRecord || event2;\n            let { startDate: start1 } = event1,\n                { startDate: start2 } = event2;\n            // Unscheduled events sort to the top.\n            if (!start1) {\n                return -1;\n            }\n            if (!start2) {\n                return 1;\n            }\n            // Limit startDates to the start of the day. In other words, all events that start before \"midnight\" are\n            // equally considered as starting at midnight:\n            start1 = (start1 < startOfDay) ? startOfDay : start1;\n            start2 = (start2 < startOfDay) ? startOfDay : start2;\n            // Sort by start timestamp first, then duration with respect to clipped start dates.\n            return start1 - start2 || (event2.endDate - start2) - (event1.endDate - start1);\n        });\n    }\n    /**\n     * Returns `Date` object for the nearest started (shifted) day prior to the given `date`. The time of this `Date`\n     * will be the `startShift`.\n     *\n     * It is possible for this date to be in the prior day on a midnight-based calendar. For example, if the `startShift`\n     * is 6PM and `date` is 6AM on May 20, this method will return 6PM of May 19 (the nearest started day).\n     * @param {Date} date The date for which to find the nearest started day.\n     * @returns {Date}\n     */\n    startOfDay(date) {\n        date = this.shiftDate(date, -1);\n        date = DH.clearTime(date);\n        date = this.shiftDate(date);\n        return date;\n    }\n    /**\n     * Returns a range of {@link Core.helper.DateHelper#function-getTimeOfDay-static times of day} for the given\n     * date range.\n     * @param {Date} startDate The start date of the date range or an event record containing both `startDate` and `endDate` fields\n     * @param {Date} [endDate] The end date if `startDate` is not an event record\n     * @returns {Number[]}\n     */\n    timeRange(startDate, endDate) {\n        const [start, end] = this._dateRangeArgs(startDate, endDate);\n        return [DH.getTimeOfDay(start), DH.getTimeOfDay(end)];\n    }\n    toString() {\n        const\n            { startShift, timeEnd, timeStart } = this,\n            suffix = startShift ? `@${DayTime.format(startShift)}` : '',\n            prefix = DayTime.format(timeStart);\n        if (timeStart === timeEnd) {\n            return startShift ? suffix : prefix;\n        }\n        return `${prefix}-${DayTime.format(timeEnd)}${suffix}`;\n    };\n    /**\n     * Decodes the arguments and returns a pair of `Date` objects for the start and end of the date range.\n     * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate\n     * fields.\n     * @param {Date} [endDate] The end date if `startDate` is not an event record.\n     * @returns {Date[]}\n     * @private\n     */\n    _dateRangeArgs(startDate, endDate) {\n        return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];\n    }\n}\n/**\n * The `DayTime` instance representing a canonical calendar day (starting at midnight).\n * @member {Core.util.DayTime} MIDNIGHT\n * @static\n * @readonly\n */\nDayTime.MIDNIGHT = new DayTime({\n    startShift : 0,\n    timeStart  : 0,\n    timeEnd    : 24\n});\nDayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;\nDayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;\nDayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;\nDayTime._$name = 'DayTime';", "import DayTime from '../../../Core/util/DayTime.js';\n/**\n * @module Scheduler/data/util/EventDayIndex\n */\nconst\n    // Maps an index name that can be requested to its storage property on the EventDayIndex instance:\n    indexNameMap = {\n        date      : '_dateIndex',\n        startDate : '_startDateIndex'\n    },\n    indexProps         = Object.values(indexNameMap),\n    emptyArray         = Object.freeze([]),\n    { MILLIS_PER_DAY } = DayTime;\n/**\n * This utility class is used by event stores to index events by their day (a \"YYYY-MM-DD\" value, also known as a\n * \"date key\"). This key is produced by a {@link Core.util.DayTime} instance. If two `DayTime` instances have a common\n * `startShift`, they can share an index.\n *\n * @internal\n */\nexport default class EventDayIndex {\n    constructor(store, dayTime) {\n        /**\n         * The `DayTime` definition for this index. This is set to the initial DayTime instance but can be used for\n         * any other {@link #function-register registered} `DayTime` instances since they all posses the same value for\n         * `startShift`.\n         *\n         * This defaults to {@link Core.util.DayTime#property-MIDNIGHT-static}.\n         * @member {Core.util.DayTime} dayTime\n         * @readonly\n         */\n        this.dayTime = dayTime || DayTime.MIDNIGHT;\n        /**\n         * The owning store instance of this index.\n         * @member {Scheduler.data.EventStore} store\n         * @private\n         * @readonly\n         */\n        this.store = store;\n        /**\n         * The `DayTime` instances {@link #function-register registered} with this index instance. As instances are\n         * {@link #function-unregister unregistered} they are removed from this array. Once this array is empty, this\n         * index can be discarded.\n         * @member {Core.util.DayTime[]} users\n         * @private\n         */\n        this.users = [this.dayTime];\n    }\n    /**\n     * Adds an event record to the specified index (either \"startDate\" or \"date\") for a given `date`.\n     * @param {String} indexName The index to which the event record is to be added (either \"startDate\" or \"date\").\n     * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}\n     * method is used to convert this date to a \"YYYY-MM-DD\" key for the index.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @private\n     */\n    add(indexName, date, eventRecord) {\n        const\n            index    = this[indexNameMap[indexName]],\n            key      = this.dayTime.dateKey(date),\n            entry    = index[key] || (index[key] = new Set());\n        entry.add(eventRecord);\n    }\n    /**\n     * Adds an event record to all indexes for all dates which the event overlaps.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @private\n     */\n    addEvent(eventRecord) {\n        let dateMS = this.dayTime.startOfDay(eventRecord.startDate)?.getTime(),\n            endDateMS;\n        if (dateMS) {\n            endDateMS = eventRecord.endDate?.getTime() ?? dateMS;\n            this.add('startDate', dateMS, eventRecord);\n            do {\n                this.add('date', dateMS, eventRecord);\n                dateMS += MILLIS_PER_DAY;\n            } while (dateMS < endDateMS);\n        }\n    }\n    /**\n     * Clear this index.\n     */\n    clear() {\n        indexProps.forEach(name => this[name] = Object.create(null));\n    }\n    /**\n     * Returns an object that has properties named by the {@link Core.util.DayTime#function-dateKey} method, or the\n     * array of event records if a `date` is specified, or the event record array and the date key in a 2-element array\n     * if `returnKey` is `true`.\n     * @param {String} indexName The name of the desired index (either 'date' or 'startDate').\n     * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch. When passed, this method will return\n     * the array of event records for this date.\n     * @param {Boolean} [returnKey] Specify `true` to return the date key along with the event record array.\n     * @returns {Object|Scheduler.model.EventModel[]}\n     */\n    get(indexName, date, returnKey) {\n        // Date indices are created on first usage and after that kept up to date on changes\n        !this.initialized && this.initialize();\n        let ret = this[indexNameMap[indexName]],\n            key;\n        if (date) {\n            key = this.dayTime.dateKey(date);\n            ret = returnKey ? [ret[key], key] : ret[key];\n        }\n        return ret;\n    }\n    /**\n     * Called when this index is first used. Once called, further store changes will be used to maintain this index.\n     * @private\n     */\n    initialize() {\n        this.initialized = true;\n        this.clear();\n        this.sync('splice', this.store.storage.allValues);\n    }\n    invalidate() {\n        this.initialized = false;\n        indexProps.forEach(name => this[name] = null);\n    }\n    /**\n     * Returns `true` if the given `dayTime` matches this index.\n     * @param {Core.util.DayTime} dayTime\n     * @returns {Boolean}\n     */\n    matches(dayTime) {\n        return this.dayTime.startShift === dayTime.startShift;\n    }\n    /**\n     * Removes an event record from the specified index (either \"startDate\" or \"date\") for a given `date`.\n     * @param {String} indexName The index to which the event record is to be removed (either \"startDate\" or \"date\").\n     * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}\n     * method is used to convert this date to a \"YYYY-MM-DD\" key for the index.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @private\n     */\n    remove(indexName, date, eventRecord) {\n        const\n            index = this[indexNameMap[indexName]],\n            key   = this.dayTime.dateKey(date),\n            entry = index[key];\n        if (entry) {\n            entry.delete(eventRecord);\n        }\n    }\n    /**\n     * Removes an event record from all indexes for all dates which the event overlaps.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @param {Date} startDate The start date for the event. This may be different from the `startDate` of the given\n     * `eventRecord` when the event is rescheduled.\n     * @param {Date} endDate The end date for the event. This may be different from the `endDate` of the given\n     * `eventRecord` when the event is rescheduled.\n     * @private\n     */\n    removeEvent(eventRecord, startDate, endDate) {\n        let dateMS = this.dayTime.startOfDay(startDate)?.getTime(),\n            endDateMS;\n        if (dateMS) {\n            endDateMS = endDate?.getTime() ?? dateMS;\n            this.remove('startDate', dateMS, eventRecord);\n            do {\n                this.remove('date', dateMS, eventRecord);\n                dateMS += MILLIS_PER_DAY;\n            } while (dateMS < endDateMS);\n        }\n    }\n    sync(action, added, removed, replaced, wasSet) {\n        added = added || emptyArray;\n        removed = removed || emptyArray;\n        const\n            me            = this,\n            addedCount    = added.length,\n            removedCount  = removed.length,\n            replacedCount = replaced?.length;\n        let i, newEvent, outgoingEvent;\n        if (!me.initialized) {\n            return;\n        }\n        switch (action) {\n            case 'clear':\n                me.clear();\n                break;\n            // Add and remove\n            case 'splice':\n                // Handle replacement of records by instances with same ID\n                if (replacedCount) {\n                    added = added.slice();\n                    removed = removed.slice();\n                    for (i = 0; i < replacedCount; i++) {\n                        removed.push(replaced[i][0]);\n                        added.push(replaced[i][1]);\n                    }\n                }\n                // Remove entries from indices\n                if (removedCount) {\n                    for (i = 0; i < removedCount; i++) {\n                        outgoingEvent = removed[i];\n                        me.removeEvent(outgoingEvent, outgoingEvent.startDate, outgoingEvent.endDate);\n                    }\n                }\n                // Add entries to indices\n                if (addedCount) {\n                    for (i = 0; i < addedCount; i++) {\n                        newEvent = added[i];\n                        // Can only be date-indexed if it's scheduled.\n                        // Also ignore parent events (likely using a Gantt project)\n                        if (newEvent.isScheduled && !newEvent.isParent) {\n                            me.addEvent(newEvent);\n                        }\n                    }\n                }\n                break;\n            // invoked when the start or end changes so that the event can be re-indexed.\n            case 'reschedule':\n                outgoingEvent = added[0];\n                me.removeEvent(outgoingEvent, wasSet.startDate?.oldValue || outgoingEvent.startDate,\n                    wasSet.endDate?.oldValue || outgoingEvent.endDate);\n                // Now process as a splice with an add and no removes.\n                me.sync('splice', added);\n                break;\n        }\n    }\n    /**\n     * This method registers a `dayTime` instance with this index in the `users` array.\n     * @param {Core.util.DayTime} dayTime The instance to register.\n     */\n    register(dayTime) {\n        this.users.push(dayTime);\n    }\n    /**\n     * This method unregisters a `dayTime` instance, removing it from the `users` array. This method returns `true` if\n     * this was the last registered instance and this index is no longer needed.\n     * @param {Core.util.DayTime} dayTime The instance to register.\n     * @returns {Boolean}\n     */\n    unregister(dayTime) {\n        const\n            { users } = this,\n            i = users.indexOf(dayTime);\n        if (i > -1) {\n            users.splice(i, 1);\n        }\n        return !users.length;\n    }\n};\n// To avoid shape changes:\nconst proto = EventDayIndex.prototype;\nindexProps.forEach(name => proto[name] = null);\nproto.initialized = false;\nEventDayIndex._$name = 'EventDayIndex';", "import DayTime from '../../../Core/util/DayTime.js';\nimport EventDayIndex from '../util/EventDayIndex.js';\n/**\n * @module Scheduler/data/mixin/DayIndexMixin\n */\nconst { MIDNIGHT } = DayTime;\n/**\n * Mixing handling Calendars day indices.\n *\n * Consumed by EventStore in Scheduler & Scheduler Pro and TaskStore in Gantt.\n *\n * @mixin\n * @internal\n */\nexport default Target => class DayIndexMixin extends Target {\n    static $name = 'DayIndexMixin';\n    construct(config) {\n        super.construct(config);\n        this.dayIndices = null;\n    }\n    //region Keeping index in sync\n    // Override to syncIndices on initial load\n    afterLoadData() {\n        this.syncIndices('splice', this.storage.allValues);\n        super.afterLoadData?.();\n    }\n    /**\n     * Responds to mutations of the underlying storage Collection.\n     *\n     * Maintain indices for fast finding of events by date.\n     * @param {Object} event\n     * @private\n     */\n    onDataChange({ action, added, removed, replaced }) {\n        // Indices must be synced before responding to change\n        this.syncIndices(action, added, removed, replaced);\n        super.onDataChange(...arguments);\n    }\n    onDataReplaced(action, data) {\n        // Indices must be synced before responding to change\n        this.syncIndices('clear');\n        this.syncIndices('splice', this.storage.values);\n        super.onDataReplaced(action, data);\n    }\n    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {\n        // Ensure by-date indices are up to date.\n        if (('startDate' in wasSet) || ('endDate' in wasSet)) {\n            this.syncIndices('reschedule', [record], null, null, wasSet);\n        }\n        super.onModelChange(...arguments);\n    }\n    //endregion\n    //region Index\n    /**\n     * Invalidates associated day indices.\n     * @internal\n     */\n    invalidateDayIndices() {\n        this.dayIndices?.forEach(dayIndex => dayIndex.invalidate());\n    }\n    /**\n     * Registers a `DayTime` instance, creating an `EventDayIndex` for each distinct `startShift`. This index is\n     * maintained until all instances with a matching `startShift` are {@link #function-unregisterDayIndex unregistered}.\n     * @param {Core.util.DayTime} dayTime The instance to register.\n     * @internal\n     * @category Indexing\n     */\n    registerDayIndex(dayTime) {\n        const\n            me = this,\n            dayIndices = me.dayIndices || (me.dayIndices = []);\n        let dayIndex, i;\n        for (i = 0; !dayIndex && i < dayIndices.length; ++i) {\n            if (dayIndices[i].matches(dayTime)) {\n                (dayIndex = dayIndices[i]).register(dayTime);\n            }\n        }\n        !dayIndex && dayIndices.push(dayIndex = new EventDayIndex(me, dayTime));\n        return dayIndex;\n    }\n    syncIndices(...args) {\n        this.dayIndices?.forEach(dayIndex => dayIndex.sync(...args));\n    }\n    /**\n     * Removes a registered `DayTime` instance. If this is the last instance registered to an `EventDayIndex`, that\n     * index is removed.\n     * @param {Core.util.DayTime} dayTime The instance to unregister.\n     * @internal\n     * @category Indexing\n     */\n    unregisterDayIndex(dayTime) {\n        const\n            me = this,\n            { dayIndices } = me;\n        for (let i = dayIndices?.length; i-- > 0; /* empty */) {\n            if (dayIndices[i].matches(dayTime)) {\n                if (dayIndices[i].unregister(dayTime)) {\n                    dayIndices.splice(i, 1);\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Returns the `EventDayIndex` to use for the given `DayTime` instance. This may be the primary instance or a\n     * child instance created by {@link #function-registerDayIndex}.\n     * @param {Core.util.DayTime} dayTime The `DayTime` of the desired index.\n     * @returns {Scheduler.data.util.EventDayIndex}\n     * @private\n     * @category Indexing\n     */\n    useDayIndex(dayTime) {\n        const\n            me             = this,\n            { dayIndices } = me;\n        dayTime = dayTime || MIDNIGHT;\n        for (let i = 0; dayIndices && i < dayIndices.length; ++i) {\n            if (dayIndices[i].matches(dayTime)) {\n                return dayIndices[i];\n            }\n        }\n        if (dayTime.startShift) {\n            throw new Error(`No day index registered for ${dayTime} on ${me.id}`);\n        }\n        return me.registerDayIndex(MIDNIGHT);\n    }\n    //endregion\n};\n", "/**\n * @module Scheduler/data/mixin/SharedEventStoreMixin\n */\n/**\n * This is a mixin, containing functionality related to managing events.\n *\n * It is consumed by the regular {@link Scheduler.data.EventStore} class and Scheduler Pros counterpart.\n *\n * @mixin\n */\nexport default Target => class SharedEventStoreMixin extends Target {\n    static get $name() {\n        return 'SharedEventStoreMixin';\n    }\n    /**\n     * Add events to the store.\n     *\n     * NOTE: Dates, durations and references (assignments, resources) on the events are determined async by a calculation\n     * engine. Thus they cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * eventStore.add({ startDate, duration });\n     * // endDate is not yet calculated\n     * ```\n     *\n     * To guarantee data is in a calculated state, wait for calculations for finish:\n     *\n     * ```javascript\n     * eventStore.add({ startDate, duration });\n     * await eventStore.project.commitAsync();\n     * // endDate is calculated\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * await eventStore.addAsync({ startDate, duration });\n     * // endDate is calculated\n     * ```\n     *\n     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.EventModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n    /**\n     * Add events to the store and triggers calculations directly after. Await this function to have up to date data on\n     * the added events.\n     *\n     * ```javascript\n     * await eventStore.addAsync({ startDate, duration });\n     * // endDate is calculated\n     * ```\n     *\n     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.EventModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n    /**\n     * Applies a new dataset to the EventStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: Dates, durations and relations (assignments, resources) on the events are determined async by a calculation\n     * engine. Thus they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * eventStore.data = [{ startDate, duration }];\n     * // eventStore.first.endDate is not yet calculated\n     * ```\n     *\n     * To guarantee data is in a calculated state, wait for calculations for finish:\n     *\n     * ```javascript\n     * eventStore.data = [{ startDate, duration }];\n     * await eventStore.project.commitAsync();\n     * // eventStore.first.endDate is calculated\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await eventStore.loadDataAsync([{ startDate, duration }]);\n     * // eventStore.first.endDate is calculated\n     * ```\n     *\n     * @member {EventModelConfig[]} data\n     * @category Records\n     */\n    /**\n     * Applies a new dataset to the EventStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await eventStore.loadDataAsync([{ startDate, duration }]);\n     * // eventStore.first.endDate is calculated\n     * ```\n     *\n     * @param {EventModelConfig[]} data Array of EventModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 100,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 200,\n            storeId : 'events',\n            /**\n             * Configure with `true` to also remove the event when removing the last assignment from the linked\n             * AssignmentStore. This config has not effect when using EventStore in legacy `resourceId`-mode.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            removeUnassignedEvent : true,\n            /**\n             * Configure with `true` to force single-resource mode, an event can only be assigned to a single resource.\n             * If not provided, the mode will be inferred from\n             *\n             * 1. presence of an assignment store (i.e. multi-assignment)\n             * 2. presence of `resourceId` in the event store data (i.e. single assignment mode)\n             * @config {Boolean}\n             * @category Common\n             */\n            singleAssignment : null\n        };\n    }\n    /**\n     * Class used to represent records. Defaults to class EventModel.\n     * @member {Scheduler.model.EventModel} modelClass\n     * @typings {typeof EventModel}\n     * @category Records\n     */\n    construct(config) {\n        super.construct(config, true);\n        if (this.singleAssignment) {\n            this.usesSingleAssignment = true;\n        }\n        if (!this.modelClass.isEventModel) {\n            throw new Error('The model for the EventStore must subclass EventModel');\n        }\n    }\n    /**\n     * Appends a new record to the store\n     * @param {Scheduler.model.EventModel} record The record to append to the store\n     * @category CRUD\n     */\n    append(record) {\n        return this.add(record);\n    }\n    //region Project\n    get project() {\n        return super.project;\n    }\n    set project(project) {\n        super.project = project;\n        this.detachListeners('project');\n        if (project) {\n            // Project already has AssignmentStore instance? Attach to it.\n            if (project.assignmentStore?.isAssignmentStore) {\n                this.attachToAssignmentStore(project.assignmentStore);\n            }\n            // Accessing assignmentStore would trigger `assignmentStoreChange` event on the project, so we set up\n            // the listener after\n            project.ion({\n                name                  : 'project',\n                assignmentStoreChange : 'onProjectAssignmentStoreChange',\n                thisObj               : this,\n                prio                  : 200 // Before UI updates\n            });\n        }\n    }\n    //endregion\n    //region Single assignment\n    get usesSingleAssignment() {\n        if (this.isChained) {\n            return this.masterStore.usesSingleAssignment;\n        }\n        return this._usesSingleAssignment;\n    }\n    set usesSingleAssignment(value) {\n        this._usesSingleAssignment = value;\n    }\n    processRecords(eventRecords) {\n        const\n            { assignmentStore } = this,\n            assignmentsToAdd = [];\n        // Same as on `joinRecordsToStore`, when adding a number of event records CoreEventMixin#joinProject method\n        // will clear/rebuild cache in a loop. We raise this flag to skip invalidating assignment store indices for the time\n        // we are joining records to the store. When they're added and indices are read, we will invalidate them.\n        if (assignmentStore) {\n            assignmentStore.skipInvalidateIndices = true;\n        }\n        eventRecords = super.processRecords(eventRecords, assignmentStore && !this.stm?.isRestoring && (eventRecord => {\n            // AssignmentStore found, add an assignment to it if this is not a dataset operation\n            const resourceId = eventRecord.get('resourceId');\n            if (!eventRecord.reassignedFromReplace && resourceId != null) {\n                // Check if the event is already assigned to the resource, though it's not in the event store.\n                // It could happen when you remove an event, so both event and assignment records are removed,\n                // then you \"undo\" the action and the assignment is restored before the event is restored.\n                if (!assignmentStore.includesAssignment(eventRecord.id, resourceId)) {\n                    // Cannot use `event.assign(resourceId)` since event is not part of store yet\n                    // Using a bit shorter generated id to not look so ugly in DOM\n                    assignmentsToAdd.push({\n                        id      : assignmentStore.modelClass.generateId(''),\n                        resourceId,\n                        eventId : eventRecord.id\n                    });\n                }\n            }\n            // clear flag\n            eventRecord.reassignedFromReplace = false;\n        }) || undefined);\n        if (assignmentStore) {\n            assignmentStore.storage.invalidateIndices();\n            assignmentStore.skipInvalidateIndices = false;\n            assignmentStore.add(assignmentsToAdd);\n        }\n        return eventRecords;\n    }\n    joinRecordsToStore(records) {\n        const { assignmentStore } = this;\n        if (assignmentStore) {\n            // When adding a number of event records CoreEventMixin#joinProject method will clear/rebuild cache in a loop.\n            // We raise this flag to skip invalidating assignment store indices for the time we are joining records to\n            // the store. When they're added and indices are read, we will invalidate them.\n            assignmentStore.skipInvalidateIndices = true;\n            super.joinRecordsToStore(records);\n            assignmentStore.storage.invalidateIndices();\n            assignmentStore.skipInvalidateIndices = false;\n        }\n        else {\n            super.joinRecordsToStore(records);\n        }\n    }\n    processRecord(eventRecord, isDataset = false) {\n        eventRecord = super.processRecord(eventRecord, isDataset);\n        const resourceId = eventRecord.get('resourceId');\n        if (resourceId != null && !eventRecord.meta.skipEnforcingSingleAssignment) {\n            const\n                me                  = this,\n                { assignmentStore } = me,\n                existingRecord      = me.getById(eventRecord.id),\n                isReplacing         = existingRecord && existingRecord !== eventRecord && !isDataset;\n            // Replacing an existing event, repoint the resource of its assignment\n            // (already repointed to the new event by engine in EventStoreMixin)\n            if (isReplacing) {\n                // Have to look assignment up on store, removed by engine in super call above\n                const assignment = assignmentStore.find(e => e.eventId === eventRecord.id);\n                if (assignment) {\n                    assignment.resource = resourceId;\n                    eventRecord.reassignedFromReplace = true;\n                }\n            }\n            // No AssignmentStore assigned yet, need to process when that happens. Or if it is a dataset operation,\n            // processing will happen at the end of it to not add individual assignment (bad for performance)\n            else {\n                me.$processResourceIds = true;\n            }\n            // Flag that we have been loaded using resourceId, checked by CrudManager to exclude the internal\n            // AssignmentStore from sync\n            me.usesSingleAssignment = true;\n        }\n        return eventRecord;\n    }\n    processResourceIds() {\n        const\n            me              = this,\n            // When used in a standalone CrudManager, there is no direct link to the assignment store\n            assignmentStore = me.assignmentStore ?? me.crudManager?.assignmentStore;\n        if (me.$processResourceIds && assignmentStore?.isAssignmentStore && !(me.project?.isSharingAssignmentStore && me.isChained)) {\n            const assignments = [];\n            // resourceIds used during initialization, convert into assignments\n            me.forEach(eventRecord => {\n                const { resourceId, id : eventId } = eventRecord;\n                if (resourceId != null) {\n                    // Using a bit shorter generated id to not look so ugly in DOM\n                    assignments.push({\n                        id : assignmentStore.modelClass.generateId(''),\n                        resourceId,\n                        eventId\n                    });\n                }\n            });\n            // Disable as much as possible, since we are in full control of this store when using single assignment mode\n            assignmentStore.useRawData = {\n                disableDefaultValue     : true,\n                disableDuplicateIdCheck : true,\n                disableTypeConversion   : true\n            };\n            // Flag that throws in AssignmentStore if data is loaded some other way when using single assignment\n            assignmentStore.usesSingleAssignment = false;\n            // These assignments all use generated ids, and are not meant to be searialized anyway so bypass check\n            assignmentStore.verifyNoGeneratedIds = false;\n            assignmentStore.data = assignments;\n            assignmentStore.usesSingleAssignment = true;\n            me.$processResourceIds = false;\n        }\n    }\n    loadData() {\n        super.loadData(...arguments);\n        this.processResourceIds();\n    }\n    // Optionally remove unassigned events\n    onBeforeRemoveAssignment({ records }) {\n        const me = this;\n        if (\n            me.removeUnassignedEvent && !me.isRemoving && !me.isSettingData &&\n            !me.stm?.isRestoring && !me.usesSingleAssignment &&\n            // Do not remove unassigned events when syncing data, new assignments etc. might be synced afterwards\n            !me.assignmentStore.isSyncingDataOnLoad && !me.resourceStore.isSyncingDataOnLoad\n        ) {\n            const toRemove = new Set();\n            // Collect all events that are unassigned after the remove\n            records.forEach(assignmentRecord => {\n                const { event } = assignmentRecord;\n                // Assignment might not have an event or the event might already be removed\n                if (event && !event.isRemoved && event.assignments.every(a => records.includes(a))) {\n                    toRemove.add(event);\n                }\n            });\n            // And remove them\n            if (toRemove.size) {\n                me.remove([...toRemove]);\n            }\n        }\n    }\n    onProjectAssignmentStoreChange({ store }) {\n        this.attachToAssignmentStore(store);\n    }\n    attachToAssignmentStore(assignmentStore) {\n        const me = this;\n        me.detachListeners('assignmentStore');\n        if (assignmentStore) {\n            me.processResourceIds();\n            assignmentStore.ion({\n                name : 'assignmentStore',\n                // Adding an assignment in single assignment mode should set events resourceId if needed\n                addPreCommit({ records }) {\n                    if (me.usesSingleAssignment && !me.isSettingData && !me.isAssigning) {\n                        records.forEach(assignment => {\n                            const { event } = assignment;\n                            if (event?.isEvent && event.resourceId !== assignment.resourceId) {\n                                event.meta.isAssigning = true;\n                                event.set('resourceId', assignment.resourceId);\n                                event.meta.isAssigning = false;\n                            }\n                        });\n                    }\n                },\n                // Called both for remove and removeAll\n                beforeRemove : 'onBeforeRemoveAssignment',\n                // Removing an assignment in single assignment mode should set events resourceId to null\n                removePreCommit({ records }) {\n                    if (me.usesSingleAssignment) {\n                        records.forEach(assignment => {\n                            // With engine link to event is already broken when we get here, hence the lookup\n                            me.getById(assignment.eventId)?.set('resourceId', null);\n                        });\n                    }\n                },\n                removeAllPreCommit() {\n                    if (me.usesSingleAssignment && !me.isSettingData) {\n                        me.allRecords.forEach(eventRecord => eventRecord.set('resourceId', null));\n                    }\n                },\n                // Keep events resourceId in sync with assignment on changes in single assignment mode\n                update({ record, changes }) {\n                    if (me.usesSingleAssignment && 'resourceId' in changes) {\n                        const { event } = record;\n                        event.meta.isAssigning = true;\n                        event.set('resourceId', changes.resourceId.value);\n                        event.meta.isAssigning = false;\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n    set data(data) {\n        this.isSettingData = true;\n        // When using single assignment, remove all assignments when loading a new set of events.\n        // Don't do it when filling a chained store, assignments are for the master store\n        if (this.usesSingleAssignment && !this.syncDataOnLoad && !this.isChained) {\n            this.assignmentStore.removeAll(true);\n        }\n        super.data = data;\n        this.isSettingData = false;\n    }\n    // Override trigger to decorate update/change events with a flag if resourceId was the only thing changed, in which\n    // case the change most likely can be ignored since the assignment will also change\n    trigger(eventName, params) {\n        const { changes } = params || {};\n        // https://github.com/bryntum/support/issues/6610\n        // test: SchedulerPro/tests/data/UndoRedo.t.js, \"Should refresh the view after undoing the event copy-paste\"\n        // can not ignore this event when stm is restoring, because of the edge case in that ticket\n        if (changes && 'resourceId' in changes && Object.keys(changes).length === 1 && !this.stm?.isRestoring) {\n            params.isAssign = true;\n        }\n        return super.trigger(...arguments);\n    }\n    remove(records, ...args) {\n        const result = super.remove(records, ...args);\n        // Make sure assignment is removed with event when using single assignment\n        if (result.length && this.usesSingleAssignment) {\n            for (const eventRecord of result) {\n                if (!eventRecord.isOccurrence) {\n                    (this.assignmentStore || this.crudManager?.assignmentStore)?.remove(eventRecord.assignments, true);\n                }\n            }\n        }\n        return result;\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport RecurringTimeSpansMixin from './RecurringTimeSpansMixin.js';\n/**\n * @module Scheduler/data/mixin/RecurringEventsMixin\n */\n/**\n * This mixin class provides recurrence functionality to the {@link Scheduler.data.EventStore event store}.\n * @extends Scheduler/data/mixin/RecurringTimeSpansMixin\n * @mixin\n */\nexport default Target => class RecurringEventsMixin extends RecurringTimeSpansMixin(Target || Base) {\n    static get $name() {\n        return 'RecurringEventsMixin';\n    }\n    /**\n     * Returns all the recurring events.\n     *\n     * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-getRecurringTimeSpans} method.\n     *\n     * @returns {Scheduler.model.EventModel[]} Array of recurring events.\n     * @category Recurrence\n     */\n    getRecurringEvents() {\n        return this.getRecurringTimeSpans();\n    }\n    isEventPersistable(event) {\n        // occurrences are not persistable\n        return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);\n    }\n};\n", "import DH from '../../../Core/helper/DateHelper.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nconst\n    oneDayMS = 1000 * 60 * 60 * 24;\n/**\n * @module Scheduler/model/mixin/EventModelMixin\n */\n/**\n * Mixin that holds configuration shared between events in Scheduler and Scheduler Pro.\n * @mixin\n */\nexport default Target => class EventModelMixin extends Target {\n    static get $name() {\n        return 'EventModelMixin';\n    }\n    // Flag checked by EventStore to make sure it uses a valid subclass\n    static get isEventModel() {\n        return true;\n    }\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     *\n     * ```javascript\n     * eventRecord.set('duration', 4);\n     * // eventRecord.endDate is not yet calculated\n     *\n     * await eventRecord.setAsync('duration', 4);\n     * // eventRecord.endDate is calculated\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events. If event is recurring, occurrences won't be updated\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n    //region Fields\n    static get fields() {\n        return [\n            /**\n             * The start date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}\n             * for details.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * Also note that modifying the `startDate` at runtime will move the event in time, without affecting its\n             * duration (with reservation for other scheduling logic affecting the duration). If you want to change the\n             * `startDate` and `duration`, use {@link Scheduler/model/TimeSpan#function-setStartDate} instead (passing\n             * `false` as the second argument).\n             *\n             * @field {Date} startDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            /**\n             * The end date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable} for details.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} endDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            /**\n             * The numeric part of the timespan's duration (the number of units).\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}\n             * for details.\n             *\n             * @field {Number} duration\n             * @category Scheduling\n             */\n            /**\n             * Calculated field which encapsulates the duration's magnitude and unit. This field will not be persisted,\n             * setting it will update the {@link #field-duration} and\n             * {@link Scheduler.model.TimeSpan#field-durationUnit} fields.\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}\n             * for details.\n             *\n             * @field {DurationConfig|Core.data.Duration} fullDuration\n             * @category Scheduling\n             */\n            /**\n             * The unique identifier of a task (mandatory)\n             * @field {String|Number} id\n             * @category Common\n             */\n            /**\n             * Id of the resource this event is associated with (only usable for single assignments). We recommend\n             * using assignments in an AssignmentStore over this approach. Internally any Event using `resourceId`\n             * will have an assignment in AssignmentStore generated.\n             * @field {String|Number} resourceId\n             * @category Common\n             */\n            {\n                name     : 'resourceId',\n                internal : true\n            },\n            /**\n             * The array of {@link Scheduler.model.ResourceModel resources} which are assigned to this event.\n             * @field {String|Number} resources\n             * @category Common\n             */\n            {\n                name   : 'resources',\n                column : {\n                    type : 'resourceassignment'\n                },\n                persist  : false,\n                internal : true\n            },\n            /**\n             * Specify false to prevent the event from being dragged (if EventDrag feature is used)\n             * @field {Boolean} draggable\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'draggable',\n                type         : 'boolean',\n                persist      : false,\n                defaultValue : true,\n                internal     : true\n            },\n            /**\n             * Specify `false` to prevent the event from being resized (if EventResize feature is used). You can also\n             * specify `'start'` or `'end'` to only allow resizing in one direction\n             * @field {Boolean|String} resizable\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'resizable',\n                persist      : false,\n                defaultValue : true,\n                internal     : true\n            }, // true, false, 'start' or 'end'\n            /**\n             * A field marking event as all day(s) spanning event.\n             * For example, a holiday day may be represented by a `startDate`, and the `allDay` flag.\n             * @field {Boolean} allDay\n             * @category Scheduling\n             */\n            {\n                name         : 'allDay',\n                type         : 'boolean',\n                defaultValue : false\n            },\n            /**\n             * Controls this events appearance, see Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for\n             * available options.\n             * @field {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'|null} eventStyle\n             * @category Styling\n             */\n            {\n                name     : 'eventStyle',\n                internal : true\n            },\n            /**\n             * Controls the primary color of the event, see Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for\n             * available colors.\n             * @field {'red'|'pink'|'purple'|'violet'|'indigo'|'blue'|'cyan'|'teal'|'green'|'lime'|'yellow'|'orange'|'deep-orange'|'gray'|'gantt-green'|String|null} eventColor\n             * @category Styling\n             */\n            {\n                name     : 'eventColor',\n                internal : true\n            },\n            /**\n             * Width (in px) to use for this milestone when using Scheduler#milestoneLayoutMode 'data'.\n             * @field {Number} milestoneWidth\n             * @category Styling\n             */\n            {\n                name     : 'milestoneWidth',\n                internal : true\n            },\n            /**\n             * Set this field to `false` to opt out of {@link Scheduler.feature.StickyEvents sticky event content}\n             * (keeping event text in view while scrolling).\n             * @field {Boolean} stickyContents\n             * @category Styling\n             */\n            {\n                name     : 'stickyContents',\n                internal : true\n            }\n        ];\n    }\n    //endregion\n    //region Id change\n    updateAssignmentEventIds() {\n        this.assigned.forEach(assignment => {\n            assignment.eventId = this.id;\n        });\n    }\n    syncId(value) {\n        super.syncId(value);\n        this.updateAssignmentEventIds();\n    }\n    //endregion\n    //region Resources\n    /**\n     * Returns all resources assigned to an event.\n     *\n     * @property {Scheduler.model.ResourceModel[]}\n     * @category Assignments & Resources\n     * @readonly\n     */\n    get resources() {\n        // Only include valid resources, to not have nulls in the result\n        return this.assignments.reduce((resources, { resource }) => {\n            resource && resources.push(resource.$original);\n            return resources;\n        }, []);\n    }\n    set resources(resources) {\n        resources = ArrayHelper.asArray(resources);\n        const\n            me             = this,\n            newResourceIds = resources.map(me.constructor.asId);\n        if (me.usesSingleAssignment) {\n            me.set('resourceId', newResourceIds[0]);\n        }\n        else {\n            const\n                existingResourceIds                     = me.assignments.map(a => a.resource.id),\n                { onlyInA : toAdd, onlyInB : toRemove } = ArrayHelper.delta(newResourceIds, existingResourceIds);\n            // Add first, remove after. Otherwise event might get removed with its last assignment\n            me.assignmentStore.add(toAdd.map(resourceId => ({ resource : resourceId, event : me })));\n            me.assignmentStore.remove(toRemove.map(resourceId => me.assignments.find(a => a.resource.id === resourceId)));\n        }\n    }\n    /**\n     * Iterate over all associated resources\n     * @private\n     * @category Assignments & Resources\n     */\n    forEachResource(fn, thisObj = this) {\n        for (const resource of this.resources) {\n            if (fn.call(thisObj, resource) === false) {\n                return;\n            }\n        }\n    }\n    /**\n     * Returns either the resource associated with this event (when called w/o `resourceId`) or resource\n     * with specified id.\n     *\n     * @param {String} [resourceId] To retrieve a specific resource\n     * @returns {Scheduler.model.ResourceModel}\n     * @category Assignments & Resources\n     */\n    getResource(resourceId) {\n        if (resourceId == null) {\n            return this.resource;\n        }\n        return this.resourceStore ? this.resourceStore.getById(resourceId) : null;\n    }\n    //endregion\n    //region Dates\n    get startDate() {\n        let dt;\n        if (this.isOccurrence) {\n            dt = this.get('startDate');\n        }\n        else {\n            // Micro optimization to avoid expensive super call. super will be hit in Scheduler Pro\n            dt = this._startDate ?? super.startDate;\n        }\n        if (this.allDay) {\n            dt = this.constructor.getAllDayStartDate(dt);\n        }\n        return dt;\n    }\n    set startDate(startDate) {\n        if (this.batching) {\n            this._startDate = startDate;\n            this.set({ startDate });\n        }\n        else {\n            super.startDate = startDate;\n        }\n    }\n    get endDate() {\n        let dt;\n        if (this.isOccurrence) {\n            dt = this.get('endDate');\n        }\n        else {\n            // Micro optimization to avoid expensive super call. super will be hit in Scheduler Pro\n            dt = this._endDate ?? super.endDate;\n        }\n        if (this.allDay) {\n            dt = this.constructor.getAllDayEndDate(dt);\n        }\n        return dt;\n    }\n    set endDate(endDate) {\n        if (this.batching) {\n            this._endDate = endDate;\n            this.set({ endDate });\n        }\n        else {\n            super.endDate = endDate;\n        }\n    }\n    // Cannot use `convert` method because it might be disabled by `useRawData : true` and we always need to calculate\n    // that value\n    get wrapStartDate() {\n        return this.startDate;\n    }\n    set wrapStartDate(value) {}\n    get wrapEndDate() {\n        return this.endDate;\n    }\n    set wrapEndDate(value) {}\n    /**\n     * Shift the dates for the date range by the passed amount and unit\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}\n     * for more information on valid formats.\n     * @param {Number} amount The amount to shift\n     * @returns {Promise} A promise which is resolved when shift calculations are done\n     * @async\n     * @method shift\n     * @category Scheduling\n     */\n    //endregion\n    //region Is\n    // Used internally to differentiate between Event and ResourceTimeRange\n    get isEvent() {\n        return true;\n    }\n    /**\n     * Returns true if event can be drag and dropped\n     * @property {Boolean}\n     * @category Editing\n     */\n    get isDraggable() {\n        return !this.readOnly && this.draggable;\n    }\n    /**\n     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can\n     * be resized.\n     *\n     * Milestones and parent events (that are not manuallyScheduled) cannot be resized.\n     *\n     * @property {Boolean|String}\n     * @readonly\n     * @category Editing\n     */\n    get isResizable() {\n        return !this.isMilestone && (!this.isParent || this.manuallyScheduled) && this.resizable;\n    }\n    /**\n     * Returns false if the event is not persistable. By default it always is, override this getter if you need\n     * custom logic.\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isPersistable() {\n        // Records not yet fully created cannot be persisted\n        return super.isPersistable && !this.isCreating;\n    }\n    endBatch() {\n        const\n            me = this,\n            { isPersistable : wasPersistable, meta : { batchChanges } } = me;\n        // Remove cached values\n        // https://github.com/bryntum/support/issues/3358\n        if (batchChanges) {\n            if ('endDate' in batchChanges) {\n                delete me._endDate;\n                // When project recalculates start/end date and committing changes to record it calls endBatch. In this\n                // case wrap dates become invalid and should be reset on the record. We do it by forcing `null` value.\n                // Possible scenarios include adding dependency or moving first event in a dependency chain.\n                // Covered by pro/features/BufferTimeDependencies.t\n                // wrap date is an internal field we should be fine without mapping\n                if (me.postamble) {\n                    me.wrapEndDate = null;\n                }\n            }\n            if ('startDate' in batchChanges) {\n                delete me._startDate;\n                if (me.preamble) {\n                    me.wrapStartDate = null;\n                }\n            }\n        }\n        super.endBatch(...arguments);\n        // If this event newly persistable, its assignments are eligible for syncing.\n        if (me.isPersistable && !wasPersistable && !me.ignoreBag && me.assigned) {\n            for (const assignment of me.assigned) {\n                assignment.stores.forEach(s =>\n                    s.updateModifiedBagForRecord(assignment)\n                );\n            }\n        }\n    }\n    get isCreating() {\n        return super.isCreating;\n    }\n    set isCreating(value) {\n        super.isCreating = value;\n        this.assignments.forEach(record => record.isCreating = value);\n    }\n    //endregion\n    //region Single assignment compatibility\n    get usesSingleAssignment() {\n        return !this.eventStore || this.eventStore.usesSingleAssignment;\n    }\n    copy(...args) {\n        const copy = super.copy(...args);\n        // Don't copy resourceId when using multi assignment\n        if (!this.usesSingleAssignment) {\n            copy.resourceId = null;\n        }\n        return copy;\n    }\n    /**\n     * Override persistable getter to prevent sending resourceId when using multiple resource assignment mode\n     * https://github.com/bryntum/support/issues/1345\n     * @private\n     */\n    get persistableData() {\n        const data = super.persistableData;\n        if (!this.usesSingleAssignment) {\n            delete data.resourceId;\n        }\n        return data;\n    }\n    /**\n     * Returns the first assigned resource, or assigns a resource\n     * @member {Scheduler.model.ResourceModel} resource\n     * @category Assignments & Resources\n     */\n    get resource() {\n        const { resources } = this;\n        return resources.length ? resources[0] : null;\n    }\n    set resource(resourceRecord) {\n        // Use the resourceId setter for single assignment\n        this.resourceId = this.constructor.asId(resourceRecord);\n    }\n    get resourceId() {\n        return this.usesSingleAssignment ? this.get('resourceId') : this.resource?.id;\n    }\n    set resourceId(resourceId) {\n        this.applyResourceId(resourceId);\n    }\n    // Resources + any links to any of them\n    get $linkedResources() {\n        return this.resources?.flatMap(resourceRecord => ([\n            resourceRecord,\n            ...resourceRecord.$links\n        ])) ?? [];\n    }\n    applyResourceId(resourceId, fromApplyValue = false) {\n        const\n            me                          = this,\n            { eventStore, assignments } = me;\n        // When part of an EventStore, resourceIds are changed to be AssignmentModels\n        if (eventStore) {\n            // If not yet part of project, we cant resolve assignmentStore from ourselves\n            const assignmentStore = eventStore.assignmentStore || eventStore.crudManager?.assignmentStore;\n            if (resourceId != null) {\n                if (!me.meta.skipEnforcingSingleAssignment) {\n                    eventStore.usesSingleAssignment = true;\n                }\n                // Reassign if already assigned, only single assignment allowed\n                if (assignments?.length && resourceId !== assignments[0].resourceId) {\n                    //assignments[0].set('resourceId', resourceId, Boolean(me.eventStore.eventsSuspended));\n                    // Silent reassign if events are suspended on event store, won't be expecting UI update then\n                    const eventsSuspended = Boolean(eventStore.eventsSuspended);\n                    eventsSuspended && assignmentStore.suspendEvents();\n                    assignments[0].resource = resourceId;\n                    eventsSuspended && assignmentStore.resumeEvents();\n                }\n                // Otherwise assign\n                else {\n                    assignmentStore.assignEventToResource(me, resourceId);\n                }\n            }\n            else {\n                // Setting resourceId to null removes all assignments\n                assignmentStore.remove(assignments);\n            }\n        }\n        // Not part of an EventStore, edge case. Set to data unless we are in such operation already\n        else if (!fromApplyValue) {\n            me.set({ resourceId });\n        }\n    }\n    // Special handling of setting resourceId, creates assignment\n    applyValue(useProp, mapping, value, skipAccessors, field) {\n        if (field && field.name === 'resourceId' && !this.meta.isAssigning) {\n            const { eventStore } = this;\n            eventStore && (eventStore.isAssigning = true);\n            this.applyResourceId(value, true);\n            eventStore && (eventStore.isAssigning = false);\n        }\n        super.applyValue(useProp, mapping, value, skipAccessors, field);\n    }\n    //endregion\n    //region Assignment\n    /**\n     * Returns all assignments for the event. Event must be part of the store for this method to work.\n     * @property {Scheduler.model.AssignmentModel[]}\n     * @readonly\n     * @category Assignments & Resources\n     */\n    get assignments() {\n        return [...(this.assigned || [])];\n    }\n    /**\n     * Assigns this event to the specified resource.\n     *\n     * *Note:* The event must be part of an EventStore for this to work. If the EventStore uses single assignment\n     * (loaded using resourceId) existing assignments will always be removed.\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource A new resource for this event, either as a full\n     *        Resource record or an id (or an array of such).\n     * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments\n     * @category Assignments & Resources\n     */\n    assign(resource, removeExistingAssignments = false) {\n        const { eventStore } = this;\n        if (eventStore && !eventStore.usesSingleAssignment) {\n            eventStore.assignEventToResource(this, resource, removeExistingAssignments);\n        }\n        else {\n            // Remember what resource to assign,  directly in single assignment mode or for later when we are joined to\n            // an EventStore\n            this.resourceId = this.constructor.asId(resource);\n            if (!eventStore) {\n                // Prevent flagging EventStore as using single assignment when that happens, we cannot know that here\n                this.meta.skipEnforcingSingleAssignment = true;\n            }\n        }\n    }\n    /**\n     * Unassigns this event from the specified resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} [resource] The resource to unassign from.\n     * @category Assignments & Resources\n     */\n    unassign(resource, removingResource = false) {\n        const me = this;\n        resource = me.constructor.asId(resource);\n        // If unassigned is caused by removing the resource the UI should be able to find out to not do extra redraws etc.\n        me.meta.removingResource = removingResource;\n        me.eventStore?.unassignEventFromResource(me, resource);\n        me.meta.removingResource = null;\n    }\n    /**\n     * Reassigns an event from an old resource to a new resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} oldResourceId A resource to unassign from or its id\n     * @param {Scheduler.model.ResourceModel|String|Number} newResourceId A resource to assign to or its id\n     * @category Assignments & Resources\n     */\n    reassign(oldResourceId, newResourceId) {\n        this.eventStore && this.eventStore.reassignEventFromResourceToResource(this, oldResourceId, newResourceId);\n    }\n    /**\n     * Returns true if this event is assigned to a certain resource.\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource The resource to query for\n     * @returns {Boolean}\n     * @category Assignments & Resources\n     */\n    isAssignedTo(resource) {\n        const resourceId = this.constructor.asId(resource);\n        return this.assignments.some(assignment => assignment.resourceId === resourceId);\n    }\n    //endregion\n    //region Dependencies\n    /**\n     * Returns all predecessor dependencies of this event\n     *\n     * @readonly\n     * @property {Scheduler.model.DependencyBaseModel[]}\n     * @category Dependencies\n     */\n    get predecessors() {\n        return [...this.incomingDeps ?? []];\n    }\n    /**\n     * Returns all successor dependencies of this event\n     *\n     * @readonly\n     * @property {Scheduler.model.DependencyBaseModel[]}\n     * @category Dependencies\n     *\n     */\n    get successors() {\n        return [...this.outgoingDeps ?? []];\n    }\n    get dependencies() {\n        // Dependency feature listens for assignment changes pre commit, thus we risk deps not being set up yet\n        return [...this.incomingDeps ?? [], ...this.outgoingDeps ?? []];\n    }\n    //endregion\n    normalize() {\n        // Normalization handled by Engine\n    }\n    inSetNormalize() {\n        // Normalization handled by Engine\n    }\n    /**\n     * The \"main\" event this model is an occurrence of.\n     * Returns `null` for non-occurrences.\n     * @property {Scheduler.model.EventModel}\n     * @alias #Scheduler.model.mixin.RecurringTimeSpan#property-recurringTimeSpan\n     * @readonly\n     * @category Scheduling\n     */\n    get recurringEvent() {\n        return this.recurringTimeSpan;\n    }\n    /**\n     * Flag which indicates that this event is an interday event. This means that it spans\n     * an entire day or multiple days.\n     *\n     * This is essentially used by the Calendar package to determine if an event should\n     * go into the all day zone of a DayView.\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Scheduling\n     */\n    get isInterDay() {\n        const { durationMS } = this;\n        // A full day (86400000 or more) marks as it as interDay,\n        // which means it belongs in the all day row of a Calendar DayView\n        if (durationMS >= oneDayMS || (!durationMS && this.allDay)) {\n            return true;\n        }\n        // Working out whether it crosses midnight is a little more difficult\n        const\n            {\n                endDate,\n                startDate\n            } = this,\n            eventStartMidnight = DH.clearTime(startDate);\n        // If either is null or NaN, we have to answer falsy\n        if (startDate && endDate) {\n            eventStartMidnight.setDate(eventStartMidnight.getDate() + 1);\n            // If the endDate is past midnight, it's interDay and goes in the all day row of a Calendar DayView\n            return (endDate || DH.add(startDate, durationMS)) > eventStartMidnight;\n        }\n    }\n    //region All day statics\n    static getAllDayStartDate(dt) {\n        if (dt && dt.isEvent) {\n            dt = dt.get('startDate');\n        }\n        if (dt) {\n            dt = DH.clearTime(dt, true);\n        }\n        return dt;\n    }\n    static getAllDayEndDate(dt) {\n        if (dt && dt.isEvent) {\n            dt = dt.get('endDate');\n        }\n        if (dt && (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0)) {\n            dt = DH.getNext(dt, 'd', 1);\n        }\n        return dt;\n    }\n    static getAllDayDisplayStartDate(dt) {\n        if (dt && dt.isEvent) {\n            dt = dt.get('startDate');\n        }\n        return DH.clearTime(dt, true);\n    }\n    static getAllDayDisplayEndDate(startDate, endDate) {\n        if (startDate && startDate.isEvent) {\n            endDate   = startDate.get('endDate');\n            startDate = startDate.get('startDate');\n        }\n        if (endDate) {\n            startDate = this.constructor.getAllDayDisplayStartDate(startDate);\n            // If date falls on start of the day - subtract one day to show end date correctly\n            // e.g. event starts on 2017-01-01 00:00 and ends on 2017-01-02 00:00, editor should show\n            // 2017-01-01 for both start and end\n            if (DH.clearTime(endDate, true).valueOf() === endDate.valueOf()) {\n                endDate = DH.add(endDate, DH.DAY, -1);\n            }\n            else if (startDate.valueOf() !== endDate.valueOf()) {\n                endDate = DH.clearTime(endDate, true);\n            }\n        }\n        return endDate;\n    }\n    /**\n     * Defines if the given event field should be manually editable in UI.\n     * You can override this method to provide your own logic.\n     *\n     * By default, the method defines {@link #field-endDate}, {@link #field-duration} and {@link #field-fullDuration}\n     * fields editable for leaf events only (in case the event is part of a tree store) and all other fields as\n     * editable.\n     *\n     * @param {String} fieldName Name of the field\n     * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the event has\n     * no such field.\n     * @category Editing\n     */\n    isEditable(fieldName) {\n        switch (fieldName) {\n            // end/duration is allowed to edit for leafs\n            case 'endDate' :\n            case 'duration' :\n            case 'fullDuration' :\n                return this.isLeaf;\n        }\n        return super.isEditable(fieldName);\n    }\n    //endregion\n};\n", "import TimeSpan from './TimeSpan.js';\nimport RecurringTimeSpan from './mixin/RecurringTimeSpan.js';\nimport EventModelMixin from './mixin/EventModelMixin.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { SchedulerCoreEvent } from '../../Engine/quark/model/scheduler_core/SchedulerCoreEvent.js';\nconst EngineMixin = SchedulerCoreEvent;\n/**\n * @module Scheduler/model/EventModel\n */\n/**\n * This class represent a single event in your schedule, usually added to a {@link Scheduler.data.EventStore}.\n *\n * It is a subclass of the {@link Scheduler.model.TimeSpan}, which is in turn subclass of {@link Core.data.Model}.\n * Please refer to documentation of that class to become familiar with the base interface of the event.\n *\n * ## Async date calculations\n *\n * A record created from an {@link Scheduler/model/EventModel} is normally part of an {@link Scheduler.data.EventStore},\n * which in turn is part of a project. When dates or the duration of an event is changed, the project performs async calculations\n * to normalize the other fields.\n * For example if {@link #field-duration} is changed, it will calculate {@link #field-endDate}.\n *\n * As a result of this being an async operation, the values of other fields are not guaranteed to be up to date\n * immediately after a change. To ensure data is up to date, await the calculations to finish.\n *\n * For example, {@link #field-endDate} is not up to date after this operation:\n *\n * ```javascript\n * eventRecord.duration = 5;\n * // endDate not yet calculated\n * ```\n *\n * But if calculations are awaited it is up to date:\n *\n * ```javascript\n * eventRecord.duration = 5;\n * await eventRecord.project.commitAsync();\n * // endDate is calculated\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await eventRecord.setAsync({ duration : 5});\n * // endDate is calculated\n * ```\n *\n * ## Subclassing the Event model class\n * The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,\n * you can do that by subclassing this class (see example below).\n *\n * ```javascript\n * class MyEvent extends EventModel {\n *\n *     static get fields() {\n *         return [\n *            // Add new field\n *            { name: 'myField', type : 'number', defaultValue : 0 }\n *         ];\n *     },\n *\n *     myCheckMethod() {\n *         return this.myField > 0\n *     },\n *\n *     ...\n * });\n * ```\n *\n * If you in your data want to use other names for the {@link #field-startDate}, {@link #field-endDate}, {@link #field-resourceId} and name fields you can configure\n * them as seen below:\n *\n * ```javascript\n * class MyEvent extends EventModel {\n *\n *     static get fields() {\n *         return [\n *            { name: 'startDate', dataSource : 'taskStart' },\n *            { name: 'endDate', dataSource : 'taskEnd', format: 'YYYY-MM-DD' },\n *            { name: 'resourceId', dataSource : 'userId' },\n *            { name: 'name', dataSource : 'taskTitle' },\n *         ];\n *     },\n *     ...\n * });\n * ```\n *\n * Please refer to {@link Core.data.Model} for additional details.\n *\n * @extends Scheduler/model/TimeSpan\n * @mixes Scheduler/model/mixin/RecurringTimeSpan\n * @mixes Scheduler/model/mixin/EventModelMixin\n */\nexport default class EventModel extends EngineMixin.derive(TimeSpan).mixin(\n    RecurringTimeSpan,\n    PartOfProject,\n    EventModelMixin\n) {\n    static get $name() {\n        return 'EventModel';\n    }\n}\nEventModel.exposeProperties();\nEventModel._$name = 'EventModel';", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport EventStoreMixin from './mixin/EventStoreMixin.js';\nimport GetEventsMixin from './mixin/GetEventsMixin.js';\nimport DayIndexMixin from './mixin/DayIndexMixin.js';\nimport SharedEventStoreMixin from './mixin/SharedEventStoreMixin.js';\nimport RecurringEventsMixin from './mixin/RecurringEventsMixin.js';\nimport EventModel from '../model/EventModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport { CoreEventStoreMixin } from '../../Engine/quark/store/CoreEventStoreMixin.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\nconst EngineMixin = PartOfProject(CoreEventStoreMixin.derive(AjaxStore));\n/**\n * @module Scheduler/data/EventStore\n */\n/**\n * A store holding all the {@link Scheduler.model.EventModel events} to be rendered into a {@link Scheduler.view.Scheduler Scheduler}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.EventModel}.\n *\n * An EventStore is usually connected to a project, which binds it to other related stores (AssignmentStore,\n * ResourceStore and DependencyStore). The project also handles normalization/calculation of the data on the records in\n * the store. For example if a record is added with a `startDate` and an `endDate`, it will calculate the `duration`.\n *\n * The calculations happens async, records are not guaranteed to have up to date data until they are finished. To be\n * certain that calculations have finished, call `await project.commitAsync()` after store actions. Or use one of the\n * `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * eventStore.data = [{ startDate, endDate }, ...];\n *\n * // duration of the record is not yet calculated\n *\n * await eventStore.project.commitAsync();\n *\n * // now it is\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await eventStore.loadDataAsync([{ startDate, endDate }, ...]);\n *\n * // duration is calculated\n * ```\n *\n * ## Using recurring events\n * When recurring events are in the database, **all recurring event definitions** which started before\n * the requested start date, and have not yet finished recurring MUST be loaded into the EventStore.\n *\n * Only the **base** recurring event **definitions** are stored in the EventStore. You do not\n * need to calculate the future occurrence dates of these events. This is all handled by the EventStore.\n *\n * When asked to yield a set of events for a certain date range for creating a UI through\n * {@link #function-getEvents}, the EventStore *automatically* interpolates any occurrences of\n * recurring events into the results. They do not occupy slots in the EventStore for every date\n * in their repetition range (that would be very inefficient, and *might* be infinite).\n *\n * @mixes Scheduler/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/SharedEventStoreMixin\n * @mixes Scheduler/data/mixin/EventStoreMixin\n * @mixes Scheduler/data/mixin/RecurringEventsMixin\n * @mixes Scheduler/data/mixin/GetEventsMixin\n * @extends Core/data/AjaxStore\n */\nexport default class EventStore extends EngineMixin.mixin(\n    SharedEventStoreMixin,\n    RecurringEventsMixin,\n    EventStoreMixin,\n    DayIndexMixin,\n    GetEventsMixin\n) {\n    static $name = 'EventStore';\n    static get defaultConfig() {\n        return {\n            /**\n             * Class used to represent records\n             * @config {Scheduler.model.EventModel}\n             * @typings {typeof EventModel}\n             * @default\n             * @category Common\n             */\n            modelClass : EventModel\n        };\n    }\n}\nEventStore._$name = 'EventStore';", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/data/mixin/ResourceStoreMixin\n */\n/**\n * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Scheduler.data.ResourceStore}.\n *\n * @mixin\n */\nexport default Target => class ResourceStoreMixin extends (Target || Base) {\n    static get $name() {\n        return 'ResourceStoreMixin';\n    }\n    get isResourceStore() {\n        return true;\n    }\n    /**\n     * Add resources to the store.\n     *\n     * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus they\n     * cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * const [resource] = resourceStore.add({ id });\n     * // resource.events is not yet available\n     * ```\n     *\n     * To guarantee references are set up, wait for calculations for finish:\n     *\n     * ```javascript\n     * const [resource] = resourceStore.add({ id });\n     * await resourceStore.project.commitAsync();\n     * // resource.events is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * const [resource] = await resourceStore.addAsync({ id });\n     * // resource.events is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.ResourceModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n    /**\n     * Add resources to the store and triggers calculations directly after. Await this function to have up to date\n     * references on the added resources.\n     *\n     * ```javascript\n     * const [resource] = await resourceStore.addAsync({ id });\n     * // resource.events is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.ResourceModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n    /**\n     * Applies a new dataset to the ResourceStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus\n     * they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * resourceStore.data = [{ id }];\n     * // resourceStore.first.events is not yet available\n     * ```\n     *\n     * To guarantee references are available, wait for calculations for finish:\n     *\n     * ```javascript\n     * resourceStore.data = [{ id }];\n     * await resourceStore.project.commitAsync();\n     * // resourceStore.first.events is available\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await resourceStore.loadDataAsync([{ id }]);\n     * // resourceStore.first.events is available\n     * ```\n     *\n     * @member {ResourceModelConfig[]} data\n     * @category Records\n     */\n    /**\n     * Applies a new dataset to the ResourceStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await resourceStore.loadDataAsync([{ id }]);\n     * // resourceStore.first.events is available\n     * ```\n     *\n     * @param {ResourceModelConfig[]} data Array of ResourceModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 200,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 100,\n            storeId      : 'resources',\n            autoTree     : true\n        };\n    }\n    construct(config) {\n        super.construct(config);\n        if (!this.modelClass.isResourceModel) {\n            throw new Error('Model for ResourceStore must subclass ResourceModel');\n        }\n    }\n    removeAll() {\n        const result = super.removeAll(...arguments);\n        // Removing all resources removes all assignments\n        result && this.assignmentStore.removeAll();\n        return result;\n    }\n    // Apply id changes also to assignments (used to be handled automatically by relations earlier, but engine does not\n    // care about ids so needed now)\n    // problems:\n    // 1. orientation/HorizontalRendering listens to assignment store changes and is trying to refresh view\n    // When we update resource id on assignment, listener will be invoked and view will try to refresh. And it will\n    // fail, because row is not updated yet. Flag is raised on resource store to make HorizontalRendering to skip\n    // refreshing view in this particular case of resource id changing\n    onRecordIdChange({ record, oldValue, value }) {\n        super.onRecordIdChange({ record, oldValue, value });\n        if (record.isFieldModified('id')) {\n            this.isChangingId = true;\n            record.updateAssignmentResourceIds();\n            this.isChangingId = false;\n        }\n    }\n    // Cache used by VerticalRendering, reset from there\n    get allResourceRecords() {\n        return this._allResourceRecords || (this._allResourceRecords = this.getAllDataRecords());\n    }\n    /**\n     * Returns all resources that have no events assigned during the specified time range.\n     * @param {Date} startDate Time range start date\n     * @param {Date} endDate Time range end date\n     * @returns {Scheduler.model.ResourceModel[]} Resources without events\n     */\n    getAvailableResources({ startDate, endDate }) {\n        return this.query(resource => this.eventStore.isDateRangeAvailable(startDate, endDate, null, resource));\n    }\n};\n", "import VersionHelper from '../../../Core/helper/VersionHelper.js';\n/**\n * @module Scheduler/model/mixin/ResourceModelMixin\n */\n/**\n * Mixin that holds configuration shared between resources in Scheduler and Scheduler Pro.\n * @mixin\n */\nexport default Target => class ResourceModelMixin extends Target {\n    static get $name() {\n        return 'ResourceModelMixin';\n    }\n    // Flag checked by ResourceStore to make sure it uses a valid subclass\n    static get isResourceModel() {\n        return true;\n    }\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     *\n     * This does not matter much on the resource itself, but is of importance when manipulating its references:\n     *\n     * ```javascript\n     * assignment.set('resourceId', 2);\n     * // resource.assignments is not yet up to date\n     *\n     * await assignment.setAsync('resourceId', 2);\n     * // resource.assignments is up to date\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n    //region Fields\n    static get fields() {\n        return [\n            /**\n             * Unique identifier\n             * @field {String|Number} id\n             * @category Common\n             */\n            /**\n             * Get or set resource name\n             * @field {String} name\n             * @category Common\n             */\n            { name : 'name', type : 'string', persist : true },\n            /**\n             * Controls the primary color used for events assigned to this resource. Can be overridden per event using\n             * EventModels {@link Scheduler/model/mixin/EventModelMixin#field-eventColor eventColor config}. See Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for available\n             * colors.\n             * @field {String} eventColor\n             * @category Styling\n             */\n            'eventColor',\n            /**\n             * Controls the style used for events assigned to this resource. Can be overridden per event using\n             * EventModels {@link Scheduler/model/mixin/EventModelMixin#field-eventStyle eventStyle config}. See Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for available\n             * options.\n             * @field {String} eventStyle\n             * @category Styling\n             */\n            'eventStyle',\n            /**\n             * Fully qualified image URL, used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image\n             * for the resource.\n             * @field {String} imageUrl\n             * @category Styling\n             */\n            'imageUrl',\n            /**\n             * Image name relative to {@link Scheduler/view/mixin/SchedulerEventRendering#config-resourceImagePath},\n             * used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image\n             * for the resource.\n             * @field {String} image\n             * @category Styling\n             */\n            'image',\n            /**\n             * Margin from rows edge to topmost event bar for this resource, in px.\n             * @field {Number} resourceMargin\n             * @category Layout\n             */\n            { name : 'resourceMargin', type : 'number' },\n            /**\n             * Margin between stacked event bars for this resource, in px.\n             * @field {Number} barMargin\n             * @category Layout\n             */\n            { name : 'barMargin', type : 'number' },\n            /**\n             * Base height of this resource, in px. When unset, Schedulers configured rowHeight is used.\n             *\n             * This value is used in horizontal mode to determine row height. When stacking, it is used as input for\n             * calculating the actual row height:\n             *\n             * ```javascript\n             * row.height = (resource.rowHeight - resourceMargin * 2) * overlap count - barMargin * (overlap count - 1)\n             * ```\n             *\n             * When packing or overlapping, it is used as the actual row height.\n             *\n             * @field {Number} rowHeight\n             * @category Layout\n             */\n            /**\n             * Base width of this resource, in px. If not set, the `columnWidth` specified in\n             * the Scheduler's configured {@link Scheduler.view.Scheduler#config-resourceColumns} is used.\n             *\n             * This value is used in vertical mode to determine column width.\n             *\n             * @field {Number} columnWidth\n             * @category Layout\n             */\n            /**\n             * Specify this to use a resource specific event layout in horizontal mode, see\n             * {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} for options.\n             *\n             * When unset (the default) Schedulers setting is used.\n             *\n             * @field {'stack'|'pack'|'mixed'|'none'} eventLayout\n             * @category Layout\n             */\n            'eventLayout'\n        ];\n    }\n    //endregion\n    //region Id change\n    updateAssignmentResourceIds() {\n        this.assigned.forEach(assignment => {\n            assignment.resourceId = this.id;\n        });\n    }\n    syncId(value) {\n        super.syncId(value);\n        this.updateAssignmentResourceIds();\n    }\n    //endregion\n    //region Getters\n    // Documented in Scheduler.model.ResourceModel, SchedulerPro.model.ResourceModel, Gantt.model.ResourceModel\n    get events() {\n        return this.assignments.reduce((events, assignment) => {\n            if (assignment.event) {\n                events.push(assignment.event);\n            }\n            return events;\n        }, []);\n    }\n    /**\n     * Returns all assignments for the resource\n     *\n     * @property {Scheduler.model.AssignmentModel[]}\n     * @category Common\n     */\n    get assignments() {\n        return this.assigned ? [...this.assigned] : [];\n    }\n    set assignments(assignments) {\n        // Engine does not allow assigning to `assigned`, handle it here\n        assignments.forEach(assignment => {\n            assignment.resource = this;\n        });\n    }\n    /**\n     * Returns an array of events, associated with this resource\n     *\n     * @deprecated 5.3.6 Use the events property instead\n     *\n     * @returns {Scheduler.model.EventModel[]}\n     */\n    getEvents() {\n        VersionHelper.deprecate('scheduler', '6.0.0', 'getEvents() is deprecated, use the events property instead');\n        return this.events;\n    }\n    /**\n     * Returns `true` if the resource can be persisted.\n     * In a flat store, a resource is always considered persistable. In a tree store, a resource is considered\n     * persistable if its parent node is persistable.\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isPersistable() {\n        return super.isPersistable && (!this.parent || this.parent.isPersistable);\n    }\n    //endregion\n    /**\n     * Unassigns this Resource from all its Events\n     */\n    unassignAll() {\n        this.assignments && this.assignmentStore.remove(this.assignments);\n    }\n    /**\n     * Returns the initials (first letter of the first & last space-separated word in the name) or an empty string\n     * if this resource has no name. You can override this method in a ResourceModel subclass to provide your own implementation\n     *\n     * @property {String}\n     * @readonly\n     * @category Common\n     */\n    get initials() {\n        const\n            { name = '' } = this;\n        if (!name) {\n            return '';\n        }\n        const names         = name.split(' '),\n            firstInitial  = names[0][0],\n            lastInitial   = (names.length > 1 ? names[names.length - 1][0] : '');\n        return firstInitial + lastInitial;\n    }\n    isWorkingTime(date) {\n        const calendar = (this.effectiveCalendar || this.project?.calendar);\n        return !calendar || calendar.isWorkingTime?.(date);\n    }\n};\n", "import GridRowModel from '../../Grid/data/GridRowModel.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport ResourceModelMixin from './mixin/ResourceModelMixin.js';\nimport { CoreResourceMixin } from '../../Engine/quark/model/scheduler_core/CoreResourceMixin.js';\nconst EngineMixin = CoreResourceMixin;\n/**\n * @module Scheduler/model/ResourceModel\n */\n/**\n * This class represent a single Resource in scheduler, usually added to a {@link Scheduler.data.ResourceStore}.\n *\n * It is a subclass of  {@link Core.data.Model}. Please refer to the documentation for that class to become familiar\n * with the base interface of the resource.\n *\n * ## Fields and references\n *\n * A resource has a few predefined fields, see Fields below. If you want to add more fields with meta data describing\n * your resources then you should subclass this class:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *       // \"id\" and \"name\" fields are already provided by the superclass\n *       { name: 'company', type : 'string' }\n *     ];\n *   }\n * });\n * ```\n *\n * If you want to use other names in your data for the id and name fields you can configure them as seen below:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *        { name: 'name', dataSource: 'userName' }\n *     ];\n *   },\n * });\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `{@link #property-assignments}` - The linked assignment records\n * - `{@link #property-events}` - The linked (through assignments) event records\n *\n * ## Async resolving of references\n *\n * As described above, a resource has links to assignments and events. These references are populated async, using the\n * calculation engine of the project that the resource via its store is a part of. Because of this asyncness, references\n * cannot be used immediately after assignment modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // resource.assignments is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // resource.assignments is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // resource.assignments is up to date\n * ```\n *\n * @extends Grid/data/GridRowModel\n * @mixes Scheduler/model/mixin/ResourceModelMixin\n */\nexport default class ResourceModel extends ResourceModelMixin(PartOfProject(EngineMixin.derive(GridRowModel))) {\n    /**\n     * Get associated events\n     *\n     * @member {Scheduler.model.EventModel[]} events\n     * @readonly\n     * @category Common\n     */\n    static $name = 'ResourceModel';\n}\nResourceModel.exposeProperties();\nResourceModel._$name = 'ResourceModel';", "import ResourceStoreMixin from './mixin/ResourceStoreMixin.js';\nimport ResourceModel from '../model/ResourceModel.js';\nimport AjaxStore from '../../Core/data/AjaxStore.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { CoreResourceStoreMixin } from '../../Engine/quark/store/CoreResourceStoreMixin.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\nconst EngineMixin = PartOfProject(CoreResourceStoreMixin.derive(AjaxStore));\n/**\n * @module Scheduler/data/ResourceStore\n */\n/**\n * A store holding all the {@link Scheduler.model.ResourceModel resources} to be rendered into a\n * {@link Scheduler.view.Scheduler Scheduler}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.ResourceModel}.\n *\n * A ResourceStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and DependencyStore). The project also handles references (assignments, events) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * resourceStore.data = [{ id }, ...];\n *\n * // references (assignments, events) not resolved yet\n *\n * await resourceStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await resourceStore.loadDataAsync([{ id }, ...]);\n *\n * // references (assignments, events) are resolved\n * ```\n *\n * @mixes Scheduler/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/ResourceStoreMixin\n * @extends Core/data/AjaxStore\n */\nexport default class ResourceStore extends ResourceStoreMixin(EngineMixin) {\n    static get defaultConfig() {\n        return {\n            modelClass : ResourceModel\n        };\n    }\n}\nResourceStore._$name = 'ResourceStore';", "import DateHelper from '../../Core/helper/DateHelper.js';\nimport Model from '../../Core/data/Model.js';\nimport Duration from '../../Core/data/Duration.js';\n/**\n * @module Scheduler/model/DependencyBaseModel\n */\nconst canonicalDependencyTypes = [\n    'SS',\n    'SF',\n    'FS',\n    'FF'\n];\n/**\n * Base class used for both Scheduler and Gantt. Not intended to be used directly\n *\n * @extends Core/data/Model\n */\nexport default class DependencyBaseModel extends Model {\n    static get $name() {\n        return 'DependencyBaseModel';\n    }\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     **\n     * ```javascript\n     * dependency.set('from', 2);\n     * // dependency.fromEvent is not yet up to date\n     *\n     * await dependency.setAsync('from', 2);\n     * // dependency.fromEvent is up to date\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n    //region Fields\n    /**\n     * An enumerable object, containing names for the dependency types integer constants.\n     * - 0 StartToStart\n     * - 1 StartToEnd\n     * - 2 EndToStart\n     * - 3 EndToEnd\n     * @property {Object}\n     * @readonly\n     * @category Dependency\n     */\n    static get Type() {\n        return {\n            StartToStart : 0,\n            StartToEnd   : 1,\n            EndToStart   : 2,\n            EndToEnd     : 3\n        };\n    }\n    static get fields() {\n        return [\n            // 3 mandatory fields\n            /**\n             * From event, id of source event\n             * @field {String|Number} from\n             * @category Dependency\n             */\n            { name : 'from' },\n            /**\n             * To event, id of target event\n             * @field {String|Number} to\n             * @category Dependency\n             */\n            { name : 'to' },\n            /**\n             * Dependency type, see static property {@link #property-Type-static}\n             * @field {Number} type=2\n             * @category Dependency\n             */\n            { name : 'type', type : 'int', defaultValue : 2 },\n            /**\n             * CSS class to apply to lines drawn for the dependency\n             * @field {String} cls\n             * @category Styling\n             */\n            { name : 'cls', defaultValue : '' },\n            /**\n             * Bidirectional, drawn with arrows in both directions\n             * @field {Boolean} bidirectional\n             * @category Dependency\n             */\n            { name : 'bidirectional', type : 'boolean' },\n            /**\n             * Start side on source (top, left, bottom, right)\n             * @field {'top'|'left'|'bottom'|'right'} fromSide\n             * @category Dependency\n             */\n            { name : 'fromSide', type : 'string' },\n            /**\n             * End side on target (top, left, bottom, right)\n             * @field {'top'|'left'|'bottom'|'right'} toSide\n             * @category Dependency\n             */\n            { name : 'toSide', type : 'string' },\n            /**\n             * The magnitude of this dependency's lag (the number of units).\n             * @field {Number} lag\n             * @category Dependency\n             */\n            { name : 'lag', type : 'number', allowNull : true, defaultValue : 0 },\n            /**\n             * The units of this dependency's lag, defaults to \"d\" (days). Valid values are:\n             *\n             * - \"ms\" (milliseconds)\n             * - \"s\" (seconds)\n             * - \"m\" (minutes)\n             * - \"h\" (hours)\n             * - \"d\" (days)\n             * - \"w\" (weeks)\n             * - \"M\" (months)\n             * - \"y\" (years)\n             *\n             * This field is readonly after creation, to change `lagUnit` use {@link #function-setLag setLag()}.\n             * @field {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} lagUnit\n             * @category Dependency\n             * @readonly\n             */\n            {\n                name         : 'lagUnit',\n                type         : 'string',\n                defaultValue : 'd'\n            },\n            { name : 'highlighted', persist : false, internal : true }\n        ];\n    }\n    // fromEvent/toEvent defined in CoreDependencyMixin in engine\n    /**\n     * Gets/sets the source event of the dependency.\n     *\n     * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.\n     *\n     * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you\n     * need to remap, consider using {@link #field-from} instead.\n     *\n     * @field {Scheduler.model.EventModel} fromEvent\n     * @accepts {String|Number|Scheduler.model.EventModel}\n     * @category Dependency\n     */\n    /**\n     * Gets/sets the target event of the dependency.\n     *\n     * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.\n     *\n     * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you\n     * need to remap, consider using {@link #field-to} instead.\n     *\n     * @field {Scheduler.model.EventModel} toEvent\n     * @accepts {String|Number|Scheduler.model.EventModel}\n     * @category Dependency\n     */\n    //endregion\n    //region Init\n    construct(data) {\n        const\n            from = data[this.fieldMap.from.dataSource],\n            to   = data[this.fieldMap.to.dataSource];\n        // Engine expects fromEvent and toEvent, not from and to. We need to support both\n        if (from != null) {\n            data.fromEvent = from;\n        }\n        if (to != null) {\n            data.toEvent = to;\n        }\n        super.construct(...arguments);\n    }\n    //endregion\n    get eventStore() {\n        return this.eventStore || this.unjoinedStores[0]?.eventStore;\n    }\n    set from(value) {\n        const { fromEvent } = this;\n        // When assigning a new id to an event, it will update the eventId of the assignment. But the assignments\n        // event is still the same so we need to announce here\n        if (fromEvent?.isModel && fromEvent.id === value) {\n            this.set('from', value);\n        }\n        else {\n            this.fromEvent = value;\n        }\n    }\n    get from() {\n        return this.get('from');\n    }\n    set to(value) {\n        const { toEvent } = this;\n        // When assigning a new id to an event, it will update the eventId of the assignment. But the assignments\n        // event is still the same so we need to announce here\n        if (toEvent?.isModel && toEvent.id === value) {\n            this.set('to', value);\n        }\n        else {\n            this.toEvent = value;\n        }\n    }\n    get to() {\n        return this.get('to');\n    }\n    /**\n     * Alias to dependency type, but when set resets {@link #field-fromSide} & {@link #field-toSide} to null as well.\n     *\n     * @property {Number}\n     * @category Dependency\n     */\n    get hardType() {\n        return this.getHardType();\n    }\n    set hardType(type) {\n        this.setHardType(type);\n    }\n    /**\n     * Returns dependency hard type, see {@link #property-hardType}.\n     *\n     * @returns {Number}\n     * @category Dependency\n     */\n    getHardType() {\n        return this.get('type');\n    }\n    /**\n     * Sets dependency {@link #field-type} and resets {@link #field-fromSide} and {@link #field-toSide} to null.\n     *\n     * @param {Number} type\n     * @category Dependency\n     */\n    setHardType(type) {\n        let result;\n        if (type !== this.hardType) {\n            result = this.set({\n                type,\n                fromSide : null,\n                toSide   : null\n            });\n        }\n        return result;\n    }\n    get lag() {\n        return this.get('lag');\n    }\n    set lag(lag) {\n        this.setLag(lag);\n    }\n    /**\n     * Sets lag and lagUnit in one go. Only allowed way to change lagUnit, the lagUnit field is readonly after creation\n     * @param {Number|String|Object} lag The lag value. May be just a numeric magnitude, or a full string descriptor eg '1d'\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [lagUnit] Unit for numeric lag value, see\n     * {@link #field-lagUnit} for valid values\n     * @category Dependency\n     */\n    setLag(lag, lagUnit = this.lagUnit) {\n        // Either they're only setting the magnitude\n        // or, if it's a string, parse the full duration.\n        if (arguments.length === 1) {\n            if (typeof lag === 'number') {\n                this.lag = lag;\n            }\n            else {\n                lag = DateHelper.parseDuration(lag);\n                this.set({\n                    lag     : lag.magnitude,\n                    lagUnit : lag.unit\n                });\n            }\n            return;\n        }\n        // Must be a number\n        lag = parseFloat(lag);\n        this.set({\n            lag,\n            lagUnit\n        });\n    }\n    getLag() {\n        if (this.lag) {\n            return `${this.lag < 0 ? '-' : '+'}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;\n        }\n        return '';\n    }\n    /**\n     * Property which encapsulates the lag's magnitude and units. An object which contains two properties:\n     * @property {Core.data.Duration}\n     * @property {Number} fullLag.magnitude The magnitude of the duration\n     * @property {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} fullLag.unit The unit in which the duration is measured, eg\n     * `'d'` for days\n     * @category Dependency\n     */\n    get fullLag() {\n        return new Duration({\n            unit      : this.lagUnit,\n            magnitude : this.lag\n        });\n    }\n    set fullLag(lag) {\n        if (typeof lag === 'string') {\n            this.setLag(lag);\n        }\n        else {\n            this.setLag(lag.magnitude, lag.unit);\n        }\n    }\n    /**\n     * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isPersistable() {\n        const\n            me = this,\n            { stores, unjoinedStores } = me,\n            store = stores[0];\n        let result;\n        if (store) {\n            const\n                { fromEvent, toEvent } = me,\n                crudManager            = store.crudManager;\n            // if crud manager is used it can deal with phantom source/target since it persists all records in one batch\n            // if no crud manager used we have to wait till source/target are persisted\n            result = fromEvent && (crudManager || !fromEvent.hasGeneratedId) && toEvent && (crudManager || !toEvent.hasGeneratedId);\n        }\n        else {\n            result = Boolean(unjoinedStores[0]);\n        }\n        return result && super.isPersistable;\n    }\n    getDateRange() {\n        const { fromEvent, toEvent } = this;\n        if (fromEvent?.isScheduled && toEvent?.isScheduled) {\n            const Type = DependencyBaseModel.Type;\n            let sourceDate,\n                targetDate;\n            switch (this.type) {\n                case Type.StartToStart:\n                    sourceDate = fromEvent.startDateMS;\n                    targetDate = toEvent.startDateMS;\n                    break;\n                case Type.StartToEnd:\n                    sourceDate = fromEvent.startDateMS;\n                    targetDate = toEvent.endDateMS;\n                    break;\n                case Type.EndToEnd:\n                    sourceDate = fromEvent.endDateMS;\n                    targetDate = toEvent.endDateMS;\n                    break;\n                case Type.EndToStart:\n                    sourceDate = fromEvent.endDateMS;\n                    targetDate = toEvent.startDateMS;\n                    break;\n                default:\n                    throw new Error('Invalid dependency type: ' + this.type);\n            }\n            return {\n                start : Math.min(sourceDate, targetDate),\n                end   : Math.max(sourceDate, targetDate)\n            };\n        }\n        return null;\n    }\n    /**\n     * Applies given CSS class to dependency, the value doesn't persist\n     *\n     * @param {String} cls\n     * @category Dependency\n     */\n    highlight(cls) {\n        const classes = this.highlighted?.split(' ') ?? [];\n        if (!classes.includes(cls)) {\n            this.highlighted = classes.concat(cls).join(' ');\n        }\n    }\n    /**\n     * Removes given CSS class from dependency if applied, the value doesn't persist\n     *\n     * @param {String} cls\n     * @category Dependency\n     */\n    unhighlight(cls) {\n        const { highlighted } = this;\n        if (highlighted) {\n            const\n                classes = highlighted.split(' '),\n                index   = classes.indexOf(cls);\n            if (index >= 0) {\n                classes.splice(index, 1);\n                this.highlighted = classes.join(' ');\n            }\n        }\n    }\n    /**\n     * Checks if the given CSS class is applied to dependency.\n     *\n     * @param {String} cls\n     * @returns {Boolean}\n     * @category Dependency\n     */\n    isHighlightedWith(cls) {\n        return this.highlighted && this.highlighted.split(' ').includes(cls);\n    }\n    getConnectorString(raw) {\n        const rawValue = canonicalDependencyTypes[this.type];\n        if (raw) {\n            return rawValue;\n        }\n        // FS => empty string; it's the default\n        if (this.type === DependencyBaseModel.Type.EndToStart) {\n            return '';\n        }\n        return rawValue;\n    }\n    // getConnectorStringFromType(type, raw) {\n    //     const rawValue = canonicalDependencyTypes[type];\n    //\n    //     if (raw) {\n    //         return rawValue;\n    //     }\n    //\n    //     // FS => empty string; it's the default\n    //     if (type === DependencyBaseModel.Type.EndToStart) {\n    //         return '';\n    //     }\n    //\n    //     const locale = LocaleManager.locale;\n    //\n    //     // See if there is a local version of SS, SF or FF\n    //     if (locale) {\n    //         const localized = locale.Scheduler && locale.Scheduler[rawValue];\n    //         if (localized) {\n    //             return localized;\n    //         }\n    //     }\n    //\n    //     return rawValue;\n    // }\n    // getConnectorString(raw) {\n    //     return this.getConnectorStringFromType(this.type);\n    // }\n    // * getConnectorStringGenerator(raw) {\n    //     return this.getConnectorStringFromType(yield this.$.type);\n    // }\n    toString() {\n        return `${this.from}${this.getConnectorString()}${this.getLag()}`;\n    }\n    /**\n     * Returns `true` if the dependency is valid. It is considered valid if it has a valid type and both from and to\n     * events are set and pointing to different events.\n     *\n     * @property {Boolean}\n     * @typings ignore\n     * @category Editing\n     */\n    get isValid() {\n        const { fromEvent, toEvent, type } = this;\n        return typeof type === 'number' && fromEvent && toEvent && fromEvent !== toEvent;\n    }\n    get fromEventName() {\n        return this.fromEvent?.name || '';\n    }\n    get toEventName() {\n        return this.toEvent?.name || '';\n    }\n    //region STM hooks\n    shouldRecordFieldChange(fieldName, oldValue, newValue) {\n        if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {\n            return false;\n        }\n        if (fieldName === 'from' || fieldName === 'to' || fieldName === 'fromEvent' || fieldName === 'toEvent') {\n            const eventStore = this.project?.eventStore;\n            if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //endregion\n}\nDependencyBaseModel.exposeProperties();\nDependencyBaseModel._$name = 'DependencyBaseModel';", "import DependencyBaseModel from './DependencyBaseModel.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { CoreDependencyMixin } from '../../Engine/quark/model/scheduler_core/CoreDependencyMixin.js';\nconst EngineMixin = CoreDependencyMixin;\n/**\n * @module Scheduler/model/DependencyModel\n */\n/**\n * This model represents a dependency between two events, usually added to a {@link Scheduler.data.DependencyStore}.\n *\n * It is a subclass of the {@link Scheduler.model.DependencyBaseModel} class, which in its turn subclasses\n * {@link Core.data.Model}. Please refer to documentation of those classes to become familiar with the base interface of\n * this class.\n *\n * ## Fields and references\n *\n * A Dependency has a few predefined fields, see Fields below.  The name of any fields data source can be customized in\n * the subclass, see the example below. Please also refer to {@link Core.data.Model} for details.\n *\n * ```javascript\n * class MyDependency extends DependencyModel {\n *   static get fields() {\n *     return [\n *       { name: 'to', dataSource: 'targetId' },\n *       { name: 'from', dataSource: 'sourceId' }\n *     ]);\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `fromEvent` - The event on the start side of the dependency\n * - `toEvent` - The event on the end side of the dependency\n *\n * ## Async resolving of references\n *\n * As described above, a dependency has links to events. These references are populated async, using the calculation\n * engine of the project that the resource via its store is a part of. Because of this asyncness, references cannot be\n * used immediately after modifications:\n *\n * ```javascript\n * dependency.from = 2;\n * // dependency.fromEvent is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * dependency.from = 2;\n * await dependency.project.commitAsync();\n * // dependency.fromEvent is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await dependency.setAsync({ from : 2});\n * // dependency.fromEvent is up to date\n * ```\n *\n * @extends Scheduler/model/DependencyBaseModel\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class DependencyModel extends PartOfProject(EngineMixin.derive(DependencyBaseModel)) {\n    static get $name() {\n        return 'DependencyModel';\n    }\n    // Determines the type of dependency based on fromSide and toSide\n    getTypeFromSides(fromSide, toSide, rtl) {\n        const\n            types     = DependencyBaseModel.Type,\n            startSide = rtl ? 'right' : 'left',\n            endSide   = rtl ? 'left' : 'right';\n        if (fromSide === startSide) {\n            return (toSide === startSide) ? types.StartToStart : types.StartToEnd;\n        }\n        return (toSide === endSide) ? types.EndToEnd : types.EndToStart;\n    }\n}\nDependencyModel.exposeProperties();\nDependencyModel._$name = 'DependencyModel';", "import ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport Model from '../../../Core/data/Model.js';\n/**\n * @module Scheduler/data/mixin/DependencyStoreMixin\n */\n/**\n * This is a mixin, containing functionality related to managing dependencies.\n *\n * It is consumed by the regular {@link Scheduler.data.DependencyStore} class and Scheduler Pros counterpart.\n *\n * @mixin\n */\nexport default Target => class DependencyStoreMixin extends Target {\n    static get $name() {\n        return 'DependencyStoreMixin';\n    }\n    /**\n     * Add dependencies to the store.\n     *\n     * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus they\n     * cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * const [dependency] = dependencyStore.add({ from, to });\n     * // dependency.fromEvent is not yet available\n     * ```\n     *\n     * To guarantee references are set up, wait for calculations for finish:\n     *\n     * ```javascript\n     * const [dependency] = dependencyStore.add({ from, to });\n     * await dependencyStore.project.commitAsync();\n     * // dependency.fromEvent is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * const [dependency] = await dependencyStore.addAsync({ from, to });\n     * // dependency.fromEvent is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.DependencyModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n    /**\n     * Add dependencies to the store and triggers calculations directly after. Await this function to have up to date\n     * references on the added dependencies.\n     *\n     * ```javascript\n     * const [dependency] = await dependencyStore.addAsync({ from, to });\n     * // dependency.fromEvent is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.DependencyModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n    /**\n     * Applies a new dataset to the DependencyStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus\n     * they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * dependencyStore.data = [{ from, to }];\n     * // dependencyStore.first.fromEvent is not yet available\n     * ```\n     *\n     * To guarantee references are available, wait for calculations for finish:\n     *\n     * ```javascript\n     * dependencyStore.data = [{ from, to }];\n     * await dependencyStore.project.commitAsync();\n     * // dependencyStore.first.fromEvent is available\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await dependencyStore.loadDataAsync([{ from, to }]);\n     * // dependencyStore.first.fromEvent is available\n     * ```\n     *\n     * @member {DependencyModelConfig[]} data\n     * @category Records\n     */\n    /**\n     * Applies a new dataset to the DependencyStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await dependencyStore.loadDataAsync([{ from, to }]);\n     * // dependencyStore.first.fromEvent is available\n     * ```\n     *\n     * @param {DependencyModelConfig[]} data Array of DependencyModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 400,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 400,\n            storeId : 'dependencies'\n        };\n    }\n    reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {\n        depsGetterFn = depsGetterFn || (event => this.getEventDependencies(event));\n        event = ArrayHelper.asArray(event);\n        event.reduce((result, event) => {\n            if (event.children && !flat) {\n                event.traverse(evt => {\n                    result = depsGetterFn(evt).reduce(reduceFn, result);\n                });\n            }\n            else {\n                result = depsGetterFn(event).reduce(reduceFn, result);\n            }\n        }, result);\n        return result;\n    }\n    mapEventDependencies(event, fn, filterFn, flat, depsGetterFn) {\n        return this.reduceEventDependencies(event, (result, dependency) => {\n            filterFn(dependency) && result.push(dependency);\n            return result;\n        }, [], flat, depsGetterFn);\n    }\n    mapEventPredecessors(event, fn, filterFn, flat) {\n        return this.reduceEventPredecessors(event, (result, dependency) => {\n            filterFn(dependency) && result.push(dependency);\n            return result;\n        }, [], flat);\n    }\n    mapEventSuccessors(event, fn, filterFn, flat) {\n        return this.reduceEventSuccessors(event, (result, dependency) => {\n            filterFn(dependency) && result.push(dependency);\n            return result;\n        }, [], flat);\n    }\n    /**\n     * Returns all dependencies for a certain event (both incoming and outgoing)\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Scheduler.model.DependencyModel[]}\n     */\n    getEventDependencies(event) {\n        return [].concat(event.predecessors || [], event.successors || []);\n    }\n    removeEventDependencies(event) {\n        this.remove(this.getEventDependencies(event));\n    }\n    removeEventPredecessors(event) {\n        this.remove(event.predecessors);\n    }\n    removeEventSuccessors(event, flat) {\n        this.remove(event.successors);\n    }\n    getBySourceTargetId(key) {\n        return this.records.find(r =>\n            key == this.constructor.makeDependencySourceTargetCompositeKey(r.from, r.to)\n        );\n    }\n    /**\n     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st\n     * task to 2nd) or backward (from 2nd to 1st).\n     *\n     * @param {Scheduler.model.EventModel|String} sourceEvent 1st event\n     * @param {Scheduler.model.EventModel|String} targetEvent 2nd event\n     * @returns {Scheduler.model.DependencyModel}\n     */\n    getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {\n        sourceEvent = Model.asId(sourceEvent);\n        targetEvent = Model.asId(targetEvent);\n        return this.getBySourceTargetId(this.constructor.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));\n    }\n    /**\n     * Returns a dependency model instance linking given events if such dependency exists in the store.\n     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).\n     *\n     * @param {Scheduler.model.EventModel|String} sourceEvent\n     * @param {Scheduler.model.EventModel|String} targetEvent\n     * @returns {Scheduler.model.DependencyModel}\n     */\n    getEventsLinkingDependency(sourceEvent, targetEvent) {\n        return this.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) ||\n            this.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);\n    }\n    /**\n     * Validation method used to validate a dependency. Override and return `true` to indicate that an\n     * existing dependency between two tasks is valid. For a new dependency being created please see\n     * {@link #function-isValidDependencyToCreate}.\n     *\n     * @param {Scheduler.model.DependencyModel|Scheduler.model.TimeSpan|Number|String} dependencyOrFromId The dependency\n     * model, the from task/event or the id of the from task/event\n     * @param {Scheduler.model.TimeSpan|Number|String} [toId] To task/event or id thereof if the first parameter is not\n     * a dependency record\n     * @param {Number} [type] Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static} if the first\n     * parameter is not a dependency model instance.\n     * @returns {Boolean}\n     */\n    async isValidDependency(dependencyOrFromId, toId, type) {\n        let fromEvent = dependencyOrFromId, toEvent = toId;\n        if (dependencyOrFromId == null) {\n            return false;\n        }\n        // Accept dependency model\n        if (dependencyOrFromId.isDependencyModel) {\n            ({ fromEvent, toEvent } = dependencyOrFromId);\n        }\n        // Accept from as id\n        fromEvent = this.eventStore.getById(fromEvent);\n        // Accept to as id\n        toEvent = this.eventStore.getById(toEvent);\n        // This condition is supposed to map all model instances to be validated by project. Lowest common ancestor\n        // for scheduler event, scheduler pro event and gantt task is TimeSpan\n        if (fromEvent && toEvent) {\n            // Block creating dependencies to display only tasks in Gantt\n            if (!fromEvent.project || !toEvent.project) {\n                return false;\n            }\n            // Not asserting dependency type here. Default value should normally suffice.\n            return this.project.isValidDependency(fromEvent, toEvent, type);\n        }\n        return dependencyOrFromId !== toId;\n    }\n    /**\n     * Validation method used to validate a dependency while creating. Override and return `true` to indicate that\n     * a new dependency is valid to be created.\n     *\n     * @param {Scheduler.model.TimeSpan|Number|String} fromId From event/task or id\n     * @param {Scheduler.model.TimeSpan|Number|String} toId To event/task or id\n     * @param {Number} type Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n     * @returns {Boolean}\n     */\n    isValidDependencyToCreate(fromId, toId, type) {\n        return this.isValidDependency(fromId, toId, type);\n    }\n    /**\n     * Returns all dependencies highlighted with the given CSS class\n     *\n     * @param {String} cls\n     * @returns {Scheduler.model.DependencyBaseModel[]}\n     */\n    getHighlightedDependencies(cls) {\n        return this.records.reduce((result, dep) => {\n            if (dep.isHighlightedWith(cls)) result.push(dep);\n            return result;\n        }, []);\n    }\n    static makeDependencySourceTargetCompositeKey(from, to) {\n        return `source(${from})-target(${to})`;\n    }\n    //region Product neutral\n    getTimeSpanDependencies(record) {\n        return this.getEventDependencies(record);\n    }\n    //endregion\n};\n", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport DependencyStoreMixin from './mixin/DependencyStoreMixin.js';\nimport { CoreDependencyStoreMixin } from '../../Engine/quark/store/CoreDependencyStoreMixin.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\nconst EngineMixin = PartOfProject(CoreDependencyStoreMixin.derive(AjaxStore));\n/**\n * @module Scheduler/data/DependencyStore\n */\n/**\n * A store representing a collection of dependencies between events in the {@link Scheduler.data.EventStore}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.DependencyModel}.\n *\n * A DependencyStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and ResourceStore). The project also handles references (fromEvent, toEvent) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * dependencyStore.data = [{ from, to }, ...];\n *\n * // references (fromEvent, toEvent) not resolved yet\n *\n * await dependencyStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await dependencyStore.loadDataAsync([{ from, to }, ...]);\n *\n * // references (fromEvent, toEvent) are resolved\n * ```\n *\n * @mixes Scheduler/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/DependencyStoreMixin\n * @extends Core/data/AjaxStore\n */\nexport default class DependencyStore extends DependencyStoreMixin(EngineMixin.derive(AjaxStore)) {\n    static get defaultConfig() {\n        return {\n            modelClass : DependencyModel\n        };\n    }\n}\nDependencyStore._$name = 'DependencyStore';", "import AbstractCrudManagerMixin from '../../../Scheduler/crud/AbstractCrudManagerMixin.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport Base from '../../../Core/Base.js';\nimport AjaxTransport from '../../crud/transport/AjaxTransport.js';\nimport JsonEncoder from '../../crud/encoder/JsonEncoder.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/data/mixin/ProjectCrudManager\n */\n/**\n * This mixin provides Crud Manager functionality supporting loading of scheduling engine projects.\n *\n * @mixin\n * @mixes Scheduler/crud/AbstractCrudManagerMixin\n * @mixes Scheduler/crud/transport/AjaxTransport\n * @mixes Scheduler/crud/encoder/JsonEncoder\n */\nexport default Target => class ProjectCrudManager extends (Target || Base).mixin(AbstractCrudManagerMixin, AjaxTransport, JsonEncoder) {\n    //region Config\n    static get defaultConfig() {\n        return {\n            project : null\n        };\n    }\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n        super.startConfigure(config);\n        this._changesToClear = new Map();\n    }\n    async doAutoLoad() {\n        const { project } = this;\n        // Delay autoLoad to after projects initial commit if configured with a project\n        if (project) {\n            await project.commitAsync();\n        }\n        return super.doAutoLoad();\n    }\n    applyProjectResponse(response) {\n        const\n            me = this,\n            { project } = me;\n        me.applyingProjectResponse = true;\n        const\n            startDateField = project.fieldMap.startDate,\n            endDateField   = project.fieldMap.endDate,\n            startDate      = ObjectHelper.getPath(response, startDateField.dataSource),\n            endDate        = ObjectHelper.getPath(response, endDateField.dataSource);\n        // With early rendering engine won't convert project dates in time, do it manually first\n        if (typeof startDate === 'string') {\n            ObjectHelper.setPath(response, startDateField.dataSource, startDateField.convert(startDate));\n        }\n        if (typeof endDate === 'string') {\n            ObjectHelper.setPath(response, endDateField.dataSource, endDateField.convert(endDate));\n        }\n        Object.assign(project, response);\n        me._changesToClear.set(me, response);\n        me.applyingProjectResponse = false;\n    }\n    loadCrudManagerData(response, options = {}) {\n        const\n            me = this,\n            { project } = me;\n        // We don't want to react on store changes while loading them\n        me.suspendChangesTracking();\n        super.loadCrudManagerData(...arguments);\n        // If there is project data provided\n        if (response?.project) {\n            // If the project is delaying its linking to a new graph instance\n            // wait till it detaches all records from the old graph\n            // and then apply the project data.\n            // Otherwise the project changes we apply here will be overridden when detaching from the old graph.\n            // Since the code copies last identifier values from the graph when detaching.\n            if (project.delayEnteringReplica) {\n                project.ion({\n                    recordsUnlinked : () => {\n                        me.suspendChangesTracking();\n                        me.applyProjectResponse(response.project);\n                        me.resumeChangesTracking();\n                    },\n                    once : true\n                });\n            }\n            else {\n                me.applyProjectResponse(response.project);\n            }\n        }\n        me.resumeChangesTracking();\n    }\n    async sync() {\n        const { project } = this;\n        // Suspend Crud Manager autoSync to not react on changes during commitAsync() call\n        this.suspendAutoSync();\n        // Make sure data is in a calculated state before syncing\n        if (project) {\n            await project.commitAsync();\n        }\n        if (this.isDestroying) {\n            return;\n        }\n        // resume autoSync silently\n        this.resumeAutoSync(false);\n        return super.sync();\n    }\n    async applyResponse(request, response, options) {\n        const me = this;\n        if (me.isDestroyed || me.project?.isDestroyed) {\n            return;\n        }\n        me.trigger('beforeApplyResponse');\n        await super.applyResponse(request, response, options);\n        // If there is the project data provided or it's not provided but short responses are enabled\n        // in such cases we treat a successful response covering all sent changes as much as that's possible\n        // so responding `project : { ... }` should not be really needed\n        if (response?.project || (me.supportShortSyncResponse && request?.pack?.project)) {\n            // apply the responded changes (or accept the requested ones)\n            me.applyProjectResponse(response.project || request?.pack?.project);\n        }\n        // if we have a project\n        if (me.project) {\n            let requestType = request.type;\n            // response can force its type\n            if (me.trackResponseType) {\n                requestType = response.type || requestType;\n            }\n            // Make a boolean flag indicating what has triggered the propagation (\"propagatingLoadChanges\" or  \"propagatingSyncChanges\")\n            const propagationFlag = `propagating${StringHelper.capitalize(requestType)}Changes`;\n            me.suspendAutoSync();\n            me[propagationFlag] = true;\n            const loud = me.project.isInitialCommit && !me.project.silenceInitialCommit;\n            // Wait till calculation gets done\n            await me.project.commitAsync();\n            me[propagationFlag] = false;\n            // for initial commit we still trigger the sync, but not for following\n            me.resumeAutoSync?.(loud);\n            // Accept changes came from the server (might have been destroyed while waiting above)\n            me.commitRespondedChanges?.();\n        }\n        // Trigger if we did not get destroyed while waiting above\n        me.trigger?.('applyResponse');\n    }\n    applySyncResponse(...args) {\n        const\n            me          = this,\n            stmDisabled = me.project?.stm.disabled;\n        if (stmDisabled === false && me.ignoreRemoteChangesInSTM) {\n            me.project.stm.disable();\n        }\n        super.applySyncResponse(...args);\n        if (stmDisabled === false) {\n            me.project.stm.enable();\n        }\n    }\n    shouldClearRecordFieldChange(record, field, value) {\n        const oldValue = record[field];\n        field = record.getFieldDefinition(field);\n        // If the field value matches the one responded from the server\n        // we silently accept it\n        return field?.isEqual ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);\n    }\n    commitRespondedChanges() {\n        // We silently accept changes came from the server\n        this._changesToClear.forEach((changes, record) => {\n            Object.entries(changes).forEach(([key, value]) => {\n                // If the field value matches the one responded from the server\n                // we silently accept it\n                if (this.shouldClearRecordFieldChange(record, key, value)) {\n                    delete record.meta.modified[key];\n                }\n            });\n        });\n        this._changesToClear.clear();\n    }\n    applyChangesToStore(storeDesc, storeResponse, storePack, ...rest) {\n        const changesMap = super.applyChangesToStore(storeDesc, storeResponse, storePack, ...rest);\n        // The changes enter graph first but not store until later, clearing changes in StoreChanges might still leave\n        // records modified. We need to clean up after the next propagation, so we store record changes in a map for now\n        if (changesMap.size && this.project) {\n            for (const [id, changes] of changesMap) {\n                const record = storeDesc.store.getById(id);\n                record && this._changesToClear.set(record, changes);\n            }\n        }\n        return changesMap;\n    }\n};\n", "import Model from '../../../Core/data/Model.js';\n/**\n * @module Scheduler/model/mixin/ProjectModelCommon\n */\n/**\n * Mixin that provides helpful methods and properties for a `ProjectModel`. This mixin applies to all Bryntum products.\n * @mixin\n * @internal\n */\nexport default Target => class ProjectModelCommon extends (Target || Model) {\n    static $name = 'ProjectModelCommon';\n    static get configurable() {\n        return {\n            // Documented in Gantt/Scheduler/SchedulerPro version of ./model/ProjectModel since types differ\n            assignments  : null,\n            dependencies : null,\n            resources    : null,\n            timeRanges   : null\n        };\n    }\n    //region Inline data\n    get assignments() {\n        return this.assignmentStore.allRecords;\n    }\n    updateAssignments(assignments) {\n        this.assignmentStore.data = assignments;\n    }\n    get dependencies() {\n        return this.dependencyStore.allRecords;\n    }\n    updateDependencies(dependencies) {\n        this.dependencyStore.data = dependencies;\n    }\n    get resources() {\n        return this.resourceStore.allRecords;\n    }\n    updateResources(resources) {\n        this.resourceStore.data = resources;\n    }\n    get timeRanges() {\n        return this.timeRangeStore.allRecords;\n    }\n    getTimeRanges(startDate, endDate) {\n        const\n            store = this.timeRangeStore,\n            ret = [];\n        for (const timeSpan of store) {\n            // Collect occurrences for the recurring events in the record set\n            if (timeSpan.isRecurring) {\n                ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));\n            }\n            else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {\n                ret.push(timeSpan);\n            }\n        }\n        return ret;\n    }\n    updateTimeRanges(timeRanges) {\n        this.timeRangeStore.data = timeRanges;\n    }\n    getResourceTimeRanges(startDate, endDate) {\n        const\n            store = this.resourceTimeRangeStore,\n            ret = [];\n        for (const timeSpan of store) {\n            // Collect occurrences for the recurring events in the record set\n            if (timeSpan.isRecurring) {\n                ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));\n            }\n            else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {\n                ret.push(timeSpan);\n            }\n        }\n        return ret;\n    }\n    //endregion\n};\n", "import Model from '../../../Core/data/Model.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\nimport FunctionHelper from '../../../Core/helper/FunctionHelper.js';\n/**\n * @module Scheduler/model/mixin/ProjectModelTimeZoneMixin\n */\n/**\n * Mixin that holds TimeZone functionality shared between projects in Scheduler, Scheduler Pro, Gantt and Calendar\n * @mixin\n */\nexport default Target => class ProjectModelTimeZoneMixin extends (Target || Model) {\n    static $name = 'ProjectModelTimeZoneMixin';\n    static configurable = {\n        /**\n         * Set to a IANA time zone (i.e. `Europe/Stockholm`) or a UTC offset in minutes (i.e. `-120`). This will\n         * convert all events, tasks and time ranges to the specified time zone or offset. It will also affect the\n         * displayed timeline's headers as well at the start and end date of it.\n         *\n         * There is currently no built-in time zone support in JavaScript which means that the converted dates\n         * technically still are in the local system time zone, but adjusted to match the configured time zone.\n         *\n         * ### DST\n         * If a IANA time zone is provided, there will be support for DST. But if local system time zone has DST that\n         * will affect the time zone conversion at the exact hour when the local system time zone switches DST on and\n         * off.\n         *\n         * *For example:*\n         * 1. The local system time zone is `Europe/Stockholm` (which is UTC+1 or UTC+2 when DST).\n         * 2. The date `2022-03-27T07:00:00Z` (which is UTC) is converted to `America/Chicago` (which is UTC-6 or UTC-5\n         *    when DST).\n         * 3. The converted JS date will be created from `2022-03-27T02:00:00` which is exactly the hour when\n         *    `Europe/Stockholm` adds an DST hour. This has the effect that the converted date shows up incorrectly as\n         *    `2022-03-27T03:00` instead.\n         *\n         * If a UTC offset is provided, there is no DST support at all.\n         *\n         * ### Editing\n         * If creating new records or editing existing record dates, the dates will be interpreted as in the selected\n         * time zone.\n         *\n         * ### Saving\n         * When saving or syncing data, the dates will be restored to local system time and converted to JSON\n         * ISO formatted.\n         *\n         * @prp {String|Number} [timeZone]\n         * @category Advanced\n         */\n        timeZone : {\n            // Don't ingest the config eagerly because it relies on project being present.\n            // Lazy means it waits for ingestion until timeZone property is referenced.\n            $config : 'lazy',\n            value   : null\n        }\n    };\n    get _storesWithDates() {\n        return [this.taskStore, this.timeRangeStore, this.resourceTimeRangeStore].filter(s => s);\n    }\n    // Overrides a Store's processRecord function to be able to convert records added by a dataset\n    // before they are processed by the engine\n    overrideStoreProcessRecord(store) {\n        if (this._storesWithDates.includes(store) && !store.$originalProcessRecord) {\n            store.$originalProcessRecord =\n                FunctionHelper.before(store, 'processRecord', (record, isDataSet) => {\n                    if (isDataSet || store.isLoadingData) {\n                        // When loading or changing dataset, de data is treated as local dates and need to be converted\n                        this.convertRecordToTimeZone(record);\n                    }\n                });\n        }\n    }\n    attachStore(store) {\n        super.attachStore(store);\n        // If a new store is attached, convert it to the configured timezone\n        if (store && this.timeZone != null && this._storesWithDates.includes(store)) {\n            this.convertStoresToTimeZone([store]);\n            this.overrideStoreProcessRecord();\n        }\n    }\n    detachStore(store) {\n        super.detachStore(store);\n        // When a store is detached, the records isn't timezone converted anymore\n        if (store && !store.isDestroyed) {\n            const { $originalProcessRecord } = store;\n            if ($originalProcessRecord) {\n                $originalProcessRecord(); // Restores the original function\n                store.$originalProcessRecord = null;\n                // Convert records back to local system timezone\n                this.convertStoresToTimeZone([store], null);\n            }\n        }\n    }\n    relayStoreChange({ source, action, records, replaced }) {\n        const me = this;\n        if (me.timeZone != null && me._storesWithDates.includes(source)) {\n            // When a record is added or replaced, it is treated as in current configured timezone\n            if (['add', 'replace'].includes(action)) {\n                if (!records?.length && replaced?.length) {\n                    records = replaced;\n                }\n                if (records.length) {\n                    records.forEach(record => record.timeZone = me.timeZone);\n                }\n            }\n        }\n    }\n    convertStoresToTimeZone(stores, timeZone = this.timeZone) {\n        const\n            me            = this,\n            stmAutoRecord = me.stm?.autoRecord;\n        // Disable STM while updating timezone values\n        if (stmAutoRecord) {\n            me.stm.autoRecord = false;\n        }\n        for (const store of stores) {\n            store?.forEach(r => me.convertRecordToTimeZone(r, timeZone));\n        }\n        if (stmAutoRecord) {\n            // Restore original value\n            me.stmAutoRecord = stmAutoRecord;\n        }\n    }\n    convertRecordToTimeZone(record, timeZone = this.timeZone) {\n        if (record.timeZone !== timeZone) {\n            record.$ignoreChange = true; // Used to ignore changes in NestedEvents feature\n            // Convert baselines if exists\n            if (record.baselines?.count) {\n                for (const bl of record.baselines) {\n                    // The baseline records is not marked with a timezone when they are created\n                    if (record.timeZone !== bl.timeZone) {\n                        bl.timeZone = record.timeZone;\n                    }\n                    bl.convertToTimeZone(timeZone);\n                }\n            }\n            record.convertToTimeZone(timeZone);\n            record.$ignoreChange = false;\n        }\n    }\n    updateTimeZone(timeZone, oldTimeZone) {\n        const\n            me            = this,\n            isConfiguring = me._isConfiguringTimeZone || me.isConfiguring;\n        me.trigger('beforeTimeZoneChange', {\n            timeZone,\n            oldTimeZone,\n            isConfiguring\n        });\n        me.calendarManagerStore.forEach(calendar => calendar.bumpVersion());\n        // Convert data to time zone\n        me.convertStoresToTimeZone(me._storesWithDates);\n        me._storesWithDates.forEach(store => me.overrideStoreProcessRecord(store));\n        // Convert project startdate\n        if (me.startDate) {\n            const startDate = oldTimeZone != null ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;\n            me.startDate = timeZone != null ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;\n        }\n        me.ignoreRecordChanges = true;\n        me.commitAsync().then(() => {\n            if (!me.isDestroyed) {\n                me.trigger('timeZoneChange', {\n                    timeZone,\n                    oldTimeZone,\n                    isConfiguring\n                });\n            }\n            delete me._isConfiguringTimeZone;\n        });\n    }\n};\n", "import Model from '../../../Core/data/Model.js';\nimport ProjectModelCommon from './ProjectModelCommon.js';\nimport ResourceTimeRangeModel from '../ResourceTimeRangeModel.js';\nimport TimeSpan from '../TimeSpan.js';\nimport Store from '../../../Core/data/Store.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ResourceTimeRangeStore from '../../data/ResourceTimeRangeStore.js';\nimport ProjectModelTimeZoneMixin from './ProjectModelTimeZoneMixin.js';\n/**\n * @module Scheduler/model/mixin/ProjectModelMixin\n */\n/**\n * Mixin that holds configuration shared between projects in Scheduler and Scheduler Pro.\n * @mixes Scheduler/model/mixin/ProjectModelTimeZoneMixin\n * @mixin\n */\nexport default Target => class ProjectModelMixin extends (Target || Model).mixin(\n    ProjectModelCommon,\n    ProjectModelTimeZoneMixin\n) {\n    static get $name() {\n        return 'ProjectModelMixin';\n    }\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * State tracking manager instance the project relies on\n             * @member {Core.data.stm.StateTrackingManager} stm\n             * @category Advanced\n             */\n            /**\n             * Configuration options to provide to the STM manager\n             *\n             * @config {StateTrackingManagerConfig|Core.data.stm.StateTrackingManager}\n             * @category Advanced\n             */\n            stm : {},\n            timeRangeModelClass         : TimeSpan,\n            resourceTimeRangeModelClass : ResourceTimeRangeModel,\n            /**\n             * The constructor to create a time range store instance with. Should be a class subclassing the\n             * {@link Core.data.Store}\n             * @config {Core.data.Store|Object}\n             * @typings {typeof Store|object}\n             * @category Models & Stores\n             */\n            timeRangeStoreClass : Store,\n            /**\n             * The constructor to create a resource time range store instance with. Should be a class subclassing the\n             * {@link Scheduler.data.ResourceTimeRangeStore}\n             * @config {Scheduler.data.ResourceTimeRangeStore|Object}\n             * @typings {typeof ResourceTimeRangeStore|object}\n             * @category Models & Stores\n             */\n            resourceTimeRangeStoreClass : ResourceTimeRangeStore,\n            /**\n             * The initial data, to fill the {@link #property-timeRangeStore timeRangeStore} with.\n             * Should be an array of {@link Scheduler.model.TimeSpan TimeSpan} or its configuration objects.\n             *\n             * @config {Scheduler.model.TimeSpan[]} [timeRangesData]\n             * @category Legacy inline data\n             */\n            /**\n             * The initial data, to fill the {@link #property-resourceTimeRangeStore resourceTimeRangeStore} with.\n             * Should be an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModel} or it's\n             * configuration objects.\n             *\n             * @config {Scheduler.model.ResourceTimeRangeModel[]} [resourceTimeRangesData]\n             * @category Legacy inline data\n             */\n            eventStore      : {},\n            assignmentStore : {},\n            dependencyStore : {},\n            resourceStore   : {},\n            timeRangesData  : null\n        };\n    }\n    static configurable = {\n        /**\n         * Project data as a JSON string, used to populate its stores.\n         *\n         * ```javascript\n         * const project = new ProjectModel({\n         *     json : '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n         * }\n         * ```\n         *\n         * @config {String}\n         * @category Inline data\n         */\n        json : null,\n        /**\n         * The {@link Core.data.Store store} holding the time ranges information.\n         *\n         * See also {@link Scheduler.model.TimeSpan}\n         *\n         * @member {Core.data.Store} timeRangeStore\n         * @category Models & Stores\n         */\n        /**\n         * A {@link Core.data.Store} instance or a config object.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Models & Stores\n         */\n        timeRangeStore : {\n            value : {\n                id         : 'timeRanges', \n                modelClass : TimeSpan\n            },\n            $config : 'nullify'\n        },\n        /**\n         * The {@link Scheduler.data.ResourceTimeRangeStore store} holding the resource time ranges information.\n         *\n         * See also {@link Scheduler.model.ResourceTimeRangeModel}\n         *\n         * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore\n         * @category Models & Stores\n         */\n        /**\n         * A {@link Scheduler.data.ResourceTimeRangeStore} instance or a config object.\n         * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}\n         * @category Models & Stores\n         */\n        resourceTimeRangeStore : {\n            value   : {},\n            $config : 'nullify'\n        },\n        // Documented in Scheduler/SchedulerPro versions of model/ProjectModel since types differ\n        events             : null,\n        resourceTimeRanges : null\n    };\n    //endregion\n    //region Properties\n    /**\n     * Get or set data of project stores. The returned data is identical to what\n     * {@link #function-toJSON} returns:\n     *\n     * ```javascript\n     *\n     * const data = scheduler.project.inlineData;\n     *\n     * // data:\n     * {\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     dependenciesData       : [...],\n     *     assignmentsData        : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * }\n     *\n     *\n     * // Plug it back in later\n     * scheduler.project.inlineData = data;\n     * ```\n     *\n     * @property {Object}\n     * @category Inline data\n     */\n    get inlineData() {\n        return StringHelper.safeJsonParse(super.json);\n    }\n    set inlineData(inlineData) {\n        this.json = inlineData;\n    }\n    //endregion\n    //region Functions\n    /**\n     * Accepts a \"data package\" consisting of data for the projects stores, which is then loaded into the stores.\n     *\n     * The package can hold data for `EventStore`, `AssignmentStore`, `ResourceStore`, `DependencyStore`,\n     * `TimeRangeStore` and `ResourceTimeRangeStore`. It uses the same format as when creating a project with inline\n     * data:\n     *\n     * ```javascript\n     * await project.loadInlineData({\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     assignmentsData        : [...],\n     *     dependenciesData       : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * });\n     * ```\n     *\n     * After populating the stores it commits the project, starting its calculations. By awaiting `loadInlineData()` you\n     * can be sure that project calculations are finished.\n     *\n     * @function loadInlineData\n     * @param {Object} dataPackage A data package as described above\n     * @fires load\n     * @async\n     * @category Inline data\n     */\n    /**\n     * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the\n     * underlying graph based calculation engine. The engine performs it calculations async.\n     *\n     * By calling this function, the commit happens right away. And by awaiting it you are sure that project\n     * calculations are finished and that references between records are up to date.\n     *\n     * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.\n     *\n     * ```javascript\n     * // Move an event in time\n     * eventStore.first.shift(1);\n     *\n     * // Trigger calculations directly and wait for them to finish\n     * const result = await project.commitAsync();\n     *\n     * if (result.rejectedWith) {\n     *     // there was a conflict during the scheduling\n     * }\n     * ```\n     *\n     * @async\n     * @function commitAsync\n     * @category Common\n     */\n    //endregion\n    //region Init\n    construct(config = {}) {\n        super.construct(...arguments);\n        // These stores are not handled by engine, but still held on project\n        if (config.timeRangesData) {\n            this.timeRangeStore.data = config.timeRangesData;\n        }\n        if (config.resourceTimeRangesData) {\n            this.resourceTimeRangeStore.data = config.resourceTimeRangesData;\n        }\n    }\n    afterConstruct() {\n        super.afterConstruct();\n        const me = this;\n        !me.timeRangeStore.stm && me.stm.addStore(me.timeRangeStore);\n        !me.resourceTimeRangeStore.stm && me.stm.addStore(me.resourceTimeRangeStore);\n    }\n    //endregion\n    //region Attaching stores\n    // Attach to a store, relaying its change events\n    attachStore(store) {\n        if (store) {\n            store.ion({\n                name    : store.$$name,\n                change  : 'relayStoreChange',\n                thisObj : this\n            });\n        }\n        super.attachStore(store);\n    }\n    // Detach a store, stop relaying its change events\n    detachStore(store) {\n        if (store) {\n            this.detachListeners(store.$$name);\n            super.detachStore(store);\n        }\n    }\n    relayStoreChange(event) {\n        super.relayStoreChange(event);\n        /**\n         * Fired when data in any of the projects stores changes.\n         *\n         * Basically a relayed version of each stores own change event, decorated with which store it originates from.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event change\n         * @param {Scheduler.model.ProjectModel} source This project\n         * @param {Core.data.Store} store Affected store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        return this.trigger('change', { store : event.source, ...event, source : this });\n    }\n    updateTimeRangeStore(store, oldStore) {\n        this.detachStore(oldStore);\n        this.attachStore(store);\n    }\n    setTimeRangeStore(store) {\n        this.timeRangeStore = store;\n    }\n    changeTimeRangeStore(store) {\n        // If it's not being nullified, upgrade a config object to be a full store\n        if (store && !store.isStore) {\n            store = this.timeRangeStoreClass.new({\n                modelClass : this.timeRangeModelClass\n            }, store);\n        }\n        return store;\n    }\n    updateResourceTimeRangeStore(store, oldStore) {\n        this.detachStore(oldStore);\n        this.attachStore(store);\n    }\n    changeResourceTimeRangeStore(store) {\n        // If it's not being nullified, upgrade a config object to be a full store\n        if (store && !store.isStore) {\n            store = this.resourceTimeRangeStoreClass.new({\n                modelClass : this.resourceTimeRangeModelClass\n            }, store);\n        }\n        return store;\n    }\n    setResourceTimeRangeStore(store) {\n        this.resourceTimeRangeStore = store;\n    }\n    //endregion\n    //region Inline data\n    get events() {\n        return this.eventStore.allRecords;\n    }\n    updateEvents(events) {\n        this.eventStore.data = events;\n    }\n    get resourceTimeRanges() {\n        return this.resourceTimeRangeStore.allRecords;\n    }\n    updateResourceTimeRanges(resourceTimeRanges) {\n        this.resourceTimeRangeStore.data = resourceTimeRanges;\n    }\n    async loadInlineData(data) {\n        // Flag reset in super\n        this.isLoadingInlineData = true;\n        // Stores not handled by engine\n        if (data.resourceTimeRangesData) {\n            this.resourceTimeRangeStore.data = data.resourceTimeRangesData;\n        }\n        if (data.timeRangesData) {\n            this.timeRangeStore.data = data.timeRangesData;\n        }\n        return super.loadInlineData(data);\n    }\n    //endregion\n    //region JSON\n    /**\n     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.\n     *\n     * Used by JSON.stringify to correctly convert this record to json.\n     *\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     assignmentsData        : [...],\n     *     dependenciesData       : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * });\n     *\n     * const json = project.toJSON();\n     *\n     * // json:\n     * {\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     dependenciesData       : [...],\n     *     assignmentsData        : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * }\n     * ```\n     *\n     * Output can be consumed by `loadInlineData()`:\n     *\n     * ```javascript\n     * const json = project.toJSON();\n     *\n     * // Plug it back in later\n     * project.loadInlineData(json);\n     * ```\n     *\n     * @returns {Object}\n     * @category Inline data\n     */\n    toJSON() {\n        const\n            me = this,\n            result = {\n                eventsData             : me.eventStore.toJSON(),\n                resourcesData          : me.resourceStore.toJSON(),\n                dependenciesData       : me.dependencyStore.toJSON(),\n                timeRangesData         : me.timeRangeStore.toJSON(),\n                resourceTimeRangesData : me.resourceTimeRangeStore.toJSON()\n            };\n        if (!me.eventStore.usesSingleAssignment) {\n            result.assignmentsData = me.assignmentStore.toJSON();\n        }\n        return result;\n    }\n    /**\n     * Get or set project data (records from its stores) as a JSON string.\n     *\n     * Get a JSON string:\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     assignmentsData        : [...],\n     *     dependenciesData       : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * });\n     *\n     * const jsonString = project.json;\n     *\n     * // jsonString:\n     * '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n     * ```\n     *\n     * Set a JSON string (to populate the project stores):\n     *\n     * ```javascript\n     * project.json = '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n     * ```\n     *\n     * @property {String}\n     * @category Inline data\n     */\n    get json() {\n        return super.json;\n    }\n    changeJson(json) {\n        if (typeof json === 'string') {\n            json = StringHelper.safeJsonParse(json);\n        }\n        return json;\n    }\n    updateJson(json) {\n        json && this.loadInlineData(json);\n    }\n    //endregion\n    afterChange(toSet, wasSet) {\n        super.afterChange(...arguments);\n        if (wasSet.calendar) {\n            this.trigger('calendarChange');\n        }\n    }\n    doDestroy() {\n        this.timeRangeStore.destroy();\n        this.resourceTimeRangeStore.destroy();\n        super.doDestroy();\n    }\n};\n", "/**\n * @module Scheduler/model/mixin/ProjectCurrentConfig\n */\n/**\n * Mixin that makes sure current config for a project includes store data and is cleaned up properly.\n *\n * @mixin\n * @private\n */\nexport default Target => class ProjectCurrentConfig extends Target {\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs/fields for the project, with special handling for inline data\n    getCurrentConfig(options) {\n        const\n            me     = this,\n            result = super.getCurrentConfig(options);\n        if (result) {\n            for (const storeName of ['eventStore', 'resourceStore', 'assignmentStore', 'dependencyStore', 'timeRangeStore', 'resourceTimeRangeStore']) {\n                const store = me[storeName];\n                if (store) {\n                    if (store.count) {\n                        result[store.id + 'Data'] = store.getInlineData(options);\n                    }\n                    // Get stores current state, in case it has filters etc. added at runtime\n                    const storeState = store.getCurrentConfig(options);\n                    if (storeState && Object.keys(storeState).length > 0) {\n                        result[storeName] = Object.assign(result[storeName] || {}, storeState);\n                    }\n                    // Remove empty store configs\n                    else if (result[storeName] && Object.keys(result[storeName]).length === 0) {\n                        delete result[storeName];\n                    }\n                }\n            }\n            if (result.timeRangeStore) {\n                // Exclude default time range modelClass (it is a plain store), spam\n                if (me.timeRangeStore.originalModelClass === me.timeRangeModelClass || me.timeRangeStore.originalModelClass.$name === 'TimeSpan') {\n                    delete result.timeRangeStore.modelClass;\n                }\n                // Same for default storeId\n                if (result.timeRangeStore.storeId === 'timeRanges') {\n                    delete result.timeRangeStore.storeId;\n                }\n                // Since timeRangeStore is a plain store it is always configured with id, spam\n                if (Object.keys(result.timeRangeStore).length === 1) {\n                    delete result.timeRangeStore;\n                }\n            }\n            // Gantt specifics\n            if (me.taskStore.isTaskStore) {\n                delete result.eventModelClass;\n                delete result.eventStoreClass;\n                delete result.children;\n            }\n            return result;\n        }\n    }\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/data/util/ModelPersistencyManager\n */\n/**\n * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable\n * records from sync operation. The logic has meaning only for CRUD-less sync operations.\n *\n * @private\n */\nexport default class ModelPersistencyManager extends Base {\n    // region Event attachers\n    set eventStore(newEventStore) {\n        const me = this;\n        me.eventStoreDetacher && me.eventStoreDetacher();\n        me._eventStore = newEventStore;\n        if (newEventStore && newEventStore.autoCommit) {\n            me.eventStoreDetacher = newEventStore.ion({\n                beforecommit : me.onEventStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n    get eventStore() {\n        return this._eventStore;\n    }\n    set resourceStore(newResourceStore) {\n        const me = this;\n        me.resourceStoreDetacher && me.resourceStoreDetacher();\n        me._resourceStore = newResourceStore;\n        if (newResourceStore && newResourceStore.autoCommit) {\n            me.resourceStoreDetacher = newResourceStore.ion({\n                beforecommit : me.onResourceStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n    get resourceStore() {\n        return this._resourceStore;\n    }\n    set assignmentStore(newAssignmentStore) {\n        const me = this;\n        me.assignmentStoreDetacher && me.assignmentStoreDetacher();\n        me._assignmentStore = newAssignmentStore;\n        if (newAssignmentStore && newAssignmentStore.autoSync) {\n            me.assignmentStoreDetacher = newAssignmentStore.ion({\n                beforecommit : me.onAssignmentStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n    get assignmentStore() {\n        return this._assignmentStore;\n    }\n    set dependencyStore(newDependencyStore) {\n        const me = this;\n        me.dependencyStoreDetacher && me.dependencyStoreDetacher();\n        me._dependencyStore = newDependencyStore;\n        if (newDependencyStore && newDependencyStore.autoSync) {\n            me.dependencyStoreDetacher = newDependencyStore.ion({\n                beforecommit : me.onDependencyStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n    get dependencyStore() {\n        return this._dependencyStore;\n    }\n    // endregion\n    // region Event handlers\n    onEventStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n    onResourceStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n    onAssignmentStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n    onDependencyStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n    // endregion\n    // region Management rules\n    removeNonPersistableRecordsToCreate(changes) {\n        const recordsToCreate = changes.added || [];\n        let r, i;\n        // We remove from the array we iterate thus we iterate from end to start\n        for (i = recordsToCreate.length - 1; i >= 0; --i) {\n            r = recordsToCreate[i];\n            if (!r.isPersistable) {\n                recordsToCreate.splice(recordsToCreate.indexOf(r), 1);\n            }\n        }\n        // Prevent empty create request\n        if (recordsToCreate.length === 0) {\n            changes.added.length = 0;\n        }\n    }\n    shallContinueSync(options) {\n        return Boolean((options.added && options.added.length > 0) ||\n            (options.modified && options.modified.length > 0) ||\n            (options.removed && options.removed.length > 0));\n    }\n    // endregion\n}\nModelPersistencyManager._$name = 'ModelPersistencyManager';", "import VersionHelper from '../../Core/helper/VersionHelper.js';\nimport ProjectModelMixin from './mixin/ProjectModelMixin.js';\nimport ProjectCurrentConfig from './mixin/ProjectCurrentConfig.js';\nimport ModelPersistencyManager from '../data/util/ModelPersistencyManager.js';\nimport { SchedulerCoreProjectMixin } from '../../Engine/quark/model/scheduler_core/SchedulerCoreProjectMixin.js';\nimport EventModel from './EventModel.js';\nimport DependencyModel from './DependencyModel.js';\nimport ResourceModel from './ResourceModel.js';\nimport AssignmentModel from './AssignmentModel.js';\nimport EventStore from '../data/EventStore.js';\nimport DependencyStore from '../data/DependencyStore.js';\nimport ResourceStore from '../data/ResourceStore.js';\nimport AssignmentStore from '../data/AssignmentStore.js';\nconst EngineMixin = SchedulerCoreProjectMixin;\n/**\n * @module Scheduler/model/ProjectModel\n */\n/**\n * This class represents a global project of your Scheduler - a central place for all data.\n *\n * It holds and links the stores usually used by Scheduler:\n *\n * - {@link Scheduler.data.EventStore}\n * - {@link Scheduler.data.ResourceStore}\n * - {@link Scheduler.data.AssignmentStore}\n * - {@link Scheduler.data.DependencyStore}\n * - {@link #config-timeRangeStore TimeRangeStore}\n * - {@link Scheduler.data.ResourceTimeRangeStore}\n *\n * The project uses a calculation engine to normalize dates and durations. It is also responsible for\n * handling references between models, for example to link an event via an assignment to a resource. These operations\n * are asynchronous, a fact that is hidden when working in the Scheduler UI but which you must know about when performing\n * more advanced operations on the data level.\n *\n * When there is a change to data that requires something else to be recalculated, the project schedules a calculation (a\n * commit) which happens moments later. It is also possible to trigger these calculations directly. This snippet illustrate\n * the process:\n *\n 1. Something changes which requires the project to recalculate, for example adding a new task:\n *\n * ```javascript\n * const [event] = project.eventStore.add({ startDate, endDate });\n * ```\n *\n * 2. A recalculation is scheduled, thus:\n *\n * ```javascript\n * event.duration; // <- Not yet calculated\n * ```\n *\n * 3. Calculate now instead of waiting for the scheduled calculation\n *\n * ```javascript\n * await project.commitAsync();\n *\n * event.duration; // <- Now available\n * ```\n *\n * ## Using inline data\n *\n * The project provides settable property {@link Scheduler.crud.AbstractCrudManager#property-inlineData} that can\n * be used to get data from all its stores at once and to set this data as well. Populating the stores this way can\n * be useful if you cannot or you do not want to use CrudManager for server requests but you pull the data by other\n * means and have it ready outside of ProjectModel. Also, the data from all stores is available in a single\n * assignment statement.\n *\n * ### Getting data\n * ```javascript\n * const data = scheduler.project.inlineData;\n *\n * // use the data in your application\n * ```\n *\n * ### Setting data\n * ```javascript\n * const data = // your function to pull server data\n *\n * scheduler.project.inlineData = data;\n * ```\n *\n * ## Monitoring data changes\n *\n * While it is possible to listen for data changes on the projects individual stores, it is sometimes more convenient\n * to have a centralized place to handle all data changes. By listening for the {@link #event-change change event} your\n * code gets notified when data in any of the stores changes. Useful for example to keep an external data model up to\n * date:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     project: {\n *         listeners : {\n *             change({ store, action, records }) {\n *                 const { $name } = store.constructor;\n *\n *                 if (action === 'add') {\n *                     externalDataModel.add($name, records);\n *                 }\n *\n *                 if (action === 'remove') {\n *                     externalDataModel.remove($name, records);\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Built in StateTrackingManager\n *\n * The project also has a built in {@link Core.data.stm.StateTrackingManager StateTrackingManager} (STM for short), that\n * handles undo/redo for the project stores (additional stores can also be added). You can enable it to track all\n * project store changes:\n *\n * ```javascript\n * // Turn on auto recording when you create your Scheduler:\n * const scheduler = new Scheduler({\n *    project : {\n *        stm : {\n *            autoRecord : true\n *        }\n *    }\n * });\n *\n * // Undo a transaction\n * project.stm.undo();\n *\n * // Redo\n * project.stm.redo();\n * ```\n *\n * Check out the `undoredo` demo to see it in action.\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/ProjectModelMixin\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class ProjectModel extends ProjectCurrentConfig(ProjectModelMixin(EngineMixin)) {\n    static get $name() {\n        return 'ProjectModel';\n    }\n    //region Inline data configs & properties\n    /**\n     * @hidefields id, readOnly, children, parentId, parentIndex\n     */\n    /**\n     * Get/set {@link #property-eventStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.EventModel EventModels} but also accepts an array of\n     * its configuration objects as input.\n     *\n     * @member {Scheduler.model.EventModel[]} events\n     * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-eventStore}. Should be an array of\n     * {@link Scheduler.model.EventModel EventModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events\n     * @category Inline data\n     */\n    /**\n     * Get/set {@link #property-resourceStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.ResourceModel ResourceModels} but also accepts an array\n     * of its configuration objects as input.\n     *\n     * @member {Scheduler.model.ResourceModel[]} resources\n     * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-resourceStore}. Should be an array of\n     * {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources\n     * @category Inline data\n     */\n    /**\n     * Get/set {@link #property-assignmentStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.AssignmentModel AssignmentModels} but also accepts an\n     * array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.AssignmentModel[]} assignments\n     * @accepts {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-assignmentStore}. Should be an array of\n     * {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} assignments\n     * @category Inline data\n     */\n    /**\n     * Get/set {@link #property-dependencyStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.DependencyModel DependencyModels} but also accepts an\n     * array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.DependencyModel[]} dependencies\n     * @accepts {Scheduler.model.DependencyModel[]|DependencyModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-dependencyStore}. Should be an array of\n     * {@link Scheduler.model.DependencyModel DependencyModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} dependencies\n     * @category Inline data\n     */\n    /**\n     * Get/set {@link #property-timeRangeStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.TimeSpan TimeSpans} but also accepts an\n     * array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.TimeSpan[]} timeRanges\n     * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-timeRangeStore}. Should be an array of\n     * {@link Scheduler.model.TimeSpan TimeSpans} or its configuration objects.\n     *\n     * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n     * @category Inline data\n     */\n    /**\n     * Get/set {@link #property-resourceTimeRangeStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} but\n     * also accepts an array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n     * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-resourceTimeRangeStore}. Should be an array\n     * of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges\n     * @category Inline data\n     */\n    //endregion\n    //region Legacy inline data configs & properties\n    /**\n     * The initial data, to fill the {@link #property-eventStore} with.\n     * Should be an array of {@link Scheduler.model.EventModel EventModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} eventsData\n     * @category Legacy inline data\n     */\n    /**\n     * The initial data, to fill the {@link #property-dependencyStore} with.\n     * Should be an array of {@link Scheduler.model.DependencyModel DependencyModels} or its configuration\n     * objects.\n     *\n     * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} [dependenciesData]\n     * @category Legacy inline data\n     */\n    /**\n     * The initial data, to fill the {@link #property-resourceStore} with.\n     * Should be an array of {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} [resourcesData]\n     * @category Legacy inline data\n     */\n    /**\n     * The initial data, to fill the {@link #property-assignmentStore} with.\n     * Should be an array of {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration\n     * objects.\n     *\n     * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} [assignmentsData]\n     * @category Legacy inline data\n     */\n    //endregion\n    //region Store configs & properties\n    /**\n     * The {@link Scheduler.data.EventStore store} holding the events information.\n     *\n     * See also {@link Scheduler.model.EventModel}\n     *\n     * @member {Scheduler.data.EventStore} eventStore\n     * @category Models & Stores\n     */\n    /**\n     * An {@link Scheduler.data.EventStore} instance or a config object.\n     * @config {Scheduler.data.EventStore|EventStoreConfig} eventStore\n     * @category Models & Stores\n     */\n    /**\n     * The {@link Scheduler.data.DependencyStore store} holding the dependencies information.\n     *\n     * See also {@link Scheduler.model.DependencyModel}\n     *\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @category Models & Stores\n     */\n    /**\n     * A {@link Scheduler.data.DependencyStore} instance or a config object.\n     * @config {Scheduler.data.DependencyStore|DependencyStoreConfig} dependencyStore\n     * @category Models & Stores\n     */\n    /**\n     * The {@link Scheduler.data.ResourceStore store} holding the resources that can be assigned to the events in the event store.\n     *\n     * See also {@link Scheduler.model.ResourceModel}\n     *\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @category Models & Stores\n     */\n    /**\n     * A {@link Scheduler.data.ResourceStore} instance or a config object.\n     * @config {Scheduler.data.ResourceStore|ResourceStoreConfig} resourceStore\n     * @category Models & Stores\n     */\n    /**\n     * The {@link Scheduler.data.AssignmentStore store} holding the assignments information.\n     *\n     * See also {@link Scheduler.model.AssignmentModel}\n     *\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @category Models & Stores\n     */\n    /**\n     * An {@link Scheduler.data.AssignmentStore} instance or a config object.\n     * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig} assignmentStore\n     * @category Models & Stores\n     */\n    //endregion\n    //region Configs\n    static get defaultConfig() {\n        return {\n            /**\n             * The constructor of the event model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-eventStore}\n             *\n             * @config {Scheduler.model.EventModel}\n             * @typings {typeof EventModel}\n             * @category Models & Stores\n             */\n            eventModelClass : EventModel,\n            /**\n             * The constructor of the dependency model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-dependencyStore}\n             *\n             * @config {Scheduler.model.DependencyModel}\n             * @typings {typeof DependencyModel}\n             * @category Models & Stores\n             */\n            dependencyModelClass : DependencyModel,\n            /**\n             * The constructor of the resource model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-resourceStore}\n             *\n             * @config {Scheduler.model.ResourceModel}\n             * @typings {typeof ResourceModel}\n             * @category Models & Stores\n             */\n            resourceModelClass : ResourceModel,\n            /**\n             * The constructor of the assignment model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-assignmentStore}\n             *\n             * @config {Scheduler.model.AssignmentModel}\n             * @typings {typeof AssignmentModel}\n             * @category Models & Stores\n             */\n            assignmentModelClass : AssignmentModel,\n            /**\n             * The constructor to create an event store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.EventStore}\n             * @config {Scheduler.data.EventStore|Object}\n             * @typings {typeof EventStore|object}\n             * @category Models & Stores\n             */\n            eventStoreClass : EventStore,\n            /**\n             * The constructor to create a dependency store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.DependencyStore}\n             * @config {Scheduler.data.DependencyStore|Object}\n             * @typings {typeof DependencyStore|object}\n             * @category Models & Stores\n             */\n            dependencyStoreClass : DependencyStore,\n            /**\n             * The constructor to create a resource store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.ResourceStore}\n             * @config {Scheduler.data.ResourceStore|Object}\n             * @typings {typeof ResourceStore|object}\n             * @category Models & Stores\n             */\n            resourceStoreClass : ResourceStore,\n            /**\n             * The constructor to create an assignment store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.AssignmentStore}\n             * @config {Scheduler.data.AssignmentStore|Object}\n             * @typings {typeof AssignmentStore|object}\n             * @category Models & Stores\n             */\n            assignmentStoreClass : AssignmentStore\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired when the engine has finished its calculations and the results has been written back to the records.\n     *\n     * ```javascript\n     * scheduler.project.on({\n     *     dataReady() {\n     *        console.log('Calculations finished');\n     *     }\n     * });\n     *\n     * scheduler.eventStore.first.duration = 10;\n     *\n     * // At some point a bit later it will log 'Calculations finished'\n     * ```\n     *\n     * @event dataReady\n     * @param {Scheduler.model.ProjectModel} source The project\n     */\n    //endregion\n    /**\n     * Silences propagations caused by the project loading.\n     *\n     * Applying the loaded data to the project occurs in two basic stages:\n     *\n     * 1. Data gets into the engine graph which triggers changes propagation\n     * 2. The changes caused by the propagation get written to related stores\n     *\n     * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes\n     * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.\n     *\n     * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.\n     * By default the system treats the data as consistent so this option is `true`.\n     *\n     * ```js\n     * new Scheduler({\n     *     project : {\n     *         // We want scheduling engine to recalculate the data properly\n     *         // so then we could save it back to the server\n     *         silenceInitialCommit : false\n     *     }\n     *     ...\n     * })\n     * ```\n     *\n     * @config {Boolean} silenceInitialCommit\n     * @default true\n     * @category Advanced\n     */\n    construct(...args) {\n        super.construct(...args);\n        if (VersionHelper.isTestEnv) {\n            globalThis.bryntum.testProject = this;\n        }\n        // Moved here from EventStore, since project is now the container instead of it\n        this.modelPersistencyManager = this.createModelPersistencyManager();\n    }\n    /**\n     * Creates and returns model persistency manager\n     *\n     * @returns {Scheduler.data.util.ModelPersistencyManager}\n     * @internal\n     */\n    createModelPersistencyManager() {\n        return new ModelPersistencyManager({\n            eventStore      : this,\n            resourceStore   : this.resourceStore,\n            assignmentStore : this.assignmentStore,\n            dependencyStore : this.dependencyStore\n        });\n    }\n    doDestroy() {\n        this.modelPersistencyManager.destroy();\n        super.doDestroy();\n    }\n    // To comply with TaskBoards expectations\n    get taskStore() {\n        return this.eventStore;\n    }\n}\nProjectModel.applyConfigs = true;\nProjectModel.initClass();\nProjectModel._$name = 'ProjectModel';", "import Base from '../../../Core/Base.js';\n/**\n * @module SchedulerPro/data/mixin/PartOfProject\n */\nconst throwIfNotTheSameStore = (oldStore, newStore) => {\n    if (oldStore !== newStore) {\n        throw new Error('Store set is prohibited for Scheduler Pro entity!');\n    }\n};\n/**\n * This is a mixin, included in all models and stores of the Scheduler Pro project. It provides a common API for accessing\n * all stores of the project.\n *\n * @typings Scheduler/data/mixin/PartOfProject -> Scheduler/data/mixin/SchedulerPartOfProject\n *\n * @mixin\n */\nexport default Target => class PartOfProject extends (Target || Base) {\n    static get $name() {\n        return 'PartOfProject';\n    }\n    /**\n     * Returns the project this entity belongs to.\n     *\n     * @member {SchedulerPro.model.ProjectModel} project\n     * @readonly\n     */\n    /**\n     * An {@link SchedulerPro.data.EventStore} instance or a config object.\n     * @config {SchedulerPro.data.EventStore|EventStoreConfig} taskStore\n     * @category Project\n     */\n    /**\n     * The {@link SchedulerPro.data.EventStore store} holding data on events.\n     *\n     * @member {SchedulerPro.data.EventStore}\n     * @category Project\n     * @readonly\n     */\n    get taskStore() {\n        return this.eventStore;\n    }\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set taskStore(store) {\n        this.eventStore = store;\n    }\n    /**\n     * Returns the task store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.EventStore}\n     * @category Project\n     * @readonly\n     * @typings Scheduler/model/mixin/ProjectModelMixin:eventStore -> {Scheduler.data.EventStore||SchedulerPro.data.EventStore}\n     */\n    get eventStore() {\n        return this.project?.eventStore;\n    }\n    get leftProjectEventStore() {\n        const project = this.leftProject;\n        return project?.getEventStore() || null;\n    }\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set eventStore(store) {\n        throwIfNotTheSameStore(this.eventStore, store);\n    }\n    /**\n     * Returns the dependency store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.DependencyStore}\n     * @category Project\n     * @readonly\n     * @typings Scheduler/model/mixin/ProjectModelMixin:dependencyStore -> {Scheduler.data.DependencyStore||SchedulerPro.data.DependencyStore}\n     */\n    get dependencyStore() {\n        return this.project?.dependencyStore;\n    }\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set dependencyStore(store) {\n        throwIfNotTheSameStore(this.dependencyStore, store);\n    }\n    /**\n     * Returns the assignment store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.AssignmentStore}\n     * @readonly\n     * @category Project\n     * @typings Scheduler/model/mixin/ProjectModelMixin:assignmentStore -> {Scheduler.data.AssignmentStore||SchedulerPro.data.AssignmentStore}\n     */\n    get assignmentStore() {\n        return this.project?.assignmentStore;\n    }\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set assignmentStore(store) {\n        throwIfNotTheSameStore(this.assignmentStore, store);\n    }\n    /**\n     * Returns the resource store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.ResourceStore}\n     * @readonly\n     * @category Project\n     * @typings Scheduler/model/mixin/ProjectModelMixin:resourceStore -> {Scheduler.data.ResourceStore||SchedulerPro.data.ResourceStore}\n     */\n    get resourceStore() {\n        return this.project?.resourceStore;\n    }\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set resourceStore(store) {\n        throwIfNotTheSameStore(this.resourceStore, store);\n    }\n    /**\n     * Returns the calendar manager store of the project this entity belongs to.\n     *\n     * @property {SchedulerPro.data.CalendarManagerStore}\n     * @readonly\n     * @category Project\n     */\n    get calendarManagerStore() {\n        return this.project?.calendarManagerStore;\n    }\n    // this setter actually does nothing, intentionally, setting the stores on other stores is deprecated\n    set calendarManagerStore(store) {\n        throwIfNotTheSameStore(this.calendarManagerStore, store);\n    }\n};\n", "import Model from '../../Core/data/Model.js';\nimport AssignmentModelMixin from '../../Scheduler/model/mixin/AssignmentModelMixin.js';\nimport { SchedulerProAssignmentMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProAssignmentMixin.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n/**\n * @module SchedulerPro/model/AssignmentModel\n */\n/**\n * This class represent a single assignment of a resource to an event in Scheduler Pro. It has a lot in common with\n * Schedulers AssignmentModel, they are separate models but they share much functionality using the\n * {@link Scheduler.model.mixin.AssignmentModelMixin AssignmentModelMixin} mixin.\n *\n * It is a subclass of {@link Core.data.Model} class. Please refer to the documentation for that class to become\n * familiar with the base interface of this class.\n *\n * ## Fields and references\n *\n * An Assignment has the following fields:\n * - `id` - The id of the assignment\n * - `resourceId` - The id of the resource assigned (optionally replaced with `resource` for load)\n * - `eventId` - The id of the event to which the resource is assigned (optionally replaced with `event` for load)\n *\n * The data source for these fields can be customized by subclassing this class:\n *\n * ```javascript\n * class MyAssignment extends AssignmentModel {\n *   static get fields() {\n *       return [\n *          { name : 'resourceId', dataSource : 'linkedResource' }\n *       ];\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `event` - The linked event record\n * - `resource` - The linked resource record\n *\n * ## Async resolving of references\n *\n * As described above, an assignment links an event to a resource. It holds references to an event record and a resource\n * record. These references are populated async, using the calculation engine of the project that the assignment via\n * its store is a part of. Because of this asyncness, references cannot be used immediately after modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // assignment.resource is not yet available\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // assignment.resource is available\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // assignment.resource is available\n * ```\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/AssignmentModelMixin\n * @uninherit Core/data/mixin/TreeNode\n * @typings Scheduler/model/AssignmentModel -> Scheduler/model/SchedulerAssignmentModel\n */\nexport default class AssignmentModel extends PartOfProject(AssignmentModelMixin(SchedulerProAssignmentMixin.derive(Model))) {\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n    /**\n     * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after\n     * load it will be populated with the actual event and not its id. This field is not persistable.\n     * @field {SchedulerPro.model.EventModel} event\n     * @accepts {String|Number|SchedulerPro.model.EventModel}\n     * @typings {String||Number||SchedulerPro.model.EventModel||Core.model.Model}\n     * @category Common\n     */\n    /**\n     * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after\n     * load it will be populated with the actual resource and not its id. This field is not persistable.\n     * @field {SchedulerPro.model.ResourceModel} resource\n     * @accepts {String|Number|SchedulerPro.model.ResourceModel}\n     * @category Common\n     */\n    /**\n     * A numeric, percent-like value, indicating the \"contribution level\"\n     * of the resource availability to the {@link #field-event}.\n     * Number 100 means that the assigned {@link #field-resource} spends all its working time\n     * on the {@link #field-event}.\n     * And number 50 means that the resource spends only half of its available time\n     * on the {@link #field-event}.\n     * Setting the value to 0 will unassign the resource (and remove the assignment)\n     * @field {Number} units\n     * @category Common\n     */\n    //region Config\n    static $name = 'AssignmentModel';\n    static isProAssignmentModel = true;\n    //endregion\n    //region Early render\n    get event() {\n        const\n            { project } = this,\n            event       = super.event;\n        // Figure reference out before buckets are created (if part of project)\n        if (project?.isDelayingCalculation) {\n            return project.eventStore.getById(event);\n        }\n        return event;\n    }\n    set event(event) {\n        super.event = event;\n    }\n    get resource() {\n        const\n            { project }  = this;\n        let resource     = super.resource;\n        // Figure reference out before buckets are created (if part of project)\n        if (project?.isDelayingCalculation) {\n            resource = project.resourceStore.getById(resource);\n        }\n        return resource?.$original;\n    }\n    set resource(resource) {\n        super.resource = resource;\n    }\n    //endregion\n    get eventResourceKey() {\n        return this.isInActiveTransaction\n            ? this.buildEventResourceKey(this.event, this.resource)\n            : this.buildEventResourceKey(this.$.event.DATA, this.$.resource.DATA);\n    }\n}\nAssignmentModel._$name = 'AssignmentModel';", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport AssignmentStoreMixin from '../../Scheduler/data/mixin/AssignmentStoreMixin.js';\nimport AssignmentModel from '../model/AssignmentModel.js';\nimport { ChronoAssignmentStoreMixin } from '../../Engine/quark/store/ChronoAssignmentStoreMixin.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n/**\n * @module SchedulerPro/data/AssignmentStore\n */\n/**\n * A store representing a collection of assignments between events in the {@link SchedulerPro.data.EventStore} and resources\n * in the {@link SchedulerPro.data.ResourceStore}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.AssignmentModel}.\n *\n * An AssignmentStore is usually connected to a project, which binds it to other related stores (EventStore,\n * ResourceStore and DependencyStore). The project also handles references (event, resource) to related records for the\n * records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * assignmentStore.data = [{ eventId, resourceId }, ...];\n *\n * // references (event, resource) not resolved yet\n *\n * await assignmentStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await assignmentStore.loadDataAsync([{ eventId, resourceId }, ...]);\n *\n * // references (event, resource) are resolved\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/AssignmentStoreMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/AssignmentStore -> Scheduler/data/SchedulerAssignmentStore\n */\nexport default class AssignmentStore extends PartOfProject(AssignmentStoreMixin(ChronoAssignmentStoreMixin.derive(AjaxStore))) {\n    static $name = 'AssignmentStore';\n    static get defaultConfig() {\n        return {\n            modelClass : AssignmentModel\n        };\n    }\n}\nAssignmentStore._$name = 'AssignmentStore';", "import Model from '../../Core/data/Model.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { CalendarIntervalMixin } from '../../Engine/calendar/CalendarIntervalMixin.js';\n/**\n * @module SchedulerPro/model/CalendarIntervalModel\n */\n/**\n * This is a documentation-only class, representing an interval in the {@link SchedulerPro/model/CalendarModel calendar}\n *\n * Please refer to the [calendars guide](#SchedulerPro/guides/basics/calendars.md) for details\n */\nexport default class CalendarIntervalModel extends PartOfProject(CalendarIntervalMixin.derive(Model)) {\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n    //region Fields\n    /**\n     * The start date of the fixed (not recurrent) time interval.\n     *\n     * @field {Date} startDate\n     */\n    /**\n     * The end date of the fixed (not recurrent) time interval.\n     *\n     * @field {Date} endDate\n     */\n    /**\n     * The start date of the recurrent time interval. Should be specified as any expression, recognized\n     * by the excellent [later](http://bunkat.github.io/later/) library.\n     *\n     * @field {String} recurrentStartDate\n     */\n    /**\n     * The end date of the recurrent time interval. Should be specified as any expression, recognized\n     * by the excellent [later](http://bunkat.github.io/later/) library.\n     *\n     * @field {String} recurrentEndDate\n     */\n    /**\n     * The \"is working\" flag, which defines what kind of interval this is - either working or non-working. Default value is `false`,\n     * denoting non-working intervals.\n     *\n     * @field {Boolean} isWorking\n     * @default false\n     */\n    /**\n     * A CSS class to add to the element visualizing this interval, when using the NonWorkingTime feature.\n     * <div class=\"note\">Note that only non working intervals are visible.</div>\n     *\n     * @field {String} cls\n     */\n    /**\n     * A CSS class used to add an icon to the element visualizing this interval, when using the NonWorkingTime feature.\n     * <div class=\"note\">Note that only non working intervals are visible.</div>\n     *\n     * @field {String} iconCls\n     */\n    //endregion\n    //region Methods\n    /**\n     * Whether this interval is recurrent (both `recurrentStartDate` and `recurrentEndDate` are present and parsed correctly\n     * by the `later` library).\n     *\n     * @method isRecurrent\n     * @returns {Boolean}\n     */\n    /**\n     * Whether this interval is static - both `startDate` and `endDate` are present.\n     *\n     * @method isStatic\n     * @returns {Boolean}\n     */\n    /**\n     * Returns an internal representation of the recurrent start date from the `later` library.\n     *\n     * @method getStartDateSchedule\n     * @returns {Object}\n     */\n    /**\n     * Returns an internal representation of the recurrent end date from the `later` library.\n     *\n     * @method getEndDateSchedule\n     * @returns {Object}\n     */\n    //endregion\n    //region Config\n    static get $name() {\n        return 'CalendarIntervalModel';\n    }\n    //endregion\n}\nCalendarIntervalModel._$name = 'CalendarIntervalModel';", "import Model from '../../Core/data/Model.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport { BaseCalendarMixin } from '../../Engine/quark/model/scheduler_basic/BaseCalendarMixin.js';\nimport CalendarIntervalModel from './CalendarIntervalModel.js';\n/**\n * @module SchedulerPro/model/CalendarModel\n */\n/**\n * This class represents a calendar in the Scheduler Pro project. It contains a collection of the {@link SchedulerPro.model.CalendarIntervalModel}.\n * Every interval can be either recurrent (regularly repeating in time) or static. These intervals can be visualized\n * by the {@link SchedulerPro.feature.ResourceNonWorkingTime} or {@link Scheduler.feature.NonWorkingTime} features.\n *\n * Please refer to the [calendars guide](#SchedulerPro/guides/basics/calendars.md) for details\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n *\n * @extends Core/data/Model\n */\nexport default class CalendarModel extends PartOfProject(BaseCalendarMixin.derive(Model)) {\n    //region Config\n    static get $name() {\n        return 'CalendarModel';\n    }\n    /**\n     * Returns the earliest point at which a working period of time starts, following the given date.\n     * Can be the date itself, if it occurs during working time.\n     * @method skipNonWorkingTime\n     * @param {Date} date The date after which to skip the non-working time\n     * @param {Boolean} [isForward=true] Whether the \"following\" means forward in time or backward\n     * @returns {Date} The earliest available date\n     */\n    /**\n     * This method adds a single {@link SchedulerPro.model.CalendarIntervalModel} to the internal collection of the\n     * calendar\n     * @method addInterval\n     * @param {SchedulerPro.model.CalendarIntervalModel|CalendarIntervalModelConfig} interval record or an object with\n     * data used to create a new record\n     * @returns {SchedulerPro.model.CalendarIntervalModel[]} Added intervals\n     */\n    /**\n     * This method adds an array of {@link SchedulerPro.model.CalendarIntervalModel} to the internal collection of the\n     * calendar\n     * @method addIntervals\n     * @param {SchedulerPro.model.CalendarIntervalModel[]|CalendarIntervalModelConfig[]} intervals An array of records\n     * or an array of objects with data used to create new records\n     * @returns {SchedulerPro.model.CalendarIntervalModel[]} Added intervals\n     */\n    /**\n     * This method removes all intervals from the internal collection of the calendar\n     * @method clearIntervals\n     * @param {Boolean} [silent] Do not trigger events\n     */\n    /**\n     * Calculate the working time duration for specific interval, in milliseconds.\n     * @method calculateDurationMs\n     * @param {Date} startDate Start of the interval\n     * @param {Date} endDate End of the interval\n     * @returns {Number} Returns working time in milliseconds\n     */\n    /**\n     * Checks if there is a working time interval in the provided time range\n     * @method isWorkingTime\n     * @param {Date} startDate Start of the interval\n     * @param {Date} endDate End of the interval\n     * @returns {Boolean} Returns `true` if the interval contains working time\n     */\n    /**\n     * Calculates the end date of the time interval which starts at `startDate` and has `durationMs` working time\n     * duration (in milliseconds).\n     * @method calculateEndDate\n     * @param {Date} startDate Start date\n     * @param {Number} durationMs Duration in milliseconds\n     * @returns {Date} The end date\n     */\n    /**\n     * Calculates the start date of the time interval which ends at `endDate` and has `durationMs` working time\n     * duration (in milliseconds).\n     * @method calculateStartDate\n     * @param {Date} endDate End date\n     * @param {Number} durationMs Duration in milliseconds\n     * @returns {Date} The start date\n     */\n    static get fields() {\n        return [\n            /**\n             * The calendar name.\n             * @field {String} name\n             */\n            /**\n             * A CSS class to add to calendar interval elements rendered in the UI.\n             * @field {String} cls\n             */\n            /**\n             * A CSS class defining an icon to show in non-working time elements rendered in the UI.\n             * @field {String} iconCls\n             */\n            /**\n             * The flag, indicating, whether the \"unspecified\" time (time that does not belong to any interval\n             * is working (`true`) or not (`false`).\n             *\n             * @field {Boolean} unspecifiedTimeIsWorking\n             * @default true\n             */\n            /**\n             * {@link SchedulerPro.model.CalendarIntervalModel Intervals} collection of the calendar. Accepts an array\n             * as its input, which behind the scenes will be converted to a store containing the intervals. When\n             * serializing it will be converted back to an array.\n             *\n             * @field {Core.data.Store} intervals\n             * @accepts {SchedulerPro.model.CalendarIntervalModel[]|CalendarIntervalModelConfig[]}\n             */\n            /**\n             * Start expanded or not\n             * @readonly\n             * @field {Boolean} expanded\n             * @default true\n             * @category Tree\n             */\n            {\n                name         : 'expanded',\n                internal     : true,\n                defaultValue : true\n            }\n        ];\n    }\n    //endregion\n    toString() {\n        return this.name || '';\n    }\n    static get defaultConfig() {\n        return {\n            calendarIntervalModelClass : CalendarIntervalModel\n        };\n    }\n}\nCalendarModel._$name = 'CalendarModel';", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport CalendarModel from '../model/CalendarModel.js';\nimport { ChronoCalendarManagerStoreMixin } from '../../Engine/quark/store/ChronoCalendarManagerStoreMixin.js';\n/**\n * @module SchedulerPro/data/CalendarManagerStore\n */\n/**\n * A class representing the tree of calendars in the SchedulerPro chart. An individual calendar is represented as an instance of the\n * {@link SchedulerPro.model.CalendarModel} class. The store expects the data loaded to be hierarchical. Each parent node should\n * contain its children in a property called 'children'.\n *\n * Please refer to the [calendars guide](#SchedulerPro/guides/basics/calendars.md) for details\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n *\n * @extends Core/data/AjaxStore\n */\nexport default class CalendarManagerStore extends PartOfProject(ChronoCalendarManagerStoreMixin.derive(AjaxStore)) {\n    //region Config\n    static get defaultConfig() {\n        return {\n            tree         : true,\n            modelClass   : CalendarModel,\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 100,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 100,\n            storeId      : 'calendars'\n        };\n    }\n    //endregion\n};\nCalendarManagerStore._$name = 'CalendarManagerStore';", "import PartOfProject from '../data/mixin/PartOfProject.js';\nimport DependencyBaseModel from '../../Scheduler/model/DependencyBaseModel.js';\nimport { SchedulerProDependencyMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProDependencyMixin.js';\n/**\n * @module SchedulerPro/model/DependencyModel\n */\n/**\n * This model represents a dependency between two events, usually added to a {@link SchedulerPro.data.DependencyStore}.\n *\n * It is a subclass of the {@link Scheduler.model.DependencyBaseModel} class, which in its turn subclasses\n * {@link Core.data.Model}. Please refer to documentation of those classes to become familiar with the base interface of\n * this class.\n *\n * ## Fields and references\n *\n * A Dependency has a few predefined fields, see Fields below.  The name of any fields data source can be customized in\n * the subclass, see the example below. Please also refer to {@link Core.data.Model} for details.\n *\n * ```javascript\n * class MyDependency extends DependencyModel {\n *   static get fields() {\n *     return [\n *       { name: 'to', dataSource: 'targetId' },\n *       { name: 'from', dataSource: 'sourceId' }\n *     ]);\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `fromEvent` - The event on the start side of the dependency\n * - `toEvent` - The event on the end side of the dependency\n *\n * ## Async resolving of references\n *\n * As described above, a dependency has links to events. These references are populated async, using the calculation\n * engine of the project that the resource via its store is a part of. Because of this asyncness, references cannot be\n * used immediately after modifications:\n *\n * ```javascript\n * dependency.from = 2;\n * // dependency.fromEvent is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * dependency.from = 2;\n * await dependency.project.commitAsync();\n * // dependency.fromEvent is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await dependency.setAsync({ from : 2});\n * // dependency.fromEvent is up to date\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @extends Scheduler/model/DependencyBaseModel\n *\n * @typings Scheduler/model/DependencyModel -> Scheduler/model/SchedulerDependencyModel\n */\nexport default class DependencyModel extends PartOfProject(SchedulerProDependencyMixin.derive(DependencyBaseModel)) {\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n    /**\n     * The calendar of the dependency used to take `lag` duration into account.\n     * @field {SchedulerPro.model.CalendarModel} calendar\n     */\n    /**\n     * Set to `false` to ignore this dependency in scheduling\n     * @field {Boolean} active\n     * @category Dependency\n     */\n    //region Config\n    static get $name() {\n        return 'DependencyModel';\n    }\n    static get isProDependencyModel() {\n        return true;\n    }\n    //endregion\n    //region Render early\n    // Buckets and references are not set up yet during early render, need to look up on stores\n    get fromEvent() {\n        if (this.project?.isDelayingCalculation) {\n            return this.project.eventStore.getById(super.fromEvent);\n        }\n        return super.fromEvent;\n    }\n    set fromEvent(from) {\n        super.fromEvent = from;\n    }\n    get toEvent() {\n        if (this.project?.isDelayingCalculation) {\n            return this.project.eventStore.getById(super.toEvent);\n        }\n        return super.toEvent;\n    }\n    set toEvent(to) {\n        super.toEvent = to;\n    }\n    //endregion\n}\nDependencyModel._$name = 'DependencyModel';", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport DependencyStoreMixin from '../../Scheduler/data/mixin/DependencyStoreMixin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport { ChronoDependencyStoreMixin } from '../../Engine/quark/store/ChronoDependencyStoreMixin.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n/**\n * @module SchedulerPro/data/DependencyStore\n */\n/**\n * A store representing a collection of dependencies between events in the {@link SchedulerPro.data.EventStore}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.DependencyModel}.\n *\n * A DependencyStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and ResourceStore). The project also handles references (fromEvent, toEvent) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * dependencyStore.data = [{ from, to }, ...];\n *\n * // references (fromEvent, toEvent) not resolved yet\n *\n * await dependencyStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await dependencyStore.loadDataAsync([{ from, to }, ...]);\n *\n * // references (fromEvent, toEvent) are resolved\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/DependencyStoreMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/DependencyStore -> Scheduler/data/SchedulerDependencyStore\n */\nexport default class DependencyStore extends PartOfProject(DependencyStoreMixin(ChronoDependencyStoreMixin.derive(AjaxStore))) {\n    static get defaultConfig() {\n        return {\n            modelClass : DependencyModel\n        };\n    }\n}\nDependencyStore._$name = 'DependencyStore';", "/**\n * @module SchedulerPro/model/mixin/PercentDoneMixin\n */\n/**\n * PercentDone mixin to get the current status of a task.\n * @mixin\n */\nexport default Target => class PercentDoneMixin extends Target {\n    static get $name() {\n        return 'PercentDoneMixin';\n    }\n    /**\n     * The current status of a task, expressed as the percentage completed (integer from 0 to 100)\n     * @field {Number} percentDone\n     * @category Scheduling\n     */\n    // Field defined in Engine\n    /**\n     * Indicates if the task is started (its {@link #field-percentDone percent completion} is greater than zero).\n     * @property {Boolean}\n     * @category Progress\n     */\n    get isStarted() {\n        return this.percentDone > 0;\n    }\n    /**\n     * Indicates if the task is complete (its {@link #field-percentDone percent completion} is 100% (or greater)).\n     * @property {Boolean}\n     * @category Progress\n     */\n    get isCompleted() {\n        return this.percentDone >= 100;\n    }\n    /**\n     * Indicates if the task is in progress (its {@link #field-percentDone percent completion} is greater than zero and less than 100%).\n     * @property {Boolean}\n     * @category Progress\n     */\n    get isInProgress() {\n        return this.isStarted && !this.isCompleted;\n    }\n    // Reset % done value when copying a task\n    copy() {\n        const copy = super.copy(...arguments);\n        copy.percentDone = 0;\n        copy.clearChanges();\n        return copy;\n    }\n    /**\n     * Human-friendly rounding. When task is completed < 99%, it rounds the value. It floors value between 99 and 100, to not\n     * show task as completed when it is for example 99.51% done.\n     * @property {Number}\n     * @category Progress\n     */\n    get renderedPercentDone() {\n        const value = typeof this.percentDone === 'number' && !isNaN(this.percentDone) ? this.percentDone : 0;\n        return this.getFormattedPercentDone(value);\n    }\n    getFormattedPercentDone(value = 0) {\n        if (value <= 99) {\n            return Math.round(value);\n        }\n        return Math.floor(value);\n    }\n    set renderedPercentDone(value) {\n        this.percentDone = value;\n    }\n};\n", "import { SchedulerProEventSegment } from '../../Engine/quark/model/scheduler_pro/SchedulerProEventSegment.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport EventModelMixin from '../../Scheduler/model/mixin/EventModelMixin.js';\nimport PercentDoneMixin from './mixin/PercentDoneMixin.js';\n/**\n * @module SchedulerPro/model/EventSegmentModel\n */\n/**\n * This class represents an individual segment of a split event.\n *\n * @extends Scheduler/model/TimeSpan\n * @mixes Scheduler/model/mixin/EventModelMixin\n * @mixes SchedulerPro/model/mixin/PercentDoneMixin\n */\nexport default class EventSegmentModel extends SchedulerProEventSegment.derive(TimeSpan).mixin(\n    EventModelMixin,\n    PercentDoneMixin\n) {\n    static get $name() {\n        return 'EventSegmentModel';\n    }\n    /**\n     * Zero-based index of the segment.\n     * @property {Number} segmentIndex\n     */\n    /**\n     * The event this segment belongs to.\n     * @member {SchedulerPro.model.EventModel} event\n     * @readonly\n     */\n    /**\n     * Alias for `event`, to better match naming in Gantt.\n     * @member {SchedulerPro.model.EventModel} task\n     * @readonly\n     */\n    get task() {\n        return this.event;\n    }\n}\nEventSegmentModel._$name = 'EventSegmentModel';", "import PartOfProject from '../data/mixin/PartOfProject.js';\nimport PercentDoneMixin from './mixin/PercentDoneMixin.js';\nimport { SchedulerProEvent } from '../../Engine/quark/model/scheduler_pro/SchedulerProEvent.js';\nimport Duration from '../../Core/data/Duration.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport EventModelMixin from '../../Scheduler/model/mixin/EventModelMixin.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport RecurringTimeSpan from '../../Scheduler/model/mixin/RecurringTimeSpan.js';\nimport EventSegmentModel from './EventSegmentModel.js';\n/**\n * @module SchedulerPro/model/EventModel\n */\n/**\n * This class represent a single event in your schedule, usually added to a {@link SchedulerPro.data.EventStore}.\n *\n * It is a subclass of the {@link Scheduler.model.TimeSpan}, which is in turn subclass of {@link Core.data.Model}.\n * Please refer to documentation of that class to become familiar with the base interface of the event.\n *\n * ## Async date calculations\n *\n * A record created from an `EventModel` is normally part of an `EventStore`, which in turn is part of a project. When\n * dates or the duration of an event is changed, the project performs async calculations to normalize the other fields.\n * For example if `duration` is change, it will calculate `endDate`.\n *\n * As a result of this being an async operation, the values of other fields are not guaranteed to be up to date\n * immediately after a change. To ensure data is up to date, await the calculations to finish.\n *\n * For example, `endDate` is not up to date after this operation:\n *\n * ```javascript\n * eventRecord.duration = 5;\n * // endDate not yet calculated\n * ```\n *\n * But if calculations are awaited it is up to date:\n *\n * ```javascript\n * eventRecord.duration = 5;\n * await eventRecord.project.commitAsync();\n * // endDate is calculated\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await eventRecord.setAsync({ duration : 5});\n * // endDate is calculated\n * ```\n *\n * ## Subclassing the Event model class\n * The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for\n * the existing fields, you can do that by subclassing this class (see example below).\n *\n * ```javascript\n * class MyEvent extends EventModel {\n *\n *     static get fields() {\n *         return [\n *            // Add new field\n *            { name: 'myField', type : 'number', defaultValue : 0 }\n *         ];\n *     },\n *\n *     myCheckMethod() {\n *         return this.myField > 0\n *     },\n *\n *     ...\n * });\n * ```\n *\n * If you in your data want to use other names for the startDate, endDate, resourceId and name fields you can configure\n * them as seen below:\n * ```javascript\n * class MyEvent extends EventModel {\n *\n *     static get fields() {\n *         return [\n *            { name: 'startDate', dataSource 'taskStart' },\n *            { name: 'endDate', dataSource 'taskEnd', format: 'YYYY-MM-DD' },\n *            { name: 'resourceId', dataSource 'userId' },\n *            { name: 'name', dataSource 'taskTitle' },\n *         ];\n *     },\n *     ...\n * });\n * ```\n *\n * Please refer to {@link Core.data.Model} for additional details.\n *\n * @extends Scheduler/model/TimeSpan\n * @mixes Scheduler/model/mixin/RecurringTimeSpan\n * @mixes Scheduler/model/mixin/EventModelMixin\n * @mixes SchedulerPro/model/mixin/PercentDoneMixin\n * @mixes SchedulerPro/data/mixin/PartOfProject\n *\n * @typings Scheduler/model/EventModel -> Scheduler/model/SchedulerEventModel\n */\nexport default class EventModel extends SchedulerProEvent.derive(TimeSpan).mixin(\n    RecurringTimeSpan,\n    PartOfProject,\n    EventModelMixin,\n    PercentDoneMixin\n) {\n    /**\n     * Returns the event store this event is part of.\n     *\n     * @member {SchedulerPro.data.EventStore} eventStore\n     * @readonly\n     * @typings Scheduler/model/TimeSpan:eventStore -> {Scheduler.data.EventStore||SchedulerPro.data.EventStore}\n     */\n    /**\n     * If given resource is assigned to this event, returns a {@link SchedulerPro.model.AssignmentModel} record.\n     * Otherwise returns `null`\n     *\n     * @method getAssignmentFor\n     * @param {SchedulerPro.model.ResourceModel} resource The instance of {@link SchedulerPro.model.ResourceModel}\n     *\n     * @returns {SchedulerPro.model.AssignmentModel|null}\n     */\n    /**\n     * This method assigns a resource to this event.\n     *\n     * Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method assign\n     * @param {SchedulerPro.model.ResourceModel} resource The instance of {@link SchedulerPro.model.ResourceModel}\n     * @param {Number} [units=100] The `units` field of the new assignment\n     *\n     * @async\n     * @propagating\n     */\n    /**\n     * This method unassigns a resource from this event.\n     *\n     * Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method unassign\n     * @param {SchedulerPro.model.ResourceModel} resource The instance of {@link SchedulerPro.model.ResourceModel}\n     *\n     * @async\n     * @propagating\n     */\n    /**\n     * Sets the calendar of the event. Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method setCalendar\n     * @param {SchedulerPro.model.CalendarModel} calendar The new calendar. Provide `null` to fall back to the project calendar.\n     * @async\n     * @propagating\n     */\n    /**\n     * Returns the event calendar.\n     *\n     * @method getCalendar\n     * @returns {SchedulerPro.model.CalendarModel} The event calendar.\n     */\n    /**\n     * Either activates or deactivates the task depending on the passed value.\n     * Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method setInactive\n     * @param {boolean} inactive `true` to deactivate the task, `false` to activate it.\n     * @async\n     * @propagating\n     */\n    /**\n     * Sets the start date of the event. Will cause the schedule to be updated - returns a `Promise`\n     *\n     * Note, that the actually set start date may be adjusted, according to the calendar, by skipping the non-working time forward.\n     *\n     * @method setStartDate\n     * @param {Date} date The new start date.\n     * @param {Boolean} [keepDuration=true] Whether to keep the duration (and update the end date), while changing the start date, or vice-versa.\n     * @async\n     * @propagating\n     */\n    /**\n     * Sets the end date of the event. Will cause the schedule to be updated - returns a `Promise`\n     *\n     * Note, that the actually set end date may be adjusted, according to the calendar, by skipping the non-working time backward.\n     *\n     * @method setEndDate\n     * @param {Date} date The new end date.\n     * @param {Boolean} [keepDuration=false] Whether to keep the duration (and update the start date), while changing the end date, or vice-versa.\n     * @async\n     * @propagating\n     */\n    /**\n     * Updates the duration (and optionally unit) of the event. Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method setDuration\n     * @param {Number} duration New duration value\n     * @param {String} [unit] New duration unit\n     * @async\n     * @propagating\n     */\n    /**\n     * Sets the constraint type and (optionally) constraining date to the event.\n     *\n     * @method setConstraint\n     * @param {'finishnoearlierthan'|'finishnolaterthan'|'mustfinishon'|'muststarton'|'startnoearlierthan'|'startnolaterthan'|null} constraintType\n     * Constraint type, please refer to the {@link #field-constraintType} for the valid\n     * values.\n     * @param {Date} [constraintDate] Constraint date.\n     * @async\n     * @propagating\n     */\n    /**\n     * Updates the {@link #field-effort} (and optionally {@link #field-effortUnit unit}) of the event.\n     * Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method setEffort\n     * @param {Number} effort New effort value\n     * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} [unit] New effort\n     * unit\n     * @async\n     * @propagating\n     */\n    /**\n     * Sets {@link #field-segments} field value.\n     *\n     * @method\n     * @name setSegments\n     * @param {SchedulerPro.model.EventSegmentModel[]} segments Array of segments or null to make the event not segmented.\n     * @returns {Promise}\n     * @propagating\n     */\n    /**\n     * Splits the event into segments.\n     * @method splitToSegments\n     * @param {Date} from The date to split this event at.\n     * @param {Number} [lag=1] Split duration.\n     * @param {String} [lagUnit] Split duration unit.\n     * @returns {Promise}\n     * @propagating\n     */\n    /**\n     * Merges the event segments.\n     * The method merges two provided event segments (and all the segment between them if any).\n     * @method mergeSegments\n     * @param {SchedulerPro.model.EventSegmentModel} [segment1] First segment to merge.\n     * @param {SchedulerPro.model.EventSegmentModel} [segment2] Second segment to merge.\n     * @returns {Promise}\n     * @propagating\n     */\n    /**\n     * Sets the event {@link #field-ignoreResourceCalendar} field value and triggers rescheduling.\n     *\n     * @method setIgnoreResourceCalendar\n     * @param {Boolean} ignore Provide `true` to ignore the calendars of the assigned resources\n     * when scheduling the event. If `false` the event performs only when\n     * its own {@link #field-calendar} and some of the assigned\n     * resource calendars allow that.\n     * @async\n     * @propagating\n     */\n    /**\n     * Returns the event {@link #field-ignoreResourceCalendar} field value.\n     *\n     * @method getIgnoreResourceCalendar\n     * @returns {Boolean} The event {@link #field-ignoreResourceCalendar} field value.\n     */\n    /**\n     * The event first segment or null if the event is not segmented.\n     * @member {SchedulerPro.model.EventSegmentModel} firstSegment\n     */\n    /**\n     * The event last segment or null if the event is not segmented.\n     * @member {SchedulerPro.model.EventSegmentModel} lastSegment\n     */\n    //region Config\n    static get $name() {\n        return 'EventModel';\n    }\n    static isProEventModel = true;\n    static get fields() {\n        return [\n            /**\n             * This field is automatically set to `true` when the event is \"unscheduled\" - user has provided an empty\n             * string in one of the UI editors for start date, end date or duration. Such event is not rendered,\n             * and does not affect the schedule of its successors.\n             *\n             * To schedule the event back, enter one of the missing values, so that there's enough information\n             * to calculate start date, end date and duration.\n             *\n             * Note, that setting this field manually does nothing. This field should be persisted, but not updated\n             * manually.\n             *\n             * @field {Boolean} unscheduled\n              * @readonly\n              * @category Scheduling\n             */\n            /**\n             * Segments of the event that appear when the event gets {@link #function-splitToSegments}.\n             * @field {SchedulerPro.model.EventSegmentModel[]} segments\n             * @category Scheduling\n             */\n            /**\n             * The current status of a task, expressed as the percentage completed (integer from 0 to 100)\n             *\n             * UI fields representing this data field are disabled for summary events.\n             * See {@link #function-isEditable} for details.\n             *\n             * @field {Number} percentDone\n             * @category Scheduling\n             */\n            /**\n             * The start date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * UI fields representing this data field are disabled for summary events\n             * except the {@link #field-manuallyScheduled manually scheduled} events.\n             * See {@link #function-isEditable} for details.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} startDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            /**\n             * The end date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * UI fields representing this data field are disabled for summary events\n             * except the {@link #field-manuallyScheduled manually scheduled} events.\n             * See {@link #function-isEditable} for details.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} endDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            /**\n             * The numeric part of the timespan's duration (the number of units).\n             *\n             * UI fields representing this data field are disabled for summary events\n             * except the {@link #field-manuallyScheduled manually scheduled} events.\n             * See {@link #function-isEditable} for details.\n             *\n             * @field {Number} duration\n             * @category Scheduling\n             */\n            /**\n             * Field storing the event constraint alias or NULL if not constraint set.\n             * Valid values are:\n             * - \"finishnoearlierthan\"\n             * - \"finishnolaterthan\"\n             * - \"mustfinishon\"\n             * - \"muststarton\"\n             * - \"startnoearlierthan\"\n             * - \"startnolaterthan\"\n             *\n             * @field {'finishnoearlierthan'|'finishnolaterthan'|'mustfinishon'|'muststarton'|'startnoearlierthan'|'startnolaterthan'|null} constraintType\n             * @category Scheduling\n             */\n            /**\n             * Field defining the constraint boundary date, if applicable.\n             * @field {Date} constraintDate\n             * @category Scheduling\n             */\n            /**\n             * When set to `true`, the `startDate` of the event will not be changed by any of its incoming dependencies\n             * or constraints.\n             *\n             * @field {Boolean} manuallyScheduled\n             * @category Scheduling\n             */\n            /**\n             * When set to `true` the event becomes inactive and stops taking part in the project scheduling (doesn't\n             * affect linked events and affect its assigned resources allocation).\n             *\n             * @field {Boolean} inactive\n             * @category Scheduling\n             */\n            /**\n             * When set to `true` the calendars of the assigned resources\n             * are not taken into account when scheduling the event.\n             *\n             * By default the field value is `false` resulting in that the event performs only when\n             * its own {@link #field-calendar} and some of the assigned\n             * resource calendars allow that.\n             * @field {Boolean} ignoreResourceCalendar\n             * @category Scheduling\n             */\n            /**\n             * A calculated field storing the _early start date_ of the event.\n             * The _early start date_ is the earliest possible date the event can start.\n             * This value is calculated based on the earliest dates of the event predecessors and the event own constraints.\n             * If the event has no predecessors nor other constraints, its early start date matches the project start date.\n             *\n             * UI fields representing this data field are naturally disabled since the field is readonly.\n             * See {@link #function-isEditable} for details.\n             *\n             * @field {Date} earlyStartDate\n             * @calculated\n             * @readonly\n             * @category Scheduling\n             */\n            /**\n             * A calculated field storing the _early end date_ of the event.\n             * The _early end date_ is the earliest possible date the event can finish.\n             * This value is calculated based on the earliest dates of the event predecessors and the event own constraints.\n             * If the event has no predecessors nor other constraints, its early end date matches the project start date plus the event duration.\n             *\n             * UI fields representing this data field are naturally disabled since the field is readonly.\n             * See {@link #function-isEditable} for details.\n             *\n             * @field {Date} earlyEndDate\n             * @calculated\n             * @readonly\n             * @category Scheduling\n             */\n            /**\n             * The calendar, assigned to the entity. Allows you to set the time when entity can perform the work.\n             *\n             * All entities are by default assigned to the project calendar, provided as the {@link SchedulerPro.model.ProjectModel#field-calendar} option.\n             *\n             * @field {SchedulerPro.model.CalendarModel} calendar\n             * @category Scheduling\n             */\n            /**\n             * The numeric part of the event effort (the number of units).\n             *\n             * @field {Number} effort\n             * @category Scheduling\n             */\n            /**\n             * The unit part of the event effort, defaults to \"h\" (hours). Valid values are:\n             *\n             * - \"millisecond\" - Milliseconds\n             * - \"second\" - Seconds\n             * - \"minute\" - Minutes\n             * - \"hour\" - Hours\n             * - \"day\" - Days\n             * - \"week\" - Weeks\n             * - \"month\" - Months\n             * - \"quarter\" - Quarters\n             * - \"year\"- Years\n             *\n             * This field is readonly after creation, to change it use the {@link #function-setEffort} call.\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} effortUnit\n             * @default \"hour\"\n             * @category Scheduling\n             * @readonly\n             */\n            /**\n             * This field defines the event scheduling mode. Based on this field some fields of the event\n             * will be \"fixed\" (should be provided by the user) and some - computed.\n             *\n             * Possible values are:\n             *\n             * - `Normal` is the default (and backward compatible) mode. It means the event will be scheduled based on\n             * information about its start/end dates, event own calendar (project calendar if there's no one) and\n             * calendars of the assigned resources.\n             *\n             * - `FixedDuration` mode means, that event has fixed start and end dates, but its effort will be computed\n             * dynamically, based on the assigned resources information. When duration of such event increases,\n             * its effort is increased too. The mode tends to preserve user provided duration so changing effort\n             * results adjusting assignment units and vise-versa assignment changes adjusts effort.\n             *\n             * @field {'Normal'|'FixedDuration'} schedulingMode\n             * @category Scheduling\n             */\n            /**\n             * This boolean flag defines what part the data should be updated in the `FixedDuration` scheduling\n             * mode.\n             * If it is `true`, then {@link #field-effort} is kept intact when new duration is provided and\n             * assignment {@link SchedulerPro.model.AssignmentModel#field-units} is updated.\n             * If it is `false`, then assignment {@link SchedulerPro.model.AssignmentModel#field-units} is kept\n             * intact when new duration is provided and {@link #field-effort} is updated.\n             *\n             * @field {Boolean} effortDriven\n             * @default false\n             * @category Scheduling\n             */\n            /**\n             * The event effective calendar. Returns the\n             * {@link SchedulerPro.model.ProjectModel#field-calendar project calendar} if the event has no own\n             * {@link #field-calendar} provided.\n             * @member {SchedulerPro.model.CalendarModel} effectiveCalendar\n             */\n            /**\n             * Set this to true if this task should be shown in the Timeline widget\n             * @field {Boolean} showInTimeline\n             * @category Common\n             */\n            { name : 'showInTimeline', type : 'boolean', defaultValue : false },\n            /**\n             * Note about the event\n             * @field {String} note\n             * @category Common\n             */\n            'note',\n            /**\n             * Buffer time before event start. Specified in a human-friendly form as accepted by\n             * {@link Core.helper.DateHelper#function-parseDuration-static}:\n             * ```javascript\n             * // Create event model with a 30 minutes buffer time before the event start\n             * new EventModel({ startDate : '2020-01-01', endDate : '2020-01-02', preamble : '30 minutes' })\n             * ```\n             *\n             * Used by the {@link SchedulerPro.feature.EventBuffer} feature.\n             *\n             * @field {Core.data.Duration} preamble\n             * @accepts {String}\n             * @category Scheduling\n             */\n            {\n                name    : 'preamble',\n                convert : value => value ? new Duration(value) : null\n            },\n            /**\n             * Buffer time after event end. Specified in a human-friendly form as accepted by\n             * {@link Core.helper.DateHelper#function-parseDuration-static}:\n             * ```javascript\n             * // Create event model with a 1 hour buffer time after the event end\n             * new EventModel({ startDate : '2020-01-01', endDate : '2020-01-02', postamble : '1 hour' })\n             * ```\n             *\n             * Used by the {@link SchedulerPro.feature.EventBuffer} feature.\n             *\n             * @field {String} postamble\n             * @accepts {String}\n             * @category Scheduling\n             */\n            {\n                name    : 'postamble',\n                convert : value => value ? new Duration(value) : null\n            }\n        ];\n    }\n    getDefaultSegmentModelClass() {\n        return EventSegmentModel;\n    }\n    //endregion\n    //region EventBuffer\n    updateWrapDate(date, duration, forward = true) {\n        duration = new Duration(duration);\n        return new Date(date.getTime() + (forward ? 1 : -1) * duration.milliseconds);\n    }\n    get startDate() {\n        let dt;\n        if (this.isOccurrence) {\n            dt = this.get('startDate');\n        }\n        else {\n            // Micro optimization to avoid expensive super call. super will be hit in Scheduler Pro\n            dt = this._startDate ?? super.startDate;\n        }\n        if (this.allDay) {\n            dt = this.constructor.getAllDayStartDate(dt);\n        }\n        return dt;\n    }\n    set startDate(startDate) {\n        const me = this;\n        // Update children when parents startDate changes (ignoring initial data set)\n        if (me.generation && me.isParent && !me.$ignoreChange) {\n            const timeDiff = DateHelper.diff(me.startDate, startDate);\n            if (timeDiff) {\n                // Move all children same amount\n                for (const child of this.children) {\n                    child.startDate = DateHelper.add(child.startDate, timeDiff);\n                }\n            }\n        }\n        if (me.batching) {\n            me._startDate = startDate;\n            me.set({ startDate });\n        }\n        else {\n            super.startDate = startDate;\n            if (me.preamble) {\n                me.wrapStartDate = null;\n                me.wrapEndDate = null;\n            }\n        }\n    }\n    get endDate() {\n        let dt;\n        if (this.isOccurrence) {\n            dt = this.get('endDate');\n        }\n        else {\n            // Micro optimization to avoid expensive super call. super will be hit in Scheduler Pro\n            dt = this._endDate ?? super.endDate;\n        }\n        if (this.allDay) {\n            dt = this.constructor.getAllDayEndDate(dt);\n        }\n        return dt;\n    }\n    set endDate(endDate) {\n        const me = this;\n        if (me.batching) {\n            me._endDate = endDate;\n            me.set({ endDate });\n        }\n        else {\n            super.endDate = endDate;\n            if (me.postamble) {\n                me.wrapStartDate = null;\n                me.wrapEndDate = null;\n            }\n        }\n    }\n    /**\n     * Property which encapsulates the effort's magnitude and units.\n     *\n     * UI fields representing this property are disabled for summary events.\n     * See {@link #function-isEditable} for details.\n     *\n     * @property {Core.data.Duration}\n     */\n    get fullEffort() {\n        return new Duration({\n            unit      : this.effortUnit,\n            magnitude : this.effort\n        });\n    }\n    set fullEffort(effort) {\n        this.setEffort(effort.magnitude, effort.unit);\n    }\n    // Cannot use `convert` method because it might be disabled by `useRawData : true` and we always need to calculate\n    // that value\n    get wrapStartDate() {\n        const\n            me                      = this,\n            { preamble, startDate } = me,\n            wrapStartDate           = me._wrapStartDate;\n        let result;\n        if (wrapStartDate) {\n            result = wrapStartDate;\n        }\n        else {\n            if (preamble) {\n                result = me.updateWrapDate(startDate, preamble, false);\n                me._wrapStartDate = result;\n            }\n            else {\n                result = startDate;\n            }\n        }\n        return result;\n    }\n    set wrapStartDate(value) {\n        this._wrapStartDate = value;\n    }\n    get wrapEndDate() {\n        const\n            me                     = this,\n            { postamble, endDate } = me,\n            wrapEndDate            = me._wrapEndDate;\n        let result;\n        if (wrapEndDate) {\n            result = wrapEndDate;\n        }\n        else {\n            if (postamble) {\n                result = me.updateWrapDate(endDate, postamble, true);\n                me._wrapEndDate = result;\n            }\n            else {\n                result = endDate;\n            }\n        }\n        return result;\n    }\n    set wrapEndDate(value) {\n        this._wrapEndDate = value;\n    }\n    set(data) {\n        const isObject = typeof data === 'object';\n        if (data === 'preamble' || (isObject && 'preamble' in data)) {\n            this.wrapStartDate = null;\n        }\n        if (data === 'postamble' || (isObject && 'postamble' in data)) {\n            this.wrapEndDate = null;\n        }\n        return super.set(...arguments);\n    }\n    /**\n     * Returns event start date adjusted by {@link #field-preamble} (start date - duration).\n     * @property {Date}\n     * @readonly\n     */\n    get outerStartDate() {\n        return this.wrapStartDate;\n    }\n    /**\n     * Returns event end date adjusted by {@link #field-postamble} (end date + duration).\n     * @property {Date}\n     * @readonly\n     */\n    get outerEndDate() {\n        return this.wrapEndDate;\n    }\n    //endregion\n    /**\n     * Defines if the given event field should be manually editable in UI.\n     * You can override this method to provide your own logic.\n     *\n     * By default, the method defines:\n     * - {@link #field-earlyStartDate}, {@link #field-earlyEndDate} as not editable;\n     * - {@link #field-endDate}, {@link #field-duration} and {@link #field-fullDuration} fields\n     *   as not editable for summary events except the {@link #field-manuallyScheduled manually scheduled} ones;\n     * - {@link #field-percentDone} as not editable for summary events.\n     *\n     * @param {String} fieldName Name of the field\n     * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the event has\n     * no such field.\n     */\n    isEditable(fieldName) {\n        switch (fieldName) {\n            // r/o fields\n            case 'earlyStartDate':\n            case 'earlyEndDate':\n                return false;\n            // disable percentDone editing for summary tasks\n            case 'percentDone' :\n            case 'renderedPercentDone' :\n                return this.isLeaf;\n            // end/duration is allowed to edit for leafs and manually scheduled summaries\n            case 'endDate' :\n            case 'duration' :\n            case 'fullDuration' :\n                return this.isLeaf || this.manuallyScheduled;\n        }\n        return super.isEditable(fieldName);\n    }\n    // Occurrences are not part of the project, when requesting their stm we retrieve it from the master event instead\n    get stm() {\n        return this.recurringEvent?.stm ?? super.stm;\n    }\n    set stm(stm) {\n        super.stm = stm;\n    }\n    //region Early render\n    get assigned() {\n        const\n            { project }  = this,\n            assigned     = super.assigned;\n        // Figure assigned events out before buckets are created  (if part of project)\n        if (project?.isDelayingCalculation && !assigned) {\n            return project.assignmentStore.storage.findItem('event', this);\n        }\n        return assigned;\n    }\n    set assigned(assigned) {\n        super.assigned = assigned;\n    }\n    //endregion\n    getCurrentConfig(options) {\n        const\n            { segments } = this,\n            result       = super.getCurrentConfig(options);\n        // include segments\n        if (result && segments) {\n            result.segments = segments.map(segment => segment.getCurrentConfig(options));\n        }\n        return result;\n    }\n}\nEventModel._$name = 'EventModel';", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport GetEventsMixin from '../../Scheduler/data/mixin/GetEventsMixin.js';\nimport DayIndexMixin from '../../Scheduler/data/mixin/DayIndexMixin.js';\nimport EventStoreMixin from '../../Scheduler/data/mixin/EventStoreMixin.js';\nimport SharedEventStoreMixin from '../../Scheduler/data/mixin/SharedEventStoreMixin.js';\nimport RecurringEventsMixin from '../../Scheduler/data/mixin/RecurringEventsMixin.js';\nimport EventModel from '../model/EventModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport { ChronoEventStoreMixin } from '../../Engine/quark/store/ChronoEventStoreMixin.js';\n/**\n * @module SchedulerPro/data/EventStore\n */\n/**\n * A store holding all the {@link SchedulerPro.model.EventModel events} to be rendered into a {@link SchedulerPro.view.SchedulerPro Scheduler Pro}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.EventModel}.\n *\n * An EventStore is usually connected to a project, which binds it to other related stores (AssignmentStore,\n * ResourceStore and DependencyStore). The project also handles normalization/calculation of the data on the records in\n * the store. For example if a record is added with a `startDate` and an `endDate`, it will calculate the `duration`.\n *\n * The calculations happens async, records are not guaranteed to have up to date data until they are finished. To be\n * certain that calculations have finished, call `await project.commitAsync()` after store actions. Or use one of the\n * `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * eventStore.data = [{ startDate, endDate }, ...];\n *\n * // duration of the record is not yet calculated\n *\n * await eventStore.project.commitAsync();\n *\n * // now it is\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await eventStore.loadDataAsync([{ startDate, endDate }, ...]);\n *\n * // duration is calculated\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/SharedEventStoreMixin\n * @mixes Scheduler/data/mixin/GetEventsMixin\n * @mixes Scheduler/data/mixin/EventStoreMixin\n * @mixes Scheduler/data/mixin/RecurringEventsMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/EventStore -> Scheduler/data/SchedulerEventStore\n */\nexport default class EventStore extends PartOfProject(SharedEventStoreMixin(RecurringEventsMixin(GetEventsMixin(DayIndexMixin(EventStoreMixin(ChronoEventStoreMixin.derive(AjaxStore))))))) {\n    //region Config\n    static $name = 'EventStore';\n    static get defaultConfig() {\n        return {\n            modelClass : EventModel\n        };\n    }\n    //endregion\n}\nEventStore._$name = 'EventStore';", "import GridRowModel from '../../Grid/data/GridRowModel.js';\nimport ResourceModelMixin from '../../Scheduler/model/mixin/ResourceModelMixin.js';\nimport { SchedulerProResourceMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProResourceMixin.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n/**\n * @module SchedulerPro/model/ResourceModel\n */\n/**\n * This class represent a single Resource in Scheduler Pro, usually added to a {@link SchedulerPro.data.ResourceStore}.\n *\n * It is a subclass of  {@link Core.data.Model}. Please refer to the documentation for that class to become familiar\n * with the base interface of the resource.\n *\n * ## Fields and references\n *\n * A resource has a few predefined fields, see Fields below. If you want to add more fields with meta data describing\n * your resources then you should subclass this class:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *       // \"id\" and \"name\" fields are already provided by the superclass\n *       { name: 'company', type : 'string' }\n *     ];\n *   }\n * });\n * ```\n *\n * If you want to use other names in your data for the id and name fields you can configure them as seen below:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *        { name: 'name', dataSource: 'userName' }\n *     ];\n *   },\n * });\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `{@link #property-assignments}` - The linked assignment records\n * - `{@link #property-events}` - The linked (through assignments) event records\n *\n * ## Async resolving of references\n *\n * As described above, a resource has links to assignments and events. These references are populated async, using the\n * calculation engine of the project that the resource via its store is a part of. Because of this asyncness, references\n * cannot be used immediately after assignment modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // resource.assignments is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // resource.assignments is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // resource.assignments is up to date\n * ```\n *\n * @extends Grid/data/GridRowModel\n * @mixes Scheduler/model/mixin/ResourceModelMixin\n *\n * @typings Scheduler/model/ResourceModel -> Scheduler/model/SchedulerResourceModel\n */\nexport default class ResourceModel extends PartOfProject(ResourceModelMixin(SchedulerProResourceMixin.derive(GridRowModel))) {\n    //region Calendar\n    /**\n     * Sets the calendar of the task. Will cause the schedule to be updated - returns a `Promise`\n     *\n     * @method setCalendar\n     * @param {SchedulerPro.model.CalendarModel} calendar The new calendar. Provide `null` to use the project calendar.\n     * @async\n     * @propagating\n     */\n    /**\n     * Returns the resource calendar.\n     *\n     * @method getCalendar\n     * @returns {SchedulerPro.model.CalendarModel} The resource calendar.\n     */\n    /**\n     * The calendar, assigned to the entity. Allows you to set the time when entity can perform the work.\n     *\n     * @field {SchedulerPro.model.CalendarModel} calendar\n     * @accepts {SchedulerPro.model.CalendarModel|String}\n     * @category Scheduling\n     */\n    //endregion\n    //region Config\n    static get $name() {\n        return 'ResourceModel';\n    }\n    //endregion\n    /**\n     * Get associated events\n     *\n     * @member {SchedulerPro.model.EventModel[]} events\n     * @readonly\n     * @category Common\n     */\n    /**\n     * Returns all assignments for the resource\n     *\n     * @member {SchedulerPro.model.AssignmentModel[]} assignments\n     * @category Common\n     */\n    //region Early render\n    get assigned() {\n        const { project } = this;\n        // Figure assigned events out before buckets are created (if part of project)\n        if (project?.assignmentStore.storage._indices?.resource) {\n            return project.assignmentStore.storage.findItem('resource', this) ?? new Set();\n        }\n        return super.assigned;\n    }\n    set assigned(assigned) {\n        super.assigned = assigned;\n    }\n    //endregion\n}\nResourceModel._$name = 'ResourceModel';", "import AjaxStore from '../../Core/data/AjaxStore.js';\nimport ResourceStoreMixin from '../../Scheduler/data/mixin/ResourceStoreMixin.js';\nimport ResourceModel from '../model/ResourceModel.js';\nimport { ChronoResourceStoreMixin } from '../../Engine/quark/store/ChronoResourceStoreMixin.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n/**\n * @module SchedulerPro/data/ResourceStore\n */\n/**\n * A store holding all the {@link SchedulerPro.model.ResourceModel resources} to be rendered into a\n * {@link SchedulerPro.view.SchedulerPro Scheduler Pro}.\n *\n * This store only accepts a model class inheriting from {@link SchedulerPro.model.ResourceModel}.\n *\n * A ResourceStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and DependencyStore). The project also handles references (assignments, events) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * resourceStore.data = [{ id }, ...];\n *\n * // references (assignments, events) not resolved yet\n *\n * await resourceStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await resourceStore.loadDataAsync([{ id }, ...]);\n *\n * // references (assignments, events) are resolved\n * ```\n *\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/ResourceStoreMixin\n * @extends Core/data/AjaxStore\n *\n * @typings Scheduler/data/ResourceStore -> Scheduler/data/SchedulerResourceStore\n */\nexport default class ResourceStore extends PartOfProject(ResourceStoreMixin(ChronoResourceStoreMixin.derive(AjaxStore))) {\n    static get defaultConfig() {\n        return {\n            modelClass : ResourceModel\n        };\n    }\n}\nResourceStore._$name = 'ResourceStore';", "import SchedulerProjectCrudManager from '../../../Scheduler/data/mixin/ProjectCrudManager.js';\nimport Base from '../../../Core/Base.js';\n/**\n * @module SchedulerPro/data/mixin/ProjectCrudManager\n */\n// the order of the @mixes tags is important below, as the \"AbstractCrudManagerMixin\"\n// contains the abstract methods, which are then overwritten by the concrete\n// implementation in the AjaxTransport and JsonEncoder\n/**\n * This mixin provides Crud manager functionality to a Scheduler Pro project.\n * The mixin turns the provided project model into a Crud manager instance.\n *\n * @mixin\n * @mixes Scheduler/data/mixin/ProjectCrudManager\n * @typings Scheduler/data/mixin/ProjectCrudManager -> Scheduler/data/mixin/SchedulerProjectCrudManager\n */\nexport default Target => class ProjectCrudManager extends (Target || Base).mixin(SchedulerProjectCrudManager) {\n    static get configurable() {\n        return {\n            crudLoadValidationWarningPrefix : 'Project load response error(s):',\n            crudSyncValidationWarningPrefix : 'Project sync response error(s):',\n            /**\n             * If `true`, project {@link #property-changes} API will also report project model changes: start/end date,\n             * calendar, effort, duration, etc.\n             * @prp {Boolean}\n             * @default\n             */\n            trackProjectModelChanges : false\n        };\n    }\n    construct(...args) {\n        const me = this;\n        super.construct(...args);\n        // add the Engine specific stores to the crud manager\n        me.addPrioritizedStore(me.calendarManagerStore);\n        me.addPrioritizedStore(me.assignmentStore);\n        me.addPrioritizedStore(me.dependencyStore);\n        me.addPrioritizedStore(me.resourceStore);\n        me.addPrioritizedStore(me.eventStore);\n        if (me.timeRangeStore) {\n            me.addPrioritizedStore(me.timeRangeStore);\n        }\n        if (me.resourceTimeRangeStore) {\n            me.addPrioritizedStore(me.resourceTimeRangeStore);\n        }\n    }\n    get project() {\n        return this;\n    }\n    set project(value) {\n        super.project = value;\n    }\n    get crudLoadValidationMandatoryStores() {\n        return [this.getStoreDescriptor(this.eventStore).storeId];\n    }\n    loadCrudManagerData(...args) {\n        if (this.delayCalculation && !this.isDelayingCalculation && !this.usingSyncDataOnLoad()) {\n            this.scheduleDelayedCalculation();\n        }\n        super.loadCrudManagerData(...args);\n    }\n    acceptChanges() {\n        super.acceptChanges();\n        // clear project model own field changes\n        this.clearChanges(true, false);\n    }\n    revertChanges() {\n        // revertChanges method exists both on the Model and AbstractCrudManagerMixin class\n        // so here we have to couple both of them\n        // first invoke Crud Manager logic\n        this.revertCrudStoreChanges();\n        // then invoke Model logic - revert project model own field changes\n        this.set(this.meta.modified, undefined, true);\n    }\n    // Override to take into account project model own field changes\n    crudStoreHasChanges(storeId) {\n        const store = this.getCrudStore(storeId);\n        let result;\n        if (store) {\n            result = super.crudStoreHasChanges(store);\n        }\n        else {\n            result = this.hasPersistableChanges || super.crudStoreHasChanges();\n        }\n        return result;\n    }\n    /**\n     * Returns current changes as an object consisting of added/modified/removed arrays of records for every\n     * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:\n     *\n     * ```javascript\n     * {\n     *     resources : {\n     *         added    : [{ name : 'New guy' }],\n     *         modified : [{ id : 2, name : 'Mike' }],\n     *         removed  : [{ id : 3 }]\n     *     },\n     *     events : {\n     *         modified : [{  id : 12, name : 'Cool task' }]\n     *     },\n     *     ...\n     * }\n     * ```\n     *\n     * To also include changes of the project model itself set {@link #property-trackProjectModelChanges} to `true`:\n     *\n     * ```javascript\n     * {\n     *     project : {\n     *         calendar  : 'custom',\n     *         startDate : '2020-02-02',\n     *         endDate   : '2020-02-10\n     *     },\n     *     resources : {...},\n     *     events    : {...}\n     * }\n     * ```\n     *\n     * @property {Object}\n     * @readonly\n     * @category CRUD\n     */\n    get changes() {\n        let changes = super.changes;\n        if (this.trackProjectModelChanges) {\n            const projectChanges = this.modificationDataToWrite;\n            // include project changes\n            if (projectChanges) {\n                changes = changes || {};\n                changes.project = projectChanges;\n            }\n        }\n        return changes;\n    }\n    shouldClearRecordFieldChange(record, field, value) {\n        // If that's a calendar model \"intervals\" field\n        // we just check if the underlying store is actually dirty.\n        if (record.isCalendarModel && field === 'intervals') {\n            return !record.get('intervals').changes;\n        }\n        return super.shouldClearRecordFieldChange(...arguments);\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module SchedulerPro/model/mixin/ProjectChangeHandlerMixin\n */\n// Check if assigning a raw value will make the field change\nconst willChange = (fieldName, rawData, record) => {\n    const\n        field          = record.getFieldDefinition(fieldName),\n        { dataSource } = field,\n        newValue       = record.constructor.processField(fieldName, rawData[dataSource], record);\n    return dataSource in rawData && !field.isEqual(newValue, record[fieldName]);\n};\n/**\n * This mixin allows syncing a changes object between projects. See {@link #function-applyProjectChanges} for usage\n * @mixin\n */\nexport default Target => class ProjectChangeHandlerMixin extends (Target || Base) {\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n        super.startConfigure(config);\n    }\n    beforeApplyProjectChanges() {\n        const { stm } = this;\n        let shouldResume = false;\n        this.suspendChangesTracking();\n        if (stm.enabled) {\n            shouldResume = true;\n            if (stm.isRecording) {\n                stm.stash();\n            }\n            if (this.ignoreRemoteChangesInSTM) {\n                stm.disable();\n            }\n            else {\n                stm.startTransaction();\n            }\n        }\n        return shouldResume;\n    }\n    /**\n     * Allows to apply changes from one project to another. For method to produce correct results, projects should be\n     * isomorphic - they should use same models and store configuration, also data in source and target projects\n     * should be identical before changes to the source project are made and applied to the target project.\n     * This method is meant to apply changes in real time - as source project is changed, changes should be applied to\n     * the target project before it is changed.\n     * When changes are applied all changes are committed and project is recalculated, which means target project\n     * won't have any local changes after.\n     *\n     * Usage:\n     * ```javascript\n     * // Collect changes from first project\n     * const { changes } = projectA;\n     *\n     * // Apply changes to second project\n     * await projectB.applyProjectChanges(changes);\n     * ```\n     *\n     * <div class=\"note\">\n     * This method will apply changes from the incoming object and accept all current project changes. Before\n     * applying changes make sure you've processed current project changes in order not to lose them.\n     * </div>\n     *\n     * @param {Object} changes Project {@link Scheduler/crud/AbstractCrudManagerMixin#property-changes} object\n     * @returns {Promise}\n     */\n    async applyProjectChanges(changes) {\n        const\n            me           = this,\n            shouldResume = me.beforeApplyProjectChanges();\n        // Raise a flag to let store know not to stash stm changes\n        me.applyingChangeset = true;\n        if (changes.project) {\n            me.applyProjectResponse(changes.project);\n        }\n        // Apply changes from other project, except for dates that will lead to changed constraints (engine is not aware\n        // that we want to keep the constraint)\n        // Has to clone to be able to catch the change and clean it up after commit\n        me.applyChangeset(ObjectHelper.clone(changes), (storeChanges, store) => {\n            if ((store.id === 'tasks' || store.id === 'events')) {\n                const\n                    { modelClass } = store,\n                    startDate      = modelClass.getFieldDataSource('startDate'),\n                    endDate        = modelClass.getFieldDataSource('endDate');\n                if (storeChanges.updated) {\n                    for (const data of storeChanges.updated) {\n                        const record = store.getById(data[modelClass.idField]);\n                        if (!(\n                            willChange('constraintType', data, record) ||\n                            willChange('constraintDate', data, record)\n                        )) {\n                            delete data[startDate];\n                            delete data[endDate];\n                        }\n                    }\n                }\n            }\n        });\n        await me.commitAsync();\n        // This will clean up changes in the project model if they match incoming values\n        me.commitRespondedChanges();\n        // The call to applyChangeset() clears changes (it might, but not always), but commitAsync() leads to new\n        // changes. If those changes match what we requested, we flag them as not modified\n        for (const storeId in changes) {\n            const storeDescriptor = me.getStoreDescriptor(storeId);\n            // if that a Store section\n            if (storeDescriptor) {\n                const\n                    // Due to this issue better to use lookup on the project instance rather than in global registry\n                    // https://github.com/bryntum/support/issues/5238\n                    { store }    = storeDescriptor,\n                    storeChanges = changes[storeId],\n                    changedRows  = [...storeChanges.updated ?? [], ...storeChanges.added ?? []];\n                // Store might be destroyed, asyncness...\n                if (store) {\n                    // Iterate updated and added rows\n                    for (const data of changedRows) {\n                        const record = store.getById(data[store.modelClass.idField]);\n                        // Record might not have been added e.g. if change was conflicting and got resolved by rejecting\n                        if (record) {\n                            // Compare each change on the matching record with the raw data value, unflag change if they match\n                            for (const fieldName in record.modifications) {\n                                if (!willChange(fieldName, data, record)) {\n                                    delete record.meta.modified[fieldName];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        me.afterApplyProjectChanges(shouldResume);\n        me.applyingChangeset = false;\n        // Trigger commit async in case non-project related field (e.g. name) was changed to update possibly\n        // opened task editor\n        await me.commitAsync();\n    }\n    afterApplyProjectChanges(shouldResume) {\n        if (shouldResume) {\n            const { stm } = this;\n            if (this.ignoreRemoteChangesInSTM) {\n                stm.enable();\n            }\n            else {\n                stm.stopTransaction();\n            }\n            stm.applyStash();\n        }\n        this.resumeChangesTracking();\n    }\n};\n", "/**\n * @module SchedulerPro/data/stm/action/EventUpdateAction\n */\nimport UpdateAction from '../../../../Core/data/stm/action/UpdateAction.js';\n/**\n * Action to record the fact that an event model has been updated.\n * @extends Core/data/stm/action/UpdateAction\n */\nexport default class EventUpdateAction extends UpdateAction {\n    get type() {\n        return 'EventUpdateAction';\n    }\n    construct(config) {\n        let {\n            model,\n            newData,\n            oldData\n        } = config;\n        // If we have \"segments\" represented in both old & new data states\n        if (newData.segments && oldData.segments) {\n            oldData = { ...oldData };\n            newData = { ...newData };\n            const\n                oldDataSegments = oldData.segments.slice(),\n                newDataSegments = newData.segments.slice();\n            let hasChanges = false;\n            // If a segment instance exists in both states\n            // we need to find segments existing in both versions.\n            // They should not be changed when undo/redo the main event\n            // since their model changes are recorded by STM.\n            oldData.segments.forEach((segment, index) => {\n                const newDataIndex = newData.segments.indexOf(segment);\n                // If a segment instance exists in both states\n                // we uses it as-is ..since STM is supposed to handle the instance changes\n                if (newDataIndex > -1) {\n                    oldDataSegments[index] = newDataSegments[newDataIndex] = segment;\n                    hasChanges = true;\n                }\n            });\n            if (hasChanges) {\n                oldData.segments = oldDataSegments;\n                newData.segments = newDataSegments;\n            }\n        }\n        return super.construct({\n            model,\n            newData,\n            oldData\n        });\n    }\n}\nEventUpdateAction._$name = 'EventUpdateAction';", "/**\n * @module SchedulerPro/data/stm/StateTrackingManager\n */\nimport EventUpdateAction from './action/EventUpdateAction.js';\nimport CoreStateTrackingManager from '../../../Core/data/stm/StateTrackingManager.js';\nimport UpdateAction from '../../../Core/data/stm/action/UpdateAction.js';\nexport const makeModelUpdateAction = (model, newData, oldData) => {\n    // if that's a SplitEventMixin instance\n    if (model.isSplitEventMixin) {\n        return new EventUpdateAction({\n            model,\n            newData,\n            oldData\n        });\n    }\n    return new UpdateAction({\n        model,\n        newData,\n        oldData\n    });\n};\n/**\n * {@link Core/data/stm/StateTrackingManager} subclass that's aware of the Scheduler Pro data structure specifics,\n * namely supports tracking of event segment changes.\n *\n * There is normally no need to deal with this class manually since it's instantiated automatically by the project\n * and can be reached like this:\n * ```javascript\n * project.stm\n * ```\n *\n * ## Tracking store changes\n *\n * Tracks the state of every store registered via {@link #function-addStore}. It is {@link #config-disabled} by default\n * so remember to call {@link #function-enable} when your stores are registered and initial dataset is loaded.\n * Use {@link #function-undo} / {@link #function-redo} method calls to restore state to a particular\n * point in time\n *\n * ```javascript\n * stm = new StateTrackingManager({\n *     autoRecord : true,\n *     listeners  : {\n *        'recordingstop' : () => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        },\n *        'restoringstop' : ({ stm }) => {\n *            // your custom code to update undo/redo GUI controls\n *            updateUndoRedoControls();\n *        }\n *    },\n *    getTransactionTitle : (transaction) => {\n *        // your custom code to analyze the transaction and return custom transaction title\n *        const lastAction = transaction.queue[transaction.queue.length - 1];\n *\n *        if (lastAction instanceof AddAction) {\n *            let title = 'Add new record';\n *        }\n *\n *        return title;\n *    }\n * });\n *\n * stm.addStore(userStore);\n * stm.addStore(companyStore);\n * stm.addStore(otherStore);\n *\n * stm.enable();\n * ```\n *\n * ## Resetting the queue on data loading\n *\n * When loading data from the server it makes perfect sense to {@link #function-resetQueue reset the queue}.\n *\n * If project (CrudManager protocol) is used for data loading it can be done like this:\n *\n * ```javascript\n * project.on({\n *     load() {\n *         project.stm.resetQueue();\n *     }\n * });\n * ```\n *\n * and in case individual stores are used:\n *\n * ```javascript\n * ajaxStore.on({\n *     load() {\n *         ajaxStore.stm.resetQueue();\n *     }\n * });\n * ```\n *\n * @extends Core/data/stm/StateTrackingManager\n * @typings Core/data/stm/StateTrackingManager -> Core/data/stm/CoreStateTrackingManager\n */\nexport default class StateTrackingManager extends CoreStateTrackingManager {\n    static get defaultConfig() {\n        return {\n            makeModelUpdateAction\n        };\n    }\n}\nStateTrackingManager._$name = 'StateTrackingManager';", "import { SchedulerProProjectMixin } from '../../Engine/quark/model/scheduler_pro/SchedulerProProjectMixin.js';\nimport ProjectModelMixin from '../../Scheduler/model/mixin/ProjectModelMixin.js';\nimport ProjectChangeHandlerMixin from './mixin/ProjectChangeHandlerMixin.js';\nimport ProjectCrudManager from '../data/mixin/ProjectCrudManager.js';\nimport AssignmentModel from './AssignmentModel.js';\nimport CalendarModel from './CalendarModel.js';\nimport DependencyModel from './DependencyModel.js';\nimport EventModel from './EventModel.js';\nimport ResourceModel from './ResourceModel.js';\nimport CalendarManagerStore from '../data/CalendarManagerStore.js';\nimport DependencyStore from '../data/DependencyStore.js';\nimport EventStore from '../data/EventStore.js';\nimport ResourceStore from '../data/ResourceStore.js';\nimport AssignmentStore from '../data/AssignmentStore.js';\nimport StateTrackingManager from '../data/stm/StateTrackingManager.js';\n/**\n * @module SchedulerPro/model/ProjectModel\n */\n/**\n * Scheduler Pro Project model class - a central place for all data.\n *\n * It holds and links the stores usually used by Scheduler Pro:\n *\n * - {@link SchedulerPro/data/EventStore}\n * - {@link SchedulerPro/data/ResourceStore}\n * - {@link SchedulerPro/data/AssignmentStore}\n * - {@link SchedulerPro/data/DependencyStore}\n * - {@link SchedulerPro/data/CalendarManagerStore}\n * - {@link Scheduler/data/ResourceTimeRangeStore}\n * - {@link #config-timeRangeStore TimeRangeStore}\n *\n * The project uses a scheduling engine to calculate dates, durations and such. It is also responsible for\n * handling references between models, for example to link an event via an assignment to a resource. These operations\n * are asynchronous, a fact that is hidden when working in the Scheduler Pro UI but which you must know about when\n * performing operations on the data level.\n *\n * When there is a change to data that requires something else to be recalculated, the project schedules a calculation\n * (a commit) which happens moments later. It is also possible to trigger these calculations directly. This flow\n * illustrates the process:\n *\n * 1. Something changes which requires the project to recalculate, for example adding a new task:\n *\n * ```javascript\n * const [event] = project.eventStore.add({ startDate, endDate });\n * ```\n *\n * 2. A recalculation is scheduled, thus:\n *\n * ```javascript\n * event.duration; // <- Not yet calculated\n * ```\n *\n * 3. Calculate now instead of waiting for the scheduled calculation\n *\n * ```javascript\n * await project.commitAsync();\n *\n * event.duration; // <- Now available\n * ```\n *\n * Please refer to [this guide](#SchedulerPro/guides/basics/project_data.md) for more information.\n *\n * ## Built in CrudManager\n *\n * Scheduler Pro's project has a {@link Scheduler/crud/AbstractCrudManagerMixin CrudManager} built in. Using it is the recommended\n * way of syncing data between Scheduler Pro and a backend. Example usage:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     project : {\n *         // Configure urls used by the built in CrudManager\n *         transport : {\n *             load : {\n *                 url : 'php/load.php'\n *             },\n *             sync : {\n *                 url : 'php/sync.php'\n *             }\n *         }\n *     }\n * });\n *\n * // Load data from the backend\n * scheduler.project.load()\n * ```\n *\n * For more information on CrudManager, see Schedulers docs on {@link Scheduler/data/CrudManager}.\n * For a detailed description of the protocol used by CrudManager, see the [Crud manager guide](#Scheduler/guides/data/crud_manager.md)\n *\n * You can access the current Project data changes anytime using the {@link #property-changes} property.\n *\n * ## Working with inline data\n *\n * The project provides an {@link #property-inlineData} getter/setter that can\n * be used to manage data from all Project stores at once. Populating the stores this way can\n * be useful if you do not want to use the CrudManager for server communication but instead load data using Axios\n * or similar.\n *\n * ### Getting data\n * ```javascript\n * const data = scheduler.project.inlineData;\n *\n * // use the data in your application\n * ```\n *\n * ### Setting data\n * ```javascript\n * // Get data from server manually\n * const data = await axios.get('/project?id=12345');\n *\n * // Feed it to the project\n * scheduler.project.inlineData = data;\n * ```\n *\n * See also {@link #function-loadInlineData}\n *\n * ### Getting changed records\n *\n * You can access the changes in the current Project dataset anytime using the {@link #property-changes} property. It\n * returns an object with all changes:\n *\n * ```javascript\n * const changes = project.changes;\n *\n * console.log(changes);\n *\n * > {\n *   tasks : {\n *       updated : [{\n *           name : 'My task',\n *           id   : 12\n *       }]\n *   },\n *   assignments : {\n *       added : [{\n *           event      : 12,\n *           resource   : 7,\n *           units      : 100,\n *           $PhantomId : 'abc123'\n *       }]\n *     }\n * };\n * ```\n *\n * ## Monitoring data changes\n *\n * While it is possible to listen for data changes on the projects individual stores, it is sometimes more convenient\n * to have a centralized place to handle all data changes. By listening for the {@link #event-change change event} your\n * code gets notified when data in any of the stores changes. Useful for example to keep an external data model up to\n * date:\n *\n * ```javascript\n * const scheduler = new SchedulerPro({\n *     project: {\n *         listeners : {\n *             change({ store, action, records }) {\n *                 const { $name } = store.constructor;\n *\n *                 if (action === 'add') {\n *                     externalDataModel.add($name, records);\n *                 }\n *\n *                 if (action === 'remove') {\n *                     externalDataModel.remove($name, records);\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Processing the data loaded from the server\n *\n * If you want to process the data received from the server after loading, you can use\n * the {@link #event-beforeLoadApply} or {@link #event-beforeSyncApply} events:\n *\n * ```javascript\n * const gantt = new Gantt({\n *     project: {\n *         listeners : {\n *             beforeLoadApply({ response }) {\n *                 // do something with load-response object before data is fed to the stores\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Built in StateTrackingManager\n *\n * The project also has a built in {@link Core/data/stm/StateTrackingManager} (STM for short), that\n * handles undo/redo for the project stores (additional stores can also be added). By default, it is only used while\n * editing tasks using the task editor, the editor updates tasks live and uses STM to rollback changes if canceled. But\n * you can enable it to track all project store changes:\n *\n * ```javascript\n * // Enable automatic transaction creation and start recording\n * project.stm.autoRecord = true;\n * project.stm.enable();\n *\n * // Undo a transaction\n * project.stm.undo();\n *\n * // Redo\n * project.stm.redo();\n * ```\n *\n * Check out the `undoredo` demo to see it in action.\n *\n * @mixes Core/mixin/Events\n * @mixes SchedulerPro/data/mixin/PartOfProject\n * @mixes SchedulerPro/data/mixin/ProjectCrudManager\n * @mixes SchedulerPro/model/mixin/ProjectChangeHandlerMixin\n *\n * @extends Scheduler/model/mixin/ProjectModelMixin\n *\n * @typings Scheduler/model/ProjectModel -> Scheduler/model/SchedulerProjectModel\n */\nexport default class ProjectModel extends ProjectChangeHandlerMixin(ProjectCrudManager(ProjectModelMixin(SchedulerProProjectMixin))) {\n    //region Events\n    /**\n     * Fired when the engine has finished its calculations and the results has been written back to the records.\n     *\n     * ```javascript\n     * scheduler.project.on({\n     *     dataReady() {\n     *        console.log('Calculations finished');\n     *     }\n     * });\n     *\n     * scheduler.eventStore.first.duration = 10;\n     *\n     * // At some point a bit later it will log 'Calculations finished'\n     * ```\n     *\n     * @event dataReady\n     * @param {SchedulerPro.model.ProjectModel} source The project\n     */\n    /**\n     * Fired during the Engine calculation if {@link #config-enableProgressNotifications enableProgressNotifications} config is `true`\n     * @event progress\n     * @param {Number} total The total number of operations\n     * @param {Number} remaining The number of remaining operations\n     * @param {'storePopulation'|'propagating'} phase The phase of the calculation, either 'storePopulation'\n     * when data is getting loaded, or 'propagating' when data is getting calculated\n     */\n    /**\n     * Fired when the Engine detects a computation cycle.\n     * @event cycle\n     * @param {Object} schedulingIssue Scheduling error describing the case:\n     * @param {Function} schedulingIssue.getDescription Returns the cycle description\n     * @param {Object} schedulingIssue.cycle Object providing the cycle info\n     * @param {Function} schedulingIssue.getResolutions Returns possible resolutions\n     * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to\n     * proceed with the Engine calculations:\n     * ```js\n     * project.on('cycle', ({ continueWithResolutionResult }) => {\n     *     // cancel changes in case of a cycle\n     *     continueWithResolutionResult(EffectResolutionResult.Cancel);\n     * })\n     * ```\n     */\n    /**\n     * Fired when the Engine detects a scheduling conflict.\n     * @event schedulingConflict\n     * @param {Object} schedulingIssue The conflict details:\n     * @param {Function} schedulingIssue.getDescription Returns the conflict description\n     * @param {Object[]} schedulingIssue.intervals Array of conflicting intervals\n     * @param {Function} schedulingIssue.getResolutions Function to get possible resolutions\n     * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to\n     * proceed with the Engine calculations:\n     * ```js\n     * project.on('schedulingConflict', ({ schedulingIssue, continueWithResolutionResult }) => {\n     *     // apply the first resolution and continue\n     *     schedulingIssue.getResolutions()[0].resolve();\n     *     continueWithResolutionResult(EffectResolutionResult.Resume);\n     * })\n     * ```\n     */\n    /**\n     * Fired when the Engine detects a calendar misconfiguration when the calendar does\n     * not provide any working periods of time which makes the calendar usage impossible.\n     * @event emptyCalendar\n     * @param {Object} schedulingIssue Scheduling error describing the case:\n     * @param {Function} schedulingIssue.getDescription Returns the error description\n     * @param {Function} schedulingIssue.getCalendar Returns the calendar that must be fixed\n     * @param {Function} schedulingIssue.getResolutions Returns possible resolutions\n     * @param {Function} continueWithResolutionResult Function to call after a resolution is chosen to\n     * proceed with the Engine calculations:\n     * ```js\n     * project.on('emptyCalendar', ({ schedulingIssue, continueWithResolutionResult }) => {\n     *     // apply the first resolution and continue\n     *     schedulingIssue.getResolutions()[0].resolve();\n     *     continueWithResolutionResult(EffectResolutionResult.Resume);\n     * })\n     * ```\n     */\n    //endregion\n    //region Config\n    static get $name() {\n        return 'ProjectModel';\n    }\n    /**\n     * Silences propagations caused by the project loading.\n     *\n     * Applying the loaded data to the project occurs in two basic stages:\n     *\n     * 1. Data gets into the engine graph which triggers changes propagation\n     * 2. The changes caused by the propagation get written to related stores\n     *\n     * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes\n     * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.\n     *\n     * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.\n     * By default the system treats the data as consistent so this option is `true`.\n     *\n     * ```js\n     * new SchedulerPro{\n     *     project : {\n     *         // We want scheduling engine to recalculate the data properly\n     *         // so then we could save it back to the server\n     *         silenceInitialCommit : false,\n     *         ...\n     *     }\n     *     ...\n     * })\n     * ```\n     *\n     * @config {Boolean} silenceInitialCommit\n     * @default true\n     * @category Advanced\n     */\n    /**\n     * Maximum range the project calendars can iterate.\n     * The value is defined in milliseconds and by default equals `5 years` roughly.\n     * ```javascript\n     * new SchedulerPro({\n     *     project : {\n     *         // adjust calendar iteration limit to 10 years roughly:\n     *         // 10 years expressed in ms\n     *         maxCalendarRange : 10 * 365 * 24 * 3600000,\n     *         ...\n     *     }\n     * });\n     * ```\n     * @config {Number} maxCalendarRange\n     * @default 157680000000\n     * @category Advanced\n     */\n    /**\n     * When `true` the project manually scheduled tasks will adjust their proposed start/end dates\n     * to skip non working time.\n     *\n     * @field {Boolean} skipNonWorkingTimeWhenSchedulingManually\n     * @default false\n     */\n    /**\n     * When `true` the project's manually scheduled tasks adjust their duration by excluding the non-working time from it,\n     * according to the calendar. However, this may lead to inconsistencies, when moving an event which both starts\n     * and ends on the non-working time. For such cases you can disable this option.\n     *\n     * Default value is `true`\n     *\n     * IMPORTANT: Setting this option to `false` also forcefully sets the {@link #field-skipNonWorkingTimeWhenSchedulingManually} option\n     * to `false`.\n     * IMPORTANT: This option is going to be disabled by default from version 6.0.0.\n     *\n     * @field {Boolean} skipNonWorkingTimeInDurationWhenSchedulingManually\n     * @default true\n     */\n    /**\n     * This config manages DST correction in the scheduling engine. It only has effect when DST transition hour is\n     * working time. Usually DST transition occurs on Sunday, so with non working weekends the DST correction logic\n     * is not involved.\n     *\n     * If **true**, it will add/remove one hour when calculating end date. For example:\n     * Assume weekends are working and on Sunday, 2020-10-25 at 03:00 clocks are set back 1 hour. Assume there is an event:\n     *\n     * ```javascript\n     * {\n     *     startDate    : '2020-10-20',\n     *     duration     : 10 * 24 + 1,\n     *     durationUnit : 'hour'\n     * }\n     * ```\n     * It will end on 2020-10-30 01:00 (which is wrong) but duration will be reported correctly. Because of the DST\n     * transition the SchedulerPro project will add one more hour when calculating the end date.\n     *\n     * Also this may occur when day with DST transition is working but there are non-working intervals between that day\n     * and event end date.\n     *\n     * ```javascript\n     * {\n     *     calendar         : 1,\n     *     calendarsData    : [\n     *         {\n     *             id           : 1,\n     *             startDate    : '2020-10-26',\n     *             endDate      : '2020-10-27',\n     *             isWorking    : false\n     *         }\n     *     ],\n     *     eventsData       : [\n     *         {\n     *             id           : 1,\n     *             startDate    : '2020-10-20',\n     *             endDate      : '2020-10-30'\n     *         },\n     *         {\n     *             id           : 2,\n     *             startDate    : '2020-10-20',\n     *             duration     : 10 * 24 + 1,\n     *             durationUnit : 'hour'\n     *         }\n     *     ]\n     * }\n     * ```\n     *\n     * Event 1 duration will be incorrectly reported as 9 days * 24 hours, missing 1 extra hour added by DST transition.\n     * Event 2 end date will be calculated to 2020-10-30 01:00, adding one extra hour.\n     *\n     * If **false**, the SchedulerPro project will not add DST correction which fixes the quirk mentioned above.\n     * Event 1 duration will be correctly reported as 9 days * 24 hours + 1 hour. Event 2 end date will be calculated\n     * to 2020-10-30.\n     *\n     * Also, for those events days duration will be a floating point number due to extra (or missing) hour:\n     *\n     * ```javascript\n     * eventStore.getById(1).getDuration('day')  // 10.041666666666666\n     * eventStore.getById(1).getDuration('hour') // 241\n     * ```\n     *\n     * @config {Boolean} adjustDurationToDST\n     * @default false\n     */\n    /**\n     * The number of hours per day.\n     *\n     * **Please note:** the value **does not define** the amount of **working** time per day\n     * for that purpose one should use calendars.\n     *\n     * The value is used when converting the duration from one unit to another.\n     * So when user enters a duration of, for example, `5 days` the system understands that it\n     * actually means `120 hours` and schedules accordingly.\n     * @field {Number} hoursPerDay\n     * @default 24\n     */\n    /**\n     * The number of days per week.\n     *\n     * **Please note:** the value **does not define** the amount of **working** time per week\n     * for that purpose one should use calendars.\n     *\n     * The value is used when converting the duration from one unit to another.\n     * So when user enters a duration of, for example, `2 weeks` the system understands that it\n     * actually means `14 days` (which is then converted to {@link #field-hoursPerDay hours}) and\n     * schedules accordingly.\n     * @field {Number} daysPerWeek\n     * @default 7\n     */\n    /**\n     * The number of days per month.\n     *\n     * **Please note:** the value **does not define** the amount of **working** time per month\n     * for that purpose one should use calendars.\n     *\n     * The value is used when converting the duration from one unit to another.\n     * So when user enters a duration of, for example, `1 month` the system understands that it\n     * actually means `30 days` (which is then converted to {@link #field-hoursPerDay hours}) and\n     * schedules accordingly.\n     * @field {Number} daysPerMonth\n     * @default 30\n     */\n    /**\n     * The scheduling direction of the project events.\n     * Possible values are `Forward` and `Backward`. The `Forward` direction corresponds to the As-Soon-As-Possible scheduling (ASAP),\n     * `Backward` - to As-Late-As-Possible (ALAP).\n     * @field {'Forward'|'Backward'} direction\n     * @default 'Forward'\n     */\n    /**\n     * The source of the calendar for dependencies (the calendar used for taking dependencies lag into account).\n     * Possible values are:\n     *\n     * - `ToEvent` - successor calendar will be used (default);\n     * - `FromEvent` - predecessor calendar will be used;\n     * - `Project` - the project calendar will be used.\n     *\n     * @field {'ToEvent'|'FromEvent'|'Project'} dependenciesCalendar\n     * @default 'ToEvent'\n     */\n    /**\n     * The project calendar.\n     * @field {SchedulerPro.model.CalendarModel} calendar\n     * @accepts {String|CalendarModelConfig|SchedulerPro.model.CalendarModel}\n     */\n    /**\n     * Returns current Project changes as an object consisting of added/modified/removed arrays of records for every\n     * managed store. Returns `null` if no changes exist. Format:\n     *\n     * ```javascript\n     * {\n     *     resources : {\n     *         added    : [{ name : 'New guy' }],\n     *         modified : [{ id : 2, name : 'Mike' }],\n     *         removed  : [{ id : 3 }]\n     *     },\n     *     events : {\n     *         modified : [{  id : 12, name : 'Cool task' }]\n     *     },\n     *     ...\n     * }\n     * ```\n     *\n     * @member {Object} changes\n     * @readonly\n     * @category Models & Stores\n     */\n    /**\n     * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the\n     * underlying graph based calculation engine. The engine performs it calculations async.\n     *\n     * By calling this function, the commit happens right away. And by awaiting it you are sure that project\n     * calculations are finished and that references between records are up to date.\n     *\n     * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.\n     *\n     * ```javascript\n     * // Move an event in time\n     * eventStore.first.shift(1);\n     *\n     * // Trigger calculations directly and wait for them to finish\n     * const result = await project.commitAsync();\n     *\n     * if (result.rejectedWith) {\n     *     // there was a conflict during the scheduling\n     * }\n     * ```\n     *\n     * @async\n     * @function commitAsync\n     * @category Common\n     */\n    /**\n     * Set to `true` to enable calculation progress notifications.\n     * When enabled the project fires {@link #event-progress progress} event.\n     *\n     * **Note**: Enabling progress notifications will impact calculation performance, since it needs to pause calculations to allow redrawing the UI.\n     * @config {Boolean} enableProgressNotifications\n     * @category Advanced\n     */\n    /**\n     * Enables/disables the calculation progress notifications.\n     * @member {Boolean} enableProgressNotifications\n     * @category Advanced\n     */\n    /**\n     * If this flag is set to `true` (default) when a start/end date is set on the event, a corresponding\n     * `start-no-earlier/later-than` constraint is added, automatically. This is done in order to\n     * keep the event \"attached\" to this date, according to the user intention.\n     *\n     * Depending on your use case, you might want to disable this behaviour.\n     *\n     * @field {Boolean} addConstraintOnDateSet\n     * @default true\n     */\n    static get defaultConfig() {\n        return {\n            /**\n             * @hideproperties project, taskStore\n             */\n            //region Inline data configs & properties\n            /**\n             * Get/set {@link #property-eventStore} data.\n             *\n             * Always returns an array of {@link SchedulerPro.model.EventModel EventModels} but also accepts an array of\n             * its configuration objects as input.\n             *\n             * @member {SchedulerPro.model.EventModel[]} events\n             * @accepts {SchedulerPro.model.EventModel[]|EventModelConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-eventStore}. Should be an array of\n             * {@link SchedulerPro.model.EventModel EventModels} or its configuration objects.\n             *\n             * @config {SchedulerPro.model.EventModel[]|EventModelConfig[]} events\n             * @category Inline data\n             */\n            /**\n             * Get/set {@link #property-resourceStore} data.\n             *\n             * Always returns an array of {@link SchedulerPro.model.ResourceModel ResourceModels} but also accepts an\n             * array of its configuration objects as input.\n             *\n             * @member {SchedulerPro.model.ResourceModel[]} resources\n             * @accepts {SchedulerPro.model.ResourceModel[]|ResourceModelConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-resourceStore}. Should be an array of\n             * {@link SchedulerPro.model.ResourceModel ResourceModels} or its configuration objects.\n             *\n             * @config {SchedulerPro.model.ResourceModel[]|ResourceModelConfig[]} resources\n             * @category Inline data\n             */\n            /**\n             * Get/set {@link #property-assignmentStore} data.\n             *\n             * Always returns an array of {@link SchedulerPro.model.AssignmentModel AssignmentModels} but also accepts\n             * an array of its configuration objects as input.\n             *\n             * @member {SchedulerPro.model.AssignmentModel[]} assignments\n             * @accepts {SchedulerPro.model.AssignmentModel[]|AssignmentModelConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-assignmentStore}. Should be an array of\n             * {@link SchedulerPro.model.AssignmentModel AssignmentModels} or its configuration objects.\n             *\n             * @config {SchedulerPro.model.AssignmentModel[]|AssignmentModelConfig[]} assignments\n             * @category Inline data\n             */\n            /**\n             * Get/set {@link #property-dependencyStore} data.\n             *\n             * Always returns an array of {@link SchedulerPro.model.DependencyModel DependencyModels} but also accepts an\n             * array of its configuration objects as input.\n             *\n             * @member {SchedulerPro.model.DependencyModel[]} dependencies\n             * @accepts {SchedulerPro.model.DependencyModel[]|DependencyModelConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-dependencyStore}. Should be an array of\n             * {@link SchedulerPro.model.DependencyModel DependencyModels} or its configuration objects.\n             *\n             * @config {SchedulerPro.model.DependencyModel[]|DependencyModelConfig[]} dependencies\n             * @category Inline data\n             */\n            /**\n             * Get/set {@link #property-timeRangeStore} data.\n             *\n             * Always returns an array of {@link Scheduler.model.TimeSpan TimeSpans} but also accepts an\n             * array of its configuration objects as input.\n             *\n             * @member {Scheduler.model.TimeSpan[]} timeRanges\n             * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-timeRangeStore}. Should be an array of\n             * {@link Scheduler.model.TimeSpan TimeSpans} or its configuration objects.\n             *\n             * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n             * @category Inline data\n             */\n            /**\n             * Get/set {@link #property-resourceTimeRangeStore} data.\n             *\n             * Always returns an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} but\n             * also accepts an array of its configuration objects as input.\n             *\n             * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n             * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-resourceTimeRangeStore}. Should be an array\n             * of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} or its configuration objects.\n             *\n             * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges\n             * @category Inline data\n             */\n            //endregion\n            //region Legacy inline data configs & properties\n            /**\n             * The initial data, to fill the {@link #property-eventStore eventStore} with.\n             * Should be an array of {@link SchedulerPro.model.EventModel EventModels} or its configuration objects.\n             *\n             * @config {SchedulerPro.model.EventModel[]} eventsData\n             * @category Legacy inline data\n             */\n            /**\n             * The initial data, to fill the {@link #property-dependencyStore dependencyStore} with.\n             * Should be an array of {@link SchedulerPro.model.DependencyModel DependencyModels} or its configuration\n             * objects.\n             *\n             * @config {SchedulerPro.model.DependencyModel[]} [dependenciesData]\n             * @category Legacy inline data\n             */\n            /**\n             * The initial data, to fill the {@link #property-resourceStore resourceStore} with.\n             * Should be an array of {@link SchedulerPro.model.ResourceModel ResourceModels} or its configuration objects.\n             *\n             * @config {SchedulerPro.model.ResourceModel[]} [resourcesData]\n             * @category Legacy inline data\n             */\n            /**\n             * The initial data, to fill the {@link #property-assignmentStore assignmentStore} with.\n             * Should be an array of {@link SchedulerPro.model.AssignmentModel AssignmentModels} or its configuration\n             * objects.\n             *\n             * @config {SchedulerPro.model.AssignmentModel[]} [assignmentsData]\n             * @category Legacy inline data\n             */\n            //endregion\n            //region Store configs and properties\n            /**\n             * The {@link SchedulerPro.data.EventStore store} holding the event information.\n             *\n             * See also {@link SchedulerPro.model.EventModel}\n             *\n             * @member {SchedulerPro.data.EventStore} eventStore\n             * @category Models & Stores\n             */\n            /**\n             * An {@link SchedulerPro.data.EventStore} instance or a config object.\n             * @config {SchedulerPro.data.EventStore|EventStoreConfig} eventStore\n             * @category Models & Stores\n             */\n            /**\n             * The {@link SchedulerPro.data.DependencyStore store} holding the dependency information.\n             *\n             * See also {@link SchedulerPro.model.DependencyModel}\n             *\n             * @member {SchedulerPro.data.DependencyStore} dependencyStore\n             * @category Models & Stores\n             */\n            /**\n             * A {@link SchedulerPro.data.DependencyStore} instance or a config object.\n             * @config {SchedulerPro.data.DependencyStore|DependencyStoreConfig} dependencyStore\n             * @category Models & Stores\n             */\n            /**\n             * The {@link SchedulerPro.data.ResourceStore store} holding the resources that can be assigned to the\n             * events in the event store.\n             *\n             * See also {@link SchedulerPro.model.ResourceModel}\n             *\n             * @member {SchedulerPro.data.ResourceStore} resourceStore\n             * @category Models & Stores\n             */\n            /**\n             * A {@link SchedulerPro.data.ResourceStore} instance or a config object.\n             * @config {SchedulerPro.data.ResourceStore|ResourceStoreConfig} resourceStore\n             * @category Models & Stores\n             */\n            /**\n             * The {@link SchedulerPro.data.AssignmentStore store} holding the assignment information.\n             *\n             * See also {@link SchedulerPro.model.AssignmentModel}\n             *\n             * @member {SchedulerPro.data.AssignmentStore} assignmentStore\n             * @category Models & Stores\n             */\n            /**\n             * An {@link SchedulerPro.data.AssignmentStore} instance or a config object.\n             * @config {SchedulerPro.data.AssignmentStore|AssignmentStoreConfig} assignmentStore\n             * @category Models & Stores\n             */\n            /**\n             * The {@link SchedulerPro.data.CalendarManagerStore store} holding the calendar information.\n             *\n             * See also {@link SchedulerPro.model.CalendarModel}\n             * @member {SchedulerPro.data.CalendarManagerStore} calendarManagerStore\n             * @category Models & Stores\n             */\n            /**\n             * A {@link SchedulerPro.data.CalendarManagerStore} instance or a config object.\n             * @config {SchedulerPro.data.CalendarManagerStore|CalendarManagerStoreConfig} calendarManagerStore\n             * @category Models & Stores\n             */\n            //endregion\n            //region Model & store class configs\n            /**\n             * The constructor of the calendar model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the\n             * {@link #property-calendarManagerStore}\n             *\n             * @config {SchedulerPro.model.CalendarModel} [calendarModelClass]\n             * @typings {typeof CalendarModel}\n             * @category Models & Stores\n             */\n            calendarModelClass : CalendarModel,\n            /**\n             * The constructor of the dependency model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-dependencyStore}\n             *\n             * @config {SchedulerPro.model.DependencyModel}\n             * @typings {typeof DependencyModel}\n             * @category Models & Stores\n             */\n            dependencyModelClass : DependencyModel,\n            /**\n             * The constructor of the event model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-eventStore}\n             *\n             * @config {SchedulerPro.model.EventModel}\n             * @typings {typeof EventModel}\n             * @category Models & Stores\n             */\n            eventModelClass : EventModel,\n            /**\n             * The constructor of the assignment model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-assignmentStore}\n             *\n             * @config {SchedulerPro.model.AssignmentModel}\n             * @typings {typeof AssignmentModel}\n             * @category Models & Stores\n             */\n            assignmentModelClass : AssignmentModel,\n            /**\n             * The constructor of the resource model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-resourceStore}\n             *\n             * @config {SchedulerPro.model.ResourceModel}\n             * @typings {typeof ResourceModel}\n             * @category Models & Stores\n             */\n            resourceModelClass : ResourceModel,\n            /**\n             * The constructor to create a calendar store instance with. Should be a class, subclassing the\n             * {@link SchedulerPro.data.CalendarManagerStore}\n             * @config {SchedulerPro.data.CalendarManagerStore|Object}\n             * @typings {typeof CalendarManagerStore|object}\n             * @category Models & Stores\n             */\n            calendarManagerStoreClass : CalendarManagerStore,\n            /**\n             * The constructor to create a dependency store instance with. Should be a class, subclassing the\n             * {@link SchedulerPro.data.DependencyStore}\n             * @config {SchedulerPro.data.DependencyStore|Object}\n             * @typings {typeof DependencyStore|object}\n             * @category Models & Stores\n             */\n            dependencyStoreClass : DependencyStore,\n            /**\n             * The constructor to create an event store instance with. Should be a class, subclassing the\n             * {@link SchedulerPro.data.EventStore}\n             * @config {SchedulerPro.data.EventStore|Object}\n             * @typings {typeof EventStore|object}\n             * @category Models & Stores\n             */\n            eventStoreClass : EventStore,\n            /**\n             * The constructor to create an assignment store instance with. Should be a class, subclassing the\n             * {@link SchedulerPro.data.AssignmentStore}\n             * @config {SchedulerPro.data.AssignmentStore|Object}\n             * @typings {typeof AssignmentStore|object}\n             * @category Models & Stores\n             */\n            assignmentStoreClass : AssignmentStore,\n            /**\n             * The constructor to create a resource store instance with. Should be a class, subclassing the\n             * {@link SchedulerPro.data.ResourceStore}\n             * @config {SchedulerPro.data.ResourceStore|Object}\n             * @typings {typeof ResourceStore|object}\n             * @category Models & Stores\n             */\n            resourceStoreClass : ResourceStore,\n            //endregion\n            /**\n             * The initial data, to fill the {@link #property-calendarManagerStore} with.\n             * Should be an array of {@link SchedulerPro.model.CalendarModel} or it's configuration objects.\n             *\n             * @config {SchedulerPro.model.CalendarModel[]}\n             * @category Legacy inline data\n             */\n            calendarsData : null,\n            /**\n             * Set to `true` to reset the undo/redo queues of the internal {@link Core.data.stm.StateTrackingManager}\n             * after the Project has loaded. Defaults to `false`\n             * @config {Boolean} resetUndoRedoQueuesAfterLoad\n             * @category Advanced\n             */\n            supportShortSyncResponseNote : 'Note: Please consider enabling \"supportShortSyncResponse\" option to allow less detailed sync responses (https://bryntum.com/products/schedulerpro/docs/api/SchedulerPro/model/ProjectModel#config-supportShortSyncResponse)',\n            /**\n             * Enables early rendering in SchedulerPro, by postponing calculations to after the first refresh.\n             *\n             * Requires event data loaded to be pre-normalized to function as intended, since it will be used to render\n             * before engine has normalized the data. Given un-normalized data events will snap into place when\n             * calculations are finished.\n             *\n             * The Gantt chart will be read-only until the initial calculations are finished.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Advanced\n             */\n            delayCalculation : true,\n            calendarManagerStore : {},\n            stmClass : StateTrackingManager\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Get/set {@link #property-calendarManagerStore} data.\n             *\n             * Always returns a {@link SchedulerPro.model.CalendarModel} array but also accepts an array of\n             * its configuration objects as input.\n             *\n             * @member {SchedulerPro.model.CalendarModel[]} calendars\n             * @accepts {SchedulerPro.model.CalendarModel[]|CalendarModelConfig[]}\n             * @category Inline data\n             */\n            /**\n             * Data use to fill the {@link #property-eventStore}. Should be a {@link SchedulerPro.model.CalendarModel}\n             * array or its configuration objects.\n             *\n             * @config {SchedulerPro.model.CalendarModel[]|CalendarModelConfig[]} calendars\n             * @category Inline data\n             */\n            calendars : null\n        };\n    }\n    // For TaskBoard compatibility\n    get taskStore() {\n        return this.eventStore;\n    }\n    //endregion\n    //region Inline data\n    get calendars() {\n        return this.calendarManagerStore.allRecords;\n    }\n    updateCalendars(calendars) {\n        this.calendarManagerStore.data = calendars;\n    }\n    //endregion\n}\nProjectModel._$name = 'ProjectModel';"],
  "mappings": "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",
  "names": ["diffSecond", "date", "diff", "later", "searchElement", "len", "n", "k", "arr", "zeroIsLast", "a", "b", "val", "values", "extent", "cur", "zeroIsLargest", "nextIdx", "i", "min", "max", "zeroVal", "next", "start", "prevIdx", "d", "month", "DMax", "dcMax", "year", "dyMax", "m", "s", "inc", "cache", "wmMax", "wThur", "YThur", "dwFirst", "dwLast", "wyThur", "wyMax", "wyStart", "wyEnd", "constraint", "value", "startDate", "schedDef", "constraints", "constraintsLen", "tickConstraint", "key", "nameParts", "name", "mod", "vals", "ra", "rb", "compareFn", "dir", "nextVal", "maxAttempts", "done", "curVal", "newVal", "result", "compare", "sched", "schedules", "schedulesLen", "exceptions", "exceptionsLen", "j", "getInstances", "count", "endDate", "isRange", "loopCount", "schedStarts", "exceptStarts", "end", "results", "isForward", "lastResult", "rStart", "rEnd", "setNextStarts", "setRangeStarts", "findNext", "updateRangeStarts", "calcRangeOverlap", "updateNextStarts", "maxEndDate", "calcMaxEndDate", "calcEnd", "r", "getStart", "tickStarts", "cleanDate", "schedArr", "startsArr", "rangesArr", "nextStart", "newStart", "minEndDate", "range", "exceptsArr", "fn", "t", "scheduleTimeout", "now", "useLocalTime", "Y", "M", "D", "h", "get", "period", "expr", "hasSeconds", "NAMES", "REPLACEMENTS", "FIELDS", "getValue", "offset", "cloneSchedule", "clone", "field", "add", "addHash", "curSched", "hash", "addWeekday", "except1", "except2", "addRange", "item", "incSplit", "rangeSplit", "parse", "split", "isHash", "itemSorter", "parseExpr", "schedule", "components", "f", "component", "items", "length", "prepareExpr", "prepared", "e", "curArr", "curName", "every", "modifier", "applyMin", "applyMax", "last", "x", "id", "custom", "str", "recur", "pos", "input", "error", "TOKENTYPES", "text", "type", "peek", "expected", "scanTokens", "whiteSpace", "token", "curInput", "scanToken", "scan", "expectedToken", "parseThroughExpr", "tokenType", "parseTokenValue", "checkAndParse", "nums", "parseRanges", "parseEvery", "num", "parseTimePeriod", "parseToken", "parseOnThe", "parseScheduleExpr", "timePeriod", "found", "convertString", "output", "parts", "hour", "later_default", "iterable", "gen1Pending", "gen2Pending", "iterator", "gen1", "gen2", "inBatchesBySize", "batchSize", "runningBatch", "el", "filter", "func", "drop", "howMany", "some", "map", "reduce", "initialAcc", "acc", "uniqueOnly", "seen", "uniqueOnlyBy", "uniqueBy", "takeWhile", "concat", "iterators", "concatIterable", "iteratorsProducer", "ChainedIteratorClass", "iter1", "iter2", "order", "element", "MemoizedIteratorClass", "ChainedIterator", "CI", "elements", "alreadyConsumed", "MemoizedIterator", "MI", "MixinInstanceOfProperty", "MixinStateProperty", "MixinWalkDepthState", "props", "me", "level1", "level2", "topoLevel", "elementsAtLevel", "maxTopoLevel", "baseElements", "mixin", "elementsByTopoLevel", "mixins", "level", "mixin1", "mixin2", "MIXIN_ID", "identity", "ZeroBaseClass", "MixinState", "getMixinState", "mixinLambda", "symbol", "mixinLambdaWrapper", "base", "extendedClass", "isInstanceOfStatic", "baseClass", "constructor", "mixinId", "newId", "self", "baseCls", "minimalClassConstructor", "cls", "nextHash", "wrapperCls", "minimalClass", "Mixin", "isMixinClass", "required", "lastRequirement", "requirements", "requirement", "index", "mixinState", "currentBaseClass", "currentIsSub", "currentIsSuper", "instance", "isInstanceOf", "MixinAny", "Base", "BrowserHelper", "platform", "userAgent", "div", "versionRe", "match", "storage", "paramName", "defaultValue", "search", "re", "nameEq", "cookieItems", "c", "filename", "url", "blob", "_a", "params", "code", "success", "textArea", "searchStrings", "bryntum", "document", "allowNative", "__publicField", "charsToEncode", "entitiesToDecode", "htmlEncodeRe", "htmlDecodeRe", "camelLettersRe", "crlfRe", "escapeRegExpRe", "htmlRe", "idRe", "whiteSpaceRe", "domIdRe", "htmlDecoder", "captured", "htmlEncoder", "hyphenateCamelLetters", "all", "g1", "g2", "separateCamelLetters", "replaceNonIdChar", "ch", "hyphenateCache", "separatedCache", "_StringHelper", "string", "cached", "inString", "replaceValue", "flags", "ret", "mappings", "chars", "prev", "parsed", "object", "replacer", "space", "paths", "pathSeparator", "delimiter", "strings", "buf", "options", "Objects", "v", "contents", "obj", "intendSize", "attr", "StringHelper", "hasOwnProperty", "toString", "isFrozen", "afterRe", "beforeRe", "blendOptions", "typeCache", "emptyObject", "dest", "sources", "source", "merge", "destValue", "handler", "cloned", "keys", "path", "p", "C", "src", "anchor", "delta", "indexMap", "shuffle", "srcVal", "array", "trueType", "property", "VersionHelper", "product", "version", "VH", "otherVersion", "bundleFor", "globalKey", "errorProduct", "capitalized", "version1", "version2", "comparison", "version1Arr", "version2Arr", "isLower", "normalizeArr", "maxLength", "states", "res", "compareArr", "arr1", "arr2", "operator", "invalidAsOfVersion", "message", "_b", "_c", "isTestEnv", "defineProperty", "getOwnPropertyDescriptor", "instancePropertiesSymbol", "configuringSymbol", "lazyConfigValues", "DATE_TYPE", "whitespace", "createClsProps", "Config", "baseCfg", "cfg", "cap", "descriptor", "value1", "value2", "equal", "equalityMethods", "target", "existing", "properties", "lazyValues", "prop", "config", "changer", "updater", "was", "applied", "newValue", "resolvedValue", "initializing", "instanceProperty", "currentValue", "prototype", "oldValue", "metaNew", "metaCurrent", "MetaClass", "create", "getPrototypeOf", "hasOwn", "metaSymbol", "mixinTagSymbol", "originalConfigSymbol", "createdAtSymbol", "lazyConfigsSymbol", "defaultConfigOptions", "emptyFn", "newMeta", "o", "setupNames", "emptyArray", "args", "configs", "shredder", "getter", "thisObject", "thisObj", "propertyPath", "enforceCallability", "inHandler", "inThisObj", "delay", "nullify", "meta", "beforeConfigure", "fullConfig", "isConstructing", "wasConfiguring", "configDone", "lazyConfig", "triggered", "group", "lazyConfigs", "myConfig", "visited", "depth", "Product", "bundlePath", "preamble", "postamble", "app", "baseConfig", "classConfigs", "tag", "names", "proto", "isName", "defineIsProperty", "decl", "setupName", "simple", "classConfigValues", "superMeta", "setDefault", "wasNullify", "declarable", "forked", "hierarchy", "topClass", "detachers", "detacher", "eventer", "bucket", "paramValueRegExp", "parseParams", "paramString", "nameValuePair", "decodedName", "decodedValue", "paramValue", "_AjaxHelper", "payload", "controller", "paramsAdded", "contentType", "bodyClass", "body", "param", "promise", "resolve", "reject", "response", "json", "urlAndParams", "parsedJson", "AjaxHelper", "ArrayHelper", "it", "removed", "comparatorFn", "beforeCheck", "afterCheck", "begin", "middle", "lhs", "rhs", "itemOrArray", "processedItem", "oneBased", "receiver", "useRelativeNaming", "onlyInA", "onlyInB", "inBoth", "bSet", "arrayOrObject", "keyGetter", "valueGetter", "getKey", "dict", "groupKeyGetter", "grouped", "commaSepRe", "decompiledSym", "fnRe1", "fnRe2", "fnRe3", "FunctionHelper", "method", "named", "withReturn", "hook", "origResult", "hookResult", "curried", "args2", "original", "interceptor", "theThis", "sequence", "sequenceResult", "buffer", "extraArgs", "alt", "lastCallTime", "callArgs", "timerId", "invoke", "elapsed", "decompiled", "duration", "easing", "cancel", "iterate", "progress", "delayable", "half", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "e10", "e11", "e12", "s1", "s2", "v1", "v2", "isArray", "specialProperties", "priorityComparator", "Events_default", "Target", "Events", "eventName", "isConfiguring", "oldThisObj", "deprecatedEvents", "deprecatedEvent", "events", "listenerSpec", "expires", "listener", "listeners", "detachable", "destroy", "internalListeners", "oldInternalListeners", "l", "oldListeners", "listenerToRemove", "eventListeners", "listenerToFind", "defaultThisObj", "listenerEntry", "through", "prefix", "transformCase", "relayAllTargets", "preserveInternal", "event", "eventNames", "listenerConfig", "autoDetachers", "oldDestructor", "dispatcher", "destructorName", "$autoDetachers", "_d", "eventsSuspended", "callOnFunctions", "handlerPromises", "fnName", "inhibit", "myProto", "internalAbort", "throttle", "promiseResults", "finalResult", "queue", "suspended", "queued", "_LocaleHelper", "locales", "locale", "toTrim", "remove", "subKey", "nameOrConfig", "localeName", "LocaleHelper", "LocaleManager", "scriptTag", "ignoreError", "localeConfig", "triggerLocaleEvent", "LocaleManagerSingleton", "LocaleManager_default", "ObjectProto", "localeRe", "capturelocaleRe", "classMatchRe", "escape", "txt", "unescape", "Localizable_default", "Localizable", "matches", "classMatch", "localeKey", "localizedValue", "templateData", "localeCls", "clsName", "localeClass", "translate", "translation", "localeClasses", "shouldThrow", "preventThrow", "data", "number", "hasSpecialCase", "suffix", "lastDigit", "En_default", "tempDate", "MS_PER_HOUR", "defValue", "rangeFormatPartRe", "enOrdinalSuffix", "useIntlFormat", "intlFormatterCache", "formatTime", "isShort", "strTime", "getDayDiff", "validConversions", "normalizeDay", "day", "msRegExp", "msReplacer", "splitRegExp", "ordinalSuffix", "formatCache", "formatRedirects", "parserCache", "redirectFormat", "format", "intlConfig", "intlFormatConfigs", "intl", "fmt", "part", "intlCfg", "DEFAULT_YEAR", "DEFAULT_MONTH", "DEFAULT_DAY", "formats", "formatter", "DateHelper", "DH", "formatKeys", "formatRegexp", "isNumber", "numberRegex", "parseMilliseconds", "parsers", "entry", "timeZoneRegEx", "timeZone", "sign", "hours", "minutes", "parserKeys", "parserRegexp", "localeStrRegExp", "normalizedUnits", "withDecimalsDurationRegex", "noDecimalsDurationRegex", "canonicalUnitNames", "canonicalUnitAbbreviations", "deltaUnits", "dateProperties", "parseNumber", "unitMagnitudes", "snapFns", "step", "keyCache", "_DateHelper", "parseFormat", "parser", "curr", "localeParsers", "parserObj", "nestedParsers", "lastItem", "ms", "dateString", "strict", "splitAt", "timeZoneIndex", "splitter", "rest", "chunks", "definition", "def", "invalid", "useUTC", "allNull", "formatMatch", "predefined", "localeFormats", "dates", "which", "amount", "unit", "time", "monthLength", "fraction", "months", "intMonths", "msInMonth", "abbrev", "unitName", "deltaObj", "sep", "precision", "maxUnit", "ignoreLocale", "getUnit", "units", "toUnit", "fromUnit", "stripEscapeRe", "fractional", "dstDiff", "weekStartDay", "inclusive", "seconds", "targetDate", "sourceDate", "jan", "jul", "first", "second", "date1Start", "date1End", "date2Start", "date2End", "unit1", "unit2", "spanStart", "spanEnd", "otherSpanStart", "otherSpanEnd", "fullYear", "increment", "dt", "noNeedToClearTime", "nextDay", "offsetNextDay", "offsetDate", "dateOnly", "monthDesc", "week", "jan01", "dec31", "firstDay", "lastDay", "dayNumber", "weekNumber", "lastWeekOfLastYear", "baseUnit", "acceptEstimate", "plural", "capitalize", "unitLower", "doNotRound", "majorUnit", "minorUnit", "operation", "snapFn", "magnitude", "weekDay", "resultMonths", "tzChange", "allowDecimals", "defaultUnit", "durationRegEx", "unitMatch", "unitOrdinal", "offsetInMinutes", "dayNames", "dayShortNames", "monthNames", "monthShortNames", "monthNamesIndex", "monthShortNamesIndex", "monthName", "monthShortName", "unitNames", "unitAbbreviations", "unitLookup", "unitAbbrRegEx", "abbreviations", "unitNamesCfg", "canonicalAbbreviations", "TimeUnit", "ConstraintType", "SchedulingMode", "DependencyValidationResult", "DependencyType", "DependenciesCalendar", "ProjectType", "Direction", "ConstraintIntervalSide", "MIN_DATE", "MAX_DATE", "isDateFinite", "EdgeInclusion", "CalendarIteratorResult", "CalendarCache", "cacheFilledStartDateN", "cacheFilledEndDateN", "startDateN", "endDateN", "_1", "_2", "scope", "maxRange", "intervalCache", "cacheCursorDate", "cursorDate", "rangeStart", "cycle", "interval", "intervalStartDate", "intervalEndDate", "countFrom", "countTill", "stripDuplicates", "CalendarCacheInterval", "copy", "intervals", "filtered", "interval1", "interval2", "CalendarCacheIntervalMultiple", "_calendar", "calendar", "calendars", "intervalsByCalendar", "unique", "binarySearch", "comparator", "left", "right", "mid", "IndexPosition", "SortedMap", "IntervalCache", "edgeInclusion", "startDateIndex", "extendInterval", "points", "curIndex", "lastUpdatedPoint", "inclusion", "existingInterval", "label", "CalendarCacheMultiple", "calendarCache", "COMBINED_CALENDARS_CACHE", "combineCalendars", "calendar1", "calendar2", "versionsHash", "TimeZoneOffsetInfo", "TimeZoneDate", "asString", "parseStringDate", "toTimeZoneInternal", "tzDateString", "getOffsetUtc", "ticks", "asTicksUtc", "stringDate", "findOffsetDates", "offsetDateCache", "offsets", "startUtcTicks", "incr", "monthIndex", "previousOffset", "currentOffset", "tzTicksUtc", "tzString", "offsetInfo", "_cache", "TimeZoneHelper", "tzDate", "dateArr", "offsetDates", "useOffset", "utcTicks", "utcOffset", "CalendarCacheSingle", "startSchedule", "endSchedule", "wrappingStartDate", "wrappingEndDate", "nextEndDate", "wrappingStartDates", "wrappingEndDates", "startDates", "endDates", "recStartDate", "recEndDate", "existingCacheInterval", "AbstractPartOfProjectGenericMixin", "superProto", "project", "toFixedFix", "fractionDigits", "newNumber", "ObjectHelper", "arrayOfItems", "namedItems", "useIsDeeply", "typeA", "idx", "OH", "aKeys", "bKeys", "aKey", "bKey", "aVal", "bVal", "ignore", "call", "entries", "mapper", "from", "to", "fromType", "toType", "isString", "propertyName", "newGetter", "newSetter", "deep", "newProperty", "existingProperty", "desc", "existingDesc", "fieldName", "baseDesc", "keepNull", "valueType", "asNumber", "digits", "factor", "keyPath", "simpleKey", "topKey", "topValue", "getDescriptor", "InstancePlugin", "client", "keyMap", "plugInto", "plugins", "PluginClass", "assign", "chain", "after", "before", "override", "fnNames", "functions", "intoName", "hookName", "prio", "chains", "hookFn", "functionChainRunner", "intoFn", "returnValue", "disable", "disabled", "Pluggable_default", "pluginClassOrName", "performance", "globalDelays", "includeIntervals", "ignoreTimeouts", "maxDelay", "scopes", "makeInvoker", "wrapFn", "appendArgs", "invoker", "decorateWrapFn", "cancelFn", "Delayable_default", "runOnDestroy", "cancelOutstanding", "timeoutIds", "timeoutMap", "timeoutId", "idOrName", "intervalId", "animationFrameIds", "frameId", "idleCallbackIds", "rafId", "handle", "bufferWrapFn", "rafWrapFn", "idleWrapFn", "throttled", "throttleWrapFn", "statics", "implName", "StateStorage", "Local", "stateProvider", "empty", "getKeys", "Memory", "nullStorage", "storageTypes", "StateProvider", "inst", "nullProvider", "stateful", "pendingSaves", "stateIds", "saved", "stateId", "primitiveRe", "State_default", "state", "responsiveState", "statefulId", "initialConfig", "statefulness", "defaultState", "reload", "statefulLoaded", "full", "pruned", "idCounts", "idTypes", "Identifiable_default", "identifiable", "oldId", "instanceId", "idMap", "STM_PROP", "unrecordedFields", "ModelStm_default", "store", "stm", "wasSet", "silent", "fromRelationUpdate", "isChronoFieldSet", "nonPersistableFields", "shouldRecord", "newData", "oldData", "childRecords", "preResult", "childRecord", "beforeResult", "inserted", "context", "isMove", "defaultTraverseOptions", "fixTraverseOptions", "TreeNode_default", "stores", "inProcessChildren", "MyClass", "child", "sorter", "children", "convertEmptyParentToLeaf", "parent", "mapMeta", "node", "onlyVisible", "task", "parentId", "newParent", "parentIdField", "skipSelf", "goOn", "childOrId", "_e", "_f", "_g", "returnArray", "wasLeaf", "changes", "recordsToInsert", "beforeRecord", "root", "rootStore", "isNoop", "newRecordsCloned", "oldParentIndices", "newRecord", "insertAt", "oldParent", "record", "toSet", "modified", "oldParentId", "oldParentIndex", "allRemovedRecords", "isRemoving", "newChildren", "indexName", "previousSibling", "newRecords", "usePreviousOrder", "movedNodes", "aPrevIndex", "bPrevIndex", "propertyOverrides", "proxyConfig", "ModelLink_default", "useConfig", "proxyRecord", "link", "records", "linked", "ownerSymbol", "typeSplitRe", "Factoryable_default", "replace", "factoryable", "caseless", "registry", "types", "lower", "typeCls", "superClass", "existingInstance", "typeKey", "defaultType", "cleanup", "defaults", "mergeType", "owner", "setup", "transform", "optional", "bases", "DataField", "itemA", "itemB", "force", "dataSource", "current", "ArrayDataField", "BooleanDataField", "DateDataField", "StringDataField", "DurationUnitDataField", "IntegerDataField", "ModelDataField", "NumberDataField", "scale", "ObjectDataField", "StoreDataField", "storeName", "action", "oldPreserveCurrentDataset", "_undefined", "internalProps", "abbreviationFields", "fieldDataTypes", "fieldsOrder", "_Model", "idField", "childrenField", "dataField", "indices", "skipExpose", "forceUseRaw", "rawData", "fieldMap", "overriddenIdField", "isCreating", "other", "fields", "ignoreDefaults", "defaultValues", "useRawData", "processed", "hasSource", "complex", "sourceExists", "useNameForValue", "convert", "converted", "classFields", "fieldsInfo", "raw", "fieldMapProperty", "dataProperty", "fieldDef", "ordinals", "propertiesExposed", "relationName", "relation", "processedData", "laterValues", "initableValues", "relatedRecords", "foreignId", "foreign", "relationCache", "foreignKey", "nullFieldOnRemove", "skipAccessors", "validOnly", "triggerBeforeUpdate", "cmp", "changed", "readOnly", "mapping", "useProp", "complexMapping", "nestedName", "nameOrField", "keySet", "alwaysWriteFields", "recordData", "includeDescendants", "removeFromStoreChanges", "noChanges", "descendants", "rawChanges", "phantomIdField", "remote", "modelClass", "fieldDataSourceMap", "rawChangesSimplePaths", "ownChangesSimplePaths", "idChanged", "propName", "change", "model", "unfilteredChildren", "jsonData", "nameField", "silentUpdates", "batchChanges", "useDeep", "fromRecord", "propertiesAndValues", "unjoinedStores", "isReplacing", "instanceOrId", "className", "superName", "applyConfigs", "Model", "Duration", "useAbbreviation", "abbreviationFn", "nestedValueReducer", "relativeDateUnitRegExp", "relativeDateOperators", "_CollectionFilter", "propertyChanged", "filterBy", "candidate", "candidateValue", "relativeExpr", "todayStart", "tomorrowStart", "oneTimeUnit", "unitStart", "timeUnit", "filters", "CollectionFilter", "IdHelper", "CollectionSorter", "sortFn", "useLocaleSort", "multiplier", "sorters", "tieBreaker", "comp", "return0", "reverseNumericSortFn", "filteredIndicesProperty", "sortEvent", "filterEvent", "keyTypes", "addItemToIndex", "set", "removeItemFromIndex", "doRebuildIndices", "keyProps", "indexCount", "keyProp", "Collection", "filteredValues", "isNewDataset", "replacedValues", "replacedFilteredValues", "ignoreFilters", "allowRemove", "_values", "toRemove", "newInstance", "oldInstance", "beforeItem", "itemIndex", "beforeIndex", "toAdd", "idProperty", "newIds", "replaced", "oldCount", "added", "mutated", "idIndex", "newItem", "existingItem", "existingIndex", "removeIndex", "contiguous", "lastIdx", "removeIndices", "isNumeric", "rep", "member", "existingMember", "gone", "oldDataset", "extraKeys", "indexConfig", "isFiltered", "filteredIndices", "filteredIndex", "dependentIndex", "keysAndOldValues", "oldIndex", "nonPrimitives", "safeIndexKey", "substitute", "Bag", "nth", "matchFn", "StoreBag", "StoreCRUD_default", "recordsInCollapsedGroups", "changedGroupParents", "rec", "groupParent", "removingMultiple", "firstRemoved", "removeChildArgs", "removals", "isLoading", "allRecords", "parentIdMap", "parentIndexField", "append", "insert", "parentNode", "toInsert", "onRecordCreated", "insertBefore", "_records", "removedAtIndex", "filterFn", "auto", "doCommit", "StoreChanges_default", "otherStore", "transformFn", "logChanges", "updated", "altered", "idDataSource", "log", "allAdded", "allAltered", "rootUpdated", "modifiedParents", "toUpdate", "addedRecords", "phantomId", "parentsModifiedByFilter", "removedStash", "removedEntry", "tree", "isGrouped", "filtersFunction", "storeSortFunction", "allValues", "addedValues", "isSorted", "trigger", "groupers", "nodesToInclude", "matchingAdd", "ancestor", "nodesToIncludeByParent", "siblingsToInclude", "sortedLength", "sorted", "updatedMatches", "newMatch", "nonMatchingAdds", "addedChild", "subset", "toInclude", "toIncludeSet", "subsetIndex", "allIndex", "subsetItem", "allItem", "StoreFilter_default", "enable", "collection", "filterConfig", "generatedFilterFunction", "hitsCurrent", "newFilters", "internal", "fieldType", "wasFiltered", "rootNode", "newDataset", "idOrInstance", "apply", "resortActions", "StoreGroup_default", "groupRecords", "generation", "targetRecord", "ignoreFilter", "groupId", "prevRecord", "targetGroupHeader", "groupField", "newGroupValue", "reapplyFilterOnUpdate", "unfilteredGroupRecords", "groupRecord", "updateMap", "startGroupsCollapsed", "toCollapse", "toExpand", "visibleRecordsIds", "isVisible", "matchesFilter", "groupedRecords", "curGroup", "curGroupRecord", "childCount", "addFooter", "footer", "ascending", "performSort", "newGrouper", "grouper", "groupValue", "parentGroupRec", "include", "mapId", "_filteredValues", "groupChildren", "unfilteredGroupChildren", "includeHeaders", "StoreProxy_default", "StoreRelation_default", "reset", "relations", "modelRelationConfig", "foreignStore", "relatedCollectionName", "relatedStore", "dependentStoreConfigs", "dependentConfigs", "existingConfig", "collectionStore", "collectionStores", "useName", "recordOrId", "old", "uncacheId", "relatedId", "oldCache", "uncacheIndex", "relatedRecord", "dependentStore", "dependentRecords", "dependentRecord", "localRecords", "localRecord", "StoreSum_default", "sum", "findInString", "matchFns", "StoreSearch_default", "formatters", "searchAllRecords", "distinct", "usedValues", "fieldValue", "nestedRe", "StoreSort_default", "currentSorters", "currentDir", "curSort", "compareItems", "sorterIndex", "storeLocaleSort", "direction", "nested", "lhsValue", "rhsValue", "returnTrue", "StoreChained_default", "masterStore", "sort", "chainedFilterFn", "doIsArray", "dontIsArray", "isTree", "master", "$handled", "chainedFields", "chainedStore", "StoreState_default", "sortParamName", "filterParamName", "zeroPad", "Wbs", "pattern", "wbs", "globLeft", "globRight", "StoreTree_default", "parentRecord", "isRootLoad", "toAddToUI", "storeInsertionPoint", "wasMoved", "toRemoveFromUI", "unfiltered", "removeUnfiltered", "childrenToRemove", "visible", "inCollapsedBranch", "idOrRecord", "collapse", "exception", "parents", "transformed", "parentTransform", "convertParents", "newRoot", "lastParent", "lastParentPath", "nodeMap", "lv", "rv", "hasParentId", "shouldTransform", "nodes", "WalkHelper", "childrenFn", "walkStack", "inFn", "outFn", "StoreSync_default", "idsToCheck", "toMove", "ids", "threshold", "surpassed", "unsorted", "allFields", "usedIds", "limitedSet", "keepMissingValues", "hitCount", "matchedNodes", "childrenUpdated", "oldChildrenValue", "StoreStm_default", "recordsOrIds", "fromRemoveChild", "wasNotEmpty", "crudManager", "shouldResume", "dataAddRemoveActions", "Store", "converterFn", "newlyPersistable", "allCount", "isAddRemove", "addedCount", "removedCount", "filtersWereReapplied", "sortersWereReapplied", "oldRecord", "lowest", "previousIndex", "collisions", "committable", "addedToBag", "needsRebuild", "processedRecords", "visibleIndex", "ClassDef", "ClassDefEx", "ModelClass", "storeId", "duplicate", "storeClass", "storeModel", "storeData", "oldRoot", "allowNoId", "creatingRecord", "warnGenerated", "isDataset", "idRegister", "oldIdMap", "internalId", "internalIdRegister", "countProcessed", "existingRec", "visibleRecords", "allExceptFilteredOutRecords", "linkedRecord", "primitiveValue", "callback", "initialValue", "topNode", "skipTopNode", "passedFn", "wrap", "skipSpecialRows", "AbstractPartOfProjectStoreMixin", "asyncEvents", "asyncEvent", "AbstractPartOfProjectModelMixin", "joinedProject", "isLeavingProjectStore", "CalendarIntervalMixin", "priority", "CalendarIntervalStore", "UnspecifiedTimeIntervalModel", "CorePartOfProjectGenericMixin", "AbstractCalendarMixin", "CalendarMixin", "durationMs", "finalDate", "adjustDurationToDST", "calendarCacheInterval", "allowNegative", "workingDate", "unspecifiedTimeInterval", "hasWorkingTime", "_intervalStartDate", "_intervalEndDate", "fullyContained", "workingTimeStart", "AbstractHasAssignmentsMixin", "HasAssignmentsMixin", "resource", "assignment", "assignmentCls", "eventStore", "CorePartOfProjectModelMixin", "invalidate", "setData", "isNotNumber", "CIFromSetOrArrayOrValue", "AbstractAssignmentStoreMixin", "AbstractCalendarManagerStoreMixin", "AbstractDependencyStoreMixin", "AbstractEventStoreMixin", "assignmentsForRemoval", "dependenciesForRemoval", "assignmentStore", "dependencyStore", "dependency", "eventRecord", "existingRecord", "AbstractResourceStoreMixin", "resourceRecord", "CoreEventMixin", "keepDuration", "keepStart", "unresolved", "cachedAssignments", "changedStart", "changedEnd", "changedDuration", "calculate", "currentOrProposedStartDate", "currentOrProposedEndDate", "currentOrProposedDuration", "currentOrProposedDurationUnit", "hourDuration", "targetDuration", "CoreResourceMixin", "resourceStore", "skipAccessor", "asId", "CoreAssignmentMixin", "update", "resolved", "CorePartOfProjectStoreMixin", "emptySet", "CoreAssignmentStoreMixin", "modelName", "CoreCalendarMixin", "CoreCalendarManagerStoreMixin", "CoreDependencyMixin", "fromEvent", "toEvent", "CoreDependencyStoreMixin", "CoreHasAssignmentsMixin", "CoreHasDependenciesMixin", "SchedulerCoreEvent", "CoreEventStoreMixin", "CoreResourceStoreMixin", "removing", "throwAbstractMethodCall", "throwInvalidMethodCall", "StateBase", "STATE_PROP", "STORES_PROP", "QUEUE_PROP", "POS_PROP", "TRANSACTION_PROP", "TRANSACTION_TIMER_PROP", "AUTO_RECORD_PROP", "PROPS", "registerStmState", "resolveStmState", "Registry_default", "resetQueue", "undo", "redo", "newProps", "DisabledStateClass", "DisabledState", "DisabledState_default", "ACTION_QUEUE_PROP", "Transaction", "ReadyStateClass", "steps", "curPos", "newPos", "undoneTransactions", "transaction", "redoneTransactions", "title", "ReadyState", "ReadyState_default", "RecordingStateClass", "position", "isInitialUserAction", "parentModel", "childModel", "previousParent", "childModels", "models", "RecordingState", "RecordingState_default", "RestoringStateClass", "RestoringState", "RestoringState_default", "AutoReadyStateClass", "AutoReadyState", "AutoReadyState_default", "AutoRecordingStateClass", "timer", "AutoRecordingState", "AutoRecordingState_default", "ActionBase", "MODEL_PROP", "NEW_DATA_PROP", "OLD_DATA_PROP", "UpdateAction", "PARENT_MODEL_PROP", "CHILD_MODELS_PROP", "INSERT_INDEX_PROP", "CONTEXT_PROP", "InsertChildAction", "ctx", "byFromParent", "newlyAdded", "undoTaskData", "moveRight", "moveLeft", "moveFromAnotherParent", "insertIndex", "RemoveChildAction", "lhsIndex", "rhsIndex", "STORE_PROP", "MODEL_LIST_PROP", "AddAction", "list", "InsertAction", "modelList", "RemoveAction", "ALL_RECORDS_PROP", "RemoveAllAction", "makeModelUpdateAction", "makeModelInsertChildAction", "makeModelRemoveChildAction", "makeStoreModelAddAction", "makeStoreModelInsertAction", "makeStoreModelRemoveAction", "makeStoreRemoveAllAction", "stateTransition", "oldState", "newState", "StateTrackingManager", "reason", "cause", "transactions", "EventsWrapper", "DelayableWrapper", "AbstractProjectMixin", "silenceInitialCommit", "deferId", "SchedulerCoreProjectMixin", "calendarsData", "eventsData", "dependenciesData", "resourcesData", "assignmentsData", "oldStore", "oldEvent", "newEvent", "oldResource", "newResource", "calendarManagerStore", "isInitialCommit", "silenceCommit", "MIN_SMI", "MAX_SMI", "uppercaseFirst", "isAtomicValue", "prototypeValue", "propertyKey", "copySetInto", "sourceSet", "targetSet", "timeout", "matchAll", "regexp", "testStr", "isRegeneratorRuntime", "isGeneratorFunction", "isPromise", "DEBUG", "DEBUG_ONLY", "debug", "warn", "StackEntry", "SourceLinePoint", "parseErrorStack", "sourceLinePoint", "stack", "RequiredProperties", "validateRequiredProperties", "OnCycleAction", "WalkSource", "NOT_VISITED", "VISITED_TOPOLOGICALLY", "WalkContext", "sourceNodes", "walkStep", "toVisit", "visitInfo", "visitedAt", "info", "visitedInfo", "visitedInfo2", "lengthBefore", "cycleInfo", "cycleSource", "cursor", "__decorate", "decorators", "FORMULA_ID", "CalculateProposed", "Formula", "VariableWalkContext", "sourceNode", "formulas", "formula", "FormulasCache", "formulasByOutput", "formulasByInput", "isCyclic", "CycleDescription", "CycleResolution", "resolution", "walkContext", "WalkState", "allResolutions", "res1", "res2", "VariableInputState", "CycleResolutionInput", "variable", "batch", "charCode", "proposedVars", "keepIfPossibleVars", "totalWeight", "isProposed", "weight", "isOverwrittenByFormulas", "usedInFormulas", "formula1", "formula2", "allInputsHasProposed1", "allInputsHasProposed2", "countInputsWithProposedOrKeep1", "countInputsWithProposedOrKeep2", "everyFormulaInputHasValue", "outputVariableAlreadyCalculated", "outputVariableHasPreviousValue", "unvisitedFormulas", "isFinal", "firstFormula", "BreakCurrentStackExecution", "Effect", "ProposedOrPreviousSymbol", "ProposedOrPrevious", "RejectSymbol", "RejectEffect", "Reject", "TransactionSymbol", "GetTransaction", "OwnQuarkSymbol", "OwnQuark", "OwnIdentifierSymbol", "OwnIdentifier", "WriteSymbol", "WriteEffect", "Write", "identifier", "proposedValue", "proposedArgs", "WriteSeveralSymbol", "WriteSeveralEffect", "WriteSeveral", "writes", "PreviousValueOfSymbol", "PreviousValueOfEffect", "PreviousValueOf", "ProposedValueOfSymbol", "ProposedValueOfEffect", "ProposedValueOf", "HasProposedValueSymbol", "HasProposedValueEffect", "HasProposedValue", "HasProposedNotPreviousValueSymbol", "HasProposedNotPreviousValueEffect", "HasProposedNotPreviousValue", "ProposedOrPreviousValueOfSymbol", "ProposedOrPreviousValueOfEffect", "ProposedOrPreviousValueOf", "ProposedArgumentsOfSymbol", "ProposedArgumentsOfEffect", "ProposedArgumentsOf", "UnsafeProposedOrPreviousValueOfSymbol", "UnsafeProposedOrPreviousValueOfEffect", "UnsafeProposedOrPreviousValueOf", "UnsafePreviousValueOfSymbol", "UnsafePreviousValueOfEffect", "UnsafePreviousValueOf", "CycleResolutionInputChrono", "ContextSync", "ContextGen", "CalculationGen", "onEffect", "SynchronousCalculationStarted", "calculationStartedConstant", "CalculationSync", "runGeneratorSyncWithEffect", "effect", "gen", "iteration", "runGeneratorAsyncWithEffect", "effectResolution", "repeat", "EdgeType", "ORIGIN_ID", "Quark", "epoch", "TombStone", "origin", "latestScope", "outgoing", "quark", "latest", "outgoingPast", "toQuark", "revision", "forEach", "latestEntry", "Levels", "Meta", "Identifier", "createdAt", "newQuark", "graph", "IdentifierC", "QuarkSync", "QuarkGen", "Variable", "YIELD", "VariableC", "CalculatedValueSync", "CalculatedValueSyncC", "CalculatedValueGen", "CalculatedValueGenC", "throwUnknownIdentifier", "CLOCK", "Revision", "LeveledQueue", "elLevel", "ComputationCycle", "cycleIdentifiers", "cycleEvents", "TransactionCycleDetectionWalkContext", "visit", "outgoingEntry", "TransactionWalkDepth", "outgoingIdentifier", "EdgeTypeNormal", "EdgeTypePast", "selfDependentIden", "activeEntry", "previousEntry", "dirtyQuark", "existingEntry", "alreadyHadEntry", "isVariable", "toIdentifier", "rejection", "identifierRead", "sameAsPrevious", "previousOutgoingEntry", "ignoreSelfDependency", "requestedEntry", "propagationStartDate", "enableProgressNotifications", "counter", "prevActiveStack", "lastProgressNotificationDate", "startedAtEpoch", "iterationResult", "onReadIdentifierResult", "effectResult", "CommitZero", "Listener", "ChronoGraph", "arg", "isBetweenTopBottom", "lastReferencedRevision", "unreachableRevisions", "isReachable", "newRev", "prevRev", "prevQuark", "revisions", "transactionCommitResult", "activeTransaction", "transactionResult", "rejectedDuringCommit", "prevBaseTentative", "quarkEntry", "calculation", "observerFunc", "onUpdated", "previous", "baseRevision", "nextRevision", "notification", "writeToHigherLevel", "writeInfo", "EntityMeta", "entity", "ReadMode", "Replica", "entities", "FieldIdentifier", "MinimalFieldIdentifierSync", "MinimalFieldIdentifierGen", "MinimalFieldVariable", "EntityIdentifier", "MinimalEntityIdentifier", "Field", "calculationFunction", "isEntityMarker", "Entity", "createEntityOnPrototype", "$", "proxy", "skeleton", "replica", "ownGraph", "removeFrom", "ensureEntityOnPrototype", "writeFunction", "buildProposedFunction", "template", "TemplateClass", "methodName", "getterFnName", "setterFnName", "putterFnName", "generic_field", "fieldConfig", "fieldCls", "cons", "_descriptor", "calculations", "write", "build_proposed", "buildProposed", "ReferenceField", "MinimalReferenceIdentifier", "reference", "ReferenceIdentifier", "locator", "resolver", "q", "prevValue", "ReferenceBucketField", "MinimalReferenceBucketIdentifier", "BucketMutationType", "ReferenceBucketQuark", "MinimalReferenceBucketQuark", "ReferenceBucketIdentifier", "preQuark", "quarkArg", "Schema", "entityDecoratorBody", "isSerializableEqual", "ModelField", "MinimalChronoModelFieldIdentifierGen", "MinimalChronoModelFieldIdentifierSync", "MinimalChronoModelFieldVariable", "ModelReferenceField", "ChronoModelReferenceFieldIdentifier", "ModelBucketField", "ChronoModelReferenceBucketFieldIdentifier", "IsChronoModelSymbol", "ChronoModelFieldIdentifier", "higherLevel", "fieldDefinition", "ChronoModelReferenceFieldQuark", "model_field", "modelFieldConfig", "chronoFieldConfig", "chronoFieldClass", "injectStaticFieldsProperty", "getDecoratedModelFields", "constr", "dateConverter", "ChronoModelMixin", "creatingOccurrence", "DateInterval", "another", "anotherStart", "anotherEnd", "EMPTY_INTERVAL", "newEnd", "collectIntersectionMeta", "copyData", "intersectIntervals", "dateIntervals", "currentInterval", "EffectResolutionResult", "SchedulingIssueEffectResolution", "SchedulingIssueEffect", "ConflictSymbol", "ConflictEffectDescription", "conflict", "ConflictEffect", "intervalsArray", "affectedInterval", "conflictingInterval", "ConflictResolution", "ConstraintIntervalDescription", "ConstraintInterval", "reflectionOf", "side", "ChronoPartOfProjectGenericMixin", "ChronoStoreMixin", "ChronoPartOfProjectStoreMixin", "ChronoPartOfProjectModelMixin", "hasMixin", "EmptyCalendarSymbol", "BaseCalendarMixin", "EmptyCalendarEffectDescription", "EmptyCalendarEffect", "Use24hrsEmptyCalendarEffectResolution", "Use8hrsEmptyCalendarEffectResolution", "BaseEmptyCalendarEffectResolution", "CycleSymbol", "EngineRevision", "EngineTransaction", "failedResolutionValue", "EngineReplica", "CycleEffect", "replacedReplicaResult", "beforeHookResult", "autoCommitStores", "quarkValue", "prevented", "RemoveDependencyCycleEffectResolution", "CycleEffectDescription", "numberOfEvents", "prevEvent", "event1", "event2", "BaseAssignmentMixin", "ChronoAssignmentStoreMixin", "ChronoCalendarManagerStoreMixin", "ChronoDependencyStoreMixin", "Instruction", "StartDateVar", "EndDateVar", "DurationVar", "startDateFormula", "endDateFormula", "durationFormula", "SEDGraphDescription", "SEDForwardCycleResolutionContext", "SEDBackwardCycleResolutionContext", "SEDDispatcher", "instruction", "SEDDispatcherIdentifier", "resolution1", "resolution2", "HasCalendarMixin", "cal", "CanCombineCalendarsMixin", "CanCombineCalendars", "BaseEventMixin", "proposed", "cycleDispatcher", "startDateProposedArgs", "startInstruction", "endDateProposedArgs", "endInstruction", "directionValue", "durationProposedArgs", "durationInstruction", "skippingRes", "durationUnit", "formulaId", "baseDate", "_value", "dispatch", "effectiveDurationToUse", "durationResolution", "manuallyScheduled", "BaseHasAssignmentsMixin", "HasDependenciesMixin", "dep", "SchedulerBasicEvent", "ChronoEventStoreMixin", "ChronoEventTreeStoreMixin", "BaseResourceMixin", "ChronoResourceStoreMixin", "DurationConverterMixin", "hoursPerDay", "daysPerWeek", "daysPerMonth", "unitsInMs", "BaseDependencyMixin", "ChronoAbstractProjectMixin", "enterRecords", "schedulingIssue", "oldValues", "oldCalculations", "projectCalculations", "HasSubEventsMixin", "hasSubEvents", "timestamp", "HasChildrenMixin", "SchedulerBasicProjectMixin", "wasDisabled", "_h", "stmClass", "recordsToDrop", "oldReplica", "skipRoot", "oldEventStore", "oldDependencyStore", "oldResourceStore", "oldAssignmentStore", "oldCalendarManagerStore", "changerFn", "stmInitiallyDisabled", "stmInitiallyAutoRecord", "calculateEffectiveStartDateConstraintInterval", "startDateIntervalIntersection", "endDateIntervalIntersection", "reflectedIntervals", "originInterval", "calculateEffectiveEndDateConstraintInterval", "EarlyLateLazyness", "ConstrainedEarlyEventMixin", "isStartDate", "startDateConstraintIntervals", "endDateConstraintIntervals", "subEventsIterator", "childEvent", "childDate", "effectiveInterval", "startDateIntervals", "endDateIntervals", "earlyStartDateConstraintIntervals", "earlyEndDateConstraintIntervals", "autoStartDate", "baseSchedulingStartDate", "earlyEffectiveStartDateInterval", "autoEndDate", "baseSchedulingEndDate", "earlyEffectiveEndDateInterval", "HasDateConstraintMixin", "HasDateConstraint", "constrainType", "constraintType", "constraintDate", "ignorePinningConstraint", "dateConstraintIntervalClass", "RemoveDateConstraintConflictResolution", "DateConstraintIntervalDescription", "tpl", "DateConstraintInterval", "constraintDateQuark", "constraintTypeQuark", "ScheduledByDependenciesEarlyEventMixin", "dependencyConstraintIntervalClass", "predecessor", "predecessorDate", "lag", "lagUnit", "BaseDependencyResolution", "RemoveDependencyResolution", "DeactivateDependencyResolution", "DependencyConstraintIntervalDescription", "DependencyConstraintInterval", "fromEventQuark", "toEventQuark", "lagQuark", "lagUnitQuark", "typeQuark", "SchedulerProAssignmentMixin", "percentDone", "actualDate", "assignmentsByCalendar", "SchedulerProDependencyMixin", "dependenciesCalendar", "HasPercentDoneMixin", "childEvents", "autoCalculatePercentDoneForParentTasks", "summaryData", "summary", "childSummaryData", "durationInMs", "SchedulerProHasAssignmentsMixin", "assignments", "effectiveCalendarsCombination", "ignoreResourceCalendar", "calendarCacheIntervalMultiple", "calendarsStatus", "workCalendars", "resourceCalendar", "iteratorOptions", "skipRes", "durationMS", "resultN", "leftDuration", "intervalStart", "intervalEnd", "intervalStartN", "intervalEndN", "intervalDuration", "MasterStartDateVar", "MasterEndDateVar", "MasterDurationVar", "MasterTotalDurationVar", "StartOffsetVar", "EndOffsetVar", "durationByOffsetsFormula", "startDateByMasterStartAndStartOffsetFormula", "endDateByMasterStartAndEndOffsetFormula", "startOffsetByMasterStartAndStartDateFormula", "endOffsetByMasterStartAndEndDateFormula", "startOffsetByEndOffsetAndDurationFormula", "endOffsetByStartOffsetAndDurationFormula", "endOffsetByMasterTotalDurationAndStartOffsetFormula", "endOffsetByMasterDurationAndStartOffsetFormula", "durationByMasterEndDateFormula", "segmentCycleDescription", "segmentCycleResolution", "SegmentSEDDispatcherIdentifier", "SchedulerProEventSegment", "shift", "segment", "masterStartDate", "masterEndDateArgs", "masterDispatcher", "masterDuration", "masterDurationUnit", "startOffset", "nextSegment", "masterDurationMs", "segments", "segmentStartOffset", "segmentDurationMs", "masterEndDate", "masterTotalDurationMs", "endOffset", "rawDate", "masterPercentDone", "completeMasterDurationMs", "previousSegment", "SegmentsVar", "segmentsConverter", "startDateByEndDateAndSegmentsFormula", "endDateByStartDateAndSegmentsFormula", "durationByStartDateAndEndDateAndSegmentsFormula", "SEDSGGraphDescription", "SEDSGForwardCycleResolution", "SEDSGBackwardCycleResolution", "SEDSGDispatcherIdentifier", "compareSegmentsArray", "compareSegments", "aStart", "bStart", "aEnd", "bEnd", "SplitEventMixin", "proposedSegments", "startDateProposed", "endDateProposed", "durationProposed", "oldSegmentsQuarkValue", "oldSegments", "oldSegmentsSet", "newSegments", "newSegmentsSet", "newSegment", "previousValue", "hasChanges", "prevEndOffset", "previousSegmentStartOffset", "previousSegmentEndOffset", "toWrite", "spliceIndex", "segmentStartDate", "segmentEndDate", "segmentsSnapshot", "lastSegmentEndOffset", "ignoreSegments", "currentSegment", "currentOffsetMs", "currentSegmentDurationMs", "currentSegmentEndOffset", "intervalStartOffset", "intervalEndOffset", "callStartOffset", "callEndOffset", "callStartDate", "callEndDate", "isSegmented", "segmentToSplit", "segmentToSplitIndex", "splitTarget", "splitTargetStart", "splitTargetDuration", "splitTargetDurationUnit", "prevSegmentDuration", "nextSegmentDuration", "lagInMs", "nextSegmentStartOffset", "segment1", "segment2", "tmp", "segmentData", "seg", "HasEffortMixin", "effort", "totalEffortMs", "childEventEffortUnit", "totalUnitsByCalendar", "intervalUnits", "workingCalendar", "_assignment", "effortUnit", "effortMS", "collectedEffort", "leftEffort", "hasUnits", "intervalEffort", "EffortVar", "UnitsVar", "effortFormula", "unitsFormula", "endDateByEffortFormula", "startDateByEffortFormula", "SEDWUDispatcher", "SEDWUDispatcherIdentifier", "HasSchedulingModeMixin", "schedulingMode", "effortResolution", "proposedOrPreviousStartDate", "proposedOrPreviousEndDate", "startDateResolution", "endDateResolution", "effortDriven", "fixedDurationSEDWUGraphDescription", "fixedDurationAndEffortSEDWUGraphDescription", "fixedDurationSEDWUForwardNonEffortDriven", "fixedDurationSEDWUForwardEffortDriven", "fixedDurationSEDWUBackwardNonEffortDriven", "fixedDurationSEDWUBackwardEffortDriven", "FixedDurationMixin", "SchedulerProEvent", "ResourceAllocationEventRangeCalendarIntervalMixin", "ResourceAllocationEventRangeCalendarIntervalStore", "ResourceAllocationEventRangeCalendar", "BaseAllocationInterval", "AssignmentAllocationInterval", "ResourceAllocationInterval", "BaseAllocationInfo", "ResourceAllocationInfo", "includeInactiveEvents", "inactive", "total", "ticksCalendar", "eventRanges", "assignmentTicksData", "byAssignments", "hasIgnoreResourceCalendarEvent", "eventCalendar", "eventRangesCalendar", "ticksData", "tick", "tickData", "assignmentTickData", "weightedUnitsSum", "weightsSum", "iterationOptions", "ticksTotalDuration", "intervalData", "isWorkingCalendar", "tickAssignments", "tickAssignmentIntervals", "intervalHasAssignments", "workingStartDate", "workingEndDate", "assignmentInterval", "assignmentEffort", "SchedulerProResourceMixin", "observer", "includeNonWorkingIntervals", "SchedulerProProjectMixin", "SchedulerProCycleEffect", "ignoreDependency", "ingoredDependencies", "dependencyClass", "branch", "ignoreDependencies", "DeactivateDependencyCycleEffectResolution", "dependencies", "invalidDependencies", "valueSymbol", "lengthSymbol", "DomClassList", "as", "classes", "returnEmpty", "asArray", "asObject", "otherClasses", "classList", "temp", "flag", "processParamEntry", "paramArray", "immediatePromise", "prependZeros", "dateToString", "AjaxStore", "pageParamName", "pageStartParamName", "paramObjects", "hasParamsInUrl", "queryString", "caseSensitive", "readUrl", "successFn", "page", "remoteTotal", "requestedPage", "responseOrError", "pageParam", "allPromises", "commitState", "dataToSend", "formData", "modifications", "returnedData", "isUpdating", "recData", "DomDataStore", "_domData", "_ChangeLogEntity", "ChangeLogEntity", "GridRowModel", "AbstractCrudManagerValidation_default", "storeInfo", "responded", "expectedResponse", "messages", "mandatoryStores", "requested", "missingRows", "missingRemoved", "respondedRows", "respondedRemoved", "showSupportShortSyncResponseNote", "row", "missingIds", "missingUpdatedRows", "requestDesc", "request", "warnings", "AbstractCrudManagerError", "CrudManagerRequestError", "storeSortFn", "sortProperty", "storeLoadSortFn", "storeSyncSortFn", "AbstractCrudManagerMixin_default", "storeDesc", "storeIdProperty", "crudStoresIndex", "storeDescriptor", "fromStore", "foundStore", "sequenceKeys", "doSync", "responseText", "fetchOptions", "requestType", "skipChangeCheck", "eventParams", "pack", "optionsCopy", "opts", "pageSize", "rows", "load", "phantomParentIdField", "subStoreFields", "subStore", "writeAllFields", "storeResponse", "storePack", "requestUpdated", "requestRemoved", "respondedIds", "responseRecord", "extraLogEntries", "updateData", "recordRequest", "extraLogInfo", "logEntry", "storeLog", "rawResponse", "requestId", "signal", "usesSingleAssignment", "sync", "AbstractCrudManager", "dataName", "AjaxTransport_default", "AjaxTransport", "requestPromise", "packCfg", "transportConfig", "requestConfig", "ajaxPromise", "resultPromise", "performSend", "cancelled", "beforeSendResult", "JsonEncoder_default", "requestData", "dateFieldsToConvert", "TimeZonedDatesMixin_default", "TimeSpan", "metaModified", "convertFields", "hasDuration", "calcEndDate", "calcStartDate", "endDateMS", "startDateMS", "fieldOrClone", "u", "timeSpan", "myStart", "myEnd", "splitPoint", "fullDuration", "oldDuration", "cloneDuration", "ownNewDuration", "unitsChanged", "clonedData", "icsEventConfig", "startEnd", "icsWrapConfig", "eventConfig", "icsItems", "eventItems", "dayParseRegExp", "days", "RecurrenceDayRuleEncoder", "rawDay", "parsedDay", "rawDays", "frequencyToUnitRe", "frequencyToUnit", "frequency", "isFirst", "captureLastOccurrence", "lastOccurrenceDate", "AbstractRecurrenceIterator", "recurrence", "until", "timeSpanStart", "earliestVisibleDate", "borderDate", "positions", "datesLength", "startOnly", "occurrenceDate", "occurenceDate", "occurrenceDateMS", "earliestVisibleDateMS", "DailyRecurrenceIterator", "spansStart", "delayInIntervals", "inView", "WeeklyRecurrenceIterator", "timeSpanStartMS", "startHours", "startMinutes", "startSeconds", "startMS", "weekDays", "weekStartDate", "MonthlyRecurrenceIterator", "dayNum", "daysInMonth", "hasPositions", "processedDate", "monthDays", "weekDayPosition", "monthStartDate", "monthEndDate", "till", "sortedMonthDates", "YearlyRecurrenceIterator", "yearStartDate", "yearEndDate", "recurrenceIterators", "convertStringOfIntegerItemsValue", "convertStringOfItemsValue", "isEqualAsString", "convertInteger", "RecurrenceModel", "rule", "timeSpanStartDate", "convertExceptionDatesValue", "dateFormat", "serializeExceptionDatesValue", "RecurringTimeSpan_default", "recurringTimeSpan", "recurrenceEnd", "recurrenceRule", "occurrence", "dateOrTimeSpan", "dateKey", "exceptionDates", "occurrenceMap", "globalOccurrences", "occurrenceKey", "onStartDate", "occurrenceEndDate", "occurrenceIndex", "newExceptionDate", "ResourceTimeRangeModel", "RecurringTimeSpansMixin_default", "recurringEvents", "replacedCount", "isRecurrenceRelatedFieldChange", "ResourceTimeRangeStore", "resourceTimeRange", "span1", "span2", "PartOfProject_default", "AssignmentModelMixin_default", "eventIdField", "resourceIdField", "eventField", "resourceField", "eventId", "resourceId", "eventKey", "resourceKey", "EngineMixin", "AssignmentModel", "AssignmentStoreMixin_default", "newAssignments", "originalAssignment", "occurrenceAssignment", "occurrenceMeta", "fnSet", "filterFnSet", "mapResult", "resources", "assignmentSetupFn", "removeExistingAssignments", "existingAssignment", "assignmentsToRemove", "AssignmentStore", "EventStoreMixin_default", "earliest", "excludeEvent", "allEvents", "eventToRemove", "newResourceId", "notRecurring", "GetEventsMixin_default", "includeOccurrences", "allowPartial", "onlyAssigned", "dateMap", "dayTime", "getDateIndex", "lastDateRange", "passedFilter", "eventStartDate", "eventEndDate", "isMilestone", "newDateRange", "dateFilter", "storeFilterFn", "candidateEvents", "dateIndex", "eventSet", "coincidingEvents", "baseEventFilter", "occurrences", "lastDate", "lastIntersectingDate", "MILLIS_PER_MINUTE", "MILLIS_PER_HOUR", "MILLIS_PER_DAY", "timeRe", "DayTime", "timeOfDay", "startShift", "startTime", "endTime", "timeStart", "timeEnd", "millis", "date0", "date1", "dayStart", "startOfDay", "start1", "start2", "indexNameMap", "indexProps", "EventDayIndex", "dateMS", "returnKey", "outgoingEvent", "users", "MIDNIGHT", "DayIndexMixin_default", "dayIndex", "dayIndices", "SharedEventStoreMixin_default", "eventRecords", "assignmentsToAdd", "assignmentRecord", "RecurringEventsMixin_default", "oneDayMS", "EventModelMixin_default", "newResourceIds", "existingResourceIds", "wasPersistable", "fromApplyValue", "removingResource", "oldResourceId", "eventStartMidnight", "EventModel", "EventStore", "ResourceStoreMixin_default", "ResourceModelMixin_default", "firstInitial", "lastInitial", "ResourceModel", "ResourceStore", "canonicalDependencyTypes", "DependencyBaseModel", "Type", "highlighted", "rawValue", "DependencyModel", "fromSide", "toSide", "rtl", "startSide", "endSide", "DependencyStoreMixin_default", "reduceFn", "flat", "depsGetterFn", "evt", "sourceEvent", "targetEvent", "dependencyOrFromId", "toId", "fromId", "DependencyStore", "ProjectCrudManager_default", "startDateField", "endDateField", "propagationFlag", "loud", "stmDisabled", "changesMap", "ProjectModelCommon_default", "timeRanges", "ProjectModelTimeZoneMixin_default", "isDataSet", "$originalProcessRecord", "stmAutoRecord", "bl", "oldTimeZone", "ProjectModelMixin_default", "inlineData", "resourceTimeRanges", "ProjectCurrentConfig_default", "storeState", "ModelPersistencyManager", "newEventStore", "newResourceStore", "newAssignmentStore", "newDependencyStore", "recordsToCreate", "ProjectModel", "throwIfNotTheSameStore", "newStore", "CalendarIntervalModel", "CalendarModel", "CalendarManagerStore", "PercentDoneMixin_default", "EventSegmentModel", "forward", "timeDiff", "wrapStartDate", "wrapEndDate", "isObject", "assigned", "projectChanges", "willChange", "ProjectChangeHandlerMixin_default", "storeChanges", "changedRows", "EventUpdateAction", "oldDataSegments", "newDataSegments", "newDataIndex"]
}
